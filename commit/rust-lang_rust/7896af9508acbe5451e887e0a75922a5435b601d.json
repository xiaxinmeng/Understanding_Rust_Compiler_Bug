{"sha": "7896af9508acbe5451e887e0a75922a5435b601d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4OTZhZjk1MDhhY2JlNTQ1MWU4ODdlMGE3NTkyMmE1NDM1YjYwMWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-15T06:36:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-15T06:36:22Z"}, "message": "Auto merge of #54177 - nnethercote:streamline-bit-stuff, r=Mark-Simulacrum\n\nRemove bitslice.rs\n\nAs the comment in `bitslice.rs` says:\n\n> FIXME: merge with `bitvec`", "tree": {"sha": "752150611efdeb2d6ba65d51f918405d5aed7699", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/752150611efdeb2d6ba65d51f918405d5aed7699"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7896af9508acbe5451e887e0a75922a5435b601d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7896af9508acbe5451e887e0a75922a5435b601d", "html_url": "https://github.com/rust-lang/rust/commit/7896af9508acbe5451e887e0a75922a5435b601d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7896af9508acbe5451e887e0a75922a5435b601d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "html_url": "https://github.com/rust-lang/rust/commit/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de"}, {"sha": "56be2afec56c6c958b3185a4ce8307d13fb8bf2f", "url": "https://api.github.com/repos/rust-lang/rust/commits/56be2afec56c6c958b3185a4ce8307d13fb8bf2f", "html_url": "https://github.com/rust-lang/rust/commit/56be2afec56c6c958b3185a4ce8307d13fb8bf2f"}], "stats": {"total": 668, "additions": 271, "deletions": 397}, "files": [{"sha": "a63033c436528bc866e32f5877f17f86be911a32", "filename": "src/librustc_data_structures/bitslice.rs", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc_data_structures%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de/src%2Flibrustc_data_structures%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitslice.rs?ref=ed45f9cbf48d67ea4ca36d71b7c28c4768fb36de", "patch": "@@ -1,146 +0,0 @@\n-// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// FIXME: merge with `bitvec`\n-\n-use std::mem;\n-\n-pub type Word = usize;\n-\n-/// `BitSlice` provides helper methods for treating a `[Word]`\n-/// as a bitvector.\n-pub trait BitSlice {\n-    fn clear_bit(&mut self, idx: usize) -> bool;\n-    fn set_bit(&mut self, idx: usize) -> bool;\n-    fn get_bit(&self, idx: usize) -> bool;\n-}\n-\n-impl BitSlice for [Word] {\n-    /// Clears bit at `idx` to 0; returns true iff this changed `self.`\n-    #[inline]\n-    fn clear_bit(&mut self, idx: usize) -> bool {\n-        let words = self;\n-        debug!(\"clear_bit: words={} idx={}\",\n-               bits_to_string(words, words.len() * mem::size_of::<Word>() * 8), idx);\n-        let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n-        debug!(\"word={} bit_in_word={} bit_mask=0x{:x}\", word, bit_in_word, bit_mask);\n-        let oldv = words[word];\n-        let newv = oldv & !bit_mask;\n-        words[word] = newv;\n-        oldv != newv\n-    }\n-\n-    /// Sets bit at `idx` to 1; returns true iff this changed `self.`\n-    #[inline]\n-    fn set_bit(&mut self, idx: usize) -> bool {\n-        let words = self;\n-        debug!(\"set_bit: words={} idx={}\",\n-               bits_to_string(words, words.len() * mem::size_of::<Word>() * 8), idx);\n-        let BitLookup { word, bit_in_word, bit_mask } = bit_lookup(idx);\n-        debug!(\"word={} bit_in_word={} bit_mask={}\", word, bit_in_word, bit_mask);\n-        let oldv = words[word];\n-        let newv = oldv | bit_mask;\n-        words[word] = newv;\n-        oldv != newv\n-    }\n-\n-    /// Extracts value of bit at `idx` in `self`.\n-    #[inline]\n-    fn get_bit(&self, idx: usize) -> bool {\n-        let words = self;\n-        let BitLookup { word, bit_mask, .. } = bit_lookup(idx);\n-        (words[word] & bit_mask) != 0\n-    }\n-}\n-\n-struct BitLookup {\n-    /// An index of the word holding the bit in original `[Word]` of query.\n-    word: usize,\n-    /// Index of the particular bit within the word holding the bit.\n-    bit_in_word: usize,\n-    /// Word with single 1-bit set corresponding to where the bit is located.\n-    bit_mask: Word,\n-}\n-\n-#[inline]\n-fn bit_lookup(bit: usize) -> BitLookup {\n-    let word_bits = mem::size_of::<Word>() * 8;\n-    let word = bit / word_bits;\n-    let bit_in_word = bit % word_bits;\n-    let bit_mask = 1 << bit_in_word;\n-    BitLookup { word, bit_in_word, bit_mask }\n-}\n-\n-pub fn bits_to_string(words: &[Word], bits: usize) -> String {\n-    let mut result = String::new();\n-    let mut sep = '[';\n-\n-    // Note: this is a little endian printout of bytes.\n-\n-    // i tracks how many bits we have printed so far.\n-    let mut i = 0;\n-    for &word in words.iter() {\n-        let mut v = word;\n-        for _ in 0..mem::size_of::<Word>() { // for each byte in `v`:\n-            let remain = bits - i;\n-            // If less than a byte remains, then mask just that many bits.\n-            let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n-            assert!(mask <= 0xFF);\n-            let byte = v & mask;\n-\n-            result.push_str(&format!(\"{}{:02x}\", sep, byte));\n-\n-            if remain <= 8 { break; }\n-            v >>= 8;\n-            i += 8;\n-            sep = '-';\n-        }\n-        sep = '|';\n-    }\n-    result.push(']');\n-\n-    result\n-}\n-\n-#[inline]\n-pub fn bitwise<Op:BitwiseOperator>(out_vec: &mut [Word],\n-                                   in_vec: &[Word],\n-                                   op: &Op) -> bool {\n-    assert_eq!(out_vec.len(), in_vec.len());\n-    let mut changed = false;\n-    for (out_elt, in_elt) in out_vec.iter_mut().zip(in_vec) {\n-        let old_val = *out_elt;\n-        let new_val = op.join(old_val, *in_elt);\n-        *out_elt = new_val;\n-        changed |= old_val != new_val;\n-    }\n-    changed\n-}\n-\n-pub trait BitwiseOperator {\n-    /// Applies some bit-operation pointwise to each of the bits in the two inputs.\n-    fn join(&self, pred1: Word, pred2: Word) -> Word;\n-}\n-\n-pub struct Intersect;\n-impl BitwiseOperator for Intersect {\n-    #[inline]\n-    fn join(&self, a: Word, b: Word) -> Word { a & b }\n-}\n-pub struct Union;\n-impl BitwiseOperator for Union {\n-    #[inline]\n-    fn join(&self, a: Word, b: Word) -> Word { a | b }\n-}\n-pub struct Subtract;\n-impl BitwiseOperator for Subtract {\n-    #[inline]\n-    fn join(&self, a: Word, b: Word) -> Word { a & !b }\n-}"}, {"sha": "52cc347f8e771c1dbfe4ecaf4d0554b5552615af", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 236, "deletions": 76, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=7896af9508acbe5451e887e0a75922a5435b601d", "patch": "@@ -9,86 +9,91 @@\n // except according to those terms.\n \n use indexed_vec::{Idx, IndexVec};\n+use rustc_serialize;\n+use std::iter;\n use std::marker::PhantomData;\n+use std::slice;\n \n-type Word = u128;\n-const WORD_BITS: usize = 128;\n+pub type Word = u64;\n+pub const WORD_BYTES: usize = ::std::mem::size_of::<Word>();\n+pub const WORD_BITS: usize = WORD_BYTES * 8;\n \n /// A very simple BitArray type.\n ///\n /// It does not support resizing after creation; use `BitVector` for that.\n-#[derive(Clone, Debug, PartialEq)]\n+#[derive(Clone, Debug, Eq, PartialEq)]\n pub struct BitArray<C: Idx> {\n     data: Vec<Word>,\n     marker: PhantomData<C>,\n }\n \n-#[derive(Clone, Debug, PartialEq)]\n-pub struct BitVector<C: Idx> {\n-    data: BitArray<C>,\n-}\n-\n-impl<C: Idx> BitVector<C> {\n-    pub fn grow(&mut self, num_bits: C) {\n-        self.data.grow(num_bits)\n-    }\n-\n-    pub fn new() -> BitVector<C> {\n-        BitVector {\n-            data: BitArray::new(0),\n-        }\n-    }\n-\n-    pub fn with_capacity(bits: usize) -> BitVector<C> {\n-        BitVector {\n-            data: BitArray::new(bits),\n-        }\n-    }\n-\n-    /// Returns true if the bit has changed.\n-    #[inline]\n-    pub fn insert(&mut self, bit: C) -> bool {\n-        self.grow(bit);\n-        self.data.insert(bit)\n-    }\n-\n-    #[inline]\n-    pub fn contains(&self, bit: C) -> bool {\n-        let (word, mask) = word_mask(bit);\n-        if let Some(word) = self.data.data.get(word) {\n-            (word & mask) != 0\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n impl<C: Idx> BitArray<C> {\n     // Do not make this method public, instead switch your use case to BitVector.\n     #[inline]\n     fn grow(&mut self, num_bits: C) {\n-        let num_words = words(num_bits);\n+        let num_words = num_words(num_bits);\n         if self.data.len() <= num_words {\n             self.data.resize(num_words + 1, 0)\n         }\n     }\n \n     #[inline]\n     pub fn new(num_bits: usize) -> BitArray<C> {\n-        let num_words = words(num_bits);\n+        BitArray::new_empty(num_bits)\n+    }\n+\n+    #[inline]\n+    pub fn new_empty(num_bits: usize) -> BitArray<C> {\n+        let num_words = num_words(num_bits);\n         BitArray {\n             data: vec![0; num_words],\n             marker: PhantomData,\n         }\n     }\n \n+    #[inline]\n+    pub fn new_filled(num_bits: usize) -> BitArray<C> {\n+        let num_words = num_words(num_bits);\n+        let mut result = BitArray {\n+            data: vec![!0; num_words],\n+            marker: PhantomData,\n+        };\n+        result.clear_above(num_bits);\n+        result\n+    }\n+\n     #[inline]\n     pub fn clear(&mut self) {\n         for p in &mut self.data {\n             *p = 0;\n         }\n     }\n \n+    /// Sets all elements up to `num_bits`.\n+    pub fn set_up_to(&mut self, num_bits: usize) {\n+        for p in &mut self.data {\n+            *p = !0;\n+        }\n+        self.clear_above(num_bits);\n+    }\n+\n+    /// Clear all elements above `num_bits`.\n+    fn clear_above(&mut self, num_bits: usize) {\n+        let first_clear_block = num_bits / WORD_BITS;\n+\n+        if first_clear_block < self.data.len() {\n+            // Within `first_clear_block`, the `num_bits % WORD_BITS` LSBs\n+            // should remain.\n+            let mask = (1 << (num_bits % WORD_BITS)) - 1;\n+            self.data[first_clear_block] &= mask;\n+\n+            // All the blocks above `first_clear_block` are fully cleared.\n+            for b in &mut self.data[first_clear_block + 1..] {\n+                *b = 0;\n+            }\n+        }\n+    }\n+\n     pub fn count(&self) -> usize {\n         self.data.iter().map(|e| e.count_ones() as usize).sum()\n     }\n@@ -128,7 +133,7 @@ impl<C: Idx> BitArray<C> {\n     /// Sets all bits to true.\n     pub fn insert_all(&mut self) {\n         for data in &mut self.data {\n-            *data = u128::max_value();\n+            *data = !0;\n         }\n     }\n \n@@ -157,52 +162,168 @@ impl<C: Idx> BitArray<C> {\n         changed\n     }\n \n+    pub fn words(&self) -> &[Word] {\n+        &self.data\n+    }\n+\n+    pub fn words_mut(&mut self) -> &mut [Word] {\n+        &mut self.data\n+    }\n+\n     /// Iterates over indexes of set bits in a sorted order\n     #[inline]\n     pub fn iter<'a>(&'a self) -> BitIter<'a, C> {\n         BitIter {\n-            iter: self.data.iter(),\n-            current: 0,\n-            idx: 0,\n+            cur: None,\n+            iter: self.data.iter().enumerate(),\n             marker: PhantomData,\n         }\n     }\n }\n \n+impl<T: Idx> rustc_serialize::Encodable for BitArray<T> {\n+    fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n+        self.data.encode(encoder)\n+    }\n+}\n+\n+impl<T: Idx> rustc_serialize::Decodable for BitArray<T> {\n+    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<BitArray<T>, D::Error> {\n+        let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n+        Ok(BitArray {\n+            data: words,\n+            marker: PhantomData,\n+        })\n+    }\n+}\n+\n pub struct BitIter<'a, C: Idx> {\n-    iter: ::std::slice::Iter<'a, Word>,\n-    current: Word,\n-    idx: usize,\n+    cur: Option<(Word, usize)>,\n+    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n     marker: PhantomData<C>\n }\n \n impl<'a, C: Idx> Iterator for BitIter<'a, C> {\n     type Item = C;\n     fn next(&mut self) -> Option<C> {\n-        while self.current == 0 {\n-            self.current = if let Some(&i) = self.iter.next() {\n-                if i == 0 {\n-                    self.idx += WORD_BITS;\n-                    continue;\n-                } else {\n-                    self.idx = words(self.idx) * WORD_BITS;\n-                    i\n+        loop {\n+            if let Some((ref mut word, offset)) = self.cur {\n+                let bit_pos = word.trailing_zeros() as usize;\n+                if bit_pos != WORD_BITS {\n+                    let bit = 1 << bit_pos;\n+                    *word ^= bit;\n+                    return Some(C::new(bit_pos + offset))\n                 }\n-            } else {\n-                return None;\n             }\n+\n+            let (i, word) = self.iter.next()?;\n+            self.cur = Some((*word, WORD_BITS * i));\n         }\n-        let offset = self.current.trailing_zeros() as usize;\n-        self.current >>= offset;\n-        self.current >>= 1; // shift otherwise overflows for 0b1000_0000_\u2026_0000\n-        self.idx += offset + 1;\n+    }\n+}\n+\n+pub trait BitwiseOperator {\n+    /// Applies some bit-operation pointwise to each of the bits in the two inputs.\n+    fn join(&self, pred1: Word, pred2: Word) -> Word;\n+}\n+\n+#[inline]\n+pub fn bitwise<Op: BitwiseOperator>(out_vec: &mut [Word], in_vec: &[Word], op: &Op) -> bool\n+{\n+    assert_eq!(out_vec.len(), in_vec.len());\n+    let mut changed = false;\n+    for (out_elem, in_elem) in out_vec.iter_mut().zip(in_vec.iter()) {\n+        let old_val = *out_elem;\n+        let new_val = op.join(old_val, *in_elem);\n+        *out_elem = new_val;\n+        changed |= old_val != new_val;\n+    }\n+    changed\n+}\n+\n+pub struct Intersect;\n+impl BitwiseOperator for Intersect {\n+    #[inline]\n+    fn join(&self, a: Word, b: Word) -> Word { a & b }\n+}\n+\n+pub struct Union;\n+impl BitwiseOperator for Union {\n+    #[inline]\n+    fn join(&self, a: Word, b: Word) -> Word { a | b }\n+}\n+\n+pub struct Subtract;\n+impl BitwiseOperator for Subtract {\n+    #[inline]\n+    fn join(&self, a: Word, b: Word) -> Word { a & !b }\n+}\n+\n+pub fn bits_to_string(words: &[Word], bits: usize) -> String {\n+    let mut result = String::new();\n+    let mut sep = '[';\n+\n+    // Note: this is a little endian printout of bytes.\n+\n+    // i tracks how many bits we have printed so far.\n+    let mut i = 0;\n+    for &word in words.iter() {\n+        let mut v = word;\n+        for _ in 0..WORD_BYTES { // for each byte in `v`:\n+            let remain = bits - i;\n+            // If less than a byte remains, then mask just that many bits.\n+            let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n+            assert!(mask <= 0xFF);\n+            let byte = v & mask;\n+\n+            result.push_str(&format!(\"{}{:02x}\", sep, byte));\n+\n+            if remain <= 8 { break; }\n+            v >>= 8;\n+            i += 8;\n+            sep = '-';\n+        }\n+        sep = '|';\n+    }\n+    result.push(']');\n+\n+    result\n+}\n+\n+/// A resizable BitVector type.\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct BitVector<C: Idx> {\n+    data: BitArray<C>,\n+}\n+\n+impl<C: Idx> BitVector<C> {\n+    pub fn grow(&mut self, num_bits: C) {\n+        self.data.grow(num_bits)\n+    }\n+\n+    pub fn new() -> BitVector<C> {\n+        BitVector { data: BitArray::new(0) }\n+    }\n \n-        Some(C::new(self.idx - 1))\n+    pub fn with_capacity(bits: usize) -> BitVector<C> {\n+        BitVector { data: BitArray::new(bits) }\n     }\n \n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper)\n+    /// Returns true if the bit has changed.\n+    #[inline]\n+    pub fn insert(&mut self, bit: C) -> bool {\n+        self.grow(bit);\n+        self.data.insert(bit)\n+    }\n+\n+    #[inline]\n+    pub fn contains(&self, bit: C) -> bool {\n+        let (word, mask) = word_mask(bit);\n+        if let Some(word) = self.data.data.get(word) {\n+            (word & mask) != 0\n+        } else {\n+            false\n+        }\n     }\n }\n \n@@ -221,7 +342,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     pub fn new(rows: usize, columns: usize) -> BitMatrix<R, C> {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of words.\n-        let words_per_row = words(columns);\n+        let words_per_row = num_words(columns);\n         BitMatrix {\n             columns,\n             vector: vec![0; rows * words_per_row],\n@@ -232,7 +353,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// The range of bits for a given row.\n     fn range(&self, row: R) -> (usize, usize) {\n         let row = row.index();\n-        let words_per_row = words(self.columns);\n+        let words_per_row = num_words(self.columns);\n         let start = row * words_per_row;\n         (start, start + words_per_row)\n     }\n@@ -310,9 +431,8 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     pub fn iter<'a>(&'a self, row: R) -> BitIter<'a, C> {\n         let (start, end) = self.range(row);\n         BitIter {\n-            iter: self.vector[start..end].iter(),\n-            current: 0,\n-            idx: 0,\n+            cur: None,\n+            iter: self.vector[start..end].iter().enumerate(),\n             marker: PhantomData,\n         }\n     }\n@@ -421,7 +541,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n }\n \n #[inline]\n-fn words<C: Idx>(elements: C) -> usize {\n+fn num_words<C: Idx>(elements: C) -> usize {\n     (elements.index() + WORD_BITS - 1) / WORD_BITS\n }\n \n@@ -433,6 +553,46 @@ fn word_mask<C: Idx>(index: C) -> (usize, Word) {\n     (word, mask)\n }\n \n+#[test]\n+fn test_clear_above() {\n+    use std::cmp;\n+\n+    for i in 0..256 {\n+        let mut idx_buf: BitArray<usize> = BitArray::new_filled(128);\n+        idx_buf.clear_above(i);\n+\n+        let elems: Vec<usize> = idx_buf.iter().collect();\n+        let expected: Vec<usize> = (0..cmp::min(i, 128)).collect();\n+        assert_eq!(elems, expected);\n+    }\n+}\n+\n+#[test]\n+fn test_set_up_to() {\n+    for i in 0..128 {\n+        for mut idx_buf in\n+            vec![BitArray::new_empty(128), BitArray::new_filled(128)]\n+            .into_iter()\n+        {\n+            idx_buf.set_up_to(i);\n+\n+            let elems: Vec<usize> = idx_buf.iter().collect();\n+            let expected: Vec<usize> = (0..i).collect();\n+            assert_eq!(elems, expected);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_new_filled() {\n+    for i in 0..128 {\n+        let idx_buf = BitArray::new_filled(i);\n+        let elems: Vec<usize> = idx_buf.iter().collect();\n+        let expected: Vec<usize> = (0..i).collect();\n+        assert_eq!(elems, expected);\n+    }\n+}\n+\n #[test]\n fn bitvec_iter_works() {\n     let mut bitvec: BitArray<usize> = BitArray::new(100);"}, {"sha": "5ba8c150e1fcb7a30a9793bca5b3b9b1cfd41c53", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 25, "deletions": 165, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=7896af9508acbe5451e887e0a75922a5435b601d", "patch": "@@ -10,12 +10,9 @@\n \n use array_vec::ArrayVec;\n use std::fmt;\n-use std::iter;\n-use std::marker::PhantomData;\n use std::mem;\n use std::slice;\n-use bitslice::{BitSlice, Word};\n-use bitslice::{bitwise, Union, Subtract, Intersect};\n+use bitvec::{bitwise, BitArray, BitIter, Intersect, Subtract, Union, Word, WORD_BITS};\n use indexed_vec::Idx;\n use rustc_serialize;\n \n@@ -40,39 +37,21 @@ pub trait SubtractFromIdxSet<T: Idx> {\n /// this type uses to represent the set of object it holds.\n ///\n /// The representation is dense, using one bit per possible element.\n-#[derive(Eq, PartialEq)]\n-pub struct IdxSet<T: Idx> {\n-    _pd: PhantomData<fn(&T)>,\n-    bits: Vec<Word>,\n-}\n-\n-impl<T: Idx> Clone for IdxSet<T> {\n-    fn clone(&self) -> Self {\n-        IdxSet { _pd: PhantomData, bits: self.bits.clone() }\n-    }\n-}\n+#[derive(Clone, Eq, PartialEq)]\n+pub struct IdxSet<T: Idx>(BitArray<T>);\n \n impl<T: Idx> rustc_serialize::Encodable for IdxSet<T> {\n-    fn encode<E: rustc_serialize::Encoder>(&self,\n-                                     encoder: &mut E)\n-                                     -> Result<(), E::Error> {\n-        self.bits.encode(encoder)\n+    fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n+        self.0.encode(encoder)\n     }\n }\n \n impl<T: Idx> rustc_serialize::Decodable for IdxSet<T> {\n     fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<IdxSet<T>, D::Error> {\n-        let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n-\n-        Ok(IdxSet {\n-            _pd: PhantomData,\n-            bits: words,\n-        })\n+        Ok(IdxSet(rustc_serialize::Decodable::decode(d)?))\n     }\n }\n \n-const BITS_PER_WORD: usize = mem::size_of::<Word>() * 8;\n-\n impl<T: Idx> fmt::Debug for IdxSet<T> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n         w.debug_list()\n@@ -82,92 +61,57 @@ impl<T: Idx> fmt::Debug for IdxSet<T> {\n }\n \n impl<T: Idx> IdxSet<T> {\n-    fn new(init: Word, domain_size: usize) -> Self {\n-        let num_words = (domain_size + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n-        IdxSet {\n-            _pd: Default::default(),\n-            bits: vec![init; num_words],\n-        }\n+    /// Creates set holding no elements.\n+    pub fn new_empty(domain_size: usize) -> Self {\n+        IdxSet(BitArray::new_empty(domain_size))\n     }\n \n     /// Creates set holding every element whose index falls in range 0..domain_size.\n     pub fn new_filled(domain_size: usize) -> Self {\n-        let mut result = Self::new(!0, domain_size);\n-        result.trim_to(domain_size);\n-        result\n-    }\n-\n-    /// Creates set holding no elements.\n-    pub fn new_empty(domain_size: usize) -> Self {\n-        Self::new(0, domain_size)\n+        IdxSet(BitArray::new_filled(domain_size))\n     }\n \n     /// Duplicates as a hybrid set.\n     pub fn to_hybrid(&self) -> HybridIdxSet<T> {\n         // This domain_size may be slightly larger than the one specified\n         // upon creation, due to rounding up to a whole word. That's ok.\n-        let domain_size = self.bits.len() * BITS_PER_WORD;\n+        let domain_size = self.words().len() * WORD_BITS;\n \n         // Note: we currently don't bother trying to make a Sparse set.\n         HybridIdxSet::Dense(self.to_owned(), domain_size)\n     }\n \n     /// Removes all elements\n     pub fn clear(&mut self) {\n-        for b in &mut self.bits {\n-            *b = 0;\n-        }\n+        self.0.clear();\n     }\n \n     /// Sets all elements up to `domain_size`\n     pub fn set_up_to(&mut self, domain_size: usize) {\n-        for b in &mut self.bits {\n-            *b = !0;\n-        }\n-        self.trim_to(domain_size);\n-    }\n-\n-    /// Clear all elements above `domain_size`.\n-    fn trim_to(&mut self, domain_size: usize) {\n-        // `trim_block` is the first block where some bits have\n-        // to be cleared.\n-        let trim_block = domain_size / BITS_PER_WORD;\n-\n-        // all the blocks above it have to be completely cleared.\n-        if trim_block < self.bits.len() {\n-            for b in &mut self.bits[trim_block+1..] {\n-                *b = 0;\n-            }\n-\n-            // at that block, the `domain_size % BITS_PER_WORD` LSBs\n-            // should remain.\n-            let remaining_bits = domain_size % BITS_PER_WORD;\n-            let mask = (1<<remaining_bits)-1;\n-            self.bits[trim_block] &= mask;\n-        }\n+        self.0.set_up_to(domain_size);\n     }\n \n     /// Removes `elem` from the set `self`; returns true iff this changed `self`.\n     pub fn remove(&mut self, elem: &T) -> bool {\n-        self.bits.clear_bit(elem.index())\n+        self.0.remove(*elem)\n     }\n \n     /// Adds `elem` to the set `self`; returns true iff this changed `self`.\n     pub fn add(&mut self, elem: &T) -> bool {\n-        self.bits.set_bit(elem.index())\n+        self.0.insert(*elem)\n     }\n \n     /// Returns true iff set `self` contains `elem`.\n     pub fn contains(&self, elem: &T) -> bool {\n-        self.bits.get_bit(elem.index())\n+        self.0.contains(*elem)\n     }\n \n     pub fn words(&self) -> &[Word] {\n-        &self.bits\n+        self.0.words()\n     }\n \n     pub fn words_mut(&mut self) -> &mut [Word] {\n-        &mut self.bits\n+        self.0.words_mut()\n     }\n \n     /// Efficiently overwrite `self` with `other`. Panics if `self` and `other`\n@@ -194,12 +138,8 @@ impl<T: Idx> IdxSet<T> {\n         bitwise(self.words_mut(), other.words(), &Intersect)\n     }\n \n-    pub fn iter(&self) -> Iter<T> {\n-        Iter {\n-            cur: None,\n-            iter: self.words().iter().enumerate(),\n-            _pd: PhantomData,\n-        }\n+    pub fn iter(&self) -> BitIter<T> {\n+        self.0.iter()\n     }\n }\n \n@@ -215,32 +155,6 @@ impl<T: Idx> SubtractFromIdxSet<T> for IdxSet<T> {\n     }\n }\n \n-pub struct Iter<'a, T: Idx> {\n-    cur: Option<(Word, usize)>,\n-    iter: iter::Enumerate<slice::Iter<'a, Word>>,\n-    _pd: PhantomData<fn(&T)>,\n-}\n-\n-impl<'a, T: Idx> Iterator for Iter<'a, T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        loop {\n-            if let Some((ref mut word, offset)) = self.cur {\n-                let bit_pos = word.trailing_zeros() as usize;\n-                if bit_pos != BITS_PER_WORD {\n-                    let bit = 1 << bit_pos;\n-                    *word ^= bit;\n-                    return Some(T::new(bit_pos + offset))\n-                }\n-            }\n-\n-            let (i, word) = self.iter.next()?;\n-            self.cur = Some((*word, BITS_PER_WORD * i));\n-        }\n-    }\n-}\n-\n const SPARSE_MAX: usize = 8;\n \n /// A sparse index set with a maximum of SPARSE_MAX elements. Used by\n@@ -293,10 +207,8 @@ impl<T: Idx> SparseIdxSet<T> {\n         dense\n     }\n \n-    fn iter(&self) -> SparseIter<T> {\n-        SparseIter {\n-            iter: self.0.iter(),\n-        }\n+    fn iter(&self) -> slice::Iter<T> {\n+        self.0.iter()\n     }\n }\n \n@@ -320,18 +232,6 @@ impl<T: Idx> SubtractFromIdxSet<T> for SparseIdxSet<T> {\n     }\n }\n \n-pub struct SparseIter<'a, T: Idx> {\n-    iter: slice::Iter<'a, T>,\n-}\n-\n-impl<'a, T: Idx> Iterator for SparseIter<'a, T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|e| *e)\n-    }\n-}\n-\n /// Like IdxSet, but with a hybrid representation: sparse when there are few\n /// elements in the set, but dense when there are many. It's especially\n /// efficient for sets that typically have a small number of elements, but a\n@@ -442,57 +342,17 @@ impl<T: Idx> SubtractFromIdxSet<T> for HybridIdxSet<T> {\n }\n \n pub enum HybridIter<'a, T: Idx> {\n-    Sparse(SparseIter<'a, T>),\n-    Dense(Iter<'a, T>),\n+    Sparse(slice::Iter<'a, T>),\n+    Dense(BitIter<'a, T>),\n }\n \n impl<'a, T: Idx> Iterator for HybridIter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> {\n         match self {\n-            HybridIter::Sparse(sparse) => sparse.next(),\n+            HybridIter::Sparse(sparse) => sparse.next().map(|e| *e),\n             HybridIter::Dense(dense) => dense.next(),\n         }\n     }\n }\n-\n-#[test]\n-fn test_trim_to() {\n-    use std::cmp;\n-\n-    for i in 0..256 {\n-        let mut idx_buf: IdxSet<usize> = IdxSet::new_filled(128);\n-        idx_buf.trim_to(i);\n-\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..cmp::min(i, 128)).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}\n-\n-#[test]\n-fn test_set_up_to() {\n-    for i in 0..128 {\n-        for mut idx_buf in\n-            vec![IdxSet::new_empty(128), IdxSet::new_filled(128)]\n-            .into_iter()\n-        {\n-            idx_buf.set_up_to(i);\n-\n-            let elems: Vec<usize> = idx_buf.iter().collect();\n-            let expected: Vec<usize> = (0..i).collect();\n-            assert_eq!(elems, expected);\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_new_filled() {\n-    for i in 0..128 {\n-        let idx_buf = IdxSet::new_filled(i);\n-        let elems: Vec<usize> = idx_buf.iter().collect();\n-        let expected: Vec<usize> = (0..i).collect();\n-        assert_eq!(elems, expected);\n-    }\n-}"}, {"sha": "9435cb3184293acb020899727964e16c5d964a13", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=7896af9508acbe5451e887e0a75922a5435b601d", "patch": "@@ -62,7 +62,6 @@ pub use rustc_serialize::hex::ToHex;\n pub mod svh;\n pub mod array_vec;\n pub mod base_n;\n-pub mod bitslice;\n pub mod bitvec;\n pub mod const_cstr;\n pub mod flock;"}, {"sha": "a4900ab57f58861d37043996794cd322e66e2b0d", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=7896af9508acbe5451e887e0a75922a5435b601d", "patch": "@@ -15,7 +15,7 @@\n \n use rustc::mir::{BasicBlock, Location};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::indexed_set::Iter;\n+use rustc_data_structures::bitvec::BitIter;\n \n use borrow_check::location::LocationIndex;\n \n@@ -67,7 +67,7 @@ impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    crate fn with_outgoing_borrows(&self, op: impl FnOnce(Iter<BorrowIndex>)) {\n+    crate fn with_outgoing_borrows(&self, op: impl FnOnce(BitIter<BorrowIndex>)) {\n         self.borrows.with_iter_outgoing(op)\n     }\n }"}, {"sha": "39643af77a17845306d25780004dabddb36221f8", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=7896af9508acbe5451e887e0a75922a5435b601d", "patch": "@@ -12,7 +12,8 @@\n //! locations.\n \n use rustc::mir::{BasicBlock, Location};\n-use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet, Iter};\n+use rustc_data_structures::bitvec::BitIter;\n+use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet};\n \n use dataflow::{BitDenotation, BlockSets, DataflowResults};\n use dataflow::move_paths::{HasMoveData, MovePathIndex};\n@@ -125,7 +126,7 @@ where\n     }\n \n     /// Returns an iterator over the elements present in the current state.\n-    pub fn iter_incoming(&self) -> iter::Peekable<Iter<BD::Idx>> {\n+    pub fn iter_incoming(&self) -> iter::Peekable<BitIter<BD::Idx>> {\n         self.curr_state.iter().peekable()\n     }\n \n@@ -134,7 +135,7 @@ where\n     /// Invokes `f` with an iterator over the resulting state.\n     pub fn with_iter_outgoing<F>(&self, f: F)\n     where\n-        F: FnOnce(Iter<BD::Idx>),\n+        F: FnOnce(BitIter<BD::Idx>),\n     {\n         let mut curr_state = self.curr_state.clone();\n         curr_state.union(&self.stmt_gen);"}, {"sha": "9487147ea9df95e4ee193a763196aaa565e22068", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=7896af9508acbe5451e887e0a75922a5435b601d", "patch": "@@ -12,7 +12,7 @@\n \n use syntax::ast::NodeId;\n use rustc::mir::{BasicBlock, Mir};\n-use rustc_data_structures::bitslice::bits_to_string;\n+use rustc_data_structures::bitvec::bits_to_string;\n \n use dot;\n use dot::IntoCow;"}, {"sha": "66f020faa87df8e31ac0f2e3541de4593c533801", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=7896af9508acbe5451e887e0a75922a5435b601d", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::TyCtxt;\n use rustc::ty::{RegionKind, RegionVid};\n use rustc::ty::RegionKind::ReScope;\n \n-use rustc_data_structures::bitslice::{BitwiseOperator, Word};\n+use rustc_data_structures::bitvec::{BitwiseOperator, Word};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::IndexVec;"}, {"sha": "c8f704798529bd5151f13652bf088ec0c2012103", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=7896af9508acbe5451e887e0a75922a5435b601d", "patch": "@@ -14,7 +14,7 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::bitslice::{BitwiseOperator, Word};\n+use rustc_data_structures::bitvec::{BitwiseOperator, Word};\n use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n "}, {"sha": "49d75d31fc7fb95f1896b668ed93d765e4cde690", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7896af9508acbe5451e887e0a75922a5435b601d/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=7896af9508acbe5451e887e0a75922a5435b601d", "patch": "@@ -10,7 +10,7 @@\n \n use syntax::ast::{self, MetaItem};\n \n-use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n+use rustc_data_structures::bitvec::{bitwise, BitwiseOperator};\n use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;"}]}