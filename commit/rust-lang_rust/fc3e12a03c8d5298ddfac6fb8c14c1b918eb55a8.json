{"sha": "fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjM2UxMmEwM2M4ZDUyOThkZGZhYzZmYjhjMTRjMWI5MThlYjU1YTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-01T01:45:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-01T01:45:58Z"}, "message": "Auto merge of #45187 - GuillaumeGomez:doc-ui-improvement, r=QuietMisdreavus\n\nImprove sidebar rendering and add methods list\n\nI suppose it can be reviewed as is, but this is just the first step of a more global plan.\n\ncc @rust-lang/docs @nical\n\nAnd a screenshot of course:\n\n<img width=\"1440\" alt=\"screen shot 2017-10-10 at 23 38 45\" src=\"https://user-images.githubusercontent.com/3050060/31412170-657beaf6-ae14-11e7-9f01-1e562a034595.png\">", "tree": {"sha": "d78c6e67c4d7ee4061f03e7da07ae6c112d48cd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d78c6e67c4d7ee4061f03e7da07ae6c112d48cd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8", "html_url": "https://github.com/rust-lang/rust/commit/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3b900cc3b122c7e9eb78ca28bec18df68791b08", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3b900cc3b122c7e9eb78ca28bec18df68791b08", "html_url": "https://github.com/rust-lang/rust/commit/f3b900cc3b122c7e9eb78ca28bec18df68791b08"}, {"sha": "6fa521c491b365b354771213186e35c2e2e7a628", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fa521c491b365b354771213186e35c2e2e7a628", "html_url": "https://github.com/rust-lang/rust/commit/6fa521c491b365b354771213186e35c2e2e7a628"}], "stats": {"total": 190, "additions": 142, "deletions": 48}, "files": [{"sha": "edd01a66075b0b62d128c5ca05f9b638b27dc1e0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 104, "deletions": 42, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8", "patch": "@@ -37,7 +37,7 @@ pub use self::ExternalLocation::*;\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n-use std::collections::BTreeMap;\n+use std::collections::{BTreeMap, HashSet};\n use std::default::Default;\n use std::error;\n use std::fmt::{self, Display, Formatter, Write as FmtWrite};\n@@ -3207,12 +3207,37 @@ fn render_deref_methods(w: &mut fmt::Formatter, cx: &Context, impl_: &Impl,\n     }\n }\n \n+fn should_render_item(item: &clean::Item, deref_mut_: bool) -> bool {\n+    let self_type_opt = match item.inner {\n+        clean::MethodItem(ref method) => method.decl.self_type(),\n+        clean::TyMethodItem(ref method) => method.decl.self_type(),\n+        _ => None\n+    };\n+\n+    if let Some(self_ty) = self_type_opt {\n+        let (by_mut_ref, by_box) = match self_ty {\n+            SelfTy::SelfBorrowed(_, mutability) |\n+            SelfTy::SelfExplicit(clean::BorrowedRef { mutability, .. }) => {\n+                (mutability == Mutability::Mutable, false)\n+            },\n+            SelfTy::SelfExplicit(clean::ResolvedPath { did, .. }) => {\n+                (false, Some(did) == cache().owned_box_did)\n+            },\n+            _ => (false, false),\n+        };\n+\n+        (deref_mut_ || !by_mut_ref) && !by_box\n+    } else {\n+        false\n+    }\n+}\n+\n fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLink,\n                render_mode: RenderMode, outer_version: Option<&str>,\n                show_def_docs: bool) -> fmt::Result {\n     if render_mode == RenderMode::Normal {\n         let id = derive_id(match i.inner_impl().trait_ {\n-            Some(ref t) => format!(\"impl-{}\", Escape(&format!(\"{:#}\", t))),\n+            Some(ref t) => format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t))),\n             None => \"impl\".to_string(),\n         });\n         write!(w, \"<h3 id='{}' class='impl'><span class='in-band'><code>{}</code>\",\n@@ -3244,30 +3269,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n         let render_method_item: bool = match render_mode {\n             RenderMode::Normal => true,\n-            RenderMode::ForDeref { mut_: deref_mut_ } => {\n-                let self_type_opt = match item.inner {\n-                    clean::MethodItem(ref method) => method.decl.self_type(),\n-                    clean::TyMethodItem(ref method) => method.decl.self_type(),\n-                    _ => None\n-                };\n-\n-                if let Some(self_ty) = self_type_opt {\n-                    let (by_mut_ref, by_box) = match self_ty {\n-                        SelfTy::SelfBorrowed(_, mutability) |\n-                        SelfTy::SelfExplicit(clean::BorrowedRef { mutability, .. }) => {\n-                            (mutability == Mutability::Mutable, false)\n-                        },\n-                        SelfTy::SelfExplicit(clean::ResolvedPath { did, .. }) => {\n-                            (false, Some(did) == cache().owned_box_did)\n-                        },\n-                        _ => (false, false),\n-                    };\n-\n-                    (deref_mut_ || !by_mut_ref) && !by_box\n-                } else {\n-                    false\n-                }\n-            },\n+            RenderMode::ForDeref { mut_: deref_mut_ } => should_render_item(&item, deref_mut_),\n         };\n \n         match item.inner {\n@@ -3514,12 +3516,48 @@ impl<'a> fmt::Display for Sidebar<'a> {\n     }\n }\n \n+fn get_methods(i: &clean::Impl, for_deref: bool) -> Vec<String> {\n+    i.items.iter().filter_map(|item| {\n+        match item.name {\n+            // Maybe check with clean::Visibility::Public as well?\n+            Some(ref name) if !name.is_empty() && item.visibility.is_some() && item.is_method() => {\n+                if !for_deref || should_render_item(item, false) {\n+                    Some(format!(\"<a href=\\\"#method.{name}\\\">{name}</a>\", name = name))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    }).collect::<Vec<_>>()\n+}\n+\n+// The point is to url encode any potential character from a type with genericity.\n+fn small_url_encode(s: &str) -> String {\n+    s.replace(\"<\", \"%3C\")\n+     .replace(\">\", \"%3E\")\n+     .replace(\" \", \"%20\")\n+     .replace(\"?\", \"%3F\")\n+     .replace(\"'\", \"%27\")\n+     .replace(\"&\", \"%26\")\n+     .replace(\",\", \"%2C\")\n+     .replace(\":\", \"%3A\")\n+     .replace(\";\", \"%3B\")\n+     .replace(\"[\", \"%5B\")\n+     .replace(\"]\", \"%5D\")\n+}\n+\n fn sidebar_assoc_items(it: &clean::Item) -> String {\n     let mut out = String::new();\n     let c = cache();\n     if let Some(v) = c.impls.get(&it.def_id) {\n-        if v.iter().any(|i| i.inner_impl().trait_.is_none()) {\n-            out.push_str(\"<li><a href=\\\"#methods\\\">Methods</a></li>\");\n+        let ret = v.iter()\n+                   .filter(|i| i.inner_impl().trait_.is_none())\n+                   .flat_map(|i| get_methods(i.inner_impl(), false))\n+                   .collect::<String>();\n+        if !ret.is_empty() {\n+            out.push_str(&format!(\"<a class=\\\"sidebar-title\\\" href=\\\"#methods\\\">Methods\\\n+                                   </a><div class=\\\"sidebar-links\\\">{}</div>\", ret));\n         }\n \n         if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n@@ -3535,16 +3573,40 @@ fn sidebar_assoc_items(it: &clean::Item) -> String {\n                     let inner_impl = target.def_id().or(target.primitive_type().and_then(|prim| {\n                         c.primitive_locations.get(&prim).cloned()\n                     })).and_then(|did| c.impls.get(&did));\n-                    if inner_impl.is_some() {\n-                        out.push_str(\"<li><a href=\\\"#deref-methods\\\">\");\n+                    if let Some(impls) = inner_impl {\n+                        out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#deref-methods\\\">\");\n                         out.push_str(&format!(\"Methods from {:#}&lt;Target={:#}&gt;\",\n-                                                  impl_.inner_impl().trait_.as_ref().unwrap(),\n-                                                  target));\n-                        out.push_str(\"</a></li>\");\n+                                              impl_.inner_impl().trait_.as_ref().unwrap(),\n+                                              target));\n+                        out.push_str(\"</a>\");\n+                        let ret = impls.iter()\n+                                       .filter(|i| i.inner_impl().trait_.is_none())\n+                                       .flat_map(|i| get_methods(i.inner_impl(), true))\n+                                       .collect::<String>();\n+                        out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", ret));\n                     }\n                 }\n             }\n-            out.push_str(\"<li><a href=\\\"#implementations\\\">Trait Implementations</a></li>\");\n+            let mut links = HashSet::new();\n+            let ret = v.iter()\n+                       .filter_map(|i| if let Some(ref i) = i.inner_impl().trait_ {\n+                           let out = format!(\"{:#}\", i).replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\");\n+                           let encoded = small_url_encode(&format!(\"{:#}\", i));\n+                           let generated = format!(\"<a href=\\\"#impl-{}\\\">{}</a>\", encoded, out);\n+                           if !links.contains(&generated) && links.insert(generated.clone()) {\n+                               Some(generated)\n+                           } else {\n+                               None\n+                           }\n+                       } else {\n+                           None\n+                       })\n+                       .collect::<String>();\n+            if !ret.is_empty() {\n+                out.push_str(\"<a class=\\\"sidebar-title\\\" href=\\\"#implementations\\\">\\\n+                              Trait Implementations</a>\");\n+                out.push_str(&format!(\"<div class=\\\"sidebar-links\\\">{}</div>\", ret));\n+            }\n         }\n     }\n \n@@ -3565,7 +3627,7 @@ fn sidebar_struct(fmt: &mut fmt::Formatter, it: &clean::Item,\n     sidebar.push_str(&sidebar_assoc_items(it));\n \n     if !sidebar.is_empty() {\n-        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+        write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)?;\n     }\n     Ok(())\n }\n@@ -3592,8 +3654,6 @@ fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n         sidebar.push_str(\"<li><a href=\\\"#provided-methods\\\">Provided Methods</a></li>\");\n     }\n \n-    sidebar.push_str(&sidebar_assoc_items(it));\n-\n     let c = cache();\n \n     if let Some(implementors) = c.implementors.get(&it.def_id) {\n@@ -3607,15 +3667,17 @@ fn sidebar_trait(fmt: &mut fmt::Formatter, it: &clean::Item,\n \n     sidebar.push_str(\"<li><a href=\\\"#implementors\\\">Implementors</a></li>\");\n \n-    write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)\n+    sidebar.push_str(&sidebar_assoc_items(it));\n+\n+    write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)\n }\n \n fn sidebar_primitive(fmt: &mut fmt::Formatter, it: &clean::Item,\n                      _p: &clean::PrimitiveType) -> fmt::Result {\n     let sidebar = sidebar_assoc_items(it);\n \n     if !sidebar.is_empty() {\n-        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+        write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)?;\n     }\n     Ok(())\n }\n@@ -3625,7 +3687,7 @@ fn sidebar_typedef(fmt: &mut fmt::Formatter, it: &clean::Item,\n     let sidebar = sidebar_assoc_items(it);\n \n     if !sidebar.is_empty() {\n-        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+        write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)?;\n     }\n     Ok(())\n }\n@@ -3642,7 +3704,7 @@ fn sidebar_union(fmt: &mut fmt::Formatter, it: &clean::Item,\n     sidebar.push_str(&sidebar_assoc_items(it));\n \n     if !sidebar.is_empty() {\n-        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+        write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)?;\n     }\n     Ok(())\n }\n@@ -3658,7 +3720,7 @@ fn sidebar_enum(fmt: &mut fmt::Formatter, it: &clean::Item,\n     sidebar.push_str(&sidebar_assoc_items(it));\n \n     if !sidebar.is_empty() {\n-        write!(fmt, \"<div class=\\\"block items\\\"><ul>{}</ul></div>\", sidebar)?;\n+        write!(fmt, \"<div class=\\\"block items\\\">{}</div>\", sidebar)?;\n     }\n     Ok(())\n }"}, {"sha": "dcb0de3bb92de8fb0d06ef569c861799c5040ca2", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8", "patch": "@@ -188,18 +188,16 @@ nav.sub {\n \n .js-only, .hidden { display: none !important; }\n \n-.sidebar {\n-\tpadding: 10px;\n-}\n .sidebar img {\n \tmargin: 20px auto;\n \tdisplay: block;\n+\tmargin-top: 10px;\n }\n \n .sidebar .location {\n \tborder: 1px solid;\n \tfont-size: 17px;\n-\tmargin: 30px 0 20px 0;\n+\tmargin: 30px 10px 20px 10px;\n \ttext-align: center;\n \tword-wrap: break-word;\n }\n@@ -220,7 +218,7 @@ nav.sub {\n .location a:first-child { font-weight: 500; }\n \n .block {\n-\tpadding: 0 10px;\n+\tpadding: 0;\n \tmargin-bottom: 14px;\n }\n .block h2, .block h3 {\n@@ -229,7 +227,7 @@ nav.sub {\n \ttext-align: center;\n }\n .block ul, .block li {\n-\tmargin: 0;\n+\tmargin: 0 10px;\n \tpadding: 0;\n \tlist-style: none;\n }\n@@ -245,6 +243,23 @@ nav.sub {\n \ttransition: border 500ms ease-out;\n }\n \n+.sidebar-title {\n+\tborder-top: 1px solid #777;\n+\tborder-bottom: 1px solid #777;\n+\ttext-align: center;\n+\tfont-size: 17px;\n+\tmargin-bottom: 5px;\n+}\n+\n+.sidebar-links {\n+\tmargin-bottom: 15px;\n+}\n+\n+.sidebar-links > a {\n+\tpadding-left: 10px;\n+\twidth: 100%;\n+}\n+\n .content {\n \tpadding: 15px 0;\n }"}, {"sha": "e0153e1e6f67c0cb83bfd91ce0d3326667d00cd8", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=fc3e12a03c8d5298ddfac6fb8c14c1b918eb55a8", "patch": "@@ -69,15 +69,32 @@ struct FileEntry {\n \n type Cache = HashMap<PathBuf, FileEntry>;\n \n+fn small_url_encode(s: &str) -> String {\n+    s.replace(\"<\", \"%3C\")\n+     .replace(\">\", \"%3E\")\n+     .replace(\" \", \"%20\")\n+     .replace(\"?\", \"%3F\")\n+     .replace(\"'\", \"%27\")\n+     .replace(\"&\", \"%26\")\n+     .replace(\",\", \"%2C\")\n+     .replace(\":\", \"%3A\")\n+     .replace(\";\", \"%3B\")\n+     .replace(\"[\", \"%5B\")\n+     .replace(\"]\", \"%5D\")\n+}\n+\n impl FileEntry {\n     fn parse_ids(&mut self, file: &Path, contents: &str, errors: &mut bool) {\n         if self.ids.is_empty() {\n             with_attrs_in_source(contents, \" id\", |fragment, i, _| {\n                 let frag = fragment.trim_left_matches(\"#\").to_owned();\n+                let encoded = small_url_encode(&frag);\n                 if !self.ids.insert(frag) {\n                     *errors = true;\n                     println!(\"{}:{}: id is not unique: `{}`\", file.display(), i, fragment);\n                 }\n+                // Just in case, we also add the encoded id.\n+                self.ids.insert(encoded);\n             });\n         }\n     }"}]}