{"sha": "fc92d3b8202874c52328fbc3b7816f999586045a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjOTJkM2I4MjAyODc0YzUyMzI4ZmJjM2I3ODE2Zjk5OTU4NjA0NWE=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-17T23:25:40Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-28T14:06:52Z"}, "message": "Add dataflow-based const validation", "tree": {"sha": "d97279ed6ce89eed94c90c079aa541d6c5f7c704", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d97279ed6ce89eed94c90c079aa541d6c5f7c704"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc92d3b8202874c52328fbc3b7816f999586045a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc92d3b8202874c52328fbc3b7816f999586045a", "html_url": "https://github.com/rust-lang/rust/commit/fc92d3b8202874c52328fbc3b7816f999586045a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc92d3b8202874c52328fbc3b7816f999586045a/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3698d04fefaa72a1418986aede9cc1d05b6b899b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3698d04fefaa72a1418986aede9cc1d05b6b899b", "html_url": "https://github.com/rust-lang/rust/commit/3698d04fefaa72a1418986aede9cc1d05b6b899b"}], "stats": {"total": 1292, "additions": 1292, "deletions": 0}, "files": [{"sha": "ce26af64741b80ee0d9fda8a96b6147dafe7de07", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fc92d3b8202874c52328fbc3b7816f999586045a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc92d3b8202874c52328fbc3b7816f999586045a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=fc92d3b8202874c52328fbc3b7816f999586045a", "patch": "@@ -0,0 +1,45 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::mir;\n+use rustc::ty::{self, TyCtxt};\n+\n+pub use self::qualifs::Qualif;\n+\n+mod resolver;\n+mod qualifs;\n+pub mod validation;\n+\n+/// Information about the item currently being validated, as well as a reference to the global\n+/// context.\n+pub struct Item<'mir, 'tcx> {\n+    body: &'mir mir::Body<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    param_env: ty::ParamEnv<'tcx>,\n+    mode: validation::Mode,\n+}\n+\n+impl Item<'mir, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        body: &'mir mir::Body<'tcx>,\n+    ) -> Self {\n+        let param_env = tcx.param_env(def_id);\n+        let mode = validation::Mode::for_item(tcx, def_id)\n+            .expect(\"const validation must only be run inside a const context\");\n+\n+        Item {\n+            body,\n+            tcx,\n+            def_id,\n+            param_env,\n+            mode,\n+        }\n+    }\n+}\n+\n+\n+fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n+    Some(def_id) == tcx.lang_items().panic_fn() ||\n+    Some(def_id) == tcx.lang_items().begin_panic_fn()\n+}"}, {"sha": "4fa00bf098be41793c0552822f6fb8acf5120a0d", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/fc92d3b8202874c52328fbc3b7816f999586045a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc92d3b8202874c52328fbc3b7816f999586045a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=fc92d3b8202874c52328fbc3b7816f999586045a", "patch": "@@ -0,0 +1,327 @@\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::{self, BasicBlock, Local, Location};\n+use rustc_data_structures::bit_set::BitSet;\n+\n+use std::cell::RefCell;\n+use std::marker::PhantomData;\n+use std::rc::Rc;\n+\n+use crate::dataflow::{self as old_dataflow, generic as dataflow};\n+use super::{Item, Qualif};\n+use self::old_dataflow::IndirectlyMutableLocals;\n+\n+/// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n+/// `FlowSensitiveAnalysis` as well as the logic underlying `TempPromotionResolver`.\n+///\n+/// This transfer does nothing when encountering an indirect assignment. Consumers should rely on\n+/// the `IndirectlyMutableLocals` dataflow pass to see if a `Local` may have become qualified via\n+/// an indirect assignment or function call.\n+struct TransferFunction<'a, 'mir, 'tcx, Q> {\n+    item: &'a Item<'mir, 'tcx>,\n+    qualifs_per_local: &'a mut BitSet<Local>,\n+\n+    _qualif: PhantomData<Q>,\n+}\n+\n+impl<Q> TransferFunction<'a, 'mir, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    fn new(\n+        item: &'a Item<'mir, 'tcx>,\n+        qualifs_per_local: &'a mut BitSet<Local>,\n+    ) -> Self {\n+        TransferFunction {\n+            item,\n+            qualifs_per_local,\n+            _qualif: PhantomData,\n+        }\n+    }\n+\n+    fn initialize_state(&mut self) {\n+        self.qualifs_per_local.clear();\n+\n+        for arg in self.item.body.args_iter() {\n+            let arg_ty = self.item.body.local_decls[arg].ty;\n+            if Q::in_any_value_of_ty(self.item, arg_ty).unwrap() {\n+                self.qualifs_per_local.insert(arg);\n+            }\n+        }\n+    }\n+\n+    fn assign_qualif_direct(&mut self, place: &mir::Place<'tcx>, value: bool) {\n+        debug_assert!(!place.is_indirect());\n+\n+        match (value, place) {\n+            (true, mir::Place { base: mir::PlaceBase::Local(local), .. }) => {\n+                self.qualifs_per_local.insert(*local);\n+            }\n+\n+            // For now, we do not clear the qualif if a local is overwritten in full by\n+            // an unqualified rvalue (e.g. `y = 5`). This is to be consistent\n+            // with aggregates where we overwrite all fields with assignments, which would not\n+            // get this feature.\n+            (false, mir::Place { base: mir::PlaceBase::Local(_local), projection: box [] }) => {\n+                // self.qualifs_per_local.remove(*local);\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+\n+    fn apply_call_return_effect(\n+        &mut self,\n+        _block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    ) {\n+        let return_ty = return_place.ty(self.item.body, self.item.tcx).ty;\n+        let qualif = Q::in_call(self.item, &mut self.qualifs_per_local, func, args, return_ty);\n+        if !return_place.is_indirect() {\n+            self.assign_qualif_direct(return_place, qualif);\n+        }\n+    }\n+}\n+\n+impl<Q> Visitor<'tcx> for TransferFunction<'_, '_, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    fn visit_operand(&mut self, operand: &mir::Operand<'tcx>, location: Location) {\n+        self.super_operand(operand, location);\n+\n+        if !Q::IS_CLEARED_ON_MOVE {\n+            return;\n+        }\n+\n+        // If a local with no projections is moved from (e.g. `x` in `y = x`), record that\n+        // it no longer needs to be dropped.\n+        if let mir::Operand::Move(mir::Place {\n+            base: mir::PlaceBase::Local(local),\n+            projection: box [],\n+        }) = *operand {\n+            self.qualifs_per_local.remove(local);\n+        }\n+    }\n+\n+    fn visit_assign(\n+        &mut self,\n+        place: &mir::Place<'tcx>,\n+        rvalue: &mir::Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        let qualif = Q::in_rvalue(self.item, self.qualifs_per_local, rvalue);\n+        if !place.is_indirect() {\n+            self.assign_qualif_direct(place, qualif);\n+        }\n+\n+        // We need to assign qualifs to the left-hand side before visiting `rvalue` since\n+        // qualifs can be cleared on move.\n+        self.super_assign(place, rvalue, location);\n+    }\n+\n+    fn visit_terminator_kind(&mut self, kind: &mir::TerminatorKind<'tcx>, location: Location) {\n+        // The effect of assignment to the return place in `TerminatorKind::Call` is not applied\n+        // here; that occurs in `apply_call_return_effect`.\n+\n+        if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n+            let qualif = Q::in_operand(self.item, self.qualifs_per_local, value);\n+            if !dest.is_indirect() {\n+                self.assign_qualif_direct(dest, qualif);\n+            }\n+        }\n+\n+        // We need to assign qualifs to the dropped location before visiting the operand that\n+        // replaces it since qualifs can be cleared on move.\n+        self.super_terminator_kind(kind, location);\n+    }\n+}\n+\n+/// Types that can compute the qualifs of each local at each location in a `mir::Body`.\n+///\n+/// Code that wishes to use a `QualifResolver` must call `visit_{statement,terminator}` for each\n+/// statement or terminator, processing blocks in reverse post-order beginning from the\n+/// `START_BLOCK`. Calling code may optionally call `get` after visiting each statement or\n+/// terminator to query the qualification state immediately before that statement or terminator.\n+///\n+/// These conditions are much more restrictive than woud be required by `FlowSensitiveResolver`\n+/// alone. This is to allow a linear, on-demand `TempPromotionResolver` that can operate\n+/// efficiently on simple CFGs.\n+pub trait QualifResolver<Q> {\n+    /// Get the qualifs of each local at the last location visited.\n+    ///\n+    /// This takes `&mut self` so qualifs can be computed lazily.\n+    fn get(&mut self) -> &BitSet<Local>;\n+\n+    /// A convenience method for `self.get().contains(local)`.\n+    fn contains(&mut self, local: Local) -> bool {\n+        self.get().contains(local)\n+    }\n+\n+    /// Resets the resolver to the `START_BLOCK`. This allows a resolver to be reused\n+    /// for multiple passes over a `mir::Body`.\n+    fn reset(&mut self);\n+}\n+\n+type IndirectlyMutableResults<'mir, 'tcx> =\n+    old_dataflow::DataflowResultsCursor<'mir, 'tcx, IndirectlyMutableLocals<'mir, 'tcx>>;\n+\n+/// A resolver for qualifs that works on arbitrarily complex CFGs.\n+///\n+/// As soon as a `Local` becomes writable through a reference (as determined by the\n+/// `IndirectlyMutableLocals` dataflow pass), we must assume that it takes on all other qualifs\n+/// possible for its type. This is because no effort is made to track qualifs across indirect\n+/// assignments (e.g. `*p = x` or calls to opaque functions).\n+///\n+/// It is possible to be more precise here by waiting until an indirect assignment actually occurs\n+/// before marking a borrowed `Local` as qualified.\n+pub struct FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    location: Location,\n+    indirectly_mutable_locals: Rc<RefCell<IndirectlyMutableResults<'mir, 'tcx>>>,\n+    cursor: dataflow::ResultsCursor<'mir, 'tcx, FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>>,\n+    qualifs_per_local: BitSet<Local>,\n+}\n+\n+impl<Q> FlowSensitiveResolver<'a, 'mir, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    pub fn new(\n+        _: Q,\n+        item: &'a Item<'mir, 'tcx>,\n+        indirectly_mutable_locals: Rc<RefCell<IndirectlyMutableResults<'mir, 'tcx>>>,\n+        dead_unwinds: &BitSet<BasicBlock>,\n+    ) -> Self {\n+        let analysis = FlowSensitiveAnalysis {\n+            item,\n+            _qualif: PhantomData,\n+        };\n+        let results =\n+            dataflow::Engine::new(item.body, dead_unwinds, analysis).iterate_to_fixpoint();\n+        let cursor = dataflow::ResultsCursor::new(item.body, results);\n+\n+        FlowSensitiveResolver {\n+            cursor,\n+            indirectly_mutable_locals,\n+            qualifs_per_local: BitSet::new_empty(item.body.local_decls.len()),\n+            location: Location { block: mir::START_BLOCK, statement_index: 0 },\n+        }\n+    }\n+}\n+\n+impl<Q> Visitor<'tcx> for FlowSensitiveResolver<'_, '_, 'tcx, Q>\n+where\n+    Q: Qualif\n+{\n+    fn visit_statement(&mut self, _: &mir::Statement<'tcx>, location: Location) {\n+        self.location = location;\n+    }\n+\n+    fn visit_terminator(&mut self, _: &mir::Terminator<'tcx>, location: Location) {\n+        self.location = location;\n+    }\n+}\n+\n+impl<Q> QualifResolver<Q> for FlowSensitiveResolver<'_, '_, '_, Q>\n+where\n+    Q: Qualif\n+{\n+    fn get(&mut self) -> &BitSet<Local> {\n+        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n+\n+        indirectly_mutable_locals.seek(self.location);\n+        self.cursor.seek_before(self.location);\n+\n+        self.qualifs_per_local.overwrite(indirectly_mutable_locals.get());\n+        self.qualifs_per_local.union(self.cursor.get());\n+        &self.qualifs_per_local\n+    }\n+\n+    fn contains(&mut self, local: Local) -> bool {\n+        self.cursor.seek_before(self.location);\n+        if self.cursor.get().contains(local) {\n+            return true;\n+        }\n+\n+\n+        let mut indirectly_mutable_locals = self.indirectly_mutable_locals.borrow_mut();\n+        indirectly_mutable_locals.seek(self.location);\n+        indirectly_mutable_locals.get().contains(local)\n+    }\n+\n+    fn reset(&mut self)  {\n+        self.location = Location { block: mir::START_BLOCK, statement_index: 0 };\n+    }\n+}\n+\n+/// The dataflow analysis used to propagate qualifs on arbitrary CFGs.\n+pub(super) struct FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q> {\n+    item: &'a Item<'mir, 'tcx>,\n+    _qualif: PhantomData<Q>,\n+}\n+\n+impl<'a, 'mir, 'tcx, Q> FlowSensitiveAnalysis<'a, 'mir, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    fn transfer_function(\n+        &self,\n+        state: &'a mut BitSet<Local>,\n+    ) -> TransferFunction<'a, 'mir, 'tcx, Q> {\n+        TransferFunction::<Q>::new(self.item, state)\n+    }\n+}\n+\n+impl<Q> old_dataflow::BottomValue for FlowSensitiveAnalysis<'_, '_, '_, Q> {\n+    const BOTTOM_VALUE: bool = false;\n+}\n+\n+impl<Q> dataflow::Analysis<'tcx> for FlowSensitiveAnalysis<'_, '_, 'tcx, Q>\n+where\n+    Q: Qualif,\n+{\n+    type Idx = Local;\n+\n+    const NAME: &'static str = \"flow_sensitive_qualif\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n+    }\n+\n+    fn initialize_start_block(&self, _body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+        self.transfer_function(state).initialize_state();\n+    }\n+\n+    fn apply_statement_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        statement: &mir::Statement<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(state).visit_statement(statement, location);\n+    }\n+\n+    fn apply_terminator_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        terminator: &mir::Terminator<'tcx>,\n+        location: Location,\n+    ) {\n+        self.transfer_function(state).visit_terminator(terminator, location);\n+    }\n+\n+    fn apply_call_return_effect(\n+        &self,\n+        state: &mut BitSet<Self::Idx>,\n+        block: BasicBlock,\n+        func: &mir::Operand<'tcx>,\n+        args: &[mir::Operand<'tcx>],\n+        return_place: &mir::Place<'tcx>,\n+    ) {\n+        self.transfer_function(state).apply_call_return_effect(block, func, args, return_place)\n+    }\n+}"}, {"sha": "eee8f4856fd8d737a28268e6110da86cd2553d6e", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "added", "additions": 919, "deletions": 0, "changes": 919, "blob_url": "https://github.com/rust-lang/rust/blob/fc92d3b8202874c52328fbc3b7816f999586045a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc92d3b8202874c52328fbc3b7816f999586045a/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=fc92d3b8202874c52328fbc3b7816f999586045a", "patch": "@@ -0,0 +1,919 @@\n+use rustc::hir::{self, def_id::DefId};\n+use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n+use rustc::mir::*;\n+use rustc::session::config::nightly_options;\n+use rustc::ty::cast::CastTy;\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::bit_set::BitSet;\n+use rustc_target::spec::abi::Abi;\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::symbol::sym;\n+use syntax_pos::{Span, Symbol};\n+\n+use std::cell::RefCell;\n+use std::fmt;\n+use std::ops::Deref;\n+use std::rc::Rc;\n+\n+use crate::dataflow as old_dataflow;\n+use super::{Item, Qualif, is_lang_panic_fn};\n+use super::resolver::{QualifResolver, FlowSensitiveResolver};\n+use super::qualifs::{HasMutInterior, NeedsDrop};\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum CheckOpResult {\n+    Forbidden,\n+    Unleashed,\n+    Allowed,\n+}\n+\n+/// What kind of item we are in.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Mode {\n+    /// A `static` item.\n+    Static,\n+    /// A `static mut` item.\n+    StaticMut,\n+    /// A `const fn` item.\n+    ConstFn,\n+    /// A `const` item or an anonymous constant (e.g. in array lengths).\n+    Const,\n+}\n+\n+impl Mode {\n+    /// Returns the validation mode for the item with the given `DefId`, or `None` if this item\n+    /// does not require validation (e.g. a non-const `fn`).\n+    pub fn for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> Option<Self> {\n+        use hir::BodyOwnerKind as HirKind;\n+\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+\n+        let mode = match tcx.hir().body_owner_kind(hir_id) {\n+            HirKind::Closure => return None,\n+\n+            HirKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n+            HirKind::Fn => return None,\n+\n+            HirKind::Const => Mode::Const,\n+\n+            HirKind::Static(hir::MutImmutable) => Mode::Static,\n+            HirKind::Static(hir::MutMutable) => Mode::StaticMut,\n+        };\n+\n+        Some(mode)\n+    }\n+\n+    pub fn is_static(self) -> bool {\n+        match self {\n+            Mode::Static | Mode::StaticMut => true,\n+            Mode::ConstFn | Mode::Const => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the value returned by this item must be `Sync`.\n+    ///\n+    /// This returns false for `StaticMut` since all accesses to one are `unsafe` anyway.\n+    pub fn requires_sync(self) -> bool {\n+        match self {\n+            Mode::Static => true,\n+            Mode::ConstFn | Mode::Const |  Mode::StaticMut => false,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Mode {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Mode::Const => write!(f, \"constant\"),\n+            Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n+            Mode::ConstFn => write!(f, \"constant function\"),\n+        }\n+    }\n+}\n+\n+/// An operation that is not *always* allowed in a const context.\n+pub trait NonConstOp {\n+    /// Whether this operation can be evaluated by miri.\n+    const IS_SUPPORTED_IN_MIRI: bool = true;\n+\n+    /// Returns a boolean indicating whether the feature gate that would allow this operation is\n+    /// enabled, or `None` if such a feature gate does not exist.\n+    fn feature_gate(_tcx: TyCtxt<'tcx>) -> Option<bool> {\n+        None\n+    }\n+\n+    /// Returns `true` if this operation is allowed in the given item.\n+    ///\n+    /// This check should assume that we are not in a non-const `fn`, where all operations are\n+    /// legal.\n+    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+        Self::feature_gate(item.tcx).unwrap_or(false)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = struct_span_err!(\n+            item.tcx.sess,\n+            span,\n+            E0019,\n+            \"{} contains unimplemented expression type\",\n+            item.mode\n+        );\n+        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\"A function call isn't allowed in the const's initialization expression \\\n+                      because the expression's value must be known at compile-time.\");\n+            err.note(\"Remember: you can't use a function call inside a const's initialization \\\n+                      expression! However, you can use it anywhere else.\");\n+        }\n+        err.emit();\n+    }\n+}\n+\n+pub struct Qualifs<'a, 'mir, 'tcx> {\n+    has_mut_interior: FlowSensitiveResolver<'a, 'mir, 'tcx, HasMutInterior>,\n+    needs_drop: FlowSensitiveResolver<'a, 'mir, 'tcx, NeedsDrop>,\n+}\n+\n+pub struct Validator<'a, 'mir, 'tcx> {\n+    item: &'a Item<'mir, 'tcx>,\n+    qualifs: Qualifs<'a, 'mir, 'tcx>,\n+\n+    /// The span of the current statement.\n+    span: Span,\n+\n+    /// True if the local was assigned the result of an illegal borrow (`ops::MutBorrow`).\n+    ///\n+    /// This is used to hide errors from {re,}borrowing the newly-assigned local, instead pointing\n+    /// the user to the place where the illegal borrow occurred. This set is only populated once an\n+    /// error has been emitted, so it will never cause an erroneous `mir::Body` to pass validation.\n+    ///\n+    /// FIXME(ecstaticmorse): assert at the end of checking that if `tcx.has_errors() == false`,\n+    /// this set is empty. Note that if we start removing locals from\n+    /// `derived_from_illegal_borrow`, just checking at the end won't be enough.\n+    derived_from_illegal_borrow: BitSet<Local>,\n+\n+    errors: Vec<(Span, String)>,\n+\n+    /// Whether to actually emit errors or just store them in `errors`.\n+    pub(crate) suppress_errors: bool,\n+}\n+\n+impl Deref for Validator<'_, 'mir, 'tcx> {\n+    type Target = Item<'mir, 'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.item\n+    }\n+}\n+\n+impl Validator<'a, 'mir, 'tcx> {\n+    pub fn new(item: &'a Item<'mir, 'tcx>) -> Self {\n+        let dead_unwinds = BitSet::new_empty(item.body.basic_blocks().len());\n+\n+        let indirectly_mutable_locals = old_dataflow::do_dataflow(\n+            item.tcx,\n+            item.body,\n+            item.def_id,\n+            &[],\n+            &dead_unwinds,\n+            old_dataflow::IndirectlyMutableLocals::new(item.tcx, item.body, item.param_env),\n+            |_, local| old_dataflow::DebugFormatted::new(&local),\n+        );\n+\n+        let indirectly_mutable_locals = old_dataflow::DataflowResultsCursor::new(\n+            indirectly_mutable_locals,\n+            item.body,\n+        );\n+        let indirectly_mutable_locals = Rc::new(RefCell::new(indirectly_mutable_locals));\n+\n+        let needs_drop = FlowSensitiveResolver::new(\n+            NeedsDrop,\n+            item,\n+            indirectly_mutable_locals.clone(),\n+            &dead_unwinds,\n+        );\n+\n+        let has_mut_interior = FlowSensitiveResolver::new(\n+            HasMutInterior,\n+            item,\n+            indirectly_mutable_locals.clone(),\n+            &dead_unwinds,\n+        );\n+\n+        let qualifs = Qualifs {\n+            needs_drop,\n+            has_mut_interior,\n+        };\n+\n+        Validator {\n+            span: item.body.span,\n+            item,\n+            qualifs,\n+            errors: vec![],\n+            derived_from_illegal_borrow: BitSet::new_empty(item.body.local_decls.len()),\n+            suppress_errors: false,\n+        }\n+    }\n+\n+    /// Resets the `QualifResolver`s used by this `Validator` and returns them so they can be\n+    /// reused.\n+    pub fn into_qualifs(mut self) -> Qualifs<'a, 'mir, 'tcx> {\n+        self.qualifs.needs_drop.reset();\n+        self.qualifs.has_mut_interior.reset();\n+        self.qualifs\n+    }\n+\n+    pub fn take_errors(&mut self) -> Vec<(Span, String)> {\n+        std::mem::replace(&mut self.errors, vec![])\n+    }\n+\n+    /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n+    /// context. Returns `Forbidden` if an error was emitted.\n+    pub fn check_op_spanned<O>(&mut self, op: O, span: Span) -> CheckOpResult\n+    where\n+        O: NonConstOp + fmt::Debug\n+    {\n+        trace!(\"check_op: op={:?}\", op);\n+\n+        if op.is_allowed_in_item(self) {\n+            return CheckOpResult::Allowed;\n+        }\n+\n+        // If an operation is supported in miri (and is not already controlled by a feature gate) it\n+        // can be turned on with `-Zunleash-the-miri-inside-of-you`.\n+        let is_unleashable = O::IS_SUPPORTED_IN_MIRI\n+            && O::feature_gate(self.tcx).is_none();\n+\n+        if is_unleashable && self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+            self.tcx.sess.span_warn(span, \"skipping const checks\");\n+            return CheckOpResult::Unleashed;\n+        }\n+\n+        if !self.suppress_errors {\n+            op.emit_error(self, span);\n+        }\n+\n+        self.errors.push((span, format!(\"{:?}\", op)));\n+        CheckOpResult::Forbidden\n+    }\n+\n+    /// Emits an error if an expression cannot be evaluated in the current context.\n+    pub fn check_op(&mut self, op: impl NonConstOp + fmt::Debug) -> CheckOpResult {\n+        let span = self.span;\n+        self.check_op_spanned(op, span)\n+    }\n+}\n+\n+impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        trace!(\"visit_rvalue: rvalue={:?} location={:?}\", rvalue, location);\n+\n+        // Check nested operands and places.\n+        if let Rvalue::Ref(_, kind, ref place) = *rvalue {\n+            // Special-case reborrows to be more like a copy of a reference.\n+            let mut reborrow_place = None;\n+            if let box [proj_base @ .., elem] = &place.projection {\n+                if *elem == ProjectionElem::Deref {\n+                    let base_ty = Place::ty_from(&place.base, proj_base, self.body, self.tcx).ty;\n+                    if let ty::Ref(..) = base_ty.sty {\n+                        reborrow_place = Some(proj_base);\n+                    }\n+                }\n+            }\n+\n+            if let Some(proj) = reborrow_place {\n+                let ctx = match kind {\n+                    BorrowKind::Shared => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::SharedBorrow,\n+                    ),\n+                    BorrowKind::Shallow => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::ShallowBorrow,\n+                    ),\n+                    BorrowKind::Unique => PlaceContext::NonMutatingUse(\n+                        NonMutatingUseContext::UniqueBorrow,\n+                    ),\n+                    BorrowKind::Mut { .. } => PlaceContext::MutatingUse(\n+                        MutatingUseContext::Borrow,\n+                    ),\n+                };\n+                self.visit_place_base(&place.base, ctx, location);\n+                self.visit_projection(&place.base, proj, ctx, location);\n+            } else {\n+                self.super_rvalue(rvalue, location);\n+            }\n+        } else {\n+            self.super_rvalue(rvalue, location);\n+        }\n+\n+        match *rvalue {\n+            Rvalue::Use(_) |\n+            Rvalue::Repeat(..) |\n+            Rvalue::UnaryOp(UnOp::Neg, _) |\n+            Rvalue::UnaryOp(UnOp::Not, _) |\n+            Rvalue::NullaryOp(NullOp::SizeOf, _) |\n+            Rvalue::CheckedBinaryOp(..) |\n+            Rvalue::Cast(CastKind::Pointer(_), ..) |\n+            Rvalue::Discriminant(..) |\n+            Rvalue::Len(_) |\n+            Rvalue::Ref(..) |\n+            Rvalue::Aggregate(..) => {}\n+\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) => {\n+                let operand_ty = operand.ty(self.body, self.tcx);\n+                let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n+                let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+\n+                if let (CastTy::Ptr(_), CastTy::Int(_))\n+                     | (CastTy::FnPtr,  CastTy::Int(_)) = (cast_in, cast_out) {\n+                    self.check_op(ops::RawPtrToIntCast);\n+                }\n+            }\n+\n+            Rvalue::BinaryOp(op, ref lhs, _) => {\n+                if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(self.body, self.tcx).sty {\n+                    assert!(op == BinOp::Eq || op == BinOp::Ne ||\n+                            op == BinOp::Le || op == BinOp::Lt ||\n+                            op == BinOp::Ge || op == BinOp::Gt ||\n+                            op == BinOp::Offset);\n+\n+\n+                    self.check_op(ops::RawPtrComparison);\n+                }\n+            }\n+\n+            Rvalue::NullaryOp(NullOp::Box, _) => {\n+                self.check_op(ops::HeapAllocation);\n+            }\n+        }\n+    }\n+\n+    fn visit_place_base(\n+        &mut self,\n+        place_base: &PlaceBase<'tcx>,\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        trace!(\n+            \"visit_place_base: place_base={:?} context={:?} location={:?}\",\n+            place_base,\n+            context,\n+            location,\n+        );\n+        self.super_place_base(place_base, context, location);\n+\n+        match place_base {\n+            PlaceBase::Local(_) => {}\n+            PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_, _), .. }) => {\n+                bug!(\"Promotion must be run after const validation\");\n+            }\n+\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static, def_id, .. }) => {\n+                let is_thread_local = self.tcx.has_attr(*def_id, sym::thread_local);\n+                if is_thread_local {\n+                    self.check_op(ops::ThreadLocalAccess);\n+                } else if self.mode == Mode::Static && context.is_mutating_use() {\n+                    // this is not strictly necessary as miri will also bail out\n+                    // For interior mutability we can't really catch this statically as that\n+                    // goes through raw pointers and intermediate temporaries, so miri has\n+                    // to catch this anyway\n+\n+                    self.tcx.sess.span_err(\n+                        self.span,\n+                        \"cannot mutate statics in the initializer of another static\",\n+                    );\n+                } else {\n+                    self.check_op(ops::StaticAccess);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_assign(&mut self, dest: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+        trace!(\"visit_assign: dest={:?} rvalue={:?} location={:?}\", dest, rvalue, location);\n+\n+        // Error on mutable borrows or shared borrows of values with interior mutability.\n+        //\n+        // This replicates the logic at the start of `assign` in the old const checker.  Note that\n+        // it depends on `HasMutInterior` being set for mutable borrows as well as values with\n+        // interior mutability.\n+        if let Rvalue::Ref(_, kind, ref borrowed_place) = *rvalue {\n+            let rvalue_has_mut_interior = HasMutInterior::in_rvalue(\n+                &self.item,\n+                self.qualifs.has_mut_interior.get(),\n+                rvalue,\n+            );\n+\n+            if rvalue_has_mut_interior {\n+                let is_derived_from_illegal_borrow = match *borrowed_place {\n+                    // If an unprojected local was borrowed and its value was the result of an\n+                    // illegal borrow, suppress this error and mark the result of this borrow as\n+                    // illegal as well.\n+                    Place { base: PlaceBase::Local(borrowed_local), projection: box [] }\n+                        if self.derived_from_illegal_borrow.contains(borrowed_local) => true,\n+\n+                    // Otherwise proceed normally: check the legality of a mutable borrow in this\n+                    // context.\n+                    _ => self.check_op(ops::MutBorrow(kind)) == CheckOpResult::Forbidden,\n+                };\n+\n+                // When the target of the assignment is a local with no projections, mark it as\n+                // derived from an illegal borrow if necessary.\n+                //\n+                // FIXME: should we also clear `derived_from_illegal_borrow` when a local is\n+                // assigned a new value?\n+                if is_derived_from_illegal_borrow {\n+                    if let Place { base: PlaceBase::Local(dest), projection: box [] } = *dest {\n+                        self.derived_from_illegal_borrow.insert(dest);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.super_assign(dest, rvalue, location);\n+    }\n+\n+    fn visit_projection(\n+        &mut self,\n+        place_base: &PlaceBase<'tcx>,\n+        proj: &[PlaceElem<'tcx>],\n+        context: PlaceContext,\n+        location: Location,\n+    ) {\n+        trace!(\n+            \"visit_place_projection: proj={:?} context={:?} location={:?}\",\n+            proj,\n+            context,\n+            location,\n+        );\n+        self.super_projection(place_base, proj, context, location);\n+\n+        let (elem, proj_base) = match proj.split_last() {\n+            Some(x) => x,\n+            None => return,\n+        };\n+\n+        match elem {\n+            ProjectionElem::Deref => {\n+                if context.is_mutating_use() {\n+                    self.check_op(ops::MutDeref);\n+                }\n+\n+                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                if let ty::RawPtr(_) = base_ty.sty {\n+                    self.check_op(ops::RawPtrDeref);\n+                }\n+            }\n+\n+            ProjectionElem::ConstantIndex {..} |\n+            ProjectionElem::Subslice {..} |\n+            ProjectionElem::Field(..) |\n+            ProjectionElem::Index(_) => {\n+                let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n+                match base_ty.ty_adt_def() {\n+                    Some(def) if def.is_union() => {\n+                        self.check_op(ops::UnionAccess);\n+                    }\n+\n+                    _ => {}\n+                }\n+            }\n+\n+            ProjectionElem::Downcast(..) => {\n+                self.check_op(ops::Downcast);\n+            }\n+        }\n+    }\n+\n+\n+    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n+        trace!(\"visit_source_info: source_info={:?}\", source_info);\n+        self.span = source_info.span;\n+    }\n+\n+    fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n+        trace!(\"visit_statement: statement={:?} location={:?}\", statement, location);\n+\n+        self.qualifs.needs_drop.visit_statement(statement, location);\n+        self.qualifs.has_mut_interior.visit_statement(statement, location);\n+        debug!(\"needs_drop: {:?}\", self.qualifs.needs_drop.get());\n+        debug!(\"has_mut_interior: {:?}\", self.qualifs.has_mut_interior.get());\n+\n+        match statement.kind {\n+            StatementKind::Assign(..) => {\n+                self.super_statement(statement, location);\n+            }\n+            StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n+                self.check_op(ops::IfOrMatch);\n+            }\n+            // FIXME(eddyb) should these really do nothing?\n+            StatementKind::FakeRead(..) |\n+            StatementKind::SetDiscriminant { .. } |\n+            StatementKind::StorageLive(_) |\n+            StatementKind::StorageDead(_) |\n+            StatementKind::InlineAsm {..} |\n+            StatementKind::Retag { .. } |\n+            StatementKind::AscribeUserType(..) |\n+            StatementKind::Nop => {}\n+        }\n+    }\n+\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        trace!(\"visit_terminator: terminator={:?} location={:?}\", terminator, location);\n+\n+        self.qualifs.needs_drop.visit_terminator(terminator, location);\n+        self.qualifs.has_mut_interior.visit_terminator(terminator, location);\n+        debug!(\"needs_drop: {:?}\", self.qualifs.needs_drop.get());\n+        debug!(\"has_mut_interior: {:?}\", self.qualifs.has_mut_interior.get());\n+\n+        self.super_terminator(terminator, location);\n+    }\n+\n+    fn visit_terminator_kind(&mut self, kind: &TerminatorKind<'tcx>, location: Location) {\n+        trace!(\"visit_terminator_kind: kind={:?} location={:?}\", kind, location);\n+        self.super_terminator_kind(kind, location);\n+\n+        match kind {\n+            TerminatorKind::Call { func, .. } => {\n+                let fn_ty = func.ty(self.body, self.tcx);\n+\n+                let def_id = match fn_ty.sty {\n+                    ty::FnDef(def_id, _) => def_id,\n+\n+                    ty::FnPtr(_) => {\n+                        self.check_op(ops::FnCallIndirect);\n+                        return;\n+                    }\n+                    _ => {\n+                        self.check_op(ops::FnCallOther);\n+                        return;\n+                    }\n+                };\n+\n+                // At this point, we are calling a function whose `DefId` is known...\n+\n+                if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = self.tcx.fn_sig(def_id).abi() {\n+                    assert!(!self.tcx.is_const_fn(def_id));\n+\n+                    if self.tcx.item_name(def_id) == sym::transmute {\n+                        self.check_op(ops::Transmute);\n+                        return;\n+                    }\n+\n+                    // To preserve the current semantics, we return early, allowing all\n+                    // intrinsics (except `transmute`) to pass unchecked to miri.\n+                    //\n+                    // FIXME: We should keep a whitelist of allowed intrinsics (or at least a\n+                    // blacklist of unimplemented ones) and fail here instead.\n+                    return;\n+                }\n+\n+                if self.tcx.is_const_fn(def_id) {\n+                    return;\n+                }\n+\n+                if is_lang_panic_fn(self.tcx, def_id) {\n+                    self.check_op(ops::Panic);\n+                } else if let Some(feature) = self.tcx.is_unstable_const_fn(def_id) {\n+                    // Exempt unstable const fns inside of macros with\n+                    // `#[allow_internal_unstable]`.\n+                    if !self.span.allows_unstable(feature) {\n+                        self.check_op(ops::FnCallUnstable(def_id, feature));\n+                    }\n+                } else {\n+                    self.check_op(ops::FnCallNonConst(def_id));\n+                }\n+\n+            }\n+\n+            // Forbid all `Drop` terminators unless the place being dropped is a local with no\n+            // projections that cannot be `NeedsDrop`.\n+            | TerminatorKind::Drop { location: dropped_place, .. }\n+            | TerminatorKind::DropAndReplace { location: dropped_place, .. }\n+            => {\n+                let mut err_span = self.span;\n+\n+                // Check to see if the type of this place can ever have a drop impl. If not, this\n+                // `Drop` terminator is frivolous.\n+                let ty_needs_drop = dropped_place\n+                    .ty(self.body, self.tcx)\n+                    .ty\n+                    .needs_drop(self.tcx, self.param_env);\n+\n+                if !ty_needs_drop {\n+                    return;\n+                }\n+\n+                let needs_drop = if let Place {\n+                    base: PlaceBase::Local(local),\n+                    projection: box [],\n+                } = *dropped_place {\n+                    // Use the span where the local was declared as the span of the drop error.\n+                    err_span = self.body.local_decls[local].source_info.span;\n+                    self.qualifs.needs_drop.contains(local)\n+                } else {\n+                    true\n+                };\n+\n+                if needs_drop {\n+                    self.check_op_spanned(ops::LiveDrop, err_span);\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+}\n+\n+/// All implementers of `NonConstOp`.\n+pub mod ops {\n+    use super::*;\n+\n+    /// A `Downcast` projection.\n+    #[derive(Debug)]\n+    pub struct Downcast;\n+    impl NonConstOp for Downcast {}\n+\n+    /// A function call where the callee is a pointer.\n+    #[derive(Debug)]\n+    pub struct FnCallIndirect;\n+    impl NonConstOp for FnCallIndirect {\n+        const IS_SUPPORTED_IN_MIRI: bool = false;\n+\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            let mut err = item.tcx.sess.struct_span_err(\n+                span,\n+                &format!(\"function pointers are not allowed in const fn\"));\n+            err.emit();\n+        }\n+    }\n+\n+    /// A function call where the callee is not marked as `const`.\n+    #[derive(Debug)]\n+    pub struct FnCallNonConst(pub DefId);\n+    impl NonConstOp for FnCallNonConst {\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            let mut err = struct_span_err!(\n+                item.tcx.sess,\n+                span,\n+                E0015,\n+                \"calls in {}s are limited to constant functions, \\\n+                 tuple structs and tuple variants\",\n+                item.mode,\n+            );\n+            err.emit();\n+        }\n+    }\n+\n+    /// A function call where the callee is not a function definition or function pointer, e.g. a\n+    /// closure.\n+    ///\n+    /// This can be subdivided in the future to produce a better error message.\n+    #[derive(Debug)]\n+    pub struct FnCallOther;\n+    impl NonConstOp for FnCallOther {\n+        const IS_SUPPORTED_IN_MIRI: bool = false;\n+    }\n+\n+    /// A call to a `#[unstable]` const fn or `#[rustc_const_unstable]` function.\n+    ///\n+    /// Contains the name of the feature that would allow the use of this function.\n+    #[derive(Debug)]\n+    pub struct FnCallUnstable(pub DefId, pub Symbol);\n+    impl NonConstOp for FnCallUnstable {\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            let FnCallUnstable(def_id, feature) = *self;\n+\n+            let mut err = item.tcx.sess.struct_span_err(span,\n+                &format!(\"`{}` is not yet stable as a const fn\",\n+                        item.tcx.def_path_str(def_id)));\n+            if nightly_options::is_nightly_build() {\n+                help!(&mut err,\n+                      \"add `#![feature({})]` to the \\\n+                       crate attributes to enable\",\n+                      feature);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct HeapAllocation;\n+    impl NonConstOp for HeapAllocation {\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            let mut err = struct_span_err!(item.tcx.sess, span, E0010,\n+                                           \"allocations are not allowed in {}s\", item.mode);\n+            err.span_label(span, format!(\"allocation not allowed in {}s\", item.mode));\n+            if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(\n+                    \"The value of statics and constants must be known at compile time, \\\n+                     and they live for the entire lifetime of a program. Creating a boxed \\\n+                     value allocates memory on the heap at runtime, and therefore cannot \\\n+                     be done at compile time.\"\n+                );\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct IfOrMatch;\n+    impl NonConstOp for IfOrMatch {}\n+\n+    #[derive(Debug)]\n+    pub struct LiveDrop;\n+    impl NonConstOp for LiveDrop {\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            struct_span_err!(item.tcx.sess, span, E0493,\n+                             \"destructors cannot be evaluated at compile-time\")\n+                .span_label(span, format!(\"{}s cannot evaluate destructors\",\n+                                          item.mode))\n+                .emit();\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct Loop;\n+    impl NonConstOp for Loop {}\n+\n+    #[derive(Debug)]\n+    pub struct MutBorrow(pub BorrowKind);\n+    impl NonConstOp for MutBorrow {\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            let kind = self.0;\n+            if let BorrowKind::Mut { .. } = kind {\n+                let mut err = struct_span_err!(item.tcx.sess, span, E0017,\n+                                               \"references in {}s may only refer \\\n+                                                to immutable values\", item.mode);\n+                err.span_label(span, format!(\"{}s require immutable values\",\n+                                                    item.mode));\n+                if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+                    err.note(\"References in statics and constants may only refer \\\n+                              to immutable values.\\n\\n\\\n+                              Statics are shared everywhere, and if they refer to \\\n+                              mutable data one might violate memory safety since \\\n+                              holding multiple mutable references to shared data \\\n+                              is not allowed.\\n\\n\\\n+                              If you really want global mutable state, try using \\\n+                              static mut or a global UnsafeCell.\");\n+                }\n+                err.emit();\n+            } else {\n+                span_err!(item.tcx.sess, span, E0492,\n+                          \"cannot borrow a constant which may contain \\\n+                           interior mutability, create a static instead\");\n+            }\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct MutDeref;\n+    impl NonConstOp for MutDeref {}\n+\n+    #[derive(Debug)]\n+    pub struct Panic;\n+    impl NonConstOp for Panic {\n+        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+            Some(tcx.features().const_panic)\n+        }\n+\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            emit_feature_err(\n+                &item.tcx.sess.parse_sess,\n+                sym::const_panic,\n+                span,\n+                GateIssue::Language,\n+                &format!(\"panicking in {}s is unstable\", item.mode),\n+            );\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct RawPtrComparison;\n+    impl NonConstOp for RawPtrComparison {\n+        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+            Some(tcx.features().const_compare_raw_pointers)\n+        }\n+\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            emit_feature_err(\n+                &item.tcx.sess.parse_sess,\n+                sym::const_compare_raw_pointers,\n+                span,\n+                GateIssue::Language,\n+                &format!(\"comparing raw pointers inside {}\", item.mode),\n+            );\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct RawPtrDeref;\n+    impl NonConstOp for RawPtrDeref {\n+        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+            Some(tcx.features().const_raw_ptr_deref)\n+        }\n+\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            emit_feature_err(\n+                &item.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n+                span, GateIssue::Language,\n+                &format!(\n+                    \"dereferencing raw pointers in {}s is unstable\",\n+                    item.mode,\n+                ),\n+            );\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct RawPtrToIntCast;\n+    impl NonConstOp for RawPtrToIntCast {\n+        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+            Some(tcx.features().const_raw_ptr_to_usize_cast)\n+        }\n+\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            emit_feature_err(\n+                &item.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n+                span, GateIssue::Language,\n+                &format!(\n+                    \"casting pointers to integers in {}s is unstable\",\n+                    item.mode,\n+                ),\n+            );\n+        }\n+    }\n+\n+    /// An access to a (non-thread-local) `static`.\n+    #[derive(Debug)]\n+    pub struct StaticAccess;\n+    impl NonConstOp for StaticAccess {\n+        fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+            item.mode.is_static()\n+        }\n+\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            let mut err = struct_span_err!(item.tcx.sess, span, E0013,\n+                                            \"{}s cannot refer to statics, use \\\n+                                            a constant instead\", item.mode);\n+            if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(\n+                    \"Static and const variables can refer to other const variables. \\\n+                        But a const variable cannot refer to a static variable.\"\n+                );\n+                err.help(\n+                    \"To fix this, the value can be extracted as a const and then used.\"\n+                );\n+            }\n+            err.emit();\n+        }\n+    }\n+\n+    /// An access to a thread-local `static`.\n+    #[derive(Debug)]\n+    pub struct ThreadLocalAccess;\n+    impl NonConstOp for ThreadLocalAccess {\n+        const IS_SUPPORTED_IN_MIRI: bool = false;\n+\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            span_err!(item.tcx.sess, span, E0625,\n+                \"thread-local statics cannot be \\\n+                accessed at compile-time\");\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct Transmute;\n+    impl NonConstOp for Transmute {\n+        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+            Some(tcx.features().const_transmute)\n+        }\n+\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            emit_feature_err(\n+                &item.tcx.sess.parse_sess, sym::const_transmute,\n+                span, GateIssue::Language,\n+                &format!(\"The use of std::mem::transmute() \\\n+                is gated in {}s\", item.mode));\n+        }\n+    }\n+\n+    #[derive(Debug)]\n+    pub struct UnionAccess;\n+    impl NonConstOp for UnionAccess {\n+        fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+            // Union accesses are stable in all contexts except `const fn`.\n+            item.mode != Mode::ConstFn || Self::feature_gate(item.tcx).unwrap()\n+        }\n+\n+        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+            Some(tcx.features().const_fn_union)\n+        }\n+\n+        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+            emit_feature_err(\n+                &item.tcx.sess.parse_sess, sym::const_fn_union,\n+                span, GateIssue::Language,\n+                \"unions in const fn are unstable\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "5037c791cb68892fc26fddf110ed621bc0af4a69", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc92d3b8202874c52328fbc3b7816f999586045a/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc92d3b8202874c52328fbc3b7816f999586045a/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=fc92d3b8202874c52328fbc3b7816f999586045a", "patch": "@@ -15,6 +15,7 @@ use syntax_pos::Span;\n pub mod add_retag;\n pub mod add_moves_for_packed_drops;\n pub mod cleanup_post_borrowck;\n+pub mod check_consts;\n pub mod check_unsafety;\n pub mod simplify_branches;\n pub mod simplify;"}]}