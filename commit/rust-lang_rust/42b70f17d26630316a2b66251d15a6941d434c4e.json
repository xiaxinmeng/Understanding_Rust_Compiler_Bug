{"sha": "42b70f17d26630316a2b66251d15a6941d434c4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyYjcwZjE3ZDI2NjMwMzE2YTJiNjYyNTFkMTVhNjk0MWQ0MzRjNGU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-22T09:35:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-22T09:35:36Z"}, "message": "Merge branch 'master' into exit", "tree": {"sha": "4df2b69d617aa37d93d4cc32aa5479e90d37cd60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4df2b69d617aa37d93d4cc32aa5479e90d37cd60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42b70f17d26630316a2b66251d15a6941d434c4e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcvYroCRBK7hj4Ov3rIwAAdHIIAHeH9hFtwfQVHh6+Rg+vAq8w\n9A39IC5fJ5tCBo6wWmHbD2cztAaJkaZS/iFaJgEvMXeEr0R4a/39iksPkNwzZr+D\nwt/Y1XOFaa6oQase2WfyxTwZ1OkSInuUg9pNcqojsalGjKuE20mkj/Mo/gVnAFXU\n+FD4p8f0TIc/lozMQMQTnlW6iVqolB4gNVl84hXjLRFC5rN+eed8R0t+B+rfxP2+\nYk68GHD9eNJRw08vEoRAeDZzn6UBqHIFXRXf3FzOFiT/4xiAy0n1v88iOKDptxOy\nbCLZtTwXvsXJYqb+vOaO8TCpX26JePebBj9kmzy3lsCXsmgHpSV5FIECq0EnAIw=\n=cMD2\n-----END PGP SIGNATURE-----\n", "payload": "tree 4df2b69d617aa37d93d4cc32aa5479e90d37cd60\nparent 6a6c0cd5f0f2e7283f2271f2188280e5ce9b9e69\nparent 1c07cd53e94fad40df70beb3fcf0fdefad849d4c\nauthor Ralf Jung <post@ralfj.de> 1555925736 +0200\ncommitter GitHub <noreply@github.com> 1555925736 +0200\n\nMerge branch 'master' into exit"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42b70f17d26630316a2b66251d15a6941d434c4e", "html_url": "https://github.com/rust-lang/rust/commit/42b70f17d26630316a2b66251d15a6941d434c4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42b70f17d26630316a2b66251d15a6941d434c4e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a6c0cd5f0f2e7283f2271f2188280e5ce9b9e69", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6c0cd5f0f2e7283f2271f2188280e5ce9b9e69", "html_url": "https://github.com/rust-lang/rust/commit/6a6c0cd5f0f2e7283f2271f2188280e5ce9b9e69"}, {"sha": "1c07cd53e94fad40df70beb3fcf0fdefad849d4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c07cd53e94fad40df70beb3fcf0fdefad849d4c", "html_url": "https://github.com/rust-lang/rust/commit/1c07cd53e94fad40df70beb3fcf0fdefad849d4c"}], "stats": {"total": 334, "additions": 217, "deletions": 117}, "files": [{"sha": "62ad675218a4fa491ccdc06797354332bc8c3bad", "filename": "src/fn_call.rs", "status": "modified", "additions": 142, "deletions": 82, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/42b70f17d26630316a2b66251d15a6941d434c4e/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b70f17d26630316a2b66251d15a6941d434c4e/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=42b70f17d26630316a2b66251d15a6941d434c4e", "patch": "@@ -50,6 +50,86 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         Ok(Some(this.load_mir(instance.def)?))\n     }\n \n+    fn malloc(\n+        &mut self,\n+        size: u64,\n+        zero_init: bool,\n+    ) -> Scalar<Tag> {\n+        let this = self.eval_context_mut();\n+        let tcx = &{this.tcx.tcx};\n+        if size == 0 {\n+            Scalar::from_int(0, this.pointer_size())\n+        } else {\n+            let align = this.tcx.data_layout.pointer_align.abi;\n+            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n+            if zero_init {\n+                // We just allocated this, the access cannot fail\n+                this.memory_mut()\n+                    .get_mut(ptr.alloc_id).unwrap()\n+                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size)).unwrap();\n+            }\n+            Scalar::Ptr(ptr)\n+        }\n+    }\n+\n+    fn free(\n+        &mut self,\n+        ptr: Scalar<Tag>,\n+    ) -> EvalResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        if !ptr.is_null_ptr(this) {\n+            this.memory_mut().deallocate(\n+                ptr.to_ptr()?,\n+                None,\n+                MiriMemoryKind::C.into(),\n+            )?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn realloc(\n+        &mut self,\n+        old_ptr: Scalar<Tag>,\n+        new_size: u64,\n+    ) -> EvalResult<'tcx, Scalar<Tag>> {\n+        let this = self.eval_context_mut();\n+        let align = this.tcx.data_layout.pointer_align.abi;\n+        if old_ptr.is_null_ptr(this) {\n+            if new_size == 0 {\n+                Ok(Scalar::from_int(0, this.pointer_size()))\n+            } else {\n+                let new_ptr = this.memory_mut().allocate(\n+                    Size::from_bytes(new_size),\n+                    align,\n+                    MiriMemoryKind::C.into()\n+                );\n+                Ok(Scalar::Ptr(new_ptr))\n+            }\n+        } else {\n+            let old_ptr = old_ptr.to_ptr()?;\n+            let memory = this.memory_mut();\n+            let old_size = Size::from_bytes(memory.get(old_ptr.alloc_id)?.bytes.len() as u64);\n+            if new_size == 0 {\n+                memory.deallocate(\n+                    old_ptr,\n+                    Some((old_size, align)),\n+                    MiriMemoryKind::C.into(),\n+                )?;\n+                Ok(Scalar::from_int(0, this.pointer_size()))\n+            } else {\n+                let new_ptr = memory.reallocate(\n+                    old_ptr,\n+                    old_size,\n+                    align,\n+                    Size::from_bytes(new_size),\n+                    align,\n+                    MiriMemoryKind::C.into(),\n+                )?;\n+                Ok(Scalar::Ptr(new_ptr))\n+            }\n+        }\n+    }\n+\n     /// Emulates calling a foreign item, failing if the item is not supported.\n     /// This function will handle `goto_block` if needed.\n     fn emulate_foreign_item(\n@@ -95,28 +175,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n         match link_name {\n             \"malloc\" => {\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                if size == 0 {\n-                    this.write_null(dest)?;\n-                } else {\n-                    let align = this.tcx.data_layout.pointer_align.abi;\n-                    let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n-                    this.write_scalar(Scalar::Ptr(ptr), dest)?;\n-                }\n+                let res = this.malloc(size, /*zero_init:*/ false);\n+                this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n                 let items = this.read_scalar(args[0])?.to_usize(this)?;\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n-                let bytes = items.checked_mul(len).ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n-\n-                if bytes == 0 {\n-                    this.write_null(dest)?;\n-                } else {\n-                    let size = Size::from_bytes(bytes);\n-                    let align = this.tcx.data_layout.pointer_align.abi;\n-                    let ptr = this.memory_mut().allocate(size, align, MiriMemoryKind::C.into());\n-                    this.memory_mut().get_mut(ptr.alloc_id)?.write_repeat(tcx, ptr, 0, size)?;\n-                    this.write_scalar(Scalar::Ptr(ptr), dest)?;\n-                }\n+                let size = items.checked_mul(len).ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n+                let res = this.malloc(size, /*zero_init:*/ true);\n+                this.write_scalar(res, dest)?;\n             }\n             \"posix_memalign\" => {\n                 let ret = this.deref_operand(args[0])?;\n@@ -144,55 +211,15 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                 }\n                 this.write_null(dest)?;\n             }\n-\n             \"free\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                if !ptr.is_null_ptr(this) {\n-                    this.memory_mut().deallocate(\n-                        ptr.to_ptr()?,\n-                        None,\n-                        MiriMemoryKind::C.into(),\n-                    )?;\n-                }\n+                this.free(ptr)?;\n             }\n             \"realloc\" => {\n                 let old_ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let new_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let align = this.tcx.data_layout.pointer_align.abi;\n-                if old_ptr.is_null_ptr(this) {\n-                    if new_size == 0 {\n-                        this.write_null(dest)?;\n-                    } else {\n-                        let new_ptr = this.memory_mut().allocate(\n-                            Size::from_bytes(new_size),\n-                            align,\n-                            MiriMemoryKind::C.into()\n-                        );\n-                        this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n-                    }\n-                } else {\n-                    let old_ptr = old_ptr.to_ptr()?;\n-                    let memory = this.memory_mut();\n-                    let old_size = Size::from_bytes(memory.get(old_ptr.alloc_id)?.bytes.len() as u64);\n-                    if new_size == 0 {\n-                        memory.deallocate(\n-                            old_ptr,\n-                            Some((old_size, align)),\n-                            MiriMemoryKind::C.into(),\n-                        )?;\n-                        this.write_null(dest)?;\n-                    } else {\n-                        let new_ptr = memory.reallocate(\n-                            old_ptr,\n-                            old_size,\n-                            align,\n-                            Size::from_bytes(new_size),\n-                            align,\n-                            MiriMemoryKind::C.into(),\n-                        )?;\n-                        this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n-                    }\n-                }\n+                let res = this.realloc(old_ptr, new_size)?;\n+                this.write_scalar(res, dest)?;\n             }\n \n             \"__rust_alloc\" => {\n@@ -279,19 +306,14 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n                 // is called if a `HashMap` is created the regular way (e.g. HashMap<K, V>).\n                 match this.read_scalar(args[0])?.to_usize(this)? {\n                     id if id == sys_getrandom => {\n-                        let ptr = this.read_scalar(args[1])?.to_ptr()?;\n+                        let ptr = this.read_scalar(args[1])?.not_undef()?;\n                         let len = this.read_scalar(args[2])?.to_usize(this)?;\n \n                         // The only supported flags are GRND_RANDOM and GRND_NONBLOCK,\n                         // neither of which have any effect on our current PRNG\n                         let _flags = this.read_scalar(args[3])?.to_i32()?;\n \n-                        if len > 0 {\n-                            let data = gen_random(this, len as usize)?;\n-                            this.memory_mut().get_mut(ptr.alloc_id)?\n-                                        .write_bytes(tcx, ptr, &data)?;\n-                        }\n-\n+                        gen_random(this, len as usize, ptr)?;\n                         this.write_scalar(Scalar::from_uint(len, dest.layout.size), dest)?;\n                     }\n                     id => {\n@@ -693,8 +715,43 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             \"_NSGetArgv\" => {\n                 this.write_scalar(Scalar::Ptr(this.machine.argv.unwrap()), dest)?;\n             },\n+            \"SecRandomCopyBytes\" => {\n+                let len = this.read_scalar(args[1])?.to_usize(this)?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                gen_random(this, len as usize, ptr)?;\n+                this.write_null(dest)?;\n+            }\n \n             // Windows API stubs.\n+            // HANDLE = isize\n+            // DWORD = ULONG = u32\n+            \"GetProcessHeap\" => {\n+                // Just fake a HANDLE\n+                this.write_scalar(Scalar::from_int(1, this.pointer_size()), dest)?;\n+            }\n+            \"HeapAlloc\" => {\n+                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let flags = this.read_scalar(args[1])?.to_u32()?;\n+                let size = this.read_scalar(args[2])?.to_usize(this)?;\n+                let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n+                let res = this.malloc(size, zero_init);\n+                this.write_scalar(res, dest)?;\n+            }\n+            \"HeapFree\" => {\n+                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _flags = this.read_scalar(args[1])?.to_u32()?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                this.free(ptr)?;\n+            }\n+            \"HeapReAlloc\" => {\n+                let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n+                let _flags = this.read_scalar(args[1])?.to_u32()?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                let size = this.read_scalar(args[3])?.to_usize(this)?;\n+                let res = this.realloc(ptr, size)?;\n+                this.write_scalar(res, dest)?;\n+            }\n+\n             \"SetLastError\" => {\n                 let err = this.read_scalar(args[0])?.to_u32()?;\n                 this.machine.last_error = err;\n@@ -818,15 +875,9 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n             }\n             // The actual name of 'RtlGenRandom'\n             \"SystemFunction036\" => {\n-                let ptr = this.read_scalar(args[0])?.to_ptr()?;\n+                let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let len = this.read_scalar(args[1])?.to_u32()?;\n-\n-                if len > 0 {\n-                    let data = gen_random(this, len as usize)?;\n-                    this.memory_mut().get_mut(ptr.alloc_id)?\n-                        .write_bytes(tcx, ptr, &data)?;\n-                }\n-\n+                gen_random(this, len as usize, ptr)?;\n                 this.write_scalar(Scalar::from_bool(true), dest)?;\n             }\n \n@@ -867,21 +918,30 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a + 'mir>: crate::MiriEvalContextExt<'\n fn gen_random<'a, 'mir, 'tcx>(\n     this: &mut MiriEvalContext<'a, 'mir, 'tcx>,\n     len: usize,\n-) -> Result<Vec<u8>, EvalError<'tcx>>  {\n+    dest: Scalar<Tag>,\n+) -> EvalResult<'tcx>  {\n+    if len == 0 {\n+        // Nothing to do\n+        return Ok(());\n+    }\n+    let ptr = dest.to_ptr()?;\n \n-    match &mut this.machine.rng {\n+    let data = match &mut this.machine.rng {\n         Some(rng) => {\n             let mut data = vec![0; len];\n             rng.fill_bytes(&mut data);\n-            Ok(data)\n+            data\n         }\n         None => {\n-            err!(Unimplemented(\n+            return err!(Unimplemented(\n                 \"miri does not support gathering system entropy in deterministic mode!\n                 Use '-Zmiri-seed=<seed>' to enable random number generation.\n                 WARNING: Miri does *not* generate cryptographically secure entropy -\n                 do not use Miri to run any program that needs secure random number generation\".to_owned(),\n-            ))\n+            ));\n         }\n-    }\n+    };\n+    let tcx = &{this.tcx.tcx};\n+    this.memory_mut().get_mut(ptr.alloc_id)?\n+        .write_bytes(tcx, ptr, &data)\n }"}, {"sha": "33664737709c0771306695a3d4d4fd00e3e8a385", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/42b70f17d26630316a2b66251d15a6941d434c4e/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/42b70f17d26630316a2b66251d15a6941d434c4e/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=42b70f17d26630316a2b66251d15a6941d434c4e", "patch": "@@ -5,12 +5,18 @@\n and the working directory to contain the cargo-miri-test project.\n '''\n \n-import sys, subprocess\n+import sys, subprocess, os\n \n def fail(msg):\n     print(\"TEST FAIL: {}\".format(msg))\n     sys.exit(1)\n \n+def cargo_miri(cmd):\n+    args = [\"cargo\", \"miri\", cmd, \"-q\"]\n+    if 'MIRI_TEST_TARGET' in os.environ:\n+        args += [\"--target\", os.environ['MIRI_TEST_TARGET']]\n+    return args\n+\n def test(name, cmd, stdout_ref, stderr_ref):\n     print(\"==> Testing `{}` <==\".format(name))\n     ## Call `cargo miri`, capture all output\n@@ -36,20 +42,29 @@ def test(name, cmd, stdout_ref, stderr_ref):\n         fail(\"stderr does not match reference\")\n \n def test_cargo_miri_run():\n-    test(\"cargo miri run\", [\"cargo\", \"miri\", \"run\", \"-q\"], \"stdout.ref\", \"stderr.ref\")\n+    test(\"cargo miri run\",\n+        cargo_miri(\"run\"),\n+        \"stdout.ref\", \"stderr.ref\"\n+    )\n     test(\"cargo miri run (with arguments)\",\n-        [\"cargo\", \"miri\", \"run\", \"-q\", \"--\", \"--\", \"hello world\", '\"hello world\"'],\n+        cargo_miri(\"run\") + [\"--\", \"--\", \"hello world\", '\"hello world\"'],\n         \"stdout.ref\", \"stderr.ref2\"\n     )\n \n def test_cargo_miri_test():\n-    test(\"cargo miri test\", [\"cargo\", \"miri\", \"test\", \"-q\", \"--\", \"-Zmiri-seed=feed\"], \"test.stdout.ref\", \"test.stderr.ref\")\n+    test(\"cargo miri test\",\n+        cargo_miri(\"test\") + [\"--\", \"-Zmiri-seed=feed\"],\n+        \"test.stdout.ref\", \"test.stderr.ref\"\n+    )\n     test(\"cargo miri test (with filter)\",\n-        [\"cargo\", \"miri\", \"test\", \"-q\", \"--\", \"--\", \"impl\"],\n+        cargo_miri(\"test\") + [\"--\", \"--\", \"impl\"],\n         \"test.stdout.ref2\", \"test.stderr.ref\"\n     )\n \n+os.chdir(os.path.dirname(os.path.realpath(__file__)))\n+\n test_cargo_miri_run()\n test_cargo_miri_test()\n+\n print(\"TEST SUCCESSFUL!\")\n sys.exit(0)"}, {"sha": "ce15824f94a225dada3bf6b3e45abdac62083ee1", "filename": "test-cargo-miri/tests/test.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/42b70f17d26630316a2b66251d15a6941d434c4e/test-cargo-miri%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b70f17d26630316a2b66251d15a6941d434c4e/test-cargo-miri%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Ftests%2Ftest.rs?ref=42b70f17d26630316a2b66251d15a6941d434c4e", "patch": "@@ -1,7 +1,3 @@\n-#![allow(unused_imports)] // FIXME for macOS\n-\n-extern crate rand;\n-\n use rand::{SeedableRng, FromEntropy, Rng, rngs::SmallRng};\n \n #[test]\n@@ -21,17 +17,13 @@ fn fixed_rng() {\n \n #[test]\n fn entropy_rng() {\n-    #[cfg(not(target_os=\"macos\"))] // FIXME entropy does not work on macOS\n-    // (Not disabling the entire test as that would change the output.)\n-    {\n-        // Use this opportunity to test querying the RNG (needs an external crate, hence tested here and not in the compiletest suite)\n-        let mut rng = SmallRng::from_entropy();\n-        let _val = rng.gen::<i32>();\n+    // Use this opportunity to test querying the RNG (needs an external crate, hence tested here and not in the compiletest suite)\n+    let mut rng = SmallRng::from_entropy();\n+    let _val = rng.gen::<i32>();\n \n-        // Also try per-thread RNG.\n-        let mut rng = rand::thread_rng();\n-        let _val = rng.gen::<i32>();\n-    }\n+    // Also try per-thread RNG.\n+    let mut rng = rand::thread_rng();\n+    let _val = rng.gen::<i32>();\n }\n \n // A test that won't work on miri"}, {"sha": "7f2c8966472fbdf06aa62796916abcc0ea3c61a8", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42b70f17d26630316a2b66251d15a6941d434c4e/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b70f17d26630316a2b66251d15a6941d434c4e/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=42b70f17d26630316a2b66251d15a6941d434c4e", "patch": "@@ -101,7 +101,7 @@ fn get_host() -> String {\n }\n \n fn get_target() -> String {\n-    std::env::var(\"MIRI_COMPILETEST_TARGET\").unwrap_or_else(|_| get_host())\n+    std::env::var(\"MIRI_TEST_TARGET\").unwrap_or_else(|_| get_host())\n }\n \n fn run_pass_miri(opt: bool) {"}, {"sha": "91e15f249d452dc4539431464549ebc974766afb", "filename": "tests/run-pass/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/42b70f17d26630316a2b66251d15a6941d434c4e/tests%2Frun-pass%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b70f17d26630316a2b66251d15a6941d434c4e/tests%2Frun-pass%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fenv.rs?ref=42b70f17d26630316a2b66251d15a6941d434c4e", "patch": "@@ -1,4 +1,4 @@\n-//ignore-windows: env var emulation not implemented on Windows\n+//ignore-windows: TODO env var emulation stubbed out on Windows\n \n use std::env;\n "}, {"sha": "25a816bcf2454df0d074259e3aaafcffe7ba43e6", "filename": "tests/run-pass/hashmap.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/42b70f17d26630316a2b66251d15a6941d434c4e/tests%2Frun-pass%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b70f17d26630316a2b66251d15a6941d434c4e/tests%2Frun-pass%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fhashmap.rs?ref=42b70f17d26630316a2b66251d15a6941d434c4e", "patch": "@@ -27,13 +27,12 @@ fn test_map<S: BuildHasher>(mut map: HashMap<i32, i32, S>) {\n }\n \n fn main() {\n-    if cfg!(not(target_os = \"macos\")) {\n-        let map: HashMap<i32, i32> = HashMap::default();\n-        test_map(map);\n-    } else {\n-        // TODO: Implement random number generation on OS X.\n+    if cfg!(target_os = \"macos\") { // TODO: Implement random number generation on OS X.\n         // Until then, use a deterministic map.\n         let map : HashMap<i32, i32, BuildHasherDefault<collections::hash_map::DefaultHasher>> = HashMap::default();\n         test_map(map);\n+    } else {\n+        let map: HashMap<i32, i32> = HashMap::default();\n+        test_map(map);\n     }\n }"}, {"sha": "b201f24e25634b37c2fc2d2b73c047c32928f617", "filename": "tests/run-pass/heap_allocator.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/42b70f17d26630316a2b66251d15a6941d434c4e/tests%2Frun-pass%2Fheap_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42b70f17d26630316a2b66251d15a6941d434c4e/tests%2Frun-pass%2Fheap_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fheap_allocator.rs?ref=42b70f17d26630316a2b66251d15a6941d434c4e", "patch": "@@ -1,9 +1,32 @@\n-//ignore-windows: inspects allocation base address on Windows\n-\n #![feature(allocator_api)]\n \n use std::ptr::NonNull;\n use std::alloc::{Global, Alloc, Layout, System};\n+use std::slice;\n+\n+fn check_alloc<T: Alloc>(mut allocator: T) { unsafe {\n+    let layout = Layout::from_size_align(20, 4).unwrap();\n+    let a = allocator.alloc(layout).unwrap();\n+    allocator.dealloc(a, layout);\n+\n+    let p1 = allocator.alloc_zeroed(layout).unwrap();\n+\n+    let p2 = allocator.realloc(p1, Layout::from_size_align(20, 4).unwrap(), 40).unwrap();\n+    let slice = slice::from_raw_parts(p2.as_ptr(), 20);\n+    assert_eq!(&slice, &[0_u8; 20]);\n+\n+    // old size == new size\n+    let p3 = allocator.realloc(p2, Layout::from_size_align(40, 4).unwrap(), 40).unwrap();\n+    let slice = slice::from_raw_parts(p3.as_ptr(), 20);\n+    assert_eq!(&slice, &[0_u8; 20]);\n+\n+    // old size > new size\n+    let p4 = allocator.realloc(p3, Layout::from_size_align(40, 4).unwrap(), 10).unwrap();\n+    let slice = slice::from_raw_parts(p4.as_ptr(), 10);\n+    assert_eq!(&slice, &[0_u8; 10]);\n+\n+    allocator.dealloc(p4, Layout::from_size_align(10, 4).unwrap());\n+} }\n \n fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n     let size = 8;\n@@ -50,6 +73,9 @@ fn box_to_global() {\n }\n \n fn main() {\n+    check_alloc(System);\n+    check_alloc(Global);\n+    #[cfg(not(target_os = \"windows\"))] // TODO: Inspects allocation base address on Windows; needs intptrcast model\n     check_overalign_requests(System);\n     check_overalign_requests(Global);\n     global_to_box();"}, {"sha": "84f9c408dcba5c84cef754aa320a1ac513d3f72c", "filename": "travis.sh", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/42b70f17d26630316a2b66251d15a6941d434c4e/travis.sh", "raw_url": "https://github.com/rust-lang/rust/raw/42b70f17d26630316a2b66251d15a6941d434c4e/travis.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/travis.sh?ref=42b70f17d26630316a2b66251d15a6941d434c4e", "patch": "@@ -3,13 +3,14 @@ set -euo pipefail\n \n # Determine configuration\n if [ \"$TRAVIS_OS_NAME\" == osx ]; then\n-  export MIRI_SYSROOT_BASE=~/Library/Caches/miri.miri.miri/\n+  MIRI_SYSROOT_BASE=~/Library/Caches/miri.miri.miri/\n   FOREIGN_TARGET=i686-apple-darwin\n else\n-  export MIRI_SYSROOT_BASE=~/.cache/miri/\n+  MIRI_SYSROOT_BASE=~/.cache/miri/\n   FOREIGN_TARGET=i686-unknown-linux-gnu\n fi\n \n+# Prepare\n echo \"Build and install miri\"\n cargo build --release --all-features --all-targets\n cargo install --all-features --force --path .\n@@ -20,11 +21,18 @@ cargo miri setup\n cargo miri setup --target \"$FOREIGN_TARGET\"\n echo\n \n-echo \"Test miri with full MIR, on the host and other architectures\"\n-MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\"/HOST cargo test --release --all-features\n-MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\" MIRI_COMPILETEST_TARGET=\"$FOREIGN_TARGET\" cargo test --release --all-features\n+# Test\n+function run_tests {\n+  cargo test --release --all-features\n+  test-cargo-miri/run-test.py\n+}\n+\n+echo \"Test host architecture\"\n+export MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\"/HOST\n+run_tests\n echo\n \n-echo \"Test cargo integration\"\n-(cd test-cargo-miri && MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\"/HOST ./run-test.py)\n+echo \"Test foreign architecture ($FOREIGN_TARGET)\"\n+export MIRI_SYSROOT=\"$MIRI_SYSROOT_BASE\" MIRI_TEST_TARGET=\"$FOREIGN_TARGET\"\n+run_tests\n echo"}]}