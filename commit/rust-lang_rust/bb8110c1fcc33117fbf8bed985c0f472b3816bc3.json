{"sha": "bb8110c1fcc33117fbf8bed985c0f472b3816bc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiODExMGMxZmNjMzMxMTdmYmY4YmVkOTg1YzBmNDcyYjM4MTZiYzM=", "commit": {"author": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-19T01:30:15Z"}, "committer": {"name": "Mark Mansi", "email": "markm@cs.wisc.edu", "date": "2018-01-30T18:30:41Z"}, "message": "Update the macro parser to allow at most once repetitions for `?` Kleene", "tree": {"sha": "c3d3d931b7cfd51ef922011b7825a0ca01fcebad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3d3d931b7cfd51ef922011b7825a0ca01fcebad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb8110c1fcc33117fbf8bed985c0f472b3816bc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb8110c1fcc33117fbf8bed985c0f472b3816bc3", "html_url": "https://github.com/rust-lang/rust/commit/bb8110c1fcc33117fbf8bed985c0f472b3816bc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb8110c1fcc33117fbf8bed985c0f472b3816bc3/comments", "author": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mark-i-m", "id": 8827840, "node_id": "MDQ6VXNlcjg4Mjc4NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/8827840?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mark-i-m", "html_url": "https://github.com/mark-i-m", "followers_url": "https://api.github.com/users/mark-i-m/followers", "following_url": "https://api.github.com/users/mark-i-m/following{/other_user}", "gists_url": "https://api.github.com/users/mark-i-m/gists{/gist_id}", "starred_url": "https://api.github.com/users/mark-i-m/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mark-i-m/subscriptions", "organizations_url": "https://api.github.com/users/mark-i-m/orgs", "repos_url": "https://api.github.com/users/mark-i-m/repos", "events_url": "https://api.github.com/users/mark-i-m/events{/privacy}", "received_events_url": "https://api.github.com/users/mark-i-m/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "760879bc88b2884275b59fc38e0c5b1a8632e4cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/760879bc88b2884275b59fc38e0c5b1a8632e4cd", "html_url": "https://github.com/rust-lang/rust/commit/760879bc88b2884275b59fc38e0c5b1a8632e4cd"}], "stats": {"total": 38, "additions": 22, "deletions": 16}, "files": [{"sha": "88144b19609800357b8d2cb07aee0d845d007c0b", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bb8110c1fcc33117fbf8bed985c0f472b3816bc3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb8110c1fcc33117fbf8bed985c0f472b3816bc3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=bb8110c1fcc33117fbf8bed985c0f472b3816bc3", "patch": "@@ -486,8 +486,8 @@ fn inner_parse_loop(\n             match item.top_elts.get_tt(idx) {\n                 // Need to descend into a sequence\n                 TokenTree::Sequence(sp, seq) => {\n-                    if seq.op == quoted::KleeneOp::ZeroOrMore {\n-                        // Examine the case where there are 0 matches of this sequence\n+                    // Examine the case where there are 0 matches of this sequence\n+                    if seq.op == quoted::KleeneOp::ZeroOrMore || seq.op == quoted::KleeneOp::ZeroOrOne {\n                         let mut new_item = item.clone();\n                         new_item.match_cur += seq.num_captures;\n                         new_item.idx += 1;\n@@ -497,20 +497,26 @@ fn inner_parse_loop(\n                         cur_items.push(new_item);\n                     }\n \n-                    // Examine the case where there is at least one match of this sequence\n-                    let matches = create_matches(item.matches.len());\n-                    cur_items.push(Box::new(MatcherPos {\n-                        stack: vec![],\n-                        sep: seq.separator.clone(),\n-                        idx: 0,\n-                        matches,\n-                        match_lo: item.match_cur,\n-                        match_cur: item.match_cur,\n-                        match_hi: item.match_cur + seq.num_captures,\n-                        up: Some(item),\n-                        sp_lo: sp.lo(),\n-                        top_elts: Tt(TokenTree::Sequence(sp, seq)),\n-                    }));\n+                    // For ZeroOrMore and OneOrMore, we want to examine the case were there is at\n+                    // least one match. For ZeroOrOne, we only want the case where there is exactly\n+                    // one match.\n+                    if (seq.op == quoted::KleeneOp::ZeroOrOne && seq.num_captures == 1) ||\n+                        seq.op != quoted::KleeneOp::ZeroOrOne {\n+\n+                        let matches = create_matches(item.matches.len());\n+                        cur_items.push(Box::new(MatcherPos {\n+                            stack: vec![],\n+                            sep: seq.separator.clone(),\n+                            idx: 0,\n+                            matches,\n+                            match_lo: item.match_cur,\n+                            match_cur: item.match_cur,\n+                            match_hi: item.match_cur + seq.num_captures,\n+                            up: Some(item),\n+                            sp_lo: sp.lo(),\n+                            top_elts: Tt(TokenTree::Sequence(sp, seq)),\n+                        }));\n+                    }\n                 }\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error"}]}