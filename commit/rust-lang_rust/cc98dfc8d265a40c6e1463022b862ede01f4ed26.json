{"sha": "cc98dfc8d265a40c6e1463022b862ede01f4ed26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOThkZmM4ZDI2NWE0MGM2ZTE0NjMwMjJiODYyZWRlMDFmNGVkMjY=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-03-23T03:37:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-03-23T03:37:59Z"}, "message": "Rollup merge of #40518 - michaelwoerister:hir-id, r=eddyb\n\nIntroduce HirId, a replacement for ast::NodeId after lowering to HIR\n\nThis is the first step towards implementing #40303. This PR introduces the `HirId` type and generates a `HirId` for everything that would be assigned one (i.e. stuff in the HIR), but the HIR data types still use `NodeId` for now. Changing that is a big refactoring that I want to do in a separate PR.\n\nA `HirId` uniquely identifies a node in the HIR of the current crate. It is composed of the `owner`, which is the `DefIndex` of the directly enclosing `hir::Item`, `hir::TraitItem`, or `hir::ImplItem` (i.e. the closest \"item-like\"), and the `local_id` which is unique within the given owner.\n\nThis PR is also running a number of consistency checks for the generated `HirId`s:\n- Does `NodeId` in the HIR have a corresponding `HirId`?\n- Is the `owner` part of each `HirId` consistent with its position in the HIR?\n- Do the numerical values of the `local_id` part all lie within a dense range of integers?\n\ncc @rust-lang/compiler\n\nr? @eddyb or @nikomatsakis", "tree": {"sha": "220e5c46fa60e35de9d2f3154c3a37243b4e6d15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/220e5c46fa60e35de9d2f3154c3a37243b4e6d15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc98dfc8d265a40c6e1463022b862ede01f4ed26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc98dfc8d265a40c6e1463022b862ede01f4ed26", "html_url": "https://github.com/rust-lang/rust/commit/cc98dfc8d265a40c6e1463022b862ede01f4ed26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc98dfc8d265a40c6e1463022b862ede01f4ed26/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "916c0b83ccabea3be0ee7b4861c56a9ef44b6804", "url": "https://api.github.com/repos/rust-lang/rust/commits/916c0b83ccabea3be0ee7b4861c56a9ef44b6804", "html_url": "https://github.com/rust-lang/rust/commit/916c0b83ccabea3be0ee7b4861c56a9ef44b6804"}, {"sha": "090767b5ef59188e5defb466ff6580b99891f1ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/090767b5ef59188e5defb466ff6580b99891f1ed", "html_url": "https://github.com/rust-lang/rust/commit/090767b5ef59188e5defb466ff6580b99891f1ed"}], "stats": {"total": 2400, "additions": 1541, "deletions": 859}, "files": [{"sha": "a6b18ac10a79074bb35d0c3e39a5c590fce391f5", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -78,33 +78,86 @@ impl serialize::UseSpecializedDecodable for CrateNum {\n /// A DefIndex is an index into the hir-map for a crate, identifying a\n /// particular definition. It should really be considered an interned\n /// shorthand for a particular DefPath.\n+///\n+/// At the moment we are allocating the numerical values of DefIndexes into two\n+/// ranges: the \"low\" range (starting at zero) and the \"high\" range (starting at\n+/// DEF_INDEX_HI_START). This allows us to allocate the DefIndexes of all\n+/// item-likes (Items, TraitItems, and ImplItems) into one of these ranges and\n+/// consequently use a simple array for lookup tables keyed by DefIndex and\n+/// known to be densely populated. This is especially important for the HIR map.\n+///\n+/// Since the DefIndex is mostly treated as an opaque ID, you probably\n+/// don't have to care about these ranges.\n #[derive(Clone, Debug, Eq, Ord, PartialOrd, PartialEq, RustcEncodable,\n            RustcDecodable, Hash, Copy)]\n pub struct DefIndex(u32);\n \n impl DefIndex {\n+    #[inline]\n     pub fn new(x: usize) -> DefIndex {\n         assert!(x < (u32::MAX as usize));\n         DefIndex(x as u32)\n     }\n \n+    #[inline]\n     pub fn from_u32(x: u32) -> DefIndex {\n         DefIndex(x)\n     }\n \n+    #[inline]\n     pub fn as_usize(&self) -> usize {\n         self.0 as usize\n     }\n \n+    #[inline]\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n+\n+    #[inline]\n+    pub fn address_space(&self) -> DefIndexAddressSpace {\n+        if self.0 < DEF_INDEX_HI_START.0 {\n+            DefIndexAddressSpace::Low\n+        } else {\n+            DefIndexAddressSpace::High\n+        }\n+    }\n+\n+    /// Converts this DefIndex into a zero-based array index.\n+    /// This index is the offset within the given \"range\" of the DefIndex,\n+    /// that is, if the DefIndex is part of the \"high\" range, the resulting\n+    /// index will be (DefIndex - DEF_INDEX_HI_START).\n+    #[inline]\n+    pub fn as_array_index(&self) -> usize {\n+        (self.0 & !DEF_INDEX_HI_START.0) as usize\n+    }\n }\n \n+/// The start of the \"high\" range of DefIndexes.\n+const DEF_INDEX_HI_START: DefIndex = DefIndex(1 << 31);\n+\n /// The crate root is always assigned index 0 by the AST Map code,\n /// thanks to `NodeCollector::new`.\n pub const CRATE_DEF_INDEX: DefIndex = DefIndex(0);\n \n+#[derive(Copy, Clone, Eq, PartialEq, Hash)]\n+pub enum DefIndexAddressSpace {\n+    Low = 0,\n+    High = 1,\n+}\n+\n+impl DefIndexAddressSpace {\n+    #[inline]\n+    pub fn index(&self) -> usize {\n+        *self as usize\n+    }\n+\n+    #[inline]\n+    pub fn start(&self) -> usize {\n+        self.index() * DEF_INDEX_HI_START.as_usize()\n+    }\n+}\n+\n /// A DefId identifies a particular *definition*, by combining a crate\n /// index and a def index.\n #[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]"}, {"sha": "2ac1a036f99e1a996a85f60c1f653c0693474181", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 1006, "deletions": 774, "changes": 1780, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26"}, {"sha": "cae358a303e028ea17a60d9a7745d30de4af558b", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -9,13 +9,15 @@\n // except according to those terms.\n \n use hir::map::definitions::*;\n-use hir::def_id::{CRATE_DEF_INDEX, DefIndex};\n+use hir::def_id::{CRATE_DEF_INDEX, DefIndex, DefIndexAddressSpace};\n \n use syntax::ast::*;\n use syntax::ext::hygiene::Mark;\n use syntax::visit;\n use syntax::symbol::{Symbol, keywords};\n \n+use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n+\n /// Creates def ids for nodes in the AST.\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n@@ -39,23 +41,31 @@ impl<'a> DefCollector<'a> {\n     }\n \n     pub fn collect_root(&mut self) {\n-        let root = self.create_def_with_parent(None, CRATE_NODE_ID, DefPathData::CrateRoot);\n+        let root = self.create_def_with_parent(None,\n+                                               CRATE_NODE_ID,\n+                                               DefPathData::CrateRoot,\n+                                               ITEM_LIKE_SPACE);\n         assert_eq!(root, CRATE_DEF_INDEX);\n         self.parent_def = Some(root);\n     }\n \n-    fn create_def(&mut self, node_id: NodeId, data: DefPathData) -> DefIndex {\n+    fn create_def(&mut self,\n+                  node_id: NodeId,\n+                  data: DefPathData,\n+                  address_space: DefIndexAddressSpace)\n+                  -> DefIndex {\n         let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data)\n+        self.definitions.create_def_with_parent(parent_def, node_id, data, address_space)\n     }\n \n     fn create_def_with_parent(&mut self,\n                               parent: Option<DefIndex>,\n                               node_id: NodeId,\n-                              data: DefPathData)\n+                              data: DefPathData,\n+                              address_space: DefIndexAddressSpace)\n                               -> DefIndex {\n-        self.definitions.create_def_with_parent(parent, node_id, data)\n+        self.definitions.create_def_with_parent(parent, node_id, data, address_space)\n     }\n \n     pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n@@ -76,7 +86,7 @@ impl<'a> DefCollector<'a> {\n             _ => {}\n         }\n \n-        self.create_def(expr.id, DefPathData::Initializer);\n+        self.create_def(expr.id, DefPathData::Initializer, REGULAR_SPACE);\n     }\n \n     fn visit_macro_invoc(&mut self, id: NodeId, const_expr: bool) {\n@@ -118,27 +128,32 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     ViewPathSimple(..) => {}\n                     ViewPathList(_, ref imports) => {\n                         for import in imports {\n-                            self.create_def(import.node.id, DefPathData::Misc);\n+                            self.create_def(import.node.id,\n+                                            DefPathData::Misc,\n+                                            ITEM_LIKE_SPACE);\n                         }\n                     }\n                 }\n                 DefPathData::Misc\n             }\n         };\n-        let def = self.create_def(i.id, def_data);\n+        let def = self.create_def(i.id, def_data, ITEM_LIKE_SPACE);\n \n         self.with_parent(def, |this| {\n             match i.node {\n                 ItemKind::Enum(ref enum_definition, _) => {\n                     for v in &enum_definition.variants {\n                         let variant_def_index =\n                             this.create_def(v.node.data.id(),\n-                                            DefPathData::EnumVariant(v.node.name.name.as_str()));\n+                                            DefPathData::EnumVariant(v.node.name.name.as_str()),\n+                                            REGULAR_SPACE);\n                         this.with_parent(variant_def_index, |this| {\n                             for (index, field) in v.node.data.fields().iter().enumerate() {\n                                 let name = field.ident.map(|ident| ident.name)\n                                     .unwrap_or_else(|| Symbol::intern(&index.to_string()));\n-                                this.create_def(field.id, DefPathData::Field(name.as_str()));\n+                                this.create_def(field.id,\n+                                                DefPathData::Field(name.as_str()),\n+                                                REGULAR_SPACE);\n                             }\n \n                             if let Some(ref expr) = v.node.disr_expr {\n@@ -151,13 +166,14 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     // If this is a tuple-like struct, register the constructor.\n                     if !struct_def.is_struct() {\n                         this.create_def(struct_def.id(),\n-                                        DefPathData::StructCtor);\n+                                        DefPathData::StructCtor,\n+                                        REGULAR_SPACE);\n                     }\n \n                     for (index, field) in struct_def.fields().iter().enumerate() {\n                         let name = field.ident.map(|ident| ident.name.as_str())\n                             .unwrap_or(Symbol::intern(&index.to_string()).as_str());\n-                        this.create_def(field.id, DefPathData::Field(name));\n+                        this.create_def(field.id, DefPathData::Field(name), REGULAR_SPACE);\n                     }\n                 }\n                 _ => {}\n@@ -168,7 +184,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()));\n+                                  DefPathData::ValueNs(foreign_item.ident.name.as_str()),\n+                                  REGULAR_SPACE);\n \n         self.with_parent(def, |this| {\n             visit::walk_foreign_item(this, foreign_item);\n@@ -177,7 +194,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name.as_str()));\n+            self.create_def(ty_param.id,\n+                            DefPathData::TypeParam(ty_param.ident.name.as_str()),\n+                            REGULAR_SPACE);\n         }\n \n         visit::walk_generics(self, generics);\n@@ -191,7 +210,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id, false),\n         };\n \n-        let def = self.create_def(ti.id, def_data);\n+        let def = self.create_def(ti.id, def_data, ITEM_LIKE_SPACE);\n         self.with_parent(def, |this| {\n             if let TraitItemKind::Const(_, Some(ref expr)) = ti.node {\n                 this.visit_const_expr(expr);\n@@ -209,7 +228,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id, false),\n         };\n \n-        let def = self.create_def(ii.id, def_data);\n+        let def = self.create_def(ii.id, def_data, ITEM_LIKE_SPACE);\n         self.with_parent(def, |this| {\n             if let ImplItemKind::Const(_, ref expr) = ii.node {\n                 this.visit_const_expr(expr);\n@@ -225,7 +244,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         match pat.node {\n             PatKind::Mac(..) => return self.visit_macro_invoc(pat.id, false),\n             PatKind::Ident(_, id, _) => {\n-                let def = self.create_def(pat.id, DefPathData::Binding(id.node.name.as_str()));\n+                let def = self.create_def(pat.id,\n+                                          DefPathData::Binding(id.node.name.as_str()),\n+                                          REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n             _ => {}\n@@ -242,7 +263,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id, false),\n             ExprKind::Repeat(_, ref count) => self.visit_const_expr(count),\n             ExprKind::Closure(..) => {\n-                let def = self.create_def(expr.id, DefPathData::ClosureExpr);\n+                let def = self.create_def(expr.id,\n+                                          DefPathData::ClosureExpr,\n+                                          REGULAR_SPACE);\n                 self.parent_def = Some(def);\n             }\n             _ => {}\n@@ -257,7 +280,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n             TyKind::Array(_, ref length) => self.visit_const_expr(length),\n             TyKind::ImplTrait(..) => {\n-                self.create_def(ty.id, DefPathData::ImplTrait);\n+                self.create_def(ty.id, DefPathData::ImplTrait, REGULAR_SPACE);\n             }\n             TyKind::Typeof(ref expr) => self.visit_const_expr(expr),\n             _ => {}\n@@ -266,7 +289,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n-        self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n+        self.create_def(def.lifetime.id,\n+                        DefPathData::LifetimeDef(def.lifetime.name.as_str()),\n+                        REGULAR_SPACE);\n     }\n \n     fn visit_stmt(&mut self, stmt: &'a Stmt) {"}, {"sha": "809d5db3071d7be75607974035a056b28ef3c377", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 108, "deletions": 26, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -14,8 +14,10 @@\n //! There are also some rather random cases (like const initializer\n //! expressions) that are mostly just leftovers.\n \n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use hir;\n+use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace};\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n@@ -29,24 +31,44 @@ use util::nodemap::NodeMap;\n /// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n /// stores the DefIndex of its parent.\n /// There is one DefPathTable for each crate.\n-#[derive(Clone)]\n pub struct DefPathTable {\n-    index_to_key: Vec<DefKey>,\n+    index_to_key: [Vec<DefKey>; 2],\n     key_to_index: FxHashMap<DefKey, DefIndex>,\n }\n \n+// Unfortunately we have to provide a manual impl of Clone because of the\n+// fixed-sized array field.\n+impl Clone for DefPathTable {\n+    fn clone(&self) -> Self {\n+        DefPathTable {\n+            index_to_key: [self.index_to_key[0].clone(),\n+                           self.index_to_key[1].clone()],\n+            key_to_index: self.key_to_index.clone(),\n+        }\n+    }\n+}\n+\n impl DefPathTable {\n-    fn insert(&mut self, key: DefKey) -> DefIndex {\n-        let index = DefIndex::new(self.index_to_key.len());\n-        debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n-        self.index_to_key.push(key.clone());\n+\n+    fn allocate(&mut self,\n+                key: DefKey,\n+                address_space: DefIndexAddressSpace)\n+                -> DefIndex {\n+        let index = {\n+            let index_to_key = &mut self.index_to_key[address_space.index()];\n+            let index = DefIndex::new(index_to_key.len() + address_space.start());\n+            debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n+            index_to_key.push(key.clone());\n+            index\n+        };\n         self.key_to_index.insert(key, index);\n         index\n     }\n \n     #[inline(always)]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.index_to_key[index.as_usize()].clone()\n+        self.index_to_key[index.address_space().index()]\n+                         [index.as_array_index()].clone()\n     }\n \n     #[inline(always)]\n@@ -94,17 +116,28 @@ impl DefPathTable {\n \n impl Encodable for DefPathTable {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        self.index_to_key.encode(s)\n+        self.index_to_key[DefIndexAddressSpace::Low.index()].encode(s)?;\n+        self.index_to_key[DefIndexAddressSpace::High.index()].encode(s)\n     }\n }\n \n impl Decodable for DefPathTable {\n     fn decode<D: Decoder>(d: &mut D) -> Result<DefPathTable, D::Error> {\n-        let index_to_key: Vec<DefKey> = Decodable::decode(d)?;\n-        let key_to_index = index_to_key.iter()\n-                                       .enumerate()\n-                                       .map(|(index, key)| (key.clone(), DefIndex::new(index)))\n-                                       .collect();\n+        let index_to_key_lo: Vec<DefKey> = Decodable::decode(d)?;\n+        let index_to_key_high: Vec<DefKey> = Decodable::decode(d)?;\n+\n+        let index_to_key = [index_to_key_lo, index_to_key_high];\n+\n+        let mut key_to_index = FxHashMap();\n+\n+        for space in &[DefIndexAddressSpace::Low, DefIndexAddressSpace::High] {\n+            key_to_index.extend(index_to_key[space.index()]\n+                .iter()\n+                .enumerate()\n+                .map(|(index, key)| (key.clone(),\n+                                     DefIndex::new(index + space.start()))))\n+        }\n+\n         Ok(DefPathTable {\n             index_to_key: index_to_key,\n             key_to_index: key_to_index,\n@@ -116,11 +149,27 @@ impl Decodable for DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n /// mapping from NodeIds to local DefIds.\n-#[derive(Clone)]\n pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n-    def_index_to_node: Vec<ast::NodeId>,\n+    def_index_to_node: [Vec<ast::NodeId>; 2],\n+    pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n+}\n+\n+// Unfortunately we have to provide a manual impl of Clone because of the\n+// fixed-sized array field.\n+impl Clone for Definitions {\n+    fn clone(&self) -> Self {\n+        Definitions {\n+            table: self.table.clone(),\n+            node_to_def_index: self.node_to_def_index.clone(),\n+            def_index_to_node: [\n+                self.def_index_to_node[0].clone(),\n+                self.def_index_to_node[1].clone(),\n+            ],\n+            node_to_hir_id: self.node_to_hir_id.clone(),\n+        }\n+    }\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -206,6 +255,23 @@ impl DefPath {\n         s\n     }\n \n+    /// Returns a string representation of the DefPath without\n+    /// the crate-prefix. This method is useful if you don't have\n+    /// a TyCtxt available.\n+    pub fn to_string_no_crate(&self) -> String {\n+        let mut s = String::with_capacity(self.data.len() * 16);\n+\n+        for component in &self.data {\n+            write!(s,\n+                   \"::{}[{}]\",\n+                   component.data.as_interned_str(),\n+                   component.disambiguator)\n+                .unwrap();\n+        }\n+\n+        s\n+    }\n+\n     pub fn deterministic_hash(&self, tcx: TyCtxt) -> u64 {\n         debug!(\"deterministic_hash({:?})\", self);\n         let mut state = StableHasher::new();\n@@ -270,11 +336,12 @@ impl Definitions {\n     pub fn new() -> Definitions {\n         Definitions {\n             table: DefPathTable {\n-                index_to_key: vec![],\n+                index_to_key: [vec![], vec![]],\n                 key_to_index: FxHashMap(),\n             },\n             node_to_def_index: NodeMap(),\n-            def_index_to_node: vec![],\n+            def_index_to_node: [vec![], vec![]],\n+            node_to_hir_id: IndexVec::new(),\n         }\n     }\n \n@@ -283,8 +350,9 @@ impl Definitions {\n     }\n \n     /// Get the number of definitions.\n-    pub fn len(&self) -> usize {\n-        self.def_index_to_node.len()\n+    pub fn def_index_counts_lo_hi(&self) -> (usize, usize) {\n+        (self.def_index_to_node[DefIndexAddressSpace::Low.index()].len(),\n+         self.def_index_to_node[DefIndexAddressSpace::High.index()].len())\n     }\n \n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n@@ -318,8 +386,9 @@ impl Definitions {\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            assert!(def_id.index.as_usize() < self.def_index_to_node.len());\n-            Some(self.def_index_to_node[def_id.index.as_usize()])\n+            let space_index = def_id.index.address_space().index();\n+            let array_index = def_id.index.as_array_index();\n+            Some(self.def_index_to_node[space_index][array_index])\n         } else {\n             None\n         }\n@@ -329,7 +398,9 @@ impl Definitions {\n     pub fn create_def_with_parent(&mut self,\n                                   parent: Option<DefIndex>,\n                                   node_id: ast::NodeId,\n-                                  data: DefPathData)\n+                                  data: DefPathData,\n+                                  // is_owner: bool)\n+                                  address_space: DefIndexAddressSpace)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n@@ -359,14 +430,25 @@ impl Definitions {\n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = self.table.insert(key);\n+        let index = self.table.allocate(key, address_space);\n+        assert_eq!(index.as_array_index(),\n+                   self.def_index_to_node[address_space.index()].len());\n+        self.def_index_to_node[address_space.index()].push(node_id);\n+\n         debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n         self.node_to_def_index.insert(node_id, index);\n-        assert_eq!(index.as_usize(), self.def_index_to_node.len());\n-        self.def_index_to_node.push(node_id);\n \n         index\n     }\n+\n+    /// Initialize the ast::NodeId to HirId mapping once it has been generated during\n+    /// AST to HIR lowering.\n+    pub fn init_node_id_to_hir_id_mapping(&mut self,\n+                                          mapping: IndexVec<ast::NodeId, hir::HirId>) {\n+        assert!(self.node_to_hir_id.is_empty(),\n+                \"Trying initialize NodeId -> HirId mapping twice\");\n+        self.node_to_hir_id = mapping;\n+    }\n }\n \n impl DefPathData {"}, {"sha": "b3cc0c542ef9da217dfb225c0bcbc9746e193397", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -0,0 +1,184 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use hir::{self, intravisit, HirId, ItemLocalId};\n+use syntax::ast::NodeId;\n+use hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_data_structures::fx::FxHashMap;\n+\n+pub fn check_crate<'hir>(hir_map: &hir::map::Map<'hir>) {\n+    let mut outer_visitor = OuterVisitor {\n+        hir_map: hir_map,\n+        errors: vec![],\n+    };\n+\n+    hir_map.dep_graph.with_ignore(|| {\n+        hir_map.krate().visit_all_item_likes(&mut outer_visitor);\n+        if !outer_visitor.errors.is_empty() {\n+            let message = outer_visitor\n+                .errors\n+                .iter()\n+                .fold(String::new(), |s1, s2| s1 + \"\\n\" + s2);\n+            bug!(\"{}\", message);\n+        }\n+    });\n+}\n+\n+struct HirIdValidator<'a, 'hir: 'a> {\n+    hir_map: &'a hir::map::Map<'hir>,\n+    owner_def_index: Option<DefIndex>,\n+    hir_ids_seen: FxHashMap<ItemLocalId, NodeId>,\n+    errors: Vec<String>,\n+}\n+\n+struct OuterVisitor<'a, 'hir: 'a> {\n+    hir_map: &'a hir::map::Map<'hir>,\n+    errors: Vec<String>,\n+}\n+\n+impl<'a, 'hir: 'a> OuterVisitor<'a, 'hir> {\n+    fn new_inner_visitor(&self,\n+                         hir_map: &'a hir::map::Map<'hir>)\n+                         -> HirIdValidator<'a, 'hir> {\n+        HirIdValidator {\n+            hir_map: hir_map,\n+            owner_def_index: None,\n+            hir_ids_seen: FxHashMap(),\n+            errors: Vec::new(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'hir: 'a> ItemLikeVisitor<'hir> for OuterVisitor<'a, 'hir> {\n+    fn visit_item(&mut self, i: &'hir hir::Item) {\n+        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n+        inner_visitor.check(i.id, |this| intravisit::walk_item(this, i));\n+        self.errors.extend(inner_visitor.errors.drain(..));\n+    }\n+\n+    fn visit_trait_item(&mut self, i: &'hir hir::TraitItem) {\n+        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n+        inner_visitor.check(i.id, |this| intravisit::walk_trait_item(this, i));\n+        self.errors.extend(inner_visitor.errors.drain(..));\n+    }\n+\n+    fn visit_impl_item(&mut self, i: &'hir hir::ImplItem) {\n+        let mut inner_visitor = self.new_inner_visitor(self.hir_map);\n+        inner_visitor.check(i.id, |this| intravisit::walk_impl_item(this, i));\n+        self.errors.extend(inner_visitor.errors.drain(..));\n+    }\n+}\n+\n+impl<'a, 'hir: 'a> HirIdValidator<'a, 'hir> {\n+\n+    fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self,\n+                                                       node_id: NodeId,\n+                                                       walk: F) {\n+        assert!(self.owner_def_index.is_none());\n+        let owner_def_index = self.hir_map.local_def_id(node_id).index;\n+        self.owner_def_index = Some(owner_def_index);\n+        walk(self);\n+\n+        if owner_def_index == CRATE_DEF_INDEX {\n+            return\n+        }\n+\n+        // There's always at least one entry for the owning item itself\n+        let max = self.hir_ids_seen\n+                      .keys()\n+                      .map(|local_id| local_id.as_usize())\n+                      .max()\n+                      .unwrap();\n+\n+        if max != self.hir_ids_seen.len() - 1 {\n+            // Collect the missing ItemLocalIds\n+            let missing: Vec<_> = (0 .. max + 1)\n+              .filter(|&i| !self.hir_ids_seen.contains_key(&ItemLocalId(i as u32)))\n+              .collect();\n+\n+            // Try to map those to something more useful\n+            let mut missing_items = vec![];\n+\n+            for local_id in missing {\n+                let hir_id = HirId {\n+                    owner: owner_def_index,\n+                    local_id: ItemLocalId(local_id as u32),\n+                };\n+\n+                // We are already in ICE mode here, so doing a linear search\n+                // should be fine.\n+                let (node_id, _) = self.hir_map\n+                                       .definitions()\n+                                       .node_to_hir_id\n+                                       .iter()\n+                                       .enumerate()\n+                                       .find(|&(_, &entry)| hir_id == entry)\n+                                       .unwrap();\n+                let node_id = NodeId::new(node_id);\n+                missing_items.push(format!(\"[local_id: {}, node:{}]\",\n+                                           local_id,\n+                                           self.hir_map.node_to_string(node_id)));\n+            }\n+\n+            self.errors.push(format!(\n+                \"ItemLocalIds not assigned densely in {}. \\\n+                Max ItemLocalId = {}, missing IDs = {:?}\",\n+                self.hir_map.def_path(DefId::local(owner_def_index)).to_string_no_crate(),\n+                max,\n+                missing_items));\n+        }\n+    }\n+}\n+\n+impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n+\n+    fn nested_visit_map<'this>(&'this mut self)\n+                               -> intravisit::NestedVisitorMap<'this, 'hir> {\n+        intravisit::NestedVisitorMap::OnlyBodies(self.hir_map)\n+    }\n+\n+    fn visit_id(&mut self, node_id: NodeId) {\n+        let owner = self.owner_def_index.unwrap();\n+        let stable_id = self.hir_map.definitions().node_to_hir_id[node_id];\n+\n+        if stable_id == hir::DUMMY_HIR_ID {\n+            self.errors.push(format!(\"HirIdValidator: No HirId assigned for NodeId {}: {:?}\",\n+                                     node_id,\n+                                     self.hir_map.node_to_string(node_id)));\n+        }\n+\n+        if owner != stable_id.owner {\n+            self.errors.push(format!(\n+                \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n+                self.hir_map.node_to_string(node_id),\n+                self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n+                self.hir_map.def_path(DefId::local(owner)).to_string_no_crate()));\n+        }\n+\n+        if let Some(prev) = self.hir_ids_seen.insert(stable_id.local_id, node_id) {\n+            if prev != node_id {\n+                self.errors.push(format!(\n+                    \"HirIdValidator: Same HirId {}/{} assigned for nodes {} and {}\",\n+                    self.hir_map.def_path(DefId::local(stable_id.owner)).to_string_no_crate(),\n+                    stable_id.local_id.as_usize(),\n+                    self.hir_map.node_to_string(prev),\n+                    self.hir_map.node_to_string(node_id)));\n+            }\n+        }\n+    }\n+\n+    fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {\n+        // Explicitly do nothing here. ImplItemRefs contain hir::Visibility\n+        // values that actually belong to an ImplItem instead of the ItemImpl\n+        // we are currently in. So for those it's correct that they have a\n+        // different owner.\n+    }\n+}"}, {"sha": "583b3b848f30d88a7e572cc713233555a265f594", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -17,7 +17,7 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n \n use dep_graph::{DepGraph, DepNode};\n \n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex, DefIndexAddressSpace};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n@@ -36,6 +36,10 @@ pub mod blocks;\n mod collector;\n mod def_collector;\n pub mod definitions;\n+mod hir_id_validator;\n+\n+pub const ITEM_LIKE_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::Low;\n+pub const REGULAR_SPACE: DefIndexAddressSpace = DefIndexAddressSpace::High;\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n@@ -346,10 +350,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn num_local_def_ids(&self) -> usize {\n-        self.definitions.len()\n-    }\n-\n     pub fn definitions(&self) -> &Definitions {\n         &self.definitions\n     }\n@@ -964,13 +964,17 @@ pub fn map_crate<'hir>(forest: &'hir mut Forest,\n               entries, vector_length, (entries as f64 / vector_length as f64) * 100.);\n     }\n \n-    Map {\n+    let map = Map {\n         forest: forest,\n         dep_graph: forest.dep_graph.clone(),\n         map: map,\n         definitions: definitions,\n         inlined_bodies: RefCell::new(DefIdMap()),\n-    }\n+    };\n+\n+    hir_id_validator::check_crate(&map);\n+\n+    map\n }\n \n /// Identical to the `PpAnn` implementation for `hir::Crate`,"}, {"sha": "1c79a02d3da0e88d83f9b36511b09deb34bfc69d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -30,7 +30,7 @@ pub use self::Visibility::{Public, Inherited};\n pub use self::PathParameters::*;\n \n use hir::def::Def;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use util::nodemap::{NodeMap, FxHashSet};\n \n use syntax_pos::{Span, ExpnId, DUMMY_SP};\n@@ -43,6 +43,8 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n \n+use rustc_data_structures::indexed_vec;\n+\n use std::collections::BTreeMap;\n use std::fmt;\n \n@@ -73,6 +75,63 @@ pub mod pat_util;\n pub mod print;\n pub mod svh;\n \n+/// A HirId uniquely identifies a node in the HIR of then current crate. It is\n+/// composed of the `owner`, which is the DefIndex of the directly enclosing\n+/// hir::Item, hir::TraitItem, or hir::ImplItem (i.e. the closest \"item-like\"),\n+/// and the `local_id` which is unique within the given owner.\n+///\n+/// This two-level structure makes for more stable values: One can move an item\n+/// around within the source code, or add or remove stuff before it, without\n+/// the local_id part of the HirId changing, which is a very useful property\n+/// incremental compilation where we have to persist things through changes to\n+/// the code base.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct HirId {\n+    pub owner: DefIndex,\n+    pub local_id: ItemLocalId,\n+}\n+\n+/// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n+/// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n+/// guarantee that the numerical value of a given `ItemLocalId` corresponds to\n+/// the node's position within the owning item in any way, but there is a\n+/// guarantee that the `LocalItemId`s within an owner occupy a dense range of\n+/// integers starting at zero, so a mapping that maps all or most nodes within\n+/// an \"item-like\" to something else can be implement by a `Vec` instead of a\n+/// tree or hash map.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n+         RustcEncodable, RustcDecodable)]\n+pub struct ItemLocalId(pub u32);\n+\n+impl ItemLocalId {\n+    pub fn as_usize(&self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+impl indexed_vec::Idx for ItemLocalId {\n+    fn new(idx: usize) -> Self {\n+        debug_assert!((idx as u32) as usize == idx);\n+        ItemLocalId(idx as u32)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+/// The `HirId` corresponding to CRATE_NODE_ID and CRATE_DEF_INDEX\n+pub const CRATE_HIR_ID: HirId = HirId {\n+    owner: CRATE_DEF_INDEX,\n+    local_id: ItemLocalId(0)\n+};\n+\n+pub const DUMMY_HIR_ID: HirId = HirId {\n+    owner: CRATE_DEF_INDEX,\n+    local_id: ItemLocalId(!0)\n+};\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,"}, {"sha": "62c430dda327fe1c48c4a9537c50daecbd87ecce", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -189,6 +189,13 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T: Clone> IndexVec<I, T> {\n+    #[inline]\n+    pub fn resize(&mut self, new_len: usize, value: T) {\n+        self.raw.resize(new_len, value)\n+    }\n+}\n+\n impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n     type Output = T;\n "}, {"sha": "970a401177ba54e600e3b67aa5a7786717a0a4d3", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 50, "deletions": 17, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -10,7 +10,7 @@\n \n use schema::*;\n \n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace};\n use std::io::{Cursor, Write};\n use std::slice;\n use std::u32;\n@@ -23,12 +23,15 @@ use std::u32;\n /// appropriate spot by calling `record_position`. We should never\n /// visit the same index twice.\n pub struct Index {\n-    positions: Vec<u32>,\n+    positions: [Vec<u32>; 2]\n }\n \n impl Index {\n-    pub fn new(max_index: usize) -> Index {\n-        Index { positions: vec![u32::MAX; max_index] }\n+    pub fn new((max_index_lo, max_index_hi): (usize, usize)) -> Index {\n+        Index {\n+            positions: [vec![u32::MAX; max_index_lo],\n+                        vec![u32::MAX; max_index_hi]],\n+        }\n     }\n \n     pub fn record(&mut self, def_id: DefId, entry: Lazy<Entry>) {\n@@ -37,24 +40,31 @@ impl Index {\n     }\n \n     pub fn record_index(&mut self, item: DefIndex, entry: Lazy<Entry>) {\n-        let item = item.as_usize();\n-\n         assert!(entry.position < (u32::MAX as usize));\n         let position = entry.position as u32;\n+        let space_index = item.address_space().index();\n+        let array_index = item.as_array_index();\n \n-        assert!(self.positions[item] == u32::MAX,\n+        assert!(self.positions[space_index][array_index] == u32::MAX,\n                 \"recorded position for item {:?} twice, first at {:?} and now at {:?}\",\n                 item,\n-                self.positions[item],\n+                self.positions[space_index][array_index],\n                 position);\n \n-        self.positions[item] = position.to_le();\n+        self.positions[space_index][array_index] = position.to_le();\n     }\n \n     pub fn write_index(&self, buf: &mut Cursor<Vec<u8>>) -> LazySeq<Index> {\n         let pos = buf.position();\n-        buf.write_all(words_to_bytes(&self.positions)).unwrap();\n-        LazySeq::with_position_and_length(pos as usize, self.positions.len())\n+\n+        // First we write the length of the lower range ...\n+        buf.write_all(words_to_bytes(&[self.positions[0].len() as u32])).unwrap();\n+        // ... then the values in the lower range ...\n+        buf.write_all(words_to_bytes(&self.positions[0][..])).unwrap();\n+        // ... then the values in the higher range.\n+        buf.write_all(words_to_bytes(&self.positions[1][..])).unwrap();\n+        LazySeq::with_position_and_length(pos as usize,\n+            self.positions[0].len() + self.positions[1].len() + 1)\n     }\n }\n \n@@ -70,7 +80,18 @@ impl<'tcx> LazySeq<Index> {\n                index,\n                words.len());\n \n-        let position = u32::from_le(words[index].get());\n+        let positions = match def_index.address_space() {\n+            DefIndexAddressSpace::Low => &words[1..],\n+            DefIndexAddressSpace::High => {\n+                // This is a DefIndex in the higher range, so find out where\n+                // that starts:\n+                let lo_count = u32::from_le(words[0].get()) as usize;\n+                &words[lo_count + 1 .. ]\n+            }\n+        };\n+\n+        let array_index = def_index.as_array_index();\n+        let position = u32::from_le(positions[array_index].get());\n         if position == u32::MAX {\n             debug!(\"Index::lookup: position=u32::MAX\");\n             None\n@@ -84,14 +105,26 @@ impl<'tcx> LazySeq<Index> {\n                                bytes: &'a [u8])\n                                -> impl Iterator<Item = (DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n         let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n-        words.iter().map(|word| word.get()).enumerate().filter_map(|(index, position)| {\n-            if position == u32::MAX {\n+        let lo_count = u32::from_le(words[0].get()) as usize;\n+        let lo = &words[1 .. lo_count + 1];\n+        let hi = &words[1 + lo_count ..];\n+\n+        lo.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n+            if pos == u32::MAX {\n+                None\n+            } else {\n+                let pos = u32::from_le(pos) as usize;\n+                Some((DefIndex::new(index), Lazy::with_position(pos)))\n+            }\n+        }).chain(hi.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n+            if pos == u32::MAX {\n                 None\n             } else {\n-                let position = u32::from_le(position) as usize;\n-                Some((DefIndex::new(index), Lazy::with_position(position)))\n+                let pos = u32::from_le(pos) as usize;\n+                Some((DefIndex::new(index + DefIndexAddressSpace::High.start()),\n+                                    Lazy::with_position(pos)))\n             }\n-        })\n+        }))\n     }\n }\n "}, {"sha": "a811f72bc956cbe1408c0ff27753d0583ce0f111", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -90,7 +90,7 @@ impl<'a, 'b, 'tcx> DerefMut for IndexBuilder<'a, 'b, 'tcx> {\n impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     pub fn new(ecx: &'a mut EncodeContext<'b, 'tcx>) -> Self {\n         IndexBuilder {\n-            items: Index::new(ecx.tcx.hir.num_local_def_ids()),\n+            items: Index::new(ecx.tcx.hir.definitions().def_index_counts_lo_hi()),\n             ecx: ecx,\n         }\n     }"}, {"sha": "3dd4bdbd14ddb40e422d99686a6cb05ff67cc6cc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -23,6 +23,7 @@ use abi::Abi;\n use ext::hygiene::SyntaxContext;\n use print::pprust;\n use ptr::P;\n+use rustc_data_structures::indexed_vec;\n use symbol::{Symbol, keywords};\n use tokenstream::{ThinTokenStream, TokenStream};\n \n@@ -275,6 +276,16 @@ impl serialize::UseSpecializedDecodable for NodeId {\n     }\n }\n \n+impl indexed_vec::Idx for NodeId {\n+    fn new(idx: usize) -> Self {\n+        NodeId::new(idx)\n+    }\n+\n+    fn index(self) -> usize {\n+        self.as_usize()\n+    }\n+}\n+\n /// Node id used to represent the root of the crate.\n pub const CRATE_NODE_ID: NodeId = NodeId(0);\n "}, {"sha": "f0e328a551d5f37003d53bf6f93a40617708ea83", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -178,17 +178,9 @@ impl<'a, 'b> Folder for PlaceholderExpander<'a, 'b> {\n             block.stmts = block.stmts.move_flat_map(|mut stmt| {\n                 remaining_stmts -= 1;\n \n-                match stmt.node {\n-                    // Avoid wasting a node id on a trailing expression statement,\n-                    // which shares a HIR node with the expression itself.\n-                    ast::StmtKind::Expr(ref expr) if remaining_stmts == 0 => stmt.id = expr.id,\n-\n-                    _ if self.monotonic => {\n-                        assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n-                        stmt.id = self.cx.resolver.next_node_id();\n-                    }\n-\n-                    _ => {}\n+                if self.monotonic {\n+                    assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n+                    stmt.id = self.cx.resolver.next_node_id();\n                 }\n \n                 Some(stmt)"}, {"sha": "fd8d5ff9e7ea857b1f080d10c1fee5650010006f", "filename": "src/test/compile-fail/region-bounds-on-objects-and-type-parameters.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc98dfc8d265a40c6e1463022b862ede01f4ed26/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-bounds-on-objects-and-type-parameters.rs?ref=cc98dfc8d265a40c6e1463022b862ede01f4ed26", "patch": "@@ -18,7 +18,7 @@ trait SomeTrait { }\n \n // Bounds on object types:\n \n-struct Foo<'a,'b,'c> { //~ ERROR parameter `'b` is never used\n+struct Foo<'a,'b,'c> { //~ ERROR parameter `'c` is never used\n     // All of these are ok, because we can derive exactly one bound:\n     a: Box<IsStatic>,\n     b: Box<Is<'static>>,"}]}