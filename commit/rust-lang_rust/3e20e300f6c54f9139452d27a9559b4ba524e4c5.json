{"sha": "3e20e300f6c54f9139452d27a9559b4ba524e4c5", "node_id": "C_kwDOAAsO6NoAKDNlMjBlMzAwZjZjNTRmOTEzOTQ1MmQyN2E5NTU5YjRiYTUyNGU0YzU", "commit": {"author": {"name": "Skyler Calaman", "email": "54462713+Blckbrry-Pi@users.noreply.github.com", "date": "2021-11-14T23:18:43Z"}, "committer": {"name": "Skyler Calaman", "email": "54462713+Blckbrry-Pi@users.noreply.github.com", "date": "2021-11-14T23:18:43Z"}, "message": "Fix specific code outlined in issue #7975.\n\nStill needs to generalize to other mixes of let bindings, `map` method calls, etc.", "tree": {"sha": "388124b3d5959b00ab67c538530e1eb85070e647", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/388124b3d5959b00ab67c538530e1eb85070e647"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e20e300f6c54f9139452d27a9559b4ba524e4c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e20e300f6c54f9139452d27a9559b4ba524e4c5", "html_url": "https://github.com/rust-lang/rust/commit/3e20e300f6c54f9139452d27a9559b4ba524e4c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e20e300f6c54f9139452d27a9559b4ba524e4c5/comments", "author": {"login": "Blckbrry-Pi", "id": 54462713, "node_id": "MDQ6VXNlcjU0NDYyNzEz", "avatar_url": "https://avatars.githubusercontent.com/u/54462713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Blckbrry-Pi", "html_url": "https://github.com/Blckbrry-Pi", "followers_url": "https://api.github.com/users/Blckbrry-Pi/followers", "following_url": "https://api.github.com/users/Blckbrry-Pi/following{/other_user}", "gists_url": "https://api.github.com/users/Blckbrry-Pi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Blckbrry-Pi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Blckbrry-Pi/subscriptions", "organizations_url": "https://api.github.com/users/Blckbrry-Pi/orgs", "repos_url": "https://api.github.com/users/Blckbrry-Pi/repos", "events_url": "https://api.github.com/users/Blckbrry-Pi/events{/privacy}", "received_events_url": "https://api.github.com/users/Blckbrry-Pi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Blckbrry-Pi", "id": 54462713, "node_id": "MDQ6VXNlcjU0NDYyNzEz", "avatar_url": "https://avatars.githubusercontent.com/u/54462713?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Blckbrry-Pi", "html_url": "https://github.com/Blckbrry-Pi", "followers_url": "https://api.github.com/users/Blckbrry-Pi/followers", "following_url": "https://api.github.com/users/Blckbrry-Pi/following{/other_user}", "gists_url": "https://api.github.com/users/Blckbrry-Pi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Blckbrry-Pi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Blckbrry-Pi/subscriptions", "organizations_url": "https://api.github.com/users/Blckbrry-Pi/orgs", "repos_url": "https://api.github.com/users/Blckbrry-Pi/repos", "events_url": "https://api.github.com/users/Blckbrry-Pi/events{/privacy}", "received_events_url": "https://api.github.com/users/Blckbrry-Pi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f51fb341dd3ff79f400ee816dceb81eb2d0c5106", "url": "https://api.github.com/repos/rust-lang/rust/commits/f51fb341dd3ff79f400ee816dceb81eb2d0c5106", "html_url": "https://github.com/rust-lang/rust/commit/f51fb341dd3ff79f400ee816dceb81eb2d0c5106"}], "stats": {"total": 137, "additions": 113, "deletions": 24}, "files": [{"sha": "22c123e9e0419e7031c595fb79c418a81b3c5006", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 101, "deletions": 24, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/3e20e300f6c54f9139452d27a9559b4ba524e4c5/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e20e300f6c54f9139452d27a9559b4ba524e4c5/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=3e20e300f6c54f9139452d27a9559b4ba524e4c5", "patch": "@@ -3,13 +3,15 @@ use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_trait_method, path_to_local_id};\n+use clippy_utils::{can_move_expr_to_closure, is_trait_method, path_to_local_id, CaptureKind};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node, PatKind, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n+use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::{TyKind, TyS};\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n@@ -83,7 +85,8 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n                     is_type_diagnostic_item(cx, ty, sym::VecDeque) ||\n                     is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n                     is_type_diagnostic_item(cx, ty, sym::LinkedList);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, id);\n+                let iter_ty = cx.typeck_results().expr_ty(iter_source);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, id, cx, get_captured_ids(cx, iter_ty));\n                 if let [iter_call] = &*iter_calls;\n                 then {\n                     let mut used_count_visitor = UsedCountVisitor {\n@@ -167,34 +170,57 @@ enum IterFunctionKind {\n     Contains(Span),\n }\n \n-struct IterFunctionVisitor {\n+struct IterFunctionVisitor<'b, 'a> {\n+    illegal_mutable_capture_ids: HirIdSet,\n+    current_mutably_captured_ids: HirIdSet,\n+    cx: &'a LateContext<'b>,\n     uses: Vec<IterFunction>,\n     seen_other: bool,\n     target: HirId,\n }\n-impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n+impl<'tcx> Visitor<'tcx> for IterFunctionVisitor<'_, 'tcx> {\n+    fn visit_block(&mut self, block: &'txc Block<'tcx>) {\n+        for elem in block.stmts.iter().filter_map(get_expr_from_stmt).chain(block.expr) {\n+            self.current_mutably_captured_ids = HirIdSet::default();\n+            self.visit_expr(elem);\n+        }\n+    }\n+\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n         if let ExprKind::MethodCall(method_name, _, [recv, args @ ..], _) = &expr.kind {\n+            if method_name.ident.name == sym!(collect) && is_trait_method(self.cx, expr, sym::Iterator) {\n+                self.current_mutably_captured_ids = get_captured_ids(self.cx, self.cx.typeck_results().expr_ty(recv));\n+                self.visit_expr(recv);\n+                return;\n+            }\n+\n             if path_to_local_id(recv, self.target) {\n-                match &*method_name.ident.name.as_str() {\n-                    \"into_iter\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::IntoIter,\n-                        span: expr.span,\n-                    }),\n-                    \"len\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::Len,\n-                        span: expr.span,\n-                    }),\n-                    \"is_empty\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::IsEmpty,\n-                        span: expr.span,\n-                    }),\n-                    \"contains\" => self.uses.push(IterFunction {\n-                        func: IterFunctionKind::Contains(args[0].span),\n-                        span: expr.span,\n-                    }),\n-                    _ => self.seen_other = true,\n+                if self\n+                    .illegal_mutable_capture_ids\n+                    .intersection(&self.current_mutably_captured_ids)\n+                    .next()\n+                    .is_none()\n+                {\n+                    match &*method_name.ident.name.as_str() {\n+                        \"into_iter\" => self.uses.push(IterFunction {\n+                            func: IterFunctionKind::IntoIter,\n+                            span: expr.span,\n+                        }),\n+                        \"len\" => self.uses.push(IterFunction {\n+                            func: IterFunctionKind::Len,\n+                            span: expr.span,\n+                        }),\n+                        \"is_empty\" => self.uses.push(IterFunction {\n+                            func: IterFunctionKind::IsEmpty,\n+                            span: expr.span,\n+                        }),\n+                        \"contains\" => self.uses.push(IterFunction {\n+                            func: IterFunctionKind::Contains(args[0].span),\n+                            span: expr.span,\n+                        }),\n+                        _ => self.seen_other = true,\n+                    }\n                 }\n                 return;\n             }\n@@ -213,6 +239,14 @@ impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     }\n }\n \n+fn get_expr_from_stmt<'v>(stmt: &'v Stmt<'v>) -> Option<&'v Expr<'v>> {\n+    match stmt.kind {\n+        StmtKind::Expr(expr) | StmtKind::Semi(expr) => Some(expr),\n+        StmtKind::Item(..) => None,\n+        StmtKind::Local(Local { init, .. }) => *init,\n+    }\n+}\n+\n struct UsedCountVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     id: HirId,\n@@ -237,12 +271,55 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n \n /// Detect the occurrences of calls to `iter` or `into_iter` for the\n /// given identifier\n-fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, id: HirId) -> Option<Vec<IterFunction>> {\n+fn detect_iter_and_into_iters<'tcx: 'a, 'a>(\n+    block: &'tcx Block<'tcx>,\n+    id: HirId,\n+    cx: &'a LateContext<'tcx>,\n+    captured_ids: HirIdSet,\n+) -> Option<Vec<IterFunction>> {\n     let mut visitor = IterFunctionVisitor {\n         uses: Vec::new(),\n         target: id,\n         seen_other: false,\n+        cx,\n+        current_mutably_captured_ids: HirIdSet::default(),\n+        illegal_mutable_capture_ids: captured_ids,\n     };\n     visitor.visit_block(block);\n     if visitor.seen_other { None } else { Some(visitor.uses) }\n }\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+fn get_captured_ids(cx: &LateContext<'tcx>, ty: &'_ TyS<'_>) -> HirIdSet {\n+    fn get_captured_ids_recursive(cx: &LateContext<'tcx>, ty: &'_ TyS<'_>, set: &mut HirIdSet) {\n+        match ty.kind() {\n+            TyKind::Adt(_, generics) => {\n+                for generic in *generics {\n+                    if let GenericArgKind::Type(ty) = generic.unpack() {\n+                        get_captured_ids_recursive(cx, ty, set);\n+                    }\n+                }\n+            },\n+            TyKind::Closure(def_id, _) => {\n+                let closure_hir_node = cx.tcx.hir().get_if_local(*def_id).unwrap();\n+                if let Node::Expr(closure_expr) = closure_hir_node {\n+                    can_move_expr_to_closure(cx, closure_expr)\n+                        .unwrap()\n+                        .into_iter()\n+                        .for_each(|(hir_id, capture_kind)| {\n+                            if matches!(capture_kind, CaptureKind::Ref(Mutability::Mut)) {\n+                                set.insert(hir_id);\n+                            }\n+                        });\n+                }\n+            },\n+            _ => (),\n+        }\n+    }\n+\n+    let mut set = HirIdSet::default();\n+\n+    get_captured_ids_recursive(cx, ty, &mut set);\n+\n+    set\n+}"}, {"sha": "7f2d86b092530cef539bc2f21df6955c6f3213f7", "filename": "tests/ui/needless_collect_indirect.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e20e300f6c54f9139452d27a9559b4ba524e4c5/tests%2Fui%2Fneedless_collect_indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e20e300f6c54f9139452d27a9559b4ba524e4c5/tests%2Fui%2Fneedless_collect_indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_collect_indirect.rs?ref=3e20e300f6c54f9139452d27a9559b4ba524e4c5", "patch": "@@ -76,6 +76,18 @@ mod issue7110 {\n     }\n }\n \n+mod issue7975 {\n+    use super::*;\n+\n+    fn shouldnt_lint() -> Vec<()> {\n+        let test_vec: Vec<()> = vec![];\n+        let mut vec_2: Vec<()> = vec![];\n+        let mut_ref = &mut vec_2;\n+        let collected_vec: Vec<_> = test_vec.into_iter().map(|_| mut_ref.push(())).collect();\n+        collected_vec.into_iter().map(|_| mut_ref.push(())).collect()\n+    }\n+}\n+\n fn allow_test() {\n     #[allow(clippy::needless_collect)]\n     let v = [1].iter().collect::<Vec<_>>();"}]}