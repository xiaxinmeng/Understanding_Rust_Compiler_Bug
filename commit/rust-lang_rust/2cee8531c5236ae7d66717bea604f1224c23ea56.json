{"sha": "2cee8531c5236ae7d66717bea604f1224c23ea56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjZWU4NTMxYzUyMzZhZTdkNjY3MTdiZWE2MDRmMTIyNGMyM2VhNTY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-03T07:46:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-03T07:46:46Z"}, "message": "Merge #3814\n\n3814: Add impl From for enum variant assist r=flodiebold a=mattyhall\n\nBasically adds a From impl for tuple enum variants with one field. It was recommended to me on the zulip to maybe try using the trait solver, but I had trouble with that as, although it could resolve the trait impl, it couldn't resolve the variable unambiguously in real use. I'm also unsure of how it would work if there were already multiple From impls to resolve - I can't see a way we could get more than one solution to my query.\r\n\r\nFixes #3766\n\nCo-authored-by: Matthew Hall <matthew@quickbeam.me.uk>", "tree": {"sha": "b2e2de013f8c028b5cd70ac421c8e8f7d4c6bfb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2e2de013f8c028b5cd70ac421c8e8f7d4c6bfb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cee8531c5236ae7d66717bea604f1224c23ea56", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehunmCRBK7hj4Ov3rIwAAdHIIAFY1ZwsXCrsLFp6CavH73BBl\nmfrKQMM0B9okvOMAB0aG3UA7Lc3BzSOKjKEJ3wVN7LWy+eFuLrhWEFBjZlQ5Lz30\n58NM8dIuJpCZ78zyvqVZwh+1Uiq+ouiGowVkFwsqpnYdhgySItT6mCltPizIHmkQ\nMvU5qBoxh0ZzjNVG9zkMUUlgQPuZbVTxFWGe8QIqDOxC3XlCEC+HwCHrm3L2wpIS\nWrcKcN6cYJFoRYDhrBgozRt12AdUjRxbFqnIEHVzTfUnx1jquyK1JgPmLZgypuiR\nC/h9OVFgIZJvOVkPXXYelGC9kJ8cg2FVl6/JULE3CbBWzNeerybvA8zT5PNgS/8=\n=JHf9\n-----END PGP SIGNATURE-----\n", "payload": "tree b2e2de013f8c028b5cd70ac421c8e8f7d4c6bfb5\nparent 642f3f4bd62019d8c0fdd6304ff07d87a5aca627\nparent 6a2127be28a837215801f4ac3cd7d46ef7c4485b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1585900006 +0000\ncommitter GitHub <noreply@github.com> 1585900006 +0000\n\nMerge #3814\n\n3814: Add impl From for enum variant assist r=flodiebold a=mattyhall\n\nBasically adds a From impl for tuple enum variants with one field. It was recommended to me on the zulip to maybe try using the trait solver, but I had trouble with that as, although it could resolve the trait impl, it couldn't resolve the variable unambiguously in real use. I'm also unsure of how it would work if there were already multiple From impls to resolve - I can't see a way we could get more than one solution to my query.\r\n\r\nFixes #3766\n\nCo-authored-by: Matthew Hall <matthew@quickbeam.me.uk>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cee8531c5236ae7d66717bea604f1224c23ea56", "html_url": "https://github.com/rust-lang/rust/commit/2cee8531c5236ae7d66717bea604f1224c23ea56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cee8531c5236ae7d66717bea604f1224c23ea56/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "url": "https://api.github.com/repos/rust-lang/rust/commits/642f3f4bd62019d8c0fdd6304ff07d87a5aca627", "html_url": "https://github.com/rust-lang/rust/commit/642f3f4bd62019d8c0fdd6304ff07d87a5aca627"}, {"sha": "6a2127be28a837215801f4ac3cd7d46ef7c4485b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a2127be28a837215801f4ac3cd7d46ef7c4485b", "html_url": "https://github.com/rust-lang/rust/commit/6a2127be28a837215801f4ac3cd7d46ef7c4485b"}], "stats": {"total": 231, "additions": 230, "deletions": 1}, "files": [{"sha": "864373aa5d58e2031684d4e8fe652ded492c0b4f", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/2cee8531c5236ae7d66717bea604f1224c23ea56/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cee8531c5236ae7d66717bea604f1224c23ea56/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=2cee8531c5236ae7d66717bea604f1224c23ea56", "patch": "@@ -0,0 +1,206 @@\n+use ra_syntax::{\n+    ast::{self, AstNode, NameOwner},\n+    TextUnit,\n+};\n+use stdx::format_to;\n+\n+use crate::{Assist, AssistCtx, AssistId};\n+use ra_ide_db::RootDatabase;\n+\n+// Assist add_from_impl_for_enum\n+//\n+// Adds a From impl for an enum variant with one tuple field\n+//\n+// ```\n+// enum A { <|>One(u32) }\n+// ```\n+// ->\n+// ```\n+// enum A { One(u32) }\n+//\n+// impl From<u32> for A {\n+//     fn from(v: u32) -> Self {\n+//         A::One(v)\n+//     }\n+// }\n+// ```\n+pub(crate) fn add_from_impl_for_enum(ctx: AssistCtx) -> Option<Assist> {\n+    let variant = ctx.find_node_at_offset::<ast::EnumVariant>()?;\n+    let variant_name = variant.name()?;\n+    let enum_name = variant.parent_enum().name()?;\n+    let field_list = match variant.kind() {\n+        ast::StructKind::Tuple(field_list) => field_list,\n+        _ => return None,\n+    };\n+    if field_list.fields().count() != 1 {\n+        return None;\n+    }\n+    let field_type = field_list.fields().next()?.type_ref()?;\n+    let path = match field_type {\n+        ast::TypeRef::PathType(p) => p,\n+        _ => return None,\n+    };\n+\n+    if already_has_from_impl(ctx.sema, &variant) {\n+        return None;\n+    }\n+\n+    ctx.add_assist(\n+        AssistId(\"add_from_impl_for_enum\"),\n+        \"Add From impl for this enum variant\",\n+        |edit| {\n+            let start_offset = variant.parent_enum().syntax().text_range().end();\n+            let mut buf = String::new();\n+            format_to!(\n+                buf,\n+                r#\"\n+\n+impl From<{0}> for {1} {{\n+    fn from(v: {0}) -> Self {{\n+        {1}::{2}(v)\n+    }}\n+}}\"#,\n+                path.syntax(),\n+                enum_name,\n+                variant_name\n+            );\n+            edit.insert(start_offset, buf);\n+            edit.set_cursor(start_offset + TextUnit::of_str(\"\\n\\n\"));\n+        },\n+    )\n+}\n+\n+fn already_has_from_impl(\n+    sema: &'_ hir::Semantics<'_, RootDatabase>,\n+    variant: &ast::EnumVariant,\n+) -> bool {\n+    let scope = sema.scope(&variant.syntax());\n+\n+    let from_path = ast::make::path_from_text(\"From\");\n+    let from_hir_path = match hir::Path::from_ast(from_path) {\n+        Some(p) => p,\n+        None => return false,\n+    };\n+    let from_trait = match scope.resolve_hir_path(&from_hir_path) {\n+        Some(hir::PathResolution::Def(hir::ModuleDef::Trait(t))) => t,\n+        _ => return false,\n+    };\n+\n+    let e: hir::Enum = match sema.to_def(&variant.parent_enum()) {\n+        Some(e) => e,\n+        None => return false,\n+    };\n+    let e_ty = e.ty(sema.db);\n+\n+    let hir_enum_var: hir::EnumVariant = match sema.to_def(variant) {\n+        Some(ev) => ev,\n+        None => return false,\n+    };\n+    let var_ty = hir_enum_var.fields(sema.db)[0].signature_ty(sema.db);\n+\n+    e_ty.impls_trait(sema.db, from_trait, &[var_ty.clone()])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::helpers::{check_assist, check_assist_not_applicable};\n+\n+    #[test]\n+    fn test_add_from_impl_for_enum() {\n+        check_assist(\n+            add_from_impl_for_enum,\n+            \"enum A { <|>One(u32) }\",\n+            r#\"enum A { One(u32) }\n+\n+<|>impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_for_enum_complicated_path() {\n+        check_assist(\n+            add_from_impl_for_enum,\n+            \"enum A { <|>One(foo::bar::baz::Boo) }\",\n+            r#\"enum A { One(foo::bar::baz::Boo) }\n+\n+<|>impl From<foo::bar::baz::Boo> for A {\n+    fn from(v: foo::bar::baz::Boo) -> Self {\n+        A::One(v)\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_no_element() {\n+        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One }\");\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_more_than_one_element_in_tuple() {\n+        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One(u32, String) }\");\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_struct_variant() {\n+        check_assist_not_applicable(add_from_impl_for_enum, \"enum A { <|>One { x: u32 } }\");\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_already_exists() {\n+        check_assist_not_applicable(\n+            add_from_impl_for_enum,\n+            r#\"enum A { <|>One(u32), }\n+\n+impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\n+\n+pub trait From<T> {\n+    fn from(T) -> Self;\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_from_impl_different_variant_impl_exists() {\n+        check_assist(\n+            add_from_impl_for_enum,\n+            r#\"enum A { <|>One(u32), Two(String), }\n+\n+impl From<String> for A {\n+    fn from(v: String) -> Self {\n+        A::Two(v)\n+    }\n+}\n+\n+pub trait From<T> {\n+    fn from(T) -> Self;\n+}\"#,\n+            r#\"enum A { One(u32), Two(String), }\n+\n+<|>impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\n+\n+impl From<String> for A {\n+    fn from(v: String) -> Self {\n+        A::Two(v)\n+    }\n+}\n+\n+pub trait From<T> {\n+    fn from(T) -> Self;\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "6b4c56dcdc12c803ea09089e6d8cc3cb9b2ea5b4", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2cee8531c5236ae7d66717bea604f1224c23ea56/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cee8531c5236ae7d66717bea604f1224c23ea56/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=2cee8531c5236ae7d66717bea604f1224c23ea56", "patch": "@@ -122,6 +122,7 @@ mod handlers {\n     mod replace_qualified_name_with_use;\n     mod replace_unwrap_with_match;\n     mod split_import;\n+    mod add_from_impl_for_enum;\n \n     pub(crate) fn all() -> &'static [AssistHandler] {\n         &[\n@@ -159,6 +160,7 @@ mod handlers {\n             replace_qualified_name_with_use::replace_qualified_name_with_use,\n             replace_unwrap_with_match::replace_unwrap_with_match,\n             split_import::split_import,\n+            add_from_impl_for_enum::add_from_impl_for_enum,\n         ]\n     }\n }"}, {"sha": "c6f3bdb8eb610bc61734da5ce17ce68234ec1d8c", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2cee8531c5236ae7d66717bea604f1224c23ea56/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cee8531c5236ae7d66717bea604f1224c23ea56/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=2cee8531c5236ae7d66717bea604f1224c23ea56", "patch": "@@ -1084,6 +1084,26 @@ impl Type {\n         )\n     }\n \n+    pub fn impls_trait(&self, db: &dyn HirDatabase, trait_: Trait, args: &[Type]) -> bool {\n+        let trait_ref = hir_ty::TraitRef {\n+            trait_: trait_.id,\n+            substs: Substs::build_for_def(db, trait_.id)\n+                .push(self.ty.value.clone())\n+                .fill(args.iter().map(|t| t.ty.value.clone()))\n+                .build(),\n+        };\n+\n+        let goal = Canonical {\n+            value: hir_ty::InEnvironment::new(\n+                self.ty.environment.clone(),\n+                hir_ty::Obligation::Trait(trait_ref),\n+            ),\n+            num_vars: 0,\n+        };\n+\n+        db.trait_solve(self.krate, goal).is_some()\n+    }\n+\n     // FIXME: this method is broken, as it doesn't take closures into account.\n     pub fn as_callable(&self) -> Option<CallableDef> {\n         Some(self.ty.value.as_callable()?.0)"}, {"sha": "c49cf9a3b89a1cbccffac7f222000fb22ea31ed4", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cee8531c5236ae7d66717bea604f1224c23ea56/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cee8531c5236ae7d66717bea604f1224c23ea56/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=2cee8531c5236ae7d66717bea604f1224c23ea56", "patch": "@@ -22,7 +22,8 @@ pub fn path_unqualified(segment: ast::PathSegment) -> ast::Path {\n pub fn path_qualified(qual: ast::Path, segment: ast::PathSegment) -> ast::Path {\n     path_from_text(&format!(\"{}::{}\", qual, segment))\n }\n-fn path_from_text(text: &str) -> ast::Path {\n+\n+pub fn path_from_text(text: &str) -> ast::Path {\n     ast_from_text(text)\n }\n "}]}