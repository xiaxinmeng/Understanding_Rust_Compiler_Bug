{"sha": "50ccd17db686be2f411dce4a46119c39ccc59343", "node_id": "C_kwDOAAsO6NoAKDUwY2NkMTdkYjY4NmJlMmY0MTFkY2U0YTQ2MTE5YzM5Y2NjNTkzNDM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-27T19:34:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-27T19:34:17Z"}, "message": "Rollup merge of #110886 - nnethercote:dep-graph-cleanups, r=cjgillot\n\n`DepGraph` cleanups\n\nr? `@cjgillot`", "tree": {"sha": "d5716385820f34c0b9c06ba72f155c464f32cb30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5716385820f34c0b9c06ba72f155c464f32cb30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50ccd17db686be2f411dce4a46119c39ccc59343", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkSs45CRBK7hj4Ov3rIwAAzEUIAEcTvwLgBwBrO3zmk/GuyYsq\nJY1TFr0AxUv5sbKozEjVz51MiiRf+XkOhLZlyyoUADTE2AprBGzrd61HjszhMG+0\nMUGbTkd7SzQ52Q6HllyImCGKIDHPBDCoqj17OEbuHMD67eDufLaQZ+MJome44zph\n0/Rypz5QYphzzhvUExvpgES3U7zIcinz4VgMUzEQyvRrcIbY/7/Oen0OIJ8JOUFn\nv06ADSM9HuXCHct7EGlXUtPGi/K0FTjmcXI8xsQmIgz8nGsPpF6ypSpMqh9RBFdy\nVvT73HRVJhVkGAF8tOcX0FDqnBqDvczjvUDqIKnU+ZjrDb1L3AArRDl75DCDty8=\n=0aeS\n-----END PGP SIGNATURE-----\n", "payload": "tree d5716385820f34c0b9c06ba72f155c464f32cb30\nparent 1091a7a884b2de331ced19a7a4d1325c74fdaf06\nparent 793b2ffb67630bd4d92ba5083bfdd06ae84b61eb\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1682624057 +0200\ncommitter GitHub <noreply@github.com> 1682624057 +0200\n\nRollup merge of #110886 - nnethercote:dep-graph-cleanups, r=cjgillot\n\n`DepGraph` cleanups\n\nr? `@cjgillot`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50ccd17db686be2f411dce4a46119c39ccc59343", "html_url": "https://github.com/rust-lang/rust/commit/50ccd17db686be2f411dce4a46119c39ccc59343", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50ccd17db686be2f411dce4a46119c39ccc59343/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1091a7a884b2de331ced19a7a4d1325c74fdaf06", "url": "https://api.github.com/repos/rust-lang/rust/commits/1091a7a884b2de331ced19a7a4d1325c74fdaf06", "html_url": "https://github.com/rust-lang/rust/commit/1091a7a884b2de331ced19a7a4d1325c74fdaf06"}, {"sha": "793b2ffb67630bd4d92ba5083bfdd06ae84b61eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/793b2ffb67630bd4d92ba5083bfdd06ae84b61eb", "html_url": "https://github.com/rust-lang/rust/commit/793b2ffb67630bd4d92ba5083bfdd06ae84b61eb"}], "stats": {"total": 96, "additions": 32, "deletions": 64}, "files": [{"sha": "8de4d06fe782b0055cf046e3b6a5f35b21b36aa6", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 32, "deletions": 64, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/50ccd17db686be2f411dce4a46119c39ccc59343/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ccd17db686be2f411dce4a46119c39ccc59343/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=50ccd17db686be2f411dce4a46119c39ccc59343", "patch": "@@ -354,24 +354,20 @@ impl<K: DepKind> DepGraphData<K> {\n                  - dep-node: {key:?}\"\n         );\n \n-        let task_deps = if cx.dep_context().is_eval_always(key.kind) {\n-            None\n+        let with_deps = |task_deps| K::with_deps(task_deps, || task(cx, arg));\n+        let (result, edges) = if cx.dep_context().is_eval_always(key.kind) {\n+            (with_deps(TaskDepsRef::EvalAlways), smallvec![])\n         } else {\n-            Some(Lock::new(TaskDeps {\n+            let task_deps = Lock::new(TaskDeps {\n                 #[cfg(debug_assertions)]\n                 node: Some(key),\n                 reads: SmallVec::new(),\n                 read_set: Default::default(),\n                 phantom_data: PhantomData,\n-            }))\n+            });\n+            (with_deps(TaskDepsRef::Allow(&task_deps)), task_deps.into_inner().reads)\n         };\n \n-        let task_deps_ref =\n-            task_deps.as_ref().map(TaskDepsRef::Allow).unwrap_or(TaskDepsRef::EvalAlways);\n-\n-        let result = K::with_deps(task_deps_ref, || task(cx, arg));\n-        let edges = task_deps.map_or_else(|| smallvec![], |lock| lock.into_inner().reads);\n-\n         let dcx = cx.dep_context();\n         let hashing_timer = dcx.profiler().incr_result_hashing();\n         let current_fingerprint =\n@@ -1236,76 +1232,48 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             self.node_intern_event_id.map(|eid| profiler.generic_activity_with_event_id(eid));\n \n         if let Some(prev_index) = prev_graph.node_to_index_opt(&key) {\n+            let get_dep_node_index = |color, fingerprint| {\n+                if print_status {\n+                    eprintln!(\"[task::{color:}] {key:?}\");\n+                }\n+\n+                let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                let dep_node_index = match prev_index_to_index[prev_index] {\n+                    Some(dep_node_index) => dep_node_index,\n+                    None => {\n+                        let dep_node_index =\n+                            self.encoder.borrow().send(profiler, key, fingerprint, edges);\n+                        prev_index_to_index[prev_index] = Some(dep_node_index);\n+                        dep_node_index\n+                    }\n+                };\n+\n+                #[cfg(debug_assertions)]\n+                self.record_edge(dep_node_index, key, fingerprint);\n+\n+                dep_node_index\n+            };\n+\n             // Determine the color and index of the new `DepNode`.\n             if let Some(fingerprint) = fingerprint {\n                 if fingerprint == prev_graph.fingerprint_by_index(prev_index) {\n-                    if print_status {\n-                        eprintln!(\"[task::green] {key:?}\");\n-                    }\n-\n                     // This is a green node: it existed in the previous compilation,\n                     // its query was re-executed, and it has the same result as before.\n-                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n-\n-                    let dep_node_index = match prev_index_to_index[prev_index] {\n-                        Some(dep_node_index) => dep_node_index,\n-                        None => {\n-                            let dep_node_index =\n-                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n-                            prev_index_to_index[prev_index] = Some(dep_node_index);\n-                            dep_node_index\n-                        }\n-                    };\n-\n-                    #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key, fingerprint);\n+                    let dep_node_index = get_dep_node_index(\"green\", fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n                 } else {\n-                    if print_status {\n-                        eprintln!(\"[task::red] {key:?}\");\n-                    }\n-\n                     // This is a red node: it existed in the previous compilation, its query\n                     // was re-executed, but it has a different result from before.\n-                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n-\n-                    let dep_node_index = match prev_index_to_index[prev_index] {\n-                        Some(dep_node_index) => dep_node_index,\n-                        None => {\n-                            let dep_node_index =\n-                                self.encoder.borrow().send(profiler, key, fingerprint, edges);\n-                            prev_index_to_index[prev_index] = Some(dep_node_index);\n-                            dep_node_index\n-                        }\n-                    };\n-\n-                    #[cfg(debug_assertions)]\n-                    self.record_edge(dep_node_index, key, fingerprint);\n+                    let dep_node_index = get_dep_node_index(\"red\", fingerprint);\n                     (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n                 }\n             } else {\n-                if print_status {\n-                    eprintln!(\"[task::unknown] {key:?}\");\n-                }\n-\n                 // This is a red node, effectively: it existed in the previous compilation\n                 // session, its query was re-executed, but it doesn't compute a result hash\n                 // (i.e. it represents a `no_hash` query), so we have no way of determining\n                 // whether or not the result was the same as before.\n-                let mut prev_index_to_index = self.prev_index_to_index.lock();\n-\n-                let dep_node_index = match prev_index_to_index[prev_index] {\n-                    Some(dep_node_index) => dep_node_index,\n-                    None => {\n-                        let dep_node_index =\n-                            self.encoder.borrow().send(profiler, key, Fingerprint::ZERO, edges);\n-                        prev_index_to_index[prev_index] = Some(dep_node_index);\n-                        dep_node_index\n-                    }\n-                };\n-\n-                #[cfg(debug_assertions)]\n-                self.record_edge(dep_node_index, key, Fingerprint::ZERO);\n+                let dep_node_index = get_dep_node_index(\"unknown\", Fingerprint::ZERO);\n                 (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n             }\n         } else {"}]}