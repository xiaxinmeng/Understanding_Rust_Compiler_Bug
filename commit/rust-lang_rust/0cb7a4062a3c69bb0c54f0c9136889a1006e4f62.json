{"sha": "0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjYjdhNDA2MmEzYzY5YmIwYzU0ZjBjOTEzNjg4OWExMDA2ZTRmNjI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-04T06:24:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-05T06:59:26Z"}, "message": "serialize: Use assoc types + less old_orphan_check\n\nThis commit moves the libserialize crate (and will force the hand of the\nrustc-serialize crate) to not require the `old_orphan_check` feature gate as\nwell as using associated types wherever possible. Concretely, the following\nchanges were made:\n\n* The error type of `Encoder` and `Decoder` is now an associated type, meaning\n  that these traits have no type parameters.\n\n* The `Encoder` and `Decoder` type parameters on the `Encodable` and `Decodable`\n  traits have moved to the corresponding method of the trait. This movement\n  alleviates the dependency on `old_orphan_check` but implies that\n  implementations can no longer be specialized for the type of encoder/decoder\n  being implemented.\n\nDue to the trait definitions changing, this is a:\n\n[breaking-change]", "tree": {"sha": "63d90c804529054b3f8e13a8296cc10b330d2593", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63d90c804529054b3f8e13a8296cc10b330d2593"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "html_url": "https://github.com/rust-lang/rust/commit/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed22606c8382822efc555f72f895c560289a5c70", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed22606c8382822efc555f72f895c560289a5c70", "html_url": "https://github.com/rust-lang/rust/commit/ed22606c8382822efc555f72f895c560289a5c70"}], "stats": {"total": 6192, "additions": 5755, "deletions": 437}, "files": [{"sha": "3acedac111d606b97aff651a95af57821f7d6257", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 464, "deletions": 1, "changes": 465, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -25,7 +25,7 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n #![feature(macro_rules, phase, slicing_syntax, globs)]\n-#![feature(unboxed_closures)]\n+#![feature(unboxed_closures, associated_types)]\n #![allow(missing_docs)]\n \n extern crate serialize;\n@@ -417,6 +417,7 @@ pub mod reader {\n         }\n     }\n \n+    #[cfg(stage0)]\n     impl<'doc> serialize::Decoder<Error> for Decoder<'doc> {\n         fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n \n@@ -671,6 +672,263 @@ pub mod reader {\n             ApplicationError(err.to_string())\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    impl<'doc> serialize::Decoder for Decoder<'doc> {\n+        type Error = Error;\n+        fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n+\n+        fn read_u64(&mut self) -> DecodeResult<u64> { Ok(doc_as_u64(try!(self.next_doc(EsU64)))) }\n+        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(doc_as_u32(try!(self.next_doc(EsU32)))) }\n+        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(doc_as_u16(try!(self.next_doc(EsU16)))) }\n+        fn read_u8 (&mut self) -> DecodeResult<u8 > { Ok(doc_as_u8 (try!(self.next_doc(EsU8 )))) }\n+        fn read_uint(&mut self) -> DecodeResult<uint> {\n+            let v = doc_as_u64(try!(self.next_doc(EsUint)));\n+            if v > (::std::uint::MAX as u64) {\n+                Err(IntTooBig(v as uint))\n+            } else {\n+                Ok(v as uint)\n+            }\n+        }\n+\n+        fn read_i64(&mut self) -> DecodeResult<i64> {\n+            Ok(doc_as_u64(try!(self.next_doc(EsI64))) as i64)\n+        }\n+        fn read_i32(&mut self) -> DecodeResult<i32> {\n+            Ok(doc_as_u32(try!(self.next_doc(EsI32))) as i32)\n+        }\n+        fn read_i16(&mut self) -> DecodeResult<i16> {\n+            Ok(doc_as_u16(try!(self.next_doc(EsI16))) as i16)\n+        }\n+        fn read_i8 (&mut self) -> DecodeResult<i8> {\n+            Ok(doc_as_u8(try!(self.next_doc(EsI8 ))) as i8)\n+        }\n+        fn read_int(&mut self) -> DecodeResult<int> {\n+            let v = doc_as_u64(try!(self.next_doc(EsInt))) as i64;\n+            if v > (int::MAX as i64) || v < (int::MIN as i64) {\n+                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n+                Err(IntTooBig(v as uint))\n+            } else {\n+                Ok(v as int)\n+            }\n+        }\n+\n+        fn read_bool(&mut self) -> DecodeResult<bool> {\n+            Ok(doc_as_u8(try!(self.next_doc(EsBool))) != 0)\n+        }\n+\n+        fn read_f64(&mut self) -> DecodeResult<f64> {\n+            let bits = doc_as_u64(try!(self.next_doc(EsF64)));\n+            Ok(unsafe { transmute(bits) })\n+        }\n+        fn read_f32(&mut self) -> DecodeResult<f32> {\n+            let bits = doc_as_u32(try!(self.next_doc(EsF32)));\n+            Ok(unsafe { transmute(bits) })\n+        }\n+        fn read_char(&mut self) -> DecodeResult<char> {\n+            Ok(char::from_u32(doc_as_u32(try!(self.next_doc(EsChar)))).unwrap())\n+        }\n+        fn read_str(&mut self) -> DecodeResult<String> {\n+            Ok(try!(self.next_doc(EsStr)).as_str())\n+        }\n+\n+        // Compound types:\n+        fn read_enum<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_enum({})\", name);\n+            try!(self._check_label(name));\n+\n+            let doc = try!(self.next_doc(EsEnum));\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = try!(f(self));\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            Ok(result)\n+        }\n+\n+        fn read_enum_variant<T, F>(&mut self, _: &[&str],\n+                                   mut f: F) -> DecodeResult<T>\n+            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_enum_variant()\");\n+            let idx = try!(self._next_uint(EsEnumVid));\n+            debug!(\"  idx={}\", idx);\n+\n+            let doc = try!(self.next_doc(EsEnumBody));\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = try!(f(self, idx));\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            Ok(result)\n+        }\n+\n+        fn read_enum_variant_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_enum_variant_arg(idx={})\", idx);\n+            f(self)\n+        }\n+\n+        fn read_enum_struct_variant<T, F>(&mut self, _: &[&str],\n+                                          mut f: F) -> DecodeResult<T>\n+            where F: FnMut(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_enum_struct_variant()\");\n+            let idx = try!(self._next_uint(EsEnumVid));\n+            debug!(\"  idx={}\", idx);\n+\n+            let doc = try!(self.next_doc(EsEnumBody));\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = try!(f(self, idx));\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            Ok(result)\n+        }\n+\n+        fn read_enum_struct_variant_field<T, F>(&mut self,\n+                                                name: &str,\n+                                                idx: uint,\n+                                                f: F)\n+                                                -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+                debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n+            f(self)\n+        }\n+\n+        fn read_struct<T, F>(&mut self, name: &str, _: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_struct(name={})\", name);\n+            f(self)\n+        }\n+\n+        fn read_struct_field<T, F>(&mut self, name: &str, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n+            try!(self._check_label(name));\n+            f(self)\n+        }\n+\n+        fn read_tuple<T, F>(&mut self, tuple_len: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_tuple()\");\n+            self.read_seq(move |d, len| {\n+                if len == tuple_len {\n+                    f(d)\n+                } else {\n+                    Err(Expected(format!(\"Expected tuple of length `{}`, \\\n+                                          found tuple of length `{}`\", tuple_len, len)))\n+                }\n+            })\n+        }\n+\n+        fn read_tuple_arg<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_tuple_arg(idx={})\", idx);\n+            self.read_seq_elt(idx, f)\n+        }\n+\n+        fn read_tuple_struct<T, F>(&mut self, name: &str, len: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_tuple_struct(name={})\", name);\n+            self.read_tuple(len, f)\n+        }\n+\n+        fn read_tuple_struct_arg<T, F>(&mut self,\n+                                       idx: uint,\n+                                       f: F)\n+                                       -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n+            self.read_tuple_arg(idx, f)\n+        }\n+\n+        fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T> where\n+            F: FnMut(&mut Decoder<'doc>, bool) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_option()\");\n+            self.read_enum(\"Option\", move |this| {\n+                this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n+                    match idx {\n+                        0 => f(this, false),\n+                        1 => f(this, true),\n+                        _ => {\n+                            Err(Expected(format!(\"Expected None or Some\")))\n+                        }\n+                    }\n+                })\n+            })\n+        }\n+\n+        fn read_seq<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_seq()\");\n+            self.push_doc(EsVec, move |d| {\n+                let len = try!(d._next_uint(EsVecLen));\n+                debug!(\"  len={}\", len);\n+                f(d, len)\n+            })\n+        }\n+\n+        fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_seq_elt(idx={})\", idx);\n+            self.push_doc(EsVecElt, f)\n+        }\n+\n+        fn read_map<T, F>(&mut self, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>, uint) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_map()\");\n+            self.push_doc(EsMap, move |d| {\n+                let len = try!(d._next_uint(EsMapLen));\n+                debug!(\"  len={}\", len);\n+                f(d, len)\n+            })\n+        }\n+\n+        fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_map_elt_key(idx={})\", idx);\n+            self.push_doc(EsMapKey, f)\n+        }\n+\n+        fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> DecodeResult<T> where\n+            F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n+        {\n+            debug!(\"read_map_elt_val(idx={})\", idx);\n+            self.push_doc(EsMapVal, f)\n+        }\n+\n+        fn error(&mut self, err: &str) -> Error {\n+            ApplicationError(err.to_string())\n+        }\n+    }\n }\n \n pub mod writer {\n@@ -872,7 +1130,212 @@ pub mod writer {\n         }\n     }\n \n+    #[cfg(stage0)]\n     impl<'a, W: Writer + Seek> serialize::Encoder<io::IoError> for Encoder<'a, W> {\n+\n+        fn emit_nil(&mut self) -> EncodeResult {\n+            Ok(())\n+        }\n+\n+        fn emit_uint(&mut self, v: uint) -> EncodeResult {\n+            self.wr_tagged_u64(EsUint as uint, v as u64)\n+        }\n+        fn emit_u64(&mut self, v: u64) -> EncodeResult {\n+            self.wr_tagged_u64(EsU64 as uint, v)\n+        }\n+        fn emit_u32(&mut self, v: u32) -> EncodeResult {\n+            self.wr_tagged_u32(EsU32 as uint, v)\n+        }\n+        fn emit_u16(&mut self, v: u16) -> EncodeResult {\n+            self.wr_tagged_u16(EsU16 as uint, v)\n+        }\n+        fn emit_u8(&mut self, v: u8) -> EncodeResult {\n+            self.wr_tagged_u8(EsU8 as uint, v)\n+        }\n+\n+        fn emit_int(&mut self, v: int) -> EncodeResult {\n+            self.wr_tagged_i64(EsInt as uint, v as i64)\n+        }\n+        fn emit_i64(&mut self, v: i64) -> EncodeResult {\n+            self.wr_tagged_i64(EsI64 as uint, v)\n+        }\n+        fn emit_i32(&mut self, v: i32) -> EncodeResult {\n+            self.wr_tagged_i32(EsI32 as uint, v)\n+        }\n+        fn emit_i16(&mut self, v: i16) -> EncodeResult {\n+            self.wr_tagged_i16(EsI16 as uint, v)\n+        }\n+        fn emit_i8(&mut self, v: i8) -> EncodeResult {\n+            self.wr_tagged_i8(EsI8 as uint, v)\n+        }\n+\n+        fn emit_bool(&mut self, v: bool) -> EncodeResult {\n+            self.wr_tagged_u8(EsBool as uint, v as u8)\n+        }\n+\n+        fn emit_f64(&mut self, v: f64) -> EncodeResult {\n+            let bits = unsafe { mem::transmute(v) };\n+            self.wr_tagged_u64(EsF64 as uint, bits)\n+        }\n+        fn emit_f32(&mut self, v: f32) -> EncodeResult {\n+            let bits = unsafe { mem::transmute(v) };\n+            self.wr_tagged_u32(EsF32 as uint, bits)\n+        }\n+        fn emit_char(&mut self, v: char) -> EncodeResult {\n+            self.wr_tagged_u32(EsChar as uint, v as u32)\n+        }\n+\n+        fn emit_str(&mut self, v: &str) -> EncodeResult {\n+            self.wr_tagged_str(EsStr as uint, v)\n+        }\n+\n+        fn emit_enum<F>(&mut self, name: &str, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            try!(self._emit_label(name));\n+            try!(self.start_tag(EsEnum as uint));\n+            try!(f(self));\n+            self.end_tag()\n+        }\n+\n+        fn emit_enum_variant<F>(&mut self,\n+                                _: &str,\n+                                v_id: uint,\n+                                _: uint,\n+                                f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            try!(self._emit_tagged_uint(EsEnumVid, v_id));\n+            try!(self.start_tag(EsEnumBody as uint));\n+            try!(f(self));\n+            self.end_tag()\n+        }\n+\n+        fn emit_enum_variant_arg<F>(&mut self, _: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            f(self)\n+        }\n+\n+        fn emit_enum_struct_variant<F>(&mut self,\n+                                       v_name: &str,\n+                                       v_id: uint,\n+                                       cnt: uint,\n+                                       f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            self.emit_enum_variant(v_name, v_id, cnt, f)\n+        }\n+\n+        fn emit_enum_struct_variant_field<F>(&mut self,\n+                                             _: &str,\n+                                             idx: uint,\n+                                             f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            self.emit_enum_variant_arg(idx, f)\n+        }\n+\n+        fn emit_struct<F>(&mut self, _: &str, _len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            f(self)\n+        }\n+\n+        fn emit_struct_field<F>(&mut self, name: &str, _: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            try!(self._emit_label(name));\n+            f(self)\n+        }\n+\n+        fn emit_tuple<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            self.emit_seq_elt(idx, f)\n+        }\n+\n+        fn emit_tuple_struct<F>(&mut self, _: &str, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_struct_arg<F>(&mut self, idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            self.emit_seq_elt(idx, f)\n+        }\n+\n+        fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            self.emit_enum(\"Option\", f)\n+        }\n+        fn emit_option_none(&mut self) -> EncodeResult {\n+            self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n+        }\n+        fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+\n+            self.emit_enum_variant(\"Some\", 1, 1, f)\n+        }\n+\n+        fn emit_seq<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+\n+            try!(self.start_tag(EsVec as uint));\n+            try!(self._emit_tagged_uint(EsVecLen, len));\n+            try!(f(self));\n+            self.end_tag()\n+        }\n+\n+        fn emit_seq_elt<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+\n+            try!(self.start_tag(EsVecElt as uint));\n+            try!(f(self));\n+            self.end_tag()\n+        }\n+\n+        fn emit_map<F>(&mut self, len: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+\n+            try!(self.start_tag(EsMap as uint));\n+            try!(self._emit_tagged_uint(EsMapLen, len));\n+            try!(f(self));\n+            self.end_tag()\n+        }\n+\n+        fn emit_map_elt_key<F>(&mut self, _idx: uint, mut f: F) -> EncodeResult where\n+            F: FnMut(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+\n+            try!(self.start_tag(EsMapKey as uint));\n+            try!(f(self));\n+            self.end_tag()\n+        }\n+\n+        fn emit_map_elt_val<F>(&mut self, _idx: uint, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a, W>) -> EncodeResult,\n+        {\n+            try!(self.start_tag(EsMapVal as uint));\n+            try!(f(self));\n+            self.end_tag()\n+        }\n+    }\n+    #[cfg(not(stage0))]\n+    impl<'a, W: Writer + Seek> serialize::Encoder for Encoder<'a, W> {\n+        type Error = io::IoError;\n+\n         fn emit_nil(&mut self) -> EncodeResult {\n             Ok(())\n         }"}, {"sha": "269b09a5f2ed8abd94189d775c41ffa942669c1d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -263,18 +263,27 @@ trait def_id_encoder_helpers {\n     fn emit_def_id(&mut self, did: ast::DefId);\n }\n \n+#[cfg(stage0)]\n impl<S:serialize::Encoder<E>, E> def_id_encoder_helpers for S {\n     fn emit_def_id(&mut self, did: ast::DefId) {\n         did.encode(self).ok().unwrap()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n+    fn emit_def_id(&mut self, did: ast::DefId) {\n+        did.encode(self).ok().unwrap()\n+    }\n+}\n+\n trait def_id_decoder_helpers {\n     fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId;\n     fn read_def_id_nodcx(&mut self,\n                          cdata: &cstore::crate_metadata) -> ast::DefId;\n }\n \n+#[cfg(stage0)]\n impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n     fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId {\n         let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n@@ -288,6 +297,20 @@ impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n+    fn read_def_id(&mut self, dcx: &DecodeContext) -> ast::DefId {\n+        let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n+        did.tr(dcx)\n+    }\n+\n+    fn read_def_id_nodcx(&mut self,\n+                         cdata: &cstore::crate_metadata) -> ast::DefId {\n+        let did: ast::DefId = Decodable::decode(self).ok().unwrap();\n+        decoder::translate_def_id(cdata, did)\n+    }\n+}\n+\n // ______________________________________________________________________\n // Encoding and decoding the AST itself\n //"}, {"sha": "7ba329c518e91074cd0f5bddab7b1d96139c2e21", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 47, "deletions": 81, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -19,11 +19,9 @@ use std::collections::{DList, RingBuf, BTreeMap, BTreeSet, HashMap, HashSet, Vec\n use collections::enum_set::{EnumSet, CLike};\n \n impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E>\n-> Encodable<S, E> for DList<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+    T: Encodable\n+> Encodable for DList<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 try!(s.emit_seq_elt(i, |s| e.encode(s)));\n@@ -33,8 +31,8 @@ impl<\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for DList<T> {\n-    fn decode(d: &mut D) -> Result<DList<T>, E> {\n+impl<T:Decodable> Decodable for DList<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<DList<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut list = DList::new();\n             for i in range(0u, len) {\n@@ -45,12 +43,8 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for DList<T> {\n     }\n }\n \n-impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E>\n-> Encodable<S, E> for RingBuf<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl<T: Encodable> Encodable for RingBuf<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 try!(s.emit_seq_elt(i, |s| e.encode(s)));\n@@ -60,8 +54,8 @@ impl<\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for RingBuf<T> {\n-    fn decode(d: &mut D) -> Result<RingBuf<T>, E> {\n+impl<T:Decodable> Decodable for RingBuf<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<RingBuf<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut deque: RingBuf<T> = RingBuf::new();\n             for i in range(0u, len) {\n@@ -73,12 +67,10 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for RingBuf<T> {\n }\n \n impl<\n-    E,\n-    S: Encoder<E>,\n-    K: Encodable<S, E> + PartialEq + Ord,\n-    V: Encodable<S, E> + PartialEq\n-> Encodable<S, E> for BTreeMap<K, V> {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n+    K: Encodable + PartialEq + Ord,\n+    V: Encodable + PartialEq\n+> Encodable for BTreeMap<K, V> {\n+    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self.iter() {\n@@ -92,12 +84,10 @@ impl<\n }\n \n impl<\n-    E,\n-    D: Decoder<E>,\n-    K: Decodable<D, E> + PartialEq + Ord,\n-    V: Decodable<D, E> + PartialEq\n-> Decodable<D, E> for BTreeMap<K, V> {\n-    fn decode(d: &mut D) -> Result<BTreeMap<K, V>, E> {\n+    K: Decodable + PartialEq + Ord,\n+    V: Decodable + PartialEq\n+> Decodable for BTreeMap<K, V> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n             for i in range(0u, len) {\n@@ -111,11 +101,9 @@ impl<\n }\n \n impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E> + PartialEq + Ord\n-> Encodable<S, E> for BTreeSet<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+    T: Encodable + PartialEq + Ord\n+> Encodable for BTreeSet<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n@@ -128,11 +116,9 @@ impl<\n }\n \n impl<\n-    E,\n-    D: Decoder<E>,\n-    T: Decodable<D, E> + PartialEq + Ord\n-> Decodable<D, E> for BTreeSet<T> {\n-    fn decode(d: &mut D) -> Result<BTreeSet<T>, E> {\n+    T: Decodable + PartialEq + Ord\n+> Decodable for BTreeSet<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n             for i in range(0u, len) {\n@@ -144,11 +130,9 @@ impl<\n }\n \n impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E> + CLike\n-> Encodable<S, E> for EnumSet<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+    T: Encodable + CLike\n+> Encodable for EnumSet<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         let mut bits = 0;\n         for item in self.iter() {\n             bits |= item.to_uint();\n@@ -158,11 +142,9 @@ impl<\n }\n \n impl<\n-    E,\n-    D: Decoder<E>,\n-    T: Decodable<D, E> + CLike\n-> Decodable<D, E> for EnumSet<T> {\n-    fn decode(d: &mut D) -> Result<EnumSet<T>, E> {\n+    T: Decodable + CLike\n+> Decodable for EnumSet<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<EnumSet<T>, D::Error> {\n         let bits = try!(d.read_uint());\n         let mut set = EnumSet::new();\n         for bit in range(0, uint::BITS) {\n@@ -175,14 +157,12 @@ impl<\n }\n \n impl<\n-    E,\n-    S: Encoder<E>,\n-    K: Encodable<S, E> + Hash<X> + Eq,\n-    V: Encodable<S, E>,\n+    K: Encodable + Hash<X> + Eq,\n+    V: Encodable,\n     X,\n     H: Hasher<X>\n-> Encodable<S, E> for HashMap<K, V, H> {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n+> Encodable for HashMap<K, V, H> {\n+    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self.iter() {\n@@ -196,14 +176,12 @@ impl<\n }\n \n impl<\n-    E,\n-    D: Decoder<E>,\n-    K: Decodable<D, E> + Hash<S> + Eq,\n-    V: Decodable<D, E>,\n+    K: Decodable + Hash<S> + Eq,\n+    V: Decodable,\n     S,\n     H: Hasher<S> + Default\n-> Decodable<D, E> for HashMap<K, V, H> {\n-    fn decode(d: &mut D) -> Result<HashMap<K, V, H>, E> {\n+> Decodable for HashMap<K, V, H> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, H>, D::Error> {\n         d.read_map(|d, len| {\n             let hasher = Default::default();\n             let mut map = HashMap::with_capacity_and_hasher(len, hasher);\n@@ -218,13 +196,11 @@ impl<\n }\n \n impl<\n-    E,\n-    S: Encoder<E>,\n-    T: Encodable<S, E> + Hash<X> + Eq,\n+    T: Encodable + Hash<X> + Eq,\n     X,\n     H: Hasher<X>\n-> Encodable<S, E> for HashSet<T, H> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+> Encodable for HashSet<T, H> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n@@ -237,13 +213,11 @@ impl<\n }\n \n impl<\n-    E,\n-    D: Decoder<E>,\n-    T: Decodable<D, E> + Hash<S> + Eq,\n+    T: Decodable + Hash<S> + Eq,\n     S,\n     H: Hasher<S> + Default\n-> Decodable<D, E> for HashSet<T, H> {\n-    fn decode(d: &mut D) -> Result<HashSet<T, H>, E> {\n+> Decodable for HashSet<T, H> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, H>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = HashSet::with_capacity_and_hasher(len, Default::default());\n             for i in range(0u, len) {\n@@ -254,12 +228,8 @@ impl<\n     }\n }\n \n-impl<\n-    E,\n-    S: Encoder<E>,\n-    V: Encodable<S, E>\n-> Encodable<S, E> for VecMap<V> {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n+impl<V: Encodable> Encodable for VecMap<V> {\n+    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         e.emit_map(self.len(), |e| {\n                 for (i, (key, val)) in self.iter().enumerate() {\n                     try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n@@ -270,12 +240,8 @@ impl<\n     }\n }\n \n-impl<\n-    E,\n-    D: Decoder<E>,\n-    V: Decodable<D, E>\n-> Decodable<D, E> for VecMap<V> {\n-    fn decode(d: &mut D) -> Result<VecMap<V>, E> {\n+impl<V: Decodable> Decodable for VecMap<V> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<VecMap<V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = VecMap::new();\n             for i in range(0u, len) {"}, {"sha": "f2d79b133469958d48a5a3d8b3519871b5f494c0", "filename": "src/libserialize/collection_impls_stage0.rs", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fcollection_impls_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fcollection_impls_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls_stage0.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -0,0 +1,289 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementations of serialization for structures found in libcollections\n+\n+use std::uint;\n+use std::default::Default;\n+use std::hash::{Hash, Hasher};\n+\n+use {Decodable, Encodable, Decoder, Encoder};\n+use std::collections::{DList, RingBuf, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n+use collections::enum_set::{EnumSet, CLike};\n+\n+impl<\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E>\n+> Encodable<S, E> for DList<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for DList<T> {\n+    fn decode(d: &mut D) -> Result<DList<T>, E> {\n+        d.read_seq(|d, len| {\n+            let mut list = DList::new();\n+            for i in range(0u, len) {\n+                list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(list)\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E>\n+> Encodable<S, E> for RingBuf<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for RingBuf<T> {\n+    fn decode(d: &mut D) -> Result<RingBuf<T>, E> {\n+        d.read_seq(|d, len| {\n+            let mut deque: RingBuf<T> = RingBuf::new();\n+            for i in range(0u, len) {\n+                deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(deque)\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    S: Encoder<E>,\n+    K: Encodable<S, E> + PartialEq + Ord,\n+    V: Encodable<S, E> + PartialEq\n+> Encodable<S, E> for BTreeMap<K, V> {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n+        e.emit_map(self.len(), |e| {\n+            let mut i = 0;\n+            for (key, val) in self.iter() {\n+                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n+                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    D: Decoder<E>,\n+    K: Decodable<D, E> + PartialEq + Ord,\n+    V: Decodable<D, E> + PartialEq\n+> Decodable<D, E> for BTreeMap<K, V> {\n+    fn decode(d: &mut D) -> Result<BTreeMap<K, V>, E> {\n+        d.read_map(|d, len| {\n+            let mut map = BTreeMap::new();\n+            for i in range(0u, len) {\n+                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n+                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n+                map.insert(key, val);\n+            }\n+            Ok(map)\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E> + PartialEq + Ord\n+> Encodable<S, E> for BTreeSet<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_seq(self.len(), |s| {\n+            let mut i = 0;\n+            for e in self.iter() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    D: Decoder<E>,\n+    T: Decodable<D, E> + PartialEq + Ord\n+> Decodable<D, E> for BTreeSet<T> {\n+    fn decode(d: &mut D) -> Result<BTreeSet<T>, E> {\n+        d.read_seq(|d, len| {\n+            let mut set = BTreeSet::new();\n+            for i in range(0u, len) {\n+                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(set)\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E> + CLike\n+> Encodable<S, E> for EnumSet<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        let mut bits = 0;\n+        for item in self.iter() {\n+            bits |= item.to_uint();\n+        }\n+        s.emit_uint(bits)\n+    }\n+}\n+\n+impl<\n+    E,\n+    D: Decoder<E>,\n+    T: Decodable<D, E> + CLike\n+> Decodable<D, E> for EnumSet<T> {\n+    fn decode(d: &mut D) -> Result<EnumSet<T>, E> {\n+        let bits = try!(d.read_uint());\n+        let mut set = EnumSet::new();\n+        for bit in range(0, uint::BITS) {\n+            if bits & (1 << bit) != 0 {\n+                set.insert(CLike::from_uint(1 << bit));\n+            }\n+        }\n+        Ok(set)\n+    }\n+}\n+\n+impl<\n+    E,\n+    S: Encoder<E>,\n+    K: Encodable<S, E> + Hash<X> + Eq,\n+    V: Encodable<S, E>,\n+    X,\n+    H: Hasher<X>\n+> Encodable<S, E> for HashMap<K, V, H> {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n+        e.emit_map(self.len(), |e| {\n+            let mut i = 0;\n+            for (key, val) in self.iter() {\n+                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n+                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    D: Decoder<E>,\n+    K: Decodable<D, E> + Hash<S> + Eq,\n+    V: Decodable<D, E>,\n+    S,\n+    H: Hasher<S> + Default\n+> Decodable<D, E> for HashMap<K, V, H> {\n+    fn decode(d: &mut D) -> Result<HashMap<K, V, H>, E> {\n+        d.read_map(|d, len| {\n+            let hasher = Default::default();\n+            let mut map = HashMap::with_capacity_and_hasher(len, hasher);\n+            for i in range(0u, len) {\n+                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n+                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n+                map.insert(key, val);\n+            }\n+            Ok(map)\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E> + Hash<X> + Eq,\n+    X,\n+    H: Hasher<X>\n+> Encodable<S, E> for HashSet<T, H> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_seq(self.len(), |s| {\n+            let mut i = 0;\n+            for e in self.iter() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    D: Decoder<E>,\n+    T: Decodable<D, E> + Hash<S> + Eq,\n+    S,\n+    H: Hasher<S> + Default\n+> Decodable<D, E> for HashSet<T, H> {\n+    fn decode(d: &mut D) -> Result<HashSet<T, H>, E> {\n+        d.read_seq(|d, len| {\n+            let mut set = HashSet::with_capacity_and_hasher(len, Default::default());\n+            for i in range(0u, len) {\n+                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(set)\n+        })\n+    }\n+}\n+\n+impl<\n+    E,\n+    S: Encoder<E>,\n+    V: Encodable<S, E>\n+> Encodable<S, E> for VecMap<V> {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n+        e.emit_map(self.len(), |e| {\n+                for (i, (key, val)) in self.iter().enumerate() {\n+                    try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n+                    try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n+                }\n+                Ok(())\n+            })\n+    }\n+}\n+\n+impl<\n+    E,\n+    D: Decoder<E>,\n+    V: Decodable<D, E>\n+> Decodable<D, E> for VecMap<V> {\n+    fn decode(d: &mut D) -> Result<VecMap<V>, E> {\n+        d.read_map(|d, len| {\n+            let mut map = VecMap::new();\n+            for i in range(0u, len) {\n+                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n+                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n+                map.insert(key, val);\n+            }\n+            Ok(map)\n+        })\n+    }\n+}"}, {"sha": "e8bd46815e6ac3f547c4ffefedcb295bfb38354f", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -300,7 +300,7 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n }\n \n /// Shortcut function to decode a JSON `&str` into an object\n-pub fn decode<T: ::Decodable<Decoder, DecoderError>>(s: &str) -> DecodeResult<T> {\n+pub fn decode<T: ::Decodable>(s: &str) -> DecodeResult<T> {\n     let json = match from_str(s) {\n         Ok(x) => x,\n         Err(e) => return Err(ParseError(e))\n@@ -311,9 +311,7 @@ pub fn decode<T: ::Decodable<Decoder, DecoderError>>(s: &str) -> DecodeResult<T>\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<T>(object: &T) -> string::String\n-                 where T: for<'a> Encodable<Encoder<'a>, fmt::Error>\n-{\n+pub fn encode<T: ::Encodable>(object: &T) -> string::String {\n     let mut s = String::new();\n     {\n         let mut encoder = Encoder::new(&mut s);\n@@ -444,7 +442,9 @@ impl<'a> Encoder<'a> {\n     }\n }\n \n-impl<'a> ::Encoder<fmt::Error> for Encoder<'a> {\n+impl<'a> ::Encoder for Encoder<'a> {\n+    type Error = fmt::Error;\n+\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n@@ -664,7 +664,9 @@ impl<'a> PrettyEncoder<'a> {\n     }\n }\n \n-impl<'a> ::Encoder<fmt::Error> for PrettyEncoder<'a> {\n+impl<'a> ::Encoder for PrettyEncoder<'a> {\n+    type Error = fmt::Error;\n+\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n@@ -909,8 +911,8 @@ impl<'a> ::Encoder<fmt::Error> for PrettyEncoder<'a> {\n     }\n }\n \n-impl<E: ::Encoder<S>, S> Encodable<E, S> for Json {\n-    fn encode(&self, e: &mut E) -> Result<(), S> {\n+impl Encodable for Json {\n+    fn encode<E: ::Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         match *self {\n             Json::I64(v) => v.encode(e),\n             Json::U64(v) => v.encode(e),\n@@ -2062,7 +2064,9 @@ macro_rules! read_primitive {\n     }\n }\n \n-impl ::Decoder<DecoderError> for Decoder {\n+impl ::Decoder for Decoder {\n+    type Error = DecoderError;\n+\n     fn read_nil(&mut self) -> DecodeResult<()> {\n         expect!(self.pop(), Null)\n     }\n@@ -2474,9 +2478,7 @@ impl<'a> fmt::Show for PrettyJson<'a> {\n     }\n }\n \n-impl<'a, T> fmt::Show for AsJson<'a, T>\n-    where T: for<'b> Encodable<Encoder<'b>, fmt::Error>\n-{\n+impl<'a, T: Encodable> fmt::Show for AsJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -2493,9 +2495,7 @@ impl<'a, T> AsPrettyJson<'a, T> {\n     }\n }\n \n-impl<'a, T> fmt::Show for AsPrettyJson<'a, T>\n-    where T: for<'b> Encodable<PrettyEncoder<'b>, fmt::Error>\n-{\n+impl<'a, T: Encodable> fmt::Show for AsPrettyJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -3155,8 +3155,7 @@ mod tests {\n         A(f64),\n         B(string::String)\n     }\n-    fn check_err<T: Decodable<Decoder, DecoderError>>(to_parse: &'static str,\n-                                                      expected: DecoderError) {\n+    fn check_err<T: Decodable>(to_parse: &'static str, expected: DecoderError) {\n         let res: DecodeResult<T> = match from_str(to_parse) {\n             Err(e) => Err(ParseError(e)),\n             Ok(json) => Decodable::decode(&mut Decoder::new(json))"}, {"sha": "84180159c2be7a16a1ae07c47b8f17ff25b24eef", "filename": "src/libserialize/json_stage0.rs", "status": "added", "additions": 3883, "deletions": 0, "changes": 3883, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fjson_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fjson_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson_stage0.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62"}, {"sha": "8ad2013f9368f256fe50f734ce8a59eaff30502c", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -40,11 +40,25 @@ extern crate collections;\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n                           DecoderHelpers, EncoderHelpers};\n \n+#[cfg(stage0)]\n+#[path = \"serialize_stage0.rs\"]\n mod serialize;\n+#[cfg(not(stage0))]\n+mod serialize;\n+\n+#[cfg(stage0)]\n+#[path = \"collection_impls_stage0.rs\"]\n+mod collection_impls;\n+#[cfg(not(stage0))]\n mod collection_impls;\n \n pub mod base64;\n pub mod hex;\n+\n+#[cfg(stage0)]\n+#[path = \"json_stage0.rs\"]\n+pub mod json;\n+#[cfg(not(stage0))]\n pub mod json;\n \n mod rustc_serialize {"}, {"sha": "0646ee1758fc0f6b19af44260ab55a5479d14132", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 267, "deletions": 246, "changes": 513, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -19,406 +19,424 @@ use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n use std::sync::Arc;\n \n-pub trait Encoder<E> {\n+pub trait Encoder {\n+    type Error;\n+\n     // Primitive types:\n-    fn emit_nil(&mut self) -> Result<(), E>;\n-    fn emit_uint(&mut self, v: uint) -> Result<(), E>;\n-    fn emit_u64(&mut self, v: u64) -> Result<(), E>;\n-    fn emit_u32(&mut self, v: u32) -> Result<(), E>;\n-    fn emit_u16(&mut self, v: u16) -> Result<(), E>;\n-    fn emit_u8(&mut self, v: u8) -> Result<(), E>;\n-    fn emit_int(&mut self, v: int) -> Result<(), E>;\n-    fn emit_i64(&mut self, v: i64) -> Result<(), E>;\n-    fn emit_i32(&mut self, v: i32) -> Result<(), E>;\n-    fn emit_i16(&mut self, v: i16) -> Result<(), E>;\n-    fn emit_i8(&mut self, v: i8) -> Result<(), E>;\n-    fn emit_bool(&mut self, v: bool) -> Result<(), E>;\n-    fn emit_f64(&mut self, v: f64) -> Result<(), E>;\n-    fn emit_f32(&mut self, v: f32) -> Result<(), E>;\n-    fn emit_char(&mut self, v: char) -> Result<(), E>;\n-    fn emit_str(&mut self, v: &str) -> Result<(), E>;\n+    fn emit_nil(&mut self) -> Result<(), Self::Error>;\n+    fn emit_uint(&mut self, v: uint) -> Result<(), Self::Error>;\n+    fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n+    fn emit_u32(&mut self, v: u32) -> Result<(), Self::Error>;\n+    fn emit_u16(&mut self, v: u16) -> Result<(), Self::Error>;\n+    fn emit_u8(&mut self, v: u8) -> Result<(), Self::Error>;\n+    fn emit_int(&mut self, v: int) -> Result<(), Self::Error>;\n+    fn emit_i64(&mut self, v: i64) -> Result<(), Self::Error>;\n+    fn emit_i32(&mut self, v: i32) -> Result<(), Self::Error>;\n+    fn emit_i16(&mut self, v: i16) -> Result<(), Self::Error>;\n+    fn emit_i8(&mut self, v: i8) -> Result<(), Self::Error>;\n+    fn emit_bool(&mut self, v: bool) -> Result<(), Self::Error>;\n+    fn emit_f64(&mut self, v: f64) -> Result<(), Self::Error>;\n+    fn emit_f32(&mut self, v: f32) -> Result<(), Self::Error>;\n+    fn emit_char(&mut self, v: char) -> Result<(), Self::Error>;\n+    fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n \n     // Compound types:\n-    fn emit_enum<F>(&mut self, name: &str, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_enum<F>(&mut self, name: &str, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n     fn emit_enum_variant<F>(&mut self, v_name: &str,\n                             v_id: uint,\n                             len: uint,\n-                            f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_enum_variant_arg<F>(&mut self, a_idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n+                            f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_enum_variant_arg<F>(&mut self, a_idx: uint, f: F)\n+                                -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n     fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n                                    v_id: uint,\n                                    len: uint,\n-                                   f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n+                                   f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n     fn emit_enum_struct_variant_field<F>(&mut self,\n                                          f_name: &str,\n                                          f_idx: uint,\n-                                         f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n+                                         f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+\n+    fn emit_struct<F>(&mut self, name: &str, len: uint, f: F)\n+                      -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: uint, f: F)\n+                            -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+\n+    fn emit_tuple<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+\n+    fn emit_tuple_struct<F>(&mut self, name: &str, len: uint, f: F)\n+                            -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_tuple_struct_arg<F>(&mut self, f_idx: uint, f: F)\n+                                -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+\n+    // Specialized types:\n+    fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_option_none(&mut self) -> Result<(), Self::Error>;\n+    fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_seq<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n \n-    fn emit_tuple<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_map<F>(&mut self, len: uint, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+        where F: FnMut(&mut Self) -> Result<(), Self::Error>;\n+    fn emit_map_elt_val<F>(&mut self, idx: uint, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>;\n+}\n \n-    fn emit_tuple_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_tuple_struct_arg<F>(&mut self, f_idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n+pub trait Decoder {\n+    type Error;\n \n-    // Specialized types:\n-    fn emit_option<F>(&mut self, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_option_none(&mut self) -> Result<(), E>;\n-    fn emit_option_some<F>(&mut self, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    fn emit_seq<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-\n-    fn emit_map<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n-        F: FnMut(&mut Self) -> Result<(), E>;\n-    fn emit_map_elt_val<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n-        F: FnOnce(&mut Self) -> Result<(), E>;\n-}\n-\n-pub trait Decoder<E> {\n     // Primitive types:\n-    fn read_nil(&mut self) -> Result<(), E>;\n-    fn read_uint(&mut self) -> Result<uint, E>;\n-    fn read_u64(&mut self) -> Result<u64, E>;\n-    fn read_u32(&mut self) -> Result<u32, E>;\n-    fn read_u16(&mut self) -> Result<u16, E>;\n-    fn read_u8(&mut self) -> Result<u8, E>;\n-    fn read_int(&mut self) -> Result<int, E>;\n-    fn read_i64(&mut self) -> Result<i64, E>;\n-    fn read_i32(&mut self) -> Result<i32, E>;\n-    fn read_i16(&mut self) -> Result<i16, E>;\n-    fn read_i8(&mut self) -> Result<i8, E>;\n-    fn read_bool(&mut self) -> Result<bool, E>;\n-    fn read_f64(&mut self) -> Result<f64, E>;\n-    fn read_f32(&mut self) -> Result<f32, E>;\n-    fn read_char(&mut self) -> Result<char, E>;\n-    fn read_str(&mut self) -> Result<String, E>;\n+    fn read_nil(&mut self) -> Result<(), Self::Error>;\n+    fn read_uint(&mut self) -> Result<uint, Self::Error>;\n+    fn read_u64(&mut self) -> Result<u64, Self::Error>;\n+    fn read_u32(&mut self) -> Result<u32, Self::Error>;\n+    fn read_u16(&mut self) -> Result<u16, Self::Error>;\n+    fn read_u8(&mut self) -> Result<u8, Self::Error>;\n+    fn read_int(&mut self) -> Result<int, Self::Error>;\n+    fn read_i64(&mut self) -> Result<i64, Self::Error>;\n+    fn read_i32(&mut self) -> Result<i32, Self::Error>;\n+    fn read_i16(&mut self) -> Result<i16, Self::Error>;\n+    fn read_i8(&mut self) -> Result<i8, Self::Error>;\n+    fn read_bool(&mut self) -> Result<bool, Self::Error>;\n+    fn read_f64(&mut self) -> Result<f64, Self::Error>;\n+    fn read_f32(&mut self) -> Result<f32, Self::Error>;\n+    fn read_char(&mut self) -> Result<char, Self::Error>;\n+    fn read_str(&mut self) -> Result<String, Self::Error>;\n \n     // Compound types:\n-    fn read_enum<T, F>(&mut self, name: &str, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n-        F: FnMut(&mut Self, uint) -> Result<T, E>;\n-    fn read_enum_variant_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n-        F: FnMut(&mut Self, uint) -> Result<T, E>;\n+    fn read_enum<T, F>(&mut self, name: &str, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+\n+    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F)\n+                               -> Result<T, Self::Error>\n+        where F: FnMut(&mut Self, uint) -> Result<T, Self::Error>;\n+    fn read_enum_variant_arg<T, F>(&mut self, a_idx: uint, f: F)\n+                                   -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+\n+    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F)\n+                                      -> Result<T, Self::Error>\n+        where F: FnMut(&mut Self, uint) -> Result<T, Self::Error>;\n     fn read_enum_struct_variant_field<T, F>(&mut self,\n                                             &f_name: &str,\n                                             f_idx: uint,\n                                             f: F)\n-                                            -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n+                                            -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n-    fn read_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_struct<T, F>(&mut self, s_name: &str, len: uint, f: F)\n+                         -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n     fn read_struct_field<T, F>(&mut self,\n                                f_name: &str,\n                                f_idx: uint,\n                                f: F)\n-                               -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_tuple<T, F>(&mut self, len: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-    fn read_tuple_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n+                               -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+\n+    fn read_tuple<T, F>(&mut self, len: uint, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+    fn read_tuple_arg<T, F>(&mut self, a_idx: uint, f: F)\n+                            -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+\n+    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: uint, f: F)\n+                               -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: uint, f: F)\n+                                   -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n     // Specialized types:\n-    fn read_option<T, F>(&mut self, f: F) -> Result<T, E> where\n-        F: FnMut(&mut Self, bool) -> Result<T, E>;\n-\n-    fn read_seq<T, F>(&mut self, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n-    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-\n-    fn read_map<T, F>(&mut self, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n-    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n-    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n-        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_option<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+        where F: FnMut(&mut Self, bool) -> Result<T, Self::Error>;\n+\n+    fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self, uint) -> Result<T, Self::Error>;\n+    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+\n+    fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self, uint) -> Result<T, Self::Error>;\n+    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F)\n+                              -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n+    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F)\n+                              -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>;\n \n     // Failure\n-    fn error(&mut self, err: &str) -> E;\n+    fn error(&mut self, err: &str) -> Self::Error;\n }\n \n-pub trait Encodable<S:Encoder<E>, E> for Sized? {\n-    fn encode(&self, s: &mut S) -> Result<(), E>;\n+pub trait Encodable for Sized? {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error>;\n }\n \n-pub trait Decodable<D:Decoder<E>, E> {\n-    fn decode(d: &mut D) -> Result<Self, E>;\n+pub trait Decodable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error>;\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for uint {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for uint {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_uint(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for uint {\n-    fn decode(d: &mut D) -> Result<uint, E> {\n+impl Decodable for uint {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<uint, D::Error> {\n         d.read_uint()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for u8 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for u8 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u8(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for u8 {\n-    fn decode(d: &mut D) -> Result<u8, E> {\n+impl Decodable for u8 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<u8, D::Error> {\n         d.read_u8()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for u16 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for u16 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u16(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for u16 {\n-    fn decode(d: &mut D) -> Result<u16, E> {\n+impl Decodable for u16 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<u16, D::Error> {\n         d.read_u16()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for u32 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for u32 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u32(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for u32 {\n-    fn decode(d: &mut D) -> Result<u32, E> {\n+impl Decodable for u32 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<u32, D::Error> {\n         d.read_u32()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for u64 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for u64 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_u64(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for u64 {\n-    fn decode(d: &mut D) -> Result<u64, E> {\n+impl Decodable for u64 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<u64, D::Error> {\n         d.read_u64()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for int {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for int {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_int(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for int {\n-    fn decode(d: &mut D) -> Result<int, E> {\n+impl Decodable for int {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<int, D::Error> {\n         d.read_int()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for i8 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for i8 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i8(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for i8 {\n-    fn decode(d: &mut D) -> Result<i8, E> {\n+impl Decodable for i8 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<i8, D::Error> {\n         d.read_i8()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for i16 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for i16 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i16(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for i16 {\n-    fn decode(d: &mut D) -> Result<i16, E> {\n+impl Decodable for i16 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<i16, D::Error> {\n         d.read_i16()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for i32 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for i32 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i32(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for i32 {\n-    fn decode(d: &mut D) -> Result<i32, E> {\n+impl Decodable for i32 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<i32, D::Error> {\n         d.read_i32()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for i64 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for i64 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_i64(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for i64 {\n-    fn decode(d: &mut D) -> Result<i64, E> {\n+impl Decodable for i64 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<i64, D::Error> {\n         d.read_i64()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for str {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for str {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self)\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for String {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for String {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self[])\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for String {\n-    fn decode(d: &mut D) -> Result<String, E> {\n+impl Decodable for String {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<String, D::Error> {\n         d.read_str()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for f32 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for f32 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_f32(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for f32 {\n-    fn decode(d: &mut D) -> Result<f32, E> {\n+impl Decodable for f32 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<f32, D::Error> {\n         d.read_f32()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for f64 {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for f64 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_f64(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for f64 {\n-    fn decode(d: &mut D) -> Result<f64, E> {\n+impl Decodable for f64 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<f64, D::Error> {\n         d.read_f64()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for bool {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for bool {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_bool(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for bool {\n-    fn decode(d: &mut D) -> Result<bool, E> {\n+impl Decodable for bool {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<bool, D::Error> {\n         d.read_bool()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for char {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for char {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_char(*self)\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for char {\n-    fn decode(d: &mut D) -> Result<char, E> {\n+impl Decodable for char {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<char, D::Error> {\n         d.read_char()\n     }\n }\n \n-impl<E, S:Encoder<E>> Encodable<S, E> for () {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl Encodable for () {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_nil()\n     }\n }\n \n-impl<E, D:Decoder<E>> Decodable<D, E> for () {\n-    fn decode(d: &mut D) -> Result<(), E> {\n+impl Decodable for () {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<(), D::Error> {\n         d.read_nil()\n     }\n }\n \n-impl<'a, E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for &'a T {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl<'a, Sized? T: Encodable> Encodable for &'a T {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for Box<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl<Sized? T: Encodable> Encodable for Box<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<T> {\n-    fn decode(d: &mut D) -> Result<Box<T>, E> {\n+impl< T: Decodable> Decodable for Box<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Box<T>, D::Error> {\n         Ok(box try!(Decodable::decode(d)))\n     }\n }\n \n-impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<[T]> {\n-    fn decode(d: &mut D) -> Result<Box<[T]>, E> {\n+impl< T: Decodable> Decodable for Box<[T]> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Box<[T]>, D::Error> {\n         let v: Vec<T> = try!(Decodable::decode(d));\n         Ok(v.into_boxed_slice())\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Rc<T> {\n+impl<T:Encodable> Encodable for Rc<T> {\n     #[inline]\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Rc<T> {\n+impl<T:Decodable> Decodable for Rc<T> {\n     #[inline]\n-    fn decode(d: &mut D) -> Result<Rc<T>, E> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Rc<T>, D::Error> {\n         Ok(Rc::new(try!(Decodable::decode(d))))\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for [T] {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl<T:Encodable> Encodable for [T] {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 try!(s.emit_seq_elt(i, |s| e.encode(s)))\n@@ -428,8 +446,8 @@ impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for [T] {\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Vec<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl<T:Encodable> Encodable for Vec<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n                 try!(s.emit_seq_elt(i, |s| e.encode(s)))\n@@ -439,8 +457,8 @@ impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Vec<T> {\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Vec<T> {\n-    fn decode(d: &mut D) -> Result<Vec<T>, E> {\n+impl<T:Decodable> Decodable for Vec<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Vec<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in range(0, len) {\n@@ -451,8 +469,8 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Vec<T> {\n     }\n }\n \n-impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Option<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl<T:Encodable> Encodable for Option<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_option(|s| {\n             match *self {\n                 None => s.emit_option_none(),\n@@ -462,8 +480,8 @@ impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Option<T> {\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Option<T> {\n-    fn decode(d: &mut D) -> Result<Option<T>, E> {\n+impl<T:Decodable> Decodable for Option<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Option<T>, D::Error> {\n         d.read_option(|d, b| {\n             if b {\n                 Ok(Some(try!(Decodable::decode(d))))\n@@ -487,22 +505,23 @@ macro_rules! count_idents {\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        impl<E, D:Decoder<E>,$($name:Decodable<D, E>),*> Decodable<D,E> for ($($name,)*) {\n+        impl<$($name:Decodable),*> Decodable for ($($name,)*) {\n             #[allow(non_snake_case)]\n-            fn decode(d: &mut D) -> Result<($($name,)*), E> {\n+            fn decode<D: Decoder>(d: &mut D) -> Result<($($name,)*), D::Error> {\n                 let len: uint = count_idents!($($name),*);\n                 d.read_tuple(len, |d| {\n                     let mut i = 0;\n-                    let ret = ($(try!(d.read_tuple_arg({ i+=1; i-1 }, |d| -> Result<$name,E> {\n+                    let ret = ($(try!(d.read_tuple_arg({ i+=1; i-1 },\n+                                                       |d| -> Result<$name,D::Error> {\n                         Decodable::decode(d)\n                     })),)*);\n                     return Ok(ret);\n                 })\n             }\n         }\n-        impl<E, S:Encoder<E>,$($name:Encodable<S, E>),*> Encodable<S, E> for ($($name,)*) {\n+        impl<$($name:Encodable),*> Encodable for ($($name,)*) {\n             #[allow(non_snake_case)]\n-            fn encode(&self, s: &mut S) -> Result<(), E> {\n+            fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n                 let ($(ref $name,)*) = *self;\n                 let mut n = 0;\n                 $(let $name = $name; n += 1;)*\n@@ -519,40 +538,40 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl<E, S: Encoder<E>> Encodable<S, E> for path::posix::Path {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n+impl Encodable for path::posix::Path {\n+    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.as_vec().encode(e)\n     }\n }\n \n-impl<E, D: Decoder<E>> Decodable<D, E> for path::posix::Path {\n-    fn decode(d: &mut D) -> Result<path::posix::Path, E> {\n+impl Decodable for path::posix::Path {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<path::posix::Path, D::Error> {\n         let bytes: Vec<u8> = try!(Decodable::decode(d));\n         Ok(path::posix::Path::new(bytes))\n     }\n }\n \n-impl<E, S: Encoder<E>> Encodable<S, E> for path::windows::Path {\n-    fn encode(&self, e: &mut S) -> Result<(), E> {\n+impl Encodable for path::windows::Path {\n+    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n         self.as_vec().encode(e)\n     }\n }\n \n-impl<E, D: Decoder<E>> Decodable<D, E> for path::windows::Path {\n-    fn decode(d: &mut D) -> Result<path::windows::Path, E> {\n+impl Decodable for path::windows::Path {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<path::windows::Path, D::Error> {\n         let bytes: Vec<u8> = try!(Decodable::decode(d));\n         Ok(path::windows::Path::new(bytes))\n     }\n }\n \n-impl<E, S: Encoder<E>, T: Encodable<S, E> + Copy> Encodable<S, E> for Cell<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl<T: Encodable + Copy> Encodable for Cell<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.get().encode(s)\n     }\n }\n \n-impl<E, D: Decoder<E>, T: Decodable<D, E> + Copy> Decodable<D, E> for Cell<T> {\n-    fn decode(d: &mut D) -> Result<Cell<T>, E> {\n+impl<T: Decodable + Copy> Decodable for Cell<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Cell<T>, D::Error> {\n         Ok(Cell::new(try!(Decodable::decode(d))))\n     }\n }\n@@ -562,41 +581,42 @@ impl<E, D: Decoder<E>, T: Decodable<D, E> + Copy> Decodable<D, E> for Cell<T> {\n // `encoder.error(\"attempting to Encode borrowed RefCell\")`\n // from `encode` when `try_borrow` returns `None`.\n \n-impl<E, S: Encoder<E>, T: Encodable<S, E>> Encodable<S, E> for RefCell<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl<T: Encodable> Encodable for RefCell<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.borrow().encode(s)\n     }\n }\n \n-impl<E, D: Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for RefCell<T> {\n-    fn decode(d: &mut D) -> Result<RefCell<T>, E> {\n+impl<T: Decodable> Decodable for RefCell<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<RefCell<T>, D::Error> {\n         Ok(RefCell::new(try!(Decodable::decode(d))))\n     }\n }\n \n-impl<E, S:Encoder<E>, T:Encodable<S, E>> Encodable<S, E> for Arc<T> {\n-    fn encode(&self, s: &mut S) -> Result<(), E> {\n+impl<T:Encodable> Encodable for Arc<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         (**self).encode(s)\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>+Send+Sync> Decodable<D, E> for Arc<T> {\n-    fn decode(d: &mut D) -> Result<Arc<T>, E> {\n+impl<T:Decodable+Send+Sync> Decodable for Arc<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Arc<T>, D::Error> {\n         Ok(Arc::new(try!(Decodable::decode(d))))\n     }\n }\n \n // ___________________________________________________________________________\n // Helper routines\n \n-pub trait EncoderHelpers<E> {\n-    fn emit_from_vec<T, F>(&mut self, v: &[T], f: F) -> Result<(), E> where\n-        F: FnMut(&mut Self, &T) -> Result<(), E>;\n+pub trait EncoderHelpers: Encoder {\n+    fn emit_from_vec<T, F>(&mut self, v: &[T], f: F)\n+                           -> Result<(), <Self as Encoder>::Error>\n+        where F: FnMut(&mut Self, &T) -> Result<(), <Self as Encoder>::Error>;\n }\n \n-impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n-    fn emit_from_vec<T, F>(&mut self, v: &[T], mut f: F) -> Result<(), E> where\n-        F: FnMut(&mut S, &T) -> Result<(), E>,\n+impl<S:Encoder> EncoderHelpers for S {\n+    fn emit_from_vec<T, F>(&mut self, v: &[T], mut f: F) -> Result<(), S::Error> where\n+        F: FnMut(&mut S, &T) -> Result<(), S::Error>,\n     {\n         self.emit_seq(v.len(), |this| {\n             for (i, e) in v.iter().enumerate() {\n@@ -609,14 +629,15 @@ impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n     }\n }\n \n-pub trait DecoderHelpers<E> {\n-    fn read_to_vec<T, F>(&mut self, f: F) -> Result<Vec<T>, E> where\n-        F: FnMut(&mut Self) -> Result<T, E>;\n+pub trait DecoderHelpers: Decoder {\n+    fn read_to_vec<T, F>(&mut self, f: F)\n+                         -> Result<Vec<T>, <Self as Decoder>::Error> where\n+        F: FnMut(&mut Self) -> Result<T, <Self as Decoder>::Error>;\n }\n \n-impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n-    fn read_to_vec<T, F>(&mut self, mut f: F) -> Result<Vec<T>, E> where F:\n-        FnMut(&mut D) -> Result<T, E>,\n+impl<D: Decoder> DecoderHelpers for D {\n+    fn read_to_vec<T, F>(&mut self, mut f: F) -> Result<Vec<T>, D::Error> where F:\n+        FnMut(&mut D) -> Result<T, D::Error>,\n     {\n         self.read_seq(|this, len| {\n             let mut v = Vec::with_capacity(len);"}, {"sha": "558f9e603e15989fd8ccbd1607761883ffe6d235", "filename": "src/libserialize/serialize_stage0.rs", "status": "added", "additions": 629, "deletions": 0, "changes": 629, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fserialize_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibserialize%2Fserialize_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize_stage0.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -0,0 +1,629 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Support code for encoding and decoding types.\n+\n+/*\n+Core encoding and decoding interfaces.\n+*/\n+\n+use std::path;\n+use std::rc::Rc;\n+use std::cell::{Cell, RefCell};\n+use std::sync::Arc;\n+\n+pub trait Encoder<E> {\n+    // Primitive types:\n+    fn emit_nil(&mut self) -> Result<(), E>;\n+    fn emit_uint(&mut self, v: uint) -> Result<(), E>;\n+    fn emit_u64(&mut self, v: u64) -> Result<(), E>;\n+    fn emit_u32(&mut self, v: u32) -> Result<(), E>;\n+    fn emit_u16(&mut self, v: u16) -> Result<(), E>;\n+    fn emit_u8(&mut self, v: u8) -> Result<(), E>;\n+    fn emit_int(&mut self, v: int) -> Result<(), E>;\n+    fn emit_i64(&mut self, v: i64) -> Result<(), E>;\n+    fn emit_i32(&mut self, v: i32) -> Result<(), E>;\n+    fn emit_i16(&mut self, v: i16) -> Result<(), E>;\n+    fn emit_i8(&mut self, v: i8) -> Result<(), E>;\n+    fn emit_bool(&mut self, v: bool) -> Result<(), E>;\n+    fn emit_f64(&mut self, v: f64) -> Result<(), E>;\n+    fn emit_f32(&mut self, v: f32) -> Result<(), E>;\n+    fn emit_char(&mut self, v: char) -> Result<(), E>;\n+    fn emit_str(&mut self, v: &str) -> Result<(), E>;\n+\n+    // Compound types:\n+    fn emit_enum<F>(&mut self, name: &str, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_enum_variant<F>(&mut self, v_name: &str,\n+                            v_id: uint,\n+                            len: uint,\n+                            f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_enum_variant_arg<F>(&mut self, a_idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n+                                   v_id: uint,\n+                                   len: uint,\n+                                   f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_enum_struct_variant_field<F>(&mut self,\n+                                         f_name: &str,\n+                                         f_idx: uint,\n+                                         f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_struct_field<F>(&mut self, f_name: &str, f_idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_tuple<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_tuple_arg<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_tuple_struct<F>(&mut self, name: &str, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_tuple_struct_arg<F>(&mut self, f_idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    // Specialized types:\n+    fn emit_option<F>(&mut self, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_option_none(&mut self) -> Result<(), E>;\n+    fn emit_option_some<F>(&mut self, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_seq<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_seq_elt<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+\n+    fn emit_map<F>(&mut self, len: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+    fn emit_map_elt_key<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnMut(&mut Self) -> Result<(), E>;\n+    fn emit_map_elt_val<F>(&mut self, idx: uint, f: F) -> Result<(), E> where\n+        F: FnOnce(&mut Self) -> Result<(), E>;\n+}\n+\n+pub trait Decoder<E> {\n+    // Primitive types:\n+    fn read_nil(&mut self) -> Result<(), E>;\n+    fn read_uint(&mut self) -> Result<uint, E>;\n+    fn read_u64(&mut self) -> Result<u64, E>;\n+    fn read_u32(&mut self) -> Result<u32, E>;\n+    fn read_u16(&mut self) -> Result<u16, E>;\n+    fn read_u8(&mut self) -> Result<u8, E>;\n+    fn read_int(&mut self) -> Result<int, E>;\n+    fn read_i64(&mut self) -> Result<i64, E>;\n+    fn read_i32(&mut self) -> Result<i32, E>;\n+    fn read_i16(&mut self) -> Result<i16, E>;\n+    fn read_i8(&mut self) -> Result<i8, E>;\n+    fn read_bool(&mut self) -> Result<bool, E>;\n+    fn read_f64(&mut self) -> Result<f64, E>;\n+    fn read_f32(&mut self) -> Result<f32, E>;\n+    fn read_char(&mut self) -> Result<char, E>;\n+    fn read_str(&mut self) -> Result<String, E>;\n+\n+    // Compound types:\n+    fn read_enum<T, F>(&mut self, name: &str, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_enum_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n+        F: FnMut(&mut Self, uint) -> Result<T, E>;\n+    fn read_enum_variant_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, E> where\n+        F: FnMut(&mut Self, uint) -> Result<T, E>;\n+    fn read_enum_struct_variant_field<T, F>(&mut self,\n+                                            &f_name: &str,\n+                                            f_idx: uint,\n+                                            f: F)\n+                                            -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_struct_field<T, F>(&mut self,\n+                               f_name: &str,\n+                               f_idx: uint,\n+                               f: F)\n+                               -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_tuple<T, F>(&mut self, len: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_tuple_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_tuple_struct<T, F>(&mut self, s_name: &str, len: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    // Specialized types:\n+    fn read_option<T, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnMut(&mut Self, bool) -> Result<T, E>;\n+\n+    fn read_seq<T, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_seq_elt<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    fn read_map<T, F>(&mut self, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self, uint) -> Result<T, E>;\n+    fn read_map_elt_key<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+    fn read_map_elt_val<T, F>(&mut self, idx: uint, f: F) -> Result<T, E> where\n+        F: FnOnce(&mut Self) -> Result<T, E>;\n+\n+    // Failure\n+    fn error(&mut self, err: &str) -> E;\n+}\n+\n+pub trait Encodable<S:Encoder<E>, E> for Sized? {\n+    fn encode(&self, s: &mut S) -> Result<(), E>;\n+}\n+\n+pub trait Decodable<D:Decoder<E>, E> {\n+    fn decode(d: &mut D) -> Result<Self, E>;\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for uint {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_uint(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for uint {\n+    fn decode(d: &mut D) -> Result<uint, E> {\n+        d.read_uint()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for u8 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_u8(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for u8 {\n+    fn decode(d: &mut D) -> Result<u8, E> {\n+        d.read_u8()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for u16 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_u16(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for u16 {\n+    fn decode(d: &mut D) -> Result<u16, E> {\n+        d.read_u16()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for u32 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_u32(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for u32 {\n+    fn decode(d: &mut D) -> Result<u32, E> {\n+        d.read_u32()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for u64 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_u64(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for u64 {\n+    fn decode(d: &mut D) -> Result<u64, E> {\n+        d.read_u64()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for int {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_int(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for int {\n+    fn decode(d: &mut D) -> Result<int, E> {\n+        d.read_int()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for i8 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_i8(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for i8 {\n+    fn decode(d: &mut D) -> Result<i8, E> {\n+        d.read_i8()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for i16 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_i16(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for i16 {\n+    fn decode(d: &mut D) -> Result<i16, E> {\n+        d.read_i16()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for i32 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_i32(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for i32 {\n+    fn decode(d: &mut D) -> Result<i32, E> {\n+        d.read_i32()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for i64 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_i64(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for i64 {\n+    fn decode(d: &mut D) -> Result<i64, E> {\n+        d.read_i64()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for str {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_str(self)\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for String {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_str(self[])\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for String {\n+    fn decode(d: &mut D) -> Result<String, E> {\n+        d.read_str()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for f32 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_f32(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for f32 {\n+    fn decode(d: &mut D) -> Result<f32, E> {\n+        d.read_f32()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for f64 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_f64(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for f64 {\n+    fn decode(d: &mut D) -> Result<f64, E> {\n+        d.read_f64()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for bool {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_bool(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for bool {\n+    fn decode(d: &mut D) -> Result<bool, E> {\n+        d.read_bool()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for char {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_char(*self)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for char {\n+    fn decode(d: &mut D) -> Result<char, E> {\n+        d.read_char()\n+    }\n+}\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for () {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_nil()\n+    }\n+}\n+\n+impl<E, D:Decoder<E>> Decodable<D, E> for () {\n+    fn decode(d: &mut D) -> Result<(), E> {\n+        d.read_nil()\n+    }\n+}\n+\n+impl<'a, E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for &'a T {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<E, S: Encoder<E>, Sized? T: Encodable<S, E>> Encodable<S, E> for Box<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<T> {\n+    fn decode(d: &mut D) -> Result<Box<T>, E> {\n+        Ok(box try!(Decodable::decode(d)))\n+    }\n+}\n+\n+impl<E, D:Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for Box<[T]> {\n+    fn decode(d: &mut D) -> Result<Box<[T]>, E> {\n+        let v: Vec<T> = try!(Decodable::decode(d));\n+        Ok(v.into_boxed_slice())\n+    }\n+}\n+\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Rc<T> {\n+    #[inline]\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Rc<T> {\n+    #[inline]\n+    fn decode(d: &mut D) -> Result<Rc<T>, E> {\n+        Ok(Rc::new(try!(Decodable::decode(d))))\n+    }\n+}\n+\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for [T] {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Vec<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Vec<T> {\n+    fn decode(d: &mut D) -> Result<Vec<T>, E> {\n+        d.read_seq(|d, len| {\n+            let mut v = Vec::with_capacity(len);\n+            for i in range(0, len) {\n+                v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(v)\n+        })\n+    }\n+}\n+\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Option<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_option(|s| {\n+            match *self {\n+                None => s.emit_option_none(),\n+                Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n+            }\n+        })\n+    }\n+}\n+\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Option<T> {\n+    fn decode(d: &mut D) -> Result<Option<T>, E> {\n+        d.read_option(|d, b| {\n+            if b {\n+                Ok(Some(try!(Decodable::decode(d))))\n+            } else {\n+                Ok(None)\n+            }\n+        })\n+    }\n+}\n+\n+macro_rules! peel {\n+    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n+}\n+\n+/// Evaluates to the number of identifiers passed to it, for example: `count_idents!(a, b, c) == 3\n+macro_rules! count_idents {\n+    () => { 0u };\n+    ($_i:ident $(, $rest:ident)*) => { 1 + count_idents!($($rest),*) }\n+}\n+\n+macro_rules! tuple {\n+    () => ();\n+    ( $($name:ident,)+ ) => (\n+        impl<E, D:Decoder<E>,$($name:Decodable<D, E>),*> Decodable<D,E> for ($($name,)*) {\n+            #[allow(non_snake_case)]\n+            fn decode(d: &mut D) -> Result<($($name,)*), E> {\n+                let len: uint = count_idents!($($name),*);\n+                d.read_tuple(len, |d| {\n+                    let mut i = 0;\n+                    let ret = ($(try!(d.read_tuple_arg({ i+=1; i-1 }, |d| -> Result<$name,E> {\n+                        Decodable::decode(d)\n+                    })),)*);\n+                    return Ok(ret);\n+                })\n+            }\n+        }\n+        impl<E, S:Encoder<E>,$($name:Encodable<S, E>),*> Encodable<S, E> for ($($name,)*) {\n+            #[allow(non_snake_case)]\n+            fn encode(&self, s: &mut S) -> Result<(), E> {\n+                let ($(ref $name,)*) = *self;\n+                let mut n = 0;\n+                $(let $name = $name; n += 1;)*\n+                s.emit_tuple(n, |s| {\n+                    let mut i = 0;\n+                    $(try!(s.emit_tuple_arg({ i+=1; i-1 }, |s| $name.encode(s)));)*\n+                    Ok(())\n+                })\n+            }\n+        }\n+        peel! { $($name,)* }\n+    )\n+}\n+\n+tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n+\n+impl<E, S: Encoder<E>> Encodable<S, E> for path::posix::Path {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n+        self.as_vec().encode(e)\n+    }\n+}\n+\n+impl<E, D: Decoder<E>> Decodable<D, E> for path::posix::Path {\n+    fn decode(d: &mut D) -> Result<path::posix::Path, E> {\n+        let bytes: Vec<u8> = try!(Decodable::decode(d));\n+        Ok(path::posix::Path::new(bytes))\n+    }\n+}\n+\n+impl<E, S: Encoder<E>> Encodable<S, E> for path::windows::Path {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n+        self.as_vec().encode(e)\n+    }\n+}\n+\n+impl<E, D: Decoder<E>> Decodable<D, E> for path::windows::Path {\n+    fn decode(d: &mut D) -> Result<path::windows::Path, E> {\n+        let bytes: Vec<u8> = try!(Decodable::decode(d));\n+        Ok(path::windows::Path::new(bytes))\n+    }\n+}\n+\n+impl<E, S: Encoder<E>, T: Encodable<S, E> + Copy> Encodable<S, E> for Cell<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        self.get().encode(s)\n+    }\n+}\n+\n+impl<E, D: Decoder<E>, T: Decodable<D, E> + Copy> Decodable<D, E> for Cell<T> {\n+    fn decode(d: &mut D) -> Result<Cell<T>, E> {\n+        Ok(Cell::new(try!(Decodable::decode(d))))\n+    }\n+}\n+\n+// FIXME: #15036\n+// Should use `try_borrow`, returning a\n+// `encoder.error(\"attempting to Encode borrowed RefCell\")`\n+// from `encode` when `try_borrow` returns `None`.\n+\n+impl<E, S: Encoder<E>, T: Encodable<S, E>> Encodable<S, E> for RefCell<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        self.borrow().encode(s)\n+    }\n+}\n+\n+impl<E, D: Decoder<E>, T: Decodable<D, E>> Decodable<D, E> for RefCell<T> {\n+    fn decode(d: &mut D) -> Result<RefCell<T>, E> {\n+        Ok(RefCell::new(try!(Decodable::decode(d))))\n+    }\n+}\n+\n+impl<E, S:Encoder<E>, T:Encodable<S, E>> Encodable<S, E> for Arc<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<E, D:Decoder<E>,T:Decodable<D, E>+Send+Sync> Decodable<D, E> for Arc<T> {\n+    fn decode(d: &mut D) -> Result<Arc<T>, E> {\n+        Ok(Arc::new(try!(Decodable::decode(d))))\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Helper routines\n+\n+pub trait EncoderHelpers<E> {\n+    fn emit_from_vec<T, F>(&mut self, v: &[T], f: F) -> Result<(), E> where\n+        F: FnMut(&mut Self, &T) -> Result<(), E>;\n+}\n+\n+impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n+    fn emit_from_vec<T, F>(&mut self, v: &[T], mut f: F) -> Result<(), E> where\n+        F: FnMut(&mut S, &T) -> Result<(), E>,\n+    {\n+        self.emit_seq(v.len(), |this| {\n+            for (i, e) in v.iter().enumerate() {\n+                try!(this.emit_seq_elt(i, |this| {\n+                    f(this, e)\n+                }));\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+pub trait DecoderHelpers<E> {\n+    fn read_to_vec<T, F>(&mut self, f: F) -> Result<Vec<T>, E> where\n+        F: FnMut(&mut Self) -> Result<T, E>;\n+}\n+\n+impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n+    fn read_to_vec<T, F>(&mut self, mut f: F) -> Result<Vec<T>, E> where F:\n+        FnMut(&mut D) -> Result<T, E>,\n+    {\n+        self.read_seq(|this, len| {\n+            let mut v = Vec::with_capacity(len);\n+            for i in range(0, len) {\n+                v.push(try!(this.read_seq_elt(i, |this| f(this))));\n+            }\n+            Ok(v)\n+        })\n+    }\n+}"}, {"sha": "c9d27e304ff1594358fa02e48ca1245a5258e112", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -182,18 +182,34 @@ impl Name {\n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = u32;\n \n+#[cfg(stage0)]\n impl<S: Encoder<E>, E> Encodable<S, E> for Ident {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_str(token::get_ident(*self).get())\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Encodable for Ident {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(token::get_ident(*self).get())\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D: Decoder<E>, E> Decodable<D, E> for Ident {\n     fn decode(d: &mut D) -> Result<Ident, E> {\n         Ok(str_to_ident(try!(d.read_str())[]))\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Decodable for Ident {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Ident, D::Error> {\n+        Ok(str_to_ident(try!(d.read_str())[]))\n+    }\n+}\n+\n /// Function name (not all functions have names)\n pub type FnIdent = Option<Ident>;\n \n@@ -1686,27 +1702,7 @@ mod test {\n     // are ASTs encodable?\n     #[test]\n     fn check_asts_encodable() {\n-        use std::io;\n-        let e = Crate {\n-            module: Mod {\n-                inner: Span {\n-                    lo: BytePos(11),\n-                    hi: BytePos(19),\n-                    expn_id: NO_EXPANSION,\n-                },\n-                view_items: Vec::new(),\n-                items: Vec::new(),\n-            },\n-            attrs: Vec::new(),\n-            config: Vec::new(),\n-            span: Span {\n-                lo: BytePos(10),\n-                hi: BytePos(20),\n-                expn_id: NO_EXPANSION,\n-            },\n-            exported_macros: Vec::new(),\n-        };\n-        // doesn't matter which encoder we use....\n-        let _f = &e as &serialize::Encodable<json::Encoder, fmt::Error>;\n+        fn assert_encodable<T: serialize::Encodable>() {}\n+        assert_encodable::<Crate>();\n     }\n }"}, {"sha": "a49f2614cd7871f1d8eef024bdd677c07fba9b43", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -120,19 +120,36 @@ impl PartialEq for Span {\n \n impl Eq for Span {}\n \n+#[cfg(stage0)]\n impl<S:Encoder<E>, E> Encodable<S, E> for Span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_nil()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Encodable for Span {\n+    /* Note #1972 -- spans are encoded but not decoded */\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_nil()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D:Decoder<E>, E> Decodable<D, E> for Span {\n     fn decode(_d: &mut D) -> Result<Span, E> {\n         Ok(DUMMY_SP)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Decodable for Span {\n+    fn decode<D: Decoder>(_d: &mut D) -> Result<Span, D::Error> {\n+        Ok(DUMMY_SP)\n+    }\n+}\n+\n pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> Spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }"}, {"sha": "c0631b8350b8c5117b72aaab88263920175e810a", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -52,27 +52,29 @@ fn expand_deriving_decodable_imp<F>(cx: &mut ExtCtxt,\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec!(krate, \"Decodable\"), None,\n-                         vec!(box Literal(Path::new_local(\"__D\")),\n-                              box Literal(Path::new_local(\"__E\"))), true),\n+        path: Path::new_(vec!(krate, \"Decodable\"), None, vec!(), true),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds {\n-            lifetimes: Vec::new(),\n-            bounds: vec!((\"__D\", vec!(Path::new_(\n-                            vec!(krate, \"Decoder\"), None,\n-                            vec!(box Literal(Path::new_local(\"__E\"))), true))),\n-                         (\"__E\", vec!()))\n-        },\n+        generics: LifetimeBounds::empty(),\n         methods: vec!(\n             MethodDef {\n                 name: \"decode\",\n-                generics: LifetimeBounds::empty(),\n+                generics: LifetimeBounds {\n+                    lifetimes: Vec::new(),\n+                    bounds: vec!((\"__D\", vec!(Path::new_(\n+                                    vec!(krate, \"Decoder\"), None,\n+                                    vec!(), true))))\n+                },\n                 explicit_self: None,\n                 args: vec!(Ptr(box Literal(Path::new_local(\"__D\")),\n                             Borrowed(None, MutMutable))),\n-                ret_ty: Literal(Path::new_(vec!(\"std\", \"result\", \"Result\"), None,\n-                                          vec!(box Self,\n-                                               box Literal(Path::new_local(\"__E\"))), true)),\n+                ret_ty: Literal(Path::new_(\n+                    vec!(\"std\", \"result\", \"Result\"),\n+                    None,\n+                    vec!(box Self, box Literal(Path::new_(\n+                        vec![\"__D\", \"Error\"], None, vec![], false\n+                    ))),\n+                    true\n+                )),\n                 attributes: Vec::new(),\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     decodable_substructure(a, b, c, krate)"}, {"sha": "4323d2979cc061511499934bbadac0e39c425205", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -128,29 +128,29 @@ fn expand_deriving_encodable_imp<F>(cx: &mut ExtCtxt,\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec!(krate, \"Encodable\"), None,\n-                         vec!(box Literal(Path::new_local(\"__S\")),\n-                              box Literal(Path::new_local(\"__E\"))), true),\n+        path: Path::new_(vec!(krate, \"Encodable\"), None, vec!(), true),\n         additional_bounds: Vec::new(),\n-        generics: LifetimeBounds {\n-            lifetimes: Vec::new(),\n-            bounds: vec!((\"__S\", vec!(Path::new_(\n-                            vec!(krate, \"Encoder\"), None,\n-                            vec!(box Literal(Path::new_local(\"__E\"))), true))),\n-                         (\"__E\", vec!()))\n-        },\n+        generics: LifetimeBounds::empty(),\n         methods: vec!(\n             MethodDef {\n                 name: \"encode\",\n-                generics: LifetimeBounds::empty(),\n+                generics: LifetimeBounds {\n+                    lifetimes: Vec::new(),\n+                    bounds: vec!((\"__S\", vec!(Path::new_(\n+                                    vec!(krate, \"Encoder\"), None,\n+                                    vec!(), true))))\n+                },\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec!(Ptr(box Literal(Path::new_local(\"__S\")),\n                             Borrowed(None, MutMutable))),\n-                ret_ty: Literal(Path::new_(vec!(\"std\", \"result\", \"Result\"),\n-                                           None,\n-                                           vec!(box Tuple(Vec::new()),\n-                                                box Literal(Path::new_local(\"__E\"))),\n-                                           true)),\n+                ret_ty: Literal(Path::new_(\n+                    vec!(\"std\", \"result\", \"Result\"),\n+                    None,\n+                    vec!(box Tuple(Vec::new()), box Literal(Path::new_(\n+                        vec![\"__S\", \"Error\"], None, vec![], false\n+                    ))),\n+                    true\n+                )),\n                 attributes: Vec::new(),\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     encodable_substructure(a, b, c)"}, {"sha": "2a27431a0868cff224bbf2a32e6514cf363749e1", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -82,12 +82,21 @@ impl<T> FromIterator<T> for OwnedSlice<T> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: Encoder<E>, T: Encodable<S, E>, E> Encodable<S, E> for OwnedSlice<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n        self.as_slice().encode(s)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<T: Encodable> Encodable for OwnedSlice<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+       self.as_slice().encode(s)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<D: Decoder<E>, T: Decodable<D, E>, E> Decodable<D, E> for OwnedSlice<T> {\n     fn decode(d: &mut D) -> Result<OwnedSlice<T>, E> {\n         Ok(OwnedSlice::from_vec(match Decodable::decode(d) {\n@@ -96,3 +105,13 @@ impl<D: Decoder<E>, T: Decodable<D, E>, E> Decodable<D, E> for OwnedSlice<T> {\n         }))\n     }\n }\n+\n+#[cfg(not(stage0))]\n+impl<T: Decodable> Decodable for OwnedSlice<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<OwnedSlice<T>, D::Error> {\n+        Ok(OwnedSlice::from_vec(match Decodable::decode(d) {\n+            Ok(t) => t,\n+            Err(e) => return Err(e)\n+        }))\n+    }\n+}"}, {"sha": "b7e89b32b709e6f3c73cb20e5e6da9c1260ca3fe", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -653,19 +653,36 @@ impl<'a> PartialEq<InternedString > for &'a str {\n     }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n     fn decode(d: &mut D) -> Result<InternedString, E> {\n         Ok(get_name(get_ident_interner().intern(\n                     try!(d.read_str())[])))\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Decodable for InternedString {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n+        Ok(get_name(get_ident_interner().intern(\n+                    try!(d.read_str())[])))\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<S:Encoder<E>, E> Encodable<S, E> for InternedString {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_str(self.string[])\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Encodable for InternedString {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_str(self.string[])\n+    }\n+}\n+\n /// Returns the string contents of a name, using the task-local interner.\n #[inline]\n pub fn get_name(name: ast::Name) -> InternedString {"}, {"sha": "13eda7bb88f05eb48b05824d912bb240c85f31c4", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -111,14 +111,30 @@ impl<S, T: Hash<S>> Hash<S> for P<T> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<E, D: Decoder<E>, T: 'static + Decodable<D, E>> Decodable<D, E> for P<T> {\n     fn decode(d: &mut D) -> Result<P<T>, E> {\n         Decodable::decode(d).map(P)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<T: 'static + Decodable> Decodable for P<T> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n+        Decodable::decode(d).map(P)\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl<E, S: Encoder<E>, T: Encodable<S, E>> Encodable<S, E> for P<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n+\n+#[cfg(not(stage0))]\n+impl<T: Encodable> Encodable for P<T> {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        (**self).encode(s)\n+    }\n+}"}, {"sha": "cae7a4cefadb0c5635cc73a97bfa0ee9da3f1a30", "filename": "src/test/compile-fail/variance-trait-matching-2.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ed22606c8382822efc555f72f895c560289a5c70/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed22606c8382822efc555f72f895c560289a5c70/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-matching-2.rs?ref=ed22606c8382822efc555f72f895c560289a5c70", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-extern crate serialize;\n-\n-use std::fmt;\n-use serialize::{Encodable, Encoder};\n-\n-pub fn buffer_encode<'a,\n-                     T:Encodable<serialize::json::Encoder<'a>,fmt::Error>>(\n-                     to_encode_object: &T)\n-                     -> String {\n-    let mut m = String::new();\n-    {\n-        let mut encoder =\n-            serialize::json::Encoder::new(&mut m);\n-        //~^ ERROR `m` does not live long enough\n-        to_encode_object.encode(&mut encoder);\n-    }\n-    m\n-}\n-\n-fn main() {}"}, {"sha": "d0d8a8589a4e2b861232dc0dd777b8683b75f218", "filename": "src/test/run-pass/issue-11881.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Ftest%2Frun-pass%2Fissue-11881.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11881.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -40,16 +40,10 @@ enum WireProtocol {\n     // ...\n }\n \n-fn encode_json<\n-               T: for<'a> Encodable<json::Encoder<'a>,\n-                            fmt::Error>>(val: &T,\n-                                               wr: &mut SeekableMemWriter) {\n+fn encode_json<T: Encodable>(val: &T, wr: &mut SeekableMemWriter) {\n     write!(wr, \"{}\", json::as_json(val));\n }\n-fn encode_rbml<'a,\n-               T: Encodable<writer::Encoder<'a, SeekableMemWriter>,\n-                            io::IoError>>(val: &T,\n-                                               wr: &'a mut SeekableMemWriter) {\n+fn encode_rbml<T: Encodable>(val: &T, wr: &mut SeekableMemWriter) {\n     let mut encoder = writer::Encoder::new(wr);\n     val.encode(&mut encoder);\n }"}, {"sha": "db9f1cc9df7c9138c4b577c0bf083ef6c31d5204", "filename": "src/test/run-pass/issue-15924.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15924.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -21,7 +21,7 @@ struct Foo<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: for<'a> Encodable<json::Encoder<'a>, fmt::Error>> Drop for Foo<T> {\n+impl<T: Encodable> Drop for Foo<T> {\n     fn drop(&mut self) {\n         json::encode(&self.v);\n     }"}, {"sha": "220332f63548af28921350fec8d9cd2fe38f1c55", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0cb7a4062a3c69bb0c54f0c9136889a1006e4f62/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=0cb7a4062a3c69bb0c54f0c9136889a1006e4f62", "patch": "@@ -13,7 +13,7 @@ extern crate serialize;\n \n use serialize::{json, Decodable};\n \n-trait JD : Decodable<json::Decoder, json::DecoderError> { }\n+trait JD : Decodable {}\n \n fn exec<T: JD>() {\n     let doc = json::from_str(\"\").unwrap();"}]}