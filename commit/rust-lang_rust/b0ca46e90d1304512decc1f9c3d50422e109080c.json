{"sha": "b0ca46e90d1304512decc1f9c3d50422e109080c", "node_id": "C_kwDOAAsO6NoAKGIwY2E0NmU5MGQxMzA0NTEyZGVjYzFmOWMzZDUwNDIyZTEwOTA4MGM", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-04-03T11:32:34Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-04-03T11:51:38Z"}, "message": "Update safety comments, make `split_at_mut` unsafe\n\n`&mut [T]` implies validity which automatically makes `ptr::add` ok within its bounds.\nBut `*mut [T]` does not. Since we still want the benefits of in-bounds pointer arithmetic\n`split_at_must` must require the caller to pass valid pointers and therefore it is `unsafe`.", "tree": {"sha": "e3217c16859ffc699ada6744b758cb11c00da078", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3217c16859ffc699ada6744b758cb11c00da078"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0ca46e90d1304512decc1f9c3d50422e109080c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0ca46e90d1304512decc1f9c3d50422e109080c", "html_url": "https://github.com/rust-lang/rust/commit/b0ca46e90d1304512decc1f9c3d50422e109080c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0ca46e90d1304512decc1f9c3d50422e109080c/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a671fa1b15451fc386ed9077466047e19fb74078", "url": "https://api.github.com/repos/rust-lang/rust/commits/a671fa1b15451fc386ed9077466047e19fb74078", "html_url": "https://github.com/rust-lang/rust/commit/a671fa1b15451fc386ed9077466047e19fb74078"}], "stats": {"total": 56, "additions": 34, "deletions": 22}, "files": [{"sha": "56d6f11ac83ff08ea143437c8a3a09f0ba778d24", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b0ca46e90d1304512decc1f9c3d50422e109080c/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0ca46e90d1304512decc1f9c3d50422e109080c/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=b0ca46e90d1304512decc1f9c3d50422e109080c", "patch": "@@ -1366,6 +1366,22 @@ impl<T> *mut [T] {\n     ///\n     /// Panics if `mid > len`.\n     ///\n+    /// # Safety\n+    ///\n+    /// `mid` must be [in-bounds] of the underlying [allocated object].\n+    /// Which means `self` must be dereferenceable and span a single allocation\n+    /// that is at least `mid * size_of::<T>()` bytes long. Not upholding these\n+    /// requirements is *[undefined behavior]* even if the resulting pointers are not used.\n+    ///\n+    /// Since `len` being in-bounds it is not a safety invariant of `*mut [T]` the\n+    /// safety requirements of this method are the same as for [`split_at_mut_unchecked`].\n+    /// The explicit bounds check is only as useful as `len` is correct.\n+    ///\n+    /// [`split_at_mut_unchecked`]: #method.split_at_mut_unchecked\n+    /// [in-bounds]: #method.add\n+    /// [allocated object]: crate::ptr#allocated-object\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1374,19 +1390,19 @@ impl<T> *mut [T] {\n     ///\n     /// let mut v = [1, 0, 3, 0, 5, 6];\n     /// let ptr = &mut v as *mut [_];\n-    /// let (left, right) = ptr.split_at_mut(2);\n     /// unsafe {\n+    ///     let (left, right) = ptr.split_at_mut(2);\n     ///     assert_eq!(&*left, [1, 0]);\n     ///     assert_eq!(&*right, [3, 0, 5, 6]);\n     /// }\n     /// ```\n     #[inline(always)]\n     #[track_caller]\n     #[unstable(feature = \"raw_slice_split\", issue = \"95595\")]\n-    pub fn split_at_mut(self, mid: usize) -> (*mut [T], *mut [T]) {\n+    pub unsafe fn split_at_mut(self, mid: usize) -> (*mut [T], *mut [T]) {\n         assert!(mid <= self.len());\n-        // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n-        // fulfills the requirements of `from_raw_parts_mut`.\n+        // SAFETY: The assert above is only a safety-net as long as `self.len()` is correct\n+        // The actual safety requirements of this function are the same as for `split_at_mut_unchecked`\n         unsafe { self.split_at_mut_unchecked(mid) }\n     }\n \n@@ -1396,16 +1412,15 @@ impl<T> *mut [T] {\n     /// the index `mid` itself) and the second will contain all\n     /// indices from `[mid, len)` (excluding the index `len` itself).\n     ///\n-    /// For a safe alternative see [`split_at_mut`].\n-    ///\n-    /// [`split_at_mut`]: #method.split_at_mut\n-    ///\n     /// # Safety\n     ///\n-    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n-    /// even if the resulting reference is not used. The caller has to ensure that\n-    /// `0 <= mid <= self.len()`.\n+    /// `mid` must be [in-bounds] of the underlying [allocated object].\n+    /// Which means `self` must be dereferenceable and span a single allocation\n+    /// that is at least `mid * size_of::<T>()` bytes long. Not upholding these\n+    /// requirements is *[undefined behavior]* even if the resulting pointers are not used.\n     ///\n+    /// [in-bounds]: #method.add\n+    /// [out-of-bounds index]: #method.add\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples\n@@ -1431,16 +1446,12 @@ impl<T> *mut [T] {\n         let len = self.len();\n         let ptr = self.as_mut_ptr();\n \n-        // SAFETY: Caller has to check that `0 <= mid <= self.len()`.\n-        //\n-        // `[ptr; mid]` and `[mid; len]` are not overlapping, so returning a mutable reference\n-        // is fine.\n-        unsafe {\n-            (\n-                crate::ptr::slice_from_raw_parts_mut(ptr, mid),\n-                crate::ptr::slice_from_raw_parts_mut(ptr.add(mid), len - mid),\n-            )\n-        }\n+        // SAFETY: Caller must pass a valid pointer and an index that is in-bounds.\n+        let tail = unsafe { ptr.add(mid) };\n+        (\n+            crate::ptr::slice_from_raw_parts_mut(ptr, mid),\n+            crate::ptr::slice_from_raw_parts_mut(tail, len - mid),\n+        )\n     }\n \n     /// Returns a raw pointer to the slice's buffer.\n@@ -1466,9 +1477,10 @@ impl<T> *mut [T] {\n     /// Returns a raw pointer to an element or subslice, without doing bounds\n     /// checking.\n     ///\n-    /// Calling this method with an out-of-bounds index or when `self` is not dereferenceable\n+    /// Calling this method with an [out-of-bounds index] or when `self` is not dereferenceable\n     /// is *[undefined behavior]* even if the resulting pointer is not used.\n     ///\n+    /// [out-of-bounds index]: #method.add\n     /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n     ///\n     /// # Examples"}]}