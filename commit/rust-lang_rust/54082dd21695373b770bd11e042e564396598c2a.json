{"sha": "54082dd21695373b770bd11e042e564396598c2a", "node_id": "C_kwDOAAsO6NoAKDU0MDgyZGQyMTY5NTM3M2I3NzBiZDExZTA0MmU1NjQzOTY1OThjMmE", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-10-16T21:29:40Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-11-16T04:46:39Z"}, "message": "Merge basic blocks where possible when generating LLVM IR.\n\nIn `codegen_assert_terminator` we decide if a BB's successor is a\ncandidate for merging, which requires that it be the only successor, and\nthat it only have one predecessor. That result then gets passed down,\nand if it reaches `funclet_br` with the appropriate BB characteristics,\nthen no `br` instruction is issued, a `MergingSucc::True` result is\npassed back, and the merging proceeds in `codegen_block`.\n\nThe commit also adds `CachedLlbb`, a new type to help keep track of\neach BB that has been merged into its predecessor.", "tree": {"sha": "9570a6265d93a4b6d7b147600b9a8ecc8fa38073", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9570a6265d93a4b6d7b147600b9a8ecc8fa38073"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54082dd21695373b770bd11e042e564396598c2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54082dd21695373b770bd11e042e564396598c2a", "html_url": "https://github.com/rust-lang/rust/commit/54082dd21695373b770bd11e042e564396598c2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54082dd21695373b770bd11e042e564396598c2a/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68194aa8d5c513fad53147e46144684f14f99463", "url": "https://api.github.com/repos/rust-lang/rust/commits/68194aa8d5c513fad53147e46144684f14f99463", "html_url": "https://github.com/rust-lang/rust/commit/68194aa8d5c513fad53147e46144684f14f99463"}], "stats": {"total": 405, "additions": 261, "deletions": 144}, "files": [{"sha": "ade33b6c77728defec98a0e57bfc8d3e8b20c869", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/54082dd21695373b770bd11e042e564396598c2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54082dd21695373b770bd11e042e564396598c2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=54082dd21695373b770bd11e042e564396598c2a", "patch": "@@ -1,12 +1,13 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n-#![feature(box_patterns)]\n-#![feature(try_blocks)]\n-#![feature(once_cell)]\n #![feature(associated_type_bounds)]\n-#![feature(strict_provenance)]\n-#![feature(int_roundings)]\n+#![feature(box_patterns)]\n #![feature(if_let_guard)]\n+#![feature(int_roundings)]\n+#![feature(let_chains)]\n #![feature(never_type)]\n+#![feature(once_cell)]\n+#![feature(strict_provenance)]\n+#![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n "}, {"sha": "7822d924c01549c184cf83023b3893ce3d01c590", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 231, "deletions": 129, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/54082dd21695373b770bd11e042e564396598c2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54082dd21695373b770bd11e042e564396598c2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=54082dd21695373b770bd11e042e564396598c2a", "patch": "@@ -1,7 +1,7 @@\n use super::operand::OperandRef;\n use super::operand::OperandValue::{Immediate, Pair, Ref};\n use super::place::PlaceRef;\n-use super::{FunctionCx, LocalRef};\n+use super::{CachedLlbb, FunctionCx, LocalRef};\n \n use crate::base;\n use crate::common::{self, IntPredicate};\n@@ -25,6 +25,15 @@ use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode, Reg};\n use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n use rustc_target::spec::abi::Abi;\n \n+// Indicates if we are in the middle of merging a BB's successor into it. This\n+// can happen when BB jumps directly to its successor and the successor has no\n+// other predecessors.\n+#[derive(Debug, PartialEq)]\n+enum MergingSucc {\n+    False,\n+    True,\n+}\n+\n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n /// e.g., creating a basic block, calling a function, etc.\n struct TerminatorCodegenHelper<'tcx> {\n@@ -64,39 +73,18 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         }\n     }\n \n-    /// Get a basic block (creating it if necessary), possibly with a landing\n-    /// pad next to it.\n-    fn llbb_with_landing_pad<Bx: BuilderMethods<'a, 'tcx>>(\n-        &self,\n-        fx: &mut FunctionCx<'a, 'tcx, Bx>,\n-        target: mir::BasicBlock,\n-    ) -> (Bx::BasicBlock, bool) {\n-        let span = self.terminator.source_info.span;\n-        let lltarget = fx.llbb(target);\n-        let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n-        match (self.funclet_bb, target_funclet) {\n-            (None, None) => (lltarget, false),\n-            // jump *into* cleanup - need a landing pad if GNU, cleanup pad if MSVC\n-            (None, Some(_)) => (fx.landing_pad_for(target), false),\n-            (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n-            (Some(f), Some(t_f)) => {\n-                if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) {\n-                    (lltarget, false)\n-                } else {\n-                    (fx.landing_pad_for(target), true)\n-                }\n-            }\n-        }\n-    }\n-\n     /// Get a basic block (creating it if necessary), possibly with cleanup\n     /// stuff in it or next to it.\n     fn llbb_with_cleanup<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         target: mir::BasicBlock,\n     ) -> Bx::BasicBlock {\n-        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n+        let (needs_landing_pad, is_cleanupret) = self.llbb_characteristics(fx, target);\n+        let mut lltarget = fx.llbb(target);\n+        if needs_landing_pad {\n+            lltarget = fx.landing_pad_for(target);\n+        }\n         if is_cleanupret {\n             // MSVC cross-funclet jump - need a trampoline\n             debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n@@ -111,20 +99,54 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         }\n     }\n \n+    fn llbb_characteristics<Bx: BuilderMethods<'a, 'tcx>>(\n+        &self,\n+        fx: &mut FunctionCx<'a, 'tcx, Bx>,\n+        target: mir::BasicBlock,\n+    ) -> (bool, bool) {\n+        let target_funclet = fx.cleanup_kinds[target].funclet_bb(target);\n+        let (needs_landing_pad, is_cleanupret) = match (self.funclet_bb, target_funclet) {\n+            (None, None) => (false, false),\n+            (None, Some(_)) => (true, false),\n+            (Some(_), None) => {\n+                let span = self.terminator.source_info.span;\n+                span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator);\n+            }\n+            (Some(f), Some(t_f)) => {\n+                if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) {\n+                    (false, false)\n+                } else {\n+                    (true, true)\n+                }\n+            }\n+        };\n+        (needs_landing_pad, is_cleanupret)\n+    }\n+\n     fn funclet_br<Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n         fx: &mut FunctionCx<'a, 'tcx, Bx>,\n         bx: &mut Bx,\n         target: mir::BasicBlock,\n-    ) {\n-        let (lltarget, is_cleanupret) = self.llbb_with_landing_pad(fx, target);\n-        if is_cleanupret {\n-            // MSVC micro-optimization: generate a `ret` rather than a jump\n-            // to a trampoline.\n-            debug_assert!(base::wants_msvc_seh(fx.cx.tcx().sess));\n-            bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n+        let (needs_landing_pad, is_cleanupret) = self.llbb_characteristics(fx, target);\n+        if mergeable_succ && !needs_landing_pad && !is_cleanupret {\n+            // We can merge the successor into this bb, so no need for a `br`.\n+            MergingSucc::True\n         } else {\n-            bx.br(lltarget);\n+            let mut lltarget = fx.llbb(target);\n+            if needs_landing_pad {\n+                lltarget = fx.landing_pad_for(target);\n+            }\n+            if is_cleanupret {\n+                // micro-optimization: generate a `ret` rather than a jump\n+                // to a trampoline.\n+                bx.cleanup_ret(self.funclet(fx).unwrap(), Some(lltarget));\n+            } else {\n+                bx.br(lltarget);\n+            }\n+            MergingSucc::False\n         }\n     }\n \n@@ -140,7 +162,8 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         destination: Option<(ReturnDest<'tcx, Bx::Value>, mir::BasicBlock)>,\n         cleanup: Option<mir::BasicBlock>,\n         copied_constant_arguments: &[PlaceRef<'tcx, <Bx as BackendTypes>::Value>],\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         // If there is a cleanup block and the function we're calling can unwind, then\n         // do an invoke, otherwise do a call.\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n@@ -191,6 +214,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 }\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, invokeret);\n             }\n+            MergingSucc::False\n         } else {\n             let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &llargs, self.funclet(fx));\n             if fx.mir[self.bb].is_cleanup {\n@@ -206,9 +230,10 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                     bx.lifetime_end(tmp.llval, tmp.layout.size);\n                 }\n                 fx.store_return(bx, ret_dest, &fn_abi.ret, llret);\n-                self.funclet_br(fx, bx, target);\n+                self.funclet_br(fx, bx, target, mergeable_succ)\n             } else {\n                 bx.unreachable();\n+                MergingSucc::False\n             }\n         }\n     }\n@@ -225,7 +250,8 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         destination: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n         instance: Instance<'_>,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         if let Some(cleanup) = cleanup {\n             let ret_llbb = if let Some(target) = destination {\n                 fx.llbb(target)\n@@ -241,13 +267,15 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 instance,\n                 Some((ret_llbb, self.llbb_with_cleanup(fx, cleanup), self.funclet(fx))),\n             );\n+            MergingSucc::False\n         } else {\n             bx.codegen_inline_asm(template, &operands, options, line_spans, instance, None);\n \n             if let Some(target) = destination {\n-                self.funclet_br(fx, bx, target);\n+                self.funclet_br(fx, bx, target, mergeable_succ)\n             } else {\n                 bx.unreachable();\n+                MergingSucc::False\n             }\n         }\n     }\n@@ -413,15 +441,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         location: mir::Place<'tcx>,\n         target: mir::BasicBlock,\n         unwind: Option<mir::BasicBlock>,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         let ty = location.ty(self.mir, bx.tcx()).ty;\n         let ty = self.monomorphize(ty);\n         let drop_fn = Instance::resolve_drop_in_place(bx.tcx(), ty);\n \n         if let ty::InstanceDef::DropGlue(_, None) = drop_fn.def {\n             // we don't actually need to drop anything.\n-            helper.funclet_br(self, bx, target);\n-            return;\n+            return helper.funclet_br(self, bx, target, mergeable_succ);\n         }\n \n         let place = self.codegen_place(bx, location.as_ref());\n@@ -522,7 +550,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Some((ReturnDest::Nothing, target)),\n             unwind,\n             &[],\n-        );\n+            mergeable_succ,\n+        )\n     }\n \n     fn codegen_assert_terminator(\n@@ -535,7 +564,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         msg: &mir::AssertMessage<'tcx>,\n         target: mir::BasicBlock,\n         cleanup: Option<mir::BasicBlock>,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         let span = terminator.source_info.span;\n         let cond = self.codegen_operand(bx, cond).immediate();\n         let mut const_cond = bx.const_to_opt_u128(cond, false).map(|c| c == 1);\n@@ -555,8 +585,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Don't codegen the panic block if success if known.\n         if const_cond == Some(expected) {\n-            helper.funclet_br(self, bx, target);\n-            return;\n+            return helper.funclet_br(self, bx, target, mergeable_succ);\n         }\n \n         // Pass the condition through llvm.expect for branch hinting.\n@@ -598,7 +627,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let (fn_abi, llfn) = common::build_langcall(bx, Some(span), lang_item);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, bx, fn_abi, llfn, &args, None, cleanup, &[]);\n+        let merging_succ = helper.do_call(self, bx, fn_abi, llfn, &args, None, cleanup, &[], false);\n+        assert_eq!(merging_succ, MergingSucc::False);\n+        MergingSucc::False\n     }\n \n     fn codegen_abort_terminator(\n@@ -614,10 +645,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let (fn_abi, llfn) = common::build_langcall(bx, Some(span), LangItem::PanicNoUnwind);\n \n         // Codegen the actual panic invoke/call.\n-        helper.do_call(self, bx, fn_abi, llfn, &[], None, None, &[]);\n+        let merging_succ = helper.do_call(self, bx, fn_abi, llfn, &[], None, None, &[], false);\n+        assert_eq!(merging_succ, MergingSucc::False);\n     }\n \n-    /// Returns `true` if this is indeed a panic intrinsic and codegen is done.\n+    /// Returns `Some` if this is indeed a panic intrinsic and codegen is done.\n     fn codegen_panic_intrinsic(\n         &mut self,\n         helper: &TerminatorCodegenHelper<'tcx>,\n@@ -627,7 +659,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         source_info: mir::SourceInfo,\n         target: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n-    ) -> bool {\n+        mergeable_succ: bool,\n+    ) -> Option<MergingSucc> {\n         // Emit a panic or a no-op for `assert_*` intrinsics.\n         // These are intrinsics that compile to panics so that we can get a message\n         // which mentions the offending type, even from a const context.\n@@ -653,7 +686,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 ZeroValid => !bx.tcx().permits_zero_init(layout),\n                 UninitValid => !bx.tcx().permits_uninit_init(layout),\n             };\n-            if do_panic {\n+            Some(if do_panic {\n                 let msg_str = with_no_visible_paths!({\n                     with_no_trimmed_paths!({\n                         if layout.abi.is_uninhabited() {\n@@ -686,15 +719,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     target.as_ref().map(|bb| (ReturnDest::Nothing, *bb)),\n                     cleanup,\n                     &[],\n-                );\n+                    mergeable_succ,\n+                )\n             } else {\n                 // a NOP\n                 let target = target.unwrap();\n-                helper.funclet_br(self, bx, target)\n-            }\n-            true\n+                helper.funclet_br(self, bx, target, mergeable_succ)\n+            })\n         } else {\n-            false\n+            None\n         }\n     }\n \n@@ -709,7 +742,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         target: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n         fn_span: Span,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         let source_info = terminator.source_info;\n         let span = source_info.span;\n \n@@ -734,8 +768,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if let Some(ty::InstanceDef::DropGlue(_, None)) = def {\n             // Empty drop glue; a no-op.\n             let target = target.unwrap();\n-            helper.funclet_br(self, bx, target);\n-            return;\n+            return helper.funclet_br(self, bx, target, mergeable_succ);\n         }\n \n         // FIXME(eddyb) avoid computing this if possible, when `instance` is\n@@ -762,9 +795,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         if intrinsic == Some(sym::transmute) {\n-            if let Some(target) = target {\n+            return if let Some(target) = target {\n                 self.codegen_transmute(bx, &args[0], destination);\n-                helper.funclet_br(self, bx, target);\n+                helper.funclet_br(self, bx, target, mergeable_succ)\n             } else {\n                 // If we are trying to transmute to an uninhabited type,\n                 // it is likely there is no allotted destination. In fact,\n@@ -774,20 +807,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 // it must be unreachable.\n                 assert_eq!(fn_abi.ret.layout.abi, abi::Abi::Uninhabited);\n                 bx.unreachable();\n-            }\n-            return;\n+                MergingSucc::False\n+            };\n         }\n \n-        if self.codegen_panic_intrinsic(\n+        if let Some(merging_succ) = self.codegen_panic_intrinsic(\n             &helper,\n             bx,\n             intrinsic,\n             instance,\n             source_info,\n             target,\n             cleanup,\n+            mergeable_succ,\n         ) {\n-            return;\n+            return merging_succ;\n         }\n \n         // The arguments we'll be passing. Plus one to account for outptr, if used.\n@@ -803,17 +837,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         };\n \n         if intrinsic == Some(sym::caller_location) {\n-            if let Some(target) = target {\n+            return if let Some(target) = target {\n                 let location =\n                     self.get_caller_location(bx, mir::SourceInfo { span: fn_span, ..source_info });\n \n                 if let ReturnDest::IndirectOperand(tmp, _) = ret_dest {\n                     location.val.store(bx, tmp);\n                 }\n                 self.store_return(bx, ret_dest, &fn_abi.ret, location.immediate());\n-                helper.funclet_br(self, bx, target);\n-            }\n-            return;\n+                helper.funclet_br(self, bx, target, mergeable_succ)\n+            } else {\n+                MergingSucc::False\n+            };\n         }\n \n         match intrinsic {\n@@ -874,13 +909,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     self.store_return(bx, ret_dest, &fn_abi.ret, dst.llval);\n                 }\n \n-                if let Some(target) = target {\n-                    helper.funclet_br(self, bx, target);\n+                return if let Some(target) = target {\n+                    helper.funclet_br(self, bx, target, mergeable_succ)\n                 } else {\n                     bx.unreachable();\n-                }\n-\n-                return;\n+                    MergingSucc::False\n+                };\n             }\n         }\n \n@@ -1041,7 +1075,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             bx.cond_br(cond, bb_pass, bb_fail);\n \n             bx.switch_to_block(bb_pass);\n-            helper.do_call(\n+            let merging_succ = helper.do_call(\n                 self,\n                 bx,\n                 fn_abi,\n@@ -1050,13 +1084,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 target.as_ref().map(|&target| (ret_dest, target)),\n                 cleanup,\n                 &copied_constant_arguments,\n+                false,\n             );\n+            assert_eq!(merging_succ, MergingSucc::False);\n \n             bx.switch_to_block(bb_fail);\n             bx.abort();\n             bx.unreachable();\n \n-            return;\n+            return MergingSucc::False;\n         }\n \n         helper.do_call(\n@@ -1068,7 +1104,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             target.as_ref().map(|&target| (ret_dest, target)),\n             cleanup,\n             &copied_constant_arguments,\n-        );\n+            mergeable_succ,\n+        )\n     }\n \n     fn codegen_asm_terminator(\n@@ -1083,7 +1120,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         destination: Option<mir::BasicBlock>,\n         cleanup: Option<mir::BasicBlock>,\n         instance: Instance<'_>,\n-    ) {\n+        mergeable_succ: bool,\n+    ) -> MergingSucc {\n         let span = terminator.source_info.span;\n \n         let operands: Vec<_> = operands\n@@ -1146,71 +1184,128 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             destination,\n             cleanup,\n             instance,\n-        );\n+            mergeable_succ,\n+        )\n     }\n }\n \n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n-    pub fn codegen_block(&mut self, bb: mir::BasicBlock) {\n-        let llbb = self.llbb(bb);\n+    pub fn codegen_block(&mut self, mut bb: mir::BasicBlock) {\n+        let llbb = match self.try_llbb(bb) {\n+            Some(llbb) => llbb,\n+            None => return,\n+        };\n         let bx = &mut Bx::build(self.cx, llbb);\n         let mir = self.mir;\n-        let data = &mir[bb];\n \n-        debug!(\"codegen_block({:?}={:?})\", bb, data);\n+        // MIR basic blocks stop at any function call. This may not be the case\n+        // for the backend's basic blocks, in which case we might be able to\n+        // combine multiple MIR basic blocks into a single backend basic block.\n+        loop {\n+            let data = &mir[bb];\n \n-        for statement in &data.statements {\n-            self.codegen_statement(bx, statement);\n-        }\n+            debug!(\"codegen_block({:?}={:?})\", bb, data);\n+\n+            for statement in &data.statements {\n+                self.codegen_statement(bx, statement);\n+            }\n \n-        self.codegen_terminator(bx, bb, data.terminator());\n+            let merging_succ = self.codegen_terminator(bx, bb, data.terminator());\n+            if let MergingSucc::False = merging_succ {\n+                break;\n+            }\n+\n+            // We are merging the successor into the produced backend basic\n+            // block. Record that the successor should be skipped when it is\n+            // reached.\n+            //\n+            // Note: we must not have already generated code for the successor.\n+            // This is implicitly ensured by the reverse postorder traversal,\n+            // and the assertion explicitly guarantees that.\n+            let mut successors = data.terminator().successors();\n+            let succ = successors.next().unwrap();\n+            assert!(matches!(self.cached_llbbs[succ], CachedLlbb::None));\n+            self.cached_llbbs[succ] = CachedLlbb::Skip;\n+            bb = succ;\n+        }\n     }\n \n     fn codegen_terminator(\n         &mut self,\n         bx: &mut Bx,\n         bb: mir::BasicBlock,\n         terminator: &'tcx mir::Terminator<'tcx>,\n-    ) {\n+    ) -> MergingSucc {\n         debug!(\"codegen_terminator: {:?}\", terminator);\n \n         // Create the cleanup bundle, if needed.\n         let funclet_bb = self.cleanup_kinds[bb].funclet_bb(bb);\n         let helper = TerminatorCodegenHelper { bb, terminator, funclet_bb };\n \n+        let mergeable_succ = || {\n+            // Note: any call to `switch_to_block` will invalidate a `true` value\n+            // of `mergeable_succ`.\n+            let mut successors = terminator.successors();\n+            if let Some(succ) = successors.next()\n+                && successors.next().is_none()\n+                && let &[succ_pred] = self.mir.basic_blocks.predecessors()[succ].as_slice()\n+            {\n+                // bb has a single successor, and bb is its only predecessor. This\n+                // makes it a candidate for merging.\n+                assert_eq!(succ_pred, bb);\n+                true\n+            } else {\n+                false\n+            }\n+        };\n+\n         self.set_debug_loc(bx, terminator.source_info);\n         match terminator.kind {\n-            mir::TerminatorKind::Resume => self.codegen_resume_terminator(helper, bx),\n+            mir::TerminatorKind::Resume => {\n+                self.codegen_resume_terminator(helper, bx);\n+                MergingSucc::False\n+            }\n \n             mir::TerminatorKind::Abort => {\n                 self.codegen_abort_terminator(helper, bx, terminator);\n+                MergingSucc::False\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                helper.funclet_br(self, bx, target);\n+                helper.funclet_br(self, bx, target, mergeable_succ())\n             }\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref targets } => {\n                 self.codegen_switchint_terminator(helper, bx, discr, switch_ty, targets);\n+                MergingSucc::False\n             }\n \n             mir::TerminatorKind::Return => {\n                 self.codegen_return_terminator(bx);\n+                MergingSucc::False\n             }\n \n             mir::TerminatorKind::Unreachable => {\n                 bx.unreachable();\n+                MergingSucc::False\n             }\n \n             mir::TerminatorKind::Drop { place, target, unwind } => {\n-                self.codegen_drop_terminator(helper, bx, place, target, unwind);\n+                self.codegen_drop_terminator(helper, bx, place, target, unwind, mergeable_succ())\n             }\n \n-            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                self.codegen_assert_terminator(\n-                    helper, bx, terminator, cond, expected, msg, target, cleanup,\n-                );\n-            }\n+            mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => self\n+                .codegen_assert_terminator(\n+                    helper,\n+                    bx,\n+                    terminator,\n+                    cond,\n+                    expected,\n+                    msg,\n+                    target,\n+                    cleanup,\n+                    mergeable_succ(),\n+                ),\n \n             mir::TerminatorKind::DropAndReplace { .. } => {\n                 bug!(\"undesugared DropAndReplace in codegen: {:?}\", terminator);\n@@ -1224,19 +1319,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 cleanup,\n                 from_hir_call: _,\n                 fn_span,\n-            } => {\n-                self.codegen_call_terminator(\n-                    helper,\n-                    bx,\n-                    terminator,\n-                    func,\n-                    args,\n-                    destination,\n-                    target,\n-                    cleanup,\n-                    fn_span,\n-                );\n-            }\n+            } => self.codegen_call_terminator(\n+                helper,\n+                bx,\n+                terminator,\n+                func,\n+                args,\n+                destination,\n+                target,\n+                cleanup,\n+                fn_span,\n+                mergeable_succ(),\n+            ),\n             mir::TerminatorKind::GeneratorDrop | mir::TerminatorKind::Yield { .. } => {\n                 bug!(\"generator ops in codegen\")\n             }\n@@ -1251,20 +1345,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 line_spans,\n                 destination,\n                 cleanup,\n-            } => {\n-                self.codegen_asm_terminator(\n-                    helper,\n-                    bx,\n-                    terminator,\n-                    template,\n-                    operands,\n-                    options,\n-                    line_spans,\n-                    destination,\n-                    cleanup,\n-                    self.instance,\n-                );\n-            }\n+            } => self.codegen_asm_terminator(\n+                helper,\n+                bx,\n+                terminator,\n+                template,\n+                operands,\n+                options,\n+                line_spans,\n+                destination,\n+                cleanup,\n+                self.instance,\n+                mergeable_succ(),\n+            ),\n         }\n     }\n \n@@ -1582,12 +1675,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     // FIXME(eddyb) rename `llbb` and other `ll`-prefixed things to use a\n     // more backend-agnostic prefix such as `cg` (i.e. this would be `cgbb`).\n     pub fn llbb(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n-        self.cached_llbbs[bb].unwrap_or_else(|| {\n-            // FIXME(eddyb) only name the block if `fewer_names` is `false`.\n-            let llbb = Bx::append_block(self.cx, self.llfn, &format!(\"{:?}\", bb));\n-            self.cached_llbbs[bb] = Some(llbb);\n-            llbb\n-        })\n+        self.try_llbb(bb).unwrap()\n+    }\n+\n+    /// Like `llbb`, but may fail if the basic block should be skipped.\n+    pub fn try_llbb(&mut self, bb: mir::BasicBlock) -> Option<Bx::BasicBlock> {\n+        match self.cached_llbbs[bb] {\n+            CachedLlbb::None => {\n+                // FIXME(eddyb) only name the block if `fewer_names` is `false`.\n+                let llbb = Bx::append_block(self.cx, self.llfn, &format!(\"{:?}\", bb));\n+                self.cached_llbbs[bb] = CachedLlbb::Some(llbb);\n+                Some(llbb)\n+            }\n+            CachedLlbb::Some(llbb) => Some(llbb),\n+            CachedLlbb::Skip => None,\n+        }\n     }\n \n     fn make_return_dest("}, {"sha": "4bd985884f0ceccc796d2a1c8c580f9e8230c76f", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/54082dd21695373b770bd11e042e564396598c2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54082dd21695373b770bd11e042e564396598c2a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=54082dd21695373b770bd11e042e564396598c2a", "patch": "@@ -16,6 +16,18 @@ use rustc_middle::mir::traversal;\n \n use self::operand::{OperandRef, OperandValue};\n \n+// Used for tracking the state of generated basic blocks.\n+enum CachedLlbb<T> {\n+    /// Nothing created yet.\n+    None,\n+\n+    /// Has been created.\n+    Some(T),\n+\n+    /// Nothing created yet, and nothing should be.\n+    Skip,\n+}\n+\n /// Master context for codegenning from MIR.\n pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     instance: Instance<'tcx>,\n@@ -43,7 +55,7 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// as-needed (e.g. RPO reaching it or another block branching to it).\n     // FIXME(eddyb) rename `llbbs` and other `ll`-prefixed things to use a\n     // more backend-agnostic prefix such as `cg` (i.e. this would be `cgbbs`).\n-    cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n+    cached_llbbs: IndexVec<mir::BasicBlock, CachedLlbb<Bx::BasicBlock>>,\n \n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n@@ -155,11 +167,13 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n-    let cached_llbbs: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>> = mir\n-        .basic_blocks\n-        .indices()\n-        .map(|bb| if bb == mir::START_BLOCK { Some(start_llbb) } else { None })\n-        .collect();\n+    let cached_llbbs: IndexVec<mir::BasicBlock, CachedLlbb<Bx::BasicBlock>> =\n+        mir.basic_blocks\n+            .indices()\n+            .map(|bb| {\n+                if bb == mir::START_BLOCK { CachedLlbb::Some(start_llbb) } else { CachedLlbb::None }\n+            })\n+            .collect();\n \n     let mut fx = FunctionCx {\n         instance,"}, {"sha": "8fee459bd7ac778113bdc5b523ccfa2c36cc9767", "filename": "src/test/debuginfo/lexical-scope-in-if-let.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/54082dd21695373b770bd11e042e564396598c2a/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54082dd21695373b770bd11e042e564396598c2a/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-in-if-let.rs?ref=54082dd21695373b770bd11e042e564396598c2a", "patch": "@@ -58,19 +58,19 @@\n \n // cdb-command: g\n // cdb-command: dv\n-// cdb-check:[...]y = true\n-// cdb-check:[...]b = 0n456\n // cdb-check:[...]a = 0n123\n // cdb-check:[...]x = 0n42\n+// cdb-check:[...]b = 0n456\n+// cdb-check:[...]y = true\n \n // cdb-command: g\n // cdb-command: dv\n // cdb-check:[...]z = 0n10\n // cdb-check:[...]c = 0n789\n-// cdb-check:[...]y = true\n-// cdb-check:[...]b = 0n456\n // cdb-check:[...]a = 0n123\n // cdb-check:[...]x = 0n42\n+// cdb-check:[...]b = 0n456\n+// cdb-check:[...]y = true\n \n fn main() {\n     let a = id(123);"}]}