{"sha": "57b722688d03fc8115987375eee1d076cc89bc68", "node_id": "C_kwDOAAsO6NoAKDU3YjcyMjY4OGQwM2ZjODExNTk4NzM3NWVlZTFkMDc2Y2M4OWJjNjg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-07T18:33:26Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-07T18:33:26Z"}, "message": "Properly print generator interior type sizes", "tree": {"sha": "d387f2451a3a066a1ea2c5a19a4aaaef86c39691", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d387f2451a3a066a1ea2c5a19a4aaaef86c39691"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57b722688d03fc8115987375eee1d076cc89bc68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57b722688d03fc8115987375eee1d076cc89bc68", "html_url": "https://github.com/rust-lang/rust/commit/57b722688d03fc8115987375eee1d076cc89bc68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57b722688d03fc8115987375eee1d076cc89bc68/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc", "html_url": "https://github.com/rust-lang/rust/commit/b0dcadfc45bb04be3ba56d8bd62f1331a98949dc"}], "stats": {"total": 319, "additions": 219, "deletions": 100}, "files": [{"sha": "1085bce44758fe7235929e8c7ca2b703f23cbae3", "filename": "compiler/rustc_session/src/code_stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57b722688d03fc8115987375eee1d076cc89bc68/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57b722688d03fc8115987375eee1d076cc89bc68/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs?ref=57b722688d03fc8115987375eee1d076cc89bc68", "patch": "@@ -19,7 +19,7 @@ pub enum SizeKind {\n     Min,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FieldInfo {\n     pub name: Symbol,\n     pub offset: u64,\n@@ -114,8 +114,8 @@ impl CodeStats {\n             let mut max_variant_size = discr_size;\n \n             let struct_like = match kind {\n-                DataTypeKind::Struct | DataTypeKind::Closure | DataTypeKind::Generator => true,\n-                DataTypeKind::Enum | DataTypeKind::Union => false,\n+                DataTypeKind::Struct | DataTypeKind::Closure => true,\n+                DataTypeKind::Enum | DataTypeKind::Union | DataTypeKind::Generator => false,\n             };\n             for (i, variant_info) in variants.into_iter().enumerate() {\n                 let VariantInfo { ref name, kind: _, align: _, size, ref fields } = *variant_info;"}, {"sha": "8bbbf26f47069a7d8a27f731f1054dfe4857110b", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 188, "deletions": 86, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/57b722688d03fc8115987375eee1d076cc89bc68/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57b722688d03fc8115987375eee1d076cc89bc68/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=57b722688d03fc8115987375eee1d076cc89bc68", "patch": "@@ -814,10 +814,196 @@ fn record_layout_for_printing_outlined<'tcx>(\n         );\n     };\n \n-    let adt_def = match *layout.ty.kind() {\n+    match *layout.ty.kind() {\n         ty::Adt(ref adt_def, _) => {\n             debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n-            adt_def\n+            let adt_kind = adt_def.adt_kind();\n+            let adt_packed = adt_def.repr().pack.is_some();\n+\n+            let build_variant_info =\n+                |n: Option<Symbol>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n+                    let mut min_size = Size::ZERO;\n+                    let field_info: Vec<_> = flds\n+                        .iter()\n+                        .enumerate()\n+                        .map(|(i, &name)| {\n+                            let field_layout = layout.field(cx, i);\n+                            let offset = layout.fields.offset(i);\n+                            min_size = min_size.max(offset + field_layout.size);\n+                            FieldInfo {\n+                                name,\n+                                offset: offset.bytes(),\n+                                size: field_layout.size.bytes(),\n+                                align: field_layout.align.abi.bytes(),\n+                            }\n+                        })\n+                        .collect();\n+\n+                    VariantInfo {\n+                        name: n,\n+                        kind: if layout.is_unsized() { SizeKind::Min } else { SizeKind::Exact },\n+                        align: layout.align.abi.bytes(),\n+                        size: if min_size.bytes() == 0 {\n+                            layout.size.bytes()\n+                        } else {\n+                            min_size.bytes()\n+                        },\n+                        fields: field_info,\n+                    }\n+                };\n+\n+            match layout.variants {\n+                Variants::Single { index } => {\n+                    if !adt_def.variants().is_empty() && layout.fields != FieldsShape::Primitive {\n+                        debug!(\n+                            \"print-type-size `{:#?}` variant {}\",\n+                            layout,\n+                            adt_def.variant(index).name\n+                        );\n+                        let variant_def = &adt_def.variant(index);\n+                        let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n+                        record(\n+                            adt_kind.into(),\n+                            adt_packed,\n+                            None,\n+                            vec![build_variant_info(Some(variant_def.name), &fields, layout)],\n+                        );\n+                    } else {\n+                        // (This case arises for *empty* enums; so give it\n+                        // zero variants.)\n+                        record(adt_kind.into(), adt_packed, None, vec![]);\n+                    }\n+                }\n+\n+                Variants::Multiple { tag, ref tag_encoding, .. } => {\n+                    debug!(\n+                        \"print-type-size `{:#?}` adt general variants def {}\",\n+                        layout.ty,\n+                        adt_def.variants().len()\n+                    );\n+                    let variant_infos: Vec<_> = adt_def\n+                        .variants()\n+                        .iter_enumerated()\n+                        .map(|(i, variant_def)| {\n+                            let fields: Vec<_> =\n+                                variant_def.fields.iter().map(|f| f.name).collect();\n+                            build_variant_info(\n+                                Some(variant_def.name),\n+                                &fields,\n+                                layout.for_variant(cx, i),\n+                            )\n+                        })\n+                        .collect();\n+                    record(\n+                        adt_kind.into(),\n+                        adt_packed,\n+                        match tag_encoding {\n+                            TagEncoding::Direct => Some(tag.size(cx)),\n+                            _ => None,\n+                        },\n+                        variant_infos,\n+                    );\n+                }\n+            }\n+        }\n+\n+        ty::Generator(def_id, substs, _) => {\n+            debug!(\"print-type-size t: `{:?}` record generator\", layout.ty);\n+            // Generators always have a begin/poisoned/end state with additional suspend points\n+            match layout.variants {\n+                Variants::Multiple { tag, ref tag_encoding, .. } => {\n+                    let (generator, state_specific_names) =\n+                        cx.tcx.generator_layout_and_saved_local_names(def_id);\n+                    let upvar_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n+\n+                    let mut upvars_size = Size::ZERO;\n+                    let upvar_fields: Vec<_> = substs\n+                        .as_generator()\n+                        .upvar_tys()\n+                        .zip(upvar_names)\n+                        .enumerate()\n+                        .map(|(field_idx, (_, name))| {\n+                            let field_layout = layout.field(cx, field_idx);\n+                            let offset = layout.fields.offset(field_idx);\n+                            upvars_size = upvars_size.max(offset + field_layout.size);\n+                            FieldInfo {\n+                                name: Symbol::intern(&name),\n+                                offset: offset.bytes(),\n+                                size: field_layout.size.bytes(),\n+                                align: field_layout.align.abi.bytes(),\n+                            }\n+                        })\n+                        .collect();\n+\n+                    let variant_infos: Vec<_> = generator\n+                        .variant_fields\n+                        .iter_enumerated()\n+                        .map(|(variant_idx, variant_def)| {\n+                            let variant_layout = layout.for_variant(cx, variant_idx);\n+                            let mut variant_size = Size::ZERO;\n+                            let fields = variant_def\n+                                .iter()\n+                                .enumerate()\n+                                .map(|(field_idx, local)| {\n+                                    let field_layout = variant_layout.field(cx, field_idx);\n+                                    let offset = variant_layout.fields.offset(field_idx);\n+                                    // The struct is as large as the last field's end\n+                                    variant_size = variant_size.max(offset + field_layout.size);\n+                                    FieldInfo {\n+                                        name: state_specific_names\n+                                            .get(*local)\n+                                            .copied()\n+                                            .flatten()\n+                                            .unwrap_or(Symbol::intern(&format!(\n+                                                \".generator_field{}\",\n+                                                local.as_usize()\n+                                            ))),\n+                                        offset: offset.bytes(),\n+                                        size: field_layout.size.bytes(),\n+                                        align: field_layout.align.abi.bytes(),\n+                                    }\n+                                })\n+                                .chain(upvar_fields.iter().copied())\n+                                .collect();\n+\n+                            // If the variant has no state-specific fields, then it's the size of the upvars.\n+                            if variant_size == Size::ZERO {\n+                                variant_size = upvars_size;\n+                            }\n+                            // We need to add the discriminant size back into min_size, since it is subtracted\n+                            // later during printing.\n+                            variant_size += match tag_encoding {\n+                                TagEncoding::Direct => tag.size(cx),\n+                                _ => Size::ZERO,\n+                            };\n+\n+                            VariantInfo {\n+                                name: Some(Symbol::intern(&ty::GeneratorSubsts::variant_name(\n+                                    variant_idx,\n+                                ))),\n+                                kind: SizeKind::Exact,\n+                                size: variant_size.bytes(),\n+                                align: variant_layout.align.abi.bytes(),\n+                                fields,\n+                            }\n+                        })\n+                        .collect();\n+                    record(\n+                        DataTypeKind::Generator,\n+                        false,\n+                        match tag_encoding {\n+                            TagEncoding::Direct => Some(tag.size(cx)),\n+                            _ => None,\n+                        },\n+                        variant_infos,\n+                    );\n+                }\n+                _ => {\n+                    // This should never happen, but I would rather not panic.\n+                    record(DataTypeKind::Generator, false, None, vec![]);\n+                    return;\n+                }\n+            }\n         }\n \n         ty::Closure(..) => {\n@@ -826,93 +1012,9 @@ fn record_layout_for_printing_outlined<'tcx>(\n             return;\n         }\n \n-        ty::Generator(..) => {\n-            debug!(\"print-type-size t: `{:?}` record generator\", layout.ty);\n-            record(DataTypeKind::Generator, false, None, vec![]);\n-            return;\n-        }\n-\n         _ => {\n             debug!(\"print-type-size t: `{:?}` skip non-nominal\", layout.ty);\n             return;\n         }\n     };\n-\n-    let adt_kind = adt_def.adt_kind();\n-    let adt_packed = adt_def.repr().pack.is_some();\n-\n-    let build_variant_info = |n: Option<Symbol>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n-        let mut min_size = Size::ZERO;\n-        let field_info: Vec<_> = flds\n-            .iter()\n-            .enumerate()\n-            .map(|(i, &name)| {\n-                let field_layout = layout.field(cx, i);\n-                let offset = layout.fields.offset(i);\n-                let field_end = offset + field_layout.size;\n-                if min_size < field_end {\n-                    min_size = field_end;\n-                }\n-                FieldInfo {\n-                    name,\n-                    offset: offset.bytes(),\n-                    size: field_layout.size.bytes(),\n-                    align: field_layout.align.abi.bytes(),\n-                }\n-            })\n-            .collect();\n-\n-        VariantInfo {\n-            name: n,\n-            kind: if layout.is_unsized() { SizeKind::Min } else { SizeKind::Exact },\n-            align: layout.align.abi.bytes(),\n-            size: if min_size.bytes() == 0 { layout.size.bytes() } else { min_size.bytes() },\n-            fields: field_info,\n-        }\n-    };\n-\n-    match layout.variants {\n-        Variants::Single { index } => {\n-            if !adt_def.variants().is_empty() && layout.fields != FieldsShape::Primitive {\n-                debug!(\"print-type-size `{:#?}` variant {}\", layout, adt_def.variant(index).name);\n-                let variant_def = &adt_def.variant(index);\n-                let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n-                record(\n-                    adt_kind.into(),\n-                    adt_packed,\n-                    None,\n-                    vec![build_variant_info(Some(variant_def.name), &fields, layout)],\n-                );\n-            } else {\n-                // (This case arises for *empty* enums; so give it\n-                // zero variants.)\n-                record(adt_kind.into(), adt_packed, None, vec![]);\n-            }\n-        }\n-\n-        Variants::Multiple { tag, ref tag_encoding, .. } => {\n-            debug!(\n-                \"print-type-size `{:#?}` adt general variants def {}\",\n-                layout.ty,\n-                adt_def.variants().len()\n-            );\n-            let variant_infos: Vec<_> = adt_def\n-                .variants()\n-                .iter_enumerated()\n-                .map(|(i, variant_def)| {\n-                    let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n-                    build_variant_info(Some(variant_def.name), &fields, layout.for_variant(cx, i))\n-                })\n-                .collect();\n-            record(\n-                adt_kind.into(),\n-                adt_packed,\n-                match tag_encoding {\n-                    TagEncoding::Direct => Some(tag.size(cx)),\n-                    _ => None,\n-                },\n-                variant_infos,\n-            );\n-        }\n-    }\n }"}, {"sha": "94ad09ef296d3b15b713c3e5dc68adf8596671eb", "filename": "src/test/ui/print_type_sizes/async.stdout", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/57b722688d03fc8115987375eee1d076cc89bc68/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/57b722688d03fc8115987375eee1d076cc89bc68/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fasync.stdout?ref=57b722688d03fc8115987375eee1d076cc89bc68", "patch": "@@ -1,20 +1,29 @@\n-print-type-size type: `[static generator@$DIR/async.rs:10:32: 13:2]`: 16386 bytes, alignment: 1 bytes\n-print-type-size     end padding: 16386 bytes\n-print-type-size type: `std::future::from_generator::GenFuture<[static generator@$DIR/async.rs:10:32: 13:2]>`: 16386 bytes, alignment: 1 bytes\n-print-type-size     field `.0`: 16386 bytes\n+print-type-size type: `[async fn body@$DIR/async.rs:10:32: 13:2]`: 16386 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Suspend0`: 16385 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size         field `.arg`: 8192 bytes\n+print-type-size         field `.__awaitee`: 1 bytes\n+print-type-size     variant `Unresumed`: 8192 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Returned`: 8192 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Panicked`: 8192 bytes\n+print-type-size         field `.arg`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n print-type-size type: `std::mem::ManuallyDrop<[u8; 8192]>`: 8192 bytes, alignment: 1 bytes\n print-type-size     field `.value`: 8192 bytes\n print-type-size type: `std::mem::MaybeUninit<[u8; 8192]>`: 8192 bytes, alignment: 1 bytes\n print-type-size     variant `MaybeUninit`: 8192 bytes\n print-type-size         field `.uninit`: 0 bytes\n print-type-size         field `.value`: 8192 bytes\n-print-type-size type: `[static generator@$DIR/async.rs:8:17: 8:19]`: 1 bytes, alignment: 1 bytes\n-print-type-size     end padding: 1 bytes\n-print-type-size type: `std::future::from_generator::GenFuture<[static generator@$DIR/async.rs:8:17: 8:19]>`: 1 bytes, alignment: 1 bytes\n-print-type-size     field `.0`: 1 bytes\n-print-type-size type: `std::mem::ManuallyDrop<std::future::from_generator::GenFuture<[static generator@$DIR/async.rs:8:17: 8:19]>>`: 1 bytes, alignment: 1 bytes\n+print-type-size type: `[async fn body@$DIR/async.rs:8:17: 8:19]`: 1 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 0 bytes\n+print-type-size     variant `Returned`: 0 bytes\n+print-type-size     variant `Panicked`: 0 bytes\n+print-type-size type: `std::mem::ManuallyDrop<[async fn body@$DIR/async.rs:8:17: 8:19]>`: 1 bytes, alignment: 1 bytes\n print-type-size     field `.value`: 1 bytes\n-print-type-size type: `std::mem::MaybeUninit<std::future::from_generator::GenFuture<[static generator@$DIR/async.rs:8:17: 8:19]>>`: 1 bytes, alignment: 1 bytes\n+print-type-size type: `std::mem::MaybeUninit<[async fn body@$DIR/async.rs:8:17: 8:19]>`: 1 bytes, alignment: 1 bytes\n print-type-size     variant `MaybeUninit`: 1 bytes\n print-type-size         field `.uninit`: 0 bytes\n print-type-size         field `.value`: 1 bytes"}, {"sha": "28d4a6e6cff40de7cfa64a1c4cca2655ef26d27d", "filename": "src/test/ui/print_type_sizes/generator.stdout", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57b722688d03fc8115987375eee1d076cc89bc68/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/57b722688d03fc8115987375eee1d076cc89bc68/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerator.stdout?ref=57b722688d03fc8115987375eee1d076cc89bc68", "patch": "@@ -1,2 +1,10 @@\n print-type-size type: `[generator@$DIR/generator.rs:10:5: 10:14]`: 8193 bytes, alignment: 1 bytes\n-print-type-size     end padding: 8193 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Unresumed`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Returned`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Panicked`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes\n+print-type-size     variant `Suspend0`: 8192 bytes\n+print-type-size         field `.array`: 8192 bytes, offset: 0 bytes, alignment: 1 bytes"}]}