{"sha": "86f16b90cd694cd706469bb42737e63b1d9c1fdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZjE2YjkwY2Q2OTRjZDcwNjQ2OWJiNDI3MzdlNjNiMWQ5YzFmZGM=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-30T12:46:17Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-06-30T16:36:12Z"}, "message": "Support type parameters in resources\n\nSome rather dodgy code was added to trans in the process. I'd love to\ndiscuss it with someone who knows more about types during translation.", "tree": {"sha": "f81e107848cf5b8ba5488c6f4fbba20e38e0788e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f81e107848cf5b8ba5488c6f4fbba20e38e0788e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86f16b90cd694cd706469bb42737e63b1d9c1fdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86f16b90cd694cd706469bb42737e63b1d9c1fdc", "html_url": "https://github.com/rust-lang/rust/commit/86f16b90cd694cd706469bb42737e63b1d9c1fdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86f16b90cd694cd706469bb42737e63b1d9c1fdc/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31ec26d46afe543508b4a11d33309afefa85b29a", "url": "https://api.github.com/repos/rust-lang/rust/commits/31ec26d46afe543508b4a11d33309afefa85b29a", "html_url": "https://github.com/rust-lang/rust/commit/31ec26d46afe543508b4a11d33309afefa85b29a"}], "stats": {"total": 230, "additions": 164, "deletions": 66}, "files": [{"sha": "b671b2485c00c850e3de8f54eed1928b284e9cad", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=86f16b90cd694cd706469bb42737e63b1d9c1fdc", "patch": "@@ -1570,6 +1570,13 @@ fn type_to_str_inner(type_names names,\n     }\n }\n \n+fn fn_ty_param_tys(TypeRef fn_ty) -> vec[TypeRef] {\n+    auto args = vec::init_elt(0 as TypeRef, llvm::LLVMCountParamTypes(fn_ty));\n+    llvm::LLVMGetParamTypes(fn_ty, vec::buf(args));\n+    ret args;\n+}\n+\n+\n /* Memory-managed interface to target data. */\n \n obj target_data_dtor(TargetDataRef TD) {"}, {"sha": "353eb0928c6aa0e30802279f629c5df9c45ed918", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=86f16b90cd694cd706469bb42737e63b1d9c1fdc", "patch": "@@ -257,9 +257,13 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n             ret ty::mk_obj(st.tcx, methods);\n         }\n         case ('r') {\n+            assert (next(st) as char == '[');\n             auto def = parse_def(st, sd);\n             auto inner = parse_ty(st, sd);\n-            ret ty::mk_res(st.tcx, def, inner);\n+            let vec[ty::t] params = [];\n+            while (peek(st) as char != ']') { params += [parse_ty(st, sd)]; }\n+            st.pos = st.pos + 1u;\n+            ret ty::mk_res(st.tcx, def, inner, params);\n         }\n         case ('X') { ret ty::mk_var(st.tcx, parse_int(st)); }\n         case ('E') { ret ty::mk_native(st.tcx); }"}, {"sha": "51cd5fcc89a64dd240ce76bbbb505e0c59aa04f7", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=86f16b90cd694cd706469bb42737e63b1d9c1fdc", "patch": "@@ -172,11 +172,13 @@ fn enc_sty(&io::writer w, &@ctxt cx, &ty::sty st) {\n             }\n             w.write_char(']');\n         }\n-        case (ty::ty_res(?def, ?ty)) {\n-            w.write_char('r');\n+        case (ty::ty_res(?def, ?ty, ?tps)) {\n+            w.write_str(\"r[\");\n             w.write_str(cx.ds(def));\n             w.write_char('|');\n             enc_ty(w, cx, ty);\n+            for (ty::t t in tps) { enc_ty(w, cx, t); }\n+            w.write_char(']');\n         }\n         case (ty::ty_var(?id)) {\n             w.write_char('X');"}, {"sha": "b7f58dc4103d3a77f32aef78ce58a1ffc5e7b09c", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=86f16b90cd694cd706469bb42737e63b1d9c1fdc", "patch": "@@ -556,7 +556,7 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n                                               kind=unbox,\n                                               outer_t=base_t));\n                         }\n-                        case (ty::ty_res(_, ?inner)) {\n+                        case (ty::ty_res(_, ?inner, _)) {\n                             vec::push(ds, rec(mut=false,\n                                               kind=unbox,\n                                               outer_t=base_t));"}, {"sha": "c14938a5b6190aa14f8b9d18ac904e40bcd409ea", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 50, "deletions": 26, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=86f16b90cd694cd706469bb42737e63b1d9c1fdc", "patch": "@@ -876,8 +876,9 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             abs_pair = llvm::LLVMResolveTypeHandle(th.llth);\n             llty = abs_pair;\n         }\n-        case (ty::ty_res(_, ?sub)) {\n-            ret T_struct([T_i32(), type_of_inner(cx, sp, sub)]);\n+        case (ty::ty_res(_, ?sub, ?tps)) {\n+            auto sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n+            ret T_struct([T_i32(), type_of_inner(cx, sp, sub1)]);\n         }\n         case (ty::ty_var(_)) {\n             cx.tcx.sess.span_fatal(sp, \"trans::type_of called on ty_var\");\n@@ -1220,9 +1221,10 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n                                     ty::mk_imm_box(ccx.tcx,\n                                                    ty::mk_nil(ccx.tcx))]);\n             }\n-            case (ty::ty_res(_, ?sub)) {\n+            case (ty::ty_res(_, ?sub, ?tps)) {\n+                auto sub1 = ty::substitute_type_params(ccx.tcx, tps, sub);\n                 ret ty::mk_imm_tup(ccx.tcx, [ty::mk_int(ccx.tcx),\n-                                             simplify_type(ccx, sub)]);\n+                                             simplify_type(ccx, sub1)]);\n             }\n             case (_) { ret typ; }\n         }\n@@ -1716,8 +1718,7 @@ fn get_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n     }\n     // Otherwise, generate a tydesc if necessary, and return it.\n \n-    let vec[uint] tps = [];\n-    auto info = get_static_tydesc(cx, t, tps);\n+    auto info = get_static_tydesc(cx, t, []);\n     static_ti = some[@tydesc_info](info);\n     ret rslt(cx, info.tydesc);\n }\n@@ -2089,8 +2090,8 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n                 cx.build.GEP(v0, [C_int(0), C_int(abi::obj_field_box)]);\n             decr_refcnt_maybe_free(cx, box_cell, v0, t)\n         }\n-        case (ty::ty_res(?did, ?inner)) {\n-            trans_res_drop(cx, v0, did, inner)\n+        case (ty::ty_res(?did, ?inner, ?tps)) {\n+            trans_res_drop(cx, v0, did, inner, tps)\n         }\n         case (ty::ty_fn(_, _, _, _, _)) {\n             auto box_cell =\n@@ -2108,9 +2109,11 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n }\n \n fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n-                  ty::t inner_t) -> result {\n+                  ty::t inner_t, &vec[ty::t] tps) -> result {\n     auto ccx = cx.fcx.lcx.ccx;\n-    auto tup_ty = ty::mk_imm_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t]);\n+\n+    auto inner_t_s = ty::substitute_type_params(ccx.tcx, tps, inner_t);\n+    auto tup_ty = ty::mk_imm_tup(ccx.tcx, [ty::mk_int(ccx.tcx), inner_t_s]);\n     auto drop_cx = new_sub_block_ctxt(cx, \"drop res\");\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n \n@@ -2120,6 +2123,8 @@ fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n     cx.build.CondBr(null_test, next_cx.llbb, drop_cx.llbb);\n     cx = drop_cx;\n \n+    auto val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n+    cx = val.bcx;\n     // Find and call the actual destructor.\n     auto dtor_pair = if (did._0 == ast::local_crate) {\n         ccx.fn_pairs.get(did._1)\n@@ -2136,15 +2141,25 @@ fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n         (cx.build.GEP(dtor_pair, [C_int(0), C_int(abi::fn_field_code)]));\n     auto dtor_env = cx.build.Load\n         (cx.build.GEP(dtor_pair, [C_int(0), C_int(abi::fn_field_box)]));\n-    auto val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n-    cx = val.bcx;\n-    cx.build.FastCall(dtor_addr, [cx.fcx.llretptr, cx.fcx.lltaskptr, dtor_env]\n-                      + cx.fcx.lltydescs + [val.val]);\n-\n-    cx = drop_slot(cx, val.val, inner_t).bcx;\n+    auto args = [cx.fcx.llretptr, cx.fcx.lltaskptr, dtor_env];\n+    for (ty::t tp in tps) {\n+        let option::t[@tydesc_info] ti = none;\n+        auto td = get_tydesc(cx, tp, false, ti);\n+        args += [td.val];\n+        cx = td.bcx;\n+    }\n+    // Kludge to work around the fact that we know the precise type of the\n+    // value here, but the dtor expects a type that still has opaque pointers\n+    // for type variables.\n+    auto val_llty = lib::llvm::fn_ty_param_tys\n+        (llvm::LLVMGetElementType(llvm::LLVMTypeOf(dtor_addr)))\n+        .(vec::len(args));\n+    auto val_cast = cx.build.BitCast(val.val, val_llty);\n+    cx.build.FastCall(dtor_addr, args + [val_cast]);\n+\n+    cx = drop_slot(cx, val.val, inner_t_s).bcx;\n     cx.build.Store(C_int(0), drop_flag.val);\n     cx.build.Br(next_cx.llbb);\n-\n     ret rslt(next_cx, C_nil());\n }\n \n@@ -2611,13 +2626,15 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n                 i += 1;\n             }\n         }\n-        case (ty::ty_res(_, ?inner)) {\n+        case (ty::ty_res(_, ?inner, ?tps)) {\n+            auto inner1 = ty::substitute_type_params(cx.fcx.lcx.ccx.tcx,\n+                                                     tps, inner);\n             r = GEP_tup_like(r.bcx, t, av, [0, 1]);\n             auto llfld_a = r.val;\n             r = GEP_tup_like(r.bcx, t, bv, [0, 1]);\n             auto llfld_b = r.val;\n-            f(r.bcx, load_if_immediate(r.bcx, llfld_a, inner),\n-              load_if_immediate(r.bcx, llfld_b, inner), inner);\n+            f(r.bcx, load_if_immediate(r.bcx, llfld_a, inner1),\n+              load_if_immediate(r.bcx, llfld_b, inner1), inner1);\n         }\n         case (ty::ty_tag(?tid, ?tps)) {\n             auto variants = ty::tag_variants(cx.fcx.lcx.ccx.tcx, tid);\n@@ -2891,9 +2908,9 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                                                  T_glue_fn(lcx.ccx.tn),\n                                                  \"drop\");\n                         ti.drop_glue = some[ValueRef](glue_fn);\n-                        auto dg = make_drop_glue;\n                         make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n-                                          mgghf_single(dg), ti.ty_params);\n+                                          mgghf_single(make_drop_glue),\n+                                          ti.ty_params);\n                         log #fmt(\"--- lazily_emit_tydesc_glue DROP %s\",\n                                  ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n                     }\n@@ -5026,7 +5043,7 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, base);\n             auto offset = alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n                 case (ty::ty_box(_)) { abi::box_rc_field_body }\n-                case (ty::ty_res(_, _)) { 1 }\n+                case (ty::ty_res(_, _, _)) { 1 }\n             };\n             auto val = sub.bcx.build.GEP(sub.val, [C_int(0), C_int(offset)]);\n             ret lval_mem(sub.bcx, val);\n@@ -7850,10 +7867,17 @@ fn trans_res_ctor(@local_ctxt cx, &span sp, &ast::_fn dtor,\n     auto tup_t = ty::mk_imm_tup(cx.ccx.tcx, [ty::mk_int(cx.ccx.tcx), arg_t]);\n     auto arg = load_if_immediate\n         (bcx, fcx.llargs.get(dtor.decl.inputs.(0).id), arg_t);\n-    auto dst = GEP_tup_like(bcx, tup_t, fcx.llretptr, [0, 1]);\n+\n+    auto llretptr = fcx.llretptr;\n+    if (ty::type_has_dynamic_size(cx.ccx.tcx, ret_t)) {\n+        auto llret_t = T_ptr(T_struct([T_i32(), llvm::LLVMTypeOf(arg)]));\n+        llretptr = bcx.build.BitCast(llretptr, llret_t);\n+    }\n+\n+    auto dst = GEP_tup_like(bcx, tup_t, llretptr, [0, 1]);\n     bcx = dst.bcx;\n     bcx = copy_val(bcx, INIT, dst.val, arg, arg_t).bcx;\n-    auto flag = GEP_tup_like(bcx, tup_t, fcx.llretptr, [0, 0]);\n+    auto flag = GEP_tup_like(bcx, tup_t, llretptr, [0, 0]);\n     bcx = flag.bcx;\n     bcx.build.Store(C_int(1), flag.val);\n     bcx.build.RetVoid();\n@@ -7973,7 +7997,7 @@ fn trans_item(@local_ctxt cx, &ast::item item) {\n             trans_res_ctor(cx, item.span, dtor, ctor_id, tps);\n             // Create a function for the destructor\n             auto lldtor_decl = cx.ccx.item_ids.get(item.id);\n-            trans_fn(cx, item.span, dtor, lldtor_decl, none, tps, dtor_id);\n+            trans_fn(cx, item.span, dtor, lldtor_decl, none, tps, dtor_id)\n         }\n         case (ast::item_mod(?m)) {\n             auto sub_cx ="}, {"sha": "0d3be6b041d8eed5e3e4ab4c1d8fef1548fcf02f", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 67, "deletions": 20, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=86f16b90cd694cd706469bb42737e63b1d9c1fdc", "patch": "@@ -268,7 +268,7 @@ tag sty {\n     ty_fn(ast::proto, vec[arg], t, controlflow, vec[@constr_def]);\n     ty_native_fn(ast::native_abi, vec[arg], t);\n     ty_obj(vec[method]);\n-    ty_res(def_id, t);\n+    ty_res(def_id, t, vec[t]);\n     ty_var(int); // type variable\n     ty_param(uint); // fn/tag type param\n     ty_type;\n@@ -497,7 +497,12 @@ fn mk_raw_ty(&ctxt cx, &sty st, &option::t[str] cname) -> raw_t {\n                                  m.output);\n             }\n         }\n-        case (ty_res(_, ?tt)) { derive_flags_t(cx, has_params, has_vars, tt);}\n+        case (ty_res(_, ?tt, ?tps)) {\n+            derive_flags_t(cx, has_params, has_vars, tt);\n+            for (t tt in tps) {\n+                derive_flags_t(cx, has_params, has_vars, tt);\n+            }\n+        }\n     }\n     ret rec(struct=st,\n             cname=cname,\n@@ -604,8 +609,8 @@ fn mk_obj(&ctxt cx, &vec[method] meths) -> t {\n     ret gen_ty(cx, ty_obj(meths));\n }\n \n-fn mk_res(&ctxt cx, &ast::def_id did, &t inner) -> t {\n-    ret gen_ty(cx, ty_res(did, inner));\n+fn mk_res(&ctxt cx, &ast::def_id did, &t inner, &vec[t] tps) -> t {\n+    ret gen_ty(cx, ty_res(did, inner, tps));\n }\n \n fn mk_var(&ctxt cx, int v) -> t { ret gen_ty(cx, ty_var(v)); }\n@@ -689,7 +694,10 @@ fn walk_ty(&ctxt cx, ty_walk walker, t ty) {\n                 walk_ty(cx, walker, m.output);\n             }\n         }\n-        case (ty_res(_, ?sub)) { walk_ty(cx, walker, sub); }\n+        case (ty_res(_, ?sub, ?tps)) {\n+            walk_ty(cx, walker, sub);\n+            for (t tp in tps) { walk_ty(cx, walker, tp); }\n+        }\n         case (ty_var(_)) {/* no-op */ }\n         case (ty_param(_)) {/* no-op */ }\n     }\n@@ -822,8 +830,11 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n             }\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n-        case (ty_res(?did, ?subty)) {\n-            ty = copy_cname(cx, mk_res(cx, did, fold_ty(cx, fld, subty)), ty);\n+        case (ty_res(?did, ?subty, ?tps)) {\n+            auto new_tps = [];\n+            for (t tp in tps) { new_tps += [fold_ty(cx, fld, tp)]; }\n+            ty = copy_cname(cx, mk_res(cx, did, fold_ty(cx, fld, subty),\n+                                       new_tps), ty);\n         }\n         case (ty_var(?id)) {\n             alt (fld) {\n@@ -894,7 +905,7 @@ fn type_is_structural(&ctxt cx, &t ty) -> bool {\n         case (ty_tag(_, _)) { ret true; }\n         case (ty_fn(_, _, _, _, _)) { ret true; }\n         case (ty_obj(_)) { ret true; }\n-        case (ty_res(_, _)) { ret true; }\n+        case (ty_res(_, _, _)) { ret true; }\n         case (ty_ivec(_)) { ret true; }\n         case (ty_istr) { ret true; }\n         case (_) { ret false; }\n@@ -903,7 +914,7 @@ fn type_is_structural(&ctxt cx, &t ty) -> bool {\n \n fn type_is_copyable(&ctxt cx, &t ty) -> bool {\n     ret alt (struct(cx, ty)) {\n-        case (ty_res(_, _)) { false }\n+        case (ty_res(_, _, _)) { false }\n         case (_) { true }\n     };\n }\n@@ -1050,7 +1061,10 @@ fn type_has_pointers(&ctxt cx, &t ty) -> bool {\n                 if (type_has_pointers(cx, tup_ty)) { result = true; }\n             }\n         }\n-        case (ty_res(?did, ?inner)) { result = type_has_pointers(cx, inner); }\n+        case (ty_res(?did, ?inner, ?tps)) {\n+            result = type_has_pointers\n+                (cx, substitute_type_params(cx, tps, inner));\n+        }\n         case (_) { result = true; }\n     }\n \n@@ -1114,7 +1128,12 @@ fn type_has_dynamic_size(&ctxt cx, &t ty) -> bool {\n         case (ty_fn(_,_,_,_,_)) { ret false; }\n         case (ty_native_fn(_,_,_)) { ret false; }\n         case (ty_obj(_)) { ret false; }\n-        case (ty_res(_, ?sub)) { ret type_has_dynamic_size(cx, sub); }\n+        case (ty_res(_, ?sub, ?tps)) {\n+            for (t tp in tps) {\n+                if (type_has_dynamic_size(cx, tp)) { ret true; }\n+            }\n+            ret type_has_dynamic_size(cx, sub);\n+        }\n         case (ty_var(_)) { fail \"ty_var in type_has_dynamic_size()\"; }\n         case (ty_param(_)) { ret true; }\n         case (ty_type) { ret false; }\n@@ -1225,7 +1244,10 @@ fn type_owns_heap_mem(&ctxt cx, &t ty) -> bool {\n                 if (type_owns_heap_mem(cx, f.mt.ty)) { result = true; }\n             }\n         }\n-        case (ty_res(_, ?inner)) { result = type_owns_heap_mem(cx, inner); }\n+        case (ty_res(_, ?inner, ?tps)) {\n+            result = type_owns_heap_mem\n+                (cx, substitute_type_params(cx, tps, inner));\n+        }\n \n         case (ty_ptr(_)) { result = false; }\n         case (ty_port(_)) { result = false; }\n@@ -1337,7 +1359,11 @@ fn hash_type_structure(&sty st) -> uint {\n         case (ty_native) { ret 33u; }\n         case (ty_bot) { ret 34u; }\n         case (ty_ptr(?mt)) { ret hash_subty(35u, mt.ty); }\n-        case (ty_res(?did, ?sub)) { ret hash_subty(hash_def(18u, did), sub); }\n+        case (ty_res(?did, ?sub, ?tps)) {\n+            auto h = hash_subty(hash_def(18u, did), sub);\n+            for (t tp in tps) { h += h << 5u + hash_ty(tp); }\n+            ret h;\n+        }\n     }\n }\n \n@@ -1598,10 +1624,18 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                 case (_) { ret false; }\n             }\n         }\n-        case (ty_res(?id_a, ?inner_a)) {\n+        case (ty_res(?id_a, ?inner_a, ?tps_a)) {\n             alt (b) {\n-                case (ty_res(?id_b, ?inner_b)) {\n-                    ret equal_def(id_a, id_b) && ret eq_ty(inner_a, inner_b);\n+                case (ty_res(?id_b, ?inner_b, ?tps_b)) {\n+                    if (!equal_def(id_a, id_b) || !eq_ty(inner_a, inner_b)) {\n+                        ret false;\n+                    }\n+                    auto i = 0u;\n+                    for (t tp_a in tps_a) {\n+                        if (!eq_ty(tp_a, tps_b.(i))) { ret false; }\n+                        i += 1u;\n+                    }\n+                    ret true;\n                 }\n                 case (_) { ret false; }\n             }\n@@ -2394,17 +2428,30 @@ mod unify {\n                     case (_) { ret ures_err(terr_mismatch); }\n                 }\n             }\n-            case (ty::ty_res(?ex_id, ?ex_inner)) {\n+            case (ty::ty_res(?ex_id, ?ex_inner, ?ex_tps)) {\n                 alt (struct(cx.tcx, actual)) {\n-                    case (ty::ty_res(?act_id, ?act_inner)) {\n+                    case (ty::ty_res(?act_id, ?act_inner, ?act_tps)) {\n                         if (ex_id._0 != act_id._0 || ex_id._1 != act_id._1) {\n                             ret ures_err(terr_mismatch);\n                         }\n                         auto result = unify_step(cx, ex_inner, act_inner);\n                         alt (result) {\n                             case (ures_ok(?res_inner)) {\n-                                ret ures_ok(mk_res(cx.tcx, act_id,\n-                                                   res_inner));\n+                                auto i = 0u;\n+                                auto res_tps = [];\n+                                for (t ex_tp in ex_tps) {\n+                                    auto result =\n+                                        unify_step(cx, ex_tp, act_tps.(i));\n+                                    alt (result) {\n+                                        case (ures_ok(?rty)) {\n+                                            vec::push(res_tps, rty);\n+                                        }\n+                                        case (_) { ret result; }\n+                                    }\n+                                    i += 1u;\n+                                }\n+                                ret ures_ok(mk_res(cx.tcx, act_id, res_inner,\n+                                                   res_tps));\n                             }\n                             case (_) { ret result; }\n                         }"}, {"sha": "4230a4967cd940843e2e1af94b2d663bd7c7bd80", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=86f16b90cd694cd706469bb42737e63b1d9c1fdc", "patch": "@@ -439,6 +439,15 @@ mod write {\n mod collect {\n     type ctxt = rec(ty::ctxt tcx);\n \n+    fn mk_ty_params(&@ctxt cx, uint n) -> vec[ty::t] {\n+        auto tps = [];\n+        auto i = 0u;\n+        while (i < n) {\n+            tps += [ty::mk_param(cx.tcx, i)];\n+            i += 1u;\n+        }\n+        ret tps;\n+    }\n     fn ty_of_fn_decl(&@ctxt cx, &fn(&@ast::ty) -> ty::t  convert,\n                      &fn(&ast::arg) -> arg  ty_of_arg, &ast::fn_decl decl,\n                      ast::proto proto, &vec[ast::ty_param] ty_params,\n@@ -581,21 +590,17 @@ mod collect {\n             case (ast::item_res(?f, _, ?tps, _)) {\n                 auto t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n                 auto t_res = tup(vec::len(tps), ty::mk_res\n-                                 (cx.tcx, local_def(it.id), t_arg.ty));\n+                                 (cx.tcx, local_def(it.id), t_arg.ty,\n+                                  mk_ty_params(cx, vec::len(tps))));\n                 cx.tcx.tcache.insert(local_def(it.id), t_res);\n                 ret t_res;\n             }\n             case (ast::item_tag(_, ?tps)) {\n                 // Create a new generic polytype.\n \n-                let vec[ty::t] subtys = [];\n-                auto i = 0u;\n-                for (ast::ty_param tp in tps) {\n-                    subtys += [ty::mk_param(cx.tcx, i)];\n-                    i += 1u;\n-                }\n-                auto t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n                 auto ty_param_count = vec::len[ast::ty_param](tps);\n+                let vec[ty::t] subtys = mk_ty_params(cx, ty_param_count);\n+                auto t = ty::mk_tag(cx.tcx, local_def(it.id), subtys);\n                 auto tpt = tup(ty_param_count, t);\n                 cx.tcx.tcache.insert(local_def(it.id), tpt);\n                 ret tpt;\n@@ -631,13 +636,8 @@ mod collect {\n                              &vec[ast::ty_param] ty_params) {\n         // Create a set of parameter types shared among all the variants.\n \n-        let vec[ty::t] ty_param_tys = [];\n-        auto i = 0u;\n-        for (ast::ty_param tp in ty_params) {\n-            ty_param_tys += [ty::mk_param(cx.tcx, i)];\n-            i += 1u;\n-        }\n         auto ty_param_count = vec::len[ast::ty_param](ty_params);\n+        let vec[ty::t] ty_param_tys = mk_ty_params(cx, ty_param_count);\n         for (ast::variant variant in variants) {\n             // Nullary tag constructors get turned into constants; n-ary tag\n             // constructors get turned into functions.\n@@ -737,7 +737,8 @@ mod collect {\n             }\n             case (ast::item_res(?f, ?dtor_id, ?tps, ?ctor_id)) {\n                 auto t_arg = ty_of_arg(cx, f.decl.inputs.(0));\n-                auto t_res = ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty);\n+                auto t_res = ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n+                                        mk_ty_params(cx, vec::len(tps)));\n                 auto t_ctor = ty::mk_fn(cx.tcx, ast::proto_fn, [t_arg],\n                                         t_res, ast::return, []);\n                 auto t_dtor = ty::mk_fn(cx.tcx, ast::proto_fn, [t_arg],\n@@ -1527,7 +1528,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 case (ast::deref) {\n                     alt (structure_of(fcx, expr.span, oper_t)) {\n                         case (ty::ty_box(?inner)) { oper_t = inner.ty; }\n-                        case (ty::ty_res(_, ?inner)) { oper_t = inner; }\n+                        case (ty::ty_res(_, ?inner, _)) { oper_t = inner; }\n                         case (_) {\n                             auto s = \"dereferencing non-box type: \" +\n                                 ty_to_str(fcx.ccx.tcx, oper_t);"}, {"sha": "7be26e89c2181c8144aabde02cd56e6fc68cedd3", "filename": "src/test/run-pass/resource-generic.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86f16b90cd694cd706469bb42737e63b1d9c1fdc/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=86f16b90cd694cd706469bb42737e63b1d9c1fdc", "patch": "@@ -0,0 +1,13 @@\n+resource finish[T](rec(T val, fn(&T) fin) arg) {\n+    arg.fin(arg.val);\n+}\n+\n+fn main() {\n+    auto box = @mutable 10;\n+    fn dec_box(&@mutable int i) { *i -= 1; }\n+\n+    {\n+        auto i <- finish(rec(val=box, fin=dec_box));\n+    }\n+    assert(*box == 9);\n+}"}]}