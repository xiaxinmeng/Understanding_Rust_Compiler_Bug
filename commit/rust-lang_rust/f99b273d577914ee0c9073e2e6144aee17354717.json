{"sha": "f99b273d577914ee0c9073e2e6144aee17354717", "node_id": "C_kwDOAAsO6NoAKGY5OWIyNzNkNTc3OTE0ZWUwYzkwNzNlMmU2MTQ0YWVlMTczNTQ3MTc", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-17T19:50:50Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-18T14:28:14Z"}, "message": "implement consider_assumption", "tree": {"sha": "311d194a58340c09a41883d67ec887ed03f68b13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/311d194a58340c09a41883d67ec887ed03f68b13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f99b273d577914ee0c9073e2e6144aee17354717", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f99b273d577914ee0c9073e2e6144aee17354717", "html_url": "https://github.com/rust-lang/rust/commit/f99b273d577914ee0c9073e2e6144aee17354717", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f99b273d577914ee0c9073e2e6144aee17354717/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b84b1da2dbacdfd7e33428540062380b56bfd8de", "url": "https://api.github.com/repos/rust-lang/rust/commits/b84b1da2dbacdfd7e33428540062380b56bfd8de", "html_url": "https://github.com/rust-lang/rust/commit/b84b1da2dbacdfd7e33428540062380b56bfd8de"}], "stats": {"total": 80, "additions": 70, "deletions": 10}, "files": [{"sha": "47e6c93016a0e053e1b2f581e82849e479709ffa", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f99b273d577914ee0c9073e2e6144aee17354717/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b273d577914ee0c9073e2e6144aee17354717/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=f99b273d577914ee0c9073e2e6144aee17354717", "patch": "@@ -25,6 +25,13 @@ pub(super) trait InferCtxtExt<'tcx> {\n         lhs: T,\n         rhs: T,\n     ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution>;\n+\n+    fn sup<T: ToTrace<'tcx>>(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution>;\n }\n \n impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n@@ -59,4 +66,23 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                 NoSolution\n             })\n     }\n+\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    fn sup<T: ToTrace<'tcx>>(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        lhs: T,\n+        rhs: T,\n+    ) -> Result<Vec<Goal<'tcx, ty::Predicate<'tcx>>>, NoSolution> {\n+        self.at(&ObligationCause::dummy(), param_env)\n+            .define_opaque_types(false)\n+            .sup(lhs, rhs)\n+            .map(|InferOk { value: (), obligations }| {\n+                obligations.into_iter().map(|o| o.into()).collect()\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to sup\");\n+                NoSolution\n+            })\n+    }\n }"}, {"sha": "9ebcb4e4657d845784c4b6f957366a62e0954554", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f99b273d577914ee0c9073e2e6144aee17354717/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b273d577914ee0c9073e2e6144aee17354717/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=f99b273d577914ee0c9073e2e6144aee17354717", "patch": "@@ -6,7 +6,7 @@ use super::{Certainty, EvalCtxt, Goal, MaybeCause, QueryResult};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n-use rustc_infer::infer::InferCtxt;\n+use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n@@ -298,12 +298,37 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     }\n \n     fn consider_assumption(\n-        _ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(_poly_projection_pred) = assumption.to_opt_poly_projection_pred() {\n-            unimplemented!()\n+        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred() {\n+            ecx.infcx.probe(|_| {\n+                let assumption_projection_pred = ecx.infcx.replace_bound_vars_with_fresh_vars(\n+                    DUMMY_SP,\n+                    LateBoundRegionConversionTime::HigherRankedType,\n+                    poly_projection_pred,\n+                );\n+                let nested_goals = ecx.infcx.sup(\n+                    goal.param_env,\n+                    goal.predicate.projection_ty,\n+                    assumption_projection_pred.projection_ty,\n+                )?;\n+                let subst_certainty = ecx.evaluate_all(nested_goals)?;\n+\n+                // The term of our goal should be fully unconstrained, so this should never fail.\n+                //\n+                // It can however be ambiguous when the resolved type is a projection.\n+                let nested_goals = ecx\n+                    .infcx\n+                    .eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n+                    .expect(\"failed to unify with unconstrained term\");\n+                let rhs_certainty = ecx\n+                    .evaluate_all(nested_goals)\n+                    .expect(\"failed to unify with unconstrained term\");\n+\n+                ecx.make_canonical_response(subst_certainty.unify_and(rhs_certainty))\n+            })\n         } else {\n             Err(NoSolution)\n         }"}, {"sha": "362424b0d14314931a37a6e5adb11a6f37ee187c", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f99b273d577914ee0c9073e2e6144aee17354717/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f99b273d577914ee0c9073e2e6144aee17354717/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=f99b273d577914ee0c9073e2e6144aee17354717", "patch": "@@ -6,10 +6,11 @@ use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n use super::{EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n-use rustc_middle::ty::TraitPredicate;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{ToPolyTraitRef, TraitPredicate};\n use rustc_span::DUMMY_SP;\n \n impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n@@ -65,12 +66,20 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n     }\n \n     fn consider_assumption(\n-        _ecx: &mut EvalCtxt<'_, 'tcx>,\n-        _goal: Goal<'tcx, Self>,\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n     ) -> QueryResult<'tcx> {\n-        if let Some(_poly_trait_pred) = assumption.to_opt_poly_trait_pred() {\n-            unimplemented!()\n+        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred() {\n+            // FIXME: Constness and polarity\n+            ecx.infcx.probe(|_| {\n+                let nested_goals = ecx.infcx.sup(\n+                    goal.param_env,\n+                    ty::Binder::dummy(goal.predicate.trait_ref),\n+                    poly_trait_pred.to_poly_trait_ref(),\n+                )?;\n+                ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            })\n         } else {\n             Err(NoSolution)\n         }"}]}