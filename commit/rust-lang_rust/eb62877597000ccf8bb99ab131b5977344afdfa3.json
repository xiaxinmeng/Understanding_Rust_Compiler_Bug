{"sha": "eb62877597000ccf8bb99ab131b5977344afdfa3", "node_id": "C_kwDOAAsO6NoAKGViNjI4Nzc1OTcwMDBjY2Y4YmI5OWFiMTMxYjU5NzczNDRhZmRmYTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-29T16:17:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-29T16:17:35Z"}, "message": "Auto merge of #110994 - matthiaskrgr:rollup-wv4u5yi, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #105848 (rustdoc: Add a new lint for broken inline code)\n - #110644 (Update tests for libtest `--format json`)\n - #110950 (Deny the `unsafe_op_in_unsafe_fn` lint in `rustc_arena`.)\n - #110951 (Add support for LibreSSL 3.7.x)\n - #110964 (rustdoc: fix weird margins between Deref impl items)\n - #110979 (windows: kill rust-analyzer-proc-macro-srv before deleting stage0 directory)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "861b0adc2ddac1fc927b77b5b4fe8f5a60c4bb8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/861b0adc2ddac1fc927b77b5b4fe8f5a60c4bb8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb62877597000ccf8bb99ab131b5977344afdfa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb62877597000ccf8bb99ab131b5977344afdfa3", "html_url": "https://github.com/rust-lang/rust/commit/eb62877597000ccf8bb99ab131b5977344afdfa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb62877597000ccf8bb99ab131b5977344afdfa3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27d22d2045478c544ad043556de4993eebe4be29", "url": "https://api.github.com/repos/rust-lang/rust/commits/27d22d2045478c544ad043556de4993eebe4be29", "html_url": "https://github.com/rust-lang/rust/commit/27d22d2045478c544ad043556de4993eebe4be29"}, {"sha": "72de69e04641823c8e8fb1eafa8f4bd53c77f867", "url": "https://api.github.com/repos/rust-lang/rust/commits/72de69e04641823c8e8fb1eafa8f4bd53c77f867", "html_url": "https://github.com/rust-lang/rust/commit/72de69e04641823c8e8fb1eafa8f4bd53c77f867"}], "stats": {"total": 1990, "additions": 1952, "deletions": 38}, "files": [{"sha": "dc12737851e410ceefcad93e6a23453c3081b0db", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -2370,9 +2370,9 @@ checksum = \"ff011a302c396a5197692431fc1948019154afc178baf7d8e37367442a4601cf\"\n \n [[package]]\n name = \"openssl-sys\"\n-version = \"0.9.84\"\n+version = \"0.9.87\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3a20eace9dc2d82904039cb76dcf50fb1a0bba071cfd1629720b5d6f1ddba0fa\"\n+checksum = \"8e17f59264b2809d77ae94f0e1ebabc434773f370d6ca667bd223ea10e06cc7e\"\n dependencies = [\n  \"cc\",\n  \"libc\","}, {"sha": "6e15f06a76de015dc8c62ac25d5fdf1fd0901654", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -20,6 +20,7 @@\n #![feature(rustc_attrs)]\n #![cfg_attr(test, feature(test))]\n #![feature(strict_provenance)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n #![allow(clippy::mut_from_ref)] // Arena allocators are one of the places where this pattern is fine.\n@@ -74,19 +75,27 @@ impl<T> ArenaChunk<T> {\n     #[inline]\n     unsafe fn new(capacity: usize) -> ArenaChunk<T> {\n         ArenaChunk {\n-            storage: NonNull::new_unchecked(Box::into_raw(Box::new_uninit_slice(capacity))),\n+            storage: NonNull::from(Box::leak(Box::new_uninit_slice(capacity))),\n             entries: 0,\n         }\n     }\n \n     /// Destroys this arena chunk.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The caller must ensure that `len` elements of this chunk have been initialized.\n     #[inline]\n     unsafe fn destroy(&mut self, len: usize) {\n         // The branch on needs_drop() is an -O1 performance optimization.\n-        // Without the branch, dropping TypedArena<u8> takes linear time.\n+        // Without the branch, dropping TypedArena<T> takes linear time.\n         if mem::needs_drop::<T>() {\n-            let slice = self.storage.as_mut();\n-            ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut slice[..len]));\n+            // SAFETY: The caller must ensure that `len` elements of this chunk have\n+            // been initialized.\n+            unsafe {\n+                let slice = self.storage.as_mut();\n+                ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(&mut slice[..len]));\n+            }\n         }\n     }\n \n@@ -255,7 +264,9 @@ impl<T> TypedArena<T> {\n         self.ensure_capacity(len);\n \n         let start_ptr = self.ptr.get();\n-        self.ptr.set(start_ptr.add(len));\n+        // SAFETY: `self.ensure_capacity` makes sure that there is enough space\n+        // for `len` elements.\n+        unsafe { self.ptr.set(start_ptr.add(len)) };\n         start_ptr\n     }\n \n@@ -483,6 +494,10 @@ impl DroplessArena {\n         }\n     }\n \n+    /// # Safety\n+    ///\n+    /// The caller must ensure that `mem` is valid for writes up to\n+    /// `size_of::<T>() * len`.\n     #[inline]\n     unsafe fn write_from_iter<T, I: Iterator<Item = T>>(\n         &self,\n@@ -494,13 +509,18 @@ impl DroplessArena {\n         // Use a manual loop since LLVM manages to optimize it better for\n         // slice iterators\n         loop {\n-            let value = iter.next();\n-            if i >= len || value.is_none() {\n-                // We only return as many items as the iterator gave us, even\n-                // though it was supposed to give us `len`\n-                return slice::from_raw_parts_mut(mem, i);\n+            // SAFETY: The caller must ensure that `mem` is valid for writes up to\n+            // `size_of::<T>() * len`.\n+            unsafe {\n+                match iter.next() {\n+                    Some(value) if i < len => mem.add(i).write(value),\n+                    Some(_) | None => {\n+                        // We only return as many items as the iterator gave us, even\n+                        // though it was supposed to give us `len`\n+                        return slice::from_raw_parts_mut(mem, i);\n+                    }\n+                }\n             }\n-            ptr::write(mem.add(i), value.unwrap());\n             i += 1;\n         }\n     }"}, {"sha": "ff261ab9832737cb347092c497bbc7fc775e2079", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -19,7 +19,10 @@\n except ImportError:\n     lzma = None\n \n-if sys.platform == 'win32':\n+def platform_is_win32():\n+    return sys.platform == 'win32'\n+\n+if platform_is_win32():\n     EXE_SUFFIX = \".exe\"\n else:\n     EXE_SUFFIX = \"\"\n@@ -78,15 +81,14 @@ def _download(path, url, probably_big, verbose, exception):\n     if probably_big or verbose:\n         print(\"downloading {}\".format(url))\n \n-    platform_is_win32 = sys.platform == 'win32'\n     try:\n         if probably_big or verbose:\n             option = \"-#\"\n         else:\n             option = \"-s\"\n         # If curl is not present on Win32, we should not sys.exit\n         #   but raise `CalledProcessError` or `OSError` instead\n-        require([\"curl\", \"--version\"], exception=platform_is_win32)\n+        require([\"curl\", \"--version\"], exception=platform_is_win32())\n         with open(path, \"wb\") as outfile:\n             run([\"curl\", option,\n                 \"-L\", # Follow redirect.\n@@ -99,8 +101,8 @@ def _download(path, url, probably_big, verbose, exception):\n             )\n     except (subprocess.CalledProcessError, OSError, RuntimeError):\n         # see http://serverfault.com/questions/301128/how-to-download\n-        if platform_is_win32:\n-            run([\"PowerShell.exe\", \"/nologo\", \"-Command\",\n+        if platform_is_win32():\n+            run_powershell([\n                  \"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\",\n                  \"(New-Object System.Net.WebClient).DownloadFile('{}', '{}')\".format(url, path)],\n                 verbose=verbose,\n@@ -174,6 +176,10 @@ def run(args, verbose=False, exception=False, is_bootstrap=False, **kwargs):\n         else:\n             sys.exit(err)\n \n+def run_powershell(script, *args, **kwargs):\n+    \"\"\"Run a powershell script\"\"\"\n+    run([\"PowerShell.exe\", \"/nologo\", \"-Command\"] + script, *args, **kwargs)\n+\n \n def require(cmd, exit=True, exception=False):\n     '''Run a command, returning its output.\n@@ -229,7 +235,7 @@ def default_build_triple(verbose):\n                 print(\"pre-installed rustc not detected: {}\".format(e))\n                 print(\"falling back to auto-detect\")\n \n-    required = sys.platform != 'win32'\n+    required = not platform_is_win32()\n     ostype = require([\"uname\", \"-s\"], exit=required)\n     cputype = require(['uname', '-m'], exit=required)\n \n@@ -434,6 +440,23 @@ def download_toolchain(self):\n                 (not os.path.exists(self.rustc()) or\n                  self.program_out_of_date(self.rustc_stamp(), key)):\n             if os.path.exists(bin_root):\n+                # HACK: On Windows, we can't delete rust-analyzer-proc-macro-server while it's\n+                # running. Kill it.\n+                if platform_is_win32():\n+                    print(\"Killing rust-analyzer-proc-macro-srv before deleting stage0 toolchain\")\n+                    regex =  '{}\\\\\\\\(host|{})\\\\\\\\stage0\\\\\\\\libexec'.format(\n+                        os.path.basename(self.build_dir),\n+                        self.build\n+                    )\n+                    script = (\n+                        # NOTE: can't use `taskkill` or `Get-Process -Name` because they error if\n+                        # the server isn't running.\n+                        'Get-Process | ' +\n+                        'Where-Object {$_.Name -eq \"rust-analyzer-proc-macro-srv\"} |' +\n+                        'Where-Object {{$_.Path -match \"{}\"}} |'.format(regex) +\n+                        'Stop-Process'\n+                    )\n+                    run_powershell([script])\n                 shutil.rmtree(bin_root)\n             tarball_suffix = '.tar.gz' if lzma is None else '.tar.xz'\n             filename = \"rust-std-{}-{}{}\".format("}, {"sha": "fd57b07964481b3382c89c1aeb734d8306d66823", "filename": "src/doc/rustdoc/src/lints.md", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -374,3 +374,41 @@ warning: this URL is not a hyperlink\n \n warning: 2 warnings emitted\n ```\n+\n+## `unescaped_backticks`\n+\n+This lint is **allowed by default**. It detects backticks (\\`) that are not escaped.\n+This usually means broken inline code. For example:\n+\n+```rust\n+#![warn(rustdoc::unescaped_backticks)]\n+\n+/// `add(a, b) is the same as `add(b, a)`.\n+pub fn add(a: i32, b: i32) -> i32 { a + b }\n+```\n+\n+Which will give:\n+\n+```text\n+warning: unescaped backtick\n+ --> src/lib.rs:3:41\n+  |\n+3 | /// `add(a, b) is the same as `add(b, a)`.\n+  |                                         ^\n+  |\n+note: the lint level is defined here\n+ --> src/lib.rs:1:9\n+  |\n+1 | #![warn(rustdoc::unescaped_backticks)]\n+  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: a previous inline code might be longer than expected\n+  |\n+3 | /// `add(a, b)` is the same as `add(b, a)`.\n+  |               +\n+help: if you meant to use a literal backtick, escape it\n+  |\n+3 | /// `add(a, b) is the same as `add(b, a)\\`.\n+  |                                         +\n+\n+warning: 1 warning emitted\n+```"}, {"sha": "d90d0aecb93ad5e6d9ff6624b1d22e45d3c4b9df", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -1155,10 +1155,10 @@ fn render_assoc_items_inner(\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n         let mut tmp_buf = Buffer::html();\n-        let (render_mode, id) = match what {\n+        let (render_mode, id, class_html) = match what {\n             AssocItemRender::All => {\n                 write_impl_section_heading(&mut tmp_buf, \"Implementations\", \"implementations\");\n-                (RenderMode::Normal, \"implementations-list\".to_owned())\n+                (RenderMode::Normal, \"implementations-list\".to_owned(), \"\")\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n                 let id =\n@@ -1175,7 +1175,11 @@ fn render_assoc_items_inner(\n                     ),\n                     &id,\n                 );\n-                (RenderMode::ForDeref { mut_: deref_mut_ }, cx.derive_id(id))\n+                (\n+                    RenderMode::ForDeref { mut_: deref_mut_ },\n+                    cx.derive_id(id),\n+                    r#\" class=\"impl-items\"\"#,\n+                )\n             }\n         };\n         let mut impls_buf = Buffer::html();\n@@ -1199,7 +1203,7 @@ fn render_assoc_items_inner(\n         }\n         if !impls_buf.is_empty() {\n             write!(w, \"{}\", tmp_buf.into_inner()).unwrap();\n-            write!(w, \"<div id=\\\"{}\\\">\", id).unwrap();\n+            write!(w, \"<div id=\\\"{id}\\\"{class_html}>\").unwrap();\n             write!(w, \"{}\", impls_buf.into_inner()).unwrap();\n             w.write_str(\"</div>\").unwrap();\n         }\n@@ -1788,12 +1792,14 @@ fn render_impl(\n                 .into_string()\n             );\n         }\n+        if !default_impl_items.is_empty() || !impl_items.is_empty() {\n+            w.write_str(\"<div class=\\\"impl-items\\\">\");\n+            close_tags.insert_str(0, \"</div>\");\n+        }\n     }\n     if !default_impl_items.is_empty() || !impl_items.is_empty() {\n-        w.write_str(\"<div class=\\\"impl-items\\\">\");\n         w.push_buffer(default_impl_items);\n         w.push_buffer(impl_items);\n-        close_tags.insert_str(0, \"</div>\");\n     }\n     w.write_str(&close_tags);\n }"}, {"sha": "60754130d997c56afcdcd475023faa2f08d544c0", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -7,14 +7,15 @@\n #![feature(assert_matches)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n+#![feature(impl_trait_in_assoc_type)]\n+#![feature(iter_intersperse)]\n+#![feature(lazy_cell)]\n #![feature(let_chains)]\n-#![feature(test)]\n #![feature(never_type)]\n-#![feature(lazy_cell)]\n-#![feature(type_ascription)]\n-#![feature(iter_intersperse)]\n+#![feature(round_char_boundary)]\n+#![feature(test)]\n #![feature(type_alias_impl_trait)]\n-#![feature(impl_trait_in_assoc_type)]\n+#![feature(type_ascription)]\n #![recursion_limit = \"256\"]\n #![warn(rustc::internal)]\n #![allow(clippy::collapsible_if, clippy::collapsible_else_if)]"}, {"sha": "749c1ff51bfc582bf51bdf6a7bea080739418efd", "filename": "src/librustdoc/lint.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flint.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -174,6 +174,17 @@ declare_rustdoc_lint! {\n    \"codeblock could not be parsed as valid Rust or is empty\"\n }\n \n+declare_rustdoc_lint! {\n+   /// The `unescaped_backticks` lint detects unescaped backticks (\\`), which usually\n+   /// mean broken inline code. This is a `rustdoc` only lint, see the documentation\n+   /// in the [rustdoc book].\n+   ///\n+   /// [rustdoc book]: ../../../rustdoc/lints.html#unescaped_backticks\n+   UNESCAPED_BACKTICKS,\n+   Allow,\n+   \"detects unescaped backticks in doc comments\"\n+}\n+\n pub(crate) static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n     vec![\n         BROKEN_INTRA_DOC_LINKS,\n@@ -185,6 +196,7 @@ pub(crate) static RUSTDOC_LINTS: Lazy<Vec<&'static Lint>> = Lazy::new(|| {\n         INVALID_HTML_TAGS,\n         BARE_URLS,\n         MISSING_CRATE_LEVEL_DOCS,\n+        UNESCAPED_BACKTICKS,\n     ]\n });\n "}, {"sha": "e653207b9b6d4278b587c9cf0b5f0cada25c566b", "filename": "src/librustdoc/passes/lint.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Fpasses%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Fpasses%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -4,6 +4,7 @@\n mod bare_urls;\n mod check_code_block_syntax;\n mod html_tags;\n+mod unescaped_backticks;\n \n use super::Pass;\n use crate::clean::*;\n@@ -27,6 +28,7 @@ impl<'a, 'tcx> DocVisitor for Linter<'a, 'tcx> {\n         bare_urls::visit_item(self.cx, item);\n         check_code_block_syntax::visit_item(self.cx, item);\n         html_tags::visit_item(self.cx, item);\n+        unescaped_backticks::visit_item(self.cx, item);\n \n         self.visit_item_recur(item)\n     }"}, {"sha": "33cef82a60cbb54385fb9dbf0a4a9dba8ee5c0b8", "filename": "src/librustdoc/passes/lint/unescaped_backticks.rs", "status": "added", "additions": 416, "deletions": 0, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Funescaped_backticks.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -0,0 +1,416 @@\n+//! Detects unescaped backticks (\\`) in doc comments.\n+\n+use crate::clean::Item;\n+use crate::core::DocContext;\n+use crate::html::markdown::main_body_opts;\n+use crate::passes::source_span_for_markdown_range;\n+use pulldown_cmark::{BrokenLink, Event, Parser};\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_lint_defs::Applicability;\n+use std::ops::Range;\n+\n+pub(crate) fn visit_item(cx: &DocContext<'_>, item: &Item) {\n+    let tcx = cx.tcx;\n+    let Some(hir_id) = DocContext::as_local_hir_id(tcx, item.item_id) else {\n+        // If non-local, no need to check anything.\n+        return;\n+    };\n+\n+    let dox = item.attrs.collapsed_doc_value().unwrap_or_default();\n+    if dox.is_empty() {\n+        return;\n+    }\n+\n+    let link_names = item.link_names(&cx.cache);\n+    let mut replacer = |broken_link: BrokenLink<'_>| {\n+        link_names\n+            .iter()\n+            .find(|link| *link.original_text == *broken_link.reference)\n+            .map(|link| ((*link.href).into(), (*link.new_text).into()))\n+    };\n+    let parser = Parser::new_with_broken_link_callback(&dox, main_body_opts(), Some(&mut replacer))\n+        .into_offset_iter();\n+\n+    let mut element_stack = Vec::new();\n+\n+    let mut prev_text_end = 0;\n+    for (event, event_range) in parser {\n+        match event {\n+            Event::Start(_) => {\n+                element_stack.push(Element::new(event_range));\n+            }\n+            Event::End(_) => {\n+                let element = element_stack.pop().unwrap();\n+\n+                let Some(backtick_index) = element.backtick_index else {\n+                    continue;\n+                };\n+\n+                // If we can't get a span of the backtick, because it is in a `#[doc = \"\"]` attribute,\n+                // use the span of the entire attribute as a fallback.\n+                let span = source_span_for_markdown_range(\n+                    tcx,\n+                    &dox,\n+                    &(backtick_index..backtick_index + 1),\n+                    &item.attrs,\n+                )\n+                .unwrap_or_else(|| item.attr_span(tcx));\n+\n+                cx.tcx.struct_span_lint_hir(crate::lint::UNESCAPED_BACKTICKS, hir_id, span, \"unescaped backtick\", |lint| {\n+                    let mut help_emitted = false;\n+\n+                    match element.prev_code_guess {\n+                        PrevCodeGuess::None => {}\n+                        PrevCodeGuess::Start { guess, .. } => {\n+                            // \"foo` `bar`\" -> \"`foo` `bar`\"\n+                            if let Some(suggest_index) = clamp_start(guess, &element.suggestible_ranges)\n+                                && can_suggest_backtick(&dox, suggest_index)\n+                            {\n+                                suggest_insertion(cx, item, &dox, lint, suggest_index, '`', \"the opening backtick of a previous inline code may be missing\");\n+                                help_emitted = true;\n+                            }\n+                        }\n+                        PrevCodeGuess::End { guess, .. } => {\n+                            // \"`foo `bar`\" -> \"`foo` `bar`\"\n+                            // Don't `clamp_end` here, because the suggestion is guaranteed to be inside\n+                            // an inline code node and we intentionally \"break\" the inline code here.\n+                            let suggest_index = guess;\n+                            if can_suggest_backtick(&dox, suggest_index) {\n+                                suggest_insertion(cx, item, &dox, lint, suggest_index, '`', \"a previous inline code might be longer than expected\");\n+                                help_emitted = true;\n+                            }\n+                        }\n+                    }\n+\n+                    if !element.prev_code_guess.is_confident() {\n+                        // \"`foo` bar`\" -> \"`foo` `bar`\"\n+                        if let Some(guess) = guess_start_of_code(&dox, element.element_range.start..backtick_index)\n+                            && let Some(suggest_index) = clamp_start(guess, &element.suggestible_ranges)\n+                            && can_suggest_backtick(&dox, suggest_index)\n+                        {\n+                            suggest_insertion(cx, item, &dox, lint, suggest_index, '`', \"the opening backtick of an inline code may be missing\");\n+                            help_emitted = true;\n+                        }\n+\n+                        // \"`foo` `bar\" -> \"`foo` `bar`\"\n+                        // Don't suggest closing backtick after single trailing char,\n+                        // if we already suggested opening backtick. For example:\n+                        // \"foo`.\" -> \"`foo`.\" or \"foo`s\" -> \"`foo`s\".\n+                        if let Some(guess) = guess_end_of_code(&dox, backtick_index + 1..element.element_range.end)\n+                            && let Some(suggest_index) = clamp_end(guess, &element.suggestible_ranges)\n+                            && can_suggest_backtick(&dox, suggest_index)\n+                            && (!help_emitted || suggest_index - backtick_index > 2)\n+                        {\n+                            suggest_insertion(cx, item, &dox, lint, suggest_index, '`', \"the closing backtick of an inline code may be missing\");\n+                            help_emitted = true;\n+                        }\n+                    }\n+\n+                    if !help_emitted {\n+                        lint.help(\"the opening or closing backtick of an inline code may be missing\");\n+                    }\n+\n+                    suggest_insertion(cx, item, &dox, lint, backtick_index, '\\\\', \"if you meant to use a literal backtick, escape it\");\n+\n+                    lint\n+                });\n+            }\n+            Event::Code(_) => {\n+                let element = element_stack\n+                    .last_mut()\n+                    .expect(\"expected inline code node to be inside of an element\");\n+                assert!(\n+                    event_range.start >= element.element_range.start\n+                        && event_range.end <= element.element_range.end\n+                );\n+\n+                // This inline code might be longer than it's supposed to be.\n+                // Only check single backtick inline code for now.\n+                if !element.prev_code_guess.is_confident()\n+                    && dox.as_bytes().get(event_range.start) == Some(&b'`')\n+                    && dox.as_bytes().get(event_range.start + 1) != Some(&b'`')\n+                {\n+                    let range_inside = event_range.start + 1..event_range.end - 1;\n+                    let text_inside = &dox[range_inside.clone()];\n+\n+                    let is_confident = text_inside.starts_with(char::is_whitespace)\n+                        || text_inside.ends_with(char::is_whitespace);\n+\n+                    if let Some(guess) = guess_end_of_code(&dox, range_inside) {\n+                        // Find earlier end of code.\n+                        element.prev_code_guess = PrevCodeGuess::End { guess, is_confident };\n+                    } else {\n+                        // Find alternate start of code.\n+                        let range_before = element.element_range.start..event_range.start;\n+                        if let Some(guess) = guess_start_of_code(&dox, range_before) {\n+                            element.prev_code_guess = PrevCodeGuess::Start { guess, is_confident };\n+                        }\n+                    }\n+                }\n+            }\n+            Event::Text(text) => {\n+                let element = element_stack\n+                    .last_mut()\n+                    .expect(\"expected inline text node to be inside of an element\");\n+                assert!(\n+                    event_range.start >= element.element_range.start\n+                        && event_range.end <= element.element_range.end\n+                );\n+\n+                // The first char is escaped if the prev char is \\ and not part of a text node.\n+                let is_escaped = prev_text_end < event_range.start\n+                    && dox.as_bytes()[event_range.start - 1] == b'\\\\';\n+\n+                // Don't lint backslash-escaped (\\`) or html-escaped (&#96;) backticks.\n+                if *text == *\"`\" && !is_escaped && *text == dox[event_range.clone()] {\n+                    // We found a stray backtick.\n+                    assert!(\n+                        element.backtick_index.is_none(),\n+                        \"expected at most one unescaped backtick per element\",\n+                    );\n+                    element.backtick_index = Some(event_range.start);\n+                }\n+\n+                prev_text_end = event_range.end;\n+\n+                if is_escaped {\n+                    // Ensure that we suggest \"`\\x\" and not \"\\`x\".\n+                    element.suggestible_ranges.push(event_range.start - 1..event_range.end);\n+                } else {\n+                    element.suggestible_ranges.push(event_range);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+/// A previous inline code node, that looks wrong.\n+///\n+/// `guess` is the position, where we want to suggest a \\` and the guess `is_confident` if an\n+/// inline code starts or ends with a whitespace.\n+#[derive(Debug)]\n+enum PrevCodeGuess {\n+    None,\n+\n+    /// Missing \\` at start.\n+    ///\n+    /// ```markdown\n+    /// foo` `bar`\n+    /// ```\n+    Start {\n+        guess: usize,\n+        is_confident: bool,\n+    },\n+\n+    /// Missing \\` at end.\n+    ///\n+    /// ```markdown\n+    /// `foo `bar`\n+    /// ```\n+    End {\n+        guess: usize,\n+        is_confident: bool,\n+    },\n+}\n+\n+impl PrevCodeGuess {\n+    fn is_confident(&self) -> bool {\n+        match *self {\n+            PrevCodeGuess::None => false,\n+            PrevCodeGuess::Start { is_confident, .. } | PrevCodeGuess::End { is_confident, .. } => {\n+                is_confident\n+            }\n+        }\n+    }\n+}\n+\n+/// A markdown [tagged element], which may or may not contain an unescaped backtick.\n+///\n+/// [tagged element]: https://docs.rs/pulldown-cmark/0.9/pulldown_cmark/enum.Tag.html\n+#[derive(Debug)]\n+struct Element {\n+    /// The full range (span) of the element in the doc string.\n+    element_range: Range<usize>,\n+\n+    /// The ranges where we're allowed to put backticks.\n+    /// This is used to prevent breaking markdown elements like links or lists.\n+    suggestible_ranges: Vec<Range<usize>>,\n+\n+    /// The unescaped backtick.\n+    backtick_index: Option<usize>,\n+\n+    /// Suggest a different start or end of an inline code.\n+    prev_code_guess: PrevCodeGuess,\n+}\n+\n+impl Element {\n+    const fn new(element_range: Range<usize>) -> Self {\n+        Self {\n+            element_range,\n+            suggestible_ranges: Vec::new(),\n+            backtick_index: None,\n+            prev_code_guess: PrevCodeGuess::None,\n+        }\n+    }\n+}\n+\n+/// Given a potentially unclosed inline code, attempt to find the start.\n+fn guess_start_of_code(dox: &str, range: Range<usize>) -> Option<usize> {\n+    assert!(dox.as_bytes()[range.end] == b'`');\n+\n+    let mut braces = 0;\n+    let mut guess = 0;\n+    for (idx, ch) in dox[range.clone()].char_indices().rev() {\n+        match ch {\n+            ')' | ']' | '}' => braces += 1,\n+            '(' | '[' | '{' => {\n+                if braces == 0 {\n+                    guess = idx + 1;\n+                    break;\n+                }\n+                braces -= 1;\n+            }\n+            ch if ch.is_whitespace() && braces == 0 => {\n+                guess = idx + 1;\n+                break;\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    guess += range.start;\n+\n+    // Don't suggest empty inline code or duplicate backticks.\n+    can_suggest_backtick(dox, guess).then_some(guess)\n+}\n+\n+/// Given a potentially unclosed inline code, attempt to find the end.\n+fn guess_end_of_code(dox: &str, range: Range<usize>) -> Option<usize> {\n+    // Punctuation that should be outside of the inline code.\n+    const TRAILING_PUNCTUATION: &[u8] = b\".,\";\n+\n+    assert!(dox.as_bytes()[range.start - 1] == b'`');\n+\n+    let text = dox[range.clone()].trim_end();\n+    let mut braces = 0;\n+    let mut guess = text.len();\n+    for (idx, ch) in text.char_indices() {\n+        match ch {\n+            '(' | '[' | '{' => braces += 1,\n+            ')' | ']' | '}' => {\n+                if braces == 0 {\n+                    guess = idx;\n+                    break;\n+                }\n+                braces -= 1;\n+            }\n+            ch if ch.is_whitespace() && braces == 0 => {\n+                guess = idx;\n+                break;\n+            }\n+            _ => (),\n+        }\n+    }\n+\n+    // Strip a single trailing punctuation.\n+    if guess >= 1\n+        && TRAILING_PUNCTUATION.contains(&text.as_bytes()[guess - 1])\n+        && (guess < 2 || !TRAILING_PUNCTUATION.contains(&text.as_bytes()[guess - 2]))\n+    {\n+        guess -= 1;\n+    }\n+\n+    guess += range.start;\n+\n+    // Don't suggest empty inline code or duplicate backticks.\n+    can_suggest_backtick(dox, guess).then_some(guess)\n+}\n+\n+/// Returns whether inserting a backtick at `dox[index]` will not produce double backticks.\n+fn can_suggest_backtick(dox: &str, index: usize) -> bool {\n+    (index == 0 || dox.as_bytes()[index - 1] != b'`')\n+        && (index == dox.len() || dox.as_bytes()[index] != b'`')\n+}\n+\n+/// Increase the index until it is inside or one past the end of one of the ranges.\n+///\n+/// The ranges must be sorted for this to work correctly.\n+fn clamp_start(index: usize, ranges: &[Range<usize>]) -> Option<usize> {\n+    for range in ranges {\n+        if range.start >= index {\n+            return Some(range.start);\n+        }\n+        if index <= range.end {\n+            return Some(index);\n+        }\n+    }\n+    None\n+}\n+\n+/// Decrease the index until it is inside or one past the end of one of the ranges.\n+///\n+/// The ranges must be sorted for this to work correctly.\n+fn clamp_end(index: usize, ranges: &[Range<usize>]) -> Option<usize> {\n+    for range in ranges.iter().rev() {\n+        if range.end <= index {\n+            return Some(range.end);\n+        }\n+        if index >= range.start {\n+            return Some(index);\n+        }\n+    }\n+    None\n+}\n+\n+/// Try to emit a span suggestion and fall back to help messages if we can't find a suitable span.\n+///\n+/// This helps finding backticks in huge macro-generated docs.\n+fn suggest_insertion(\n+    cx: &DocContext<'_>,\n+    item: &Item,\n+    dox: &str,\n+    lint: &mut DiagnosticBuilder<'_, ()>,\n+    insert_index: usize,\n+    suggestion: char,\n+    message: &str,\n+) {\n+    /// Maximum bytes of context to show around the insertion.\n+    const CONTEXT_MAX_LEN: usize = 80;\n+\n+    if let Some(span) =\n+        source_span_for_markdown_range(cx.tcx, &dox, &(insert_index..insert_index), &item.attrs)\n+    {\n+        lint.span_suggestion(span, message, suggestion, Applicability::MaybeIncorrect);\n+    } else {\n+        let line_start = dox[..insert_index].rfind('\\n').map_or(0, |idx| idx + 1);\n+        let line_end = dox[insert_index..].find('\\n').map_or(dox.len(), |idx| idx + insert_index);\n+\n+        let context_before_max_len = if insert_index - line_start < CONTEXT_MAX_LEN / 2 {\n+            insert_index - line_start\n+        } else if line_end - insert_index < CONTEXT_MAX_LEN / 2 {\n+            CONTEXT_MAX_LEN - (line_end - insert_index)\n+        } else {\n+            CONTEXT_MAX_LEN / 2\n+        };\n+        let context_after_max_len = CONTEXT_MAX_LEN - context_before_max_len;\n+\n+        let (prefix, context_start) = if insert_index - line_start <= context_before_max_len {\n+            (\"\", line_start)\n+        } else {\n+            (\"...\", dox.ceil_char_boundary(insert_index - context_before_max_len))\n+        };\n+        let (suffix, context_end) = if line_end - insert_index <= context_after_max_len {\n+            (\"\", line_end)\n+        } else {\n+            (\"...\", dox.floor_char_boundary(insert_index + context_after_max_len))\n+        };\n+\n+        let context_full = &dox[context_start..context_end].trim_end();\n+        let context_before = &dox[context_start..insert_index];\n+        let context_after = &dox[insert_index..context_end].trim_end();\n+        lint.help(format!(\n+            \"{message}\\n change: {prefix}{context_full}{suffix}\\nto this: {prefix}{context_before}{suggestion}{context_after}{suffix}\"\n+        ));\n+    }\n+}"}, {"sha": "8cc935e54d117c76beac2cb680b7e119d50c257a", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -90,6 +90,9 @@ pub struct TestProps {\n     pub unset_rustc_env: Vec<String>,\n     // Environment settings to use during execution\n     pub exec_env: Vec<(String, String)>,\n+    // Environment variables to unset prior to execution.\n+    // Variables are unset before applying 'exec_env'\n+    pub unset_exec_env: Vec<String>,\n     // Build documentation for all specified aux-builds as well\n     pub build_aux_docs: bool,\n     // Flag to force a crate to be built with the host architecture\n@@ -198,6 +201,7 @@ mod directives {\n     pub const AUX_CRATE: &'static str = \"aux-crate\";\n     pub const EXEC_ENV: &'static str = \"exec-env\";\n     pub const RUSTC_ENV: &'static str = \"rustc-env\";\n+    pub const UNSET_EXEC_ENV: &'static str = \"unset-exec-env\";\n     pub const UNSET_RUSTC_ENV: &'static str = \"unset-rustc-env\";\n     pub const FORBID_OUTPUT: &'static str = \"forbid-output\";\n     pub const CHECK_TEST_LINE_NUMBERS_MATCH: &'static str = \"check-test-line-numbers-match\";\n@@ -231,6 +235,7 @@ impl TestProps {\n             rustc_env: vec![],\n             unset_rustc_env: vec![],\n             exec_env: vec![],\n+            unset_exec_env: vec![],\n             build_aux_docs: false,\n             force_host: false,\n             check_stdout: false,\n@@ -382,6 +387,12 @@ impl TestProps {\n                     &mut self.exec_env,\n                     Config::parse_env,\n                 );\n+                config.push_name_value_directive(\n+                    ln,\n+                    UNSET_EXEC_ENV,\n+                    &mut self.unset_exec_env,\n+                    |r| r,\n+                );\n                 config.push_name_value_directive(\n                     ln,\n                     RUSTC_ENV,"}, {"sha": "86a749b935d828a7eef35fd425be65d08fb070c9", "filename": "src/tools/compiletest/src/header/cfg.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fcfg.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -165,11 +165,15 @@ pub(super) fn parse_cfg_name_directive<'a>(\n         message: \"when the architecture is part of the Thumb family\"\n     }\n \n+    // Technically the locally built compiler uses the \"dev\" channel rather than the \"nightly\"\n+    // channel, even though most people don't know or won't care about it. To avoid confusion, we\n+    // treat the \"dev\" channel as the \"nightly\" channel when processing the directive.\n     condition! {\n-        name: &config.channel,\n+        name: if config.channel == \"dev\" { \"nightly\" } else { &config.channel },\n         allowed_names: &[\"stable\", \"beta\", \"nightly\"],\n         message: \"when the release channel is {name}\",\n     }\n+\n     condition! {\n         name: \"cross-compile\",\n         condition: config.target != config.host,"}, {"sha": "0fd9f3ae3f4069b8ba6fcd68262362649d30badd", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -1614,8 +1614,13 @@ impl<'test> TestCx<'test> {\n                 test_client\n                     .args(&[\"run\", &support_libs.len().to_string(), &prog])\n                     .args(support_libs)\n-                    .args(args)\n-                    .envs(env.clone());\n+                    .args(args);\n+\n+                for key in &self.props.unset_exec_env {\n+                    test_client.env_remove(key);\n+                }\n+                test_client.envs(env.clone());\n+\n                 self.compose_and_run(\n                     test_client,\n                     self.config.run_lib_path.to_str().unwrap(),\n@@ -1627,7 +1632,13 @@ impl<'test> TestCx<'test> {\n                 let aux_dir = self.aux_output_dir_name();\n                 let ProcArgs { prog, args } = self.make_run_args();\n                 let mut wr_run = Command::new(\"wr-run\");\n-                wr_run.args(&[&prog]).args(args).envs(env.clone());\n+                wr_run.args(&[&prog]).args(args);\n+\n+                for key in &self.props.unset_exec_env {\n+                    wr_run.env_remove(key);\n+                }\n+                wr_run.envs(env.clone());\n+\n                 self.compose_and_run(\n                     wr_run,\n                     self.config.run_lib_path.to_str().unwrap(),\n@@ -1639,7 +1650,13 @@ impl<'test> TestCx<'test> {\n                 let aux_dir = self.aux_output_dir_name();\n                 let ProcArgs { prog, args } = self.make_run_args();\n                 let mut program = Command::new(&prog);\n-                program.args(args).current_dir(&self.output_base_dir()).envs(env.clone());\n+                program.args(args).current_dir(&self.output_base_dir());\n+\n+                for key in &self.props.unset_exec_env {\n+                    program.env_remove(key);\n+                }\n+                program.envs(env.clone());\n+\n                 self.compose_and_run(\n                     program,\n                     self.config.run_lib_path.to_str().unwrap(),"}, {"sha": "f1ad7c8d4c7841f12177fe968f3802f834f429e5", "filename": "tests/rustdoc-ui/unescaped_backticks.rs", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc-ui%2Funescaped_backticks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc-ui%2Funescaped_backticks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Funescaped_backticks.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -0,0 +1,342 @@\n+#![deny(rustdoc::unescaped_backticks)]\n+#![allow(rustdoc::broken_intra_doc_links)]\n+#![allow(rustdoc::invalid_html_tags)]\n+\n+///\n+pub fn empty() {}\n+\n+#[doc = \"\"]\n+pub fn empty2() {}\n+\n+/// `\n+//~^ ERROR unescaped backtick\n+pub fn single() {}\n+\n+/// \\`\n+pub fn escaped() {}\n+\n+/// \\\\`\n+//~^ ERROR unescaped backtick\n+pub fn not_escaped() {}\n+\n+/// \\\\\\`\n+pub fn not_not_escaped() {}\n+\n+/// [`link1]\n+//~^ ERROR unescaped backtick\n+pub fn link1() {}\n+\n+/// [link2`]\n+//~^ ERROR unescaped backtick\n+pub fn link2() {}\n+\n+/// [`link_long](link_long)\n+//~^ ERROR unescaped backtick\n+pub fn link_long() {}\n+\n+/// [`broken-link]\n+//~^ ERROR unescaped backtick\n+pub fn broken_link() {}\n+\n+/// <xx:`>\n+pub fn url() {}\n+\n+/// <x:`>\n+//~^ ERROR unescaped backtick\n+pub fn not_url() {}\n+\n+/// <h1>`</h1>\n+pub fn html_tag() {}\n+\n+/// &#96;\n+pub fn html_escape() {}\n+\n+/// \ud83e\udd80`\ud83e\udd80\n+//~^ ERROR unescaped backtick\n+pub fn unicode() {}\n+\n+/// `foo(\n+//~^ ERROR unescaped backtick\n+///\n+/// paragraph\n+pub fn paragraph() {}\n+\n+/// `foo `bar`\n+//~^ ERROR unescaped backtick\n+///\n+/// paragraph\n+pub fn paragraph2() {}\n+\n+/// `foo(\n+//~^ ERROR unescaped backtick\n+/// not paragraph\n+pub fn not_paragraph() {}\n+\n+/// Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\n+//~^ ERROR unescaped backtick\n+///\n+/// You could use this function to add 42 to a number `n` (add(n, 42)`),\n+/// or even to add a number `n` to 42 (`add(42, b)`)!\n+//~^ ERROR unescaped backtick\n+pub fn add1(a: i32, b: i32) -> i32 { a + b }\n+\n+/// Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\n+//~^ ERROR unescaped backtick\n+///\n+/// You could use this function to add 42 to a number `n` (`add(n, 42)),\n+/// or even to add a number `n` to 42 (`add(42, n)`)!\n+//~^ ERROR unescaped backtick\n+pub fn add2(a: i32, b: i32) -> i32 { a + b }\n+\n+/// Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\n+//~^ ERROR unescaped backtick\n+///\n+/// You could use this function to add 42 to a number `n` (`add(n, 42)`),\n+/// or even to add a number `n` to 42 (add(42, n)`)!\n+//~^ ERROR unescaped backtick\n+pub fn add3(a: i32, b: i32) -> i32 { a + b }\n+\n+/// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\n+//~^ ERROR unescaped backtick\n+///\n+/// You could use this function to add 42 to a number `n` (`add(n, 42)),\n+/// or even to add a number `n` to 42 (`add(42, n)`)!\n+//~^ ERROR unescaped backtick\n+pub fn add4(a: i32, b: i32) -> i32 { a + b }\n+\n+#[doc = \"`\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr() {}\n+\n+#[doc = concat!(\"\\\\\", \"`\")]\n+pub fn attr_escaped() {}\n+\n+#[doc = concat!(\"\\\\\\\\\", \"`\")]\n+//~^ ERROR unescaped backtick\n+pub fn attr_not_escaped() {}\n+\n+#[doc = \"Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr_add1(a: i32, b: i32) -> i32 { a + b }\n+\n+#[doc = \"Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr_add2(a: i32, b: i32) -> i32 { a + b }\n+\n+#[doc = \"Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr_add3(a: i32, b: i32) -> i32 { a + b }\n+\n+#[doc = \"Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\"]\n+//~^ ERROR unescaped backtick\n+pub fn attr_add4(a: i32, b: i32) -> i32 { a + b }\n+\n+/// ``double backticks``\n+/// `foo\n+//~^ ERROR unescaped backtick\n+pub fn double_backticks() {}\n+\n+/// # `(heading\n+//~^ ERROR unescaped backtick\n+/// ## heading2)`\n+//~^ ERROR unescaped backtick\n+///\n+/// multi `(\n+//~^ ERROR unescaped backtick\n+/// line\n+/// ) heading\n+/// =\n+///\n+/// para)`(graph\n+//~^ ERROR unescaped backtick\n+///\n+/// para)`(graph2\n+//~^ ERROR unescaped backtick\n+///\n+/// 1. foo)`\n+//~^ ERROR unescaped backtick\n+/// 2. `(bar\n+//~^ ERROR unescaped backtick\n+/// * baz)`\n+//~^ ERROR unescaped backtick\n+/// * `(quux\n+//~^ ERROR unescaped backtick\n+///\n+/// `#![this_is_actually_an_image(and(not), an = \"attribute\")]\n+//~^ ERROR unescaped backtick\n+///\n+/// #![this_is_actually_an_image(and(not), an = \"attribute\")]`\n+//~^ ERROR unescaped backtick\n+///\n+/// [this_is_actually_an_image(and(not), an = \"attribute\")]: `.png\n+///\n+/// | `table( | )head` |\n+//~^ ERROR unescaped backtick\n+//~| ERROR unescaped backtick\n+/// |---------|--------|\n+/// | table`( | )`body |\n+//~^ ERROR unescaped backtick\n+//~| ERROR unescaped backtick\n+pub fn complicated_markdown() {}\n+\n+/// The `custom_mir` attribute tells the compiler to treat the function as being custom MIR. This\n+/// attribute only works on functions - there is no way to insert custom MIR into the middle of\n+/// another function. The `dialect` and `phase` parameters indicate which [version of MIR][dialect\n+/// docs] you are inserting here. Generally you'll want to use `#![custom_mir(dialect = \"built\")]`\n+/// if you want your MIR to be modified by the full MIR pipeline, or `#![custom_mir(dialect =\n+//~^ ERROR unescaped backtick\n+/// \"runtime\", phase = \"optimized\")] if you don't.\n+pub mod mir {}\n+\n+pub mod rustc {\n+    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n+    //~^ ERROR unescaped backtick\n+    /// ensure it gets used.\n+    pub fn ty_error_with_message() {}\n+\n+    pub struct WhereClause {\n+        /// `true` if we ate a `where` token: this can happen\n+        /// if we parsed no predicates (e.g. `struct Foo where {}\n+        /// This allows us to accurately pretty-print\n+        /// in `nt_to_tokenstream`\n+        //~^ ERROR unescaped backtick\n+        pub has_where_token: bool,\n+    }\n+\n+    /// A symbol is an interned or gensymed string. The use of `newtype_index!` means\n+    /// that `Option<Symbol>` only takes up 4 bytes, because `newtype_index! reserves\n+    //~^ ERROR unescaped backtick\n+    /// the last 256 values for tagging purposes.\n+    pub struct Symbol();\n+\n+    /// It is equivalent to `OpenOptions::new()` but allows you to write more\n+    /// readable code. Instead of `OpenOptions::new().read(true).open(\"foo.txt\")`\n+    /// you can write `File::with_options().read(true).open(\"foo.txt\"). This\n+    /// also avoids the need to import `OpenOptions`.\n+    //~^ ERROR unescaped backtick\n+    pub fn with_options() {}\n+\n+    /// Subtracts `set from `row`. `set` can be either `BitSet` or\n+    /// `HybridBitSet`. Has no effect if `row` does not exist.\n+    //~^ ERROR unescaped backtick\n+    ///\n+    /// Returns true if the row was changed.\n+    pub fn subtract_row() {}\n+\n+    pub mod assert_module_sources {\n+        //! The reason that we use `cfg=...` and not `#[cfg_attr]` is so that\n+        //! the HIR doesn't change as a result of the annotations, which might\n+        //! perturb the reuse results.\n+        //!\n+        //! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]\n+        //~^ ERROR unescaped backtick\n+        //! allows for doing a more fine-grained check to see if pre- or post-lto data\n+        //! was re-used.\n+\n+        /// `cfg=...\n+        //~^ ERROR unescaped backtick\n+        pub fn foo() {}\n+\n+        /// `cfg=... and not `#[cfg_attr]`\n+        //~^ ERROR unescaped backtick\n+        pub fn bar() {}\n+    }\n+\n+    /// Conceptually, this is like a `Vec<Vec<RWU>>`. But the number of\n+    /// RWU`s can get very large, so it uses a more compact representation.\n+    //~^ ERROR unescaped backtick\n+    pub struct RWUTable {}\n+\n+    /// Like [Self::canonicalize_query], but preserves distinct universes. For\n+    /// example, canonicalizing `&'?0: Trait<'?1>`, where `'?0` is in `U1` and\n+    /// `'?1` is in `U3` would be canonicalized to have ?0` in `U1` and `'?1`\n+    /// in `U2`.\n+    //~^ ERROR unescaped backtick\n+    ///\n+    /// This is used for Chalk integration.\n+    pub fn canonicalize_query_preserving_universes() {}\n+\n+    /// Note that we used to return `Error` here, but that was quite\n+    /// dubious -- the premise was that an error would *eventually* be\n+    /// reported, when the obligation was processed. But in general once\n+    /// you see an `Error` you are supposed to be able to assume that an\n+    /// error *has been* reported, so that you can take whatever heuristic\n+    /// paths you want to take. To make things worse, it was possible for\n+    /// cycles to arise, where you basically had a setup like `<MyType<$0>\n+    /// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n+    /// Trait>::Foo> to `[type error]` would lead to an obligation of\n+    /// `<MyType<[type error]> as Trait>::Foo`. We are supposed to report\n+    /// an error for this obligation, but we legitimately should not,\n+    /// because it contains `[type error]`. Yuck! (See issue #29857 for\n+    //~^ ERROR unescaped backtick\n+    /// one case where this arose.)\n+    pub fn normalize_to_error() {}\n+\n+    /// you don't want to cache that `B: AutoTrait` or `A: AutoTrait`\n+    /// is `EvaluatedToOk`; this is because they were only considered\n+    /// ok on the premise that if `A: AutoTrait` held, but we indeed\n+    /// encountered a problem (later on) with `A: AutoTrait. So we\n+    /// currently set a flag on the stack node for `B: AutoTrait` (as\n+    /// well as the second instance of `A: AutoTrait`) to suppress\n+    //~^ ERROR unescaped backtick\n+    /// caching.\n+    pub struct TraitObligationStack;\n+\n+    /// Extend `scc` so that it can outlive some placeholder region\n+    /// from a universe it can't name; at present, the only way for\n+    /// this to be true is if `scc` outlives `'static`. This is\n+    /// actually stricter than necessary: ideally, we'd support bounds\n+    /// like `for<'a: 'b`>` that might then allow us to approximate\n+    /// `'a` with `'b` and not `'static`. But it will have to do for\n+    //~^ ERROR unescaped backtick\n+    /// now.\n+    pub fn add_incompatible_universe(){}\n+}\n+\n+/// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+/// which returns an `Option<Dispatch>`. If all [`Dispatch`] clones that point\n+/// at the `Subscriber` have been dropped, [`WeakDispatch::upgrade`] will return\n+/// `None`. Otherwise, it will return `Some(Dispatch)`.\n+//~^ ERROR unescaped backtick\n+///\n+/// Returns some reference to this `[`Subscriber`] value if it is of type `T`,\n+/// or `None` if it isn't.\n+//~^ ERROR unescaped backtick\n+///\n+/// Called before the filtered [`Layer]'s [`on_event`], to determine if\n+/// `on_event` should be called.\n+//~^ ERROR unescaped backtick\n+///\n+/// Therefore, if the `Filter will change the value returned by this\n+/// method, it is responsible for ensuring that\n+/// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+//~^ ERROR unescaped backtick\n+/// level changes.\n+pub mod tracing {}\n+\n+macro_rules! id {\n+    ($($tt:tt)*) => { $($tt)* }\n+}\n+\n+id! {\n+    /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+    //~^ ERROR unescaped backtick\n+    //~| ERROR unescaped backtick\n+    //~| ERROR unescaped backtick\n+    //~| ERROR unescaped backtick\n+    /// which returns an `Option<Dispatch>`. If all [`Dispatch`] clones that point\n+    /// at the `Subscriber` have been dropped, [`WeakDispatch::upgrade`] will return\n+    /// `None`. Otherwise, it will return `Some(Dispatch)`.\n+    ///\n+    /// Returns some reference to this `[`Subscriber`] value if it is of type `T`,\n+    /// or `None` if it isn't.\n+    ///\n+    /// Called before the filtered [`Layer]'s [`on_event`], to determine if\n+    /// `on_event` should be called.\n+    ///\n+    /// Therefore, if the `Filter will change the value returned by this\n+    /// method, it is responsible for ensuring that\n+    /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+    /// level changes.\n+    pub mod tracing_macro {}\n+}"}, {"sha": "e629dbc34e9b44e42d36e3132544ff9343cb725b", "filename": "tests/rustdoc-ui/unescaped_backticks.stderr", "status": "added", "additions": 959, "deletions": 0, "changes": 959, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc-ui%2Funescaped_backticks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc-ui%2Funescaped_backticks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Funescaped_backticks.stderr?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -0,0 +1,959 @@\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:186:70\n+   |\n+LL | /// if you want your MIR to be modified by the full MIR pipeline, or `#![custom_mir(dialect =\n+   |                                                                      ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unescaped_backticks.rs:1:9\n+   |\n+LL | #![deny(rustdoc::unescaped_backticks)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// \"runtime\", phase = \"optimized\")]` if you don't.\n+   |                                     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// if you want your MIR to be modified by the full MIR pipeline, or \\`#![custom_mir(dialect =\n+   |                                                                      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:231:13\n+   |\n+LL |         //! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]\n+   |             ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL |         //! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]`\n+   |                                                                                         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |         //! \\`#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]\n+   |             +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:236:13\n+   |\n+LL |         /// `cfg=...\n+   |             ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL |         /// `cfg=...`\n+   |                     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |         /// \\`cfg=...\n+   |             +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:240:42\n+   |\n+LL |         /// `cfg=... and not `#[cfg_attr]`\n+   |                                          ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |         /// `cfg=...` and not `#[cfg_attr]`\n+   |                     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |         /// `cfg=... and not `#[cfg_attr]\\`\n+   |                                          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:192:91\n+   |\n+LL |     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n+   |                                                                                           ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL |     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg` to\n+   |                                                                                               +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given \\`msg to\n+   |                                                                                           +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:201:34\n+   |\n+LL |         /// in `nt_to_tokenstream`\n+   |                                  ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |         /// if we parsed no predicates (e.g. `struct` Foo where {}\n+   |                                                     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |         /// in `nt_to_tokenstream\\`\n+   |                                  +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:207:62\n+   |\n+LL |     /// that `Option<Symbol>` only takes up 4 bytes, because `newtype_index! reserves\n+   |                                                              ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL |     /// that `Option<Symbol>` only takes up 4 bytes, because `newtype_index!` reserves\n+   |                                                                             +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// that `Option<Symbol>` only takes up 4 bytes, because \\`newtype_index! reserves\n+   |                                                              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:215:52\n+   |\n+LL |     /// also avoids the need to import `OpenOptions`.\n+   |                                                    ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |     /// you can write `File::with_options().read(true).open(\"foo.txt\")`. This\n+   |                                                                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// also avoids the need to import `OpenOptions\\`.\n+   |                                                    +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:220:46\n+   |\n+LL |     /// `HybridBitSet`. Has no effect if `row` does not exist.\n+   |                                              ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |     /// Subtracts `set` from `row`. `set` can be either `BitSet` or\n+   |                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// `HybridBitSet`. Has no effect if `row\\` does not exist.\n+   |                                              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:246:12\n+   |\n+LL |     /// RWU`s can get very large, so it uses a more compact representation.\n+   |            ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL |     /// `RWU`s can get very large, so it uses a more compact representation.\n+   |         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// RWU\\`s can get very large, so it uses a more compact representation.\n+   |            +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:253:15\n+   |\n+LL |     /// in `U2`.\n+   |               ^\n+   |\n+help: the opening backtick of a previous inline code may be missing\n+   |\n+LL |     /// `'?1` is in `U3` would be canonicalized to have `?0` in `U1` and `'?1`\n+   |                                                         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// in `U2\\`.\n+   |               +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:270:42\n+   |\n+LL |     /// because it contains `[type error]`. Yuck! (See issue #29857 for\n+   |                                          ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |     /// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0>` as\n+   |                                                              +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// because it contains `[type error]\\`. Yuck! (See issue #29857 for\n+   |                                          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:280:53\n+   |\n+LL |     /// well as the second instance of `A: AutoTrait`) to suppress\n+   |                                                     ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL |     /// encountered a problem (later on) with `A:` AutoTrait. So we\n+   |                                                  +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// well as the second instance of `A: AutoTrait\\`) to suppress\n+   |                                                     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:290:40\n+   |\n+LL |     /// `'a` with `'b` and not `'static`. But it will have to do for\n+   |                                        ^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL |     /// `'a` with `'b` and not `'static\\`. But it will have to do for\n+   |                                        +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:299:54\n+   |\n+LL | /// `None`. Otherwise, it will return `Some(Dispatch)`.\n+   |                                                      ^\n+   |\n+help: the opening backtick of a previous inline code may be missing\n+   |\n+LL | /// The `Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+   |         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// `None`. Otherwise, it will return `Some(Dispatch)\\`.\n+   |                                                      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:303:13\n+   |\n+LL | /// or `None` if it isn't.\n+   |             ^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or `None\\` if it isn't.\n+   |             +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:307:14\n+   |\n+LL | /// `on_event` should be called.\n+   |              ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// Called before the filtered [`Layer`]'s [`on_event`], to determine if\n+   |                                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// `on_event\\` should be called.\n+   |              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:312:29\n+   |\n+LL | /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+   |                             ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// Therefore, if the `Filter` will change the value returned by this\n+   |                              +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [`rebuild_interest_cache\\`][rebuild] is called after the value of the max\n+   |                             +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:322:5\n+   |\n+LL | /     /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+LL | |     /// level changes.\n+   | |______________________^\n+   |\n+   = help: the opening backtick of a previous inline code may be missing\n+            change: The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+           to this: The `Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+   = help: if you meant to use a literal backtick, escape it\n+            change: `None`. Otherwise, it will return `Some(Dispatch)`.\n+           to this: `None`. Otherwise, it will return `Some(Dispatch)\\`.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:322:5\n+   |\n+LL | /     /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+LL | |     /// level changes.\n+   | |______________________^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+   = help: if you meant to use a literal backtick, escape it\n+            change: or `None` if it isn't.\n+           to this: or `None\\` if it isn't.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:322:5\n+   |\n+LL | /     /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+LL | |     /// level changes.\n+   | |______________________^\n+   |\n+   = help: a previous inline code might be longer than expected\n+            change: Called before the filtered [`Layer]'s [`on_event`], to determine if\n+           to this: Called before the filtered [`Layer`]'s [`on_event`], to determine if\n+   = help: if you meant to use a literal backtick, escape it\n+            change: `on_event` should be called.\n+           to this: `on_event\\` should be called.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:322:5\n+   |\n+LL | /     /// The Subscriber` may be accessed by calling [`WeakDispatch::upgrade`],\n+LL | |\n+LL | |\n+LL | |\n+...  |\n+LL | |     /// [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+LL | |     /// level changes.\n+   | |______________________^\n+   |\n+   = help: a previous inline code might be longer than expected\n+            change: Therefore, if the `Filter will change the value returned by this\n+           to this: Therefore, if the `Filter` will change the value returned by this\n+   = help: if you meant to use a literal backtick, escape it\n+            change: [`rebuild_interest_cache`][rebuild] is called after the value of the max\n+           to this: [`rebuild_interest_cache\\`][rebuild] is called after the value of the max\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:11:5\n+   |\n+LL | /// `\n+   |     ^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:18:7\n+   |\n+LL | /// \\`\n+   |       ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `\\`\n+   |     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\\\`\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:25:6\n+   |\n+LL | /// [`link1]\n+   |      ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// [`link1`]\n+   |            +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [\\`link1]\n+   |      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:29:11\n+   |\n+LL | /// [link2`]\n+   |           ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// [`link2`]\n+   |      +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [link2\\`]\n+   |           +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:33:6\n+   |\n+LL | /// [`link_long](link_long)\n+   |      ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// [`link_long`](link_long)\n+   |                +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [\\`link_long](link_long)\n+   |      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:37:6\n+   |\n+LL | /// [`broken-link]\n+   |      ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// [`broken-link`]\n+   |                  +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// [\\`broken-link]\n+   |      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:44:8\n+   |\n+LL | /// <x:`>\n+   |        ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `<x:`>\n+   |     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// <x:\\`>\n+   |        +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:54:6\n+   |\n+LL | /// \ud83e\udd80`\ud83e\udd80\n+   |       ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `\ud83e\udd80`\ud83e\udd80\n+   |     +\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// \ud83e\udd80`\ud83e\udd80`\n+   |          +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \ud83e\udd80\\`\ud83e\udd80\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:58:5\n+   |\n+LL | /// `foo(\n+   |     ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// `foo(`\n+   |          +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`foo(\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:64:14\n+   |\n+LL | /// `foo `bar`\n+   |              ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// `foo` `bar`\n+   |         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// `foo `bar\\`\n+   |              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:70:5\n+   |\n+LL | /// `foo(\n+   |     ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// not paragraph`\n+   |                  +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`foo(\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:75:83\n+   |\n+LL | /// Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\n+   |                                                                                   ^\n+   |\n+help: the opening backtick of a previous inline code may be missing\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   |                                               +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// Addition is commutative, which means that add(a, b)` is the same as `add(b, a)\\`.\n+   |                                                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:79:51\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, b)`)!\n+   |                                                   ^\n+   |\n+help: the opening backtick of a previous inline code may be missing\n+   |\n+LL | /// You could use this function to add 42 to a number `n` (`add(n, 42)`),\n+   |                                                            +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, b)\\`)!\n+   |                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:83:83\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\n+   |                                                                                   ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   |                                                         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b) is the same as `add(b, a)\\`.\n+   |                                                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:87:51\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)`)!\n+   |                                                   ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// You could use this function to add 42 to a number `n` (`add(n, 42)`),\n+   |                                                                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)\\`)!\n+   |                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:91:83\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\n+   |                                                                                   ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   |                                                                          +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as add(b, a)\\`.\n+   |                                                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:95:50\n+   |\n+LL | /// or even to add a number `n` to 42 (add(42, n)`)!\n+   |                                                  ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)`)!\n+   |                                        +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or even to add a number `n` to 42 (add(42, n)\\`)!\n+   |                                                  +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:99:74\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\n+   |                                                                          ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   |                                                                                    +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// Addition is commutative, which means that `add(a, b)` is the same as \\`add(b, a).\n+   |                                                                          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:103:51\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)`)!\n+   |                                                   ^\n+   |\n+help: a previous inline code might be longer than expected\n+   |\n+LL | /// You could use this function to add 42 to a number `n` (`add(n, 42)`),\n+   |                                                                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// or even to add a number `n` to 42 (`add(42, n)\\`)!\n+   |                                                   +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:107:1\n+   |\n+LL | #[doc = \"`\"]\n+   | ^^^^^^^^^^^^\n+   |\n+   = help: the opening or closing backtick of an inline code may be missing\n+   = help: if you meant to use a literal backtick, escape it\n+            change: `\n+           to this: \\`\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:114:1\n+   |\n+LL | #[doc = concat!(\"\\\\\", \"`\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the opening backtick of an inline code may be missing\n+            change: \\`\n+           to this: `\\`\n+   = help: if you meant to use a literal backtick, escape it\n+            change: \\`\n+           to this: \\\\`\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:118:1\n+   |\n+LL | #[doc = \"Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the opening backtick of a previous inline code may be missing\n+            change: Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   = help: if you meant to use a literal backtick, escape it\n+            change: Addition is commutative, which means that add(a, b)` is the same as `add(b, a)`.\n+           to this: Addition is commutative, which means that add(a, b)` is the same as `add(b, a)\\`.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:122:1\n+   |\n+LL | #[doc = \"Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: a previous inline code might be longer than expected\n+            change: Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   = help: if you meant to use a literal backtick, escape it\n+            change: Addition is commutative, which means that `add(a, b) is the same as `add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b) is the same as `add(b, a)\\`.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:126:1\n+   |\n+LL | #[doc = \"Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the opening backtick of an inline code may be missing\n+            change: Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   = help: if you meant to use a literal backtick, escape it\n+            change: Addition is commutative, which means that `add(a, b)` is the same as add(b, a)`.\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as add(b, a)\\`.\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:130:1\n+   |\n+LL | #[doc = \"Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: the closing backtick of an inline code may be missing\n+            change: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a)`.\n+   = help: if you meant to use a literal backtick, escape it\n+            change: Addition is commutative, which means that `add(a, b)` is the same as `add(b, a).\n+           to this: Addition is commutative, which means that `add(a, b)` is the same as \\`add(b, a).\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:135:5\n+   |\n+LL | /// `foo\n+   |     ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// `foo`\n+   |         +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`foo\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:139:7\n+   |\n+LL | /// # `(heading\n+   |       ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// # `(heading`\n+   |                +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// # \\`(heading\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:141:17\n+   |\n+LL | /// ## heading2)`\n+   |                 ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// ## `heading2)`\n+   |        +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// ## heading2)\\`\n+   |                 +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:144:11\n+   |\n+LL | /// multi `(\n+   |           ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// )` heading\n+   |      +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// multi \\`(\n+   |           +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:150:10\n+   |\n+LL | /// para)`(graph\n+   |          ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `para)`(graph\n+   |     +\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// para)`(graph`\n+   |                 +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// para)\\`(graph\n+   |          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:153:10\n+   |\n+LL | /// para)`(graph2\n+   |          ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `para)`(graph2\n+   |     +\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// para)`(graph2`\n+   |                  +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// para)\\`(graph2\n+   |          +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:156:12\n+   |\n+LL | /// 1. foo)`\n+   |            ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// 1. `foo)`\n+   |        +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// 1. foo)\\`\n+   |            +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:158:8\n+   |\n+LL | /// 2. `(bar\n+   |        ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// 2. `(bar`\n+   |             +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// 2. \\`(bar\n+   |        +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:160:11\n+   |\n+LL | /// * baz)`\n+   |           ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// * `baz)`\n+   |       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// * baz)\\`\n+   |           +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:162:7\n+   |\n+LL | /// * `(quux\n+   |       ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// * `(quux`\n+   |             +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// * \\`(quux\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:165:5\n+   |\n+LL | /// `#![this_is_actually_an_image(and(not), an = \"attribute\")]\n+   |     ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// `#`![this_is_actually_an_image(and(not), an = \"attribute\")]\n+   |       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// \\`#![this_is_actually_an_image(and(not), an = \"attribute\")]\n+   |     +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:168:62\n+   |\n+LL | /// #![this_is_actually_an_image(and(not), an = \"attribute\")]`\n+   |                                                              ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// `#![this_is_actually_an_image(and(not), an = \"attribute\")]`\n+   |     +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// #![this_is_actually_an_image(and(not), an = \"attribute\")]\\`\n+   |                                                              +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:173:7\n+   |\n+LL | /// | `table( | )head` |\n+   |       ^\n+   |\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// | `table(` | )head` |\n+   |              +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// | \\`table( | )head` |\n+   |       +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:173:22\n+   |\n+LL | /// | `table( | )head` |\n+   |                      ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// | `table( | `)head` |\n+   |                 +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// | `table( | )head\\` |\n+   |                      +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:177:12\n+   |\n+LL | /// | table`( | )`body |\n+   |            ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// | `table`( | )`body |\n+   |       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// | table\\`( | )`body |\n+   |            +\n+\n+error: unescaped backtick\n+  --> $DIR/unescaped_backticks.rs:177:18\n+   |\n+LL | /// | table`( | )`body |\n+   |                  ^\n+   |\n+help: the opening backtick of an inline code may be missing\n+   |\n+LL | /// | table`( | `)`body |\n+   |                 +\n+help: the closing backtick of an inline code may be missing\n+   |\n+LL | /// | table`( | )`body` |\n+   |                       +\n+help: if you meant to use a literal backtick, escape it\n+   |\n+LL | /// | table`( | )\\`body |\n+   |                  +\n+\n+error: aborting due to 63 previous errors\n+"}, {"sha": "8ecca6d12d24af01bd4c61fe58a422a97bd9e607", "filename": "tests/rustdoc/deref/deref-const-fn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fderef-const-fn.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/deref-const-fn.rs"}, {"sha": "fa3607c5fc12d711be9dfc24f7b7779a2150b3f1", "filename": "tests/rustdoc/deref/deref-multiple-impl-blocks.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-multiple-impl-blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-multiple-impl-blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fderef-multiple-impl-blocks.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -0,0 +1,43 @@\n+#![crate_name=\"foo\"]\n+\n+use std::ops::{Deref, DerefMut};\n+\n+// @has foo/struct.Vec.html\n+// @count - '//h2[@id=\"deref-methods-Slice\"]' 1\n+// @count - '//div[@id=\"deref-methods-Slice-1\"]' 1\n+// @count - '//div[@id=\"deref-methods-Slice-1\"][@class=\"impl-items\"]' 1\n+// @count - '//div[@id=\"deref-methods-Slice-1\"]/div[@class=\"impl-items\"]' 0\n+pub struct Vec;\n+\n+pub struct Slice;\n+\n+impl Deref for Vec {\n+    type Target = Slice;\n+    fn deref(&self) -> &Slice {\n+        &Slice\n+    }\n+}\n+\n+impl DerefMut for Vec {\n+    fn deref_mut(&mut self) -> &mut Slice {\n+        &mut Slice\n+    }\n+}\n+\n+impl Slice {\n+    pub fn sort_floats(&mut self) {\n+        todo!();\n+    }\n+}\n+\n+impl Slice {\n+    pub fn sort(&mut self) {\n+        todo!();\n+    }\n+}\n+\n+impl Slice {\n+    pub fn len(&self) {\n+        todo!();\n+    }\n+}"}, {"sha": "fdf8434224f839b0a00453f32ae77eb2b147b3bf", "filename": "tests/rustdoc/deref/deref-mut-methods.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-mut-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-mut-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fderef-mut-methods.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/deref-mut-methods.rs"}, {"sha": "be2b42b5ac611dbd99d3a493722dee694b86d1d4", "filename": "tests/rustdoc/deref/deref-recursive-pathbuf.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-recursive-pathbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-recursive-pathbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fderef-recursive-pathbuf.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/deref-recursive-pathbuf.rs"}, {"sha": "0436f2f86f594f056e7213eda790f6145b55ef42", "filename": "tests/rustdoc/deref/deref-recursive.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fderef-recursive.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/deref-recursive.rs"}, {"sha": "cccf273a820283afbcd848eb50b8bc7192bc8556", "filename": "tests/rustdoc/deref/deref-slice-core.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-slice-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-slice-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fderef-slice-core.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/deref-slice-core.rs"}, {"sha": "527de780d48923c5d2b3ba501ed5e2f8b4b20397", "filename": "tests/rustdoc/deref/deref-to-primitive.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-to-primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-to-primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fderef-to-primitive.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/deref-to-primitive.rs"}, {"sha": "32424d13eb85509c26e56e1c057a15a893030817", "filename": "tests/rustdoc/deref/deref-typedef.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-typedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fderef-typedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fderef-typedef.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/deref-typedef.rs"}, {"sha": "66919d73eeb63e286c4919d86d30f18157f1aa3e", "filename": "tests/rustdoc/deref/escape-deref-methods.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fescape-deref-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fescape-deref-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fescape-deref-methods.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/escape-deref-methods.rs"}, {"sha": "f09d23206093d7a36d43f6789ed479c8c74206e9", "filename": "tests/rustdoc/deref/issue-100679-sidebar-links-deref.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fissue-100679-sidebar-links-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Fissue-100679-sidebar-links-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Fissue-100679-sidebar-links-deref.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/issue-100679-sidebar-links-deref.rs"}, {"sha": "619f40eff8984fc6ee45fdf1f58fa233b23e60c2", "filename": "tests/rustdoc/deref/recursive-deref-sidebar.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Frecursive-deref-sidebar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Frecursive-deref-sidebar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Frecursive-deref-sidebar.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/recursive-deref-sidebar.rs"}, {"sha": "aa38485c44558b7658d0e0100fdaaa7105597222", "filename": "tests/rustdoc/deref/recursive-deref.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Frecursive-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Frustdoc%2Fderef%2Frecursive-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fderef%2Frecursive-deref.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "previous_filename": "tests/rustdoc/recursive-deref.rs"}, {"sha": "2dd0e10b5216f6728c2bfe2d10c3234339933e2f", "filename": "tests/ui/feature-gates/test-listing-format-json.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Fui%2Ffeature-gates%2Ftest-listing-format-json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Fui%2Ffeature-gates%2Ftest-listing-format-json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ftest-listing-format-json.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -0,0 +1,18 @@\n+// no-prefer-dynamic\n+// compile-flags: --test\n+// run-flags: --list --format json -Zunstable-options\n+// run-fail\n+// check-run-results\n+// ignore-nightly\n+// unset-exec-env:RUSTC_BOOTSTRAP\n+\n+#![cfg(test)]\n+#[test]\n+fn m_test() {}\n+\n+#[test]\n+#[ignore = \"not yet implemented\"]\n+fn z_test() {}\n+\n+#[test]\n+fn a_test() {}"}, {"sha": "e81cb81f32c3f0be39cf97f2b1c9b62f784a25e2", "filename": "tests/ui/feature-gates/test-listing-format-json.run.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Fui%2Ffeature-gates%2Ftest-listing-format-json.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Fui%2Ffeature-gates%2Ftest-listing-format-json.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ftest-listing-format-json.run.stderr?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -0,0 +1 @@\n+error: the option `Z` is only accepted on the nightly compiler"}, {"sha": "5afc2746fe4e0b03cfa7f493ea274c60742c8fb0", "filename": "tests/ui/test-attrs/tests-listing-format-json.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.rs?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -3,6 +3,7 @@\n // run-flags: --list --format json -Zunstable-options\n // run-pass\n // check-run-results\n+// only-nightly\n // normalize-stdout-test: \"fake-test-src-base/test-attrs/\" -> \"$$DIR/\"\n // normalize-stdout-test: \"fake-test-src-base\\\\test-attrs\\\\\" -> \"$$DIR/\"\n "}, {"sha": "33cc939b59f5df23d2ddf047ba9af1fff2a7baaf", "filename": "tests/ui/test-attrs/tests-listing-format-json.run.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/eb62877597000ccf8bb99ab131b5977344afdfa3/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Ftests-listing-format-json.run.stdout?ref=eb62877597000ccf8bb99ab131b5977344afdfa3", "patch": "@@ -1,5 +1,5 @@\n { \"type\": \"suite\", \"event\": \"discovery\" }\n-{ \"type\": \"test\", \"event\": \"discovered\", \"name\": \"a_test\", \"ignore\": false, \"ignore_message\": \"\", \"source_path\": \"$DIR/tests-listing-format-json.rs\", \"start_line\": 20, \"start_col\": 4, \"end_line\": 20, \"end_col\": 10 }\n-{ \"type\": \"test\", \"event\": \"discovered\", \"name\": \"m_test\", \"ignore\": false, \"ignore_message\": \"\", \"source_path\": \"$DIR/tests-listing-format-json.rs\", \"start_line\": 13, \"start_col\": 4, \"end_line\": 13, \"end_col\": 10 }\n-{ \"type\": \"test\", \"event\": \"discovered\", \"name\": \"z_test\", \"ignore\": true, \"ignore_message\": \"not yet implemented\", \"source_path\": \"$DIR/tests-listing-format-json.rs\", \"start_line\": 17, \"start_col\": 4, \"end_line\": 17, \"end_col\": 10 }\n+{ \"type\": \"test\", \"event\": \"discovered\", \"name\": \"a_test\", \"ignore\": false, \"ignore_message\": \"\", \"source_path\": \"$DIR/tests-listing-format-json.rs\", \"start_line\": 21, \"start_col\": 4, \"end_line\": 21, \"end_col\": 10 }\n+{ \"type\": \"test\", \"event\": \"discovered\", \"name\": \"m_test\", \"ignore\": false, \"ignore_message\": \"\", \"source_path\": \"$DIR/tests-listing-format-json.rs\", \"start_line\": 14, \"start_col\": 4, \"end_line\": 14, \"end_col\": 10 }\n+{ \"type\": \"test\", \"event\": \"discovered\", \"name\": \"z_test\", \"ignore\": true, \"ignore_message\": \"not yet implemented\", \"source_path\": \"$DIR/tests-listing-format-json.rs\", \"start_line\": 18, \"start_col\": 4, \"end_line\": 18, \"end_col\": 10 }\n { \"type\": \"suite\", \"event\": \"completed\", \"tests\": 3, \"benchmarks\": 0, \"total\": 3, \"ignored\": 1 }"}]}