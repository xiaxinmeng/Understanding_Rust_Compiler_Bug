{"sha": "f692fafee8bf90d603c36668f43b151e5e111ec3", "node_id": "C_kwDOAAsO6NoAKGY2OTJmYWZlZThiZjkwZDYwM2MzNjY2OGY0M2IxNTFlNWUxMTFlYzM", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-25T19:02:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-12-25T19:03:57Z"}, "message": "rename", "tree": {"sha": "ec765ea710e0ce32b341429c709f2a78a57b05f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec765ea710e0ce32b341429c709f2a78a57b05f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f692fafee8bf90d603c36668f43b151e5e111ec3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f692fafee8bf90d603c36668f43b151e5e111ec3", "html_url": "https://github.com/rust-lang/rust/commit/f692fafee8bf90d603c36668f43b151e5e111ec3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f692fafee8bf90d603c36668f43b151e5e111ec3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74de79b1daeefb4868ce34e03e84949d33d3dd1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/74de79b1daeefb4868ce34e03e84949d33d3dd1e", "html_url": "https://github.com/rust-lang/rust/commit/74de79b1daeefb4868ce34e03e84949d33d3dd1e"}], "stats": {"total": 83, "additions": 39, "deletions": 44}, "files": [{"sha": "a6abe3cccf3f3dce5b4dc93db659ebd2582379e1", "filename": "crates/syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f692fafee8bf90d603c36668f43b151e5e111ec3/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f692fafee8bf90d603c36668f43b151e5e111ec3/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=f692fafee8bf90d603c36668f43b151e5e111ec3", "patch": "@@ -94,7 +94,7 @@ fn reparse_block(\n         return None;\n     }\n \n-    let tree_traversal = reparser.parse(&parser_tokens);\n+    let tree_traversal = reparser.parse(&parser_input);\n \n     let (green, new_parser_errors, _eof) = build_tree(lexed, tree_traversal, false);\n "}, {"sha": "f40c549e3d7bcedb12ec44a97a5ffb7a543216c5", "filename": "crates/syntax/src/parsing/text_tree_sink.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f692fafee8bf90d603c36668f43b151e5e111ec3/crates%2Fsyntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f692fafee8bf90d603c36668f43b151e5e111ec3/crates%2Fsyntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fparsing%2Ftext_tree_sink.rs?ref=f692fafee8bf90d603c36668f43b151e5e111ec3", "patch": "@@ -17,35 +17,32 @@ pub(crate) fn build_tree(\n     parser_output: parser::Output,\n     synthetic_root: bool,\n ) -> (GreenNode, Vec<SyntaxError>, bool) {\n-    let mut builder = TextTreeSink::new(lexed);\n+    let mut builder = Builder::new(lexed);\n \n     if synthetic_root {\n-        builder.start_node(SyntaxKind::SOURCE_FILE);\n+        builder.enter(SyntaxKind::SOURCE_FILE);\n     }\n \n     for event in parser_output.iter() {\n         match event {\n             parser::Step::Token { kind, n_input_tokens: n_raw_tokens } => {\n                 builder.token(kind, n_raw_tokens)\n             }\n-            parser::Step::Enter { kind } => builder.start_node(kind),\n-            parser::Step::Exit => builder.finish_node(),\n+            parser::Step::Enter { kind } => builder.enter(kind),\n+            parser::Step::Exit => builder.exit(),\n             parser::Step::Error { msg } => {\n                 let text_pos = builder.lexed.text_start(builder.pos).try_into().unwrap();\n                 builder.inner.error(msg.to_string(), text_pos);\n             }\n         }\n     }\n     if synthetic_root {\n-        builder.finish_node()\n+        builder.exit()\n     }\n-    builder.finish_eof()\n+    builder.build()\n }\n \n-/// Bridges the parser with our specific syntax tree representation.\n-///\n-/// `TextTreeSink` also handles attachment of trivia (whitespace) to nodes.\n-struct TextTreeSink<'a> {\n+struct Builder<'a> {\n     lexed: LexedStr<'a>,\n     pos: usize,\n     state: State,\n@@ -58,7 +55,35 @@ enum State {\n     PendingFinish,\n }\n \n-impl<'a> TextTreeSink<'a> {\n+impl<'a> Builder<'a> {\n+    fn new(lexed: parser::LexedStr<'a>) -> Self {\n+        Self { lexed, pos: 0, state: State::PendingStart, inner: SyntaxTreeBuilder::default() }\n+    }\n+\n+    fn build(mut self) -> (GreenNode, Vec<SyntaxError>, bool) {\n+        match mem::replace(&mut self.state, State::Normal) {\n+            State::PendingFinish => {\n+                self.eat_trivias();\n+                self.inner.finish_node();\n+            }\n+            State::PendingStart | State::Normal => unreachable!(),\n+        }\n+\n+        let (node, mut errors) = self.inner.finish_raw();\n+        for (i, err) in self.lexed.errors() {\n+            let text_range = self.lexed.text_range(i);\n+            let text_range = TextRange::new(\n+                text_range.start.try_into().unwrap(),\n+                text_range.end.try_into().unwrap(),\n+            );\n+            errors.push(SyntaxError::new(err, text_range))\n+        }\n+\n+        let is_eof = self.pos == self.lexed.len();\n+\n+        (node, errors, is_eof)\n+    }\n+\n     fn token(&mut self, kind: SyntaxKind, n_tokens: u8) {\n         match mem::replace(&mut self.state, State::Normal) {\n             State::PendingStart => unreachable!(),\n@@ -69,7 +94,7 @@ impl<'a> TextTreeSink<'a> {\n         self.do_token(kind, n_tokens as usize);\n     }\n \n-    fn start_node(&mut self, kind: SyntaxKind) {\n+    fn enter(&mut self, kind: SyntaxKind) {\n         match mem::replace(&mut self.state, State::Normal) {\n             State::PendingStart => {\n                 self.inner.start_node(kind);\n@@ -93,43 +118,13 @@ impl<'a> TextTreeSink<'a> {\n         self.eat_n_trivias(n_attached_trivias);\n     }\n \n-    fn finish_node(&mut self) {\n+    fn exit(&mut self) {\n         match mem::replace(&mut self.state, State::PendingFinish) {\n             State::PendingStart => unreachable!(),\n             State::PendingFinish => self.inner.finish_node(),\n             State::Normal => (),\n         }\n     }\n-}\n-\n-impl<'a> TextTreeSink<'a> {\n-    pub(super) fn new(lexed: parser::LexedStr<'a>) -> Self {\n-        Self { lexed, pos: 0, state: State::PendingStart, inner: SyntaxTreeBuilder::default() }\n-    }\n-\n-    pub(super) fn finish_eof(mut self) -> (GreenNode, Vec<SyntaxError>, bool) {\n-        match mem::replace(&mut self.state, State::Normal) {\n-            State::PendingFinish => {\n-                self.eat_trivias();\n-                self.inner.finish_node();\n-            }\n-            State::PendingStart | State::Normal => unreachable!(),\n-        }\n-\n-        let (node, mut errors) = self.inner.finish_raw();\n-        for (i, err) in self.lexed.errors() {\n-            let text_range = self.lexed.text_range(i);\n-            let text_range = TextRange::new(\n-                text_range.start.try_into().unwrap(),\n-                text_range.end.try_into().unwrap(),\n-            );\n-            errors.push(SyntaxError::new(err, text_range))\n-        }\n-\n-        let is_eof = self.pos == self.lexed.len();\n-\n-        (node, errors, is_eof)\n-    }\n \n     fn eat_trivias(&mut self) {\n         while self.pos < self.lexed.len() {"}]}