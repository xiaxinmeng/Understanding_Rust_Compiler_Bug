{"sha": "859b8da21fc82c08fde8b3aafefc12881a0c3f09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OWI4ZGEyMWZjODJjMDhmZGU4YjNhYWZlZmMxMjg4MWEwYzNmMDk=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-04-07T17:55:00Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-04-07T17:55:00Z"}, "message": "Implement Chain with Option fuses\n\nThe iterators are now \"fused\" with `Option` so we don't need separate\nstate to track which part is already exhausted, and we may also get\nniche layout for `None`. We don't use the real `Fuse` adapter because\nits specialization for `FusedIterator` unconditionally descends into the\niterator, and that could be expensive to keep revisiting stuff like\nnested chains. It also hurts compiler performance to add more iterator\nlayers to `Chain`.", "tree": {"sha": "898f76f9d228e5000b19f8addefab084b68e1ece", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/898f76f9d228e5000b19f8addefab084b68e1ece"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/859b8da21fc82c08fde8b3aafefc12881a0c3f09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/859b8da21fc82c08fde8b3aafefc12881a0c3f09", "html_url": "https://github.com/rust-lang/rust/commit/859b8da21fc82c08fde8b3aafefc12881a0c3f09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/859b8da21fc82c08fde8b3aafefc12881a0c3f09/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0", "html_url": "https://github.com/rust-lang/rust/commit/39b62533c7f9d0581a6ea9b9fc2cc51f21c3b5b0"}], "stats": {"total": 255, "additions": 106, "deletions": 149}, "files": [{"sha": "6c97c43df407ac4dfdff08fe2f131782c63bc65d", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 106, "deletions": 149, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/859b8da21fc82c08fde8b3aafefc12881a0c3f09/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/859b8da21fc82c08fde8b3aafefc12881a0c3f09/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=859b8da21fc82c08fde8b3aafefc12881a0c3f09", "patch": "@@ -1,8 +1,7 @@\n+use crate::iter::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n use crate::ops::Try;\n use crate::usize;\n \n-use super::super::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n-\n /// An iterator that links two iterators together, in a chain.\n ///\n /// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n@@ -14,37 +13,34 @@ use super::super::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<A, B> {\n-    a: A,\n-    b: B,\n-    state: ChainState,\n+    // These are \"fused\" with `Option` so we don't need separate state to track which part is\n+    // already exhausted, and we may also get niche layout for `None`. We don't use the real `Fuse`\n+    // adapter because its specialization for `FusedIterator` unconditionally descends into the\n+    // iterator, and that could be expensive to keep revisiting stuff like nested chains. It also\n+    // hurts compiler performance to add more iterator layers to `Chain`.\n+    a: Option<A>,\n+    b: Option<B>,\n }\n impl<A, B> Chain<A, B> {\n     pub(in super::super) fn new(a: A, b: B) -> Chain<A, B> {\n-        Chain { a, b, state: ChainState::Both }\n+        Chain { a: Some(a), b: Some(b) }\n     }\n }\n \n-// The iterator protocol specifies that iteration ends with the return value\n-// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n-// further calls return. The chain adaptor must account for this since it uses\n-// two subiterators.\n-//\n-//  It uses three states:\n-//\n-//  - Both: `a` and `b` are remaining\n-//  - Front: `a` remaining\n-//  - Back: `b` remaining\n-//\n-//  The fourth state (neither iterator is remaining) only occurs after Chain has\n-//  returned None once, so we don't need to store this state.\n-#[derive(Clone, Debug)]\n-enum ChainState {\n-    // both front and back iterator are remaining\n-    Both,\n-    // only front is remaining\n-    Front,\n-    // only back is remaining\n-    Back,\n+/// Fuse the iterator if the expression is `None`.\n+macro_rules! fuse {\n+    ($self:ident . $iter:ident . $($call:tt)+) => {\n+        match $self.$iter {\n+            Some(ref mut iter) => match iter.$($call)+ {\n+                None => {\n+                    $self.$iter = None;\n+                    None\n+                }\n+                item => item,\n+            },\n+            None => None,\n+        }\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -57,128 +53,99 @@ where\n \n     #[inline]\n     fn next(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.a.next() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.next()\n-                }\n-            },\n-            ChainState::Front => self.a.next(),\n-            ChainState::Back => self.b.next(),\n+        match fuse!(self.a.next()) {\n+            None => fuse!(self.b.next()),\n+            item => item,\n         }\n     }\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n     fn count(self) -> usize {\n-        match self.state {\n-            ChainState::Both => self.a.count() + self.b.count(),\n-            ChainState::Front => self.a.count(),\n-            ChainState::Back => self.b.count(),\n+        match self {\n+            Chain { a: Some(a), b: Some(b) } => a.count() + b.count(),\n+            Chain { a: Some(a), b: None } => a.count(),\n+            Chain { a: None, b: Some(b) } => b.count(),\n+            Chain { a: None, b: None } => 0,\n         }\n     }\n \n-    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.try_fold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n-                }\n-            }\n-            _ => {}\n+        if let Some(ref mut a) = self.a {\n+            acc = a.try_fold(acc, &mut f)?;\n+            self.a = None;\n         }\n-        if let ChainState::Back = self.state {\n-            accum = self.b.try_fold(accum, &mut f)?;\n+        if let Some(ref mut b) = self.b {\n+            acc = b.try_fold(acc, &mut f)?;\n+            self.b = None;\n         }\n-        Try::from_ok(accum)\n+        Try::from_ok(acc)\n     }\n \n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, mut acc: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.fold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(a) = self.a {\n+            acc = a.fold(acc, &mut f);\n         }\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.fold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(b) = self.b {\n+            acc = b.fold(acc, &mut f);\n         }\n-        accum\n+        acc\n     }\n \n     #[inline]\n     fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                for x in self.a.by_ref() {\n-                    if n == 0 {\n-                        return Some(x);\n-                    }\n-                    n -= 1;\n-                }\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n+        if let Some(ref mut a) = self.a {\n+            while let Some(x) = a.next() {\n+                if n == 0 {\n+                    return Some(x);\n                 }\n+                n -= 1;\n             }\n-            ChainState::Back => {}\n+            self.a = None;\n         }\n-        if let ChainState::Back = self.state { self.b.nth(n) } else { None }\n+        fuse!(self.b.nth(n))\n     }\n \n     #[inline]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        match self.state {\n-            ChainState::Both => match self.a.find(&mut predicate) {\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.find(predicate)\n-                }\n-                v => v,\n-            },\n-            ChainState::Front => self.a.find(predicate),\n-            ChainState::Back => self.b.find(predicate),\n+        match fuse!(self.a.find(&mut predicate)) {\n+            None => fuse!(self.b.find(predicate)),\n+            item => item,\n         }\n     }\n \n     #[inline]\n     fn last(self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => {\n+        match self {\n+            Chain { a: Some(a), b: Some(b) } => {\n                 // Must exhaust a before b.\n-                let a_last = self.a.last();\n-                let b_last = self.b.last();\n+                let a_last = a.last();\n+                let b_last = b.last();\n                 b_last.or(a_last)\n             }\n-            ChainState::Front => self.a.last(),\n-            ChainState::Back => self.b.last(),\n+            Chain { a: Some(a), b: None } => a.last(),\n+            Chain { a: None, b: Some(b) } => b.last(),\n+            Chain { a: None, b: None } => None,\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.state {\n-            ChainState::Both => {\n-                let (a_lower, a_upper) = self.a.size_hint();\n-                let (b_lower, b_upper) = self.b.size_hint();\n+        match self {\n+            Chain { a: Some(a), b: Some(b) } => {\n+                let (a_lower, a_upper) = a.size_hint();\n+                let (b_lower, b_upper) = b.size_hint();\n \n                 let lower = a_lower.saturating_add(b_lower);\n \n@@ -189,8 +156,9 @@ where\n \n                 (lower, upper)\n             }\n-            ChainState::Front => self.a.size_hint(),\n-            ChainState::Back => self.b.size_hint(),\n+            Chain { a: Some(a), b: None } => a.size_hint(),\n+            Chain { a: None, b: Some(b) } => b.size_hint(),\n+            Chain { a: None, b: None } => (0, Some(0)),\n         }\n     }\n }\n@@ -203,82 +171,71 @@ where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.b.next_back() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Front;\n-                    self.a.next_back()\n-                }\n-            },\n-            ChainState::Front => self.a.next_back(),\n-            ChainState::Back => self.b.next_back(),\n+        match fuse!(self.b.next_back()) {\n+            None => fuse!(self.a.next_back()),\n+            item => item,\n         }\n     }\n \n     #[inline]\n     fn nth_back(&mut self, mut n: usize) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                for x in self.b.by_ref().rev() {\n-                    if n == 0 {\n-                        return Some(x);\n-                    }\n-                    n -= 1;\n-                }\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Front;\n+        if let Some(ref mut b) = self.b {\n+            while let Some(x) = b.next_back() {\n+                if n == 0 {\n+                    return Some(x);\n                 }\n+                n -= 1;\n             }\n-            ChainState::Front => {}\n+            self.b = None;\n+        }\n+        fuse!(self.a.nth_back(n))\n+    }\n+\n+    #[inline]\n+    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        match fuse!(self.b.rfind(&mut predicate)) {\n+            None => fuse!(self.a.rfind(predicate)),\n+            item => item,\n         }\n-        if let ChainState::Front = self.state { self.a.nth_back(n) } else { None }\n     }\n \n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    fn try_rfold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.try_rfold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Front;\n-                }\n-            }\n-            _ => {}\n+        if let Some(ref mut b) = self.b {\n+            acc = b.try_rfold(acc, &mut f)?;\n+            self.b = None;\n         }\n-        if let ChainState::Front = self.state {\n-            accum = self.a.try_rfold(accum, &mut f)?;\n+        if let Some(ref mut a) = self.a {\n+            acc = a.try_rfold(acc, f)?;\n+            self.a = None;\n         }\n-        Try::from_ok(accum)\n+        Try::from_ok(acc)\n     }\n \n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, mut acc: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.rfold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(b) = self.b {\n+            acc = b.rfold(acc, &mut f);\n         }\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.rfold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(a) = self.a {\n+            acc = a.rfold(acc, f);\n         }\n-        accum\n+        acc\n     }\n }\n \n // Note: *both* must be fused to handle double-ended iterators.\n+// Now that we \"fuse\" both sides, we *could* implement this unconditionally,\n+// but we should be cautious about committing to that in the public API.\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Chain<A, B>\n where"}]}