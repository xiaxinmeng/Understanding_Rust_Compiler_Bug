{"sha": "9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNGEwMWVlOWVlYTZmYzUwMjUyZjA4YWZiZjk4YTkxMjcwZTlkNWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-07T05:34:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2016-09-30T21:02:48Z"}, "message": "Ignore lots and lots of std tests on emscripten", "tree": {"sha": "92464da1ce31eb25756cbc98938a5c3dff5c7462", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92464da1ce31eb25756cbc98938a5c3dff5c7462"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "html_url": "https://github.com/rust-lang/rust/commit/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcd3279f36214e6915a3b14074f154da3c7cd88a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcd3279f36214e6915a3b14074f154da3c7cd88a", "html_url": "https://github.com/rust-lang/rust/commit/fcd3279f36214e6915a3b14074f154da3c7cd88a"}], "stats": {"total": 255, "additions": 255, "deletions": 0}, "files": [{"sha": "29e18781ce2a597884333e84f57f5d1938a27948", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -1000,6 +1000,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn manually_share_arc() {\n         let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = Arc::new(v);"}, {"sha": "67f3708a62b91dbf50e83d6bf98fcb5842f967b0", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -1294,6 +1294,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_send() {\n         let n = list_from(&[1, 2, 3]);\n         thread::spawn(move || {"}, {"sha": "9580714075ad78260e8c68e50354d8af085319ea", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -1116,6 +1116,7 @@ fn test_box_slice_clone() {\n }\n \n #[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "76a2f93c162e7a3f9579fd69388dbc450aa9a109", "filename": "src/libstd/env.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -1033,6 +1033,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_var_big() {\n         let mut s = \"\".to_string();\n         let mut i = 0;\n@@ -1046,6 +1047,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_self_exe_path() {\n         let path = current_exe();\n         assert!(path.is_ok());\n@@ -1056,6 +1058,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_env_set_get_huge() {\n         let n = make_rand_name();\n         let s = repeat(\"x\").take(10000).collect::<String>();"}, {"sha": "08d71c1d9f8c9dba9052b0f65faae9908db1e78b", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -1745,6 +1745,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_io_smoke_test() {\n         let message = \"it's alright. have a good time\";\n         let tmpdir = tmpdir();\n@@ -1766,6 +1767,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn invalid_path_raises() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n@@ -1780,6 +1782,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n@@ -1795,6 +1798,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_io_non_positional_read() {\n         let message: &str = \"ten-four\";\n         let mut read_mem = [0; 8];\n@@ -1821,6 +1825,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_io_seek_and_tell_smoke_test() {\n         let message = \"ten-four\";\n         let mut read_mem = [0; 4];\n@@ -1848,6 +1853,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_io_seek_and_write() {\n         let initial_msg =   \"food-is-yummy\";\n         let overwrite_msg =    \"-the-bar!!\";\n@@ -1872,6 +1878,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_io_seek_shakedown() {\n         //                   01234567890123\n         let initial_msg =   \"qwer-asdf-zxcv\";\n@@ -1904,6 +1911,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_stat_is_correct_on_is_file() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n@@ -1925,6 +1933,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n@@ -1937,6 +1946,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n@@ -1946,6 +1956,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n@@ -1956,6 +1967,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n@@ -1968,6 +1980,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_test_directoryinfo_readdir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n@@ -1997,6 +2010,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_create_new_already_exists_error() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"file_create_new_error_exists\");\n@@ -2006,6 +2020,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn mkdir_path_already_exists_error() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"mkdir_error_twice\");\n@@ -2015,6 +2030,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn recursive_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = tmpdir.join(\"d1/d2\");\n@@ -2023,6 +2039,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn recursive_mkdir_failure() {\n         let tmpdir = tmpdir();\n         let dir = tmpdir.join(\"d1\");\n@@ -2037,11 +2054,13 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn recursive_mkdir_slash() {\n         check!(fs::create_dir_all(&Path::new(\"/\")));\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn recursive_rmdir() {\n         let tmpdir = tmpdir();\n         let d1 = tmpdir.join(\"d1\");\n@@ -2061,6 +2080,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn recursive_rmdir_of_symlink() {\n         // test we do not recursively delete a symlink but only dirs.\n         let tmpdir = tmpdir();\n@@ -2094,6 +2114,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn unicode_path_is_dir() {\n         assert!(Path::new(\".\").is_dir());\n         assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n@@ -2113,6 +2134,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn unicode_path_exists() {\n         assert!(Path::new(\".\").exists());\n         assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n@@ -2126,6 +2148,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n@@ -2140,6 +2163,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn copy_src_does_not_exist() {\n         let tmpdir = tmpdir();\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n@@ -2153,6 +2177,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn copy_file_ok() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n@@ -2169,6 +2194,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn copy_file_dst_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n@@ -2180,6 +2206,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn copy_file_dst_exists() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in\");\n@@ -2195,6 +2222,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn copy_file_src_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n@@ -2206,6 +2234,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn copy_file_preserves_perm_bits() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n@@ -2234,6 +2263,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn symlinks_work() {\n         let tmpdir = tmpdir();\n         if !got_symlink_permission(&tmpdir) { return };\n@@ -2252,6 +2282,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn symlink_noexist() {\n         // Symlinks can point to things that don't exist\n         let tmpdir = tmpdir();\n@@ -2265,6 +2296,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn read_link() {\n         if cfg!(windows) {\n             // directory symlink\n@@ -2285,6 +2317,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n         match fs::read_link(tmpdir.path()) {\n@@ -2294,6 +2327,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn links_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n@@ -2322,6 +2356,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn chmod_works() {\n         let tmpdir = tmpdir();\n         let file = tmpdir.join(\"in.txt\");\n@@ -2345,6 +2380,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n@@ -2358,6 +2394,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn truncate_works() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n@@ -2392,6 +2429,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn open_flavors() {\n         use fs::OpenOptions as OO;\n         fn c<T: Clone>(t: &T) -> T { t.clone() }\n@@ -2511,6 +2549,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn binary_file() {\n         let mut bytes = [0; 1024];\n         StdRng::new().unwrap().fill_bytes(&mut bytes);\n@@ -2524,6 +2563,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn file_try_clone() {\n         let tmpdir = tmpdir();\n \n@@ -2546,6 +2586,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     #[cfg(not(windows))]\n     fn unlink_readonly() {\n         let tmpdir = tmpdir();\n@@ -2558,13 +2599,15 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn mkdir_trailing_slash() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"file\");\n         check!(fs::create_dir_all(&path.join(\"a/\")));\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn canonicalize_works_simple() {\n         let tmpdir = tmpdir();\n         let tmpdir = fs::canonicalize(tmpdir.path()).unwrap();\n@@ -2574,6 +2617,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn realpath_works() {\n         let tmpdir = tmpdir();\n         if !got_symlink_permission(&tmpdir) { return };\n@@ -2599,6 +2643,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn realpath_works_tricky() {\n         let tmpdir = tmpdir();\n         if !got_symlink_permission(&tmpdir) { return };\n@@ -2628,6 +2673,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn dir_entry_methods() {\n         let tmpdir = tmpdir();\n \n@@ -2662,12 +2708,14 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn read_dir_not_found() {\n         let res = fs::read_dir(\"/path/that/does/not/exist\");\n         assert_eq!(res.err().unwrap().kind(), ErrorKind::NotFound);\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn create_dir_all_with_junctions() {\n         let tmpdir = tmpdir();\n         let target = tmpdir.join(\"target\");\n@@ -2695,6 +2743,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn metadata_access_times() {\n         let tmpdir = tmpdir();\n "}, {"sha": "21a0cc1fb3b13e0028014fc916973a9f06ef7775", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -1107,6 +1107,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn panic_in_write_doesnt_flush_in_drop() {\n         static WRITES: AtomicUsize = AtomicUsize::new(0);\n "}, {"sha": "2ba2e8de71b54066a553982cef2f32fb32b7dbed", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -1761,6 +1761,7 @@ mod tests {\n     use super::repeat;\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn read_until() {\n         let mut buf = Cursor::new(&b\"12\"[..]);\n         let mut v = Vec::new();\n@@ -1971,6 +1972,7 @@ mod tests {\n     }\n \n     #[bench]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn bench_read_to_end(b: &mut test::Bencher) {\n         b.iter(|| {\n             let mut lr = repeat(1).take(10000000);"}, {"sha": "89cb9909956ee7b79e658853a1f5523afba37085", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -668,6 +668,7 @@ mod tests {\n     use super::*;\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn panic_doesnt_poison() {\n         thread::spawn(|| {\n             let _a = stdin();"}, {"sha": "930f2c721a7b704a370504ac3189cf3fda7a39e1", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -533,6 +533,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn to_socket_addr_str_u16() {\n         let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n         assert_eq!(Ok(vec![a]), tsa((\"77.88.21.11\", 24352)));\n@@ -545,6 +546,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn to_socket_addr_str() {\n         let a = sa4(Ipv4Addr::new(77, 88, 21, 11), 24352);\n         assert_eq!(Ok(vec![a]), tsa(\"77.88.21.11:24352\"));\n@@ -559,6 +561,7 @@ mod tests {\n     // FIXME: figure out why this fails on openbsd and bitrig and fix it\n     #[test]\n     #[cfg(not(any(windows, target_os = \"openbsd\", target_os = \"bitrig\")))]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn to_socket_addr_str_bad() {\n         assert!(tsa(\"1200::AB00:1234::2552:7777:1313:34300\").is_err());\n     }"}, {"sha": "d34fce2be43cac3c7dd1e2d056e95c4834355257", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -454,6 +454,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn bind_error() {\n         match TcpListener::bind(\"1.1.1.1:9999\") {\n             Ok(..) => panic!(),\n@@ -463,6 +464,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn connect_error() {\n         match TcpStream::connect(\"0.0.0.0:1\") {\n             Ok(..) => panic!(),\n@@ -475,6 +477,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn listen_localhost() {\n         let socket_addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&socket_addr));\n@@ -492,6 +495,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn connect_loopback() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -513,6 +517,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke_test() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -533,6 +538,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn read_eof() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -552,6 +558,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn write_close() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -578,6 +585,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn multiple_connect_serial() {\n         each_ip(&mut |addr| {\n             let max = 10;\n@@ -600,6 +608,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn multiple_connect_interleaved_greedy_schedule() {\n         const MAX: usize = 10;\n         each_ip(&mut |addr| {\n@@ -635,6 +644,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn multiple_connect_interleaved_lazy_schedule() {\n         const MAX: usize = 10;\n         each_ip(&mut |addr| {\n@@ -668,6 +678,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn socket_and_peer_name() {\n         each_ip(&mut |addr| {\n             let listener = t!(TcpListener::bind(&addr));\n@@ -683,6 +694,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn partial_read() {\n         each_ip(&mut |addr| {\n             let (tx, rx) = channel();\n@@ -704,6 +716,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn double_bind() {\n         each_ip(&mut |addr| {\n             let _listener = t!(TcpListener::bind(&addr));\n@@ -720,6 +733,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn fast_rebind() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -735,6 +749,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn tcp_clone_smoke() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -766,6 +781,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn tcp_clone_two_read() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -800,6 +816,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn tcp_clone_two_write() {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n@@ -827,6 +844,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shutdown_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -847,6 +865,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn close_readwrite_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -885,6 +904,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn close_read_wakes_up() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -912,6 +932,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn clone_while_reading() {\n         each_ip(&mut |addr| {\n             let accept = t!(TcpListener::bind(&addr));\n@@ -952,6 +973,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn clone_accept_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -970,6 +992,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn clone_accept_concurrent() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n@@ -998,6 +1021,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn debug() {\n         let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n         let socket_addr = next_test_ip4();\n@@ -1024,6 +1048,7 @@ mod tests {\n     //        no longer has rounding errors.\n     #[cfg_attr(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn timeouts() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));\n@@ -1050,6 +1075,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_timeout() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));\n@@ -1066,6 +1092,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_with_timeout() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));\n@@ -1088,6 +1115,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn nodelay() {\n         let addr = next_test_ip4();\n         let _listener = t!(TcpListener::bind(&addr));\n@@ -1102,6 +1130,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn ttl() {\n         let ttl = 100;\n \n@@ -1118,6 +1147,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn set_nonblocking() {\n         let addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&addr));"}, {"sha": "7315b6aaeb6ed6491f49bf75492f8e0cc6e53f91", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -378,6 +378,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn bind_error() {\n         match UdpSocket::bind(\"1.1.1.1:9999\") {\n             Ok(..) => panic!(),\n@@ -388,6 +389,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn socket_smoke_test_ip4() {\n         each_ip(&mut |server_ip, client_ip| {\n             let (tx1, rx1) = channel();\n@@ -412,6 +414,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn socket_name_ip4() {\n         each_ip(&mut |addr, _| {\n             let server = t!(UdpSocket::bind(&addr));\n@@ -420,6 +423,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn udp_clone_smoke() {\n         each_ip(&mut |addr1, addr2| {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n@@ -449,6 +453,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn udp_clone_two_read() {\n         each_ip(&mut |addr1, addr2| {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n@@ -481,6 +486,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn udp_clone_two_write() {\n         each_ip(&mut |addr1, addr2| {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n@@ -519,6 +525,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn debug() {\n         let name = if cfg!(windows) {\"socket\"} else {\"fd\"};\n         let socket_addr = next_test_ip4();\n@@ -534,6 +541,7 @@ mod tests {\n     //        no longer has rounding errors.\n     #[cfg_attr(any(target_os = \"bitrig\", target_os = \"netbsd\", target_os = \"openbsd\"), ignore)]\n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn timeouts() {\n         let addr = next_test_ip4();\n \n@@ -558,6 +566,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_timeout() {\n         let addr = next_test_ip4();\n \n@@ -573,6 +582,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_with_timeout() {\n         let addr = next_test_ip4();\n \n@@ -592,6 +602,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn connect_send_recv() {\n         let addr = next_test_ip4();\n \n@@ -606,6 +617,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn ttl() {\n         let ttl = 100;\n \n@@ -618,6 +630,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn set_nonblocking() {\n         let addr = next_test_ip4();\n "}, {"sha": "233a4d3639c3b807feb3c9ff13c043f0be713c98", "filename": "src/libstd/process.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -819,6 +819,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke() {\n         let p = Command::new(\"true\").spawn();\n         assert!(p.is_ok());\n@@ -837,6 +838,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn exit_reported_right() {\n         let p = Command::new(\"false\").spawn();\n         assert!(p.is_ok());\n@@ -848,6 +850,7 @@ mod tests {\n     #[test]\n     #[cfg(unix)]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn signal_reported_right() {\n         use os::unix::process::ExitStatusExt;\n \n@@ -876,6 +879,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stdout_works() {\n         let mut cmd = Command::new(\"echo\");\n         cmd.arg(\"foobar\").stdout(Stdio::piped());\n@@ -884,6 +888,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn set_current_dir_works() {\n         let mut cmd = Command::new(\"/bin/sh\");\n         cmd.arg(\"-c\").arg(\"pwd\")\n@@ -894,6 +899,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stdin_works() {\n         let mut p = Command::new(\"/bin/sh\")\n                             .arg(\"-c\").arg(\"read line; echo $line\")\n@@ -912,6 +918,7 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n     #[cfg(unix)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn uid_works() {\n         use os::unix::prelude::*;\n         use libc;\n@@ -938,6 +945,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_process_status() {\n         let mut status = Command::new(\"false\").status().unwrap();\n         assert!(status.code() == Some(1));\n@@ -947,6 +955,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_process_output_fail_to_start() {\n         match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n             Err(e) => assert_eq!(e.kind(), ErrorKind::NotFound),\n@@ -956,6 +965,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_process_output_output() {\n         let Output {status, stdout, stderr}\n              = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n@@ -968,6 +978,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_process_output_error() {\n         let Output {status, stdout, stderr}\n              = Command::new(\"mkdir\").arg(\".\").output().unwrap();\n@@ -979,13 +990,15 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_finish_once() {\n         let mut prog = Command::new(\"false\").spawn().unwrap();\n         assert!(prog.wait().unwrap().code() == Some(1));\n     }\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_finish_twice() {\n         let mut prog = Command::new(\"false\").spawn().unwrap();\n         assert!(prog.wait().unwrap().code() == Some(1));\n@@ -994,6 +1007,7 @@ mod tests {\n \n     #[test]\n     #[cfg_attr(target_os = \"android\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_wait_with_output_once() {\n         let prog = Command::new(\"echo\").arg(\"hello\").stdout(Stdio::piped())\n             .spawn().unwrap();\n@@ -1024,6 +1038,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_inherit_env() {\n         use env;\n \n@@ -1049,6 +1064,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_override_env() {\n         use env;\n \n@@ -1069,6 +1085,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_add_to_env() {\n         let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n         let output = String::from_utf8_lossy(&result.stdout).to_string();"}, {"sha": "69cd37651d5c28bde1bc9d5427975abea94e0133", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -242,6 +242,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_os_rng_tasks() {\n \n         let mut txs = vec!();"}, {"sha": "f46eab684846384a9b5245657d11f20bd450d867", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -118,6 +118,7 @@ mod tests {\n     use thread;\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_barrier() {\n         const N: usize = 10;\n "}, {"sha": "a983ae716a4816d387c75659c4dedafc3a5007e3", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -270,6 +270,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn notify_one() {\n         let m = Arc::new(Mutex::new(()));\n         let m2 = m.clone();\n@@ -286,6 +287,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn notify_all() {\n         const N: usize = 10;\n \n@@ -322,6 +324,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn wait_timeout_ms() {\n         let m = Arc::new(Mutex::new(()));\n         let m2 = m.clone();\n@@ -343,6 +346,7 @@ mod tests {\n \n     #[test]\n     #[should_panic]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn two_mutexes() {\n         let m = Arc::new(Mutex::new(()));\n         let m2 = m.clone();"}, {"sha": "b8101ae85cff3f328bce13efb5871e51184cb3e5", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -1314,6 +1314,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke_threads() {\n         let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n@@ -1346,6 +1347,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn port_gone_concurrent() {\n         let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n@@ -1355,6 +1357,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<i32>();\n         let tx2 = tx.clone();\n@@ -1381,6 +1384,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<i32>();\n         let _t = thread::spawn(move|| {\n@@ -1391,6 +1395,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress() {\n         let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n@@ -1403,6 +1408,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_shared() {\n         const AMT: u32 = 10000;\n         const NTHREADS: u32 = 8;\n@@ -1429,6 +1435,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<i32>();\n@@ -1449,6 +1456,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<i32>();\n         let t = thread::spawn(move|| {\n@@ -1463,6 +1471,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn no_runtime() {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<i32>();\n@@ -1501,6 +1510,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n@@ -1570,6 +1580,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n@@ -1580,6 +1591,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<i32>>();\n         let _t = thread::spawn(move|| {\n@@ -1592,6 +1604,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n@@ -1603,6 +1616,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n@@ -1616,6 +1630,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<i32>();\n@@ -1634,6 +1649,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<Box<isize>>();\n@@ -1645,6 +1661,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stream_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel();\n@@ -1683,6 +1700,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -1724,6 +1742,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_recv_timeout_shared() {\n         let (tx, rx) = channel();\n         let stress = stress_factor() + 100;\n@@ -1762,6 +1781,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shared_recv_timeout() {\n         let (tx, rx) = channel();\n         let total = 5;\n@@ -1780,6 +1800,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shared_chan_stress() {\n         let (tx, rx) = channel();\n         let total = stress_factor() + 100;\n@@ -1796,6 +1817,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_nested_recv_iter() {\n         let (tx, rx) = channel::<i32>();\n         let (total_tx, total_rx) = channel::<i32>();\n@@ -1816,6 +1838,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_recv_iter_break() {\n         let (tx, rx) = channel::<i32>();\n         let (count_tx, count_rx) = channel();\n@@ -1841,6 +1864,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_recv_try_iter() {\n         let (request_tx, request_rx) = channel();\n         let (response_tx, response_rx) = channel();\n@@ -1895,6 +1919,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn try_recv_states() {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<()>();\n@@ -1921,6 +1946,7 @@ mod tests {\n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n@@ -1988,6 +2014,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n@@ -2013,6 +2040,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n@@ -2022,6 +2050,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n@@ -2048,6 +2077,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n@@ -2058,6 +2088,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         thread::spawn(move|| {\n@@ -2069,6 +2100,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_recv_timeout_two_threads() {\n         let (tx, rx) = sync_channel::<i32>(0);\n \n@@ -2092,6 +2124,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_recv_timeout_shared() {\n         const AMT: u32 = 1000;\n         const NTHREADS: u32 = 8;\n@@ -2130,6 +2163,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress_shared() {\n         const AMT: u32 = 1000;\n         const NTHREADS: u32 = 8;\n@@ -2180,6 +2214,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = thread::spawn(move|| {\n@@ -2264,6 +2299,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n@@ -2274,6 +2310,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<i32>>(0);\n         let _t = thread::spawn(move|| {\n@@ -2286,6 +2323,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n@@ -2297,6 +2335,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n@@ -2310,6 +2349,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<i32>(0);\n@@ -2328,6 +2368,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<i32>>(0);\n@@ -2339,6 +2380,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stream_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<i32>>(0);\n@@ -2375,6 +2417,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shared_chan_stress() {\n         let (tx, rx) = sync_channel(0);\n         let total = stress_factor() + 100;\n@@ -2391,6 +2434,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_nested_recv_iter() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (total_tx, total_rx) = sync_channel::<i32>(0);\n@@ -2411,6 +2455,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_recv_iter_break() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n@@ -2436,6 +2481,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn try_recv_states() {\n         let (tx1, rx1) = sync_channel::<i32>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n@@ -2462,6 +2508,7 @@ mod sync_tests {\n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n@@ -2483,20 +2530,23 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send1() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { rx.recv().unwrap(); });\n         assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send2() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send3() {\n         let (tx, rx) = sync_channel::<i32>(1);\n         assert_eq!(tx.send(1), Ok(()));\n@@ -2505,6 +2555,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn send4() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let tx2 = tx.clone();\n@@ -2545,6 +2596,7 @@ mod sync_tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn issue_15761() {\n         fn repro() {\n             let (tx1, rx1) = sync_channel::<()>(3);"}, {"sha": "2ff9ffe6d0810340e7cc046c2faa34bd6fa6af3b", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -161,6 +161,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test() {\n         let nthreads = 8;\n         let nmsgs = 1000;"}, {"sha": "3058282edf33770507c1da65d758611ac39da3e8", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -444,6 +444,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn unblocks() {\n         let (tx1, rx1) = channel::<i32>();\n         let (_tx2, rx2) = channel::<i32>();\n@@ -468,6 +469,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn both_ready() {\n         let (tx1, rx1) = channel::<i32>();\n         let (tx2, rx2) = channel::<i32>();\n@@ -494,6 +496,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress() {\n         const AMT: i32 = 10000;\n         let (tx1, rx1) = channel::<i32>();\n@@ -521,6 +524,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn cloning() {\n         let (tx1, rx1) = channel::<i32>();\n         let (_tx2, rx2) = channel::<i32>();\n@@ -543,6 +547,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn cloning2() {\n         let (tx1, rx1) = channel::<i32>();\n         let (_tx2, rx2) = channel::<i32>();\n@@ -565,6 +570,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn cloning3() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<()>();\n@@ -682,6 +688,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn oneshot_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n@@ -698,6 +705,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stream_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n@@ -718,6 +726,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn shared_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n@@ -746,6 +755,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn sync2() {\n         let (tx, rx) = sync_channel::<i32>(0);\n         let _t = thread::spawn(move|| {\n@@ -758,6 +768,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn sync3() {\n         let (tx1, rx1) = sync_channel::<i32>(0);\n         let (tx2, rx2): (Sender<i32>, Receiver<i32>) = channel();"}, {"sha": "cb9577f155ea1c389fdcbb9f9848fd8255bd8852", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -305,6 +305,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stress() {\n         unsafe {\n             stress_bound(0);"}, {"sha": "07d60f0610f8cb1f787182992b595f5e3eb85d94", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -375,6 +375,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn lots_and_lots() {\n         const J: u32 = 1000;\n         const K: u32 = 3;\n@@ -435,6 +436,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_into_inner_poison() {\n         let m = Arc::new(Mutex::new(NonCopy(10)));\n         let m2 = m.clone();\n@@ -458,6 +460,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_get_mut_poison() {\n         let m = Arc::new(Mutex::new(NonCopy(10)));\n         let m2 = m.clone();\n@@ -474,6 +477,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_mutex_arc_condvar() {\n         let packet = Packet(Arc::new((Mutex::new(false), Condvar::new())));\n         let packet2 = Packet(packet.0.clone());\n@@ -497,6 +501,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_arc_condvar_poison() {\n         let packet = Packet(Arc::new((Mutex::new(1), Condvar::new())));\n         let packet2 = Packet(packet.0.clone());\n@@ -526,6 +531,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_mutex_arc_poison() {\n         let arc = Arc::new(Mutex::new(1));\n         assert!(!arc.is_poisoned());\n@@ -539,6 +545,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_mutex_arc_nested() {\n         // Tests nested mutexes and access\n         // to underlying data.\n@@ -555,6 +562,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_mutex_arc_access_in_unwind() {\n         let arc = Arc::new(Mutex::new(1));\n         let arc2 = arc.clone();"}, {"sha": "64c3e2bb42f499e06df1a0c60cc7e4b8f2122383", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -385,6 +385,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn stampede_once() {\n         static O: Once = Once::new();\n         static mut run: bool = false;\n@@ -447,6 +448,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn wait_for_force_to_finish() {\n         static O: Once = Once::new();\n "}, {"sha": "cb46b694f37e561fdfb21550b88e1afb5a025164", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -403,6 +403,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn frob() {\n         const N: usize = 10;\n         const M: usize = 1000;\n@@ -430,6 +431,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n@@ -441,6 +443,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_rw_arc_poison_ww() {\n         let arc = Arc::new(RwLock::new(1));\n         assert!(!arc.is_poisoned());\n@@ -454,6 +457,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n@@ -465,6 +469,7 @@ mod tests {\n         assert_eq!(*lock, 1);\n     }\n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n@@ -477,6 +482,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_rw_arc() {\n         let arc = Arc::new(RwLock::new(0));\n         let arc2 = arc.clone();\n@@ -515,6 +521,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n@@ -587,6 +594,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_into_inner_poison() {\n         let m = Arc::new(RwLock::new(NonCopy(10)));\n         let m2 = m.clone();\n@@ -610,6 +618,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_get_mut_poison() {\n         let m = Arc::new(RwLock::new(NonCopy(10)));\n         let m2 = m.clone();"}, {"sha": "2778ed9326c0783729943cfdecae4cbff72d7dca", "filename": "src/libstd/sys/common/io.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -165,6 +165,7 @@ mod tests {\n     }\n \n     #[bench]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn bench_uninitialized(b: &mut ::test::Bencher) {\n         b.iter(|| {\n             let mut lr = repeat(1).take(10000000);"}, {"sha": "4935afe6afc42024e6d27090e3a0fc65c3d12005", "filename": "src/libstd/sys/common/remutex.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fremutex.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -181,6 +181,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn is_mutex() {\n         let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n         let m2 = m.clone();\n@@ -198,6 +199,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn trylock_works() {\n         let m = Arc::new(ReentrantMutex::new(()));\n         let m2 = m.clone();\n@@ -218,6 +220,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn poison_works() {\n         let m = Arc::new(ReentrantMutex::new(RefCell::new(0)));\n         let mc = m.clone();"}, {"sha": "8224696db2f8d516d7eee5a0b10d69f62a11f3eb", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -806,6 +806,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn basic() {\n         let dir = tmpdir();\n         let socket_path = dir.path().join(\"sock\");\n@@ -834,6 +835,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn pair() {\n         let msg1 = b\"hello\";\n         let msg2 = b\"world!\";\n@@ -857,6 +859,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn try_clone() {\n         let dir = tmpdir();\n         let socket_path = dir.path().join(\"sock\");\n@@ -883,6 +886,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn iter() {\n         let dir = tmpdir();\n         let socket_path = dir.path().join(\"sock\");\n@@ -905,6 +909,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn long_path() {\n         let dir = tmpdir();\n         let socket_path = dir.path()\n@@ -930,6 +935,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn timeouts() {\n         let dir = tmpdir();\n         let socket_path = dir.path().join(\"sock\");\n@@ -957,6 +963,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_timeout() {\n         let dir = tmpdir();\n         let socket_path = dir.path().join(\"sock\");\n@@ -972,6 +979,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_read_with_timeout() {\n         let dir = tmpdir();\n         let socket_path = dir.path().join(\"sock\");\n@@ -993,6 +1001,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_unix_datagram() {\n         let dir = tmpdir();\n         let path1 = dir.path().join(\"sock1\");\n@@ -1009,6 +1018,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_unnamed_unix_datagram() {\n         let dir = tmpdir();\n         let path1 = dir.path().join(\"sock1\");\n@@ -1026,6 +1036,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_connect_unix_datagram() {\n         let dir = tmpdir();\n         let path1 = dir.path().join(\"sock1\");\n@@ -1052,6 +1063,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_unix_datagram_recv() {\n         let dir = tmpdir();\n         let path1 = dir.path().join(\"sock1\");\n@@ -1069,6 +1081,7 @@ mod test {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn datagram_pair() {\n         let msg1 = b\"hello\";\n         let msg2 = b\"world!\";"}, {"sha": "85aba4b9b156b222f49fe47d8f0b7485b0081ef5", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -630,6 +630,7 @@ mod tests {\n     #[test]\n     #[cfg_attr(target_os = \"macos\", ignore)]\n     #[cfg_attr(target_os = \"nacl\", ignore)] // no signals on NaCl.\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_process_mask() {\n         unsafe {\n             // Test to make sure that a signal mask does not get inherited."}, {"sha": "59748b47d815793ec60760cd8335b5d7bf389431", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -541,6 +541,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke_no_dtor() {\n         thread_local!(static FOO: Cell<i32> = Cell::new(1));\n \n@@ -563,6 +564,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn states() {\n         struct Foo;\n         impl Drop for Foo {\n@@ -586,6 +588,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn smoke_dtor() {\n         thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell::new(None));\n \n@@ -600,6 +603,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn circular() {\n         struct S1;\n         struct S2;\n@@ -640,6 +644,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn self_referential() {\n         struct S1;\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));\n@@ -661,6 +666,7 @@ mod tests {\n     // test on OSX.\n     #[test]\n     #[cfg_attr(target_os = \"macos\", ignore)]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn dtors_in_dtors_in_dtors() {\n         struct S1(Sender<()>);\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));"}, {"sha": "b42a0fa3ac1302e6cc0bc14bcf699a38815efb51", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c4a01ee9eea6fc50252f08afbf98a91270e9d5e/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=9c4a01ee9eea6fc50252f08afbf98a91270e9d5e", "patch": "@@ -755,13 +755,15 @@ mod tests {\n     // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_unnamed_thread() {\n         thread::spawn(move|| {\n             assert!(thread::current().name().is_none());\n         }).join().ok().unwrap();\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_named_thread() {\n         Builder::new().name(\"ada lovelace\".to_string()).spawn(move|| {\n             assert!(thread::current().name().unwrap() == \"ada lovelace\".to_string());\n@@ -770,11 +772,13 @@ mod tests {\n \n     #[test]\n     #[should_panic]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_invalid_named_thread() {\n         let _ = Builder::new().name(\"ada l\\0velace\".to_string()).spawn(|| {});\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_run_basic() {\n         let (tx, rx) = channel();\n         thread::spawn(move|| {\n@@ -784,6 +788,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_join_panic() {\n         match thread::spawn(move|| {\n             panic!()\n@@ -794,6 +799,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_spawn_sched() {\n         let (tx, rx) = channel();\n \n@@ -813,6 +819,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_spawn_sched_childs_on_default_sched() {\n         let (tx, rx) = channel();\n \n@@ -841,13 +848,15 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_avoid_copying_the_body_spawn() {\n         avoid_copying_the_body(|v| {\n             thread::spawn(move || v());\n         });\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_avoid_copying_the_body_thread_spawn() {\n         avoid_copying_the_body(|f| {\n             thread::spawn(move|| {\n@@ -857,6 +866,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_avoid_copying_the_body_join() {\n         avoid_copying_the_body(|f| {\n             let _ = thread::spawn(move|| {\n@@ -866,6 +876,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_child_doesnt_ref_parent() {\n         // If the child refcounts the parent thread, this will stack overflow when\n         // climbing the thread tree to dereference each ancestor. (See #1789)\n@@ -883,11 +894,13 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_simple_newsched_spawn() {\n         thread::spawn(move || {});\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_try_panic_message_static_str() {\n         match thread::spawn(move|| {\n             panic!(\"static string\");\n@@ -902,6 +915,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_try_panic_message_owned_str() {\n         match thread::spawn(move|| {\n             panic!(\"owned string\".to_string());\n@@ -916,6 +930,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_try_panic_message_any() {\n         match thread::spawn(move|| {\n             panic!(box 413u16 as Box<Any + Send>);\n@@ -932,6 +947,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_try_panic_message_unit_struct() {\n         struct Juju;\n \n@@ -944,6 +960,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_park_timeout_unpark_before() {\n         for _ in 0..10 {\n             thread::current().unpark();\n@@ -952,13 +969,15 @@ mod tests {\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_park_timeout_unpark_not_called() {\n         for _ in 0..10 {\n             thread::park_timeout(Duration::from_millis(10));\n         }\n     }\n \n     #[test]\n+    #[cfg_attr(target_os = \"emscripten\", ignore)]\n     fn test_park_timeout_unpark_called_other_thread() {\n         for _ in 0..10 {\n             let th = thread::current();"}]}