{"sha": "bf2d145c62888c853db0bcfd8f5b3a6919f15502", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMmQxNDVjNjI4ODhjODUzZGIwYmNmZDhmNWIzYTY5MTlmMTU1MDI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-31T03:27:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-31T03:27:36Z"}, "message": "Auto merge of #67032 - cjgillot:hirene, r=Zoxc\n\nAllocate HIR on an arena 4/4\n\nThis is the fourth and last PR in the series started by #66931, #66936 and #66942.\n\nThe last commits should compile on their own.\nThe difference with the previous PR is given by https://github.com/cjgillot/rust/compare/hirene-ty...hirene\n\nA few more cleanups may be necessary, please tell me.\n\nr? @eddyb like the other\ncc @Zoxc", "tree": {"sha": "9af922d78574fe87299b511f06e14f729e74424f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9af922d78574fe87299b511f06e14f729e74424f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf2d145c62888c853db0bcfd8f5b3a6919f15502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf2d145c62888c853db0bcfd8f5b3a6919f15502", "html_url": "https://github.com/rust-lang/rust/commit/bf2d145c62888c853db0bcfd8f5b3a6919f15502", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf2d145c62888c853db0bcfd8f5b3a6919f15502/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9dd56ff9a08d74c53d5cc22d18f126a12749608", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9dd56ff9a08d74c53d5cc22d18f126a12749608", "html_url": "https://github.com/rust-lang/rust/commit/a9dd56ff9a08d74c53d5cc22d18f126a12749608"}, {"sha": "ac8c0f4008d379d834fb08841f601cbe365c0c07", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac8c0f4008d379d834fb08841f601cbe365c0c07", "html_url": "https://github.com/rust-lang/rust/commit/ac8c0f4008d379d834fb08841f601cbe365c0c07"}], "stats": {"total": 519, "additions": 186, "deletions": 333}, "files": [{"sha": "9ac63001bf34b2bbd6af84e25c5872f0b9345dbb", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -672,7 +672,7 @@ pub fn walk_generic_args<'v, V: Visitor<'v>>(\n     _path_span: Span,\n     generic_args: &'v GenericArgs<'v>,\n ) {\n-    walk_list!(visitor, visit_generic_arg, &generic_args.args);\n+    walk_list!(visitor, visit_generic_arg, generic_args.args);\n     walk_list!(visitor, visit_assoc_type_binding, generic_args.bindings);\n }\n \n@@ -780,7 +780,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n }\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics<'v>) {\n-    walk_list!(visitor, visit_generic_param, &generics.params);\n+    walk_list!(visitor, visit_generic_param, generics.params);\n     walk_list!(visitor, visit_where_predicate, generics.where_clause.predicates);\n }\n "}, {"sha": "15eee3cad7f581aef3c98d184adcd4a77772e5bc", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 97, "deletions": 85, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -37,8 +37,6 @@ use crate::dep_graph::DepGraph;\n use crate::hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n use crate::hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n use crate::hir::map::{DefKey, DefPathData, Definitions};\n-use crate::hir::ptr::P;\n-use crate::hir::HirVec;\n use crate::hir::{self, ParamName};\n use crate::hir::{ConstArg, GenericArg};\n use crate::lint;\n@@ -75,12 +73,10 @@ use syntax_pos::Span;\n use rustc_error_codes::*;\n \n macro_rules! arena_vec {\n-    () => (\n-        &[]\n-    );\n-    ($this:expr; $($x:expr),*) => (\n-        $this.arena.alloc_from_iter(vec![$($x),*])\n-    );\n+    ($this:expr; $($x:expr),*) => ({\n+        let a = [$($x),*];\n+        $this.arena.alloc_from_iter(std::array::IntoIter::new(a))\n+    });\n }\n \n mod expr;\n@@ -540,7 +536,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         visit::walk_crate(&mut item::ItemLowerer { lctx: &mut self }, c);\n \n         let module = self.lower_mod(&c.module);\n-        let attrs = self.arena.alloc_from_iter(self.lower_attrs(&c.attrs).into_iter());\n+        let attrs = self.lower_attrs(&c.attrs);\n         let body_ids = body_ids(&self.bodies);\n \n         self.resolver.definitions().init_node_id_to_hir_id_mapping(self.node_id_to_hir_id);\n@@ -893,7 +889,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // in-band-lifetimes introduced by generics or where-clauses\n                     // wouldn't have been added yet.\n                     let generics =\n-                        this.lower_generics(generics, ImplTraitContext::Universal(&mut params));\n+                        this.lower_generics_mut(generics, ImplTraitContext::Universal(&mut params));\n                     let res = f(this, &mut params);\n                     (params, (generics, res))\n                 })\n@@ -914,6 +910,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         lowered_generics.params = lowered_params.into();\n \n+        let lowered_generics = lowered_generics.into_generics(self.arena);\n         (lowered_generics, res)\n     }\n \n@@ -957,14 +954,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    fn lower_attrs_arena(&mut self, attrs: &[Attribute]) -> &'hir [Attribute] {\n+    fn lower_attrs(&mut self, attrs: &[Attribute]) -> &'hir [Attribute] {\n         self.arena.alloc_from_iter(attrs.iter().map(|a| self.lower_attr(a)))\n     }\n \n-    fn lower_attrs(&mut self, attrs: &[Attribute]) -> hir::HirVec<Attribute> {\n-        attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into()\n-    }\n-\n     fn lower_attr(&mut self, attr: &Attribute) -> Attribute {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n@@ -1226,24 +1219,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(&f.generic_params, |this| {\n                 this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n-                    hir::TyKind::BareFn(\n-                        this.arena.alloc(hir::BareFnTy {\n-                            generic_params: this.arena.alloc_from_iter(\n-                                this.lower_generic_params(\n-                                    &f.generic_params,\n-                                    &NodeMap::default(),\n-                                    ImplTraitContext::disallowed(),\n-                                )\n-                                .into_iter(),\n-                            ),\n-                            unsafety: f.unsafety,\n-                            abi: this.lower_extern(f.ext),\n-                            decl: this.lower_fn_decl(&f.decl, None, false, None),\n-                            param_names: this.arena.alloc_from_iter(\n-                                this.lower_fn_params_to_names(&f.decl).into_iter(),\n-                            ),\n-                        }),\n-                    )\n+                    hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n+                        generic_params: this.lower_generic_params(\n+                            &f.generic_params,\n+                            &NodeMap::default(),\n+                            ImplTraitContext::disallowed(),\n+                        ),\n+                        unsafety: f.unsafety,\n+                        abi: this.lower_extern(f.ext),\n+                        decl: this.lower_fn_decl(&f.decl, None, false, None),\n+                        param_names: this.lower_fn_params_to_names(&f.decl),\n+                    }))\n                 })\n             }),\n             TyKind::Never => hir::TyKind::Never,\n@@ -1419,7 +1405,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs,);\n \n-        self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n+        self.with_hir_id_owner(opaque_ty_node_id, move |lctx| {\n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n@@ -1474,7 +1460,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         opaque_ty_id: NodeId,\n         parent_index: DefIndex,\n         bounds: hir::GenericBounds<'hir>,\n-    ) -> (&'hir [hir::GenericArg<'hir>], HirVec<hir::GenericParam<'hir>>) {\n+    ) -> (&'hir [hir::GenericArg<'hir>], &'hir [hir::GenericParam<'hir>]) {\n         debug!(\n             \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n              parent_index={:?}, \\\n@@ -1641,7 +1627,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let ImplTraitLifetimeCollector { output_lifetimes, output_lifetime_params, .. } =\n             lifetime_collector;\n \n-        (self.arena.alloc_from_iter(output_lifetimes), output_lifetime_params.into())\n+        (\n+            self.arena.alloc_from_iter(output_lifetimes),\n+            self.arena.alloc_from_iter(output_lifetime_params),\n+        )\n     }\n \n     fn lower_qpath(\n@@ -1809,8 +1798,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &Path,\n         param_mode: ParamMode,\n         explicit_owner: Option<NodeId>,\n-    ) -> hir::Path<'hir> {\n-        hir::Path {\n+    ) -> &'hir hir::Path<'hir> {\n+        self.arena.alloc(hir::Path {\n             res,\n             segments: self.arena.alloc_from_iter(p.segments.iter().map(|segment| {\n                 self.lower_path_segment(\n@@ -1824,10 +1813,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 )\n             })),\n             span: p.span,\n-        }\n+        })\n     }\n \n-    fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> hir::Path<'hir> {\n+    fn lower_path(&mut self, id: NodeId, p: &Path, param_mode: ParamMode) -> &'hir hir::Path<'hir> {\n         let res = self.expect_full_res(id);\n         let res = self.lower_res(res);\n         self.lower_path_extra(res, p, param_mode, None)\n@@ -1899,7 +1888,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         if !generic_args.parenthesized && !has_lifetimes {\n             generic_args.args = self\n                 .elided_path_lifetimes(path_span, expected_lifetimes)\n-                .into_iter()\n                 .map(|lt| GenericArg::Lifetime(lt))\n                 .chain(generic_args.args.into_iter())\n                 .collect();\n@@ -1978,7 +1966,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             hir_id: Some(id),\n             res: Some(self.lower_res(res)),\n             infer_args,\n-            args: if generic_args.is_empty() { None } else { Some(self.arena.alloc(generic_args)) },\n+            args: if generic_args.is_empty() {\n+                None\n+            } else {\n+                Some(self.arena.alloc(generic_args.into_generic_args(self.arena)))\n+            },\n         }\n     }\n \n@@ -1987,15 +1979,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         data: &AngleBracketedArgs,\n         param_mode: ParamMode,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> (hir::GenericArgs<'hir>, bool) {\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n         let &AngleBracketedArgs { ref args, ref constraints, .. } = data;\n         let has_non_lt_args = args.iter().any(|arg| match arg {\n             ast::GenericArg::Lifetime(_) => false,\n             ast::GenericArg::Type(_) => true,\n             ast::GenericArg::Const(_) => true,\n         });\n         (\n-            hir::GenericArgs {\n+            GenericArgsCtor {\n                 args: args.iter().map(|a| self.lower_generic_arg(a, itctx.reborrow())).collect(),\n                 bindings: self.arena.alloc_from_iter(\n                     constraints.iter().map(|b| self.lower_assoc_ty_constraint(b, itctx.reborrow())),\n@@ -2009,7 +2001,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_parenthesized_parameter_data(\n         &mut self,\n         data: &ParenthesizedArgs,\n-    ) -> (hir::GenericArgs<'hir>, bool) {\n+    ) -> (GenericArgsCtor<'hir>, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n         // a hidden lifetime parameter. This is needed for backwards\n@@ -2024,15 +2016,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 FunctionRetTy::Ty(ty) => this.lower_ty(&ty, ImplTraitContext::disallowed()),\n                 FunctionRetTy::Default(_) => this.arena.alloc(this.ty_tup(span, &[])),\n             };\n-            let args = hir_vec![GenericArg::Type(this.ty_tup(span, inputs))];\n+            let args = smallvec![GenericArg::Type(this.ty_tup(span, inputs))];\n             let binding = hir::TypeBinding {\n                 hir_id: this.next_id(),\n                 ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 span: output_ty.span,\n                 kind: hir::TypeBindingKind::Equality { ty: output_ty },\n             };\n             (\n-                hir::GenericArgs { args, bindings: arena_vec![this; binding], parenthesized: true },\n+                GenericArgsCtor { args, bindings: arena_vec![this; binding], parenthesized: true },\n                 false,\n             )\n         })\n@@ -2072,21 +2064,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n+    fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> &'hir [Ident] {\n         // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n         // as they are not explicit in HIR/Ty function signatures.\n         // (instead, the `c_variadic` flag is set to `true`)\n         let mut inputs = &decl.inputs[..];\n         if decl.c_variadic() {\n             inputs = &inputs[..inputs.len() - 1];\n         }\n-        inputs\n-            .iter()\n-            .map(|param| match param.pat.kind {\n-                PatKind::Ident(_, ident, _) => ident,\n-                _ => Ident::new(kw::Invalid, param.pat.span),\n-            })\n-            .collect()\n+        self.arena.alloc_from_iter(inputs.iter().map(|param| match param.pat.kind {\n+            PatKind::Ident(_, ident, _) => ident,\n+            _ => Ident::new(kw::Invalid, param.pat.span),\n+        }))\n     }\n \n     // Lowers a function declaration.\n@@ -2310,12 +2299,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n             debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n \n-            let generic_params = lifetime_params\n-                .iter()\n-                .map(|(span, hir_name)| {\n+            let generic_params =\n+                this.arena.alloc_from_iter(lifetime_params.iter().map(|(span, hir_name)| {\n                     this.lifetime_to_generic_param(*span, *hir_name, opaque_ty_def_index)\n-                })\n-                .collect();\n+                }));\n \n             let opaque_ty_item = hir::OpaqueTy {\n                 generics: hir::Generics {\n@@ -2395,7 +2382,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // \"<Output = T>\"\n         let future_params = self.arena.alloc(hir::GenericArgs {\n-            args: HirVec::new(),\n+            args: &[],\n             bindings: arena_vec![self; hir::TypeBinding {\n                 ident: Ident::with_dummy_span(FN_OUTPUT_NAME),\n                 kind: hir::TypeBindingKind::Equality { ty: output_ty },\n@@ -2406,12 +2393,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         });\n \n         // ::std::future::Future<future_params>\n-        let future_path = self.arena.alloc(self.std_path(\n-            span,\n-            &[sym::future, sym::Future],\n-            Some(future_params),\n-            false,\n-        ));\n+        let future_path =\n+            self.std_path(span, &[sym::future, sym::Future], Some(future_params), false);\n \n         hir::GenericBound::Trait(\n             hir::PolyTraitRef {\n@@ -2474,16 +2457,24 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::Lifetime { hir_id: self.lower_node_id(id), span, name }\n     }\n \n+    fn lower_generic_params_mut<'s>(\n+        &'s mut self,\n+        params: &'s [GenericParam],\n+        add_bounds: &'s NodeMap<Vec<GenericBound>>,\n+        mut itctx: ImplTraitContext<'s, 'hir>,\n+    ) -> impl Iterator<Item = hir::GenericParam<'hir>> + Captures<'a> + Captures<'s> {\n+        params\n+            .iter()\n+            .map(move |param| self.lower_generic_param(param, add_bounds, itctx.reborrow()))\n+    }\n+\n     fn lower_generic_params(\n         &mut self,\n         params: &[GenericParam],\n         add_bounds: &NodeMap<Vec<GenericBound>>,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> HirVec<hir::GenericParam<'hir>> {\n-        params\n-            .iter()\n-            .map(|param| self.lower_generic_param(param, add_bounds, itctx.reborrow()))\n-            .collect()\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> &'hir [hir::GenericParam<'hir>] {\n+        self.arena.alloc_from_iter(self.lower_generic_params_mut(params, add_bounds, itctx))\n     }\n \n     fn lower_generic_param(\n@@ -2561,7 +2552,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             name,\n             span: param.ident.span,\n             pure_wrt_drop: attr::contains_name(&param.attrs, sym::may_dangle),\n-            attrs: self.lower_attrs_arena(&param.attrs),\n+            attrs: self.lower_attrs(&param.attrs),\n             bounds: self.arena.alloc_from_iter(bounds),\n             kind,\n         }\n@@ -2593,11 +2584,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             this.lower_trait_ref(&p.trait_ref, itctx)\n         });\n \n-        hir::PolyTraitRef {\n-            bound_generic_params: self.arena.alloc_from_iter(bound_generic_params.into_iter()),\n-            trait_ref,\n-            span: p.span,\n-        }\n+        hir::PolyTraitRef { bound_generic_params, trait_ref, span: p.span }\n     }\n \n     fn lower_mt(&mut self, mt: &MutTy, itctx: ImplTraitContext<'_, 'hir>) -> hir::MutTy<'hir> {\n@@ -3053,7 +3040,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         subpats: &'hir [&'hir hir::Pat<'hir>],\n     ) -> &'hir hir::Pat<'hir> {\n         let path = self.std_path(span, components, None, true);\n-        let qpath = hir::QPath::Resolved(None, self.arena.alloc(path));\n+        let qpath = hir::QPath::Resolved(None, path);\n         let pt = if subpats.is_empty() {\n             hir::PatKind::Path(qpath)\n         } else {\n@@ -3101,7 +3088,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         components: &[Symbol],\n         params: Option<&'hir hir::GenericArgs<'hir>>,\n         is_value: bool,\n-    ) -> hir::Path<'hir> {\n+    ) -> &'hir hir::Path<'hir> {\n         let ns = if is_value { Namespace::ValueNS } else { Namespace::TypeNS };\n         let (path, res) = self.resolver.resolve_str_path(span, self.crate_root, components, ns);\n \n@@ -3121,11 +3108,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .collect();\n         segments.last_mut().unwrap().args = params;\n \n-        hir::Path {\n+        self.arena.alloc(hir::Path {\n             span,\n             res: res.map_id(|_| panic!(\"unexpected `NodeId`\")),\n             segments: self.arena.alloc_from_iter(segments),\n-        }\n+        })\n     }\n \n     fn ty_path(\n@@ -3209,8 +3196,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// `std::cell::Ref<T>`; note that implicit lifetimes in these\n     /// sorts of cases are deprecated. This may therefore report a warning or an\n     /// error, depending on the mode.\n-    fn elided_path_lifetimes(&mut self, span: Span, count: usize) -> P<[hir::Lifetime]> {\n-        (0..count).map(|_| self.elided_path_lifetime(span)).collect()\n+    fn elided_path_lifetimes<'s>(\n+        &'s mut self,\n+        span: Span,\n+        count: usize,\n+    ) -> impl Iterator<Item = hir::Lifetime> + Captures<'a> + Captures<'s> + Captures<'hir> {\n+        (0..count).map(move |_| self.elided_path_lifetime(span))\n     }\n \n     fn elided_path_lifetime(&mut self, span: Span) -> hir::Lifetime {\n@@ -3304,3 +3295,24 @@ fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body<'hir>>) -> Vec<hir::BodyId>\n     body_ids.sort_by_key(|b| bodies[b].value.span);\n     body_ids\n }\n+\n+/// Helper struct for delayed construction of GenericArgs.\n+struct GenericArgsCtor<'hir> {\n+    args: SmallVec<[hir::GenericArg<'hir>; 4]>,\n+    bindings: &'hir [hir::TypeBinding<'hir>],\n+    parenthesized: bool,\n+}\n+\n+impl GenericArgsCtor<'hir> {\n+    fn is_empty(&self) -> bool {\n+        self.args.is_empty() && self.bindings.is_empty() && !self.parenthesized\n+    }\n+\n+    fn into_generic_args(self, arena: &'hir Arena<'hir>) -> hir::GenericArgs<'hir> {\n+        hir::GenericArgs {\n+            args: arena.alloc_from_iter(self.args),\n+            bindings: self.bindings,\n+            parenthesized: self.parenthesized,\n+        }\n+    }\n+}"}, {"sha": "3911f09a227926663a1c7ada6dba9c68c84f06c0", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -464,7 +464,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm<'hir> {\n         hir::Arm {\n             hir_id: self.next_id(),\n-            attrs: self.lower_attrs_arena(&arm.attrs),\n+            attrs: self.lower_attrs(&arm.attrs),\n             pat: self.lower_pat(&arm.pat),\n             guard: match arm.guard {\n                 Some(ref x) => Some(hir::Guard::If(self.lower_expr(x))),\n@@ -827,7 +827,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let is_unit = fields.is_empty();\n         let struct_path = [sym::ops, path];\n         let struct_path = self.std_path(span, &struct_path, None, is_unit);\n-        let struct_path = hir::QPath::Resolved(None, self.arena.alloc(struct_path));\n+        let struct_path = hir::QPath::Resolved(None, struct_path);\n \n         if is_unit {\n             hir::ExprKind::Path(struct_path)\n@@ -1336,7 +1336,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         assoc_fn_name: &str,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::ExprKind<'hir> {\n-        let ty_path = self.arena.alloc(self.std_path(span, ty_path_components, None, false));\n+        let ty_path = self.std_path(span, ty_path_components, None, false);\n         let ty =\n             self.arena.alloc(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n         let fn_seg = self.arena.alloc(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n@@ -1354,11 +1354,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n         let path = self.std_path(span, components, params, true);\n-        self.expr(\n-            span,\n-            hir::ExprKind::Path(hir::QPath::Resolved(None, self.arena.alloc(path))),\n-            attrs,\n-        )\n+        self.expr(span, hir::ExprKind::Path(hir::QPath::Resolved(None, path)), attrs)\n     }\n \n     pub(super) fn expr_ident("}, {"sha": "6f1088de6c21d515fbb7584378cd53c9a48bffc3", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 52, "deletions": 40, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -5,6 +5,7 @@ use super::ImplTraitTypeIdVisitor;\n use super::LoweringContext;\n use super::ParamMode;\n \n+use crate::arena::Arena;\n use crate::hir;\n use crate::hir::def::{DefKind, Res};\n use crate::hir::def_id::DefId;\n@@ -225,7 +226,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item<'hir>> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n-        let attrs = self.lower_attrs_arena(&i.attrs);\n+        let attrs = self.lower_attrs(&i.attrs);\n \n         if let ItemKind::MacroDef(ref def) = i.kind {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n@@ -506,7 +507,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         let new_id = this.lower_node_id(new_node_id);\n                         let res = this.lower_res(res);\n                         let path = this.lower_path_extra(res, &path, ParamMode::Explicit, None);\n-                        let kind = hir::ItemKind::Use(this.arena.alloc(path), hir::UseKind::Single);\n+                        let kind = hir::ItemKind::Use(path, hir::UseKind::Single);\n                         let vis = this.rebuild_vis(&vis);\n \n                         this.insert_item(hir::Item {\n@@ -521,15 +522,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n \n                 let path = self.lower_path_extra(ret_res, &path, ParamMode::Explicit, None);\n-                let path = self.arena.alloc(path);\n                 hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n-                let path = self.arena.alloc(self.lower_path(\n-                    id,\n-                    &Path { segments, span: path.span },\n-                    ParamMode::Explicit,\n-                ));\n+                let path =\n+                    self.lower_path(id, &Path { segments, span: path.span }, ParamMode::Explicit);\n                 hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n@@ -617,7 +614,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let res = self.expect_full_res_from_use(id).next().unwrap_or(Res::Err);\n                 let res = self.lower_res(res);\n                 let path = self.lower_path_extra(res, &prefix, ParamMode::Explicit, None);\n-                let path = self.arena.alloc(path);\n                 hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }\n@@ -626,7 +622,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     /// Paths like the visibility path in `pub(super) use foo::{bar, baz}` are repeated\n     /// many times in the HIR tree; for each occurrence, we need to assign distinct\n     /// `NodeId`s. (See, e.g., #56128.)\n-    fn rebuild_use_path(&mut self, path: &hir::Path<'hir>) -> hir::Path<'hir> {\n+    fn rebuild_use_path(&mut self, path: &hir::Path<'hir>) -> &'hir hir::Path<'hir> {\n         debug!(\"rebuild_use_path(path = {:?})\", path);\n         let segments =\n             self.arena.alloc_from_iter(path.segments.iter().map(|seg| hir::PathSegment {\n@@ -636,7 +632,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 args: None,\n                 infer_args: seg.infer_args,\n             }));\n-        hir::Path { span: path.span, res: path.res, segments }\n+        self.arena.alloc(hir::Path { span: path.span, res: path.res, segments })\n     }\n \n     fn rebuild_vis(&mut self, vis: &hir::Visibility<'hir>) -> hir::Visibility<'hir> {\n@@ -646,7 +642,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n             hir::VisibilityKind::Restricted { ref path, hir_id: _ } => {\n                 hir::VisibilityKind::Restricted {\n-                    path: self.arena.alloc(self.rebuild_use_path(path)),\n+                    path: self.rebuild_use_path(path),\n                     hir_id: self.next_id(),\n                 }\n             }\n@@ -659,7 +655,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::ForeignItem {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n-            attrs: self.lower_attrs_arena(&i.attrs),\n+            attrs: self.lower_attrs(&i.attrs),\n             kind: match i.kind {\n                 ForeignItemKind::Fn(ref fdec, ref generics) => {\n                     let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n@@ -674,7 +670,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             )\n                         },\n                     );\n-                    let fn_args = self.arena.alloc_from_iter(fn_args.into_iter());\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n@@ -703,7 +698,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant<'hir> {\n         hir::Variant {\n-            attrs: self.lower_attrs_arena(&v.attrs),\n+            attrs: self.lower_attrs(&v.attrs),\n             data: self.lower_variant_data(&v.data),\n             disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n             id: self.lower_node_id(v.id),\n@@ -751,7 +746,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             },\n             vis: self.lower_visibility(&f.vis, None),\n             ty,\n-            attrs: self.lower_attrs_arena(&f.attrs),\n+            attrs: self.lower_attrs(&f.attrs),\n         }\n     }\n \n@@ -772,7 +767,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::Fn(ref sig, None) => {\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n-                let names: &[Ident] = self.arena.alloc_from_iter(names.into_iter());\n                 let (generics, sig) =\n                     self.lower_method_sig(&i.generics, sig, trait_item_def_id, false, None);\n                 (generics, hir::TraitItemKind::Method(sig, hir::TraitMethod::Required(names)))\n@@ -799,7 +793,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::TraitItem {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n-            attrs: self.lower_attrs_arena(&i.attrs),\n+            attrs: self.lower_attrs(&i.attrs),\n             generics,\n             kind,\n             span: i.span,\n@@ -886,7 +880,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         hir::ImplItem {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n-            attrs: self.lower_attrs_arena(&i.attrs),\n+            attrs: self.lower_attrs(&i.attrs),\n             generics,\n             vis: self.lower_visibility(&i.vis, None),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n@@ -945,12 +939,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let res = self.expect_full_res(id);\n                 let res = self.lower_res(res);\n                 hir::VisibilityKind::Restricted {\n-                    path: self.arena.alloc(self.lower_path_extra(\n-                        res,\n-                        path,\n-                        ParamMode::Explicit,\n-                        explicit_owner,\n-                    )),\n+                    path: self.lower_path_extra(res, path, ParamMode::Explicit, explicit_owner),\n                     hir_id: lowered_id,\n                 }\n             }\n@@ -993,7 +982,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_param(&mut self, param: &Param) -> hir::Param<'hir> {\n         hir::Param {\n-            attrs: self.lower_attrs_arena(&param.attrs),\n+            attrs: self.lower_attrs(&param.attrs),\n             hir_id: self.lower_node_id(param.id),\n             pat: self.lower_pat(&param.pat),\n             span: param.span,\n@@ -1133,7 +1122,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n-                        Some(this.arena.alloc(expr)),\n+                        Some(expr),\n                         parameter.pat,\n                         hir::LocalSource::AsyncFn,\n                     );\n@@ -1163,7 +1152,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let move_stmt = this.stmt_let_pat(\n                         AttrVec::new(),\n                         desugared_span,\n-                        Some(this.arena.alloc(move_expr)),\n+                        Some(move_expr),\n                         move_pat,\n                         hir::LocalSource::AsyncFn,\n                     );\n@@ -1174,7 +1163,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let pattern_stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n-                        Some(this.arena.alloc(pattern_expr)),\n+                        Some(pattern_expr),\n                         parameter.pat,\n                         hir::LocalSource::AsyncFn,\n                     );\n@@ -1295,11 +1284,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n \n-    pub(super) fn lower_generics(\n+    pub(super) fn lower_generics_mut(\n         &mut self,\n         generics: &Generics,\n         itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> hir::Generics<'hir> {\n+    ) -> GenericsCtor<'hir> {\n         // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n         // FIXME: this could probably be done with less rightward drift. It also looks like two\n         // control paths where `report_error` is called are the only paths that advance to after the\n@@ -1355,13 +1344,22 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n         }\n \n-        hir::Generics {\n-            params: self.lower_generic_params(&generics.params, &add_bounds, itctx),\n+        GenericsCtor {\n+            params: self.lower_generic_params_mut(&generics.params, &add_bounds, itctx).collect(),\n             where_clause: self.lower_where_clause(&generics.where_clause),\n             span: generics.span,\n         }\n     }\n \n+    pub(super) fn lower_generics(\n+        &mut self,\n+        generics: &Generics,\n+        itctx: ImplTraitContext<'_, 'hir>,\n+    ) -> hir::Generics<'hir> {\n+        let generics_ctor = self.lower_generics_mut(generics, itctx);\n+        generics_ctor.into_generics(self.arena)\n+    }\n+\n     fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause<'hir> {\n         self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n             hir::WhereClause {\n@@ -1383,13 +1381,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }) => {\n                 self.with_in_scope_lifetime_defs(&bound_generic_params, |this| {\n                     hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                        bound_generic_params: this.arena.alloc_from_iter(\n-                            this.lower_generic_params(\n-                                bound_generic_params,\n-                                &NodeMap::default(),\n-                                ImplTraitContext::disallowed(),\n-                            )\n-                            .into_iter(),\n+                        bound_generic_params: this.lower_generic_params(\n+                            bound_generic_params,\n+                            &NodeMap::default(),\n+                            ImplTraitContext::disallowed(),\n                         ),\n                         bounded_ty: this.lower_ty(bounded_ty, ImplTraitContext::disallowed()),\n                         bounds: this.arena.alloc_from_iter(bounds.iter().filter_map(|bound| {\n@@ -1426,3 +1421,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         }\n     }\n }\n+\n+/// Helper struct for delayed construction of Generics.\n+pub(super) struct GenericsCtor<'hir> {\n+    pub(super) params: SmallVec<[hir::GenericParam<'hir>; 4]>,\n+    where_clause: hir::WhereClause<'hir>,\n+    span: Span,\n+}\n+\n+impl GenericsCtor<'hir> {\n+    pub(super) fn into_generics(self, arena: &'hir Arena<'hir>) -> hir::Generics<'hir> {\n+        hir::Generics {\n+            params: arena.alloc_from_iter(self.params),\n+            where_clause: self.where_clause,\n+            span: self.span,\n+        }\n+    }\n+}"}, {"sha": "f56c9f8e72c2d385514ec36d66c6877a8d680004", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -10,7 +10,6 @@ pub use self::UnsafeSource::*;\n \n use crate::hir::def::{DefKind, Res};\n use crate::hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n-use crate::hir::ptr::P;\n use crate::mir::mono::Linkage;\n use crate::ty::query::Providers;\n use crate::ty::AdtKind;\n@@ -35,21 +34,6 @@ use syntax_pos::source_map::{SourceMap, Spanned};\n use syntax_pos::symbol::{kw, sym, Symbol};\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n \n-/// HIR doesn't commit to a concrete storage type and has its own alias for a vector.\n-/// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n-/// behavior. Unlike AST, HIR is mostly a static structure, so we can use an owned slice instead\n-/// of `Vec` to avoid keeping extra capacity.\n-pub type HirVec<T> = P<[T]>;\n-\n-macro_rules! hir_vec {\n-    ($elem:expr; $n:expr) => (\n-        $crate::hir::HirVec::from(vec![$elem; $n])\n-    );\n-    ($($x:expr),*) => (\n-        $crate::hir::HirVec::from(vec![$($x),*])\n-    );\n-}\n-\n pub mod check_attr;\n pub mod def;\n pub mod def_id;\n@@ -59,7 +43,6 @@ pub mod lowering;\n pub mod map;\n pub mod pat_util;\n pub mod print;\n-pub mod ptr;\n pub mod upvars;\n \n /// Uniquely identifies a node in the HIR of the current crate. It is\n@@ -415,7 +398,7 @@ impl GenericArg<'_> {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct GenericArgs<'hir> {\n     /// The generic arguments for this path segment.\n-    pub args: HirVec<GenericArg<'hir>>,\n+    pub args: &'hir [GenericArg<'hir>],\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A = Bar>`.\n     pub bindings: &'hir [TypeBinding<'hir>],\n@@ -427,7 +410,7 @@ pub struct GenericArgs<'hir> {\n \n impl GenericArgs<'_> {\n     pub const fn none() -> Self {\n-        Self { args: HirVec::new(), bindings: &[], parenthesized: false }\n+        Self { args: &[], bindings: &[], parenthesized: false }\n     }\n \n     pub fn is_empty(&self) -> bool {\n@@ -436,7 +419,7 @@ impl GenericArgs<'_> {\n \n     pub fn inputs(&self) -> &[Ty<'_>] {\n         if self.parenthesized {\n-            for arg in &self.args {\n+            for arg in self.args {\n                 match arg {\n                     GenericArg::Lifetime(_) => {}\n                     GenericArg::Type(ref ty) => {\n@@ -458,7 +441,7 @@ impl GenericArgs<'_> {\n         // presence of this method will be a constant reminder.\n         let mut own_counts: GenericParamCount = Default::default();\n \n-        for arg in &self.args {\n+        for arg in self.args {\n             match arg {\n                 GenericArg::Lifetime(_) => own_counts.lifetimes += 1,\n                 GenericArg::Type(_) => own_counts.types += 1,\n@@ -555,15 +538,15 @@ pub struct GenericParamCount {\n /// of a function, enum, trait, etc.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct Generics<'hir> {\n-    pub params: HirVec<GenericParam<'hir>>,\n+    pub params: &'hir [GenericParam<'hir>],\n     pub where_clause: WhereClause<'hir>,\n     pub span: Span,\n }\n \n impl Generics<'hir> {\n     pub const fn empty() -> Generics<'hir> {\n         Generics {\n-            params: HirVec::new(),\n+            params: &[],\n             where_clause: WhereClause { predicates: &[], span: DUMMY_SP },\n             span: DUMMY_SP,\n         }\n@@ -575,7 +558,7 @@ impl Generics<'hir> {\n         // presence of this method will be a constant reminder.\n         let mut own_counts: GenericParamCount = Default::default();\n \n-        for param in &self.params {\n+        for param in self.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => own_counts.lifetimes += 1,\n                 GenericParamKind::Type { .. } => own_counts.types += 1,\n@@ -587,7 +570,7 @@ impl Generics<'hir> {\n     }\n \n     pub fn get_named(&self, name: Symbol) -> Option<&GenericParam<'_>> {\n-        for param in &self.params {\n+        for param in self.params {\n             if name == param.name.ident().name {\n                 return Some(param);\n             }\n@@ -2128,7 +2111,7 @@ pub struct InlineAsmOutput {\n }\n \n // NOTE(eddyb) This is used within MIR as well, so unlike the rest of the HIR,\n-// it needs to be `Clone` and use plain `Vec<T>` instead of `HirVec<T>`.\n+// it needs to be `Clone` and use plain `Vec<T>` instead of arena-allocated slice.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable, PartialEq)]\n pub struct InlineAsmInner {\n     pub asm: Symbol,"}, {"sha": "ae760d22f751c2afac5ae9aa642e0dbaa025ec6d", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -10,7 +10,6 @@ use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n \n use crate::hir;\n-use crate::hir::HirVec;\n use crate::hir::{GenericArg, GenericParam, GenericParamKind};\n use crate::hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n \n@@ -2097,7 +2096,7 @@ impl<'a> State<'a> {\n             self.print_generic_params(generic_params);\n         }\n         let generics = hir::Generics {\n-            params: HirVec::new(),\n+            params: &[],\n             where_clause: hir::WhereClause { predicates: &[], span: syntax_pos::DUMMY_SP },\n             span: syntax_pos::DUMMY_SP,\n         };"}, {"sha": "b43817c9601b305b0053125f86444a3235df6962", "filename": "src/librustc/hir/ptr.rs", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a9dd56ff9a08d74c53d5cc22d18f126a12749608/src%2Flibrustc%2Fhir%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9dd56ff9a08d74c53d5cc22d18f126a12749608/src%2Flibrustc%2Fhir%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fptr.rs?ref=a9dd56ff9a08d74c53d5cc22d18f126a12749608", "patch": "@@ -1,128 +0,0 @@\n-// HACK(eddyb) this is a copy of `syntax::ptr`, minus the mutation (the HIR is\n-// frozen anyway). The only reason for doing this instead of replacing `P<T>`\n-// with `Box<T>` in HIR, is that `&Box<[T]>` doesn't implement `IntoIterator`.\n-\n-use std::fmt::{self, Debug, Display};\n-use std::iter::FromIterator;\n-use std::ops::Deref;\n-use std::{slice, vec};\n-\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-/// An owned smart pointer.\n-#[derive(PartialEq, Eq)]\n-pub struct P<T: ?Sized> {\n-    ptr: Box<T>,\n-}\n-\n-/// Construct a `P<T>` from a `T` value.\n-#[allow(non_snake_case)]\n-pub fn P<T: 'static>(value: T) -> P<T> {\n-    P { ptr: box value }\n-}\n-\n-impl<T: ?Sized> Deref for P<T> {\n-    type Target = T;\n-\n-    fn deref(&self) -> &T {\n-        &self.ptr\n-    }\n-}\n-\n-impl<T: ?Sized + Debug> Debug for P<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Debug::fmt(&self.ptr, f)\n-    }\n-}\n-\n-impl<T: Display> Display for P<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Display::fmt(&**self, f)\n-    }\n-}\n-\n-impl<T: 'static + Decodable> Decodable for P<T> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {\n-        Decodable::decode(d).map(P)\n-    }\n-}\n-\n-impl<T: Encodable> Encodable for P<T> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        (**self).encode(s)\n-    }\n-}\n-\n-impl<T> P<[T]> {\n-    pub const fn new() -> P<[T]> {\n-        // HACK(eddyb) bypass the lack of a `const fn` to create an empty `Box<[T]>`\n-        // (as trait methods, `default` in this case, can't be `const fn` yet).\n-        P {\n-            ptr: unsafe {\n-                use std::ptr::NonNull;\n-                std::mem::transmute(NonNull::<[T; 0]>::dangling() as NonNull<[T]>)\n-            },\n-        }\n-    }\n-\n-    #[inline(never)]\n-    pub fn from_vec(v: Vec<T>) -> P<[T]> {\n-        P { ptr: v.into_boxed_slice() }\n-    }\n-\n-    // HACK(eddyb) used by HIR lowering in a few places still.\n-    // NOTE: do not make this more public than `pub(super)`,\n-    // and do not make this into an `IntoIterator` impl.\n-    pub(super) fn into_iter(self) -> vec::IntoIter<T> {\n-        self.ptr.into_vec().into_iter()\n-    }\n-}\n-\n-impl<T> Default for P<[T]> {\n-    /// Creates an empty `P<[T]>`.\n-    fn default() -> P<[T]> {\n-        P::new()\n-    }\n-}\n-\n-impl<T> From<Vec<T>> for P<[T]> {\n-    fn from(v: Vec<T>) -> Self {\n-        P::from_vec(v)\n-    }\n-}\n-\n-impl<T> FromIterator<T> for P<[T]> {\n-    fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> P<[T]> {\n-        P::from_vec(iter.into_iter().collect())\n-    }\n-}\n-\n-impl<'a, T> IntoIterator for &'a P<[T]> {\n-    type Item = &'a T;\n-    type IntoIter = slice::Iter<'a, T>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.ptr.into_iter()\n-    }\n-}\n-\n-impl<T: Encodable> Encodable for P<[T]> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        Encodable::encode(&**self, s)\n-    }\n-}\n-\n-impl<T: Decodable> Decodable for P<[T]> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<P<[T]>, D::Error> {\n-        Ok(P::from_vec(Decodable::decode(d)?))\n-    }\n-}\n-\n-impl<CTX, T> HashStable<CTX> for P<T>\n-where\n-    T: ?Sized + HashStable<CTX>,\n-{\n-    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n-        (**self).hash_stable(hcx, hasher);\n-    }\n-}"}, {"sha": "4e7913b8dfc0e286aa472d08f7dc6408b78e62d1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -28,6 +28,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(arbitrary_self_types)]\n+#![feature(array_value_iter)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]"}, {"sha": "5f8a58636c083e5e8a866b379c8248b315f9956b", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -657,7 +657,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut elision = None;\n                 let mut lifetimes = FxHashMap::default();\n                 let mut non_lifetime_count = 0;\n-                for param in &generics.params {\n+                for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (name, reg) = Region::early(&self.tcx.hir(), &mut index, &param);\n@@ -899,7 +899,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n-        for param in &generics.params {\n+        for param in generics.params {\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => {}\n                 GenericParamKind::Type { ref default, .. } => {\n@@ -1996,7 +1996,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         debug!(\"visit_segment_args: object_lifetime_defaults={:?}\", object_lifetime_defaults);\n \n         let mut i = 0;\n-        for arg in &generic_args.args {\n+        for arg in generic_args.args {\n             match arg {\n                 GenericArg::Lifetime(_) => {}\n                 GenericArg::Type(ty) => {\n@@ -2789,7 +2789,7 @@ fn insert_late_bound_lifetimes(\n     let mut appears_in_where_clause = AllCollector::default();\n     appears_in_where_clause.visit_generics(generics);\n \n-    for param in &generics.params {\n+    for param in generics.params {\n         if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n             if !param.bounds.is_empty() {\n                 // `'a: 'b` means both `'a` and `'b` are referenced\n@@ -2809,7 +2809,7 @@ fn insert_late_bound_lifetimes(\n     // - appear in the inputs\n     // - do not appear in the where-clauses\n     // - are not implicitly captured by `impl Trait`\n-    for param in &generics.params {\n+    for param in generics.params {\n         match param.kind {\n             hir::GenericParamKind::Lifetime { .. } => { /* fall through */ }\n "}, {"sha": "9cf49f8ab4b09dc8acea517b2c5bd36b3ed2bea6", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -841,7 +841,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n         match it.kind {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n                 if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, sym::no_mangle) {\n-                    for param in &generics.params {\n+                    for param in generics.params {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n                             GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n@@ -1663,7 +1663,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n             let mut bound_count = 0;\n             let mut lint_spans = Vec::new();\n \n-            for param in &hir_generics.params {\n+            for param in hir_generics.params {\n                 let has_lifetime_bounds = param.bounds.iter().any(|bound| {\n                     if let hir::GenericBound::Outlives(_) = bound { true } else { false }\n                 });"}, {"sha": "b14c9c0eb590c96e8891e570e39ee6c7bf522427", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -1569,7 +1569,7 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_info_for_generics(&mut self, generics: &hir::Generics<'tcx>) {\n-        for param in &generics.params {\n+        for param in generics.params {\n             let def_id = self.tcx.hir().local_def_id(param.hir_id);\n             match param.kind {\n                 GenericParamKind::Lifetime { .. } => continue,"}, {"sha": "33a37ecb7f573ce3478e9a36aa48c3beb8c5faa1", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -619,7 +619,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         args: &'hir hir::GenericArgs<'hir>,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n     ) -> Option<&'hir hir::Lifetime> {\n-        for (kind, hir_arg) in substs.iter().zip(&args.args) {\n+        for (kind, hir_arg) in substs.iter().zip(args.args) {\n             match (kind.unpack(), hir_arg) {\n                 (GenericArgKind::Lifetime(r), hir::GenericArg::Lifetime(lt)) => {\n                     if r.to_region_vid() == needle_fr {"}, {"sha": "844bebdf7b87457d031c138a064b469d0e2968e3", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -1132,7 +1132,7 @@ fn create_mono_items_for_default_impls<'tcx>(\n ) {\n     match item.kind {\n         hir::ItemKind::Impl(_, _, _, ref generics, .., ref impl_item_refs) => {\n-            for param in &generics.params {\n+            for param in generics.params {\n                 match param.kind {\n                     hir::GenericParamKind::Lifetime { .. } => {}\n                     hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => {"}, {"sha": "d666c80b899e99e13d86e223d020945f80f90823", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -1653,7 +1653,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n-        for param in &generics.params {\n+        for param in generics.params {\n             for bound in param.bounds {\n                 self.check_generic_bound(bound);\n             }"}, {"sha": "569be6e1a55fddbafb263dc15563ff0a09769a9a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -5,8 +5,7 @@\n use crate::hir::def::{CtorOf, DefKind, Res};\n use crate::hir::def_id::DefId;\n use crate::hir::print;\n-use crate::hir::ptr::P;\n-use crate::hir::{self, ExprKind, GenericArg, GenericArgs, HirVec};\n+use crate::hir::{self, ExprKind, GenericArg, GenericArgs};\n use crate::lint;\n use crate::middle::lang_items::SizedTraitLangItem;\n use crate::middle::resolve_lifetime as rl;\n@@ -255,8 +254,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         seg: &hir::PathSegment<'_>,\n         is_method_call: bool,\n     ) -> bool {\n-        let empty_args =\n-            P(hir::GenericArgs { args: HirVec::new(), bindings: &[], parenthesized: false });\n+        let empty_args = hir::GenericArgs::none();\n         let suppress_mismatch = Self::check_impl_trait(tcx, seg, &def);\n         Self::check_generic_arg_count(\n             tcx,\n@@ -2278,7 +2276,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut has_err = false;\n         for segment in segments {\n             let (mut err_for_lt, mut err_for_ty, mut err_for_ct) = (false, false, false);\n-            for arg in &segment.generic_args().args {\n+            for arg in segment.generic_args().args {\n                 let (span, kind) = match arg {\n                     hir::GenericArg::Lifetime(lt) => {\n                         if err_for_lt {"}, {"sha": "552e6a57c1d25f789796baf471fe6c1863f0045a", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -54,7 +54,6 @@ use crate::check::{FnCtxt, Needs};\n use errors::DiagnosticBuilder;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::ptr::P;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::infer::{Coercion, InferOk, InferResult};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n@@ -1377,12 +1376,6 @@ impl AsCoercionSite for hir::Expr<'_> {\n     }\n }\n \n-impl AsCoercionSite for P<hir::Expr<'_>> {\n-    fn as_coercion_site(&self) -> &hir::Expr<'_> {\n-        self\n-    }\n-}\n-\n impl<'a, T> AsCoercionSite for &'a T\n where\n     T: AsCoercionSite,"}, {"sha": "b387a5d15201764f090dc37c0e0845b81151a65c", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -83,7 +83,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                 }\n                 Err(traits::OrphanCheckErr::UncoveredTy(param_ty, local_type)) => {\n                     let mut sp = sp;\n-                    for param in &generics.params {\n+                    for param in generics.params {\n                         if param.name.ident().to_string() == param_ty.to_string() {\n                             sp = param.span;\n                         }"}, {"sha": "1e3e6d77b9261103312a2f7a56fc88c40cbf5ef3", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -117,7 +117,7 @@ impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n-        for param in &generics.params {\n+        for param in generics.params {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n                 hir::GenericParamKind::Type { default: Some(_), .. } => {\n@@ -860,7 +860,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             outer_index: ty::INNERMOST,\n             has_late_bound_regions: None,\n         };\n-        for param in &generics.params {\n+        for param in generics.params {\n             if let GenericParamKind::Lifetime { .. } = param.kind {\n                 if tcx.is_late_bound(param.hir_id) {\n                     return Some(param.span);\n@@ -2102,7 +2102,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T: Foo>`).\n-    for param in &ast_generics.params {\n+    for param in ast_generics.params {\n         if let GenericParamKind::Type { .. } = param.kind {\n             let name = param.name.ident().name;\n             let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);"}, {"sha": "e12d9affdfabc8bba4a0965cb92167f6f61b68f9", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -474,7 +474,7 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.enter_resolver(|r| r.cstore().load_macro_untracked(did, cx.sess())) {\n         LoadedMacro::MacroDef(def, _) => {\n-            let matchers: hir::HirVec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.kind {\n+            let matchers: Vec<Span> = if let ast::ItemKind::MacroDef(ref def) = def.kind {\n                 let tts: Vec<_> = def.body.inner_tokens().into_trees().collect();\n                 tts.chunks(4).map(|arm| arm[0].span()).collect()\n             } else {"}, {"sha": "defdeb52186cbf5bff37cef866f4f2853a04385e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -12,7 +12,6 @@ pub mod utils;\n use rustc::hir;\n use rustc::hir::def::{CtorKind, DefKind, Res};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n-use rustc::hir::ptr::P;\n use rustc::infer::region_constraints::{Constraint, RegionConstraintData};\n use rustc::middle::lang_items;\n use rustc::middle::resolve_lifetime as rl;\n@@ -74,12 +73,6 @@ impl<T: Clean<U>, U> Clean<U> for &T {\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<U> for P<T> {\n-    fn clean(&self, cx: &DocContext<'_>) -> U {\n-        (**self).clean(cx)\n-    }\n-}\n-\n impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n     fn clean(&self, cx: &DocContext<'_>) -> U {\n         (**self).clean(cx)\n@@ -101,12 +94,6 @@ where\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Vec<U> {\n-        self.iter().map(|x| x.clean(cx)).collect()\n-    }\n-}\n-\n impl Clean<ExternalCrate> for CrateNum {\n     fn clean(&self, cx: &DocContext<'_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };"}, {"sha": "07a3f663145224236548ee0d67396d8a6b78e892", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d145c62888c853db0bcfd8f5b3a6919f15502/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=bf2d145c62888c853db0bcfd8f5b3a6919f15502", "patch": "@@ -230,7 +230,7 @@ pub struct Macro<'hir> {\n     pub def_id: hir::def_id::DefId,\n     pub attrs: &'hir [ast::Attribute],\n     pub whence: Span,\n-    pub matchers: hir::HirVec<Span>,\n+    pub matchers: Vec<Span>,\n     pub imported_from: Option<Name>,\n }\n "}]}