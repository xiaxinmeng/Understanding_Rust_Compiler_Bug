{"sha": "b858b7f4ced2acaabcf1d0f59abd4a0c4a62ded3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NThiN2Y0Y2VkMmFjYWFiY2YxZDBmNTlhYmQ0YTBjNGE2MmRlZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-02T02:48:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-02T02:48:53Z"}, "message": "Auto merge of #25015 - alexcrichton:rwlock-check-ret, r=aturon\n\nApparently implementations are allowed to return EDEADLK instead of blocking\r\nforever, in which case this can lead to unsafety in the `RwLock` primitive\r\nexposed by the standard library. A debug-build of the standard library would\r\nhave caught this error (due to the debug assert), but we don't ship debug\r\nbuilds right now.\r\n\r\nThis commit adds explicit checks for the EDEADLK error code and triggers a panic\r\nto ensure the call does not succeed.\r\n\r\nCloses #25012", "tree": {"sha": "1532e270de8b5ddf71a9dd072fe2348dd031e5a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1532e270de8b5ddf71a9dd072fe2348dd031e5a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b858b7f4ced2acaabcf1d0f59abd4a0c4a62ded3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b858b7f4ced2acaabcf1d0f59abd4a0c4a62ded3", "html_url": "https://github.com/rust-lang/rust/commit/b858b7f4ced2acaabcf1d0f59abd4a0c4a62ded3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b858b7f4ced2acaabcf1d0f59abd4a0c4a62ded3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c42c1e7a678a27bb63c24fb1eca2866af4e3ab7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c42c1e7a678a27bb63c24fb1eca2866af4e3ab7a", "html_url": "https://github.com/rust-lang/rust/commit/c42c1e7a678a27bb63c24fb1eca2866af4e3ab7a"}, {"sha": "5c8ca26ad7fd6bbe0e7d4f5ddc10a891b2e74512", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c8ca26ad7fd6bbe0e7d4f5ddc10a891b2e74512", "html_url": "https://github.com/rust-lang/rust/commit/5c8ca26ad7fd6bbe0e7d4f5ddc10a891b2e74512"}], "stats": {"total": 41, "additions": 29, "deletions": 12}, "files": [{"sha": "7bb9fb68c14f0a4217ca2da3c6c590f65608d838", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b858b7f4ced2acaabcf1d0f59abd4a0c4a62ded3/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b858b7f4ced2acaabcf1d0f59abd4a0c4a62ded3/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=b858b7f4ced2acaabcf1d0f59abd4a0c4a62ded3", "patch": "@@ -10,6 +10,7 @@\n \n use prelude::v1::*;\n \n+use libc;\n use cell::UnsafeCell;\n use sys::sync as ffi;\n \n@@ -26,7 +27,23 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn read(&self) {\n         let r = ffi::pthread_rwlock_rdlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n+\n+        // According to the pthread_rwlock_rdlock spec, this function **may**\n+        // fail with EDEADLK if a deadlock is detected. On the other hand\n+        // pthread mutexes will *never* return EDEADLK if they are initialized\n+        // as the \"fast\" kind (which ours always are). As a result, a deadlock\n+        // situation may actually return from the call to pthread_rwlock_rdlock\n+        // instead of blocking forever (as mutexes and Windows rwlocks do). Note\n+        // that not all unix implementations, however, will return EDEADLK for\n+        // their rwlocks.\n+        //\n+        // We roughly maintain the deadlocking behavior by panicking to ensure\n+        // that this lock acquisition does not succeed.\n+        if r == libc::EDEADLK {\n+            panic!(\"rwlock read lock would result in deadlock\");\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n@@ -35,7 +52,12 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn write(&self) {\n         let r = ffi::pthread_rwlock_wrlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n+        // see comments above for why we check for EDEADLK\n+        if r == libc::EDEADLK {\n+            panic!(\"rwlock write lock would result in deadlock\");\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n@@ -49,21 +71,16 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn write_unlock(&self) { self.read_unlock() }\n     #[inline]\n-    #[cfg(not(target_os = \"dragonfly\"))]\n-    pub unsafe fn destroy(&self) {\n-        let r = ffi::pthread_rwlock_destroy(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    #[cfg(target_os = \"dragonfly\")]\n     pub unsafe fn destroy(&self) {\n-        use libc;\n         let r = ffi::pthread_rwlock_destroy(self.inner.get());\n         // On DragonFly pthread_rwlock_destroy() returns EINVAL if called on a\n         // rwlock that was just initialized with\n         // ffi::PTHREAD_RWLOCK_INITIALIZER. Once it is used (locked/unlocked)\n         // or pthread_rwlock_init() is called, this behaviour no longer occurs.\n-        debug_assert!(r == 0 || r == libc::EINVAL);\n+        if cfg!(target_os = \"dragonfly\") {\n+            debug_assert!(r == 0 || r == libc::EINVAL);\n+        } else {\n+            debug_assert_eq!(r, 0);\n+        }\n     }\n }"}]}