{"sha": "03eb75f759a0c027d07b7d6460f630a373b03638", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZWI3NWY3NTlhMGMwMjdkMDdiN2Q2NDYwZjYzMGEzNzNiMDM2Mzg=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-22T18:38:48Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-22T22:12:57Z"}, "message": "rustc_query_system: avoid race condition when using edge_count", "tree": {"sha": "d00ed6ac647ca282fb444e091c80e61d403efbc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d00ed6ac647ca282fb444e091c80e61d403efbc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03eb75f759a0c027d07b7d6460f630a373b03638", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03eb75f759a0c027d07b7d6460f630a373b03638", "html_url": "https://github.com/rust-lang/rust/commit/03eb75f759a0c027d07b7d6460f630a373b03638", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03eb75f759a0c027d07b7d6460f630a373b03638/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22ed75158bd1ef32d1ba08a58b56f2608c105c0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/22ed75158bd1ef32d1ba08a58b56f2608c105c0d", "html_url": "https://github.com/rust-lang/rust/commit/22ed75158bd1ef32d1ba08a58b56f2608c105c0d"}], "stats": {"total": 17, "additions": 6, "deletions": 11}, "files": [{"sha": "605d7ae4af67832eae5f495fad624add4ce0811f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/03eb75f759a0c027d07b7d6460f630a373b03638/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03eb75f759a0c027d07b7d6460f630a373b03638/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=03eb75f759a0c027d07b7d6460f630a373b03638", "patch": "@@ -3,7 +3,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::QueryInvocationId;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n+use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, LockGuard, Lrc, Ordering};\n use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -135,16 +135,14 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     pub fn query(&self) -> DepGraphQuery<K> {\n-        // We call this before acquiring locks, since it also acquires them.\n-        // The extra locking is not a big deal, as this gets called rarely.\n-        let edge_count = self.edge_count();\n         let data = self.data.as_ref().unwrap();\n         let previous = &data.previous;\n \n         // Note locking order: `prev_index_to_index`, then `data`.\n         let prev_index_to_index = data.current.prev_index_to_index.lock();\n         let data = data.current.data.lock();\n         let node_count = data.hybrid_indices.len();\n+        let edge_count = self.edge_count(&data);\n \n         let mut nodes = Vec::with_capacity(node_count);\n         let mut edge_list_indices = Vec::with_capacity(node_count);\n@@ -566,14 +564,13 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n-    fn edge_count(&self) -> usize {\n+    fn edge_count(&self, node_data: &LockGuard<'_, DepNodeData<K>>) -> usize {\n         let data = self.data.as_ref().unwrap();\n         let previous = &data.previous;\n-        let data = data.current.data.lock();\n \n-        let mut edge_count = data.unshared_edges.len();\n+        let mut edge_count = node_data.unshared_edges.len();\n \n-        for &hybrid_index in data.hybrid_indices.iter() {\n+        for &hybrid_index in node_data.hybrid_indices.iter() {\n             if let HybridIndex::DarkGreen(prev_index) = hybrid_index.into() {\n                 edge_count += previous.edge_targets_from(prev_index).len()\n             }\n@@ -585,16 +582,14 @@ impl<K: DepKind> DepGraph<K> {\n     pub fn serialize(&self) -> SerializedDepGraph<K> {\n         type SDNI = SerializedDepNodeIndex;\n \n-        // We call this before acquiring locks, since it also acquires them.\n-        // The extra locking is not a big deal, as this only gets called once.\n-        let edge_count = self.edge_count();\n         let data = self.data.as_ref().unwrap();\n         let previous = &data.previous;\n \n         // Note locking order: `prev_index_to_index`, then `data`.\n         let prev_index_to_index = data.current.prev_index_to_index.lock();\n         let data = data.current.data.lock();\n         let node_count = data.hybrid_indices.len();\n+        let edge_count = self.edge_count(&data);\n \n         let mut nodes = IndexVec::with_capacity(node_count);\n         let mut fingerprints = IndexVec::with_capacity(node_count);"}]}