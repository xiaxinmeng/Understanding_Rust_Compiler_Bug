{"sha": "8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "node_id": "C_kwDOAAsO6NoAKDhjYTQ3ZDdhZTRlMDY4Yzk0YjRhYjdiMjVjYzBjY2MzOGQwMWQ1MmM", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-02-21T07:25:18Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2022-02-21T08:54:02Z"}, "message": "Stop manually SIMDing in swap_nonoverlapping\n\nLike I previously did for `reverse`, this leaves it to LLVM to pick how to vectorize it, since it can know better the chunk size to use, compared to the \"32 bytes always\" approach we currently have.\n\nIt does still need logic to type-erase where appropriate, though, as while LLVM is now smart enough to vectorize over slices of things like `[u8; 4]`, it fails to do so over slices of `[u8; 3]`.\n\nAs a bonus, this also means one no longer gets the spurious `memcpy`(s?) at the end up swapping a slice of `__m256`s: <https://rust.godbolt.org/z/joofr4v8Y>", "tree": {"sha": "60de7dd6dc79daf75dd18b25ec5d92ea44a85222", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60de7dd6dc79daf75dd18b25ec5d92ea44a85222"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "html_url": "https://github.com/rust-lang/rust/commit/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73a7423e77b49a99e270531fbadda5b8899df3f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/73a7423e77b49a99e270531fbadda5b8899df3f6", "html_url": "https://github.com/rust-lang/rust/commit/73a7423e77b49a99e270531fbadda5b8899df3f6"}], "stats": {"total": 360, "additions": 263, "deletions": 97}, "files": [{"sha": "9b86a0ca97c09e266ea89b1c2b80e12078e2ecf7", "filename": "library/core/benches/slice.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/library%2Fcore%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/library%2Fcore%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fslice.rs?ref=8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "patch": "@@ -89,6 +89,15 @@ fn binary_search_l3_worst_case(b: &mut Bencher) {\n     binary_search_worst_case(b, Cache::L3);\n }\n \n+#[derive(Clone)]\n+struct Rgb(u8, u8, u8);\n+\n+impl Rgb {\n+    fn gen(i: usize) -> Self {\n+        Rgb(i as u8, (i as u8).wrapping_add(7), (i as u8).wrapping_add(42))\n+    }\n+}\n+\n macro_rules! rotate {\n     ($fn:ident, $n:expr, $mapper:expr) => {\n         #[bench]\n@@ -104,17 +113,43 @@ macro_rules! rotate {\n     };\n }\n \n-#[derive(Clone)]\n-struct Rgb(u8, u8, u8);\n-\n rotate!(rotate_u8, 32, |i| i as u8);\n-rotate!(rotate_rgb, 32, |i| Rgb(i as u8, (i as u8).wrapping_add(7), (i as u8).wrapping_add(42)));\n+rotate!(rotate_rgb, 32, Rgb::gen);\n rotate!(rotate_usize, 32, |i| i);\n rotate!(rotate_16_usize_4, 16, |i| [i; 4]);\n rotate!(rotate_16_usize_5, 16, |i| [i; 5]);\n rotate!(rotate_64_usize_4, 64, |i| [i; 4]);\n rotate!(rotate_64_usize_5, 64, |i| [i; 5]);\n \n+macro_rules! swap_with_slice {\n+    ($fn:ident, $n:expr, $mapper:expr) => {\n+        #[bench]\n+        fn $fn(b: &mut Bencher) {\n+            let mut x = (0usize..$n).map(&$mapper).collect::<Vec<_>>();\n+            let mut y = ($n..($n * 2)).map(&$mapper).collect::<Vec<_>>();\n+            let mut skip = 0;\n+            b.iter(|| {\n+                for _ in 0..32 {\n+                    x[skip..].swap_with_slice(&mut y[..($n - skip)]);\n+                    skip = black_box(skip + 1) % 8;\n+                }\n+                black_box((x[$n / 3].clone(), y[$n * 2 / 3].clone()))\n+            })\n+        }\n+    };\n+}\n+\n+swap_with_slice!(swap_with_slice_u8_30, 30, |i| i as u8);\n+swap_with_slice!(swap_with_slice_u8_3000, 3000, |i| i as u8);\n+swap_with_slice!(swap_with_slice_rgb_30, 30, Rgb::gen);\n+swap_with_slice!(swap_with_slice_rgb_3000, 3000, Rgb::gen);\n+swap_with_slice!(swap_with_slice_usize_30, 30, |i| i);\n+swap_with_slice!(swap_with_slice_usize_3000, 3000, |i| i);\n+swap_with_slice!(swap_with_slice_4x_usize_30, 30, |i| [i; 4]);\n+swap_with_slice!(swap_with_slice_4x_usize_3000, 3000, |i| [i; 4]);\n+swap_with_slice!(swap_with_slice_5x_usize_30, 30, |i| [i; 5]);\n+swap_with_slice!(swap_with_slice_5x_usize_3000, 3000, |i| [i; 5]);\n+\n #[bench]\n fn fill_byte_sized(b: &mut Bencher) {\n     #[derive(Copy, Clone)]"}, {"sha": "b5c1ae37e5e89091047e583cd43217697c50c275", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 42, "deletions": 3, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "patch": "@@ -700,10 +700,49 @@ pub unsafe fn uninitialized<T>() -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n pub const fn swap<T>(x: &mut T, y: &mut T) {\n-    // SAFETY: the raw pointers have been created from safe mutable references satisfying all the\n-    // constraints on `ptr::swap_nonoverlapping_one`\n+    // NOTE(eddyb) SPIR-V's Logical addressing model doesn't allow for arbitrary\n+    // reinterpretation of values as (chunkable) byte arrays, and the loop in the\n+    // block optimization in `swap_slice` is hard to rewrite back\n+    // into the (unoptimized) direct swapping implementation, so we disable it.\n+    // FIXME(eddyb) the block optimization also prevents MIR optimizations from\n+    // understanding `mem::replace`, `Option::take`, etc. - a better overall\n+    // solution might be to make `ptr::swap_nonoverlapping` into an intrinsic, which\n+    // a backend can choose to implement using the block optimization, or not.\n+    #[cfg(not(target_arch = \"spirv\"))]\n+    {\n+        // For types that are larger multiples of their alignment, the simple way\n+        // tends to copy the whole thing to stack rather than doing it one part\n+        // at a time, so instead treat them as one-element slices and piggy-back\n+        // the slice optimizations that will split up the swaps.\n+        if size_of::<T>() / align_of::<T>() > 4 {\n+            // SAFETY: exclusive references always point to one non-overlapping\n+            // element and are non-null and properly aligned.\n+            return unsafe { ptr::swap_nonoverlapping(x, y, 1) };\n+        }\n+    }\n+\n+    // If a scalar consists of just a small number of alignment units, let\n+    // the codegen just swap those pieces directly, as it's likely just a\n+    // few instructions and anything else is probably overcomplicated.\n+    //\n+    // Most importantly, this covers primitives and simd types that tend to\n+    // have size=align where doing anything else can be a pessimization.\n+    // (This will also be used for ZSTs, though any solution works for them.)\n+    swap_simple(x, y);\n+}\n+\n+/// Same as [`swap`] semantically, but always uses the simple implementation.\n+///\n+/// Used elsewhere in `mem` and `ptr` at the bottom layer of calls.\n+#[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n+#[inline]\n+pub(crate) const fn swap_simple<T>(x: &mut T, y: &mut T) {\n+    // SAFETY: exclusive references are always valid to read/write,\n+    // are non-overlapping, and nothing here panics so it's drop-safe.\n     unsafe {\n-        ptr::swap_nonoverlapping_one(x, y);\n+        let z = ptr::read(x);\n+        ptr::copy_nonoverlapping(y, x, 1);\n+        ptr::write(y, z);\n     }\n }\n "}, {"sha": "ff71fadb614182e942ce9a2d1a93a4916c211ecb", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 42, "deletions": 90, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "patch": "@@ -419,106 +419,58 @@ pub const unsafe fn swap<T>(x: *mut T, y: *mut T) {\n #[stable(feature = \"swap_nonoverlapping\", since = \"1.27.0\")]\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n-    let x = x as *mut u8;\n-    let y = y as *mut u8;\n-    let len = mem::size_of::<T>() * count;\n-    // SAFETY: the caller must guarantee that `x` and `y` are\n-    // valid for writes and properly aligned.\n-    unsafe { swap_nonoverlapping_bytes(x, y, len) }\n-}\n+    macro_rules! attempt_swap_as_chunks {\n+        ($ChunkTy:ty) => {\n+            if mem::align_of::<T>() >= mem::align_of::<$ChunkTy>()\n+                && mem::size_of::<T>() % mem::size_of::<$ChunkTy>() == 0\n+            {\n+                let x: *mut MaybeUninit<$ChunkTy> = x.cast();\n+                let y: *mut MaybeUninit<$ChunkTy> = y.cast();\n+                let count = count * (mem::size_of::<T>() / mem::size_of::<$ChunkTy>());\n+                // SAFETY: these are the same bytes that the caller promised were\n+                // ok, just typed as `MaybeUninit<ChunkTy>`s instead of as `T`s.\n+                // The `if` condition above ensures that we're not violating\n+                // alignment requirements, and that the division is exact so\n+                // that we don't lose any bytes off the end.\n+                return unsafe { swap_nonoverlapping_simple(x, y, count) };\n+            }\n+        };\n+    }\n \n-#[inline]\n-#[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n-pub(crate) const unsafe fn swap_nonoverlapping_one<T>(x: *mut T, y: *mut T) {\n-    // NOTE(eddyb) SPIR-V's Logical addressing model doesn't allow for arbitrary\n-    // reinterpretation of values as (chunkable) byte arrays, and the loop in the\n-    // block optimization in `swap_nonoverlapping_bytes` is hard to rewrite back\n-    // into the (unoptimized) direct swapping implementation, so we disable it.\n-    // FIXME(eddyb) the block optimization also prevents MIR optimizations from\n-    // understanding `mem::replace`, `Option::take`, etc. - a better overall\n-    // solution might be to make `swap_nonoverlapping` into an intrinsic, which\n-    // a backend can choose to implement using the block optimization, or not.\n-    #[cfg(not(target_arch = \"spirv\"))]\n+    // Split up the slice into small power-of-two-sized chunks that LLVM is able\n+    // to vectorize (unless it's a special type with more-than-pointer alignment,\n+    // because we don't want to pessimize things like slices of SIMD vectors.)\n+    if mem::align_of::<T>() <= mem::size_of::<usize>()\n+        && (!mem::size_of::<T>().is_power_of_two()\n+            || mem::size_of::<T>() > mem::size_of::<usize>() * 2)\n     {\n-        // Only apply the block optimization in `swap_nonoverlapping_bytes` for types\n-        // at least as large as the block size, to avoid pessimizing codegen.\n-        if mem::size_of::<T>() >= 32 {\n-            // SAFETY: the caller must uphold the safety contract for `swap_nonoverlapping`.\n-            unsafe { swap_nonoverlapping(x, y, 1) };\n-            return;\n-        }\n+        attempt_swap_as_chunks!(usize);\n+        attempt_swap_as_chunks!(u8);\n     }\n \n-    // Direct swapping, for the cases not going through the block optimization.\n-    // SAFETY: the caller must guarantee that `x` and `y` are valid\n-    // for writes, properly aligned, and non-overlapping.\n-    unsafe {\n-        let z = read(x);\n-        copy_nonoverlapping(y, x, 1);\n-        write(y, z);\n-    }\n+    // SAFETY: Same preconditions as this function\n+    unsafe { swap_nonoverlapping_simple(x, y, count) }\n }\n \n+/// Same behaviour and safety conditions as [`swap_nonoverlapping`]\n+///\n+/// LLVM can vectorize this (at least it can for the power-of-two-sized types\n+/// `swap_nonoverlapping` tries to use) so no need to manually SIMD it.\n #[inline]\n #[rustc_const_unstable(feature = \"const_swap\", issue = \"83163\")]\n-const unsafe fn swap_nonoverlapping_bytes(x: *mut u8, y: *mut u8, len: usize) {\n-    // The approach here is to utilize simd to swap x & y efficiently. Testing reveals\n-    // that swapping either 32 bytes or 64 bytes at a time is most efficient for Intel\n-    // Haswell E processors. LLVM is more able to optimize if we give a struct a\n-    // #[repr(simd)], even if we don't actually use this struct directly.\n-    //\n-    // FIXME repr(simd) broken on emscripten and redox\n-    #[cfg_attr(not(any(target_os = \"emscripten\", target_os = \"redox\")), repr(simd))]\n-    struct Block(u64, u64, u64, u64);\n-    struct UnalignedBlock(u64, u64, u64, u64);\n-\n-    let block_size = mem::size_of::<Block>();\n-\n-    // Loop through x & y, copying them `Block` at a time\n-    // The optimizer should unroll the loop fully for most types\n-    // N.B. We can't use a for loop as the `range` impl calls `mem::swap` recursively\n+const unsafe fn swap_nonoverlapping_simple<T>(x: *mut T, y: *mut T, count: usize) {\n     let mut i = 0;\n-    while i + block_size <= len {\n-        // Create some uninitialized memory as scratch space\n-        // Declaring `t` here avoids aligning the stack when this loop is unused\n-        let mut t = mem::MaybeUninit::<Block>::uninit();\n-        let t = t.as_mut_ptr() as *mut u8;\n-\n-        // SAFETY: As `i < len`, and as the caller must guarantee that `x` and `y` are valid\n-        // for `len` bytes, `x + i` and `y + i` must be valid addresses, which fulfills the\n-        // safety contract for `add`.\n-        //\n-        // Also, the caller must guarantee that `x` and `y` are valid for writes, properly aligned,\n-        // and non-overlapping, which fulfills the safety contract for `copy_nonoverlapping`.\n-        unsafe {\n-            let x = x.add(i);\n-            let y = y.add(i);\n+    while i < count {\n+        let x: &mut T =\n+            // SAFETY: By precondition, `i` is in-bounds because it's below `n`\n+            unsafe { &mut *x.add(i) };\n+        let y: &mut T =\n+            // SAFETY: By precondition, `i` is in-bounds because it's below `n`\n+            // and it's distinct from `x` since the ranges are non-overlapping\n+            unsafe { &mut *y.add(i) };\n+        mem::swap_simple(x, y);\n \n-            // Swap a block of bytes of x & y, using t as a temporary buffer\n-            // This should be optimized into efficient SIMD operations where available\n-            copy_nonoverlapping(x, t, block_size);\n-            copy_nonoverlapping(y, x, block_size);\n-            copy_nonoverlapping(t, y, block_size);\n-        }\n-        i += block_size;\n-    }\n-\n-    if i < len {\n-        // Swap any remaining bytes\n-        let mut t = mem::MaybeUninit::<UnalignedBlock>::uninit();\n-        let rem = len - i;\n-\n-        let t = t.as_mut_ptr() as *mut u8;\n-\n-        // SAFETY: see previous safety comment.\n-        unsafe {\n-            let x = x.add(i);\n-            let y = y.add(i);\n-\n-            copy_nonoverlapping(x, t, rem);\n-            copy_nonoverlapping(y, x, rem);\n-            copy_nonoverlapping(t, y, rem);\n-        }\n+        i += 1;\n     }\n }\n "}, {"sha": "535d301a3d27b0be6185fac195eba70c78954f2f", "filename": "src/test/codegen/swap-large-types.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/src%2Ftest%2Fcodegen%2Fswap-large-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/src%2Ftest%2Fcodegen%2Fswap-large-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fswap-large-types.rs?ref=8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "patch": "@@ -0,0 +1,64 @@\n+// compile-flags: -O\n+// only-x86_64\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+\n+use std::mem::swap;\n+use std::ptr::{read, copy_nonoverlapping, write};\n+\n+type KeccakBuffer = [[u64; 5]; 5];\n+\n+// A basic read+copy+write swap implementation ends up copying one of the values\n+// to stack for large types, which is completely unnecessary as the lack of\n+// overlap means we can just do whatever fits in registers at a time.\n+\n+// CHECK-LABEL: @swap_basic\n+#[no_mangle]\n+pub fn swap_basic(x: &mut KeccakBuffer, y: &mut KeccakBuffer) {\n+// CHECK: alloca [5 x [5 x i64]]\n+\n+    // SAFETY: exclusive references are always valid to read/write,\n+    // are non-overlapping, and nothing here panics so it's drop-safe.\n+    unsafe {\n+        let z = read(x);\n+        copy_nonoverlapping(y, x, 1);\n+        write(y, z);\n+    }\n+}\n+\n+// This test verifies that the library does something smarter, and thus\n+// doesn't need any scratch space on the stack.\n+\n+// CHECK-LABEL: @swap_std\n+#[no_mangle]\n+pub fn swap_std(x: &mut KeccakBuffer, y: &mut KeccakBuffer) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i64>\n+// CHECK: store <{{[0-9]+}} x i64>\n+    swap(x, y)\n+}\n+\n+// CHECK-LABEL: @swap_slice\n+#[no_mangle]\n+pub fn swap_slice(x: &mut [KeccakBuffer], y: &mut [KeccakBuffer]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i64>\n+// CHECK: store <{{[0-9]+}} x i64>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}\n+\n+type OneKilobyteBuffer = [u8; 1024];\n+\n+// CHECK-LABEL: @swap_1kb_slices\n+#[no_mangle]\n+pub fn swap_1kb_slices(x: &mut [OneKilobyteBuffer], y: &mut [OneKilobyteBuffer]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i8>\n+// CHECK: store <{{[0-9]+}} x i8>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}"}, {"sha": "c90b277eb44876fc4954399093401661f423f3b0", "filename": "src/test/codegen/swap-simd-types.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/src%2Ftest%2Fcodegen%2Fswap-simd-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/src%2Ftest%2Fcodegen%2Fswap-simd-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fswap-simd-types.rs?ref=8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "patch": "@@ -0,0 +1,32 @@\n+// compile-flags: -O -C target-feature=+avx\n+// only-x86_64\n+// ignore-debug: the debug assertions get in the way\n+\n+#![crate_type = \"lib\"]\n+\n+use std::mem::swap;\n+\n+// SIMD types are highly-aligned already, so make sure the swap code leaves their\n+// types alone and doesn't pessimize them (such as by swapping them as `usize`s).\n+extern crate core;\n+use core::arch::x86_64::__m256;\n+\n+// CHECK-LABEL: @swap_single_m256\n+#[no_mangle]\n+pub fn swap_single_m256(x: &mut __m256, y: &mut __m256) {\n+// CHECK-NOT: alloca\n+// CHECK: load <8 x float>{{.+}}align 32\n+// CHECK: store <8 x float>{{.+}}align 32\n+    swap(x, y)\n+}\n+\n+// CHECK-LABEL: @swap_m256_slice\n+#[no_mangle]\n+pub fn swap_m256_slice(x: &mut [__m256], y: &mut [__m256]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <8 x float>{{.+}}align 32\n+// CHECK: store <8 x float>{{.+}}align 32\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}"}, {"sha": "2f375844cc7166dfcb725d0020684dd5e5093698", "filename": "src/test/codegen/swap-small-types.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/src%2Ftest%2Fcodegen%2Fswap-small-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c/src%2Ftest%2Fcodegen%2Fswap-small-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fswap-small-types.rs?ref=8ca47d7ae4e068c94b4ab7b25cc0ccc38d01d52c", "patch": "@@ -16,3 +16,47 @@ pub fn swap_rgb48(x: &mut RGB48, y: &mut RGB48) {\n // CHECK: store i48\n     swap(x, y)\n }\n+\n+// LLVM doesn't vectorize a loop over 3-byte elements,\n+// so we chunk it down to bytes and loop over those instead.\n+type RGB24 = [u8; 3];\n+\n+// CHECK-LABEL: @swap_rgb24_slices\n+#[no_mangle]\n+pub fn swap_rgb24_slices(x: &mut [RGB24], y: &mut [RGB24]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i8>\n+// CHECK: store <{{[0-9]+}} x i8>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}\n+\n+// This one has a power-of-two size, so we iterate over it directly\n+type RGBA32 = [u8; 4];\n+\n+// CHECK-LABEL: @swap_rgba32_slices\n+#[no_mangle]\n+pub fn swap_rgba32_slices(x: &mut [RGBA32], y: &mut [RGBA32]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i32>\n+// CHECK: store <{{[0-9]+}} x i32>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}\n+\n+// Strings have a non-power-of-two size, but have pointer alignment,\n+// so we swap usizes instead of dropping all the way down to bytes.\n+const _: () = assert!(!std::mem::size_of::<String>().is_power_of_two());\n+\n+// CHECK-LABEL: @swap_string_slices\n+#[no_mangle]\n+pub fn swap_string_slices(x: &mut [String], y: &mut [String]) {\n+// CHECK-NOT: alloca\n+// CHECK: load <{{[0-9]+}} x i64>\n+// CHECK: store <{{[0-9]+}} x i64>\n+    if x.len() == y.len() {\n+        x.swap_with_slice(y);\n+    }\n+}"}]}