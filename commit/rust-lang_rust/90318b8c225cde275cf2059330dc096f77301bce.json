{"sha": "90318b8c225cde275cf2059330dc096f77301bce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwMzE4YjhjMjI1Y2RlMjc1Y2YyMDU5MzMwZGMwOTZmNzczMDFiY2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-25T15:13:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-25T15:13:22Z"}, "message": "Auto merge of #32258 - nikomatsakis:fewer-errors, r=arielb1\n\nSuppress fallback and ambiguity errors\n\nIf the infcx has observed other errors, then suppress both default type\nparameter fallback (which can be unreliable, as the full constraint set\nis not available) and errors related to unresovled\nvariables (annoyingly, integer type variables cannot currently be\nunified with error, so that has to be a separate mechanism). Also add a\nflag to `infcx` to allow us to independently indicate when we have\nobserved an error and hence should trigger this suppression mode.\n\nFixes #31997\n\ncc @alexcrichton\nr? @arielb1", "tree": {"sha": "6a5a5708d0fb4b45d09f90053cfbae877902e158", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a5a5708d0fb4b45d09f90053cfbae877902e158"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90318b8c225cde275cf2059330dc096f77301bce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90318b8c225cde275cf2059330dc096f77301bce", "html_url": "https://github.com/rust-lang/rust/commit/90318b8c225cde275cf2059330dc096f77301bce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90318b8c225cde275cf2059330dc096f77301bce/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfae4dea875ddcc5f23481106a149ea15b6be1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfae4dea875ddcc5f23481106a149ea15b6be1e5", "html_url": "https://github.com/rust-lang/rust/commit/cfae4dea875ddcc5f23481106a149ea15b6be1e5"}, {"sha": "b3d54a2c0e793768cd9ce4a7887a75e3ec356cb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3d54a2c0e793768cd9ce4a7887a75e3ec356cb5", "html_url": "https://github.com/rust-lang/rust/commit/b3d54a2c0e793768cd9ce4a7887a75e3ec356cb5"}], "stats": {"total": 447, "additions": 348, "deletions": 99}, "files": [{"sha": "312a446d44091102524bc20a78bda12400856b53", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 46, "deletions": 5, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -35,7 +35,7 @@ use ty::fold::TypeFoldable;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{RefCell, Ref};\n+use std::cell::{Cell, RefCell, Ref};\n use std::fmt;\n use syntax::ast;\n use syntax::codemap;\n@@ -110,6 +110,25 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     // documentation for `ProjectionMode`.\n     projection_mode: ProjectionMode,\n \n+    // When an error occurs, we want to avoid reporting \"derived\"\n+    // errors that are due to this original failure. Normally, we\n+    // handle this with the `err_count_on_creation` count, which\n+    // basically just tracks how many errors were reported when we\n+    // started type-checking a fn and checks to see if any new errors\n+    // have been reported since then. Not great, but it works.\n+    //\n+    // However, when errors originated in other passes -- notably\n+    // resolve -- this heuristic breaks down. Therefore, we have this\n+    // auxiliary flag that one can set whenever one creates a\n+    // type-error that is due to an error in a prior pass.\n+    //\n+    // Don't read this flag directly, call `is_tainted_by_errors()`\n+    // and `set_tainted_by_errors()`.\n+    tainted_by_errors_flag: Cell<bool>,\n+\n+    // Track how many errors were reported when this infcx is created.\n+    // If the number of errors increases, that's also a sign (line\n+    // `tained_by_errors`) to avoid reporting certain kinds of errors.\n     err_count_on_creation: usize,\n }\n \n@@ -379,6 +398,7 @@ pub fn new_infer_ctxt<'a, 'tcx>(tcx: &'a TyCtxt<'tcx>,\n         reported_trait_errors: RefCell::new(FnvHashSet()),\n         normalize: false,\n         projection_mode: projection_mode,\n+        tainted_by_errors_flag: Cell::new(false),\n         err_count_on_creation: tcx.sess.err_count()\n     }\n }\n@@ -1128,15 +1148,36 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                         .map(|method| resolve_ty(method.ty)))\n     }\n \n-    pub fn errors_since_creation(&self) -> bool {\n-        self.tcx.sess.err_count() - self.err_count_on_creation != 0\n+    /// True if errors have been reported since this infcx was\n+    /// created.  This is sometimes used as a heuristic to skip\n+    /// reporting errors that often occur as a result of earlier\n+    /// errors, but where it's hard to be 100% sure (e.g., unresolved\n+    /// inference variables, regionck errors).\n+    pub fn is_tainted_by_errors(&self) -> bool {\n+        debug!(\"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n+                tainted_by_errors_flag={})\",\n+               self.tcx.sess.err_count(),\n+               self.err_count_on_creation,\n+               self.tainted_by_errors_flag.get());\n+\n+        if self.tcx.sess.err_count() > self.err_count_on_creation {\n+            return true; // errors reported since this infcx was made\n+        }\n+        self.tainted_by_errors_flag.get()\n+    }\n+\n+    /// Set the \"tainted by errors\" flag to true. We call this when we\n+    /// observe an error from a prior pass.\n+    pub fn set_tainted_by_errors(&self) {\n+        debug!(\"set_tainted_by_errors()\");\n+        self.tainted_by_errors_flag.set(true)\n     }\n \n     pub fn node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n         match self.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n             // FIXME\n-            None if self.errors_since_creation() =>\n+            None if self.is_tainted_by_errors() =>\n                 self.tcx.types.err,\n             None => {\n                 bug!(\"no type for node {}: {} in fcx\",\n@@ -1158,7 +1199,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                              free_regions: &FreeRegionMap,\n                                              subject_node_id: ast::NodeId) {\n         let errors = self.region_vars.resolve_regions(free_regions, subject_node_id);\n-        if !self.errors_since_creation() {\n+        if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while\n             // this infcx was in use.  This is totally hokey but"}, {"sha": "71e1efe220f03bf142f12601b473a25547791f91", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -91,6 +91,7 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n             }\n \n             (&ty::TyError, _) | (_, &ty::TyError) => {\n+                infcx.set_tainted_by_errors();\n                 Ok(self.tcx().types.err)\n             }\n "}, {"sha": "d7ddfc9f1a6d0e26d8057d8806eefef9bfc4c863", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -624,6 +624,12 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n            predicate,\n            obligation);\n \n+    // Ambiguity errors are often caused as fallout from earlier\n+    // errors. So just ignore them if this infcx is tainted.\n+    if infcx.is_tainted_by_errors() {\n+        return;\n+    }\n+\n     match predicate {\n         ty::Predicate::Trait(ref data) => {\n             let trait_ref = data.to_poly_trait_ref();"}, {"sha": "1110e193e579b7f20fe9718820b4108d8593afaf", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -155,6 +155,12 @@ pub trait AstConv<'tcx> {\n                     _trait_ref: ty::TraitRef<'tcx>,\n                     _item_name: ast::Name)\n                     -> Ty<'tcx>;\n+\n+    /// Invoked when we encounter an error from some prior pass\n+    /// (e.g. resolve) that is translated into a ty-error. This is\n+    /// used to help suppress derived errors typeck might otherwise\n+    /// report.\n+    fn set_tainted_by_errors(&self);\n }\n \n pub fn ast_region_to_region(tcx: &TyCtxt, lifetime: &hir::Lifetime)\n@@ -1533,6 +1539,7 @@ fn base_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n             prim_ty_to_ty(tcx, base_segments, prim_ty)\n         }\n         Def::Err => {\n+            this.set_tainted_by_errors();\n             return this.tcx().types.err;\n         }\n         _ => {"}, {"sha": "a7a04f4a85fe89f4c3e37397cd2581cfb7f969e7", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -209,6 +209,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             let self_ty = fcx.to_ty(&qself.ty);\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n                 if d.base_def == Def::Err {\n+                    fcx.infcx().set_tainted_by_errors();\n                     fcx.write_error(pat.id);\n                     return;\n                 }\n@@ -628,6 +629,7 @@ fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let path_res = match tcx.def_map.borrow().get(&pat.id) {\n         Some(&path_res) if path_res.base_def != Def::Err => path_res,\n         _ => {\n+            fcx.infcx().set_tainted_by_errors();\n             fcx.write_error(pat.id);\n \n             if let Some(subpats) = subpats {"}, {"sha": "922c411ce8cd84002e7c9946b76ce8c900672511", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 101, "deletions": 8, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -45,19 +45,21 @@ use super::structurally_resolved_type;\n \n use lint;\n use hir::def_id::DefId;\n+use rustc::hir;\n+use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::cast::{CastKind, CastTy};\n-use syntax::codemap::Span;\n-use rustc::hir;\n use syntax::ast;\n-\n+use syntax::codemap::Span;\n+use util::common::ErrorReported;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n pub struct CastCheck<'tcx> {\n     expr: &'tcx hir::Expr,\n     expr_ty: Ty<'tcx>,\n     cast_ty: Ty<'tcx>,\n+    cast_span: Span,\n     span: Span,\n }\n \n@@ -111,17 +113,37 @@ enum CastError {\n }\n \n impl<'tcx> CastCheck<'tcx> {\n-    pub fn new(expr: &'tcx hir::Expr, expr_ty: Ty<'tcx>, cast_ty: Ty<'tcx>, span: Span)\n-               -> CastCheck<'tcx> {\n-        CastCheck {\n+    pub fn new<'a>(fcx: &FnCtxt<'a, 'tcx>,\n+                   expr: &'tcx hir::Expr,\n+                   expr_ty: Ty<'tcx>,\n+                   cast_ty: Ty<'tcx>,\n+                   cast_span: Span,\n+                   span: Span)\n+                   -> Result<CastCheck<'tcx>, ErrorReported> {\n+        let check = CastCheck {\n             expr: expr,\n             expr_ty: expr_ty,\n             cast_ty: cast_ty,\n+            cast_span: cast_span,\n             span: span,\n+        };\n+\n+        // For better error messages, check for some obviously unsized\n+        // cases now. We do a more thorough check at the end, once\n+        // inference is more completely known.\n+        match cast_ty.sty {\n+            ty::TyTrait(..) | ty::TySlice(..) => {\n+                check.report_cast_to_unsized_type(fcx);\n+                Err(ErrorReported)\n+            }\n+            _ => {\n+                Ok(check)\n+            }\n         }\n     }\n \n-    fn report_cast_error<'a>(&self, fcx: &FnCtxt<'a, 'tcx>,\n+    fn report_cast_error<'a>(&self,\n+                             fcx: &FnCtxt<'a, 'tcx>,\n                              e: CastError) {\n         match e {\n             CastError::NeedViaPtr |\n@@ -186,6 +208,61 @@ impl<'tcx> CastCheck<'tcx> {\n         }\n     }\n \n+    fn report_cast_to_unsized_type<'a>(&self,\n+                                       fcx: &FnCtxt<'a, 'tcx>) {\n+        if\n+            self.cast_ty.references_error() ||\n+            self.expr_ty.references_error()\n+        {\n+            return;\n+        }\n+\n+        let tstr = fcx.infcx().ty_to_string(self.cast_ty);\n+        let mut err = fcx.type_error_struct(self.span, |actual| {\n+            format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n+        }, self.expr_ty, None);\n+        match self.expr_ty.sty {\n+            ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n+                let mtstr = match mt {\n+                    hir::MutMutable => \"mut \",\n+                    hir::MutImmutable => \"\"\n+                };\n+                if self.cast_ty.is_trait() {\n+                    match fcx.tcx().sess.codemap().span_to_snippet(self.cast_span) {\n+                        Ok(s) => {\n+                            err.span_suggestion(self.cast_span,\n+                                                \"try casting to a reference instead:\",\n+                                                format!(\"&{}{}\", mtstr, s));\n+                        },\n+                        Err(_) =>\n+                            span_help!(err, self.cast_span,\n+                                       \"did you mean `&{}{}`?\", mtstr, tstr),\n+                    }\n+                } else {\n+                    span_help!(err, self.span,\n+                               \"consider using an implicit coercion to `&{}{}` instead\",\n+                               mtstr, tstr);\n+                }\n+            }\n+            ty::TyBox(..) => {\n+                match fcx.tcx().sess.codemap().span_to_snippet(self.cast_span) {\n+                    Ok(s) => {\n+                        err.span_suggestion(self.cast_span,\n+                                            \"try casting to a `Box` instead:\",\n+                                            format!(\"Box<{}>\", s));\n+                    },\n+                    Err(_) =>\n+                        span_help!(err, self.cast_span, \"did you mean `Box<{}>`?\", tstr),\n+                }\n+            }\n+            _ => {\n+                span_help!(err, self.expr.span,\n+                           \"consider using a box or reference as appropriate\");\n+            }\n+        }\n+        err.emit();\n+    }\n+\n     fn trivial_cast_lint<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n@@ -218,7 +295,9 @@ impl<'tcx> CastCheck<'tcx> {\n         debug!(\"check_cast({}, {:?} as {:?})\", self.expr.id, self.expr_ty,\n                self.cast_ty);\n \n-        if self.expr_ty.references_error() || self.cast_ty.references_error() {\n+        if !fcx.type_is_known_to_be_sized(self.cast_ty, self.span) {\n+            self.report_cast_to_unsized_type(fcx);\n+        } else if self.expr_ty.references_error() || self.cast_ty.references_error() {\n             // No sense in giving duplicate error messages\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n@@ -403,3 +482,17 @@ impl<'tcx> CastCheck<'tcx> {\n     }\n \n }\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    fn type_is_known_to_be_sized(&self,\n+                                 ty: Ty<'tcx>,\n+                                 span: Span)\n+                                 -> bool\n+    {\n+        traits::type_known_to_meet_builtin_bound(self.infcx(),\n+                                                 ty,\n+                                                 ty::BoundSized,\n+                                                 span)\n+    }\n+}\n+"}, {"sha": "2d0505d9347d59c69c1239f65a4467bdaf7068c5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 46, "deletions": 78, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -1076,64 +1076,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                         span: Span,\n-                                         t_span: Span,\n-                                         e_span: Span,\n-                                         t_cast: Ty<'tcx>,\n-                                         t_expr: Ty<'tcx>,\n-                                         id: ast::NodeId) {\n-    if t_cast.references_error() || t_expr.references_error() {\n-        return;\n-    }\n-    let tstr = fcx.infcx().ty_to_string(t_cast);\n-    let mut err = fcx.type_error_struct(span, |actual| {\n-        format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-    }, t_expr, None);\n-    match t_expr.sty {\n-        ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n-            let mtstr = match mt {\n-                hir::MutMutable => \"mut \",\n-                hir::MutImmutable => \"\"\n-            };\n-            if t_cast.is_trait() {\n-                match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n-                    Ok(s) => {\n-                        err.span_suggestion(t_span,\n-                                            \"try casting to a reference instead:\",\n-                                            format!(\"&{}{}\", mtstr, s));\n-                    },\n-                    Err(_) =>\n-                        span_help!(err, t_span,\n-                                   \"did you mean `&{}{}`?\", mtstr, tstr),\n-                }\n-            } else {\n-                span_help!(err, span,\n-                           \"consider using an implicit coercion to `&{}{}` instead\",\n-                           mtstr, tstr);\n-            }\n-        }\n-        ty::TyBox(..) => {\n-            match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n-                Ok(s) => {\n-                    err.span_suggestion(t_span,\n-                                        \"try casting to a `Box` instead:\",\n-                                        format!(\"Box<{}>\", s));\n-                },\n-                Err(_) =>\n-                    span_help!(err, t_span, \"did you mean `Box<{}>`?\", tstr),\n-            }\n-        }\n-        _ => {\n-            span_help!(err, e_span,\n-                       \"consider using a box or reference as appropriate\");\n-        }\n-    }\n-    err.emit();\n-    fcx.write_error(id);\n-}\n-\n-\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &TyCtxt<'tcx> { self.ccx.tcx }\n \n@@ -1240,6 +1182,10 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     {\n         self.normalize_associated_type(span, trait_ref, item_name)\n     }\n+\n+    fn set_tainted_by_errors(&self) {\n+        self.infcx().set_tainted_by_errors()\n+    }\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -1524,17 +1470,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.require_type_is_sized(self.expr_ty(expr), expr.span, code);\n     }\n \n-    pub fn type_is_known_to_be_sized(&self,\n-                                     ty: Ty<'tcx>,\n-                                     span: Span)\n-                                     -> bool\n-    {\n-        traits::type_known_to_meet_builtin_bound(self.infcx(),\n-                                                 ty,\n-                                                 ty::BoundSized,\n-                                                 span)\n-    }\n-\n     pub fn register_builtin_bound(&self,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n@@ -1771,16 +1706,37 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn default_type_parameters(&self) {\n         use rustc::ty::error::UnconstrainedNumeric::Neither;\n         use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat};\n+\n+        // Defaulting inference variables becomes very dubious if we have\n+        // encountered type-checking errors. Therefore, if we think we saw\n+        // some errors in this function, just resolve all uninstanted type\n+        // varibles to TyError.\n+        if self.infcx().is_tainted_by_errors() {\n+            for ty in &self.infcx().unsolved_variables() {\n+                if let ty::TyInfer(_) = self.infcx().shallow_resolve(ty).sty {\n+                    debug!(\"default_type_parameters: defaulting `{:?}` to error\", ty);\n+                    demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.err);\n+                }\n+            }\n+            return;\n+        }\n+\n         for ty in &self.infcx().unsolved_variables() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n+                debug!(\"default_type_parameters: defaulting `{:?}` to `()` because it diverges\",\n+                       resolved);\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n             } else {\n                 match self.infcx().type_is_unconstrained_numeric(resolved) {\n                     UnconstrainedInt => {\n+                        debug!(\"default_type_parameters: defaulting `{:?}` to `i32`\",\n+                               resolved);\n                         demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n                     },\n                     UnconstrainedFloat => {\n+                        debug!(\"default_type_parameters: defaulting `{:?}` to `f32`\",\n+                               resolved);\n                         demand::eqtype(self, codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n                     }\n                     Neither => { }\n@@ -3232,6 +3188,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // Find the relevant variant\n         let def = lookup_full_def(tcx, path.span, expr.id);\n         if def == Def::Err {\n+            fcx.infcx().set_tainted_by_errors();\n             check_struct_fields_on_error(fcx, expr.id, fields, base_expr);\n             return;\n         }\n@@ -3435,6 +3392,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                    expr.span,\n                                    id);\n               } else {\n+                  fcx.infcx().set_tainted_by_errors();\n                   fcx.write_ty(id, fcx.tcx().types.err);\n               }\n           }\n@@ -3560,25 +3518,29 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // Find the type of `e`. Supply hints based on the type we are casting to,\n         // if appropriate.\n         let t_cast = fcx.to_ty(t);\n-        let t_cast = structurally_resolved_type(fcx, expr.span, t_cast);\n+        let t_cast = fcx.infcx().resolve_type_vars_if_possible(&t_cast);\n         check_expr_with_expectation(fcx, e, ExpectCastableToType(t_cast));\n         let t_expr = fcx.expr_ty(e);\n         let t_cast = fcx.infcx().resolve_type_vars_if_possible(&t_cast);\n \n         // Eagerly check for some obvious errors.\n         if t_expr.references_error() || t_cast.references_error() {\n             fcx.write_error(id);\n-        } else if !fcx.type_is_known_to_be_sized(t_cast, expr.span) {\n-            report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_cast, t_expr, id);\n         } else {\n             // Write a type for the whole expression, assuming everything is going\n             // to work out Ok.\n             fcx.write_ty(id, t_cast);\n \n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = fcx.inh.deferred_cast_checks.borrow_mut();\n-            let cast_check = cast::CastCheck::new(e, t_expr, t_cast, expr.span);\n-            deferred_cast_checks.push(cast_check);\n+            match cast::CastCheck::new(fcx, e, t_expr, t_cast, t.span, expr.span) {\n+                Ok(cast_check) => {\n+                    deferred_cast_checks.push(cast_check);\n+                }\n+                Err(ErrorReported) => {\n+                    fcx.write_error(id);\n+                }\n+            }\n         }\n       }\n       hir::ExprType(ref e, ref t) => {\n@@ -4408,8 +4370,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Def::ForeignMod(..) |\n         Def::Local(..) |\n         Def::Label(..) |\n-        Def::Upvar(..) |\n+        Def::Upvar(..) => {\n+            segment_spaces = vec![None; segments.len()];\n+        }\n+\n         Def::Err => {\n+            fcx.infcx().set_tainted_by_errors();\n             segment_spaces = vec![None; segments.len()];\n         }\n     }\n@@ -4769,9 +4735,11 @@ fn structurally_resolve_type_or_else<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // If not, error.\n         if alternative.is_ty_var() || alternative.references_error() {\n-            fcx.type_error_message(sp, |_actual| {\n-                \"the type of this value must be known in this context\".to_string()\n-            }, ty, None);\n+            if !fcx.infcx().is_tainted_by_errors() {\n+                fcx.type_error_message(sp, |_actual| {\n+                    \"the type of this value must be known in this context\".to_string()\n+                }, ty, None);\n+            }\n             demand::suptype(fcx, sp, fcx.tcx().types.err, ty);\n             ty = fcx.tcx().types.err;\n         } else {"}, {"sha": "e5e82ea7f5517d50aab5c24e6e2bb935e786aae1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -384,6 +384,10 @@ impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n     {\n         self.tcx().mk_projection(trait_ref, item_name)\n     }\n+\n+    fn set_tainted_by_errors(&self) {\n+        // no obvious place to track this, just let it go\n+    }\n }\n \n /// Interface used to find the bounds on a type parameter from within"}, {"sha": "1598a9aa1fc4146a78fe16961e364dd53e085600", "filename": "src/test/compile-fail/cast-rfc0401-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401-2.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// RFC 401 test extracted into distinct file. This is because some the\n+// change to suppress \"derived\" errors wound up suppressing this error\n+// message, since the fallback for `3` doesn't occur.\n+\n+fn main() {\n+    let _ = 3 as bool;\n+    //~^ ERROR cannot cast as `bool`\n+    //~| HELP compare with zero\n+}"}, {"sha": "05c531e91f128e66e025da7150d503a8cc06f297", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -58,7 +58,7 @@ fn main()\n     let _ = f as *const u8;\n     //~^ ERROR casting\n     //~^^ HELP through a usize first\n-    let _ = 3 as bool;\n+    let _ = 3_i32 as bool;\n     //~^ ERROR cannot cast as `bool`\n     //~| HELP compare with zero\n     let _ = E::A as bool;"}, {"sha": "88d4aef6d9ddc0a873310ff8503125657763c55c", "filename": "src/test/compile-fail/derived-errors/issue-30580.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-30580.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-30580.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-30580.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "previous_filename": "src/test/compile-fail/issue-30580.rs"}, {"sha": "7d79c48c06ae2a789da006b3ebd8bbb5198cdefd", "filename": "src/test/compile-fail/derived-errors/issue-31997-1.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997-1.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for this example from #31997 -- main goal is to\n+// emit as minimal and precise an error set as possible. Ideally, we'd\n+// only emit the E0433 error below, but right now we emit two.\n+\n+use std::io::prelude::*;\n+// use std::collections::HashMap;\n+use std::io;\n+\n+#[derive(Debug)]\n+struct Instance {\n+    name: String,\n+    start: Option<String>,\n+    end: Option<String>,\n+}\n+\n+fn main() {\n+    let input = io::stdin();\n+    let mut input = input.lock();\n+\n+    let mut map = HashMap::new();\n+    //~^ ERROR E0433\n+\n+    for line in input.lines() {\n+        let line = line.unwrap();\n+        println!(\"process: {}\", line);\n+        let mut parts = line.splitn(2, \":\");\n+        let _logfile = parts.next().unwrap();\n+        let rest = parts.next().unwrap();\n+        let mut parts = line.split(\" [-] \");\n+\n+        let stamp = parts.next().unwrap();\n+\n+        let rest = parts.next().unwrap();\n+        let words = rest.split_whitespace().collect::<Vec<_>>();\n+\n+        let instance = words.iter().find(|a| a.starts_with(\"i-\")).unwrap();\n+        let name = words[1].to_owned();\n+        let mut entry = map.entry(instance.to_owned()).or_insert(Instance {\n+            name: name,\n+            start: None,\n+            end: None,\n+        });\n+\n+        if rest.contains(\"terminating\") {\n+            assert!(entry.end.is_none());\n+            entry.end = Some(stamp.to_string());\n+        }\n+        if rest.contains(\"waiting for\") {\n+            assert!(entry.start.is_none());\n+            entry.start = Some(stamp.to_string());\n+        }\n+\n+    }\n+\n+    println!(\"{:?}\", map);\n+}"}, {"sha": "cf283f6d3e4b56bee48316b9663e34e73cfd1594", "filename": "src/test/compile-fail/derived-errors/issue-31997.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderived-errors%2Fissue-31997.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the resolve failure does not lead to downstream type errors.\n+// See issue #31997.\n+\n+trait TheTrait { }\n+\n+fn closure<F, T>(x: F) -> Result<T, ()>\n+    where F: FnMut() -> T, T: TheTrait,\n+{\n+    unimplemented!()\n+}\n+\n+fn foo() -> Result<(), ()> {\n+    try!(closure(|| bar(0 as *mut _))); //~ ERROR unresolved name `bar`\n+    Ok(())\n+}\n+\n+fn main() { }"}, {"sha": "86a6bdfd4dde4d5c1b1898a50272e22c43ed5a37", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -35,7 +35,7 @@ impl Node for Stuff {\n \n fn iterate<N: Node, G: Graph<N>>(graph: &G) {\n     for node in graph.iter() { //~ ERROR no method named `iter` found\n-        node.zomg();  //~ error: the type of this value must be known in this context\n+        node.zomg();\n     }\n }\n "}, {"sha": "ca1715445e526e976f3c8f10b67c09bc7e483b4f", "filename": "src/test/compile-fail/issue-19692.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -12,7 +12,7 @@ struct Homura;\n \n fn akemi(homura: Homura) {\n     let Some(ref madoka) = Some(homura.kaname()); //~ ERROR no method named `kaname` found\n-    madoka.clone(); //~ ERROR the type of this value must be known\n+    madoka.clone();\n }\n \n fn main() { }"}, {"sha": "2f1910b26bbef55ff29317f8ed49f5ae895b97aa", "filename": "src/test/compile-fail/issue-20261.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20261.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -11,6 +11,5 @@\n fn main() {\n     for (ref i,) in [].iter() { //~ ERROR mismatched types\n         i.clone();\n-        //~^ ERROR: the type of this value must be known in this context\n     }\n }"}, {"sha": "23e4ffb1f3076fad4e09c1c2e0f21e4a8b00cfaf", "filename": "src/test/compile-fail/issue-26480.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26480.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -30,8 +30,7 @@ macro_rules! write {\n }\n \n macro_rules! cast {\n-    ($x:expr) => ($x as ())\n-    //~^ ERROR non-scalar cast: `i32` as `()`\n+    ($x:expr) => ($x as ()) //~ ERROR non-scalar cast\n }\n \n fn main() {"}, {"sha": "92456760b0508971bef2f5cde9506564b39b7f89", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -31,5 +31,5 @@ impl ToString_ for Point {\n fn main() {\n     let p = Point::new(0.0, 0.0);\n     //~^ ERROR no associated item named `new` found for type `Point` in the current scope\n-    println!(\"{}\", p.to_string()); //~ ERROR type of this value must be known\n+    println!(\"{}\", p.to_string());\n }"}, {"sha": "4acbcb165ff081240c764c277391010b0a932094", "filename": "src/test/compile-fail/issue-7092.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-7092.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Fcompile-fail%2Fissue-7092.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7092.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -19,7 +19,7 @@ fn foo(x: Whatever) {\n //~| found `std::option::Option<_>`\n //~| expected enum `Whatever`\n //~| found enum `std::option::Option`\n-            field.access(), //~ ERROR the type of this value must be known in this context\n+            field.access(),\n     }\n }\n "}, {"sha": "2aa0d9c62fb4111e1c7b63f55cee9ece34e3eafc", "filename": "src/test/run-pass/cast-to-infer-ty.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Frun-pass%2Fcast-to-infer-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90318b8c225cde275cf2059330dc096f77301bce/src%2Ftest%2Frun-pass%2Fcast-to-infer-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-to-infer-ty.rs?ref=90318b8c225cde275cf2059330dc096f77301bce", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we allow a cast to `_` so long as the target type can be\n+// inferred elsewhere.\n+\n+pub fn main() {\n+    let i: *const i32 = 0 as _;\n+    assert!(i.is_null());\n+}"}]}