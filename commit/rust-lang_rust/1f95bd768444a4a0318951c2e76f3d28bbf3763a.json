{"sha": "1f95bd768444a4a0318951c2e76f3d28bbf3763a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmOTViZDc2ODQ0NGE0YTAzMTg5NTFjMmU3NmYzZDI4YmJmMzc2M2E=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-05T20:55:08Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-05T23:30:25Z"}, "message": "Lazily initialize 'leaf node' taskgroups for unlinked spawns, for an apparent 11% speedup.", "tree": {"sha": "ca7e37a881344bb7a8323acd3f0f99e00e7efc5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca7e37a881344bb7a8323acd3f0f99e00e7efc5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f95bd768444a4a0318951c2e76f3d28bbf3763a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f95bd768444a4a0318951c2e76f3d28bbf3763a", "html_url": "https://github.com/rust-lang/rust/commit/1f95bd768444a4a0318951c2e76f3d28bbf3763a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f95bd768444a4a0318951c2e76f3d28bbf3763a/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47e82c85555895c21206c84b62cac19eb351d1b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/47e82c85555895c21206c84b62cac19eb351d1b8", "html_url": "https://github.com/rust-lang/rust/commit/47e82c85555895c21206c84b62cac19eb351d1b8"}], "stats": {"total": 108, "additions": 63, "deletions": 45}, "files": [{"sha": "3372c13b87703a72cdef5af13fa5b651cc2379fc", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f95bd768444a4a0318951c2e76f3d28bbf3763a/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f95bd768444a4a0318951c2e76f3d28bbf3763a/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=1f95bd768444a4a0318951c2e76f3d28bbf3763a", "patch": "@@ -193,6 +193,10 @@ impl BlockedTask {\n \n     /// Create a blocked task, unless the task was already killed.\n     pub fn try_block(mut task: ~Task) -> Either<~Task, BlockedTask> {\n+        // NB: As an optimization, we could give a free pass to being unkillable\n+        // to tasks whose taskgroups haven't been initialized yet, but that\n+        // introduces complications with select() and with the test cases below,\n+        // and it's not clear the uncommon performance boost is worth it.\n         if task.death.unkillable > 0 {\n             Right(Unkillable(task))\n         } else {"}, {"sha": "527b20b0e9027312afc5d66244365fa54b5cb28f", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1f95bd768444a4a0318951c2e76f3d28bbf3763a/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f95bd768444a4a0318951c2e76f3d28bbf3763a/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=1f95bd768444a4a0318951c2e76f3d28bbf3763a", "patch": "@@ -568,7 +568,8 @@ impl RuntimeGlue {\n                 let me = Local::unsafe_borrow::<Task>();\n                 blk(match (*me).taskgroup {\n                     None => {\n-                        // Main task, doing first spawn ever. Lazily initialize.\n+                        // First task in its (unlinked/unsupervised) taskgroup.\n+                        // Lazily initialize.\n                         let mut members = TaskSet::new();\n                         let my_handle = (*me).death.kill_handle.get_ref().clone();\n                         members.insert(NewTask(my_handle));\n@@ -591,37 +592,46 @@ impl RuntimeGlue {\n     }\n }\n \n+// Returns 'None' in the case where the child's TG should be lazily initialized.\n fn gen_child_taskgroup(linked: bool, supervised: bool)\n-    -> (TaskGroupArc, AncestorList, bool) {\n-    do RuntimeGlue::with_my_taskgroup |spawner_group| {\n-        let ancestors = AncestorList(spawner_group.ancestors.map(|x| x.clone()));\n-        if linked {\n-            // Child is in the same group as spawner.\n-            // Child's ancestors are spawner's ancestors.\n-            // Propagate main-ness.\n-            (spawner_group.tasks.clone(), ancestors, spawner_group.is_main)\n-        } else {\n-            // Child is in a separate group from spawner.\n-            let g = Exclusive::new(Some(TaskGroupData {\n-                members:     TaskSet::new(),\n-                descendants: TaskSet::new(),\n-            }));\n-            let a = if supervised {\n-                let new_generation = incr_generation(&ancestors);\n-                assert!(new_generation < uint::max_value);\n-                // Child's ancestors start with the spawner.\n-                // Build a new node in the ancestor list.\n-                AncestorList(Some(Exclusive::new(AncestorNode {\n-                    generation: new_generation,\n-                    parent_group: spawner_group.tasks.clone(),\n-                    ancestors: ancestors,\n-                })))\n+    -> Option<(TaskGroupArc, AncestorList, bool)> {\n+    // FIXME(#7544): Not safe to lazily initialize in the old runtime. Remove\n+    // this context check once 'spawn_raw_oldsched' is gone.\n+    if context() == OldTaskContext || linked || supervised {\n+        // with_my_taskgroup will lazily initialize the parent's taskgroup if\n+        // it doesn't yet exist. We don't want to call it in the unlinked case.\n+        do RuntimeGlue::with_my_taskgroup |spawner_group| {\n+            let ancestors = AncestorList(spawner_group.ancestors.map(|x| x.clone()));\n+            if linked {\n+                // Child is in the same group as spawner.\n+                // Child's ancestors are spawner's ancestors.\n+                // Propagate main-ness.\n+                Some((spawner_group.tasks.clone(), ancestors, spawner_group.is_main))\n             } else {\n-                // Child has no ancestors.\n-                AncestorList(None)\n-            };\n-            (g, a, false)\n+                // Child is in a separate group from spawner.\n+                let g = Exclusive::new(Some(TaskGroupData {\n+                    members:     TaskSet::new(),\n+                    descendants: TaskSet::new(),\n+                }));\n+                let a = if supervised {\n+                    let new_generation = incr_generation(&ancestors);\n+                    assert!(new_generation < uint::max_value);\n+                    // Child's ancestors start with the spawner.\n+                    // Build a new node in the ancestor list.\n+                    AncestorList(Some(Exclusive::new(AncestorNode {\n+                        generation: new_generation,\n+                        parent_group: spawner_group.tasks.clone(),\n+                        ancestors: ancestors,\n+                    })))\n+                } else {\n+                    // Child has no ancestors.\n+                    AncestorList(None)\n+                };\n+                Some((g, a, false))\n+            }\n         }\n+    } else {\n+        None\n     }\n }\n \n@@ -670,20 +680,24 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n \n     let child_wrapper: ~fn() = || {\n         // Child task runs this code.\n-        let child_data = Cell::new(child_data.take()); // :(\n-        let enlist_success = do Local::borrow::<Task, bool> |me| {\n-            let (child_tg, ancestors, is_main) = child_data.take();\n-            let mut ancestors = ancestors;\n-            // FIXME(#7544): Optimize out the xadd in this clone, somehow.\n-            let handle = me.death.kill_handle.get_ref().clone();\n-            // Atomically try to get into all of our taskgroups.\n-            if enlist_many(NewTask(handle), &child_tg, &mut ancestors) {\n-                // Got in. We can run the provided child body, and can also run\n-                // the taskgroup's exit-time-destructor afterward.\n-                me.taskgroup = Some(Taskgroup(child_tg, ancestors, is_main, None));\n-                true\n-            } else {\n-                false\n+\n+        // If child data is 'None', the enlist is vacuously successful.\n+        let enlist_success = do child_data.take().map_consume_default(true) |child_data| {\n+            let child_data = Cell::new(child_data); // :(\n+            do Local::borrow::<Task, bool> |me| {\n+                let (child_tg, ancestors, is_main) = child_data.take();\n+                let mut ancestors = ancestors;\n+                // FIXME(#7544): Optimize out the xadd in this clone, somehow.\n+                let handle = me.death.kill_handle.get_ref().clone();\n+                // Atomically try to get into all of our taskgroups.\n+                if enlist_many(NewTask(handle), &child_tg, &mut ancestors) {\n+                    // Got in. We can run the provided child body, and can also run\n+                    // the taskgroup's exit-time-destructor afterward.\n+                    me.taskgroup = Some(Taskgroup(child_tg, ancestors, is_main, None));\n+                    true\n+                } else {\n+                    false\n+                }\n             }\n         };\n         // Should be run after the local-borrowed task is returned.\n@@ -749,7 +763,7 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n                 let join_task = join_task_cell.take();\n \n                 let bootstrap_task = ~do Task::new_root(&mut new_sched.stack_pool) || {\n-                    rtdebug!(\"boostraping a 1:1 scheduler\");\n+                    rtdebug!(\"bootstrapping a 1:1 scheduler\");\n                 };\n                 new_sched.bootstrap(bootstrap_task);\n \n@@ -793,7 +807,7 @@ fn spawn_raw_newsched(mut opts: TaskOpts, f: ~fn()) {\n fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n \n     let (child_tg, ancestors, is_main) =\n-        gen_child_taskgroup(opts.linked, opts.supervised);\n+        gen_child_taskgroup(opts.linked, opts.supervised).expect(\"old runtime needs TG\");\n \n     unsafe {\n         let child_data = Cell::new((child_tg, ancestors, f));"}]}