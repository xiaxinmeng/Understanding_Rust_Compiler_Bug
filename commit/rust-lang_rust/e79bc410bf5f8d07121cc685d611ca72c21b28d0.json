{"sha": "e79bc410bf5f8d07121cc685d611ca72c21b28d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3OWJjNDEwYmY1ZjhkMDcxMjFjYzY4NWQ2MTFjYTcyYzIxYjI4ZDA=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-24T16:47:31Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:34Z"}, "message": "Consolidate into create_substs_for_generic_args", "tree": {"sha": "c9164aa1cc6d971ee706bbb68be3eae1906ecdc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9164aa1cc6d971ee706bbb68be3eae1906ecdc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e79bc410bf5f8d07121cc685d611ca72c21b28d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e79bc410bf5f8d07121cc685d611ca72c21b28d0", "html_url": "https://github.com/rust-lang/rust/commit/e79bc410bf5f8d07121cc685d611ca72c21b28d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e79bc410bf5f8d07121cc685d611ca72c21b28d0/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccef306b965697f01a5eb9fb69b9b7a34517cc8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccef306b965697f01a5eb9fb69b9b7a34517cc8a", "html_url": "https://github.com/rust-lang/rust/commit/ccef306b965697f01a5eb9fb69b9b7a34517cc8a"}], "stats": {"total": 563, "additions": 268, "deletions": 295}, "files": [{"sha": "83c18265489f35244a207d72eccfd1753d99dd87", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 189, "deletions": 96, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/e79bc410bf5f8d07121cc685d611ca72c21b28d0/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79bc410bf5f8d07121cc685d611ca72c21b28d0/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=e79bc410bf5f8d07121cc685d611ca72c21b28d0", "patch": "@@ -14,15 +14,15 @@\n \n use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::array_vec::ArrayVec;\n-use hir::{self, GenericArg};\n+use hir::{self, GenericArg, GenericArgs};\n use hir::def::Def;\n use hir::def_id::DefId;\n use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n-use rustc::ty::GenericParamDefKind;\n+use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc::ty::wf::object_region_bounds;\n use rustc_target::spec::abi;\n use std::slice;\n@@ -192,6 +192,153 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         substs\n     }\n \n+    /// Creates the relevant generic argument substitutions\n+    /// corresponding to a set of generic parameters.\n+    pub fn create_substs_for_generic_args<'a, 'b, A, P, I>(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        span: Span,\n+        err_if_invalid: bool,\n+        def_id: DefId,\n+        parent_substs: &[Kind<'tcx>],\n+        has_self: bool,\n+        self_ty: Option<Ty<'tcx>>,\n+        args_for_def_id: A,\n+        provided_kind: P,\n+        inferred_kind: I,\n+    ) -> &'tcx Substs<'tcx> where\n+        A: Fn(DefId) -> (Option<&'b GenericArgs>, bool),\n+        P: Fn(&GenericParamDef, &GenericArg) -> Kind<'tcx>,\n+        I: Fn(Option<&[Kind<'tcx>]>, &GenericParamDef, bool) -> Kind<'tcx>\n+    {\n+        // Collect the segments of the path: we need to substitute arguments\n+        // for parameters throughout the entire path (wherever there are\n+        // generic parameters).\n+        let mut parent_defs = tcx.generics_of(def_id);\n+        let count = parent_defs.count();\n+        let mut stack = vec![(def_id, parent_defs)];\n+        while let Some(def_id) = parent_defs.parent {\n+            parent_defs = tcx.generics_of(def_id);\n+            stack.push((def_id, parent_defs));\n+        }\n+\n+        // We manually build up the substitution, rather than using convenience\n+        // methods in subst.rs so that we can iterate over the arguments and\n+        // parameters in lock-step linearly, rather than trying to match each pair.\n+        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n+            AccumulateVec::Array(ArrayVec::new())\n+        } else {\n+            AccumulateVec::Heap(Vec::with_capacity(count))\n+        };\n+\n+        fn push_kind<'tcx>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>, kind: Kind<'tcx>) {\n+            match substs {\n+                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n+                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n+            }\n+        }\n+\n+        // Iterate over each segment of the path.\n+        while let Some((def_id, defs)) = stack.pop() {\n+            let mut params = defs.params.iter();\n+            let mut next_param = params.next();\n+\n+            // If we have already computed substitutions for parents, we can use those directly.\n+            while let Some(param) = next_param {\n+                if let Some(&kind) = parent_substs.get(param.index as usize) {\n+                    push_kind(&mut substs, kind);\n+                    next_param = params.next();\n+                } else {\n+                    break;\n+                }\n+            }\n+\n+            // (Unless it's been handled in `parent_substs`) `Self` is handled first.\n+            if has_self {\n+                if let Some(param) = next_param {\n+                    if param.index == 0 {\n+                        if let GenericParamDefKind::Type { .. } = param.kind {\n+                            push_kind(&mut substs, self_ty.map(|ty| ty.into())\n+                                .unwrap_or_else(|| inferred_kind(None, param, true)));\n+                            next_param = params.next();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Check whether this segment takes generic arguments and the user has provided any.\n+            let (generic_args, infer_types) = args_for_def_id(def_id);\n+            if let Some(ref generic_args) = generic_args {\n+                // We're going to iterate through the generic arguments that the user\n+                // provided, matching them with the generic parameters we expect.\n+                // Mismatches can occur as a result of elided lifetimes, or for malformed\n+                // input. We try to handle both sensibly.\n+                'args: for arg in &generic_args.args {\n+                    while let Some(param) = next_param {\n+                        match param.kind {\n+                            GenericParamDefKind::Lifetime => match arg {\n+                                GenericArg::Lifetime(_) => {\n+                                    push_kind(&mut substs, provided_kind(param, arg));\n+                                    next_param = params.next();\n+                                    continue 'args;\n+                                }\n+                                GenericArg::Type(_) => {\n+                                    // We expected a lifetime argument, but got a type\n+                                    // argument. That means we're inferring the lifetimes.\n+                                    push_kind(&mut substs, inferred_kind(None, param, infer_types));\n+                                    next_param = params.next();\n+                                }\n+                            }\n+                            GenericParamDefKind::Type { .. } => match arg {\n+                                GenericArg::Type(_) => {\n+                                    push_kind(&mut substs, provided_kind(param, arg));\n+                                    next_param = params.next();\n+                                    continue 'args;\n+                                }\n+                                GenericArg::Lifetime(_) => {\n+                                    // We expected a type argument, but got a lifetime\n+                                    // argument. This is an error, but we need to handle it\n+                                    // gracefully so we can report sensible errors. In this\n+                                    // case, we're simply going to infer the remaining\n+                                    // arguments.\n+                                    if err_if_invalid {\n+                                        tcx.sess.delay_span_bug(span,\n+                                            \"found a GenericArg::Lifetime where a \\\n+                                            GenericArg::Type was expected\");\n+                                    }\n+                                    break 'args;\n+                                }\n+                            }\n+                        }\n+                    }\n+                    // We should never be able to reach this point with well-formed input.\n+                    // Getting to this point means the user supplied more arguments than\n+                    // there are parameters.\n+                    if err_if_invalid {\n+                        tcx.sess.delay_span_bug(span,\n+                            \"GenericArg did not have matching GenericParamDef\");\n+                    }\n+                }\n+            }\n+\n+            // If there are fewer arguments than parameters, it means\n+            // we're inferring the remaining arguments.\n+            while let Some(param) = next_param {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => {\n+                        push_kind(&mut substs, inferred_kind(None, param, infer_types));\n+                    }\n+                    GenericParamDefKind::Type { .. } => {\n+                        let kind = inferred_kind(Some(&substs), param, infer_types);\n+                        push_kind(&mut substs, kind);\n+                    }\n+                }\n+                next_param = params.next();\n+            }\n+        }\n+\n+        tcx.intern_substs(&substs)\n+    }\n+\n     /// Given the type/region arguments provided to some path (along with\n     /// an implicit Self, if this is a trait reference) returns the complete\n     /// set of substitutions. This may involve applying defaulted type parameters.\n@@ -271,95 +418,37 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             false\n         };\n \n-        // Collect the segments of the path: we need to substitute arguments\n-        // for parameters throughout the entire path (wherever there are\n-        // generic parameters).\n-        let mut parent_defs = self.tcx().generics_of(def_id);\n-        let count = parent_defs.count();\n-        let mut stack = vec![(def_id, parent_defs)];\n-        while let Some(def_id) = parent_defs.parent {\n-            parent_defs = self.tcx().generics_of(def_id);\n-            stack.push((def_id, parent_defs));\n-        }\n-\n-        // We manually build up the substitution, rather than using convenience\n-        // methods in subst.rs so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, rather than trying to match each pair.\n-        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n-            AccumulateVec::Array(ArrayVec::new())\n-        } else {\n-            AccumulateVec::Heap(Vec::with_capacity(count))\n-        };\n-        fn push_kind<'tcx>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>, kind: Kind<'tcx>) {\n-            match substs {\n-                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n-                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n-            }\n-        }\n-\n-        // Iterate over each segment of the path.\n-        while let Some((_, defs)) = stack.pop() {\n-            let mut params = defs.params.iter();\n-            let mut next_param = params.next();\n-\n-            // `Self` is handled first.\n-            if let Some(ty) = self_ty {\n-                if let Some(param) = next_param {\n-                    if param.index == 0 {\n-                        if let GenericParamDefKind::Type { .. } = param.kind {\n-                            push_kind(&mut substs, ty.into());\n-                            next_param = params.next();\n+        let substs = Self::create_substs_for_generic_args(\n+            self.tcx(),\n+            span,\n+            false,\n+            def_id,\n+            &[][..],\n+            self_ty.is_some(),\n+            self_ty,\n+            // Provide the generic args, and whether types should be inferred.\n+            |_| (Some(generic_args), infer_types),\n+            // Provide substitutions for parameters for which (valid) arguments have been provided.\n+            |param, arg| {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => match arg {\n+                        GenericArg::Lifetime(lt) => {\n+                            self.ast_region_to_region(&lt, Some(param)).into()\n                         }\n+                        _ => unreachable!(),\n                     }\n-                }\n-            }\n-\n-            let args = &generic_args.args;\n-            'args: for arg in args {\n-                while let Some(param) = next_param {\n-                    match param.kind {\n-                        GenericParamDefKind::Lifetime => match arg {\n-                            GenericArg::Lifetime(lt) => {\n-                                push_kind(&mut substs,\n-                                    self.ast_region_to_region(&lt, Some(param)).into());\n-                                next_param = params.next();\n-                                continue 'args;\n-                            }\n-                            GenericArg::Type(_) => {\n-                                // We expected a lifetime argument, but got a type\n-                                // argument. That means we're inferring the lifetimes.\n-                                push_kind(&mut substs, tcx.types.re_static.into());\n-                                next_param = params.next();\n-                            }\n-                        }\n-                        GenericParamDefKind::Type { .. } => match arg {\n-                            GenericArg::Type(ty) => {\n-                                push_kind(&mut substs, self.ast_ty_to_ty(&ty).into());\n-                                next_param = params.next();\n-                                continue 'args;\n-                            }\n-                            GenericArg::Lifetime(_) => {\n-                                break 'args;\n-                            }\n-                        }\n+                    GenericParamDefKind::Type { .. } => match arg {\n+                        GenericArg::Type(ty) => self.ast_ty_to_ty(&ty).into(),\n+                        _ => unreachable!(),\n                     }\n                 }\n-            }\n-\n-            while let Some(param) = next_param {\n+            },\n+            // Provide substitutions for parameters for which arguments are inferred.\n+            |substs, param, infer_types| {\n                 match param.kind {\n-                    GenericParamDefKind::Lifetime => {\n-                        push_kind(&mut substs, tcx.types.re_static.into());\n-                    }\n+                    GenericParamDefKind::Lifetime => tcx.types.re_static.into(),\n                     GenericParamDefKind::Type { has_default, .. } => {\n-                        if infer_types {\n-                            // No type parameters were provided, we can infer all.\n-                            push_kind(&mut substs, if !default_needs_object_self(param) {\n-                                self.ty_infer_for_def(param, span).into()\n-                            } else {\n-                                self.ty_infer(span).into()\n-                            });\n-                        } else if has_default {\n+                        if !infer_types && has_default {\n                             // No type parameter provided, but a default exists.\n \n                             // If we are converting an object type, then the\n@@ -378,26 +467,30 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                                                     type parameters must be specified on object \\\n                                                     types\"))\n                                     .emit();\n-                                push_kind(&mut substs, tcx.types.err.into());\n+                                tcx.types.err.into()\n                             } else {\n                                 // This is a default type parameter.\n-                                let kind = self.normalize_ty(\n+                                self.normalize_ty(\n                                     span,\n                                     tcx.at(span).type_of(param.def_id)\n-                                        .subst_spanned(tcx, &substs, Some(span))\n-                                ).into();\n-                                push_kind(&mut substs, kind);\n+                                        .subst_spanned(tcx, substs.unwrap(), Some(span))\n+                                ).into()\n+                            }\n+                        } else if infer_types {\n+                            // No type parameters were provided, we can infer all.\n+                            if !default_needs_object_self(param) {\n+                                self.ty_infer_for_def(param, span).into()\n+                            } else {\n+                                self.ty_infer(span).into()\n                             }\n                         } else {\n                             // We've already errored above about the mismatch.\n-                            push_kind(&mut substs, tcx.types.err.into());\n+                            tcx.types.err.into()\n                         }\n                     }\n-                };\n-                next_param = params.next();\n-            }\n-        }\n-        let substs = self.tcx().intern_substs(&substs);\n+                }\n+            },\n+        );\n \n         let assoc_bindings = generic_args.bindings.iter().map(|binding| {\n             ConvertedBinding {"}, {"sha": "0acbd8031035d16ba92aaacc42cc3ddffb1d94c3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 31, "deletions": 78, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/e79bc410bf5f8d07121cc685d611ca72c21b28d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79bc410bf5f8d07121cc685d611ca72c21b28d0/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e79bc410bf5f8d07121cc685d611ca72c21b28d0", "patch": "@@ -14,7 +14,7 @@ use astconv::AstConv;\n use check::{FnCtxt, PlaceOp, callee, Needs};\n use hir::GenericArg;\n use hir::def_id::DefId;\n-use rustc::ty::subst::{Kind, Substs};\n+use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, GenericParamDefKind};\n use rustc::ty::subst::Subst;\n@@ -24,8 +24,6 @@ use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk};\n use syntax_pos::Span;\n use rustc::hir;\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use rustc_data_structures::array_vec::ArrayVec;\n \n use std::ops::Deref;\n \n@@ -325,86 +323,41 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // parameters from the type and those from the method.\n         assert_eq!(method_generics.parent_count, parent_substs.len());\n \n-        // Collect the segments of the path: we need to substitute arguments\n-        // for parameters throughout the entire path (wherever there are\n-        // generic parameters).\n-        let def_id = pick.item.def_id;\n-        let mut parent_defs = self.tcx.generics_of(def_id);\n-        let count = parent_defs.count();\n-        let mut stack = vec![(def_id, parent_defs)];\n-        while let Some(def_id) = parent_defs.parent {\n-            parent_defs = self.tcx.generics_of(def_id);\n-            stack.push((def_id, parent_defs));\n-        }\n-\n-        // We manually build up the substitution, rather than using convenience\n-        // methods in subst.rs so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, rather than trying to match each pair.\n-        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n-            AccumulateVec::Array(ArrayVec::new())\n-        } else {\n-            AccumulateVec::Heap(Vec::with_capacity(count))\n-        };\n-        fn push_kind<'tcx>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>, kind: Kind<'tcx>) {\n-            match substs {\n-                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n-                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n-            }\n-        }\n-\n-        // Iterate over each segment of the path.\n-        while let Some((_, defs)) = stack.pop() {\n-            let mut params = defs.params.iter();\n-            let mut next_param = params.next();\n-\n-            while let Some(param) = next_param {\n-                if let Some(&kind) = parent_substs.get(param.index as usize) {\n-                    push_kind(&mut substs, kind);\n-                    next_param = params.next();\n+        AstConv::create_substs_for_generic_args(\n+            self.tcx,\n+            self.span,\n+            false,\n+            pick.item.def_id,\n+            parent_substs,\n+            false,\n+            None,\n+            // Provide the generic args, and whether types should be inferred.\n+            |_| {\n+                // The last argument of the returned tuple here is unimportant.\n+                if let Some(ref data) = segment.args {\n+                    (Some(data), false)\n                 } else {\n-                    break;\n+                    (None, false)\n                 }\n-            }\n-\n-            if let Some(ref data) = segment.args {\n-                let args = &data.args;\n-                'args: for arg in args {\n-                    while let Some(param) = next_param {\n-                        match param.kind {\n-                            GenericParamDefKind::Lifetime => match arg {\n-                                GenericArg::Lifetime(lt) => {\n-                                    push_kind(&mut substs, AstConv::ast_region_to_region(\n-                                        self.fcx, lt, Some(param)).into());\n-                                    next_param = params.next();\n-                                    continue 'args;\n-                                }\n-                                _ => {\n-                                    push_kind(&mut substs, self.var_for_def(self.span, param));\n-                                    next_param = params.next();\n-                                }\n-                            }\n-                            GenericParamDefKind::Type { .. } => match arg {\n-                                GenericArg::Type(ty) => {\n-                                    push_kind(&mut substs, self.to_ty(ty).into());\n-                                    next_param = params.next();\n-                                    continue 'args;\n-                                }\n-                                _ => {\n-                                    break 'args;\n-                                }\n-                            }\n+            },\n+            // Provide substitutions for parameters for which (valid) arguments have been provided.\n+            |param, arg| {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => match arg {\n+                        GenericArg::Lifetime(lt) => {\n+                            AstConv::ast_region_to_region(self.fcx, lt, Some(param)).into()\n                         }\n+                        _ => unreachable!(),\n+                    }\n+                    GenericParamDefKind::Type { .. } => match arg {\n+                        GenericArg::Type(ty) => self.to_ty(ty).into(),\n+                        _ => unreachable!(),\n                     }\n                 }\n-            }\n-\n-            while let Some(param) = next_param {\n-                push_kind(&mut substs, self.var_for_def(self.span, param));\n-                next_param = params.next();\n-            }\n-        }\n-\n-        self.tcx.intern_substs(&substs)\n+            },\n+            // Provide substitutions for parameters for which arguments are inferred.\n+            |_, param, _| self.var_for_def(self.span, param),\n+        )\n     }\n \n     fn unify_receivers(&mut self, self_ty: Ty<'tcx>, method_self_ty: Ty<'tcx>) {"}, {"sha": "141d0aea4628e2412ae5097264d9afc18d26faea", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 48, "deletions": 121, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/e79bc410bf5f8d07121cc685d611ca72c21b28d0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e79bc410bf5f8d07121cc685d611ca72c21b28d0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e79bc410bf5f8d07121cc685d611ca72c21b28d0", "patch": "@@ -95,16 +95,14 @@ use rustc::infer::anon_types::AnonTypeDecl;\n use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{GlobalId};\n-use rustc::ty::subst::{Kind, UnpackedKind, Subst, Substs};\n+use rustc::ty::subst::{UnpackedKind, Subst, Substs};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate, RegionKind};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use errors::{DiagnosticBuilder, DiagnosticId};\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use rustc_data_structures::array_vec::ArrayVec;\n \n use require_c_abi_if_variadic;\n use session::{CompileIncomplete, config, Session};\n@@ -4282,8 +4280,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         match *qpath {\n             hir::QPath::Resolved(ref maybe_qself, ref path) => {\n-                let opt_self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n-                let ty = AstConv::def_to_ty(self, opt_self_ty, path, true);\n+                let self_ty = maybe_qself.as_ref().map(|qself| self.to_ty(qself));\n+                let ty = AstConv::def_to_ty(self, self_ty, path, true);\n                 (path.def, ty)\n             }\n             hir::QPath::TypeRelative(ref qself, ref segment) => {\n@@ -4873,7 +4871,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n                                   segments: &[hir::PathSegment],\n-                                  opt_self_ty: Option<Ty<'tcx>>,\n+                                  self_ty: Option<Ty<'tcx>>,\n                                   def: Def,\n                                   span: Span,\n                                   node_id: ast::NodeId)\n@@ -4898,7 +4896,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 if segments.len() == 1 {\n                     // `<T>::assoc` will end up here, and so can `T::assoc`.\n-                    let self_ty = opt_self_ty.expect(\"UFCS sugared assoc missing Self\");\n+                    let self_ty = self_ty.expect(\"UFCS sugared assoc missing Self\");\n                     ufcs_associated = Some((container, self_ty));\n                 }\n             }\n@@ -4955,147 +4953,76 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n-        // Collect the segments of the path: we need to substitute arguments\n-        // for parameters throughout the entire path (wherever there are\n-        // generic parameters).\n         let def_id = def.def_id();\n-        let mut parent_defs = self.tcx.generics_of(def_id);\n-        let count = parent_defs.count();\n-        let mut stack = vec![(def_id, parent_defs)];\n-        while let Some(def_id) = parent_defs.parent {\n-            parent_defs = self.tcx.generics_of(def_id);\n-            stack.push((def_id, parent_defs));\n-        }\n \n-        // We manually build up the substitution, rather than using convenience\n-        // methods in subst.rs so that we can iterate over the arguments and\n-        // parameters in lock-step linearly, rather than trying to match each pair.\n-        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n-            AccumulateVec::Array(ArrayVec::new())\n-        } else {\n-            AccumulateVec::Heap(Vec::with_capacity(count))\n-        };\n-        fn push_kind<'tcx>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>, kind: Kind<'tcx>) {\n-            match substs {\n-                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n-                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n-            }\n-        }\n-\n-        // Iterate over each segment of the path.\n-        while let Some((def_id, defs)) = stack.pop() {\n-            let mut params = defs.params.iter();\n-            let mut next_param = params.next();\n-\n-            // `Self` is handled first.\n-            if has_self {\n-                if let Some(param) = next_param {\n-                    if param.index == 0 {\n-                        if let GenericParamDefKind::Type { .. } = param.kind {\n-                            push_kind(&mut substs, opt_self_ty.map(|ty| ty.into())\n-                                .unwrap_or_else(|| self.var_for_def(span, param)));\n-                            next_param = params.next();\n+        let substs = AstConv::create_substs_for_generic_args(\n+            self.tcx,\n+            span,\n+            true,\n+            def_id,\n+            &[][..],\n+            has_self,\n+            self_ty,\n+            // Provide the generic args, and whether types should be inferred.\n+            |def_id| {\n+                if let Some(&PathSeg(_, index)) = path_segs.iter().find(|&PathSeg(did, _)| {\n+                    *did == def_id\n+                }) {\n+                    // If we've encountered an `impl Trait`-related error, we're just\n+                    // going to infer the arguments for better error messages.\n+                    if !supress_errors[&index] {\n+                        // Check whether the user has provided generic arguments.\n+                        if let Some(ref data) = segments[index].args {\n+                            return (Some(data), segments[index].infer_types);\n                         }\n                     }\n+                    return (None, segments[index].infer_types);\n                 }\n-            }\n \n-            let mut infer_types = true;\n-            // Check whether this segment takes generic arguments.\n-            if let Some(&PathSeg(_, index)) = path_segs\n-                .iter()\n-                .find(|&PathSeg(did, _)| *did == def_id) {\n-                // If we've encountered an `impl Trait`-related error, we're just\n-                // going to infer the arguments for better error messages.\n-                if !supress_errors[&index] {\n-                    infer_types = segments[index].infer_types;\n-                    // Check whether the user has provided generic arguments.\n-                    if let Some(ref data) = segments[index].args {\n-                        let args = &data.args;\n-                        // We're going to iterate through the generic arguments that the user\n-                        // provided, matching them with the generic parameters we expect.\n-                        // Mismatches can occur as a result of elided lifetimes, or for malformed\n-                        // input. We try to handle both sensibly.\n-                        'args: for arg in args {\n-                            while let Some(param) = next_param {\n-                                match param.kind {\n-                                    GenericParamDefKind::Lifetime => match arg {\n-                                        GenericArg::Lifetime(lt) => {\n-                                            push_kind(&mut substs,\n-                                                AstConv::ast_region_to_region(self, lt, Some(param))\n-                                                .into());\n-                                            next_param = params.next();\n-                                            continue 'args;\n-                                        }\n-                                        GenericArg::Type(_) => {\n-                                            // We expected a lifetime argument, but got a type\n-                                            // argument. That means we're inferring the lifetimes.\n-                                            push_kind(&mut substs,\n-                                                self.re_infer(span, Some(param)).unwrap().into());\n-                                            next_param = params.next();\n-                                        }\n-                                    }\n-                                    GenericParamDefKind::Type { .. } => match arg {\n-                                        GenericArg::Type(ty) => {\n-                                            push_kind(&mut substs, self.to_ty(ty).into());\n-                                            next_param = params.next();\n-                                            continue 'args;\n-                                        }\n-                                        GenericArg::Lifetime(_) => {\n-                                            // We expected a type argument, but got a lifetime\n-                                            // argument. This is an error, but we need to handle it\n-                                            // gracefully so we can report sensible errors. In this\n-                                            // case, we're simply going to infer the remaining\n-                                            // arguments.\n-                                            self.tcx.sess.delay_span_bug(span,\n-                                                \"found a GenericArg::Lifetime where a \\\n-                                                 GenericArg::Type was expected\");\n-                                            break 'args;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                            // We should never be able to reach this point with well-formed input.\n-                            // Getting to this point means the user supplied more arguments than\n-                            // there are parameters.\n-                            self.tcx.sess.delay_span_bug(span,\n-                                \"GenericArg did not have matching GenericParamDef\");\n+                (None, true)\n+            },\n+            // Provide substitutions for parameters for which (valid) arguments have been provided.\n+            |param, arg| {\n+                match param.kind {\n+                    GenericParamDefKind::Lifetime => match arg {\n+                        GenericArg::Lifetime(lt) => {\n+                            AstConv::ast_region_to_region(self, lt, Some(param)).into()\n                         }\n+                        _ => unreachable!(),\n+                    }\n+                    GenericParamDefKind::Type { .. } => match arg {\n+                        GenericArg::Type(ty) => self.to_ty(ty).into(),\n+                        _ => unreachable!(),\n                     }\n                 }\n-            }\n-\n-            // If there are fewer arguments than parameters, it means\n-            // we're inferring the remaining arguments.\n-            while let Some(param) = next_param {\n+            },\n+            // Provide substitutions for parameters for which arguments are inferred.\n+            |substs, param, infer_types| {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n-                        push_kind(&mut substs, self.re_infer(span, Some(param)).unwrap().into());\n+                        self.re_infer(span, Some(param)).unwrap().into()\n                     }\n                     GenericParamDefKind::Type { has_default, .. } => {\n                         if !infer_types && has_default {\n                             // If we have a default, then we it doesn't matter that we're not\n                             // inferring the type arguments: we provide the default where any\n                             // is missing.\n                             let default = self.tcx.type_of(param.def_id);\n-                            let kind = self.normalize_ty(\n+                            self.normalize_ty(\n                                 span,\n-                                default.subst_spanned(self.tcx, &substs, Some(span))\n-                            ).into();\n-                            push_kind(&mut substs, kind);\n+                                default.subst_spanned(self.tcx, substs.unwrap(), Some(span))\n+                            ).into()\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n                             // This case also occurs as a result of some malformed input, e.g.\n                             // a lifetime argument being given instead of a type paramter.\n                             // Using inference instead of `TyError` gives better error messages.\n-                            push_kind(&mut substs, self.var_for_def(span, param));\n+                            self.var_for_def(span, param)\n                         }\n                     }\n                 }\n-                next_param = params.next();\n-            }\n-        }\n-        let substs = self.tcx.intern_substs(&substs);\n+            },\n+        );\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme."}]}