{"sha": "07228a104109b00ad3ec553a33eb6b496fc97451", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MjI4YTEwNDEwOWIwMGFkM2VjNTUzYTMzZWI2YjQ5NmZjOTc0NTE=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-12T14:51:55Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-12T14:51:55Z"}, "message": "Fix `Hash` implementation for `Constant`", "tree": {"sha": "f1f54d6b8dc951ad7d453013cad57a30ff8c3ed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1f54d6b8dc951ad7d453013cad57a30ff8c3ed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07228a104109b00ad3ec553a33eb6b496fc97451", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07228a104109b00ad3ec553a33eb6b496fc97451", "html_url": "https://github.com/rust-lang/rust/commit/07228a104109b00ad3ec553a33eb6b496fc97451", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07228a104109b00ad3ec553a33eb6b496fc97451/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68ecd06f4cf67a996af348a5ccc90d6a0f25589f", "url": "https://api.github.com/repos/rust-lang/rust/commits/68ecd06f4cf67a996af348a5ccc90d6a0f25589f", "html_url": "https://github.com/rust-lang/rust/commit/68ecd06f4cf67a996af348a5ccc90d6a0f25589f"}], "stats": {"total": 103, "additions": 68, "deletions": 35}, "files": [{"sha": "416ec82799c1d884081fc28160d40ab24ae556fe", "filename": "src/consts.rs", "status": "modified", "additions": 59, "deletions": 34, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/07228a104109b00ad3ec553a33eb6b496fc97451/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07228a104109b00ad3ec553a33eb6b496fc97451/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=07228a104109b00ad3ec553a33eb6b496fc97451", "patch": "@@ -2,22 +2,21 @@\n \n use rustc::lint::LateContext;\n use rustc::middle::const_eval::lookup_const_by_id;\n-use rustc::middle::def::PathResolution;\n-use rustc::middle::def::Def;\n+use rustc::middle::def::{Def, PathResolution};\n use rustc_front::hir::*;\n-use syntax::ptr::P;\n-use std::cmp::PartialOrd;\n use std::cmp::Ordering::{self, Greater, Less, Equal};\n-use std::rc::Rc;\n+use std::cmp::PartialOrd;\n+use std::hash::{Hash, Hasher};\n+use std::mem;\n use std::ops::Deref;\n-\n-use syntax::ast::Lit_;\n-use syntax::ast::LitIntType;\n-use syntax::ast::{UintTy, FloatTy, StrStyle};\n+use std::rc::Rc;\n+use syntax::ast::{LitIntType, Lit_};\n use syntax::ast::Sign::{self, Plus, Minus};\n+use syntax::ast::{UintTy, FloatTy, StrStyle};\n+use syntax::ptr::P;\n \n \n-#[derive(PartialEq, Eq, Debug, Copy, Clone, Hash)]\n+#[derive(Debug, Copy, Clone)]\n pub enum FloatWidth {\n     Fw32,\n     Fw64,\n@@ -34,7 +33,7 @@ impl From<FloatTy> for FloatWidth {\n }\n \n /// a Lit_-like enum to fold constant `Expr`s into\n-#[derive(Eq, Debug, Clone, Hash)]\n+#[derive(Debug, Clone)]\n pub enum Constant {\n     /// a String \"abc\"\n     Str(String, StrStyle),\n@@ -100,18 +99,12 @@ impl PartialEq for Constant {\n             (&Constant::Int(lv, lty), &Constant::Int(rv, rty)) => {\n                 lv == rv && (is_negative(lty) & (lv != 0)) == (is_negative(rty) & (rv != 0))\n             }\n-            (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n-                use self::FloatWidth::*;\n-                if match (lw, rw) {\n-                    (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n+            (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n+                // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n+                // `Fw32 == Fw64` so don\u2019t compare them\n+                match (ls.parse::<f64>(), rs.parse::<f64>()) {\n+                    (Ok(l), Ok(r)) => l.eq(&r),\n                     _ => false,\n-                } {\n-                    match (ls.parse::<f64>(), rs.parse::<f64>()) {\n-                        (Ok(l), Ok(r)) => l.eq(&r),\n-                        _ => false,\n-                    }\n-                } else {\n-                    false\n                 }\n             }\n             (&Constant::Bool(l), &Constant::Bool(r)) => l == r,\n@@ -123,6 +116,46 @@ impl PartialEq for Constant {\n     }\n }\n \n+impl Hash for Constant {\n+    fn hash<H>(&self, state: &mut H) where H: Hasher {\n+        match *self {\n+            Constant::Str(ref s, ref k) => {\n+                s.hash(state);\n+                k.hash(state);\n+            }\n+            Constant::Binary(ref b) => {\n+                b.hash(state);\n+            }\n+            Constant::Byte(u) => {\n+                u.hash(state);\n+            }\n+            Constant::Char(c) => {\n+                c.hash(state);\n+            }\n+            Constant::Int(u, t) => {\n+                u.hash(state);\n+                t.hash(state);\n+            }\n+            Constant::Float(ref f, _) => {\n+                // don\u2019t use the width here because of PartialEq implementation\n+                if let Ok(f) = f.parse::<f64>() {\n+                    unsafe { mem::transmute::<f64, u64>(f) }.hash(state);\n+                }\n+            }\n+            Constant::Bool(b) => {\n+                b.hash(state);\n+            }\n+            Constant::Vec(ref v) | Constant::Tuple(ref v)=> {\n+                v.hash(state);\n+            }\n+            Constant::Repeat(ref c, l) => {\n+                c.hash(state);\n+                l.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n impl PartialOrd for Constant {\n     fn partial_cmp(&self, other: &Constant) -> Option<Ordering> {\n         match (self, other) {\n@@ -143,18 +176,10 @@ impl PartialOrd for Constant {\n                     (false, true) => Greater,\n                 })\n             }\n-            (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n-                use self::FloatWidth::*;\n-                if match (lw, rw) {\n-                    (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n-                    _ => false,\n-                } {\n-                    match (ls.parse::<f64>(), rs.parse::<f64>()) {\n-                        (Ok(ref l), Ok(ref r)) => l.partial_cmp(r),\n-                        _ => None,\n-                    }\n-                } else {\n-                    None\n+            (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n+                match (ls.parse::<f64>(), rs.parse::<f64>()) {\n+                    (Ok(ref l), Ok(ref r)) => l.partial_cmp(r),\n+                    _ => None,\n                 }\n             }\n             (&Constant::Bool(ref l), &Constant::Bool(ref r)) => Some(l.cmp(r)),"}, {"sha": "ab8636b8131dcde1fdaed92430b3ef85f71e1588", "filename": "tests/consts.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/07228a104109b00ad3ec553a33eb6b496fc97451/tests%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07228a104109b00ad3ec553a33eb6b496fc97451/tests%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconsts.rs?ref=07228a104109b00ad3ec553a33eb6b496fc97451", "patch": "@@ -17,7 +17,7 @@ use syntax::ast::LitIntType::*;\n use syntax::ast::StrStyle::*;\n use syntax::ast::Sign::*;\n \n-use clippy::consts::{constant_simple, Constant};\n+use clippy::consts::{constant_simple, Constant, FloatWidth};\n \n fn spanned<T>(t: T) -> Spanned<T> {\n     Spanned{ node: t, span: COMMAND_LINE_SP }\n@@ -78,4 +78,12 @@ fn test_ops() {\n     check(ONE, &binop(BiSub, litone.clone(), litzero.clone()));\n     check(ONE, &binop(BiMul, litone.clone(), litone.clone()));\n     check(ONE, &binop(BiDiv, litone.clone(), litone.clone()));\n+\n+    let half_any = Constant::Float(\"0.5\".into(), FloatWidth::FwAny);\n+    let half32 = Constant::Float(\"0.5\".into(), FloatWidth::Fw32);\n+    let half64 = Constant::Float(\"0.5\".into(), FloatWidth::Fw64);\n+\n+    assert_eq!(half_any, half32);\n+    assert_eq!(half_any, half64);\n+    assert_eq!(half32, half64); // for transitivity\n }"}]}