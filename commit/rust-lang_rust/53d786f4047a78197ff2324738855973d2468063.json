{"sha": "53d786f4047a78197ff2324738855973d2468063", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZDc4NmY0MDQ3YTc4MTk3ZmYyMzI0NzM4ODU1OTczZDI0NjgwNjM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-03T11:31:27Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-03T11:31:27Z"}, "message": "Rollup merge of #70728 - TimDiekmann:allocref-doc, r=Amanieu\n\nMinor doc improvements on `AllocRef`\n\nr? @Amanieu", "tree": {"sha": "1e045355c26f5c120e8bdaa71e6b9a0a29ed0124", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e045355c26f5c120e8bdaa71e6b9a0a29ed0124"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53d786f4047a78197ff2324738855973d2468063", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJehx6PCRBK7hj4Ov3rIwAAdHIIAB8R0l61RxyIHC5Fd3W2OJpB\nZp8bucCAlqz8fXIJeviQdDbXKWeHsz7g6ZGqELGl5F7OsEsxVNJL0EMSt6Yrutky\ndgpktYGX/D7+za8zw21vpfsNLzacuhcPpko9Zc59BPTukr505sOF3VY8iGCQB3n+\nxoRnk5OqpxWb2CW0t27hku5wN+6EaWoPltvK/JVyxVNYY133oFyQm+XLbvEZysY8\n10g+PTWhXQrWepoumeBBOMOcfU1pnUvUclkqzl9ze201Yit+GIzJNxliYwinvMOE\nDMWqzStPV7SB0UBwmOVsPc57XdhU/58vR1FsGE7tdoAczq/O7HvuNoM3fmWLhS0=\n=aTO6\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e045355c26f5c120e8bdaa71e6b9a0a29ed0124\nparent b91c376e4a1b7735dbe36db06c03603a2dd8e4d8\nparent c061ff4b6957572d0d1e3ed48e63d07c7946e269\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585913487 +0200\ncommitter GitHub <noreply@github.com> 1585913487 +0200\n\nRollup merge of #70728 - TimDiekmann:allocref-doc, r=Amanieu\n\nMinor doc improvements on `AllocRef`\n\nr? @Amanieu\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53d786f4047a78197ff2324738855973d2468063", "html_url": "https://github.com/rust-lang/rust/commit/53d786f4047a78197ff2324738855973d2468063", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53d786f4047a78197ff2324738855973d2468063/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8", "html_url": "https://github.com/rust-lang/rust/commit/b91c376e4a1b7735dbe36db06c03603a2dd8e4d8"}, {"sha": "c061ff4b6957572d0d1e3ed48e63d07c7946e269", "url": "https://api.github.com/repos/rust-lang/rust/commits/c061ff4b6957572d0d1e3ed48e63d07c7946e269", "html_url": "https://github.com/rust-lang/rust/commit/c061ff4b6957572d0d1e3ed48e63d07c7946e269"}], "stats": {"total": 41, "additions": 22, "deletions": 19}, "files": [{"sha": "e1892edb7c7f3014852ecf9bbfcbd58d1fb30b2f", "filename": "src/libcore/alloc/mod.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/53d786f4047a78197ff2324738855973d2468063/src%2Flibcore%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53d786f4047a78197ff2324738855973d2468063/src%2Flibcore%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc%2Fmod.rs?ref=53d786f4047a78197ff2324738855973d2468063", "patch": "@@ -119,7 +119,7 @@ pub enum ReallocPlacement {\n ///\n /// Unlike [`GlobalAlloc`][], zero-sized allocations are allowed in `AllocRef`. If an underlying\n /// allocator does not support this (like jemalloc) or return a null pointer (such as\n-/// `libc::malloc`), this case must be caught.\n+/// `libc::malloc`), this must be caught by the implementation.\n ///\n /// ### Currently allocated memory\n ///\n@@ -157,18 +157,20 @@ pub enum ReallocPlacement {\n /// # Safety\n ///\n /// * Memory blocks returned from an allocator must point to valid memory and retain their validity\n-///   until the instance and all of its clones are dropped, and\n+///   until the instance and all of its clones are dropped,\n ///\n /// * cloning or moving the allocator must not invalidate memory blocks returned from this\n-///   allocator. A cloned allocator must behave like the same allocator.\n+///   allocator. A cloned allocator must behave like the same allocator, and\n ///\n /// * any pointer to a memory block which is [*currently allocated*] may be passed to any other\n ///   method of the allocator.\n ///\n /// [*currently allocated*]: #currently-allocated-memory\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub unsafe trait AllocRef {\n-    /// On success, returns a memory block meeting the size and alignment guarantees of `layout`.\n+    /// Attempts to allocate a block of memory.\n+    ///\n+    /// On success, returns a [`MemoryBlock`][] meeting the size and alignment guarantees of `layout`.\n     ///\n     /// The returned block may have a larger size than specified by `layout.size()` and is\n     /// initialized as specified by [`init`], all the way up to the returned size of the block.\n@@ -190,26 +192,26 @@ pub unsafe trait AllocRef {\n     /// [`handle_alloc_error`]: ../../alloc/alloc/fn.handle_alloc_error.html\n     fn alloc(&mut self, layout: Layout, init: AllocInit) -> Result<MemoryBlock, AllocErr>;\n \n-    /// Deallocates the memory denoted by `memory`.\n+    /// Deallocates the memory referenced by `ptr`.\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator, and\n-    /// * `layout` must [*fit*] the `ptr`.\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator, and\n+    /// * `layout` must [*fit*] that block of memory.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n     unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout);\n \n     /// Attempts to extend the memory block.\n     ///\n-    /// Returns a new memory block containing a pointer and the actual size of the allocated\n-    /// block. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may extend the\n     /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n     /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n     ///\n-    /// If `ReallocPlacement::MayMove` is used then ownership of the memory block referenced by `ptr`\n+    /// If [`MayMove`] is used then ownership of the memory block referenced by `ptr`\n     /// is transferred to this allocator. The memory may or may not be freed, and should be\n     /// considered unusable (unless of course it is transferred back to the caller again via the\n     /// return value of this method).\n@@ -227,17 +229,18 @@ pub unsafe trait AllocRef {\n     ///     the size of the `MemoryBlock` returned by the `grow` call.\n     ///\n     /// [`InPlace`]: ReallocPlacement::InPlace\n+    /// [`MayMove`]: ReallocPlacement::MayMove\n     /// [`placement`]: ReallocPlacement\n     /// [`init`]: AllocInit\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.),\n     // We can't require that `new_size` is strictly greater than `memory.size` because of ZSTs.\n     // An alternative would be\n     // * `new_size must be strictly greater than `memory.size` or both are zero\n-    /// * `new_size` must be greater than or equal to `layout.size()`\n+    /// * `new_size` must be greater than or equal to `layout.size()`, and\n     /// * `new_size`, when rounded up to the nearest multiple of `layout.align()`, must not overflow\n     ///   (i.e., the rounded value must be less than or equal to `usize::MAX`).\n     ///\n@@ -289,8 +292,8 @@ pub unsafe trait AllocRef {\n \n     /// Attempts to shrink the memory block.\n     ///\n-    /// Returns a new memory block containing a pointer and the actual size of the allocated\n-    /// block. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n+    /// Returns a new [`MemoryBlock`][] containing a pointer and the actual size of the allocated\n+    /// memory. The pointer is suitable for holding data described by a new layout with `layout`\u2019s\n     /// alignment and a size given by `new_size`. To accomplish this, the allocator may shrink the\n     /// allocation referenced by `ptr` to fit the new layout. If the [`placement`] is\n     /// [`InPlace`], the returned pointer is guaranteed to be the same as the passed `ptr`.\n@@ -310,20 +313,20 @@ pub unsafe trait AllocRef {\n     ///\n     /// # Safety\n     ///\n-    /// * `ptr` must be [*currently allocated*] via this allocator,\n-    /// * `layout` must [*fit*] the `ptr`. (The `new_size` argument need not fit it.)\n+    /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator,\n+    /// * `layout` must [*fit*] that block of memory (The `new_size` argument need not fit it.), and\n     // We can't require that `new_size` is strictly smaller than `memory.size` because of ZSTs.\n     // An alternative would be\n     // * `new_size must be strictly smaller than `memory.size` or both are zero\n-    /// * `new_size` must be smaller than or equal to `layout.size()`\n+    /// * `new_size` must be smaller than or equal to `layout.size()`.\n     ///\n     /// [*currently allocated*]: #currently-allocated-memory\n     /// [*fit*]: #memory-fitting\n     ///\n     /// # Errors\n     ///\n     /// Returns `Err` if the new layout does not meet the allocator's size and alignment\n-    /// constraints of the allocator, or if growing otherwise fails.\n+    /// constraints of the allocator, or if shrinking otherwise fails.\n     ///\n     /// Implementations are encouraged to return `Err` on memory exhaustion rather than panicking or\n     /// aborting, but this is not a strict requirement. (Specifically: it is *legal* to implement"}]}