{"sha": "4d04b0b0fe16dbf2227b308907bc2652be4c7c95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMDRiMGIwZmUxNmRiZjIyMjdiMzA4OTA3YmMyNjUyYmU0YzdjOTU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-02T03:02:48Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-02T03:02:48Z"}, "message": "Remove wrong advice about spin locks from `spin_loop_hint` docs\n\nUsing a pure spin lock for a critical section in a preemptable thread\nis always wrong, however short the critical section may be. The thread\nmight be preempted, which will cause all other threads to hammer\nbusily at the core for the whole quant. Moreover, if threads have\ndifferent priorities, this might lead to a priority inversion problem\nand a deadlock. More generally, a spinlock is not more efficient than\na well-written mutex, which typically does several spin iterations at\nthe start anyway.\n\nThe advise about UP vs SMP is also irrelevant in the context of\npreemptive threads.", "tree": {"sha": "7b4e47929627906cce3cb20ae863c692f56c740e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b4e47929627906cce3cb20ae863c692f56c740e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d04b0b0fe16dbf2227b308907bc2652be4c7c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d04b0b0fe16dbf2227b308907bc2652be4c7c95", "html_url": "https://github.com/rust-lang/rust/commit/4d04b0b0fe16dbf2227b308907bc2652be4c7c95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d04b0b0fe16dbf2227b308907bc2652be4c7c95/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ec370670220b712b042ee09aab067ec7e5878d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec370670220b712b042ee09aab067ec7e5878d5", "html_url": "https://github.com/rust-lang/rust/commit/0ec370670220b712b042ee09aab067ec7e5878d5"}], "stats": {"total": 12, "additions": 2, "deletions": 10}, "files": [{"sha": "ba41cd2b7a08e7a66366dae44de6f8f2fdcef934", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4d04b0b0fe16dbf2227b308907bc2652be4c7c95/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d04b0b0fe16dbf2227b308907bc2652be4c7c95/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=4d04b0b0fe16dbf2227b308907bc2652be4c7c95", "patch": "@@ -134,16 +134,8 @@ use crate::hint::spin_loop;\n /// This function is different from [`std::thread::yield_now`] which directly yields to the\n /// system's scheduler, whereas `spin_loop_hint` does not interact with the operating system.\n ///\n-/// Spin locks can be very efficient for short lock durations because they do not involve context\n-/// switches or interaction with the operating system. For long lock durations they become wasteful\n-/// however because they use CPU cycles for the entire lock duration, and using a\n-/// [`std::sync::Mutex`] is likely the better approach. If actively spinning for a long time is\n-/// required, e.g. because code polls a non-blocking API, calling [`std::thread::yield_now`]\n-/// or [`std::thread::sleep`] may be the best option.\n-///\n-/// **Note**: Spin locks are based on the underlying assumption that another thread will release\n-/// the lock 'soon'. In order for this to work, that other thread must run on a different CPU or\n-/// core (at least potentially). Spin locks do not work efficiently on single CPU / core platforms.\n+/// If actively spinning for a long time is required, e.g. because code polls a non-blocking API,\n+/// calling [`std::thread::yield_now`] or [`std::thread::sleep`] may be the best option.\n ///\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all."}]}