{"sha": "dd1564a6d34ccc80152a0b609022da03f5f5bfa8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkMTU2NGE2ZDM0Y2NjODAxNTJhMGI2MDkwMjJkYTAzZjVmNWJmYTg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-30T23:44:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-31T03:37:32Z"}, "message": "rustdoc: Add iface method type info to the doc tree", "tree": {"sha": "cd0a8f148fa35388494c414024d651798882b4c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd0a8f148fa35388494c414024d651798882b4c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dd1564a6d34ccc80152a0b609022da03f5f5bfa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dd1564a6d34ccc80152a0b609022da03f5f5bfa8", "html_url": "https://github.com/rust-lang/rust/commit/dd1564a6d34ccc80152a0b609022da03f5f5bfa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dd1564a6d34ccc80152a0b609022da03f5f5bfa8/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c77579812460c2b3bf473bd560a1beed32d5fdf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c77579812460c2b3bf473bd560a1beed32d5fdf5", "html_url": "https://github.com/rust-lang/rust/commit/c77579812460c2b3bf473bd560a1beed32d5fdf5"}], "stats": {"total": 196, "additions": 185, "deletions": 11}, "files": [{"sha": "9f6e5b013b5614f7e1df396dfae2088b2ac6a6d5", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 185, "deletions": 11, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/dd1564a6d34ccc80152a0b609022da03f5f5bfa8/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dd1564a6d34ccc80152a0b609022da03f5f5bfa8/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=dd1564a6d34ccc80152a0b609022da03f5f5bfa8", "patch": "@@ -19,7 +19,8 @@ fn run(\n         fold_fn: fold_fn,\n         fold_const: fold_const,\n         fold_enum: fold_enum,\n-        fold_res: fold_res\n+        fold_res: fold_res,\n+        fold_iface: fold_iface\n         with *fold::default_seq_fold(srv)\n     });\n     fold.fold_crate(fold, doc)\n@@ -84,17 +85,21 @@ fn get_ret_ty(srv: astsrv::srv, fn_id: doc::ast_id) -> option<str> {\n           ast_map::node_item(@{\n             node: ast::item_fn(decl, _, _), _\n           }) {\n-            if decl.output.node != ast::ty_nil {\n-                some(pprust::ty_to_str(decl.output))\n-            } else {\n-                // Nil-typed return values are not interesting\n-                none\n-            }\n+            ret_ty_to_str(decl)\n           }\n         }\n     }\n }\n \n+fn ret_ty_to_str(decl: ast::fn_decl) -> option<str> {\n+    if decl.output.node != ast::ty_nil {\n+        some(pprust::ty_to_str(decl.output))\n+    } else {\n+        // Nil-typed return values are not interesting\n+        none\n+    }\n+}\n+\n #[test]\n fn should_add_fn_ret_types() {\n     let source = \"fn a() -> int { }\";\n@@ -138,14 +143,18 @@ fn get_arg_tys(srv: astsrv::srv, fn_id: doc::ast_id) -> [(str, str)] {\n           ast_map::node_item(@{\n             node: ast::item_res(decl, _, _, _, _), _\n           }) {\n-            vec::map(decl.inputs) {|arg|\n-                (arg.ident, pprust::ty_to_str(arg.ty))\n-            }\n+            decl_arg_tys(decl)\n           }\n         }\n     }\n }\n \n+fn decl_arg_tys(decl: ast::fn_decl) -> [(str, str)] {\n+    vec::map(decl.inputs) {|arg|\n+        (arg.ident, pprust::ty_to_str(arg.ty))\n+    }\n+}\n+\n #[test]\n fn should_add_arg_types() {\n     let source = \"fn a(b: int, c: bool) { }\";\n@@ -264,4 +273,169 @@ fn should_add_resource_arg_tys() {\n     let doc = extract::from_srv(srv, \"\");\n     let doc = run(srv, doc);\n     assert doc.topmod.resources()[0].args[0].ty == some(\"bool\");\n-}\n\\ No newline at end of file\n+}\n+\n+fn fold_iface(\n+    fold: fold::fold<astsrv::srv>,\n+    doc: doc::ifacedoc\n+) -> doc::ifacedoc {\n+\n+    let srv = fold.ctxt;\n+\n+    {\n+        methods: vec::map(doc.methods) {|methoddoc|\n+            {\n+                args: merge_method_arg_tys(\n+                    srv,\n+                    doc.id,\n+                    methoddoc.args,\n+                    methoddoc.name),\n+                return: merge_method_ret_ty(\n+                    srv,\n+                    doc.id,\n+                    methoddoc.return,\n+                    methoddoc.name),\n+                sig: get_method_sig(srv, doc.id, methoddoc.name)\n+                with methoddoc\n+            }\n+        }\n+        with doc\n+    }\n+}\n+\n+fn merge_method_ret_ty(\n+    srv: astsrv::srv,\n+    item_id: doc::ast_id,\n+    doc: doc::retdoc,\n+    method_name: str\n+) -> doc::retdoc {\n+    alt get_method_ret_ty(srv, item_id, method_name) {\n+      some(ty) {\n+        {\n+            ty: some(ty)\n+            with doc\n+        }\n+      }\n+      none { doc }\n+    }\n+}\n+\n+fn get_method_ret_ty(\n+    srv: astsrv::srv,\n+    item_id: doc::ast_id,\n+    method_name: str\n+) -> option<str> {\n+    astsrv::exec(srv) {|ctxt|\n+        alt ctxt.ast_map.get(item_id) {\n+          ast_map::node_item(@{\n+            node: ast::item_iface(_, methods), _\n+          }) {\n+            alt vec::find(methods) {|method|\n+                method.ident == method_name\n+            } {\n+                some(method) {\n+                    ret_ty_to_str(method.decl)\n+                }\n+            }\n+          }\n+        }\n+    }\n+}\n+\n+fn get_method_sig(\n+    srv: astsrv::srv,\n+    item_id: doc::ast_id,\n+    method_name: str\n+) -> option<str> {\n+    astsrv::exec(srv) {|ctxt|\n+        alt ctxt.ast_map.get(item_id) {\n+          ast_map::node_item(@{\n+            node: ast::item_iface(_, methods), _\n+          }) {\n+            alt vec::find(methods) {|method|\n+                method.ident == method_name\n+            } {\n+                some(method) {\n+                    some(pprust::fun_to_str(method.decl, method.ident, []))\n+                }\n+            }\n+          }\n+        }\n+    }\n+}\n+\n+fn merge_method_arg_tys(\n+    srv: astsrv::srv,\n+    item_id: doc::ast_id,\n+    args: [doc::argdoc],\n+    method_name: str\n+) -> [doc::argdoc] {\n+    let tys = get_method_arg_tys(srv, item_id, method_name);\n+    vec::map2(args, tys) {|arg, ty|\n+        assert arg.name == tuple::first(ty);\n+        {\n+            ty: some(tuple::second(ty))\n+            with arg\n+        }\n+    }\n+}\n+\n+fn get_method_arg_tys(\n+    srv: astsrv::srv,\n+    item_id: doc::ast_id,\n+    method_name: str\n+) -> [(str, str)] {\n+    astsrv::exec(srv) {|ctxt|\n+        alt ctxt.ast_map.get(item_id) {\n+          ast_map::node_item(@{\n+            node: ast::item_iface(_, methods), _\n+          }) {\n+            alt vec::find(methods) {|method|\n+                method.ident == method_name\n+            } {\n+                some(method) {\n+                    decl_arg_tys(method.decl)\n+                }\n+            }\n+          }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn should_add_iface_method_sigs() {\n+    let source = \"iface i { fn a() -> int; }\";\n+    let srv = astsrv::mk_srv_from_str(source);\n+    let doc = extract::from_srv(srv, \"\");\n+    let doc = run(srv, doc);\n+    assert doc.topmod.ifaces()[0].methods[0].sig == some(\"fn a() -> int\");\n+}\n+\n+#[test]\n+fn should_add_iface_method_ret_types() {\n+    let source = \"iface i { fn a() -> int; }\";\n+    let srv = astsrv::mk_srv_from_str(source);\n+    let doc = extract::from_srv(srv, \"\");\n+    let doc = run(srv, doc);\n+    assert doc.topmod.ifaces()[0].methods[0].return.ty == some(\"int\");\n+}\n+\n+#[test]\n+fn should_not_add_iface_method_nil_ret_type() {\n+    let source = \"iface i { fn a(); }\";\n+    let srv = astsrv::mk_srv_from_str(source);\n+    let doc = extract::from_srv(srv, \"\");\n+    let doc = run(srv, doc);\n+    assert doc.topmod.ifaces()[0].methods[0].return.ty == none;\n+}\n+\n+#[test]\n+fn should_add_iface_method_arg_types() {\n+    let source = \"iface i { fn a(b: int, c: bool); }\";\n+    let srv = astsrv::mk_srv_from_str(source);\n+    let doc = extract::from_srv(srv, \"\");\n+    let doc = run(srv, doc);\n+    let fn_ = doc.topmod.ifaces()[0].methods[0];\n+    assert fn_.args[0].ty == some(\"int\");\n+    assert fn_.args[1].ty == some(\"bool\");\n+}"}]}