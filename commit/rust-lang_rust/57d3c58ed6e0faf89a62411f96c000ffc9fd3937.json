{"sha": "57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "node_id": "C_kwDOAAsO6NoAKDU3ZDNjNThlZDZlMGZhZjg5YTYyNDExZjk2YzAwMGZmYzlmZDM5Mzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-08T06:49:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-08T06:49:52Z"}, "message": "Auto merge of #104138 - Dylan-DPC:rollup-m3ojpjg, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #103446 (Specialize `iter::ArrayChunks::fold` for TrustedRandomAccess iterators)\n - #103651 (Fix `rustc_parse_format` spans following escaped utf-8 multibyte chars)\n - #103865 (Move `fallback_has_occurred` state tracking to `FnCtxt`)\n - #103955 (Update linker-plugin-lto.md to contain up to Rust 1.65)\n - #103987 (Remove `in_tail_expr` from FnCtxt)\n - #104067 (fix debuginfo for windows_gnullvm_base.rs)\n - #104094 (fully move `on_unimplemented` to `error_reporting`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "66417c1d251dbe3b3ce934574a322963d17e8065", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66417c1d251dbe3b3ce934574a322963d17e8065"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "html_url": "https://github.com/rust-lang/rust/commit/57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "html_url": "https://github.com/rust-lang/rust/commit/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14"}, {"sha": "c23068c8c623fac0ca6c261555235a979f1c5fd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c23068c8c623fac0ca6c261555235a979f1c5fd5", "html_url": "https://github.com/rust-lang/rust/commit/c23068c8c623fac0ca6c261555235a979f1c5fd5"}], "stats": {"total": 1469, "additions": 843, "deletions": 626}, "files": [{"sha": "103c7ed8ef7012167c83c9a23e73315d50731185", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -299,7 +299,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         if errors.is_empty() {\n             definition_ty\n         } else {\n-            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n             self.tcx.ty_error()\n         }\n     }"}, {"sha": "5a8b3e30b9fc0cdaab6bc89e90bfbb3624ee2668", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -765,7 +765,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n                         let errors = ocx.select_all_or_error();\n                         if !errors.is_empty() {\n-                            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                            infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n                         }\n                     }\n \n@@ -831,7 +831,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                                         obligation.clone(),\n                                         &obligation,\n                                         &e,\n-                                        false,\n                                     );\n                                 }\n "}, {"sha": "0ba5e61510125d10e187a6269996729c21b46280", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -26,6 +26,7 @@ use rustc_session::lint::builtin::{UNINHABITED_STATIC, UNSUPPORTED_CALLING_CONVE\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedDirective;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCtxt};\n \n@@ -471,7 +472,7 @@ fn check_opaque_meets_bounds<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n     }\n     match origin {\n         // Checked when type checking the function containing them.\n@@ -655,7 +656,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n \n pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n+    let _ = OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n }\n \n pub(super) fn check_specialization_validity<'tcx>("}, {"sha": "0e8ac17fb71b1588ad19e937cf03f413ca24b73e", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -405,7 +405,7 @@ fn compare_predicate_entailment<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n \n@@ -538,7 +538,7 @@ pub fn collect_trait_impl_trait_tys<'tcx>(\n     // RPITs.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n \n@@ -1431,7 +1431,7 @@ pub(crate) fn raw_compare_const_impl<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None, false));\n+        return Err(infcx.err_ctxt().report_fulfillment_errors(&errors, None));\n     }\n \n     // FIXME return `ErrorReported` if region obligations error?\n@@ -1549,7 +1549,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n \n@@ -1769,7 +1769,7 @@ pub fn check_type_bounds<'tcx>(\n     // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return Err(reported);\n     }\n "}, {"sha": "e2c967d0b0836e03a2936ca434f091b761d92cda", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -105,7 +105,7 @@ pub(super) fn enter_wf_checking_ctxt<'tcx, F>(\n     f(&mut wfcx);\n     let errors = wfcx.select_all_or_error();\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return;\n     }\n "}, {"sha": "6f74ef3ccad6d75684c5576e5861fb83ac38425f", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -321,7 +321,7 @@ fn visit_implementation_of_dispatch_from_dyn<'tcx>(tcx: TyCtxt<'tcx>, impl_did:\n                     }),\n                 );\n                 if !errors.is_empty() {\n-                    infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n                 }\n \n                 // Finally, resolve all regions.\n@@ -561,7 +561,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n         predicate_for_trait_def(tcx, param_env, cause, trait_def_id, 0, source, &[target.into()]);\n     let errors = traits::fully_solve_obligation(&infcx, predicate);\n     if !errors.is_empty() {\n-        infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n     }\n \n     // Finally, resolve all regions."}, {"sha": "267077cdab4e62abe8f2a839445dc1e5df76f684", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -155,7 +155,7 @@ fn get_impl_substs<'tcx>(\n \n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+        ocx.infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n         return None;\n     }\n "}, {"sha": "664d3a3a1db84c3d5e8cefd394ee650daaff1613", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -173,7 +173,7 @@ fn require_same_types<'tcx>(\n     match &errors[..] {\n         [] => true,\n         errors => {\n-            infcx.err_ctxt().report_fulfillment_errors(errors, None, false);\n+            infcx.err_ctxt().report_fulfillment_errors(errors, None);\n             false\n         }\n     }\n@@ -336,7 +336,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         ocx.register_bound(cause, param_env, norm_return_ty, term_did);\n         let errors = ocx.select_all_or_error();\n         if !errors.is_empty() {\n-            infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n             error = true;\n         }\n         // now we can take the return type of the given main function"}, {"sha": "6a4a6a5b0a546716721f3bf2d9ec77cbd0a6ed5a", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 73, "deletions": 50, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -1,6 +1,6 @@\n use crate::coercion::{AsCoercionSite, CoerceMany};\n use crate::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc_errors::{Applicability, MultiSpan};\n+use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir::{self as hir, ExprKind};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::traits::Obligation;\n@@ -137,55 +137,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(&arm.body),\n                 arm_ty,\n                 Some(&mut |err| {\n-                    let Some(ret) = self\n-                        .tcx\n-                        .hir()\n-                        .find_by_def_id(self.body_id.owner.def_id)\n-                        .and_then(|owner| owner.fn_decl())\n-                        .map(|decl| decl.output.span())\n-                    else { return; };\n-                    let Expectation::IsLast(stmt) = orig_expected else {\n-                        return\n-                    };\n-                    let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n-                        Some(ret_coercion) if self.in_tail_expr => {\n-                            let ret_ty = ret_coercion.borrow().expected_ty();\n-                            let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n-                            self.can_coerce(arm_ty, ret_ty)\n-                                && prior_arm.map_or(true, |(_, t, _)| self.can_coerce(t, ret_ty))\n-                                // The match arms need to unify for the case of `impl Trait`.\n-                                && !matches!(ret_ty.kind(), ty::Opaque(..))\n-                        }\n-                        _ => false,\n-                    };\n-                    if !can_coerce_to_return_ty {\n-                        return;\n-                    }\n-\n-                    let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n-                    let mut ret_span: MultiSpan = semi_span.into();\n-                    ret_span.push_span_label(\n-                        expr.span,\n-                        \"this could be implicitly returned but it is a statement, not a \\\n-                            tail expression\",\n-                    );\n-                    ret_span\n-                        .push_span_label(ret, \"the `match` arms can conform to this return type\");\n-                    ret_span.push_span_label(\n-                        semi_span,\n-                        \"the `match` is a statement because of this semicolon, consider \\\n-                            removing it\",\n-                    );\n-                    err.span_note(\n-                        ret_span,\n-                        \"you might have meant to return the `match` expression\",\n-                    );\n-                    err.tool_only_span_suggestion(\n-                        semi_span,\n-                        \"remove this semicolon\",\n-                        \"\",\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                    self.suggest_removing_semicolon_for_coerce(\n+                        err,\n+                        expr,\n+                        orig_expected,\n+                        arm_ty,\n+                        prior_arm,\n+                    )\n                 }),\n                 false,\n             );\n@@ -219,6 +177,71 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         coercion.complete(self)\n     }\n \n+    fn suggest_removing_semicolon_for_coerce(\n+        &self,\n+        diag: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expectation: Expectation<'tcx>,\n+        arm_ty: Ty<'tcx>,\n+        prior_arm: Option<(Option<hir::HirId>, Ty<'tcx>, Span)>,\n+    ) {\n+        let hir = self.tcx.hir();\n+\n+        // First, check that we're actually in the tail of a function.\n+        let hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Block(block, _), .. }) =\n+            hir.get(self.body_id) else { return; };\n+        let Some(hir::Stmt { kind: hir::StmtKind::Semi(last_expr), .. })\n+            = block.innermost_block().stmts.last() else {  return; };\n+        if last_expr.hir_id != expr.hir_id {\n+            return;\n+        }\n+\n+        // Next, make sure that we have no type expectation.\n+        let Some(ret) = hir\n+            .find_by_def_id(self.body_id.owner.def_id)\n+            .and_then(|owner| owner.fn_decl())\n+            .map(|decl| decl.output.span()) else { return; };\n+        let Expectation::IsLast(stmt) = expectation else {\n+            return;\n+        };\n+\n+        let can_coerce_to_return_ty = match self.ret_coercion.as_ref() {\n+            Some(ret_coercion) => {\n+                let ret_ty = ret_coercion.borrow().expected_ty();\n+                let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n+                self.can_coerce(arm_ty, ret_ty)\n+                    && prior_arm.map_or(true, |(_, ty, _)| self.can_coerce(ty, ret_ty))\n+                    // The match arms need to unify for the case of `impl Trait`.\n+                    && !matches!(ret_ty.kind(), ty::Opaque(..))\n+            }\n+            _ => false,\n+        };\n+        if !can_coerce_to_return_ty {\n+            return;\n+        }\n+\n+        let semi_span = expr.span.shrink_to_hi().with_hi(stmt.hi());\n+        let mut ret_span: MultiSpan = semi_span.into();\n+        ret_span.push_span_label(\n+            expr.span,\n+            \"this could be implicitly returned but it is a statement, not a \\\n+                            tail expression\",\n+        );\n+        ret_span.push_span_label(ret, \"the `match` arms can conform to this return type\");\n+        ret_span.push_span_label(\n+            semi_span,\n+            \"the `match` is a statement because of this semicolon, consider \\\n+                            removing it\",\n+        );\n+        diag.span_note(ret_span, \"you might have meant to return the `match` expression\");\n+        diag.tool_only_span_suggestion(\n+            semi_span,\n+            \"remove this semicolon\",\n+            \"\",\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm<'tcx>]) {"}, {"sha": "3c57e33f6f7fb164e10213569cf5a32cd538343c", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -100,7 +100,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     inherited.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    fcx.in_tail_expr = true;\n     if let ty::Dynamic(..) = declared_ret_ty.kind() {\n         // FIXME: We need to verify that the return type is `Sized` after the return expression has\n         // been evaluated so that we have types available for all the nodes being returned, but that\n@@ -119,7 +118,6 @@ pub(super) fn check_fn<'a, 'tcx>(\n         fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n         fcx.check_return_expr(&body.value, false);\n     }\n-    fcx.in_tail_expr = false;\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator."}, {"sha": "25306ebf3567996d5bf26e3befa5f092db4f4dd7", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -705,12 +705,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    self.err_ctxt().report_selection_error(\n-                        obligation.clone(),\n-                        &obligation,\n-                        &err,\n-                        false,\n-                    );\n+                    self.err_ctxt().report_selection_error(obligation.clone(), &obligation, &err);\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later."}, {"sha": "89b5e5161a9c28c80dc55ad45f8b2efe19b29c13", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -843,7 +843,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         {\n             // Point any obligations that were registered due to opaque type\n             // inference at the return expression.\n-            self.select_obligations_where_possible(false, |errors| {\n+            self.select_obligations_where_possible(|errors| {\n                 self.point_at_return_for_opaque_ty_error(errors, span, return_expr_ty);\n             });\n         }\n@@ -2738,7 +2738,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some((index_ty, element_ty)) => {\n                     // two-phase not needed because index_ty is never mutable\n                     self.demand_coerce(idx, idx_t, index_ty, None, AllowTwoPhase::No);\n-                    self.select_obligations_where_possible(false, |errors| {\n+                    self.select_obligations_where_possible(|errors| {\n                         self.point_at_index_if_possible(errors, idx.span)\n                     });\n                     element_ty"}, {"sha": "5d44092a5f68e33c440e652e24608bf9745ba161", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -7,16 +7,16 @@ use rustc_data_structures::{\n use rustc_middle::ty::{self, Ty};\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n-    /// Performs type inference fallback, returning true if any fallback\n-    /// occurs.\n-    pub(super) fn type_inference_fallback(&self) -> bool {\n+    /// Performs type inference fallback, setting `FnCtxt::fallback_has_occurred`\n+    /// if fallback has occurred.\n+    pub(super) fn type_inference_fallback(&self) {\n         debug!(\n             \"type-inference-fallback start obligations: {:#?}\",\n             self.fulfillment_cx.borrow_mut().pending_obligations()\n         );\n \n         // All type checking constraints were added, try to fallback unsolved variables.\n-        self.select_obligations_where_possible(false, |_| {});\n+        self.select_obligations_where_possible(|_| {});\n \n         debug!(\n             \"type-inference-fallback post selection obligations: {:#?}\",\n@@ -26,18 +26,17 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // Check if we have any unsolved variables. If not, no need for fallback.\n         let unsolved_variables = self.unsolved_variables();\n         if unsolved_variables.is_empty() {\n-            return false;\n+            return;\n         }\n \n         let diverging_fallback = self.calculate_diverging_fallback(&unsolved_variables);\n \n-        let mut fallback_has_occurred = false;\n         // We do fallback in two passes, to try to generate\n         // better error messages.\n         // The first time, we do *not* replace opaque types.\n         for ty in unsolved_variables {\n             debug!(\"unsolved_variable = {:?}\", ty);\n-            fallback_has_occurred |= self.fallback_if_possible(ty, &diverging_fallback);\n+            self.fallback_if_possible(ty, &diverging_fallback);\n         }\n \n         // We now see if we can make progress. This might cause us to\n@@ -63,9 +62,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // If we had tried to fallback the opaque inference variable to `MyType`,\n         // we will generate a confusing type-check error that does not explicitly\n         // refer to opaque types.\n-        self.select_obligations_where_possible(fallback_has_occurred, |_| {});\n-\n-        fallback_has_occurred\n+        self.select_obligations_where_possible(|_| {});\n     }\n \n     // Tries to apply a fallback to `ty` if it is an unsolved variable.\n@@ -81,12 +78,13 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     // Fallback becomes very dubious if we have encountered\n     // type-checking errors.  In that case, fallback to Error.\n     //\n-    // The return value indicates whether fallback has occurred.\n+    // Sets `FnCtxt::fallback_has_occurred` if fallback is performed\n+    // during this call.\n     fn fallback_if_possible(\n         &self,\n         ty: Ty<'tcx>,\n         diverging_fallback: &FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n-    ) -> bool {\n+    ) {\n         // Careful: we do NOT shallow-resolve `ty`. We know that `ty`\n         // is an unsolved variable, and we determine its fallback\n         // based solely on how it was created, not what other type\n@@ -111,7 +109,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             ty::Infer(ty::FloatVar(_)) => self.tcx.types.f64,\n             _ => match diverging_fallback.get(&ty) {\n                 Some(&fallback_ty) => fallback_ty,\n-                None => return false,\n+                None => return,\n             },\n         };\n         debug!(\"fallback_if_possible(ty={:?}): defaulting to `{:?}`\", ty, fallback);\n@@ -122,7 +120,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n             .map(|origin| origin.span)\n             .unwrap_or(rustc_span::DUMMY_SP);\n         self.demand_eqtype(span, ty, fallback);\n-        true\n+        self.fallback_has_occurred.set(true);\n     }\n \n     /// The \"diverging fallback\" system is rather complicated. This is"}, {"sha": "35323137e2d5aca499caacd08b6faaef9cf663ae", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // possible. This can help substantially when there are\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n-        self.select_obligations_where_possible(false, mutate_fulfillment_errors);\n+        self.select_obligations_where_possible(mutate_fulfillment_errors);\n         self.resolve_vars_if_possible(ty)\n     }\n \n@@ -600,7 +600,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n         for (body_id, interior, kind) in generators.drain(..) {\n-            self.select_obligations_where_possible(false, |_| {});\n+            self.select_obligations_where_possible(|_| {});\n             crate::generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n         }\n     }\n@@ -611,25 +611,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         if !errors.is_empty() {\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut errors);\n-            self.err_ctxt().report_fulfillment_errors(&errors, self.inh.body_id, false);\n+            self.err_ctxt().report_fulfillment_errors(&errors, self.inh.body_id);\n         }\n     }\n \n     /// Select as many obligations as we can at present.\n     pub(in super::super) fn select_obligations_where_possible(\n         &self,\n-        fallback_has_occurred: bool,\n         mutate_fulfillment_errors: impl Fn(&mut Vec<traits::FulfillmentError<'tcx>>),\n     ) {\n         let mut result = self.fulfillment_cx.borrow_mut().select_where_possible(self);\n         if !result.is_empty() {\n             mutate_fulfillment_errors(&mut result);\n             self.adjust_fulfillment_errors_for_expr_obligation(&mut result);\n-            self.err_ctxt().report_fulfillment_errors(\n-                &result,\n-                self.inh.body_id,\n-                fallback_has_occurred,\n-            );\n+            self.err_ctxt().report_fulfillment_errors(&result, self.inh.body_id);\n         }\n     }\n "}, {"sha": "a7a60a19bd37e62429da2cafacb747a3e879706d", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -345,7 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // an \"opportunistic\" trait resolution of any trait bounds on\n             // the call. This helps coercions.\n             if check_closures {\n-                self.select_obligations_where_possible(false, |_| {})\n+                self.select_obligations_where_possible(|_| {})\n             }\n \n             // Check each argument, to satisfy the input it was provided for"}, {"sha": "d5e4b6de581c3551a2af1020a282790f0807f431", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -68,10 +68,6 @@ pub struct FnCtxt<'a, 'tcx> {\n     /// any).\n     pub(super) ret_coercion: Option<RefCell<DynamicCoerceMany<'tcx>>>,\n \n-    /// Used exclusively to reduce cost of advanced evaluation used for\n-    /// more helpful diagnostics.\n-    pub(super) in_tail_expr: bool,\n-\n     /// First span of a return site that we find. Used in error messages.\n     pub(super) ret_coercion_span: Cell<Option<Span>>,\n \n@@ -115,6 +111,8 @@ pub struct FnCtxt<'a, 'tcx> {\n     pub(super) enclosing_breakables: RefCell<EnclosingBreakables<'tcx>>,\n \n     pub(super) inh: &'a Inherited<'tcx>,\n+\n+    pub(super) fallback_has_occurred: Cell<bool>,\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -128,7 +126,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             param_env,\n             err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_coercion: None,\n-            in_tail_expr: false,\n             ret_coercion_span: Cell::new(None),\n             resume_yield_tys: None,\n             ps: Cell::new(UnsafetyState::function(hir::Unsafety::Normal, hir::CRATE_HIR_ID)),\n@@ -138,6 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 by_id: Default::default(),\n             }),\n             inh,\n+            fallback_has_occurred: Cell::new(false),\n         }\n     }\n \n@@ -159,7 +157,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// [`InferCtxt::err_ctxt`]: infer::InferCtxt::err_ctxt\n     pub fn err_ctxt(&'a self) -> TypeErrCtxt<'a, 'tcx> {\n-        TypeErrCtxt { infcx: &self.infcx, typeck_results: Some(self.typeck_results.borrow()) }\n+        TypeErrCtxt {\n+            infcx: &self.infcx,\n+            typeck_results: Some(self.typeck_results.borrow()),\n+            fallback_has_occurred: self.fallback_has_occurred.get(),\n+        }\n     }\n \n     pub fn errors_reported_since_creation(&self) -> bool {"}, {"sha": "052fdef2fc51824a5c450e78a89337fb719361d6", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -316,12 +316,12 @@ fn typeck_with_fallback<'tcx>(\n             fcx\n         };\n \n-        let fallback_has_occurred = fcx.type_inference_fallback();\n+        fcx.type_inference_fallback();\n \n         // Even though coercion casts provide type hints, we check casts after fallback for\n         // backwards compatibility. This makes fallback a stronger type hint than a cast coercion.\n         fcx.check_casts();\n-        fcx.select_obligations_where_possible(fallback_has_occurred, |_| {});\n+        fcx.select_obligations_where_possible(|_| {});\n \n         // Closure and generator analysis may run after fallback\n         // because they don't constrain other type variables."}, {"sha": "50e2b0f89267d17a63d7a9b093078de9faedb05b", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -23,10 +23,11 @@ use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n+use rustc_trait_selection::traits::error_reporting::on_unimplemented::OnUnimplementedNote;\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::TypeErrCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n-    FulfillmentError, Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedNote,\n+    FulfillmentError, Obligation, ObligationCause, ObligationCauseCode,\n };\n \n use std::cmp::Ordering;"}, {"sha": "c3bcbcc993b7ce046099f1268ae5f69001576856", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -772,7 +772,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match (method, trait_did) {\n             (Some(ok), _) => {\n                 let method = self.register_infer_ok_obligations(ok);\n-                self.select_obligations_where_possible(false, |_| {});\n+                self.select_obligations_where_possible(|_| {});\n                 Ok(method)\n             }\n             (None, None) => Err(vec![]),"}, {"sha": "3dbc9b9f3f938fcc2c4262de81da3132e874196d", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -91,6 +91,7 @@ pub mod nice_region_error;\n pub struct TypeErrCtxt<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'tcx>,\n     pub typeck_results: Option<std::cell::Ref<'a, ty::TypeckResults<'tcx>>>,\n+    pub fallback_has_occurred: bool,\n }\n \n impl TypeErrCtxt<'_, '_> {"}, {"sha": "d5be9983ea7c60b0c0f2286d9c0225bee2a8f2e8", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -677,9 +677,9 @@ pub struct CombinedSnapshot<'tcx> {\n \n impl<'tcx> InferCtxt<'tcx> {\n     /// Creates a `TypeErrCtxt` for emitting various inference errors.\n-    /// During typeck, use `FnCtxt::infer_err` instead.\n+    /// During typeck, use `FnCtxt::err_ctxt` instead.\n     pub fn err_ctxt(&self) -> TypeErrCtxt<'_, 'tcx> {\n-        TypeErrCtxt { infcx: self, typeck_results: None }\n+        TypeErrCtxt { infcx: self, typeck_results: None, fallback_has_occurred: false }\n     }\n \n     /// calls `tcx.try_unify_abstract_consts` after"}, {"sha": "54bf4d1d6b7381469d276d77b0ee66afa1663963", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -819,27 +819,27 @@ fn find_skips_from_snippet(\n     };\n \n     fn find_skips(snippet: &str, is_raw: bool) -> Vec<usize> {\n-        let mut s = snippet.char_indices().peekable();\n+        let mut s = snippet.char_indices();\n         let mut skips = vec![];\n         while let Some((pos, c)) = s.next() {\n-            match (c, s.peek()) {\n+            match (c, s.clone().next()) {\n                 // skip whitespace and empty lines ending in '\\\\'\n                 ('\\\\', Some((next_pos, '\\n'))) if !is_raw => {\n                     skips.push(pos);\n-                    skips.push(*next_pos);\n+                    skips.push(next_pos);\n                     let _ = s.next();\n \n-                    while let Some((pos, c)) = s.peek() {\n+                    while let Some((pos, c)) = s.clone().next() {\n                         if matches!(c, ' ' | '\\n' | '\\t') {\n-                            skips.push(*pos);\n+                            skips.push(pos);\n                             let _ = s.next();\n                         } else {\n                             break;\n                         }\n                     }\n                 }\n                 ('\\\\', Some((next_pos, 'n' | 't' | 'r' | '0' | '\\\\' | '\\'' | '\\\"'))) => {\n-                    skips.push(*next_pos);\n+                    skips.push(next_pos);\n                     let _ = s.next();\n                 }\n                 ('\\\\', Some((_, 'x'))) if !is_raw => {\n@@ -858,19 +858,30 @@ fn find_skips_from_snippet(\n                     }\n                     if let Some((next_pos, next_c)) = s.next() {\n                         if next_c == '{' {\n-                            skips.push(next_pos);\n-                            let mut i = 0; // consume up to 6 hexanumeric chars + closing `}`\n-                            while let (Some((next_pos, c)), true) = (s.next(), i < 7) {\n-                                if c.is_digit(16) {\n-                                    skips.push(next_pos);\n-                                } else if c == '}' {\n-                                    skips.push(next_pos);\n-                                    break;\n-                                } else {\n-                                    break;\n-                                }\n-                                i += 1;\n+                            // consume up to 6 hexanumeric chars\n+                            let digits_len =\n+                                s.clone().take(6).take_while(|(_, c)| c.is_digit(16)).count();\n+\n+                            let len_utf8 = s\n+                                .as_str()\n+                                .get(..digits_len)\n+                                .and_then(|digits| u32::from_str_radix(digits, 16).ok())\n+                                .and_then(char::from_u32)\n+                                .map_or(1, char::len_utf8);\n+\n+                            // Skip the digits, for chars that encode to more than 1 utf-8 byte\n+                            // exclude as many digits as it is greater than 1 byte\n+                            //\n+                            // So for a 3 byte character, exclude 2 digits\n+                            let required_skips =\n+                                digits_len.saturating_sub(len_utf8.saturating_sub(1));\n+\n+                            // skip '{' and '}' also\n+                            for pos in (next_pos..).take(required_skips + 2) {\n+                                skips.push(pos)\n                             }\n+\n+                            s.nth(digits_len);\n                         } else if next_c.is_digit(16) {\n                             skips.push(next_pos);\n                             // We suggest adding `{` and `}` when appropriate, accept it here as if"}, {"sha": "cada28652f98a79db8df2ac514a8fac9d22bc13a", "filename": "compiler/rustc_target/src/spec/windows_gnullvm_base.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnullvm_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnullvm_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fwindows_gnullvm_base.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -1,4 +1,5 @@\n-use crate::spec::{cvs, Cc, LinkerFlavor, Lld, TargetOptions};\n+use crate::spec::{cvs, Cc, DebuginfoKind, LinkerFlavor, Lld, SplitDebuginfo, TargetOptions};\n+use std::borrow::Cow;\n \n pub fn opts() -> TargetOptions {\n     // We cannot use `-nodefaultlibs` because compiler-rt has to be passed\n@@ -36,7 +37,10 @@ pub fn opts() -> TargetOptions {\n         eh_frame_header: false,\n         no_default_libraries: false,\n         has_thread_local: true,\n-\n+        // FIXME(davidtwco): Support Split DWARF on Windows GNU - may require LLVM changes to\n+        // output DWO, despite using DWARF, doesn't use ELF..\n+        debuginfo_kind: DebuginfoKind::Pdb,\n+        supported_split_debuginfo: Cow::Borrowed(&[SplitDebuginfo::Off]),\n         ..Default::default()\n     }\n }"}, {"sha": "c7dee4a18ac5dd9ba7f95d949dfb7a9102a6e051", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -3,14 +3,17 @@ pub mod suggestions;\n \n use super::{\n     FulfillmentContext, FulfillmentError, FulfillmentErrorCode, MismatchedProjectionTypes,\n-    Obligation, ObligationCause, ObligationCauseCode, OnUnimplementedDirective,\n-    OnUnimplementedNote, OutputTypeParameterMismatch, Overflow, PredicateObligation,\n-    SelectionContext, SelectionError, TraitNotObjectSafe,\n+    Obligation, ObligationCause, ObligationCauseCode, OutputTypeParameterMismatch, Overflow,\n+    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n };\n-\n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use crate::traits::query::normalize::AtExt as _;\n+use crate::traits::specialize::to_pretty_impl_header;\n+use on_unimplemented::OnUnimplementedNote;\n+use on_unimplemented::TypeErrCtxtExt as _;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n@@ -40,11 +43,6 @@ use rustc_span::{ExpnKind, Span, DUMMY_SP};\n use std::fmt;\n use std::iter;\n use std::ops::ControlFlow;\n-\n-use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use crate::traits::query::normalize::AtExt as _;\n-use crate::traits::specialize::to_pretty_impl_header;\n-use on_unimplemented::TypeErrCtxtExt as _;\n use suggestions::TypeErrCtxtExt as _;\n \n pub use rustc_infer::traits::error_reporting::*;\n@@ -101,7 +99,6 @@ pub trait TypeErrCtxtExt<'tcx> {\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n         body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n     ) -> ErrorGuaranteed;\n \n     fn report_overflow_error<T>(\n@@ -124,7 +121,6 @@ pub trait TypeErrCtxtExt<'tcx> {\n         obligation: PredicateObligation<'tcx>,\n         root_obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n-        fallback_has_occurred: bool,\n     );\n }\n \n@@ -375,7 +371,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         &self,\n         errors: &[FulfillmentError<'tcx>],\n         body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n     ) -> ErrorGuaranteed {\n         #[derive(Debug)]\n         struct ErrorDescriptor<'tcx> {\n@@ -452,7 +447,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         for (error, suppressed) in iter::zip(errors, is_suppressed) {\n             if !suppressed {\n-                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n+                self.report_fulfillment_error(error, body_id);\n             }\n         }\n \n@@ -534,7 +529,6 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         mut obligation: PredicateObligation<'tcx>,\n         root_obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n-        fallback_has_occurred: bool,\n     ) {\n         self.set_tainted_by_errors();\n         let tcx = self.tcx;\n@@ -1015,7 +1009,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         // variable that used to fallback to `()` now falling back to `!`. Issue a\n                         // note informing about the change in behaviour.\n                         if trait_predicate.skip_binder().self_ty().is_never()\n-                            && fallback_has_occurred\n+                            && self.fallback_has_occurred\n                         {\n                             let predicate = trait_predicate.map_bound(|mut trait_pred| {\n                                 trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n@@ -1381,7 +1375,6 @@ trait InferCtxtPrivExt<'tcx> {\n         &self,\n         error: &FulfillmentError<'tcx>,\n         body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n     );\n \n     fn report_projection_error(\n@@ -1531,15 +1524,13 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         &self,\n         error: &FulfillmentError<'tcx>,\n         body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n     ) {\n         match error.code {\n             FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n                 self.report_selection_error(\n                     error.obligation.clone(),\n                     &error.root_obligation,\n                     selection_error,\n-                    fallback_has_occurred,\n                 );\n             }\n             FulfillmentErrorCode::CodeProjectionError(ref e) => {"}, {"sha": "82f0440b3078bb17efbb8d7406f528986eab5b9f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 393, "deletions": 5, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -1,14 +1,22 @@\n-use super::{\n-    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n-};\n+use super::{ObligationCauseCode, PredicateObligation};\n use crate::infer::error_reporting::TypeErrCtxt;\n+use rustc_ast::{MetaItem, NestedMetaItem};\n+use rustc_attr as attr;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{struct_span_err, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::SubstsRef;\n-use rustc_middle::ty::{self, GenericParamDefKind};\n-use rustc_span::symbol::sym;\n+use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n+use rustc_parse_format::{ParseMode, Parser, Piece, Position};\n+use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::{Span, DUMMY_SP};\n use std::iter;\n \n+use crate::errors::{\n+    EmptyOnClauseInOnUnimplemented, InvalidOnClauseInOnUnimplemented, NoValueInOnUnimplemented,\n+};\n+\n use super::InferCtxtPrivExt;\n \n pub trait TypeErrCtxtExt<'tcx> {\n@@ -276,3 +284,383 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n }\n+\n+#[derive(Clone, Debug)]\n+pub struct OnUnimplementedFormatString(Symbol);\n+\n+#[derive(Debug)]\n+pub struct OnUnimplementedDirective {\n+    pub condition: Option<MetaItem>,\n+    pub subcommands: Vec<OnUnimplementedDirective>,\n+    pub message: Option<OnUnimplementedFormatString>,\n+    pub label: Option<OnUnimplementedFormatString>,\n+    pub note: Option<OnUnimplementedFormatString>,\n+    pub parent_label: Option<OnUnimplementedFormatString>,\n+    pub append_const_msg: Option<Option<Symbol>>,\n+}\n+\n+/// For the `#[rustc_on_unimplemented]` attribute\n+#[derive(Default)]\n+pub struct OnUnimplementedNote {\n+    pub message: Option<String>,\n+    pub label: Option<String>,\n+    pub note: Option<String>,\n+    pub parent_label: Option<String>,\n+    /// Append a message for `~const Trait` errors. `None` means not requested and\n+    /// should fallback to a generic message, `Some(None)` suggests using the default\n+    /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n+    /// default one..\n+    pub append_const_msg: Option<Option<Symbol>>,\n+}\n+\n+impl<'tcx> OnUnimplementedDirective {\n+    fn parse(\n+        tcx: TyCtxt<'tcx>,\n+        item_def_id: DefId,\n+        items: &[NestedMetaItem],\n+        span: Span,\n+        is_root: bool,\n+    ) -> Result<Self, ErrorGuaranteed> {\n+        let mut errored = None;\n+        let mut item_iter = items.iter();\n+\n+        let parse_value = |value_str| {\n+            OnUnimplementedFormatString::try_parse(tcx, item_def_id, value_str, span).map(Some)\n+        };\n+\n+        let condition = if is_root {\n+            None\n+        } else {\n+            let cond = item_iter\n+                .next()\n+                .ok_or_else(|| tcx.sess.emit_err(EmptyOnClauseInOnUnimplemented { span }))?\n+                .meta_item()\n+                .ok_or_else(|| tcx.sess.emit_err(InvalidOnClauseInOnUnimplemented { span }))?;\n+            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |cfg| {\n+                if let Some(value) = cfg.value && let Err(guar) = parse_value(value) {\n+                    errored = Some(guar);\n+                }\n+                true\n+            });\n+            Some(cond.clone())\n+        };\n+\n+        let mut message = None;\n+        let mut label = None;\n+        let mut note = None;\n+        let mut parent_label = None;\n+        let mut subcommands = vec![];\n+        let mut append_const_msg = None;\n+\n+        for item in item_iter {\n+            if item.has_name(sym::message) && message.is_none() {\n+                if let Some(message_) = item.value_str() {\n+                    message = parse_value(message_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::label) && label.is_none() {\n+                if let Some(label_) = item.value_str() {\n+                    label = parse_value(label_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::note) && note.is_none() {\n+                if let Some(note_) = item.value_str() {\n+                    note = parse_value(note_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::parent_label) && parent_label.is_none() {\n+                if let Some(parent_label_) = item.value_str() {\n+                    parent_label = parse_value(parent_label_)?;\n+                    continue;\n+                }\n+            } else if item.has_name(sym::on)\n+                && is_root\n+                && message.is_none()\n+                && label.is_none()\n+                && note.is_none()\n+            {\n+                if let Some(items) = item.meta_item_list() {\n+                    match Self::parse(tcx, item_def_id, &items, item.span(), false) {\n+                        Ok(subcommand) => subcommands.push(subcommand),\n+                        Err(reported) => errored = Some(reported),\n+                    };\n+                    continue;\n+                }\n+            } else if item.has_name(sym::append_const_msg) && append_const_msg.is_none() {\n+                if let Some(msg) = item.value_str() {\n+                    append_const_msg = Some(Some(msg));\n+                    continue;\n+                } else if item.is_word() {\n+                    append_const_msg = Some(None);\n+                    continue;\n+                }\n+            }\n+\n+            // nothing found\n+            tcx.sess.emit_err(NoValueInOnUnimplemented { span: item.span() });\n+        }\n+\n+        if let Some(reported) = errored {\n+            Err(reported)\n+        } else {\n+            Ok(OnUnimplementedDirective {\n+                condition,\n+                subcommands,\n+                message,\n+                label,\n+                note,\n+                parent_label,\n+                append_const_msg,\n+            })\n+        }\n+    }\n+\n+    pub fn of_item(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> Result<Option<Self>, ErrorGuaranteed> {\n+        let Some(attr) = tcx.get_attr(item_def_id, sym::rustc_on_unimplemented) else {\n+            return Ok(None);\n+        };\n+\n+        let result = if let Some(items) = attr.meta_item_list() {\n+            Self::parse(tcx, item_def_id, &items, attr.span, true).map(Some)\n+        } else if let Some(value) = attr.value_str() {\n+            Ok(Some(OnUnimplementedDirective {\n+                condition: None,\n+                message: None,\n+                subcommands: vec![],\n+                label: Some(OnUnimplementedFormatString::try_parse(\n+                    tcx,\n+                    item_def_id,\n+                    value,\n+                    attr.span,\n+                )?),\n+                note: None,\n+                parent_label: None,\n+                append_const_msg: None,\n+            }))\n+        } else {\n+            let reported =\n+                tcx.sess.delay_span_bug(DUMMY_SP, \"of_item: neither meta_item_list nor value_str\");\n+            return Err(reported);\n+        };\n+        debug!(\"of_item({:?}) = {:?}\", item_def_id, result);\n+        result\n+    }\n+\n+    pub fn evaluate(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &[(Symbol, Option<String>)],\n+    ) -> OnUnimplementedNote {\n+        let mut message = None;\n+        let mut label = None;\n+        let mut note = None;\n+        let mut parent_label = None;\n+        let mut append_const_msg = None;\n+        info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n+\n+        let options_map: FxHashMap<Symbol, String> =\n+            options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n+\n+        for command in self.subcommands.iter().chain(Some(self)).rev() {\n+            if let Some(ref condition) = command.condition && !attr::eval_condition(\n+                condition,\n+                &tcx.sess.parse_sess,\n+                Some(tcx.features()),\n+                &mut |cfg| {\n+                    let value = cfg.value.map(|v| {\n+                        OnUnimplementedFormatString(v).format(tcx, trait_ref, &options_map)\n+                    });\n+\n+                    options.contains(&(cfg.name, value))\n+                },\n+            ) {\n+                debug!(\"evaluate: skipping {:?} due to condition\", command);\n+                continue;\n+            }\n+            debug!(\"evaluate: {:?} succeeded\", command);\n+            if let Some(ref message_) = command.message {\n+                message = Some(message_.clone());\n+            }\n+\n+            if let Some(ref label_) = command.label {\n+                label = Some(label_.clone());\n+            }\n+\n+            if let Some(ref note_) = command.note {\n+                note = Some(note_.clone());\n+            }\n+\n+            if let Some(ref parent_label_) = command.parent_label {\n+                parent_label = Some(parent_label_.clone());\n+            }\n+\n+            append_const_msg = command.append_const_msg;\n+        }\n+\n+        OnUnimplementedNote {\n+            label: label.map(|l| l.format(tcx, trait_ref, &options_map)),\n+            message: message.map(|m| m.format(tcx, trait_ref, &options_map)),\n+            note: note.map(|n| n.format(tcx, trait_ref, &options_map)),\n+            parent_label: parent_label.map(|e_s| e_s.format(tcx, trait_ref, &options_map)),\n+            append_const_msg,\n+        }\n+    }\n+}\n+\n+impl<'tcx> OnUnimplementedFormatString {\n+    fn try_parse(\n+        tcx: TyCtxt<'tcx>,\n+        item_def_id: DefId,\n+        from: Symbol,\n+        err_sp: Span,\n+    ) -> Result<Self, ErrorGuaranteed> {\n+        let result = OnUnimplementedFormatString(from);\n+        result.verify(tcx, item_def_id, err_sp)?;\n+        Ok(result)\n+    }\n+\n+    fn verify(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        item_def_id: DefId,\n+        span: Span,\n+    ) -> Result<(), ErrorGuaranteed> {\n+        let trait_def_id = if tcx.is_trait(item_def_id) {\n+            item_def_id\n+        } else {\n+            tcx.trait_id_of_impl(item_def_id)\n+                .expect(\"expected `on_unimplemented` to correspond to a trait\")\n+        };\n+        let trait_name = tcx.item_name(trait_def_id);\n+        let generics = tcx.generics_of(item_def_id);\n+        let s = self.0.as_str();\n+        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n+        let mut result = Ok(());\n+        for token in parser {\n+            match token {\n+                Piece::String(_) => (), // Normal string, no need to check it\n+                Piece::NextArgument(a) => match a.position {\n+                    Position::ArgumentNamed(s) => {\n+                        match Symbol::intern(s) {\n+                            // `{Self}` is allowed\n+                            kw::SelfUpper => (),\n+                            // `{ThisTraitsName}` is allowed\n+                            s if s == trait_name => (),\n+                            // `{from_method}` is allowed\n+                            sym::from_method => (),\n+                            // `{from_desugaring}` is allowed\n+                            sym::from_desugaring => (),\n+                            // `{ItemContext}` is allowed\n+                            sym::ItemContext => (),\n+                            // `{integral}` and `{integer}` and `{float}` are allowed\n+                            sym::integral | sym::integer_ | sym::float => (),\n+                            // So is `{A}` if A is a type parameter\n+                            s => match generics.params.iter().find(|param| param.name == s) {\n+                                Some(_) => (),\n+                                None => {\n+                                    let reported = struct_span_err!(\n+                                        tcx.sess,\n+                                        span,\n+                                        E0230,\n+                                        \"there is no parameter `{}` on {}\",\n+                                        s,\n+                                        if trait_def_id == item_def_id {\n+                                            format!(\"trait `{}`\", trait_name)\n+                                        } else {\n+                                            \"impl\".to_string()\n+                                        }\n+                                    )\n+                                    .emit();\n+                                    result = Err(reported);\n+                                }\n+                            },\n+                        }\n+                    }\n+                    // `{:1}` and `{}` are not to be used\n+                    Position::ArgumentIs(..) | Position::ArgumentImplicitlyIs(_) => {\n+                        let reported = struct_span_err!(\n+                            tcx.sess,\n+                            span,\n+                            E0231,\n+                            \"only named substitution parameters are allowed\"\n+                        )\n+                        .emit();\n+                        result = Err(reported);\n+                    }\n+                },\n+            }\n+        }\n+\n+        result\n+    }\n+\n+    pub fn format(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        options: &FxHashMap<Symbol, String>,\n+    ) -> String {\n+        let name = tcx.item_name(trait_ref.def_id);\n+        let trait_str = tcx.def_path_str(trait_ref.def_id);\n+        let generics = tcx.generics_of(trait_ref.def_id);\n+        let generic_map = generics\n+            .params\n+            .iter()\n+            .filter_map(|param| {\n+                let value = match param.kind {\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n+                        trait_ref.substs[param.index as usize].to_string()\n+                    }\n+                    GenericParamDefKind::Lifetime => return None,\n+                };\n+                let name = param.name;\n+                Some((name, value))\n+            })\n+            .collect::<FxHashMap<Symbol, String>>();\n+        let empty_string = String::new();\n+\n+        let s = self.0.as_str();\n+        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n+        let item_context = (options.get(&sym::ItemContext)).unwrap_or(&empty_string);\n+        parser\n+            .map(|p| match p {\n+                Piece::String(s) => s,\n+                Piece::NextArgument(a) => match a.position {\n+                    Position::ArgumentNamed(s) => {\n+                        let s = Symbol::intern(s);\n+                        match generic_map.get(&s) {\n+                            Some(val) => val,\n+                            None if s == name => &trait_str,\n+                            None => {\n+                                if let Some(val) = options.get(&s) {\n+                                    val\n+                                } else if s == sym::from_desugaring || s == sym::from_method {\n+                                    // don't break messages using these two arguments incorrectly\n+                                    &empty_string\n+                                } else if s == sym::ItemContext {\n+                                    &item_context\n+                                } else if s == sym::integral {\n+                                    \"{integral}\"\n+                                } else if s == sym::integer_ {\n+                                    \"{integer}\"\n+                                } else if s == sym::float {\n+                                    \"{float}\"\n+                                } else {\n+                                    bug!(\n+                                        \"broken on_unimplemented {:?} for {:?}: \\\n+                                      no argument matching {:?}\",\n+                                        self.0,\n+                                        trait_ref,\n+                                        s\n+                                    )\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => bug!(\"broken on_unimplemented {:?} - bad format arg\", self.0),\n+                },\n+            })\n+            .collect()\n+    }\n+}"}, {"sha": "b6ded4ce5a3962e0d252dd81b0b226c72017174e", "filename": "compiler/rustc_trait_selection/src/traits/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmisc.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -70,7 +70,7 @@ pub fn can_type_implement_copy<'tcx>(\n                     }\n                 }\n                 Err(errors) => {\n-                    infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+                    infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n                 }\n             };\n         }"}, {"sha": "10e48610e3abb46287812cd87e0a0a7ddd722fd8", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -12,7 +12,6 @@ pub mod error_reporting;\n mod fulfill;\n pub mod misc;\n mod object_safety;\n-mod on_unimplemented;\n pub mod outlives_bounds;\n mod project;\n pub mod query;\n@@ -58,7 +57,6 @@ pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::project::{normalize, normalize_projection_type, normalize_to};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n@@ -214,7 +212,7 @@ fn do_normalize_predicates<'tcx>(\n     let predicates = match fully_normalize(&infcx, cause, elaborated_env, predicates) {\n         Ok(predicates) => predicates,\n         Err(errors) => {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None, false);\n+            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n             return Err(reported);\n         }\n     };"}, {"sha": "fb062ea71c4ce775bf6c74cf4c153dde6a74a1f3", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "removed", "additions": 0, "deletions": 393, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=6b23a7e87fc60f6cc43c8cfb69169f2eecefaf14", "patch": "@@ -1,393 +0,0 @@\n-use rustc_ast::{MetaItem, NestedMetaItem};\n-use rustc_attr as attr;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, ErrorGuaranteed};\n-use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n-use rustc_parse_format::{ParseMode, Parser, Piece, Position};\n-use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n-\n-use crate::errors::{\n-    EmptyOnClauseInOnUnimplemented, InvalidOnClauseInOnUnimplemented, NoValueInOnUnimplemented,\n-};\n-\n-#[derive(Clone, Debug)]\n-pub struct OnUnimplementedFormatString(Symbol);\n-\n-#[derive(Debug)]\n-pub struct OnUnimplementedDirective {\n-    pub condition: Option<MetaItem>,\n-    pub subcommands: Vec<OnUnimplementedDirective>,\n-    pub message: Option<OnUnimplementedFormatString>,\n-    pub label: Option<OnUnimplementedFormatString>,\n-    pub note: Option<OnUnimplementedFormatString>,\n-    pub parent_label: Option<OnUnimplementedFormatString>,\n-    pub append_const_msg: Option<Option<Symbol>>,\n-}\n-\n-#[derive(Default)]\n-/// For the `#[rustc_on_unimplemented]` attribute\n-pub struct OnUnimplementedNote {\n-    pub message: Option<String>,\n-    pub label: Option<String>,\n-    pub note: Option<String>,\n-    pub parent_label: Option<String>,\n-    /// Append a message for `~const Trait` errors. `None` means not requested and\n-    /// should fallback to a generic message, `Some(None)` suggests using the default\n-    /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n-    /// default one..\n-    pub append_const_msg: Option<Option<Symbol>>,\n-}\n-\n-impl<'tcx> OnUnimplementedDirective {\n-    fn parse(\n-        tcx: TyCtxt<'tcx>,\n-        item_def_id: DefId,\n-        items: &[NestedMetaItem],\n-        span: Span,\n-        is_root: bool,\n-    ) -> Result<Self, ErrorGuaranteed> {\n-        let mut errored = None;\n-        let mut item_iter = items.iter();\n-\n-        let parse_value = |value_str| {\n-            OnUnimplementedFormatString::try_parse(tcx, item_def_id, value_str, span).map(Some)\n-        };\n-\n-        let condition = if is_root {\n-            None\n-        } else {\n-            let cond = item_iter\n-                .next()\n-                .ok_or_else(|| tcx.sess.emit_err(EmptyOnClauseInOnUnimplemented { span }))?\n-                .meta_item()\n-                .ok_or_else(|| tcx.sess.emit_err(InvalidOnClauseInOnUnimplemented { span }))?;\n-            attr::eval_condition(cond, &tcx.sess.parse_sess, Some(tcx.features()), &mut |cfg| {\n-                if let Some(value) = cfg.value && let Err(guar) = parse_value(value) {\n-                    errored = Some(guar);\n-                }\n-                true\n-            });\n-            Some(cond.clone())\n-        };\n-\n-        let mut message = None;\n-        let mut label = None;\n-        let mut note = None;\n-        let mut parent_label = None;\n-        let mut subcommands = vec![];\n-        let mut append_const_msg = None;\n-\n-        for item in item_iter {\n-            if item.has_name(sym::message) && message.is_none() {\n-                if let Some(message_) = item.value_str() {\n-                    message = parse_value(message_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::label) && label.is_none() {\n-                if let Some(label_) = item.value_str() {\n-                    label = parse_value(label_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::note) && note.is_none() {\n-                if let Some(note_) = item.value_str() {\n-                    note = parse_value(note_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::parent_label) && parent_label.is_none() {\n-                if let Some(parent_label_) = item.value_str() {\n-                    parent_label = parse_value(parent_label_)?;\n-                    continue;\n-                }\n-            } else if item.has_name(sym::on)\n-                && is_root\n-                && message.is_none()\n-                && label.is_none()\n-                && note.is_none()\n-            {\n-                if let Some(items) = item.meta_item_list() {\n-                    match Self::parse(tcx, item_def_id, &items, item.span(), false) {\n-                        Ok(subcommand) => subcommands.push(subcommand),\n-                        Err(reported) => errored = Some(reported),\n-                    };\n-                    continue;\n-                }\n-            } else if item.has_name(sym::append_const_msg) && append_const_msg.is_none() {\n-                if let Some(msg) = item.value_str() {\n-                    append_const_msg = Some(Some(msg));\n-                    continue;\n-                } else if item.is_word() {\n-                    append_const_msg = Some(None);\n-                    continue;\n-                }\n-            }\n-\n-            // nothing found\n-            tcx.sess.emit_err(NoValueInOnUnimplemented { span: item.span() });\n-        }\n-\n-        if let Some(reported) = errored {\n-            Err(reported)\n-        } else {\n-            Ok(OnUnimplementedDirective {\n-                condition,\n-                subcommands,\n-                message,\n-                label,\n-                note,\n-                parent_label,\n-                append_const_msg,\n-            })\n-        }\n-    }\n-\n-    pub fn of_item(tcx: TyCtxt<'tcx>, item_def_id: DefId) -> Result<Option<Self>, ErrorGuaranteed> {\n-        let Some(attr) = tcx.get_attr(item_def_id, sym::rustc_on_unimplemented) else {\n-            return Ok(None);\n-        };\n-\n-        let result = if let Some(items) = attr.meta_item_list() {\n-            Self::parse(tcx, item_def_id, &items, attr.span, true).map(Some)\n-        } else if let Some(value) = attr.value_str() {\n-            Ok(Some(OnUnimplementedDirective {\n-                condition: None,\n-                message: None,\n-                subcommands: vec![],\n-                label: Some(OnUnimplementedFormatString::try_parse(\n-                    tcx,\n-                    item_def_id,\n-                    value,\n-                    attr.span,\n-                )?),\n-                note: None,\n-                parent_label: None,\n-                append_const_msg: None,\n-            }))\n-        } else {\n-            let reported =\n-                tcx.sess.delay_span_bug(DUMMY_SP, \"of_item: neither meta_item_list nor value_str\");\n-            return Err(reported);\n-        };\n-        debug!(\"of_item({:?}) = {:?}\", item_def_id, result);\n-        result\n-    }\n-\n-    pub fn evaluate(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        options: &[(Symbol, Option<String>)],\n-    ) -> OnUnimplementedNote {\n-        let mut message = None;\n-        let mut label = None;\n-        let mut note = None;\n-        let mut parent_label = None;\n-        let mut append_const_msg = None;\n-        info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n-\n-        let options_map: FxHashMap<Symbol, String> =\n-            options.iter().filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned()))).collect();\n-\n-        for command in self.subcommands.iter().chain(Some(self)).rev() {\n-            if let Some(ref condition) = command.condition && !attr::eval_condition(\n-                condition,\n-                &tcx.sess.parse_sess,\n-                Some(tcx.features()),\n-                &mut |cfg| {\n-                    let value = cfg.value.map(|v| {\n-                        OnUnimplementedFormatString(v).format(tcx, trait_ref, &options_map)\n-                    });\n-\n-                    options.contains(&(cfg.name, value))\n-                },\n-            ) {\n-                debug!(\"evaluate: skipping {:?} due to condition\", command);\n-                continue;\n-            }\n-            debug!(\"evaluate: {:?} succeeded\", command);\n-            if let Some(ref message_) = command.message {\n-                message = Some(message_.clone());\n-            }\n-\n-            if let Some(ref label_) = command.label {\n-                label = Some(label_.clone());\n-            }\n-\n-            if let Some(ref note_) = command.note {\n-                note = Some(note_.clone());\n-            }\n-\n-            if let Some(ref parent_label_) = command.parent_label {\n-                parent_label = Some(parent_label_.clone());\n-            }\n-\n-            append_const_msg = command.append_const_msg;\n-        }\n-\n-        OnUnimplementedNote {\n-            label: label.map(|l| l.format(tcx, trait_ref, &options_map)),\n-            message: message.map(|m| m.format(tcx, trait_ref, &options_map)),\n-            note: note.map(|n| n.format(tcx, trait_ref, &options_map)),\n-            parent_label: parent_label.map(|e_s| e_s.format(tcx, trait_ref, &options_map)),\n-            append_const_msg,\n-        }\n-    }\n-}\n-\n-impl<'tcx> OnUnimplementedFormatString {\n-    fn try_parse(\n-        tcx: TyCtxt<'tcx>,\n-        item_def_id: DefId,\n-        from: Symbol,\n-        err_sp: Span,\n-    ) -> Result<Self, ErrorGuaranteed> {\n-        let result = OnUnimplementedFormatString(from);\n-        result.verify(tcx, item_def_id, err_sp)?;\n-        Ok(result)\n-    }\n-\n-    fn verify(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        item_def_id: DefId,\n-        span: Span,\n-    ) -> Result<(), ErrorGuaranteed> {\n-        let trait_def_id = if tcx.is_trait(item_def_id) {\n-            item_def_id\n-        } else {\n-            tcx.trait_id_of_impl(item_def_id)\n-                .expect(\"expected `on_unimplemented` to correspond to a trait\")\n-        };\n-        let trait_name = tcx.item_name(trait_def_id);\n-        let generics = tcx.generics_of(item_def_id);\n-        let s = self.0.as_str();\n-        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n-        let mut result = Ok(());\n-        for token in parser {\n-            match token {\n-                Piece::String(_) => (), // Normal string, no need to check it\n-                Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => {\n-                        match Symbol::intern(s) {\n-                            // `{Self}` is allowed\n-                            kw::SelfUpper => (),\n-                            // `{ThisTraitsName}` is allowed\n-                            s if s == trait_name => (),\n-                            // `{from_method}` is allowed\n-                            sym::from_method => (),\n-                            // `{from_desugaring}` is allowed\n-                            sym::from_desugaring => (),\n-                            // `{ItemContext}` is allowed\n-                            sym::ItemContext => (),\n-                            // `{integral}` and `{integer}` and `{float}` are allowed\n-                            sym::integral | sym::integer_ | sym::float => (),\n-                            // So is `{A}` if A is a type parameter\n-                            s => match generics.params.iter().find(|param| param.name == s) {\n-                                Some(_) => (),\n-                                None => {\n-                                    let reported = struct_span_err!(\n-                                        tcx.sess,\n-                                        span,\n-                                        E0230,\n-                                        \"there is no parameter `{}` on {}\",\n-                                        s,\n-                                        if trait_def_id == item_def_id {\n-                                            format!(\"trait `{}`\", trait_name)\n-                                        } else {\n-                                            \"impl\".to_string()\n-                                        }\n-                                    )\n-                                    .emit();\n-                                    result = Err(reported);\n-                                }\n-                            },\n-                        }\n-                    }\n-                    // `{:1}` and `{}` are not to be used\n-                    Position::ArgumentIs(..) | Position::ArgumentImplicitlyIs(_) => {\n-                        let reported = struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0231,\n-                            \"only named substitution parameters are allowed\"\n-                        )\n-                        .emit();\n-                        result = Err(reported);\n-                    }\n-                },\n-            }\n-        }\n-\n-        result\n-    }\n-\n-    pub fn format(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_ref: ty::TraitRef<'tcx>,\n-        options: &FxHashMap<Symbol, String>,\n-    ) -> String {\n-        let name = tcx.item_name(trait_ref.def_id);\n-        let trait_str = tcx.def_path_str(trait_ref.def_id);\n-        let generics = tcx.generics_of(trait_ref.def_id);\n-        let generic_map = generics\n-            .params\n-            .iter()\n-            .filter_map(|param| {\n-                let value = match param.kind {\n-                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const { .. } => {\n-                        trait_ref.substs[param.index as usize].to_string()\n-                    }\n-                    GenericParamDefKind::Lifetime => return None,\n-                };\n-                let name = param.name;\n-                Some((name, value))\n-            })\n-            .collect::<FxHashMap<Symbol, String>>();\n-        let empty_string = String::new();\n-\n-        let s = self.0.as_str();\n-        let parser = Parser::new(s, None, None, false, ParseMode::Format);\n-        let item_context = (options.get(&sym::ItemContext)).unwrap_or(&empty_string);\n-        parser\n-            .map(|p| match p {\n-                Piece::String(s) => s,\n-                Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => {\n-                        let s = Symbol::intern(s);\n-                        match generic_map.get(&s) {\n-                            Some(val) => val,\n-                            None if s == name => &trait_str,\n-                            None => {\n-                                if let Some(val) = options.get(&s) {\n-                                    val\n-                                } else if s == sym::from_desugaring || s == sym::from_method {\n-                                    // don't break messages using these two arguments incorrectly\n-                                    &empty_string\n-                                } else if s == sym::ItemContext {\n-                                    &item_context\n-                                } else if s == sym::integral {\n-                                    \"{integral}\"\n-                                } else if s == sym::integer_ {\n-                                    \"{integer}\"\n-                                } else if s == sym::float {\n-                                    \"{float}\"\n-                                } else {\n-                                    bug!(\n-                                        \"broken on_unimplemented {:?} for {:?}: \\\n-                                      no argument matching {:?}\",\n-                                        self.0,\n-                                        trait_ref,\n-                                        s\n-                                    )\n-                                }\n-                            }\n-                        }\n-                    }\n-                    _ => bug!(\"broken on_unimplemented {:?} - bad format arg\", self.0),\n-                },\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "9193c79bee875daf690d6f3af31e252cee70ff21", "filename": "library/core/benches/iter.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fiter.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -1,3 +1,4 @@\n+use core::borrow::Borrow;\n use core::iter::*;\n use core::mem;\n use core::num::Wrapping;\n@@ -403,13 +404,31 @@ fn bench_trusted_random_access_adapters(b: &mut Bencher) {\n \n /// Exercises the iter::Copied specialization for slice::Iter\n #[bench]\n-fn bench_copied_array_chunks(b: &mut Bencher) {\n+fn bench_copied_chunks(b: &mut Bencher) {\n+    let v = vec![1u8; 1024];\n+\n+    b.iter(|| {\n+        let mut iter = black_box(&v).iter().copied();\n+        let mut acc = Wrapping(0);\n+        // This uses a while-let loop to side-step the TRA specialization in ArrayChunks\n+        while let Ok(chunk) = iter.next_chunk::<{ mem::size_of::<u64>() }>() {\n+            let d = u64::from_ne_bytes(chunk);\n+            acc += Wrapping(d.rotate_left(7).wrapping_add(1));\n+        }\n+        acc\n+    })\n+}\n+\n+/// Exercises the TrustedRandomAccess specialization in ArrayChunks\n+#[bench]\n+fn bench_trusted_random_access_chunks(b: &mut Bencher) {\n     let v = vec![1u8; 1024];\n \n     b.iter(|| {\n         black_box(&v)\n             .iter()\n-            .copied()\n+            // this shows that we're not relying on the slice::Iter specialization in Copied\n+            .map(|b| *b.borrow())\n             .array_chunks::<{ mem::size_of::<u64>() }>()\n             .map(|ary| {\n                 let d = u64::from_ne_bytes(ary);"}, {"sha": "cf5a7cada93ce30b4a5925b7ea9f21b2793b8d78", "filename": "library/core/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Flib.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -5,6 +5,7 @@\n #![feature(test)]\n #![feature(trusted_random_access)]\n #![feature(iter_array_chunks)]\n+#![feature(iter_next_chunk)]\n \n extern crate test;\n "}, {"sha": "2090756d7a3ec82252be10dc39e91d16cdff1234", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 52, "deletions": 23, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -865,24 +865,6 @@ where\n         return Ok(Try::from_output(unsafe { mem::zeroed() }));\n     }\n \n-    struct Guard<'a, T, const N: usize> {\n-        array_mut: &'a mut [MaybeUninit<T>; N],\n-        initialized: usize,\n-    }\n-\n-    impl<T, const N: usize> Drop for Guard<'_, T, N> {\n-        fn drop(&mut self) {\n-            debug_assert!(self.initialized <= N);\n-\n-            // SAFETY: this slice will contain only initialized objects.\n-            unsafe {\n-                crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n-                    &mut self.array_mut.get_unchecked_mut(..self.initialized),\n-                ));\n-            }\n-        }\n-    }\n-\n     let mut array = MaybeUninit::uninit_array::<N>();\n     let mut guard = Guard { array_mut: &mut array, initialized: 0 };\n \n@@ -896,13 +878,11 @@ where\n                     ControlFlow::Continue(elem) => elem,\n                 };\n \n-                // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n-                // loop and the loop is aborted once it reaches N (which is\n-                // `array.len()`).\n+                // SAFETY: `guard.initialized` starts at 0, which means push can be called\n+                // at most N times, which this loop does.\n                 unsafe {\n-                    guard.array_mut.get_unchecked_mut(guard.initialized).write(item);\n+                    guard.push_unchecked(item);\n                 }\n-                guard.initialized += 1;\n             }\n             None => {\n                 let alive = 0..guard.initialized;\n@@ -920,6 +900,55 @@ where\n     Ok(Try::from_output(output))\n }\n \n+/// Panic guard for incremental initialization of arrays.\n+///\n+/// Disarm the guard with `mem::forget` once the array has been initialized.\n+///\n+/// # Safety\n+///\n+/// All write accesses to this structure are unsafe and must maintain a correct\n+/// count of `initialized` elements.\n+///\n+/// To minimize indirection fields are still pub but callers should at least use\n+/// `push_unchecked` to signal that something unsafe is going on.\n+pub(crate) struct Guard<'a, T, const N: usize> {\n+    /// The array to be initialized.\n+    pub array_mut: &'a mut [MaybeUninit<T>; N],\n+    /// The number of items that have been initialized so far.\n+    pub initialized: usize,\n+}\n+\n+impl<T, const N: usize> Guard<'_, T, N> {\n+    /// Adds an item to the array and updates the initialized item counter.\n+    ///\n+    /// # Safety\n+    ///\n+    /// No more than N elements must be initialized.\n+    #[inline]\n+    pub unsafe fn push_unchecked(&mut self, item: T) {\n+        // SAFETY: If `initialized` was correct before and the caller does not\n+        // invoke this method more than N times then writes will be in-bounds\n+        // and slots will not be initialized more than once.\n+        unsafe {\n+            self.array_mut.get_unchecked_mut(self.initialized).write(item);\n+            self.initialized = self.initialized.unchecked_add(1);\n+        }\n+    }\n+}\n+\n+impl<T, const N: usize> Drop for Guard<'_, T, N> {\n+    fn drop(&mut self) {\n+        debug_assert!(self.initialized <= N);\n+\n+        // SAFETY: this slice will contain only initialized objects.\n+        unsafe {\n+            crate::ptr::drop_in_place(MaybeUninit::slice_assume_init_mut(\n+                &mut self.array_mut.get_unchecked_mut(..self.initialized),\n+            ));\n+        }\n+    }\n+}\n+\n /// Returns the next chunk of `N` items from the iterator or errors with an\n /// iterator over the remainder. Used for `Iterator::next_chunk`.\n #[inline]"}, {"sha": "5e4211058aa6f2b8bcd0182ef18fc340f54c771d", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -1,6 +1,8 @@\n use crate::array;\n-use crate::iter::{ByRefSized, FusedIterator, Iterator};\n-use crate::ops::{ControlFlow, Try};\n+use crate::const_closure::ConstFnMutClosure;\n+use crate::iter::{ByRefSized, FusedIterator, Iterator, TrustedRandomAccessNoCoerce};\n+use crate::mem::{self, MaybeUninit};\n+use crate::ops::{ControlFlow, NeverShortCircuit, Try};\n \n /// An iterator over `N` elements of the iterator at a time.\n ///\n@@ -82,7 +84,13 @@ where\n         }\n     }\n \n-    impl_fold_via_try_fold! { fold -> try_fold }\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        <Self as SpecFold>::fold(self, init, f)\n+    }\n }\n \n #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"100450\")]\n@@ -168,3 +176,64 @@ where\n         self.iter.len() < N\n     }\n }\n+\n+trait SpecFold: Iterator {\n+    fn fold<B, F>(self, init: B, f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B;\n+}\n+\n+impl<I, const N: usize> SpecFold for ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    #[inline]\n+    default fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let fold = ConstFnMutClosure::new(&mut f, NeverShortCircuit::wrap_mut_2_imp);\n+        self.try_fold(init, fold).0\n+    }\n+}\n+\n+impl<I, const N: usize> SpecFold for ArrayChunks<I, N>\n+where\n+    I: Iterator + TrustedRandomAccessNoCoerce,\n+{\n+    #[inline]\n+    fn fold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let mut accum = init;\n+        let inner_len = self.iter.size();\n+        let mut i = 0;\n+        // Use a while loop because (0..len).step_by(N) doesn't optimize well.\n+        while inner_len - i >= N {\n+            let mut chunk = MaybeUninit::uninit_array();\n+            let mut guard = array::Guard { array_mut: &mut chunk, initialized: 0 };\n+            while guard.initialized < N {\n+                // SAFETY: The method consumes the iterator and the loop condition ensures that\n+                // all accesses are in bounds and only happen once.\n+                unsafe {\n+                    let idx = i + guard.initialized;\n+                    guard.push_unchecked(self.iter.__iterator_get_unchecked(idx));\n+                }\n+            }\n+            mem::forget(guard);\n+            // SAFETY: The loop above initialized all elements\n+            let chunk = unsafe { MaybeUninit::array_assume_init(chunk) };\n+            accum = f(accum, chunk);\n+            i += N;\n+        }\n+\n+        // unlike try_fold this method does not need to take care of the remainder\n+        // since `self` will be dropped\n+\n+        accum\n+    }\n+}"}, {"sha": "ef4a7e53bdd339caa6f7b22fbfb37fb16927b201", "filename": "library/core/tests/iter/adapters/array_chunks.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -139,7 +139,8 @@ fn test_iterator_array_chunks_fold() {\n     let result =\n         (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>().fold(0, |acc, _item| acc + 1);\n     assert_eq!(result, 3);\n-    assert_eq!(count.get(), 10);\n+    // fold impls may or may not process the remainder\n+    assert!(count.get() <= 10 && count.get() >= 9);\n }\n \n #[test]"}, {"sha": "9272b9ac9b2d45be95b2278b97dc36b0b5c00446", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -131,24 +131,47 @@ able to get around this problem by setting `-Clinker=lld-link` in RUSTFLAGS\n \n ## Toolchain Compatibility\n \n-<!-- NOTE: to update the below table, you can use this shell script:\n-\n-```sh\n-rustup toolchain install --profile minimal nightly\n-MINOR_VERSION=$(rustc +nightly --version | cut -d . -f 2)\n-LOWER_BOUND=61\n-\n-llvm_version() {\n-    toolchain=\"$1\"\n-    printf \"Rust $toolchain    |    Clang \"\n-    rustc +\"$toolchain\" -Vv | grep LLVM | cut -d ':' -f 2 | tr -d ' '\n-}\n-\n-for version in `seq $LOWER_BOUND $((MINOR_VERSION - 2))`; do\n-    toolchain=1.$version.0\n-    rustup toolchain install --no-self-update --profile  minimal $toolchain >/dev/null 2>&1\n-    llvm_version $toolchain\n-done\n+<!-- NOTE: to update the below table, you can use this Python script:\n+\n+```python\n+from collections import defaultdict\n+import subprocess\n+\n+def minor_version(version):\n+    return int(version.split('.')[1])\n+\n+INSTALL_TOOLCHAIN = [\"rustup\", \"toolchain\", \"install\", \"--profile\", \"minimal\"]\n+subprocess.run(INSTALL_TOOLCHAIN + [\"nightly\"])\n+\n+LOWER_BOUND = 65\n+NIGHTLY_VERSION = minor_version(subprocess.run(\n+    [\"rustc\", \"+nightly\", \"--version\"],\n+    capture_output=True,\n+    text=True).stdout)\n+\n+def llvm_version(toolchain):\n+    version_text = subprocess.run(\n+        [\"rustc\", \"+{}\".format(toolchain), \"-Vv\"],\n+        capture_output=True,\n+        text=True).stdout\n+    return int(version_text.split(\"LLVM\")[1].split(':')[1].split('.')[0])\n+\n+version_map = defaultdict(lambda: [])\n+for version in range(LOWER_BOUND, NIGHTLY_VERSION - 1):\n+    toolchain = \"1.{}.0\".format(version)\n+    subprocess.run(\n+        INSTALL_TOOLCHAIN + [\"--no-self-update\", toolchain],\n+        capture_output=True)\n+    version_map[llvm_version(toolchain)].append(version)\n+\n+print(\"| Rust Version | Clang Version |\")\n+print(\"|--------------|---------------|\")\n+for clang, rust in sorted(version_map.items()):\n+    if len(rust) > 1:\n+        rust_range = \"1.{} - 1.{}\".format(rust[0], rust[-1])\n+    else:\n+        rust_range = \"1.{}       \".format(rust[0])\n+    print(\"| {}  |      {}       |\".format(rust_range, clang))\n ```\n \n -->\n@@ -166,32 +189,13 @@ The following table shows known good combinations of toolchain versions.\n \n | Rust Version | Clang Version |\n |--------------|---------------|\n-| Rust 1.34    |    Clang 8    |\n-| Rust 1.35    |    Clang 8    |\n-| Rust 1.36    |    Clang 8    |\n-| Rust 1.37    |    Clang 8    |\n-| Rust 1.38    |    Clang 9    |\n-| Rust 1.39    |    Clang 9    |\n-| Rust 1.40    |    Clang 9    |\n-| Rust 1.41    |    Clang 9    |\n-| Rust 1.42    |    Clang 9    |\n-| Rust 1.43    |    Clang 9    |\n-| Rust 1.44    |    Clang 9    |\n-| Rust 1.45    |    Clang 10   |\n-| Rust 1.46    |    Clang 10   |\n-| Rust 1.47    |    Clang 11   |\n-| Rust 1.48    |    Clang 11   |\n-| Rust 1.49    |    Clang 11   |\n-| Rust 1.50    |    Clang 11   |\n-| Rust 1.51    |    Clang 11   |\n-| Rust 1.52    |    Clang 12   |\n-| Rust 1.53    |    Clang 12   |\n-| Rust 1.54    |    Clang 12   |\n-| Rust 1.55    |    Clang 12   |\n-| Rust 1.56    |    Clang 13   |\n-| Rust 1.57    |    Clang 13   |\n-| Rust 1.58    |    Clang 13   |\n-| Rust 1.59    |    Clang 13   |\n-| Rust 1.60    |    Clang 14   |\n+| 1.34 - 1.37  |       8       |\n+| 1.38 - 1.44  |       9       |\n+| 1.45 - 1.46  |      10       |\n+| 1.47 - 1.51  |      11       |\n+| 1.52 - 1.55  |      12       |\n+| 1.56 - 1.59  |      13       |\n+| 1.60 - 1.64  |      14       |\n+| 1.65         |      15       |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "753d91ce58e6619a98687aea49be80c36d50e26e", "filename": "src/test/ui/fmt/unicode-escape-spans.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/src%2Ftest%2Fui%2Ffmt%2Funicode-escape-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/src%2Ftest%2Fui%2Ffmt%2Funicode-escape-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Funicode-escape-spans.rs?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -0,0 +1,19 @@\n+fn main() {\n+    // 1 byte in UTF-8\n+    format!(\"\\u{000041}{a}\"); //~ ERROR cannot find value\n+    format!(\"\\u{0041}{a}\"); //~ ERROR cannot find value\n+    format!(\"\\u{41}{a}\"); //~ ERROR cannot find value\n+    format!(\"\\u{0}{a}\"); //~ ERROR cannot find value\n+\n+    // 2 bytes\n+    format!(\"\\u{0df}{a}\"); //~ ERROR cannot find value\n+    format!(\"\\u{df}{a}\"); //~ ERROR cannot find value\n+\n+    // 3 bytes\n+    format!(\"\\u{00211d}{a}\"); //~ ERROR cannot find value\n+    format!(\"\\u{211d}{a}\"); //~ ERROR cannot find value\n+\n+    // 4 bytes\n+    format!(\"\\u{1f4a3}{a}\"); //~ ERROR cannot find value\n+    format!(\"\\u{10ffff}{a}\"); //~ ERROR cannot find value\n+}"}, {"sha": "1d8473f01b822af6e5d0df044463726e7e2c7e60", "filename": "src/test/ui/fmt/unicode-escape-spans.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/src%2Ftest%2Fui%2Ffmt%2Funicode-escape-spans.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57d3c58ed6e0faf89a62411f96c000ffc9fd3937/src%2Ftest%2Fui%2Ffmt%2Funicode-escape-spans.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Funicode-escape-spans.stderr?ref=57d3c58ed6e0faf89a62411f96c000ffc9fd3937", "patch": "@@ -0,0 +1,63 @@\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:3:25\n+   |\n+LL |     format!(\"\\u{000041}{a}\");\n+   |                         ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:4:23\n+   |\n+LL |     format!(\"\\u{0041}{a}\");\n+   |                       ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:5:21\n+   |\n+LL |     format!(\"\\u{41}{a}\");\n+   |                     ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:6:20\n+   |\n+LL |     format!(\"\\u{0}{a}\");\n+   |                    ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:9:22\n+   |\n+LL |     format!(\"\\u{0df}{a}\");\n+   |                      ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:10:21\n+   |\n+LL |     format!(\"\\u{df}{a}\");\n+   |                     ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:13:25\n+   |\n+LL |     format!(\"\\u{00211d}{a}\");\n+   |                         ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:14:23\n+   |\n+LL |     format!(\"\\u{211d}{a}\");\n+   |                       ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:17:24\n+   |\n+LL |     format!(\"\\u{1f4a3}{a}\");\n+   |                        ^ not found in this scope\n+\n+error[E0425]: cannot find value `a` in this scope\n+  --> $DIR/unicode-escape-spans.rs:18:25\n+   |\n+LL |     format!(\"\\u{10ffff}{a}\");\n+   |                         ^ not found in this scope\n+\n+error: aborting due to 10 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}]}