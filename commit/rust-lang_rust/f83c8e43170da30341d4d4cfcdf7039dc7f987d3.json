{"sha": "f83c8e43170da30341d4d4cfcdf7039dc7f987d3", "node_id": "C_kwDOAAsO6NoAKGY4M2M4ZTQzMTcwZGEzMDM0MWQ0ZDRjZmNkZjcwMzlkYzdmOTg3ZDM", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2023-06-09T14:29:01Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-09T14:29:01Z"}, "message": "Rollup merge of #112429 - GuillaumeGomez:ty-alias-impls, r=notriddle,lcnr\n\n[rustdoc] List matching impls on type aliases\n\nFixes #32077.\n\nThanks a lot to ``@lcnr`` who helped me a lot with this fix!\n\ncc ``@notriddle``\nr? ``@lcnr``", "tree": {"sha": "db1ceb02378cb5f50c09ddbe18d86eaaea1f14ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db1ceb02378cb5f50c09ddbe18d86eaaea1f14ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f83c8e43170da30341d4d4cfcdf7039dc7f987d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkgzctCRBK7hj4Ov3rIwAA3RQIACwjsIOTtWYOuD9DFtZ2+iWK\nlO/Rz+oH1RgZaKlx9NsnvABZHkSo+CAI1bht23XBULVCsyp2g08CbOnP7A90gwH5\nS5qT2qzFre3nc5vbxG+4VQ0LFmoI3s1C0WNAZu63MX7A43aSQgE8uQ2Ki5J1YCZh\nElauYwee/y8TnBk8coIeXEJ5XQO9eZNlZIYpikTkeIJihA/zEStg7BnjSYJ3D1AQ\n4yjEX1YEcIS4UqeLgcxlTCvO4Md2eRL0FX0+sCtvfPx1lcIegMFWrB2q4NUVvJii\neWh3KWwR6yNEyTDjg1COOXRGqrf5ksDeo/5b04DUoCwEEIBbW6FFDk5oONWLkHg=\n=3g8k\n-----END PGP SIGNATURE-----\n", "payload": "tree db1ceb02378cb5f50c09ddbe18d86eaaea1f14ef\nparent a7f46af3698c1aa083f1dacfe6f0f7512021ae7a\nparent 2ce7cd906bde70d8cbd9b07b31c6a7bf1131c345\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1686320941 +0200\ncommitter GitHub <noreply@github.com> 1686320941 +0200\n\nRollup merge of #112429 - GuillaumeGomez:ty-alias-impls, r=notriddle,lcnr\n\n[rustdoc] List matching impls on type aliases\n\nFixes #32077.\n\nThanks a lot to ``@lcnr`` who helped me a lot with this fix!\n\ncc ``@notriddle``\nr? ``@lcnr``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f83c8e43170da30341d4d4cfcdf7039dc7f987d3", "html_url": "https://github.com/rust-lang/rust/commit/f83c8e43170da30341d4d4cfcdf7039dc7f987d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f83c8e43170da30341d4d4cfcdf7039dc7f987d3/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7f46af3698c1aa083f1dacfe6f0f7512021ae7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7f46af3698c1aa083f1dacfe6f0f7512021ae7a", "html_url": "https://github.com/rust-lang/rust/commit/a7f46af3698c1aa083f1dacfe6f0f7512021ae7a"}, {"sha": "2ce7cd906bde70d8cbd9b07b31c6a7bf1131c345", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ce7cd906bde70d8cbd9b07b31c6a7bf1131c345", "html_url": "https://github.com/rust-lang/rust/commit/2ce7cd906bde70d8cbd9b07b31c6a7bf1131c345"}], "stats": {"total": 215, "additions": 178, "deletions": 37}, "files": [{"sha": "e753647ff786821584c8dfccf4604b930c55565d", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f83c8e43170da30341d4d4cfcdf7039dc7f987d3/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c8e43170da30341d4d4cfcdf7039dc7f987d3/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=f83c8e43170da30341d4d4cfcdf7039dc7f987d3", "patch": "@@ -106,7 +106,7 @@ impl<T: ?Sized> *mut T {\n     /// with [`cast_mut`] on `*const T` and may have documentation value if used instead of implicit\n     /// coercion.\n     ///\n-    /// [`cast_mut`]: #method.cast_mut\n+    /// [`cast_mut`]: pointer::cast_mut\n     #[stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     #[rustc_const_stable(feature = \"ptr_const_cast\", since = \"1.65.0\")]\n     #[inline(always)]\n@@ -117,7 +117,7 @@ impl<T: ?Sized> *mut T {\n     /// Casts a pointer to its raw bits.\n     ///\n     /// This is equivalent to `as usize`, but is more specific to enhance readability.\n-    /// The inverse method is [`from_bits`](#method.from_bits-1).\n+    /// The inverse method is [`from_bits`](pointer#method.from_bits-1).\n     ///\n     /// In particular, `*p as usize` and `p as usize` will both compile for\n     /// pointers to numeric types but do very different things, so using this\n@@ -153,7 +153,7 @@ impl<T: ?Sized> *mut T {\n     /// Creates a pointer from its raw bits.\n     ///\n     /// This is equivalent to `as *mut T`, but is more specific to enhance readability.\n-    /// The inverse method is [`to_bits`](#method.to_bits-1).\n+    /// The inverse method is [`to_bits`](pointer#method.to_bits-1).\n     ///\n     /// # Examples\n     ///\n@@ -303,7 +303,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// For the mutable counterpart see [`as_mut`].\n     ///\n-    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n+    /// [`as_uninit_ref`]: pointer#method.as_uninit_ref-1\n     /// [`as_mut`]: #method.as_mut\n     ///\n     /// # Safety\n@@ -369,7 +369,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// For the mutable counterpart see [`as_uninit_mut`].\n     ///\n-    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_ref`]: pointer#method.as_ref-1\n     /// [`as_uninit_mut`]: #method.as_uninit_mut\n     ///\n     /// # Safety\n@@ -624,7 +624,7 @@ impl<T: ?Sized> *mut T {\n     /// For the shared counterpart see [`as_ref`].\n     ///\n     /// [`as_uninit_mut`]: #method.as_uninit_mut\n-    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_ref`]: pointer#method.as_ref-1\n     ///\n     /// # Safety\n     ///\n@@ -689,7 +689,7 @@ impl<T: ?Sized> *mut T {\n     /// For the shared counterpart see [`as_uninit_ref`].\n     ///\n     /// [`as_mut`]: #method.as_mut\n-    /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n+    /// [`as_uninit_ref`]: pointer#method.as_uninit_ref-1\n     ///\n     /// # Safety\n     ///\n@@ -779,7 +779,7 @@ impl<T: ?Sized> *mut T {\n     ///\n     /// This function is the inverse of [`offset`].\n     ///\n-    /// [`offset`]: #method.offset-1\n+    /// [`offset`]: pointer#method.offset-1\n     ///\n     /// # Safety\n     ///\n@@ -2051,7 +2051,7 @@ impl<T> *mut [T] {\n     ///\n     /// For the mutable counterpart see [`as_uninit_slice_mut`].\n     ///\n-    /// [`as_ref`]: #method.as_ref-1\n+    /// [`as_ref`]: pointer#method.as_ref-1\n     /// [`as_uninit_slice_mut`]: #method.as_uninit_slice_mut\n     ///\n     /// # Safety"}, {"sha": "baffee0964da9c7e1ea6ff135ef608ede39dfeea", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 78, "deletions": 12, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f83c8e43170da30341d4d4cfcdf7039dc7f987d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c8e43170da30341d4d4cfcdf7039dc7f987d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=f83c8e43170da30341d4d4cfcdf7039dc7f987d3", "patch": "@@ -53,12 +53,15 @@ use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, DefIdSet};\n use rustc_hir::Mutability;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{Obligation, ObligationCause};\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_span::{\n     symbol::{sym, Symbol},\n     BytePos, FileName, RealFileName,\n };\n+use rustc_trait_selection::traits::ObligationCtxt;\n use serde::ser::{SerializeMap, SerializeSeq};\n use serde::{Serialize, Serializer};\n \n@@ -1112,28 +1115,76 @@ fn render_assoc_items<'a, 'cx: 'a>(\n     containing_item: &'a clean::Item,\n     it: DefId,\n     what: AssocItemRender<'a>,\n+    aliased_type: Option<DefId>,\n ) -> impl fmt::Display + 'a + Captures<'cx> {\n     let mut derefs = DefIdSet::default();\n     derefs.insert(it);\n     display_fn(move |f| {\n-        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs);\n+        render_assoc_items_inner(f, cx, containing_item, it, what, &mut derefs, aliased_type);\n         Ok(())\n     })\n }\n \n+/// Check whether `impl_def_id` may apply to *some instantiation* of `item_def_id`.\n+fn is_valid_impl_for(tcx: TyCtxt<'_>, item_def_id: DefId, impl_def_id: DefId) -> bool {\n+    let infcx = tcx.infer_ctxt().intercrate(true).build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let param_env = ParamEnv::empty();\n+\n+    let alias_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, item_def_id);\n+    let alias_ty = tcx.type_of(item_def_id).subst(tcx, alias_substs);\n+    let alias_bounds = tcx.predicates_of(item_def_id).instantiate(tcx, alias_substs);\n+\n+    let impl_substs = infcx.fresh_substs_for_item(rustc_span::DUMMY_SP, impl_def_id);\n+    let impl_self_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n+    let impl_bounds = tcx.predicates_of(impl_def_id).instantiate(tcx, impl_substs);\n+\n+    if ocx.eq(&ObligationCause::dummy(), param_env, impl_self_ty, alias_ty).is_err() {\n+        return false;\n+    }\n+    ocx.register_obligations(\n+        alias_bounds\n+            .iter()\n+            .chain(impl_bounds)\n+            .map(|(p, _)| Obligation::new(tcx, ObligationCause::dummy(), param_env, p)),\n+    );\n+\n+    let errors = ocx.select_where_possible();\n+    errors.is_empty()\n+}\n+\n+// If `aliased_type` is `Some`, it means `it` is a type alias and `aliased_type` is the \"actual\"\n+// type aliased behind `it`. It is used to check whether or not the implementation of the aliased\n+// type can be displayed on the alias doc page.\n fn render_assoc_items_inner(\n     mut w: &mut dyn fmt::Write,\n     cx: &mut Context<'_>,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n     derefs: &mut DefIdSet,\n+    aliased_type: Option<DefId>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n     let shared = Rc::clone(&cx.shared);\n     let cache = &shared.cache;\n-    let Some(v) = cache.impls.get(&it) else { return };\n-    let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n+    let empty = Vec::new();\n+    let v = match cache.impls.get(&it) {\n+        Some(v) => v,\n+        None => &empty,\n+    };\n+    let v2 = match aliased_type {\n+        Some(aliased_type) => cache.impls.get(&aliased_type).unwrap_or(&empty),\n+        None => &empty,\n+    };\n+    if v.is_empty() && v2.is_empty() {\n+        return;\n+    }\n+    let mut saw_impls = FxHashSet::default();\n+    let (non_trait, traits): (Vec<_>, _) =\n+        v.iter().chain(v2).partition(|i| i.inner_impl().trait_.is_none());\n+    let tcx = cx.tcx();\n+    let is_alias = aliased_type.is_some();\n     if !non_trait.is_empty() {\n         let mut tmp_buf = Buffer::html();\n         let (render_mode, id, class_html) = match what {\n@@ -1165,6 +1216,12 @@ fn render_assoc_items_inner(\n         };\n         let mut impls_buf = Buffer::html();\n         for i in &non_trait {\n+            if !saw_impls.insert(i.def_id()) {\n+                continue;\n+            }\n+            if is_alias && !is_valid_impl_for(tcx, it, i.def_id()) {\n+                continue;\n+            }\n             render_impl(\n                 &mut impls_buf,\n                 cx,\n@@ -1193,9 +1250,14 @@ fn render_assoc_items_inner(\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n-        if let Some(impl_) = deref_impl {\n+        if let Some(impl_) = deref_impl &&\n+            (!is_alias || is_valid_impl_for(tcx, it, impl_.def_id()))\n+        {\n             let has_deref_mut =\n-                traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n+                traits.iter().any(|t| {\n+                    t.trait_did() == cx.tcx().lang_items().deref_mut_trait() &&\n+                    (!is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n+                });\n             render_deref_methods(&mut w, cx, impl_, containing_item, has_deref_mut, derefs);\n         }\n \n@@ -1205,10 +1267,14 @@ fn render_assoc_items_inner(\n             return;\n         }\n \n-        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) =\n-            traits.into_iter().partition(|t| t.inner_impl().kind.is_auto());\n-        let (blanket_impl, concrete): (Vec<&Impl>, _) =\n-            concrete.into_iter().partition(|t| t.inner_impl().kind.is_blanket());\n+        let (synthetic, concrete): (Vec<&Impl>, Vec<&Impl>) = traits\n+            .into_iter()\n+            .filter(|t| saw_impls.insert(t.def_id()))\n+            .partition(|t| t.inner_impl().kind.is_auto());\n+        let (blanket_impl, concrete): (Vec<&Impl>, _) = concrete\n+            .into_iter()\n+            .filter(|t| !is_alias || is_valid_impl_for(tcx, it, t.def_id()))\n+            .partition(|t| t.inner_impl().kind.is_blanket());\n \n         render_all_impls(w, cx, containing_item, &concrete, &synthetic, &blanket_impl);\n     }\n@@ -1247,10 +1313,10 @@ fn render_deref_methods(\n                 return;\n             }\n         }\n-        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n+        render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n     } else if let Some(prim) = target.primitive_type() {\n         if let Some(&did) = cache.primitive_locations.get(&prim) {\n-            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs);\n+            render_assoc_items_inner(&mut w, cx, container_item, did, what, derefs, None);\n         }\n     }\n }"}, {"sha": "01089ed348bfdd3190dc796ebdee37a4d6d4d974", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 32, "deletions": 16, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f83c8e43170da30341d4d4cfcdf7039dc7f987d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c8e43170da30341d4d4cfcdf7039dc7f987d3/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=f83c8e43170da30341d4d4cfcdf7039dc7f987d3", "patch": "@@ -260,7 +260,7 @@ fn item_template_render_assoc_items<'a: 'b, 'b, 'cx: 'a>(\n     display_fn(move |f| {\n         let (item, mut cx) = templ.item_and_mut_cx();\n         let def_id = item.item_id.expect_def_id();\n-        let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All);\n+        let v = render_assoc_items(*cx, item, def_id, AssocItemRender::All, None);\n         write!(f, \"{v}\")\n     })\n }\n@@ -893,7 +893,11 @@ fn item_trait(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean:\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All));\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    );\n \n     let cloned_shared = Rc::clone(&cx.shared);\n     let cache = &cloned_shared.cache;\n@@ -1125,8 +1129,12 @@ fn item_trait_alias(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n-        .unwrap();\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    )\n+    .unwrap();\n }\n \n fn item_opaque_ty(\n@@ -1154,8 +1162,12 @@ fn item_opaque_ty(\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n-        .unwrap();\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    )\n+    .unwrap();\n }\n \n fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clean::Typedef) {\n@@ -1179,11 +1191,11 @@ fn item_typedef(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, t: &clea\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2));\n \n     let def_id = it.item_id.expect_def_id();\n-    // Render any items associated directly to this alias, as otherwise they\n-    // won't be visible anywhere in the docs. It would be nice to also show\n-    // associated items from the aliased type (see discussion in #32077), but\n-    // we need #14072 to make sense of the generics.\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, def_id, AssocItemRender::All, t.type_.def_id(&cx.cache()))\n+    );\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1423,7 +1435,7 @@ fn item_enum(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, e: &clean::\n         write!(w, \"</div>\");\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1466,7 +1478,7 @@ fn item_primitive(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::Ite\n     let def_id = it.item_id.expect_def_id();\n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n     if it.name.map(|n| n.as_str() != \"reference\").unwrap_or(false) {\n-        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All)).unwrap();\n+        write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None)).unwrap();\n     } else {\n         // We handle the \"reference\" primitive type on its own because we only want to list\n         // implementations on generic types.\n@@ -1571,7 +1583,7 @@ fn item_struct(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, s: &clean\n         }\n     }\n     let def_id = it.item_id.expect_def_id();\n-    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All));\n+    write!(w, \"{}\", render_assoc_items(cx, it, def_id, AssocItemRender::All, None));\n     write!(w, \"{}\", document_type_layout(cx, def_id));\n }\n \n@@ -1606,8 +1618,12 @@ fn item_foreign_type(w: &mut impl fmt::Write, cx: &mut Context<'_>, it: &clean::\n     });\n \n     write!(w, \"{}\", document(cx, it, None, HeadingOffset::H2)).unwrap();\n-    write!(w, \"{}\", render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All))\n-        .unwrap();\n+    write!(\n+        w,\n+        \"{}\",\n+        render_assoc_items(cx, it, it.item_id.expect_def_id(), AssocItemRender::All, None)\n+    )\n+    .unwrap();\n }\n \n fn item_keyword(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item) {"}, {"sha": "555d0579bee79b174570baee4c317f4004f859e4", "filename": "tests/rustdoc/issue-32077-type-alias-impls.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f83c8e43170da30341d4d4cfcdf7039dc7f987d3/tests%2Frustdoc%2Fissue-32077-type-alias-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f83c8e43170da30341d4d4cfcdf7039dc7f987d3/tests%2Frustdoc%2Fissue-32077-type-alias-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-32077-type-alias-impls.rs?ref=f83c8e43170da30341d4d4cfcdf7039dc7f987d3", "patch": "@@ -0,0 +1,59 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/32077>.\n+\n+#![crate_name = \"foo\"]\n+\n+pub struct GenericStruct<T>(T);\n+\n+impl<T> GenericStruct<T> {\n+    pub fn on_gen(arg: T) {}\n+}\n+\n+impl GenericStruct<u32> {\n+    pub fn on_u32(arg: u32) {}\n+}\n+\n+pub trait Foo {}\n+pub trait Bar {}\n+\n+impl<T> Foo for GenericStruct<T> {}\n+impl Bar for GenericStruct<u32> {}\n+\n+// @has 'foo/type.TypedefStruct.html'\n+// We check that we have the implementation of the type alias itself.\n+// @has - '//*[@id=\"impl-TypedefStruct\"]/h3' 'impl TypedefStruct'\n+// @has - '//*[@id=\"method.on_alias\"]/h4' 'pub fn on_alias()'\n+// @has - '//*[@id=\"impl-GenericStruct%3CT%3E\"]/h3' 'impl<T> GenericStruct<T>'\n+// @has - '//*[@id=\"method.on_gen\"]/h4' 'pub fn on_gen(arg: T)'\n+// @has - '//*[@id=\"impl-Foo-for-GenericStruct%3CT%3E\"]/h3' 'impl<T> Foo for GenericStruct<T>'\n+// This trait implementation doesn't match the type alias parameters so shouldn't appear in docs.\n+// @!has - '//h3' 'impl Bar for GenericStruct<u32> {}'\n+// Same goes for the `Deref` impl.\n+// @!has - '//h2' 'Methods from Deref<Target = u32>'\n+pub type TypedefStruct = GenericStruct<u8>;\n+\n+impl TypedefStruct {\n+    pub fn on_alias() {}\n+}\n+\n+impl std::ops::Deref for GenericStruct<u32> {\n+    type Target = u32;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+pub struct Wrap<T>(GenericStruct<T>);\n+\n+// @has 'foo/type.Alias.html'\n+// @has - '//h2' 'Methods from Deref<Target = u32>'\n+// @has - '//*[@id=\"impl-Deref-for-Wrap%3CT%3E\"]/h3' 'impl<T> Deref for Wrap<T>'\n+pub type Alias = Wrap<u32>;\n+\n+impl<T> std::ops::Deref for Wrap<T> {\n+    type Target = GenericStruct<T>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}"}]}