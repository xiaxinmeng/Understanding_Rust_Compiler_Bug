{"sha": "ac749a180bfd10a1a1c210f047cc679b12fcb1f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNzQ5YTE4MGJmZDEwYTFhMWMyMTBmMDQ3Y2M2NzliMTJmY2IxZjE=", "commit": {"author": {"name": "Miguel Raz Guzm\u00e1n Macedo", "email": "miguelraz@ciencias.unam.mx", "date": "2021-07-19T21:58:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-19T21:58:13Z"}, "message": "add matrix_inversion example (#131)\n\n* add matrix_inversion example", "tree": {"sha": "163885ff5b8439db9931ac712676be0cd965c74f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/163885ff5b8439db9931ac712676be0cd965c74f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac749a180bfd10a1a1c210f047cc679b12fcb1f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg9fV1CRBK7hj4Ov3rIwAAk3gIAKem1ZYb86ip1pm5WsqY7Y2M\nec1d7HPvxM290ooo7M8j9J6X6c3DiEGt5gGv9tY8T08cFe+PiQMaff2k5SFVYOJC\nCRiPGAdzoTHqSTFWHHlJ2PqWFLbOQmWQfWlyP5xvRPxVQ+3qYGF9L1kXI90DXuWH\nkjilTr3gSGtbKSi7FOxYdavWkqTSL+Ouzw5UcRMz8o81grbKvLAOeJ6KPRivgkho\nMIwBooM78HVGWDOxQwFbJf8EXKDnSHPH8Ixa1EYBIuLmYaJpgKOPACIADet65Fa+\nCv57xQlhmg36/7xmbSo0FxKqUt/lWe/HH3i2DOLKOTrwxy5DaUObU0EiTeI6Iu4=\n=cFCV\n-----END PGP SIGNATURE-----\n", "payload": "tree 163885ff5b8439db9931ac712676be0cd965c74f\nparent 871d588ec44ec21008df54233dc60615a76e2638\nauthor Miguel Raz Guzm\u00e1n Macedo <miguelraz@ciencias.unam.mx> 1626731893 -0500\ncommitter GitHub <noreply@github.com> 1626731893 -0700\n\nadd matrix_inversion example (#131)\n\n* add matrix_inversion example"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac749a180bfd10a1a1c210f047cc679b12fcb1f1", "html_url": "https://github.com/rust-lang/rust/commit/ac749a180bfd10a1a1c210f047cc679b12fcb1f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac749a180bfd10a1a1c210f047cc679b12fcb1f1/comments", "author": {"login": "miguelraz", "id": 13056181, "node_id": "MDQ6VXNlcjEzMDU2MTgx", "avatar_url": "https://avatars.githubusercontent.com/u/13056181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelraz", "html_url": "https://github.com/miguelraz", "followers_url": "https://api.github.com/users/miguelraz/followers", "following_url": "https://api.github.com/users/miguelraz/following{/other_user}", "gists_url": "https://api.github.com/users/miguelraz/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelraz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelraz/subscriptions", "organizations_url": "https://api.github.com/users/miguelraz/orgs", "repos_url": "https://api.github.com/users/miguelraz/repos", "events_url": "https://api.github.com/users/miguelraz/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelraz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "871d588ec44ec21008df54233dc60615a76e2638", "url": "https://api.github.com/repos/rust-lang/rust/commits/871d588ec44ec21008df54233dc60615a76e2638", "html_url": "https://github.com/rust-lang/rust/commit/871d588ec44ec21008df54233dc60615a76e2638"}], "stats": {"total": 316, "additions": 316, "deletions": 0}, "files": [{"sha": "001187124d84e6e383f69d171cd8c405da47a377", "filename": "crates/core_simd/examples/matrix_inversion.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/ac749a180bfd10a1a1c210f047cc679b12fcb1f1/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac749a180bfd10a1a1c210f047cc679b12fcb1f1/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fmatrix_inversion.rs?ref=ac749a180bfd10a1a1c210f047cc679b12fcb1f1", "patch": "@@ -0,0 +1,316 @@\n+//! 4x4 matrix inverse\n+// Code ported from the `packed_simd` crate\n+// Run this code with `cargo test --example matrix_inversion`\n+#![feature(array_chunks)]\n+use core_simd::*;\n+\n+// Gotta define our own 4x4 matrix since Rust doesn't ship multidim arrays yet :^)\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]\n+pub struct Matrix4x4([[f32; 4]; 4]);\n+\n+#[allow(clippy::too_many_lines)]\n+pub fn scalar_inv4x4(m: Matrix4x4) -> Option<Matrix4x4> {\n+    let m = m.0;\n+\n+    let mut inv = [\n+        [ // row 0:\n+            // 0,0:\n+            m[1][1]  * m[2][2] * m[3][3] -\n+            m[1][1]  * m[2][3] * m[3][2] -\n+            m[2][1]  * m[1][2]  * m[3][3] +\n+            m[2][1]  * m[1][3]  * m[3][2] +\n+            m[3][1] * m[1][2]  * m[2][3] -\n+            m[3][1] * m[1][3]  * m[2][2],\n+            // 0,1:\n+           -m[0][1]  * m[2][2] * m[3][3] +\n+            m[0][1]  * m[2][3] * m[3][2] +\n+            m[2][1]  * m[0][2] * m[3][3] -\n+            m[2][1]  * m[0][3] * m[3][2] -\n+            m[3][1] * m[0][2] * m[2][3] +\n+            m[3][1] * m[0][3] * m[2][2],\n+            // 0,2:\n+            m[0][1]  * m[1][2] * m[3][3] -\n+            m[0][1]  * m[1][3] * m[3][2] -\n+            m[1][1]  * m[0][2] * m[3][3] +\n+            m[1][1]  * m[0][3] * m[3][2] +\n+            m[3][1] * m[0][2] * m[1][3] -\n+            m[3][1] * m[0][3] * m[1][2],\n+            // 0,3:\n+           -m[0][1] * m[1][2] * m[2][3] +\n+            m[0][1] * m[1][3] * m[2][2] +\n+            m[1][1] * m[0][2] * m[2][3] -\n+            m[1][1] * m[0][3] * m[2][2] -\n+            m[2][1] * m[0][2] * m[1][3] +\n+            m[2][1] * m[0][3] * m[1][2],\n+        ],\n+        [ // row 1\n+            // 1,0:\n+           -m[1][0]  * m[2][2] * m[3][3] +\n+            m[1][0]  * m[2][3] * m[3][2] +\n+            m[2][0]  * m[1][2]  * m[3][3] -\n+            m[2][0]  * m[1][3]  * m[3][2] -\n+            m[3][0] * m[1][2]  * m[2][3] +\n+            m[3][0] * m[1][3]  * m[2][2],\n+            // 1,1:\n+            m[0][0]  * m[2][2] * m[3][3] -\n+            m[0][0]  * m[2][3] * m[3][2] -\n+            m[2][0]  * m[0][2] * m[3][3] +\n+            m[2][0]  * m[0][3] * m[3][2] +\n+            m[3][0] * m[0][2] * m[2][3] -\n+            m[3][0] * m[0][3] * m[2][2],\n+            // 1,2:\n+           -m[0][0]  * m[1][2] * m[3][3] +\n+            m[0][0]  * m[1][3] * m[3][2] +\n+            m[1][0]  * m[0][2] * m[3][3] -\n+            m[1][0]  * m[0][3] * m[3][2] -\n+            m[3][0] * m[0][2] * m[1][3] +\n+            m[3][0] * m[0][3] * m[1][2],\n+            // 1,3:\n+            m[0][0] * m[1][2] * m[2][3] -\n+            m[0][0] * m[1][3] * m[2][2] -\n+            m[1][0] * m[0][2] * m[2][3] +\n+            m[1][0] * m[0][3] * m[2][2] +\n+            m[2][0] * m[0][2] * m[1][3] -\n+            m[2][0] * m[0][3] * m[1][2],\n+        ],\n+        [ // row 2\n+            // 2,0:\n+            m[1][0]  * m[2][1] * m[3][3] -\n+            m[1][0]  * m[2][3] * m[3][1] -\n+            m[2][0]  * m[1][1] * m[3][3] +\n+            m[2][0]  * m[1][3] * m[3][1] +\n+            m[3][0] * m[1][1] * m[2][3] -\n+            m[3][0] * m[1][3] * m[2][1],\n+            // 2,1:\n+           -m[0][0]  * m[2][1] * m[3][3] +\n+            m[0][0]  * m[2][3] * m[3][1] +\n+            m[2][0]  * m[0][1] * m[3][3] -\n+            m[2][0]  * m[0][3] * m[3][1] -\n+            m[3][0] * m[0][1] * m[2][3] +\n+            m[3][0] * m[0][3] * m[2][1],\n+            // 2,2:\n+            m[0][0]  * m[1][1] * m[3][3] -\n+            m[0][0]  * m[1][3] * m[3][1] -\n+            m[1][0]  * m[0][1] * m[3][3] +\n+            m[1][0]  * m[0][3] * m[3][1] +\n+            m[3][0] * m[0][1] * m[1][3] -\n+            m[3][0] * m[0][3] * m[1][1],\n+            // 2,3:\n+           -m[0][0] * m[1][1] * m[2][3] +\n+            m[0][0] * m[1][3] * m[2][1] +\n+            m[1][0] * m[0][1] * m[2][3] -\n+            m[1][0] * m[0][3] * m[2][1] -\n+            m[2][0] * m[0][1] * m[1][3] +\n+            m[2][0] * m[0][3] * m[1][1],\n+        ],\n+        [ // row 3\n+            // 3,0:\n+           -m[1][0]  * m[2][1] * m[3][2] +\n+            m[1][0]  * m[2][2] * m[3][1] +\n+            m[2][0]  * m[1][1] * m[3][2] -\n+            m[2][0]  * m[1][2] * m[3][1] -\n+            m[3][0] * m[1][1] * m[2][2] +\n+            m[3][0] * m[1][2] * m[2][1],\n+            // 3,1:\n+            m[0][0]  * m[2][1] * m[3][2] -\n+            m[0][0]  * m[2][2] * m[3][1] -\n+            m[2][0]  * m[0][1] * m[3][2] +\n+            m[2][0]  * m[0][2] * m[3][1] +\n+            m[3][0] * m[0][1] * m[2][2] -\n+            m[3][0] * m[0][2] * m[2][1],\n+            // 3,2:\n+           -m[0][0]  * m[1][1] * m[3][2] +\n+            m[0][0]  * m[1][2] * m[3][1] +\n+            m[1][0]  * m[0][1] * m[3][2] -\n+            m[1][0]  * m[0][2] * m[3][1] -\n+            m[3][0] * m[0][1] * m[1][2] +\n+            m[3][0] * m[0][2] * m[1][1],\n+            // 3,3:\n+            m[0][0] * m[1][1] * m[2][2] -\n+            m[0][0] * m[1][2] * m[2][1] -\n+            m[1][0] * m[0][1] * m[2][2] +\n+            m[1][0] * m[0][2] * m[2][1] +\n+            m[2][0] * m[0][1] * m[1][2] -\n+            m[2][0] * m[0][2] * m[1][1],\n+        ],\n+    ];\n+\n+    let det = m[0][0] * inv[0][0] + m[0][1] * inv[1][0] +\n+              m[0][2] * inv[2][0] + m[0][3] * inv[3][0];\n+    if det == 0. { return None; }\n+\n+    let det_inv = 1. / det;\n+\n+    for row in &mut inv {\n+        for elem in row.iter_mut() {\n+            *elem *= det_inv;\n+        }\n+    }\n+\n+    Some(Matrix4x4(inv))\n+}\n+\n+pub fn simd_inv4x4(m: Matrix4x4) -> Option<Matrix4x4> {\n+    let m = m.0;\n+    let m_0 = f32x4::from_array(m[0]);\n+    let m_1 = f32x4::from_array(m[1]);\n+    let m_2 = f32x4::from_array(m[2]);\n+    let m_3 = f32x4::from_array(m[3]);\n+\n+    // 2 argument shuffle, returns an f32x4\n+    // the first f32x4 is indexes 0..=3\n+    // the second f32x4 is indexed 4..=7\n+    let tmp1 = f32x4::shuffle::<{[0, 1, 4, 5]}>(m_0, m_1);\n+    let row1 = f32x4::shuffle::<{[0, 1, 4, 5]}>(m_2, m_3,);\n+\n+    let row0 = f32x4::shuffle::<{[0, 2, 4, 6]}>(tmp1, row1);\n+    let row1 = f32x4::shuffle::<{[1, 3, 5, 7]}>(row1, tmp1);\n+\n+    let tmp1 = f32x4::shuffle::<{[2, 3, 6, 7]}>(m_0, m_1);\n+    let row3 = f32x4::shuffle::<{[2, 3, 6, 7]}>(m_2, m_3);\n+    let row2 = f32x4::shuffle::<{[0, 2, 4, 6]}>(tmp1, row3);\n+    let row3 = f32x4::shuffle::<{[1, 3, 5, 7]}>(row3, tmp1);\n+\n+    let tmp1 = row2 * row3;\n+    // there's no syntax for a 1 arg shuffle yet,\n+    // so we just pass the same f32x4 twice\n+    let tmp1 = f32x4::shuffle::<{[1, 0, 3, 2]}>(tmp1, tmp1);\n+\n+    let minor0 = row1 * tmp1;\n+    let minor1 = row0 * tmp1;\n+    let tmp1   = f32x4::shuffle::<{[2, 3, 0, 1]}>(tmp1, tmp1);\n+    let minor0 = (row1 * tmp1) - minor0;\n+    let minor1 = (row0 * tmp1) - minor1;\n+    let minor1 = f32x4::shuffle::<{[2, 3, 0, 1]}>(minor1, minor1);\n+\n+    let tmp1 = row1 * row2;\n+    let tmp1 = f32x4::shuffle::<{[1, 0, 3, 2]}>(tmp1, tmp1);\n+    let minor0 = (row3 * tmp1) + minor0;\n+    let minor3 = row0 * tmp1;\n+    let tmp1 = f32x4::shuffle::<{[2, 3, 0, 1]}>(tmp1, tmp1);\n+\n+    let minor0 = minor0 - row3 * tmp1;\n+    let minor3 = row0 * tmp1 - minor3;\n+    let minor3 = f32x4::shuffle::<{[2, 3, 0, 1]}>(minor3, minor3);\n+\n+    let tmp1 = row3 * f32x4::shuffle::<{[2, 3, 0, 1]}>(row1, row1);\n+    let tmp1 = f32x4::shuffle::<{[1, 0, 3, 2]}>(tmp1, tmp1);\n+    let row2 = f32x4::shuffle::<{[2, 3, 0, 1]}>(row2, row2);\n+    let minor0 = row2 * tmp1 + minor0;\n+    let minor2 = row0 * tmp1;\n+    let tmp1 = f32x4::shuffle::<{[2, 3, 0, 1]}>(tmp1, tmp1);\n+    let minor0 = minor0 - row2 * tmp1;\n+    let minor2 = row0 * tmp1 - minor2;\n+    let minor2 = f32x4::shuffle::<{[2, 3, 0, 1]}>(minor2, minor2);\n+\n+    let tmp1 = row0 * row1;\n+    let tmp1 = f32x4::shuffle::<{[1, 0, 3, 2]}>(tmp1, tmp1);\n+    let minor2 = minor2 + row3 * tmp1;\n+    let minor3 = row2 * tmp1 - minor3;\n+    let tmp1 = f32x4::shuffle::<{[2, 3, 0, 1]}>(tmp1, tmp1);\n+    let minor2 = row3 * tmp1 - minor2;\n+    let minor3 = minor3 - row2 * tmp1;\n+\n+    let tmp1 = row0 * row3;\n+    let tmp1 = f32x4::shuffle::<{[1, 0, 3, 2]}>(tmp1, tmp1);\n+    let minor1 = minor1 - row2 * tmp1;\n+    let minor2 = row1 * tmp1 + minor2;\n+    let tmp1 = f32x4::shuffle::<{[2, 3, 0, 1]}>(tmp1, tmp1);\n+    let minor1 = row2 * tmp1 + minor1;\n+    let minor2 = minor2 - row1 * tmp1;\n+\n+    let tmp1 = row0 * row2;\n+    let tmp1 = f32x4::shuffle::<{[1, 0, 3, 2]}>(tmp1, tmp1);\n+    let minor1 = row3 * tmp1 + minor1;\n+    let minor3 = minor3 - row1 * tmp1;\n+    let tmp1 = f32x4::shuffle::<{[2, 3, 0, 1]}>(tmp1, tmp1);\n+    let minor1 = minor1 - row3 * tmp1;\n+    let minor3 = row1 * tmp1 + minor3;\n+\n+    let det = row0 * minor0;\n+    let det = f32x4::shuffle::<{[2, 3, 0, 1]}>(det, det) + det;\n+    let det = f32x4::shuffle::<{[1, 0, 3, 2]}>(det, det) + det;\n+\n+    if det.horizontal_sum() == 0. {\n+        return None;\n+    }\n+    // calculate the reciprocal\n+    let tmp1 = f32x4::splat(1.0) / det;\n+    let det = tmp1 + tmp1 - det * tmp1 * tmp1;\n+\n+    let res0 = minor0 * det;\n+    let res1 = minor1 * det;\n+    let res2 = minor2 * det;\n+    let res3 = minor3 * det;\n+\n+    let mut m = m;\n+\n+    m[0] = res0.to_array();\n+    m[1] = res1.to_array();\n+    m[2] = res2.to_array();\n+    m[3] = res3.to_array();\n+\n+    Some(Matrix4x4(m))\n+}\n+\n+\n+#[cfg(test)]\n+#[rustfmt::skip]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test() {\n+    let tests: &[(Matrix4x4, Option<Matrix4x4>)] = &[\n+        // Identity:\n+        (Matrix4x4([\n+            [1., 0., 0., 0.],\n+            [0., 1., 0., 0.],\n+            [0., 0., 1., 0.],\n+            [0., 0., 0., 1.],\n+         ]),\n+         Some(Matrix4x4([\n+             [1., 0., 0., 0.],\n+             [0., 1., 0., 0.],\n+             [0., 0., 1., 0.],\n+             [0., 0., 0., 1.],\n+         ]))\n+        ),\n+        // None:\n+        (Matrix4x4([\n+            [1., 2., 3., 4.],\n+            [12., 11., 10., 9.],\n+            [5., 6., 7., 8.],\n+            [16., 15., 14., 13.],\n+        ]),\n+         None\n+        ),\n+        // Other:\n+        (Matrix4x4([\n+            [1., 1., 1., 0.],\n+            [0., 3., 1., 2.],\n+            [2., 3., 1., 0.],\n+            [1., 0., 2., 1.],\n+        ]),\n+         Some(Matrix4x4([\n+             [-3., -0.5,   1.5,  1.0],\n+             [ 1., 0.25, -0.25, -0.5],\n+             [ 3., 0.25, -1.25, -0.5],\n+             [-3., 0.0,    1.0,  1.0],\n+         ]))\n+        ),\n+\n+\n+    ];\n+\n+        for &(input, output) in tests {\n+            assert_eq!(scalar_inv4x4(input), output);\n+            assert_eq!(simd_inv4x4(input), output);\n+        }\n+    }\n+}\n+\n+\n+fn main() {\n+    // Empty main to make cargo happy\n+}"}]}