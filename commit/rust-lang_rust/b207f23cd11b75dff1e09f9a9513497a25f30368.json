{"sha": "b207f23cd11b75dff1e09f9a9513497a25f30368", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyMDdmMjNjZDExYjc1ZGZmMWUwOWY5YTk1MTM0OTdhMjVmMzAzNjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-08T16:03:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-08T16:03:20Z"}, "message": "Auto merge of #6725 - Y-Nak:refactor-types-lints, r=flip1995\n\nRefactor types lints\n\nRef #6724.\nAs described in #6724, `types.rs` contains many groups inside it.\nIn this PR, I reorganize the lints of the `types` group into their own modules.\n\nchangelog: none", "tree": {"sha": "dd52bb244d0222237ee7594c9bf63af4d8ee2f14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd52bb244d0222237ee7594c9bf63af4d8ee2f14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b207f23cd11b75dff1e09f9a9513497a25f30368", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b207f23cd11b75dff1e09f9a9513497a25f30368", "html_url": "https://github.com/rust-lang/rust/commit/b207f23cd11b75dff1e09f9a9513497a25f30368", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b207f23cd11b75dff1e09f9a9513497a25f30368/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0d5232c72d58db6121479f22fa6b7569003f728", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0d5232c72d58db6121479f22fa6b7569003f728", "html_url": "https://github.com/rust-lang/rust/commit/d0d5232c72d58db6121479f22fa6b7569003f728"}, {"sha": "db59c35b7eb6cebe7e392fad3f223eb458d80a5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/db59c35b7eb6cebe7e392fad3f223eb458d80a5d", "html_url": "https://github.com/rust-lang/rust/commit/db59c35b7eb6cebe7e392fad3f223eb458d80a5d"}], "stats": {"total": 842, "additions": 485, "deletions": 357}, "files": [{"sha": "a7a511b21cf59020af650c10296ce43f9eecc7d8", "filename": "clippy_lints/src/types/borrowed_box.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=b207f23cd11b75dff1e09f9a9513497a25f30368", "patch": "@@ -0,0 +1,114 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    self as hir, GenericArg, GenericBounds, GenericParamKind, HirId, Lifetime, MutTy, Mutability, Node, QPath,\n+    SyntheticTyParamKind, TyKind,\n+};\n+use rustc_lint::LateContext;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{match_path, paths, snippet, span_lint_and_sugg};\n+\n+use super::BORROWED_BOX;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, lt: &Lifetime, mut_ty: &MutTy<'_>) -> bool {\n+    match mut_ty.ty.kind {\n+        TyKind::Path(ref qpath) => {\n+            let hir_id = mut_ty.ty.hir_id;\n+            let def = cx.qpath_res(qpath, hir_id);\n+            if_chain! {\n+                if let Some(def_id) = def.opt_def_id();\n+                if Some(def_id) == cx.tcx.lang_items().owned_box();\n+                if let QPath::Resolved(None, ref path) = *qpath;\n+                if let [ref bx] = *path.segments;\n+                if let Some(ref params) = bx.args;\n+                if !params.parenthesized;\n+                if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n+                    GenericArg::Type(ty) => Some(ty),\n+                    _ => None,\n+                });\n+                then {\n+                    if is_any_trait(inner) {\n+                        // Ignore `Box<Any>` types; see issue #1884 for details.\n+                        return false;\n+                    }\n+\n+                    let ltopt = if lt.is_elided() {\n+                        String::new()\n+                    } else {\n+                        format!(\"{} \", lt.name.ident().as_str())\n+                    };\n+\n+                    if mut_ty.mutbl == Mutability::Mut {\n+                        // Ignore `&mut Box<T>` types; see issue #2907 for\n+                        // details.\n+                        return false;\n+                    }\n+\n+                    // When trait objects or opaque types have lifetime or auto-trait bounds,\n+                    // we need to add parentheses to avoid a syntax error due to its ambiguity.\n+                    // Originally reported as the issue #3128.\n+                    let inner_snippet = snippet(cx, inner.span, \"..\");\n+                    let suggestion = match &inner.kind {\n+                        TyKind::TraitObject(bounds, lt_bound) if bounds.len() > 1 || !lt_bound.is_elided() => {\n+                            format!(\"&{}({})\", ltopt, &inner_snippet)\n+                        },\n+                        TyKind::Path(qpath)\n+                            if get_bounds_if_impl_trait(cx, qpath, inner.hir_id)\n+                                .map_or(false, |bounds| bounds.len() > 1) =>\n+                        {\n+                            format!(\"&{}({})\", ltopt, &inner_snippet)\n+                        },\n+                        _ => format!(\"&{}{}\", ltopt, &inner_snippet),\n+                    };\n+                    span_lint_and_sugg(\n+                        cx,\n+                        BORROWED_BOX,\n+                        hir_ty.span,\n+                        \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n+                        \"try\",\n+                        suggestion,\n+                        // To make this `MachineApplicable`, at least one needs to check if it isn't a trait item\n+                        // because the trait impls of it will break otherwise;\n+                        // and there may be other cases that result in invalid code.\n+                        // For example, type coercion doesn't work nicely.\n+                        Applicability::Unspecified,\n+                    );\n+                    return true;\n+                }\n+            };\n+            false\n+        },\n+        _ => false,\n+    }\n+}\n+\n+// Returns true if given type is `Any` trait.\n+fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n+    if_chain! {\n+        if let TyKind::TraitObject(ref traits, _) = t.kind;\n+        if !traits.is_empty();\n+        // Only Send/Sync can be used as additional traits, so it is enough to\n+        // check only the first trait.\n+        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n+    if_chain! {\n+        if let Some(did) = cx.qpath_res(qpath, id).opt_def_id();\n+        if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n+        if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n+        if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n+        then {\n+            Some(generic_param.bounds)\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "6aa98e435e1605df715f9389304be86a09d947a5", "filename": "clippy_lints/src/types/box_vec.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fbox_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fbox_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fbox_vec.rs?ref=b207f23cd11b75dff1e09f9a9513497a25f30368", "patch": "@@ -0,0 +1,25 @@\n+use rustc_hir::{self as hir, def_id::DefId, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{is_ty_param_diagnostic_item, span_lint_and_help};\n+\n+use super::BOX_VEC;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if Some(def_id) == cx.tcx.lang_items().owned_box()\n+        && is_ty_param_diagnostic_item(cx, qpath, sym::vec_type).is_some()\n+    {\n+        span_lint_and_help(\n+            cx,\n+            BOX_VEC,\n+            hir_ty.span,\n+            \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+            None,\n+            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "47eb4ede4e422cb32017a6269fbefa0eac0c5695", "filename": "clippy_lints/src/types/linked_list.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Flinked_list.rs?ref=b207f23cd11b75dff1e09f9a9513497a25f30368", "patch": "@@ -0,0 +1,22 @@\n+use rustc_hir::{self as hir, def_id::DefId};\n+use rustc_lint::LateContext;\n+\n+use crate::utils::{match_def_path, paths, span_lint_and_help};\n+\n+use super::LINKEDLIST;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, def_id: DefId) -> bool {\n+    if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n+        span_lint_and_help(\n+            cx,\n+            LINKEDLIST,\n+            hir_ty.span,\n+            \"you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\",\n+            None,\n+            \"a `VecDeque` might work\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "25cc40917c3018f3a60eabe611039500e5321145", "filename": "clippy_lints/src/types/mod.rs", "status": "renamed", "additions": 30, "deletions": 357, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=b207f23cd11b75dff1e09f9a9513497a25f30368", "patch": "@@ -1,5 +1,14 @@\n #![allow(rustc::default_hash_types)]\n \n+mod borrowed_box;\n+mod box_vec;\n+mod linked_list;\n+mod option_option;\n+mod rc_buffer;\n+mod redundant_allocation;\n+mod utils;\n+mod vec_box;\n+\n use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::collections::BTreeMap;\n@@ -10,14 +19,13 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericBounds, GenericParamKind, HirId,\n-    ImplItem, ImplItemKind, Item, ItemKind, LangItem, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node,\n-    QPath, Stmt, StmtKind, SyntheticTyParamKind, TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n+    BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem,\n+    ImplItemKind, Item, ItemKind, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt, StmtKind, TraitFn,\n+    TraitItem, TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::TypeFoldable;\n use rustc_middle::ty::{self, FloatTy, InferTy, IntTy, Ty, TyCtxt, TyS, TypeAndMut, TypeckResults, UintTy};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n@@ -32,9 +40,8 @@ use crate::consts::{constant, Constant};\n use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n-    clip, comparisons, differing_macro_contexts, get_qpath_generic_tys, higher, in_constant, indent_of, int_bits,\n-    is_hir_ty_cfg_dependant, is_ty_param_diagnostic_item, is_ty_param_lang_item, is_type_diagnostic_item,\n-    last_path_segment, match_def_path, match_path, meets_msrv, method_chain_args, multispan_sugg,\n+    clip, comparisons, differing_macro_contexts, higher, in_constant, indent_of, int_bits, is_hir_ty_cfg_dependant,\n+    is_type_diagnostic_item, match_path, meets_msrv, method_chain_args, multispan_sugg,\n     numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt, snippet_with_applicability,\n     snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n };\n@@ -287,35 +294,6 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n }\n \n-fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n-    if is_ty_param_diagnostic_item(cx, qpath, sym::string_type).is_some() {\n-        Some(\"str\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::OsString).is_some() {\n-        Some(\"std::ffi::OsStr\")\n-    } else if is_ty_param_diagnostic_item(cx, qpath, sym::PathBuf).is_some() {\n-        Some(\"std::path::Path\")\n-    } else {\n-        None\n-    }\n-}\n-\n-fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n-    let last = last_path_segment(qpath);\n-    if_chain! {\n-        if let Some(ref params) = last.args;\n-        if !params.parenthesized;\n-        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        });\n-        if let TyKind::Rptr(..) = ty.kind;\n-        then {\n-            return Some(ty.span);\n-        }\n-    }\n-    None\n-}\n-\n impl Types {\n     pub fn new(vec_box_size_threshold: u64) -> Self {\n         Self { vec_box_size_threshold }\n@@ -334,9 +312,7 @@ impl Types {\n     /// Recursively check for `TypePass` lints in the given type. Stop at the first\n     /// lint found.\n     ///\n-    /// The parameter `is_local` distinguishes the context of the type; types from\n-    /// local bindings should only be checked for the `BORROWED_BOX` lint.\n-    #[allow(clippy::too_many_lines)]\n+    /// The parameter `is_local` distinguishes the context of the type.\n     fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n         if hir_ty.span.from_expansion() {\n             return;\n@@ -346,213 +322,16 @@ impl Types {\n                 let hir_id = hir_ty.hir_id;\n                 let res = cx.qpath_res(qpath, hir_id);\n                 if let Some(def_id) = res.opt_def_id() {\n-                    if Some(def_id) == cx.tcx.lang_items().owned_box() {\n-                        if let Some(span) = match_borrows_parameter(cx, qpath) {\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Box<&T>`\",\n-                                \"try\",\n-                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if is_ty_param_diagnostic_item(cx, qpath, sym::vec_type).is_some() {\n-                            span_lint_and_help(\n-                                cx,\n-                                BOX_VEC,\n-                                hir_ty.span,\n-                                \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                                None,\n-                                \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\",\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n-                        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Rc<Rc<T>>`\",\n-                                \"try\",\n-                                snippet_with_applicability(cx, ty.span, \"..\", &mut applicability).to_string(),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n-                            let qpath = match &ty.kind {\n-                                TyKind::Path(qpath) => qpath,\n-                                _ => return,\n-                            };\n-                            let inner_span = match get_qpath_generic_tys(qpath).next() {\n-                                Some(ty) => ty.span,\n-                                None => return,\n-                            };\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Rc<Box<T>>`\",\n-                                \"try\",\n-                                format!(\n-                                    \"Rc<{}>\",\n-                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                                ),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(alternate) = match_buffer_type(cx, qpath) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Rc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\"Rc<{}>\", alternate),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n-                            let qpath = match &ty.kind {\n-                                TyKind::Path(qpath) => qpath,\n-                                _ => return,\n-                            };\n-                            let inner_span = match get_qpath_generic_tys(qpath).next() {\n-                                Some(ty) => ty.span,\n-                                None => return,\n-                            };\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Rc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\n-                                    \"Rc<[{}]>\",\n-                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(span) = match_borrows_parameter(cx, qpath) {\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Rc<&T>`\",\n-                                \"try\",\n-                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::Arc, def_id) {\n-                        if let Some(alternate) = match_buffer_type(cx, qpath) {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Arc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\"Arc<{}>\", alternate),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n-                            let qpath = match &ty.kind {\n-                                TyKind::Path(qpath) => qpath,\n-                                _ => return,\n-                            };\n-                            let inner_span = match get_qpath_generic_tys(qpath).next() {\n-                                Some(ty) => ty.span,\n-                                None => return,\n-                            };\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                RC_BUFFER,\n-                                hir_ty.span,\n-                                \"usage of `Arc<T>` when T is a buffer type\",\n-                                \"try\",\n-                                format!(\n-                                    \"Arc<[{}]>\",\n-                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n-                        if_chain! {\n-                            // Get the _ part of Vec<_>\n-                            if let Some(ref last) = last_path_segment(qpath).args;\n-                            if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty),\n-                                _ => None,\n-                            });\n-                            // ty is now _ at this point\n-                            if let TyKind::Path(ref ty_qpath) = ty.kind;\n-                            let res = cx.qpath_res(ty_qpath, ty.hir_id);\n-                            if let Some(def_id) = res.opt_def_id();\n-                            if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                            // At this point, we know ty is Box<T>, now get T\n-                            if let Some(ref last) = last_path_segment(ty_qpath).args;\n-                            if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n-                                GenericArg::Type(ty) => Some(ty),\n-                                _ => None,\n-                            });\n-                            let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n-                            if !ty_ty.has_escaping_bound_vars();\n-                            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n-                            if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n-                            if ty_ty_size <= self.vec_box_size_threshold;\n-                            then {\n-                                span_lint_and_sugg(\n-                                    cx,\n-                                    VEC_BOX,\n-                                    hir_ty.span,\n-                                    \"`Vec<T>` is already on the heap, the boxing is unnecessary\",\n-                                    \"try\",\n-                                    format!(\"Vec<{}>\", snippet(cx, boxed_ty.span, \"..\")),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                                return; // don't recurse into the type\n-                            }\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::option_type, def_id) {\n-                        if is_ty_param_diagnostic_item(cx, qpath, sym::option_type).is_some() {\n-                            span_lint(\n-                                cx,\n-                                OPTION_OPTION,\n-                                hir_ty.span,\n-                                \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n-                                 enum if you need to distinguish all 3 cases\",\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n-                        span_lint_and_help(\n-                            cx,\n-                            LINKEDLIST,\n-                            hir_ty.span,\n-                            \"you seem to be using a `LinkedList`! Perhaps you meant some other data structure?\",\n-                            None,\n-                            \"a `VecDeque` might work\",\n-                        );\n-                        return; // don't recurse into the type\n+                    let mut triggered = false;\n+                    triggered |= box_vec::check(cx, hir_ty, qpath, def_id);\n+                    triggered |= redundant_allocation::check(cx, hir_ty, qpath, def_id);\n+                    triggered |= rc_buffer::check(cx, hir_ty, qpath, def_id);\n+                    triggered |= vec_box::check(cx, hir_ty, qpath, def_id, self.vec_box_size_threshold);\n+                    triggered |= option_option::check(cx, hir_ty, qpath, def_id);\n+                    triggered |= linked_list::check(cx, hir_ty, def_id);\n+\n+                    if triggered {\n+                        return;\n                     }\n                 }\n                 match *qpath {\n@@ -597,8 +376,11 @@ impl Types {\n                     QPath::LangItem(..) => {},\n                 }\n             },\n-            TyKind::Rptr(ref lt, ref mut_ty) => self.check_ty_rptr(cx, hir_ty, is_local, lt, mut_ty),\n-            // recurse\n+            TyKind::Rptr(ref lt, ref mut_ty) => {\n+                if !borrowed_box::check(cx, hir_ty, lt, mut_ty) {\n+                    self.check_ty(cx, &mut_ty.ty, is_local);\n+                }\n+            },\n             TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n                 self.check_ty(cx, ty, is_local)\n             },\n@@ -610,115 +392,6 @@ impl Types {\n             _ => {},\n         }\n     }\n-\n-    fn check_ty_rptr(\n-        &mut self,\n-        cx: &LateContext<'_>,\n-        hir_ty: &hir::Ty<'_>,\n-        is_local: bool,\n-        lt: &Lifetime,\n-        mut_ty: &MutTy<'_>,\n-    ) {\n-        match mut_ty.ty.kind {\n-            TyKind::Path(ref qpath) => {\n-                let hir_id = mut_ty.ty.hir_id;\n-                let def = cx.qpath_res(qpath, hir_id);\n-                if_chain! {\n-                    if let Some(def_id) = def.opt_def_id();\n-                    if Some(def_id) == cx.tcx.lang_items().owned_box();\n-                    if let QPath::Resolved(None, ref path) = *qpath;\n-                    if let [ref bx] = *path.segments;\n-                    if let Some(ref params) = bx.args;\n-                    if !params.parenthesized;\n-                    if let Some(inner) = params.args.iter().find_map(|arg| match arg {\n-                        GenericArg::Type(ty) => Some(ty),\n-                        _ => None,\n-                    });\n-                    then {\n-                        if is_any_trait(inner) {\n-                            // Ignore `Box<Any>` types; see issue #1884 for details.\n-                            return;\n-                        }\n-\n-                        let ltopt = if lt.is_elided() {\n-                            String::new()\n-                        } else {\n-                            format!(\"{} \", lt.name.ident().as_str())\n-                        };\n-\n-                        if mut_ty.mutbl == Mutability::Mut {\n-                            // Ignore `&mut Box<T>` types; see issue #2907 for\n-                            // details.\n-                            return;\n-                        }\n-\n-                        // When trait objects or opaque types have lifetime or auto-trait bounds,\n-                        // we need to add parentheses to avoid a syntax error due to its ambiguity.\n-                        // Originally reported as the issue #3128.\n-                        let inner_snippet = snippet(cx, inner.span, \"..\");\n-                        let suggestion = match &inner.kind {\n-                            TyKind::TraitObject(bounds, lt_bound) if bounds.len() > 1 || !lt_bound.is_elided() => {\n-                                format!(\"&{}({})\", ltopt, &inner_snippet)\n-                            },\n-                            TyKind::Path(qpath)\n-                                if get_bounds_if_impl_trait(cx, qpath, inner.hir_id)\n-                                    .map_or(false, |bounds| bounds.len() > 1) =>\n-                            {\n-                                format!(\"&{}({})\", ltopt, &inner_snippet)\n-                            },\n-                            _ => format!(\"&{}{}\", ltopt, &inner_snippet),\n-                        };\n-                        span_lint_and_sugg(\n-                            cx,\n-                            BORROWED_BOX,\n-                            hir_ty.span,\n-                            \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n-                            \"try\",\n-                            suggestion,\n-                            // To make this `MachineApplicable`, at least one needs to check if it isn't a trait item\n-                            // because the trait impls of it will break otherwise;\n-                            // and there may be other cases that result in invalid code.\n-                            // For example, type coercion doesn't work nicely.\n-                            Applicability::Unspecified,\n-                        );\n-                        return; // don't recurse into the type\n-                    }\n-                };\n-                self.check_ty(cx, &mut_ty.ty, is_local);\n-            },\n-            _ => self.check_ty(cx, &mut_ty.ty, is_local),\n-        }\n-    }\n-}\n-\n-// Returns true if given type is `Any` trait.\n-fn is_any_trait(t: &hir::Ty<'_>) -> bool {\n-    if_chain! {\n-        if let TyKind::TraitObject(ref traits, _) = t.kind;\n-        if !traits.is_empty();\n-        // Only Send/Sync can be used as additional traits, so it is enough to\n-        // check only the first trait.\n-        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n-        then {\n-            return true;\n-        }\n-    }\n-\n-    false\n-}\n-\n-fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id: HirId) -> Option<GenericBounds<'tcx>> {\n-    if_chain! {\n-        if let Some(did) = cx.qpath_res(qpath, id).opt_def_id();\n-        if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n-        if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n-        if synthetic == Some(SyntheticTyParamKind::ImplTrait);\n-        then {\n-            Some(generic_param.bounds)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n declare_clippy_lint! {", "previous_filename": "clippy_lints/src/types.rs"}, {"sha": "dc5db963b4e98a98a4a52294c4ad4dc0d46d5ff3", "filename": "clippy_lints/src/types/option_option.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Foption_option.rs?ref=b207f23cd11b75dff1e09f9a9513497a25f30368", "patch": "@@ -0,0 +1,24 @@\n+use rustc_hir::{self as hir, def_id::DefId, QPath};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{is_ty_param_diagnostic_item, span_lint};\n+\n+use super::OPTION_OPTION;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if cx.tcx.is_diagnostic_item(sym::option_type, def_id)\n+        && is_ty_param_diagnostic_item(cx, qpath, sym::option_type).is_some()\n+    {\n+        span_lint(\n+            cx,\n+            OPTION_OPTION,\n+            hir_ty.span,\n+            \"consider using `Option<T>` instead of `Option<Option<T>>` or a custom \\\n+                                 enum if you need to distinguish all 3 cases\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "e34b95147e10a6d4cf2fb2c06734b9d1459a71d2", "filename": "clippy_lints/src/types/rc_buffer.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Frc_buffer.rs?ref=b207f23cd11b75dff1e09f9a9513497a25f30368", "patch": "@@ -0,0 +1,98 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def_id::DefId, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{\n+    get_qpath_generic_tys, is_ty_param_diagnostic_item, snippet_with_applicability, span_lint_and_sugg,\n+};\n+\n+use super::RC_BUFFER;\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n+        if let Some(alternate) = match_buffer_type(cx, qpath) {\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Rc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\"Rc<{}>\", alternate),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n+            let qpath = match &ty.kind {\n+                TyKind::Path(qpath) => qpath,\n+                _ => return false,\n+            };\n+            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                Some(ty) => ty.span,\n+                None => return false,\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Rc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\n+                    \"Rc<[{}]>\",\n+                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        }\n+    } else if cx.tcx.is_diagnostic_item(sym::Arc, def_id) {\n+        if let Some(alternate) = match_buffer_type(cx, qpath) {\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Arc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\"Arc<{}>\", alternate),\n+                Applicability::MachineApplicable,\n+            );\n+        } else if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::vec_type) {\n+            let qpath = match &ty.kind {\n+                TyKind::Path(qpath) => qpath,\n+                _ => return false,\n+            };\n+            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                Some(ty) => ty.span,\n+                None => return false,\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                RC_BUFFER,\n+                hir_ty.span,\n+                \"usage of `Arc<T>` when T is a buffer type\",\n+                \"try\",\n+                format!(\n+                    \"Arc<[{}]>\",\n+                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                ),\n+                Applicability::MachineApplicable,\n+            );\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static str> {\n+    if is_ty_param_diagnostic_item(cx, qpath, sym::string_type).is_some() {\n+        Some(\"str\")\n+    } else if is_ty_param_diagnostic_item(cx, qpath, sym::OsString).is_some() {\n+        Some(\"std::ffi::OsStr\")\n+    } else if is_ty_param_diagnostic_item(cx, qpath, sym::PathBuf).is_some() {\n+        Some(\"std::path::Path\")\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "5da6db179c46ee1a7e98a7ca614939865a4bbe96", "filename": "clippy_lints/src/types/redundant_allocation.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=b207f23cd11b75dff1e09f9a9513497a25f30368", "patch": "@@ -0,0 +1,84 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def_id::DefId, LangItem, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{\n+    get_qpath_generic_tys, is_ty_param_diagnostic_item, is_ty_param_lang_item, snippet_with_applicability,\n+    span_lint_and_sugg,\n+};\n+\n+use super::{utils, REDUNDANT_ALLOCATION};\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+    if Some(def_id) == cx.tcx.lang_items().owned_box() {\n+        if let Some(span) = utils::match_borrows_parameter(cx, qpath) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Box<&T>`\",\n+                \"try\",\n+                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+            return true;\n+        }\n+    }\n+\n+    if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n+        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Rc<Rc<T>>`\",\n+                \"try\",\n+                snippet_with_applicability(cx, ty.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+            true\n+        } else if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n+            let qpath = match &ty.kind {\n+                TyKind::Path(qpath) => qpath,\n+                _ => return false,\n+            };\n+            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                Some(ty) => ty.span,\n+                None => return false,\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Rc<Box<T>>`\",\n+                \"try\",\n+                format!(\n+                    \"Rc<{}>\",\n+                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+            true\n+        } else {\n+            utils::match_borrows_parameter(cx, qpath).map_or(false, |span| {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    REDUNDANT_ALLOCATION,\n+                    hir_ty.span,\n+                    \"usage of `Rc<&T>`\",\n+                    \"try\",\n+                    snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                    applicability,\n+                );\n+                true\n+            })\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "4d64748f998a40deac3d0d667aba6a3d69f851e8", "filename": "clippy_lints/src/types/utils.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Futils.rs?ref=b207f23cd11b75dff1e09f9a9513497a25f30368", "patch": "@@ -0,0 +1,24 @@\n+use rustc_hir::{GenericArg, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use crate::utils::last_path_segment;\n+\n+use if_chain::if_chain;\n+\n+pub(super) fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n+    let last = last_path_segment(qpath);\n+    if_chain! {\n+        if let Some(ref params) = last.args;\n+        if !params.parenthesized;\n+        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        });\n+        if let TyKind::Rptr(..) = ty.kind;\n+        then {\n+            return Some(ty.span);\n+        }\n+    }\n+    None\n+}"}, {"sha": "2530cc133c6784ec04da443d68894b6b5b2bc0fd", "filename": "clippy_lints/src/types/vec_box.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b207f23cd11b75dff1e09f9a9513497a25f30368/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=b207f23cd11b75dff1e09f9a9513497a25f30368", "patch": "@@ -0,0 +1,64 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def_id::DefId, GenericArg, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::TypeFoldable;\n+use rustc_span::symbol::sym;\n+use rustc_target::abi::LayoutOf;\n+use rustc_typeck::hir_ty_to_ty;\n+\n+use if_chain::if_chain;\n+\n+use crate::utils::{last_path_segment, snippet, span_lint_and_sugg};\n+\n+use super::VEC_BOX;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    hir_ty: &hir::Ty<'_>,\n+    qpath: &QPath<'_>,\n+    def_id: DefId,\n+    box_size_threshold: u64,\n+) -> bool {\n+    if cx.tcx.is_diagnostic_item(sym::vec_type, def_id) {\n+        if_chain! {\n+            // Get the _ part of Vec<_>\n+            if let Some(ref last) = last_path_segment(qpath).args;\n+            if let Some(ty) = last.args.iter().find_map(|arg| match arg {\n+                GenericArg::Type(ty) => Some(ty),\n+                _ => None,\n+            });\n+            // ty is now _ at this point\n+            if let TyKind::Path(ref ty_qpath) = ty.kind;\n+            let res = cx.qpath_res(ty_qpath, ty.hir_id);\n+            if let Some(def_id) = res.opt_def_id();\n+            if Some(def_id) == cx.tcx.lang_items().owned_box();\n+            // At this point, we know ty is Box<T>, now get T\n+            if let Some(ref last) = last_path_segment(ty_qpath).args;\n+            if let Some(boxed_ty) = last.args.iter().find_map(|arg| match arg {\n+                GenericArg::Type(ty) => Some(ty),\n+                _ => None,\n+            });\n+            let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n+            if !ty_ty.has_escaping_bound_vars();\n+            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n+            if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n+            if ty_ty_size <= box_size_threshold;\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    VEC_BOX,\n+                    hir_ty.span,\n+                    \"`Vec<T>` is already on the heap, the boxing is unnecessary\",\n+                    \"try\",\n+                    format!(\"Vec<{}>\", snippet(cx, boxed_ty.span, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+                true\n+            } else {\n+                false\n+            }\n+        }\n+    } else {\n+        false\n+    }\n+}"}]}