{"sha": "18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4ZWNjNTY0ZjJjZWU0ZGEzZWY5Mzk3YmE1OGUxOWQzZmQ5YmUzZGU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-10-10T17:54:50Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:43:55Z"}, "message": "rustc_trans: support scalar pairs directly in the Rust ABI.", "tree": {"sha": "dd9970b4cfa69a7c7d52bf428280d0c196eb4f98", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd9970b4cfa69a7c7d52bf428280d0c196eb4f98"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "html_url": "https://github.com/rust-lang/rust/commit/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a36141465d1f97936cfceca87ed428dbfafdd3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a36141465d1f97936cfceca87ed428dbfafdd3f", "html_url": "https://github.com/rust-lang/rust/commit/7a36141465d1f97936cfceca87ed428dbfafdd3f"}], "stats": {"total": 730, "additions": 367, "deletions": 363}, "files": [{"sha": "592bd62056455534cfcbb331abb1aa555a2da635", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "patch": "@@ -74,22 +74,19 @@ pub fn AddFunctionAttrStringValue(llfn: ValueRef,\n     }\n }\n \n-#[repr(C)]\n #[derive(Copy, Clone)]\n pub enum AttributePlace {\n+    ReturnValue,\n     Argument(u32),\n     Function,\n }\n \n impl AttributePlace {\n-    pub fn ReturnValue() -> Self {\n-        AttributePlace::Argument(0)\n-    }\n-\n     pub fn as_uint(self) -> c_uint {\n         match self {\n+            AttributePlace::ReturnValue => 0,\n+            AttributePlace::Argument(i) => 1 + i,\n             AttributePlace::Function => !0,\n-            AttributePlace::Argument(i) => i,\n         }\n     }\n }"}, {"sha": "7ef89597b11ca890b4612ea5aaad9c7af3841667", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 226, "deletions": 227, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n-use common::{instance_ty, ty_fn_sig, type_is_fat_ptr, C_usize};\n+use common::{instance_ty, ty_fn_sig, C_usize};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -30,7 +30,8 @@ use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n use cabi_hexagon;\n-use mir::lvalue::LvalueRef;\n+use mir::lvalue::{Alignment, LvalueRef};\n+use mir::operand::OperandValue;\n use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n \n@@ -44,15 +45,19 @@ use std::{cmp, iter};\n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n \n-#[derive(Clone, Copy, PartialEq, Debug)]\n-enum ArgKind {\n-    /// Pass the argument directly using the normal converted\n-    /// LLVM type or by coercing to another specified type\n-    Direct,\n-    /// Pass the argument indirectly via a hidden pointer\n-    Indirect,\n-    /// Ignore the argument (useful for empty struct)\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum PassMode {\n+    /// Ignore the argument (useful for empty struct).\n     Ignore,\n+    /// Pass the argument directly.\n+    Direct(ArgAttributes),\n+    /// Pass a pair's elements directly in two arguments.\n+    Pair(ArgAttributes, ArgAttributes),\n+    /// Pass the argument after casting it, to either\n+    /// a single uniform or a pair of registers.\n+    Cast(CastTarget),\n+    /// Pass the argument indirectly via a hidden pointer.\n+    Indirect(ArgAttributes),\n }\n \n // Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n@@ -94,7 +99,7 @@ impl ArgAttribute {\n \n /// A compact representation of LLVM attributes (at least those relevant for this module)\n /// that can be manipulated without interacting with LLVM's Attribute machinery.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct ArgAttributes {\n     regular: ArgAttribute,\n     pointee_size: Size,\n@@ -248,7 +253,7 @@ impl Reg {\n \n /// An argument passed entirely registers with the\n /// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub struct Uniform {\n     pub unit: Reg,\n \n@@ -399,7 +404,7 @@ impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug)]\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub enum CastTarget {\n     Uniform(Uniform),\n     Pair(Reg, Reg)\n@@ -452,99 +457,90 @@ impl CastTarget {\n     }\n }\n \n-/// Information about how a specific C type\n-/// should be passed to or returned from a function\n-///\n-/// This is borrowed from clang's ABIInfo.h\n+/// Information about how to pass an argument to,\n+/// or return a value from, a function, under some ABI.\n #[derive(Debug)]\n pub struct ArgType<'tcx> {\n-    kind: ArgKind,\n     pub layout: TyLayout<'tcx>,\n-    /// Cast target, either a single uniform or a pair of registers.\n-    pub cast: Option<CastTarget>,\n+\n     /// Dummy argument, which is emitted before the real argument.\n     pub pad: Option<Reg>,\n-    /// Attributes of argument.\n-    pub attrs: ArgAttributes,\n-    pub nested: Vec<ArgType<'tcx>>\n+\n+    pub mode: PassMode,\n }\n \n impl<'a, 'tcx> ArgType<'tcx> {\n     fn new(layout: TyLayout<'tcx>) -> ArgType<'tcx> {\n-        let mut attrs = ArgAttributes::new();\n-\n-        if let layout::Abi::Scalar(ref scalar) = layout.abi {\n-            if scalar.is_bool() {\n-                attrs.set(ArgAttribute::ZExt);\n-            }\n-        }\n-\n         ArgType {\n-            kind: ArgKind::Direct,\n             layout,\n-            cast: None,\n             pad: None,\n-            attrs,\n-            nested: vec![]\n+            mode: PassMode::Direct(ArgAttributes::new()),\n         }\n     }\n \n     pub fn make_indirect(&mut self) {\n-        assert!(self.nested.is_empty());\n-        assert_eq!(self.kind, ArgKind::Direct);\n+        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n \n-        // Wipe old attributes, likely not valid through indirection.\n-        self.attrs = ArgAttributes::new();\n+        // Start with fresh attributes for the pointer.\n+        let mut attrs = ArgAttributes::new();\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n         // program-invisible so can't possibly capture\n-        self.attrs.set(ArgAttribute::NoAlias)\n-                  .set(ArgAttribute::NoCapture)\n-                  .set(ArgAttribute::NonNull);\n-        self.attrs.pointee_size = self.layout.size;\n-        self.attrs.pointee_align = Some(self.layout.align);\n+        attrs.set(ArgAttribute::NoAlias)\n+             .set(ArgAttribute::NoCapture)\n+             .set(ArgAttribute::NonNull);\n+        attrs.pointee_size = self.layout.size;\n+        attrs.pointee_align = Some(self.layout.align);\n \n-        self.kind = ArgKind::Indirect;\n+        self.mode = PassMode::Indirect(attrs);\n     }\n \n-    pub fn ignore(&mut self) {\n-        assert!(self.nested.is_empty());\n-        assert_eq!(self.kind, ArgKind::Direct);\n-        self.kind = ArgKind::Ignore;\n+    pub fn make_indirect_byval(&mut self) {\n+        self.make_indirect();\n+        match self.mode {\n+            PassMode::Indirect(ref mut attrs) => {\n+                attrs.set(ArgAttribute::ByVal);\n+            }\n+            _ => bug!()\n+        }\n     }\n \n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n         if let layout::Abi::Scalar(ref scalar) = self.layout.abi {\n             if let layout::Int(i, signed) = scalar.value {\n                 if i.size().bits() < bits {\n-                    self.attrs.set(if signed {\n-                        ArgAttribute::SExt\n-                    } else {\n-                        ArgAttribute::ZExt\n-                    });\n+                    if let PassMode::Direct(ref mut attrs) = self.mode {\n+                        attrs.set(if signed {\n+                            ArgAttribute::SExt\n+                        } else {\n+                            ArgAttribute::ZExt\n+                        });\n+                    }\n                 }\n             }\n         }\n     }\n \n     pub fn cast_to<T: Into<CastTarget>>(&mut self, target: T) {\n-        assert!(self.nested.is_empty());\n-        self.cast = Some(target.into());\n+        assert_eq!(self.mode, PassMode::Direct(ArgAttributes::new()));\n+        self.mode = PassMode::Cast(target.into());\n     }\n \n     pub fn pad_with(&mut self, reg: Reg) {\n-        assert!(self.nested.is_empty());\n         self.pad = Some(reg);\n     }\n \n     pub fn is_indirect(&self) -> bool {\n-        self.kind == ArgKind::Indirect\n+        match self.mode {\n+            PassMode::Indirect(_) => true,\n+            _ => false\n+        }\n     }\n \n     pub fn is_ignore(&self) -> bool {\n-        self.kind == ArgKind::Ignore\n+        self.mode == PassMode::Ignore\n     }\n \n     /// Get the LLVM type for an lvalue of the original Rust type of\n@@ -557,20 +553,19 @@ impl<'a, 'tcx> ArgType<'tcx> {\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &Builder<'a, 'tcx>, mut val: ValueRef, dst: LvalueRef<'tcx>) {\n+    pub fn store(&self, bcx: &Builder<'a, 'tcx>, val: ValueRef, dst: LvalueRef<'tcx>) {\n         if self.is_ignore() {\n             return;\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            let llsz = C_usize(ccx, self.layout.size.bytes());\n-            base::call_memcpy(bcx, dst.llval, val, llsz, self.layout.align);\n-        } else if let Some(ty) = self.cast {\n+            OperandValue::Ref(val, Alignment::AbiAligned).store(bcx, dst)\n+        } else if let PassMode::Cast(cast) = self.mode {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n-                let cast_dst = bcx.pointercast(dst.llval, ty.llvm_type(ccx).ptr_to());\n+                let cast_dst = bcx.pointercast(dst.llval, cast.llvm_type(ccx).ptr_to());\n                 bcx.store(val, cast_dst, Some(self.layout.align));\n             } else {\n                 // The actual return type is a struct, but the ABI\n@@ -588,8 +583,8 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.alloca(ty.llvm_type(ccx), \"abi_cast\", None);\n-                let scratch_size = ty.size(ccx);\n+                let llscratch = bcx.alloca(cast.llvm_type(ccx), \"abi_cast\", None);\n+                let scratch_size = cast.size(ccx);\n                 bcx.lifetime_start(llscratch, scratch_size);\n \n                 // ...where we first store the value...\n@@ -600,32 +595,33 @@ impl<'a, 'tcx> ArgType<'tcx> {\n                                   bcx.pointercast(dst.llval, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n                                   C_usize(ccx, self.layout.size.bytes()),\n-                                  self.layout.align.min(ty.align(ccx)));\n+                                  self.layout.align.min(cast.align(ccx)));\n \n                 bcx.lifetime_end(llscratch, scratch_size);\n             }\n         } else {\n-            val = base::from_immediate(bcx, val);\n-            bcx.store(val, dst.llval, None);\n+            OperandValue::Immediate(val).store(bcx, dst);\n         }\n     }\n \n     pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: LvalueRef<'tcx>) {\n-        if !self.nested.is_empty() {\n-            for (i, arg) in self.nested.iter().enumerate() {\n-                arg.store_fn_arg(bcx, idx, dst.project_field(bcx, i));\n-            }\n-            return;\n-        }\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n-        if self.is_ignore() {\n-            return;\n+        let mut next = || {\n+            let val = llvm::get_param(bcx.llfn(), *idx as c_uint);\n+            *idx += 1;\n+            val\n+        };\n+        match self.mode {\n+            PassMode::Ignore => {},\n+            PassMode::Pair(..) => {\n+                OperandValue::Pair(next(), next()).store(bcx, dst);\n+            }\n+            PassMode::Direct(_) | PassMode::Indirect(_) | PassMode::Cast(_) => {\n+                self.store(bcx, next(), dst);\n+            }\n         }\n-        let val = llvm::get_param(bcx.llfn(), *idx as c_uint);\n-        *idx += 1;\n-        self.store(bcx, val, dst);\n     }\n }\n \n@@ -660,7 +656,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                sig: ty::FnSig<'tcx>,\n                extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n-        fn_ty.adjust_for_abi(ccx, sig);\n+        fn_ty.adjust_for_abi(ccx, sig.abi);\n         fn_ty\n     }\n \n@@ -669,9 +665,23 @@ impl<'a, 'tcx> FnType<'tcx> {\n                       extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         // Don't pass the vtable, it's not an argument of the virtual fn.\n-        assert_eq!(fn_ty.args[0].nested.len(), 2);\n-        fn_ty.args[0].nested[1].ignore();\n-        fn_ty.adjust_for_abi(ccx, sig);\n+        {\n+            let self_arg = &mut fn_ty.args[0];\n+            match self_arg.mode {\n+                PassMode::Pair(data_ptr, _) => {\n+                    self_arg.mode = PassMode::Direct(data_ptr);\n+                }\n+                _ => bug!(\"FnType::new_vtable: non-pair self {:?}\", self_arg)\n+            }\n+\n+            let pointee = self_arg.layout.ty.builtin_deref(true, ty::NoPreference)\n+                .unwrap_or_else(|| {\n+                    bug!(\"FnType::new_vtable: non-pointer self {:?}\", self_arg)\n+                }).ty;\n+            let fat_ptr_ty = ccx.tcx().mk_mut_ptr(pointee);\n+            self_arg.layout = ccx.layout_of(fat_ptr_ty).field(ccx, 0);\n+        }\n+        fn_ty.adjust_for_abi(ccx, sig.abi);\n         fn_ty\n     }\n \n@@ -737,31 +747,37 @@ impl<'a, 'tcx> FnType<'tcx> {\n         };\n \n         // Handle safe Rust thin and fat pointers.\n-        let adjust_for_rust_type = |arg: &mut ArgType<'tcx>, is_return: bool| {\n-            match arg.layout.abi {\n-                layout::Abi::Scalar(layout::Scalar {\n-                    value: layout::Pointer,\n-                    ref valid_range\n-                }) => {\n-                    if valid_range.start > 0 && valid_range.start < valid_range.end {\n-                        arg.attrs.set(ArgAttribute::NonNull);\n-                    }\n-                }\n-                _ => {\n-                    // Nothing to do for non-pointer types.\n-                    return;\n+        let adjust_for_rust_scalar = |attrs: &mut ArgAttributes,\n+                                      scalar: &layout::Scalar,\n+                                      layout: TyLayout<'tcx>,\n+                                      offset: Size,\n+                                      is_return: bool| {\n+            // Booleans are always an i1 that needs to be zero-extended.\n+            if scalar.is_bool() {\n+                attrs.set(ArgAttribute::ZExt);\n+                return;\n+            }\n+\n+            // Only pointer types handled below.\n+            if scalar.value != layout::Pointer {\n+                return;\n+            }\n+\n+            if scalar.valid_range.start < scalar.valid_range.end {\n+                if scalar.valid_range.start > 0 {\n+                    attrs.set(ArgAttribute::NonNull);\n                 }\n             }\n \n-            if let Some(pointee) = arg.layout.pointee_info_at(ccx, Size::from_bytes(0)) {\n+            if let Some(pointee) = layout.pointee_info_at(ccx, offset) {\n                 if let Some(kind) = pointee.safe {\n-                    arg.attrs.pointee_size = pointee.size;\n-                    arg.attrs.pointee_align = Some(pointee.align);\n+                    attrs.pointee_size = pointee.size;\n+                    attrs.pointee_align = Some(pointee.align);\n \n                     // HACK(eddyb) LLVM inserts `llvm.assume` calls when inlining functions\n                     // with align attributes, and those calls later block optimizations.\n                     if !is_return {\n-                        arg.attrs.pointee_align = None;\n+                        attrs.pointee_align = None;\n                     }\n \n                     // `Box` pointer parameters never alias because ownership is transferred\n@@ -778,11 +794,11 @@ impl<'a, 'tcx> FnType<'tcx> {\n                         PointerKind::UniqueBorrowed => !is_return\n                     };\n                     if no_alias {\n-                        arg.attrs.set(ArgAttribute::NoAlias);\n+                        attrs.set(ArgAttribute::NoAlias);\n                     }\n \n                     if kind == PointerKind::Frozen && !is_return {\n-                        arg.attrs.set(ArgAttribute::ReadOnly);\n+                        attrs.set(ArgAttribute::ReadOnly);\n                     }\n                 }\n             }\n@@ -794,22 +810,39 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 // For some forsaken reason, x86_64-pc-windows-gnu\n                 // doesn't ignore zero-sized struct arguments.\n                 // The same is true for s390x-unknown-linux-gnu.\n-                if is_return || rust_abi ||\n-                    (!win_x64_gnu && !linux_s390x) {\n-                    arg.ignore();\n+                if is_return || rust_abi || (!win_x64_gnu && !linux_s390x) {\n+                    arg.mode = PassMode::Ignore;\n                 }\n             }\n \n-            // FIXME(eddyb) other ABIs don't have logic for nested.\n-            if !is_return && type_is_fat_ptr(ccx, arg.layout.ty) && rust_abi {\n-                arg.nested = vec![\n-                    ArgType::new(arg.layout.field(ccx, 0)),\n-                    ArgType::new(arg.layout.field(ccx, 1))\n-                ];\n-                adjust_for_rust_type(&mut arg.nested[0], false);\n-                adjust_for_rust_type(&mut arg.nested[1], false);\n-            } else {\n-                adjust_for_rust_type(&mut arg, is_return);\n+            // FIXME(eddyb) other ABIs don't have logic for scalar pairs.\n+            if !is_return && rust_abi {\n+                if let layout::Abi::ScalarPair(ref a, ref b) = arg.layout.abi {\n+                    let mut a_attrs = ArgAttributes::new();\n+                    let mut b_attrs = ArgAttributes::new();\n+                    adjust_for_rust_scalar(&mut a_attrs,\n+                                           a,\n+                                           arg.layout,\n+                                           Size::from_bytes(0),\n+                                           false);\n+                    adjust_for_rust_scalar(&mut b_attrs,\n+                                           b,\n+                                           arg.layout,\n+                                           a.value.size(ccx).abi_align(b.value.align(ccx)),\n+                                           false);\n+                    arg.mode = PassMode::Pair(a_attrs, b_attrs);\n+                    return arg;\n+                }\n+            }\n+\n+            if let layout::Abi::Scalar(ref scalar) = arg.layout.abi {\n+                if let PassMode::Direct(ref mut attrs) = arg.mode {\n+                    adjust_for_rust_scalar(attrs,\n+                                           scalar,\n+                                           arg.layout,\n+                                           Size::from_bytes(0),\n+                                           is_return);\n+                }\n             }\n \n             arg\n@@ -827,40 +860,20 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n     fn adjust_for_abi(&mut self,\n                       ccx: &CrateContext<'a, 'tcx>,\n-                      sig: ty::FnSig<'tcx>) {\n-        let abi = sig.abi;\n+                      abi: Abi) {\n         if abi == Abi::Unadjusted { return }\n \n         if abi == Abi::Rust || abi == Abi::RustCall ||\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             let fixup = |arg: &mut ArgType<'tcx>| {\n+                if arg.is_ignore() { return; }\n+\n                 match arg.layout.abi {\n                     layout::Abi::Aggregate { .. } => {}\n                     _ => return\n                 }\n \n                 let size = arg.layout.size;\n-\n-                if let Some(unit) = arg.layout.homogeneous_aggregate(ccx) {\n-                    // Replace newtypes with their inner-most type.\n-                    if unit.size == size {\n-                        // Needs a cast as we've unpacked a newtype.\n-                        arg.cast_to(unit);\n-                        return;\n-                    }\n-\n-                    // Pairs of floats.\n-                    if unit.kind == RegKind::Float {\n-                        if unit.size.checked_mul(2, ccx) == Some(size) {\n-                            // FIXME(eddyb) This should be using Uniform instead of a pair,\n-                            // but the resulting [2 x float/double] breaks emscripten.\n-                            // See https://github.com/kripken/emscripten-fastcomp/issues/178.\n-                            arg.cast_to(CastTarget::Pair(unit, unit));\n-                            return;\n-                        }\n-                    }\n-                }\n-\n                 if size > layout::Pointer.size(ccx) {\n                     arg.make_indirect();\n                 } else {\n@@ -873,25 +886,12 @@ impl<'a, 'tcx> FnType<'tcx> {\n                     });\n                 }\n             };\n-            // Fat pointers are returned by-value.\n-            if !self.ret.is_ignore() {\n-                if !type_is_fat_ptr(ccx, sig.output()) {\n-                    fixup(&mut self.ret);\n-                }\n-            }\n+            fixup(&mut self.ret);\n             for arg in &mut self.args {\n-                if arg.is_ignore() { continue; }\n-                if !arg.nested.is_empty() {\n-                    for arg in &mut arg.nested {\n-                        assert!(arg.nested.is_empty());\n-                        fixup(arg);\n-                    }\n-                    continue;\n-                }\n                 fixup(arg);\n             }\n-            if self.ret.is_indirect() {\n-                self.ret.attrs.set(ArgAttribute::StructRet);\n+            if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n+                attrs.set(ArgAttribute::StructRet);\n             }\n             return;\n         }\n@@ -930,55 +930,44 @@ impl<'a, 'tcx> FnType<'tcx> {\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n \n-        if self.ret.is_indirect() {\n-            self.ret.attrs.set(ArgAttribute::StructRet);\n+        if let PassMode::Indirect(ref mut attrs) = self.ret.mode {\n+            attrs.set(ArgAttribute::StructRet);\n         }\n     }\n \n     pub fn llvm_type(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n         let mut llargument_tys = Vec::new();\n \n-        let llreturn_ty = if self.ret.is_ignore() {\n-            Type::void(ccx)\n-        } else if self.ret.is_indirect() {\n-            llargument_tys.push(self.ret.memory_ty(ccx).ptr_to());\n-            Type::void(ccx)\n-        } else if let Some(cast) = self.ret.cast {\n-            cast.llvm_type(ccx)\n-        } else {\n-            self.ret.layout.immediate_llvm_type(ccx)\n+        let llreturn_ty = match self.ret.mode {\n+            PassMode::Ignore => Type::void(ccx),\n+            PassMode::Direct(_) | PassMode::Pair(..) => {\n+                self.ret.layout.immediate_llvm_type(ccx)\n+            }\n+            PassMode::Cast(cast) => cast.llvm_type(ccx),\n+            PassMode::Indirect(_) => {\n+                llargument_tys.push(self.ret.memory_ty(ccx).ptr_to());\n+                Type::void(ccx)\n+            }\n         };\n \n-        {\n-            let mut push = |arg: &ArgType<'tcx>| {\n-                if arg.is_ignore() {\n-                    return;\n-                }\n-                // add padding\n-                if let Some(ty) = arg.pad {\n-                    llargument_tys.push(ty.llvm_type(ccx));\n-                }\n-\n-                let llarg_ty = if arg.is_indirect() {\n-                    arg.memory_ty(ccx).ptr_to()\n-                } else if let Some(cast) = arg.cast {\n-                    cast.llvm_type(ccx)\n-                } else {\n-                    arg.layout.immediate_llvm_type(ccx)\n-                };\n+        for arg in &self.args {\n+            // add padding\n+            if let Some(ty) = arg.pad {\n+                llargument_tys.push(ty.llvm_type(ccx));\n+            }\n \n-                llargument_tys.push(llarg_ty);\n-            };\n-            for arg in &self.args {\n-                if !arg.nested.is_empty() {\n-                    for arg in &arg.nested {\n-                        assert!(arg.nested.is_empty());\n-                        push(arg);\n-                    }\n+            let llarg_ty = match arg.mode {\n+                PassMode::Ignore => continue,\n+                PassMode::Direct(_) => arg.layout.immediate_llvm_type(ccx),\n+                PassMode::Pair(..) => {\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(ccx, 0));\n+                    llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(ccx, 1));\n                     continue;\n                 }\n-                push(arg);\n-            }\n+                PassMode::Cast(cast) => cast.llvm_type(ccx),\n+                PassMode::Indirect(_) => arg.memory_ty(ccx).ptr_to(),\n+            };\n+            llargument_tys.push(llarg_ty);\n         }\n \n         if self.variadic {\n@@ -989,52 +978,62 @@ impl<'a, 'tcx> FnType<'tcx> {\n     }\n \n     pub fn apply_attrs_llfn(&self, llfn: ValueRef) {\n-        let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n-        if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n-        }\n-        i += 1;\n-        let mut apply = |arg: &ArgType| {\n-            if !arg.is_ignore() {\n-                if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n-                i += 1;\n-            }\n+        let mut i = 0;\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n+            i += 1;\n         };\n+        match self.ret.mode {\n+            PassMode::Direct(ref attrs) => {\n+                attrs.apply_llfn(llvm::AttributePlace::ReturnValue, llfn);\n+            }\n+            PassMode::Indirect(ref attrs) => apply(attrs),\n+            _ => {}\n+        }\n         for arg in &self.args {\n-            if !arg.nested.is_empty() {\n-                for arg in &arg.nested {\n-                    assert!(arg.nested.is_empty());\n-                    apply(arg);\n+            if arg.pad.is_some() {\n+                apply(&ArgAttributes::new());\n+            }\n+            match arg.mode {\n+                PassMode::Ignore => {}\n+                PassMode::Direct(ref attrs) |\n+                PassMode::Indirect(ref attrs) => apply(attrs),\n+                PassMode::Pair(ref a, ref b) => {\n+                    apply(a);\n+                    apply(b);\n                 }\n-                continue;\n+                PassMode::Cast(_) => apply(&ArgAttributes::new()),\n             }\n-            apply(arg);\n         }\n     }\n \n     pub fn apply_attrs_callsite(&self, callsite: ValueRef) {\n-        let mut i = if self.ret.is_indirect() { 1 } else { 0 };\n-        if !self.ret.is_ignore() {\n-            self.ret.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n-        }\n-        i += 1;\n-        let mut apply = |arg: &ArgType| {\n-            if !arg.is_ignore() {\n-                if arg.pad.is_some() { i += 1; }\n-                arg.attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n-                i += 1;\n-            }\n+        let mut i = 0;\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n+            i += 1;\n         };\n+        match self.ret.mode {\n+            PassMode::Direct(ref attrs) => {\n+                attrs.apply_callsite(llvm::AttributePlace::ReturnValue, callsite);\n+            }\n+            PassMode::Indirect(ref attrs) => apply(attrs),\n+            _ => {}\n+        }\n         for arg in &self.args {\n-            if !arg.nested.is_empty() {\n-                for arg in &arg.nested {\n-                    assert!(arg.nested.is_empty());\n-                    apply(arg);\n+            if arg.pad.is_some() {\n+                apply(&ArgAttributes::new());\n+            }\n+            match arg.mode {\n+                PassMode::Ignore => {}\n+                PassMode::Direct(ref attrs) |\n+                PassMode::Indirect(ref attrs) => apply(attrs),\n+                PassMode::Pair(ref a, ref b) => {\n+                    apply(a);\n+                    apply(b);\n                 }\n-                continue;\n+                PassMode::Cast(_) => apply(&ArgAttributes::new()),\n             }\n-            apply(arg);\n         }\n \n         if self.cconv != llvm::CCallConv {"}, {"sha": "745aa0da82900d1681a7432a9afd6745c4ce5c0b", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "patch": "@@ -116,7 +116,7 @@ pub fn from_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: ValueRe\n             naked(llfn, true);\n         } else if attr.check_name(\"allocator\") {\n             Attribute::NoAlias.apply_llfn(\n-                llvm::AttributePlace::ReturnValue(), llfn);\n+                llvm::AttributePlace::ReturnValue, llfn);\n         } else if attr.check_name(\"unwind\") {\n             unwind(llfn, true);\n         } else if attr.check_name(\"rustc_allocator_nounwind\") {"}, {"sha": "1664251cf897b0edd10b84bc6787814714dc695c", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{FnType, ArgType, ArgAttribute, LayoutExt, Uniform};\n+use abi::{FnType, ArgType, LayoutExt, Uniform};\n use context::CrateContext;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n@@ -35,8 +35,7 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n \n fn classify_arg_ty(arg: &mut ArgType) {\n     if arg.layout.is_aggregate() {\n-        arg.make_indirect();\n-        arg.attrs.set(ArgAttribute::ByVal);\n+        arg.make_indirect_byval();\n     }\n }\n "}, {"sha": "6fd0140c39901d7ce6ee4f7df3c0cb530e17a7d9", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{ArgAttribute, FnType, LayoutExt, Reg, RegKind};\n+use abi::{ArgAttribute, FnType, LayoutExt, PassMode, Reg, RegKind};\n use common::CrateContext;\n \n use rustc::ty::layout::{self, TyLayout};\n@@ -82,8 +82,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n         if arg.layout.is_aggregate() {\n-            arg.make_indirect();\n-            arg.attrs.set(ArgAttribute::ByVal);\n+            arg.make_indirect_byval();\n         } else {\n             arg.extend_integer_width_to(32);\n         }\n@@ -102,7 +101,15 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         let mut free_regs = 2;\n \n         for arg in &mut fty.args {\n-            if arg.is_ignore() || arg.is_indirect() { continue; }\n+            let attrs = match arg.mode {\n+                PassMode::Ignore |\n+                PassMode::Indirect(_) => continue,\n+                PassMode::Direct(ref mut attrs) => attrs,\n+                PassMode::Pair(..) |\n+                PassMode::Cast(_) => {\n+                    bug!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n+                }\n+            };\n \n             // At this point we know this must be a primitive of sorts.\n             let unit = arg.layout.homogeneous_aggregate(ccx).unwrap();\n@@ -124,7 +131,7 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             free_regs -= size_in_regs;\n \n             if arg.layout.size.bits() <= 32 && unit.kind == RegKind::Integer {\n-                arg.attrs.set(ArgAttribute::InReg);\n+                attrs.set(ArgAttribute::InReg);\n             }\n \n             if free_regs == 0 {"}, {"sha": "81eb362ca46dc776281e3a7d62cd763dd12d2bd3", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "patch": "@@ -11,7 +11,7 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-use abi::{ArgType, ArgAttribute, CastTarget, FnType, LayoutExt, Reg, RegKind};\n+use abi::{ArgType, CastTarget, FnType, LayoutExt, Reg, RegKind};\n use context::CrateContext;\n \n use rustc::ty::layout::{self, TyLayout, Size};\n@@ -214,11 +214,11 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType\n         };\n \n         if in_mem {\n-            arg.make_indirect();\n             if is_arg {\n-                arg.attrs.set(ArgAttribute::ByVal);\n+                arg.make_indirect_byval();\n             } else {\n                 // `sret` parameter thus one less integer register available\n+                arg.make_indirect();\n                 int_regs -= 1;\n             }\n         } else {"}, {"sha": "5abc096407d5d5aa324dca36cc8e3c512e81a0d4", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "patch": "@@ -13,7 +13,7 @@\n use intrinsics::{self, Intrinsic};\n use llvm;\n use llvm::{ValueRef};\n-use abi::{Abi, FnType};\n+use abi::{Abi, FnType, PassMode};\n use mir::lvalue::{LvalueRef, Alignment};\n use mir::operand::{OperandRef, OperandValue};\n use base::*;\n@@ -237,7 +237,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         \"volatile_load\" => {\n             let tp_ty = substs.type_at(0);\n             let mut ptr = args[0].immediate();\n-            if let Some(ty) = fn_ty.ret.cast {\n+            if let PassMode::Cast(ty) = fn_ty.ret.mode {\n                 ptr = bcx.pointercast(ptr, ty.llvm_type(ccx).ptr_to());\n             }\n             let load = bcx.volatile_load(ptr);\n@@ -671,7 +671,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     };\n \n     if !fn_ty.ret.is_ignore() {\n-        if let Some(ty) = fn_ty.ret.cast {\n+        if let PassMode::Cast(ty) = fn_ty.ret.mode {\n             let ptr = bcx.pointercast(llresult, ty.llvm_type(ccx).ptr_to());\n             bcx.store(llval, ptr, Some(ccx.align_of(ret_ty)));\n         } else {"}, {"sha": "f43eba36a8232fa8fdb188efb13e73ec93bc8320", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 68, "deletions": 66, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "patch": "@@ -15,7 +15,7 @@ use rustc::ty::{self, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::traits;\n use rustc::mir;\n-use abi::{Abi, FnType, ArgType};\n+use abi::{Abi, FnType, ArgType, PassMode};\n use base;\n use callee;\n use builder::Builder;\n@@ -207,44 +207,47 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::Return => {\n-                if self.fn_ty.ret.is_ignore() || self.fn_ty.ret.is_indirect() {\n-                    bcx.ret_void();\n-                    return;\n-                }\n+                let llval = match self.fn_ty.ret.mode {\n+                    PassMode::Ignore | PassMode::Indirect(_) => {\n+                        bcx.ret_void();\n+                        return;\n+                    }\n \n-                let llval = if let Some(cast_ty) = self.fn_ty.ret.cast {\n-                    let op = match self.locals[mir::RETURN_POINTER] {\n-                        LocalRef::Operand(Some(op)) => op,\n-                        LocalRef::Operand(None) => bug!(\"use of return before def\"),\n-                        LocalRef::Lvalue(tr_lvalue) => {\n-                            OperandRef {\n-                                val: Ref(tr_lvalue.llval, tr_lvalue.alignment),\n-                                layout: tr_lvalue.layout\n-                            }\n-                        }\n-                    };\n-                    let llslot = match op.val {\n-                        Immediate(_) | Pair(..) => {\n-                            let scratch = LvalueRef::alloca(&bcx, self.fn_ty.ret.layout, \"ret\");\n-                            op.val.store(&bcx, scratch);\n-                            scratch.llval\n-                        }\n-                        Ref(llval, align) => {\n-                            assert_eq!(align, Alignment::AbiAligned,\n-                                       \"return pointer is unaligned!\");\n-                            llval\n+                    PassMode::Direct(_) | PassMode::Pair(..) => {\n+                        let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n+                        if let Ref(llval, align) = op.val {\n+                            bcx.load(llval, align.non_abi())\n+                        } else {\n+                            op.immediate_or_packed_pair(&bcx)\n                         }\n-                    };\n-                    let load = bcx.load(\n-                        bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n-                        Some(self.fn_ty.ret.layout.align));\n-                    load\n-                } else {\n-                    let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n-                    if let Ref(llval, align) = op.val {\n-                        bcx.load(llval, align.non_abi())\n-                    } else {\n-                        op.immediate_or_packed_pair(&bcx)\n+                    }\n+\n+                    PassMode::Cast(cast_ty) => {\n+                        let op = match self.locals[mir::RETURN_POINTER] {\n+                            LocalRef::Operand(Some(op)) => op,\n+                            LocalRef::Operand(None) => bug!(\"use of return before def\"),\n+                            LocalRef::Lvalue(tr_lvalue) => {\n+                                OperandRef {\n+                                    val: Ref(tr_lvalue.llval, tr_lvalue.alignment),\n+                                    layout: tr_lvalue.layout\n+                                }\n+                            }\n+                        };\n+                        let llslot = match op.val {\n+                            Immediate(_) | Pair(..) => {\n+                                let scratch = LvalueRef::alloca(&bcx, self.fn_ty.ret.layout, \"ret\");\n+                                op.val.store(&bcx, scratch);\n+                                scratch.llval\n+                            }\n+                            Ref(llval, align) => {\n+                                assert_eq!(align, Alignment::AbiAligned,\n+                                           \"return pointer is unaligned!\");\n+                                llval\n+                            }\n+                        };\n+                        bcx.load(\n+                            bcx.pointercast(llslot, cast_ty.llvm_type(bcx.ccx).ptr_to()),\n+                            Some(self.fn_ty.ret.layout.align))\n                     }\n                 };\n                 bcx.ret(llval);\n@@ -559,12 +562,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 for (i, arg) in first_args.iter().enumerate() {\n                     let mut op = self.trans_operand(&bcx, arg);\n-                    if i == 0 {\n-                        if let Pair(_, meta) = op.val {\n-                            if let Some(ty::InstanceDef::Virtual(_, idx)) = def {\n-                                llfn = Some(meth::VirtualIndex::from_index(idx)\n-                                    .get_fn(&bcx, meta, &fn_ty));\n-                            }\n+                    if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n+                        if let Pair(data_ptr, meta) = op.val {\n+                            llfn = Some(meth::VirtualIndex::from_index(idx)\n+                                .get_fn(&bcx, meta, &fn_ty));\n+                            llargs.push(data_ptr);\n+                            continue;\n                         }\n                     }\n \n@@ -604,21 +607,6 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       arg: &ArgType<'tcx>) {\n-        if let Pair(a, b) = op.val {\n-            // Treat the values in a fat pointer separately.\n-            if !arg.nested.is_empty() {\n-                assert_eq!(arg.nested.len(), 2);\n-                let imm_op = |x| OperandRef {\n-                    val: Immediate(x),\n-                    // We won't be checking the type again.\n-                    layout: bcx.ccx.layout_of(bcx.tcx().types.never)\n-                };\n-                self.trans_argument(bcx, imm_op(a), llargs, &arg.nested[0]);\n-                self.trans_argument(bcx, imm_op(b), llargs, &arg.nested[1]);\n-                return;\n-            }\n-        }\n-\n         // Fill padding with undef value, where applicable.\n         if let Some(ty) = arg.pad {\n             llargs.push(C_undef(ty.llvm_type(bcx.ccx)));\n@@ -628,15 +616,29 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             return;\n         }\n \n+        if let PassMode::Pair(..) = arg.mode {\n+            match op.val {\n+                Pair(a, b) => {\n+                    llargs.push(a);\n+                    llargs.push(b);\n+                    return;\n+                }\n+                _ => bug!(\"trans_argument: {:?} invalid for pair arugment\", op)\n+            }\n+        }\n+\n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n-                if arg.is_indirect() || arg.cast.is_some() {\n-                    let scratch = LvalueRef::alloca(bcx, arg.layout, \"arg\");\n-                    op.val.store(bcx, scratch);\n-                    (scratch.llval, Alignment::AbiAligned, true)\n-                } else {\n-                    (op.immediate_or_packed_pair(bcx), Alignment::AbiAligned, false)\n+                match arg.mode {\n+                    PassMode::Indirect(_) | PassMode::Cast(_) => {\n+                        let scratch = LvalueRef::alloca(bcx, arg.layout, \"arg\");\n+                        op.val.store(bcx, scratch);\n+                        (scratch.llval, Alignment::AbiAligned, true)\n+                    }\n+                    _ => {\n+                        (op.immediate_or_packed_pair(bcx), Alignment::AbiAligned, false)\n+                    }\n                 }\n             }\n             Ref(llval, align @ Alignment::Packed(_)) if arg.is_indirect() => {\n@@ -653,7 +655,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if let Some(ty) = arg.cast {\n+            if let PassMode::Cast(ty) = arg.mode {\n                 llval = bcx.load(bcx.pointercast(llval, ty.llvm_type(bcx.ccx).ptr_to()),\n                                  (align | Alignment::Packed(arg.layout.align))\n                                     .non_abi());\n@@ -890,7 +892,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n-                let op = if ret_ty.cast.is_some() {\n+                let op = if let PassMode::Cast(_) = ret_ty.mode {\n                     let tmp = LvalueRef::alloca(bcx, ret_ty.layout, \"tmp_ret\");\n                     tmp.storage_live(bcx);\n                     ret_ty.store(bcx, llval, tmp);"}, {"sha": "7f3a430c418e9451df4cc682a1722e19a090efe1", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ecc564f2cee4da3ef9397ba58e19d3fd9be3de/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=18ecc564f2cee4da3ef9397ba58e19d3fd9be3de", "patch": "@@ -22,7 +22,7 @@ use builder::Builder;\n use common::{CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::Instance;\n-use abi::{ArgAttribute, FnType};\n+use abi::{ArgAttribute, FnType, PassMode};\n \n use syntax_pos::{DUMMY_SP, NO_EXPANSION, BytePos, Span};\n use syntax::symbol::keywords;\n@@ -429,55 +429,52 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n         let arg = &mircx.fn_ty.args[idx];\n         idx += 1;\n-        let lvalue = if arg.is_indirect() {\n-            // Don't copy an indirect argument to an alloca, the caller\n-            // already put it in a temporary alloca and gave it up\n-            // FIXME: lifetimes\n-            if arg.pad.is_some() {\n-                llarg_idx += 1;\n-            }\n-            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-            bcx.set_value_name(llarg, &name);\n-            llarg_idx += 1;\n-            LvalueRef::new_sized(llarg, arg.layout, Alignment::AbiAligned)\n-        } else if !lvalue_locals.contains(local.index()) &&\n-                  !arg.nested.is_empty() {\n-            assert_eq!(arg.nested.len(), 2);\n-            let (a, b) = (&arg.nested[0], &arg.nested[1]);\n-            assert!(!a.is_ignore() && a.cast.is_none() && a.pad.is_none());\n-            assert!(!b.is_ignore() && b.cast.is_none() && b.pad.is_none());\n-\n-            let a = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-            bcx.set_value_name(a, &(name.clone() + \".0\"));\n-            llarg_idx += 1;\n-\n-            let b = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n-            bcx.set_value_name(b, &(name + \".1\"));\n+        if arg.pad.is_some() {\n             llarg_idx += 1;\n+        }\n \n-            return LocalRef::Operand(Some(OperandRef {\n-                val: OperandValue::Pair(a, b),\n-                layout: arg.layout\n-            }));\n-        } else if !lvalue_locals.contains(local.index()) &&\n-                  !arg.is_indirect() && arg.cast.is_none() &&\n-                  arg_scope.is_none() {\n-            if arg.is_ignore() {\n-                return LocalRef::new_operand(bcx.ccx, arg.layout);\n-            }\n-\n+        if arg_scope.is_none() && !lvalue_locals.contains(local.index()) {\n             // We don't have to cast or keep the argument in the alloca.\n             // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n             // of putting everything in allocas just so we can use llvm.dbg.declare.\n-            if arg.pad.is_some() {\n-                llarg_idx += 1;\n+            let local = |op| LocalRef::Operand(Some(op));\n+            match arg.mode {\n+                PassMode::Ignore => {\n+                    return local(OperandRef::new_zst(bcx.ccx, arg.layout));\n+                }\n+                PassMode::Direct(_) => {\n+                    let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+                    bcx.set_value_name(llarg, &name);\n+                    llarg_idx += 1;\n+                    return local(\n+                        OperandRef::from_immediate_or_packed_pair(bcx, llarg, arg.layout));\n+                }\n+                PassMode::Pair(..) => {\n+                    let a = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+                    bcx.set_value_name(a, &(name.clone() + \".0\"));\n+                    llarg_idx += 1;\n+\n+                    let b = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n+                    bcx.set_value_name(b, &(name + \".1\"));\n+                    llarg_idx += 1;\n+\n+                    return local(OperandRef {\n+                        val: OperandValue::Pair(a, b),\n+                        layout: arg.layout\n+                    });\n+                }\n+                _ => {}\n             }\n+        }\n+\n+        let lvalue = if arg.is_indirect() {\n+            // Don't copy an indirect argument to an alloca, the caller\n+            // already put it in a temporary alloca and gave it up.\n+            // FIXME: lifetimes\n             let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             bcx.set_value_name(llarg, &name);\n             llarg_idx += 1;\n-            return LocalRef::Operand(Some(\n-                OperandRef::from_immediate_or_packed_pair(bcx, llarg, arg.layout)\n-            ));\n+            LvalueRef::new_sized(llarg, arg.layout, Alignment::AbiAligned)\n         } else {\n             let tmp = LvalueRef::alloca(bcx, arg.layout, &name);\n             arg.store_fn_arg(bcx, &mut llarg_idx, tmp);\n@@ -489,16 +486,19 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 // The Rust ABI passes indirect variables using a pointer and a manual copy, so we\n                 // need to insert a deref here, but the C ABI uses a pointer and a copy using the\n                 // byval attribute, for which LLVM does the deref itself, so we must not add it.\n-                let variable_access = if arg.is_indirect() &&\n-                    !arg.attrs.contains(ArgAttribute::ByVal) {\n-                    VariableAccess::IndirectVariable {\n-                        alloca: lvalue.llval,\n-                        address_operations: &deref_op,\n-                    }\n-                } else {\n-                    VariableAccess::DirectVariable { alloca: lvalue.llval }\n+                let mut variable_access = VariableAccess::DirectVariable {\n+                    alloca: lvalue.llval\n                 };\n \n+                if let PassMode::Indirect(ref attrs) = arg.mode {\n+                    if !attrs.contains(ArgAttribute::ByVal) {\n+                        variable_access = VariableAccess::IndirectVariable {\n+                            alloca: lvalue.llval,\n+                            address_operations: &deref_op,\n+                        };\n+                    }\n+                }\n+\n                 declare_local(\n                     bcx,\n                     &mircx.debug_context,"}]}