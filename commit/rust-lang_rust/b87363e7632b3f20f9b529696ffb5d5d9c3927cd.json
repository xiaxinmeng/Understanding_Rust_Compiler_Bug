{"sha": "b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NzM2M2U3NjMyYjNmMjBmOWI1Mjk2OTZmZmI1ZDVkOWMzOTI3Y2Q=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-09T21:23:30Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-02-10T23:42:32Z"}, "message": "tests: doc comments", "tree": {"sha": "49fee4866ed6c2d5b61562e67afe09625de217d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49fee4866ed6c2d5b61562e67afe09625de217d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "html_url": "https://github.com/rust-lang/rust/commit/b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3e182cf43aea2c010a1915eb37293a458df2228", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e182cf43aea2c010a1915eb37293a458df2228", "html_url": "https://github.com/rust-lang/rust/commit/c3e182cf43aea2c010a1915eb37293a458df2228"}], "stats": {"total": 328, "additions": 164, "deletions": 164}, "files": [{"sha": "481ee7cebc4e8382fdf21ac086becc0bddbd3f78", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -50,11 +50,11 @@ pub const CAPACITY: usize = 2 * B - 1;\n ///\n /// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n /// order to statically allocate a single dummy node to avoid allocations. This struct is\n-/// `repr(C)` to prevent them from being reordered.  `LeafNode` does not just contain a\n+/// `repr(C)` to prevent them from being reordered. `LeafNode` does not just contain a\n /// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n-/// Crucially, `NodeHeader` can be safely transmuted to different K and V.  (This is exploited\n+/// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n /// by `as_header`.)\n-/// See `into_key_slice` for an explanation of K2.  K2 cannot be safely transmuted around\n+/// See `into_key_slice` for an explanation of K2. K2 cannot be safely transmuted around\n /// because the size of `NodeHeader` depends on its alignment!\n #[repr(C)]\n struct NodeHeader<K, V, K2 = ()> {"}, {"sha": "a292bde33152a69277b38101458de06c64003f54", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1922,7 +1922,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Panics\n     ///\n-    /// If `mid` is greater than `len()`.  Note that `mid == len()`\n+    /// If `mid` is greater than `len()`. Note that `mid == len()`\n     /// does _not_ panic and is a no-op rotation.\n     ///\n     /// # Complexity\n@@ -1967,7 +1967,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// # Panics\n     ///\n-    /// If `k` is greater than `len()`.  Note that `k == len()`\n+    /// If `k` is greater than `len()`. Note that `k == len()`\n     /// does _not_ panic and is a no-op rotation.\n     ///\n     /// # Complexity"}, {"sha": "d2ba9b001916c572e142fedfbc6d312842928cb0", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -27,7 +27,7 @@\n //! will then parse the format string and determine if the list of arguments\n //! provided is suitable to pass to this format string.\n //!\n-//! To convert a single value to a string, use the [`to_string`] method.  This\n+//! To convert a single value to a string, use the [`to_string`] method. This\n //! will use the [`Display`] formatting trait.\n //!\n //! ## Positional parameters\n@@ -102,7 +102,7 @@\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n //! This allows multiple actual types to be formatted via `{:x}` (like [`i8`] as\n-//! well as [`isize`]).  The current mapping of types to traits is:\n+//! well as [`isize`]). The current mapping of types to traits is:\n //!\n //! * *nothing* \u21d2 [`Display`]\n //! * `?` \u21d2 [`Debug`]\n@@ -427,7 +427,7 @@\n //! 3. An asterisk `.*`:\n //!\n //!    `.*` means that this `{...}` is associated with *two* format inputs rather than one: the\n-//!    first input holds the `usize` precision, and the second holds the value to print.  Note that\n+//!    first input holds the `usize` precision, and the second holds the value to print. Note that\n //!    in this case, if one uses the format string `{<arg>:<spec>.*}`, then the `<arg>` part refers\n //!    to the *value* to print, and the `precision` must come in the input preceding `<arg>`.\n //!"}, {"sha": "4fe6d450add0815df7c39b51377fe7d193c14950", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -62,8 +62,8 @@ macro_rules! vec {\n \n /// Creates a `String` using interpolation of runtime expressions.\n ///\n-/// The first argument `format!` receives is a format string.  This must be a string\n-/// literal.  The power of the formatting string is in the `{}`s contained.\n+/// The first argument `format!` receives is a format string. This must be a string\n+/// literal. The power of the formatting string is in the `{}`s contained.\n ///\n /// Additional parameters passed to `format!` replace the `{}`s within the\n /// formatting string in the order given unless named or positional parameters\n@@ -73,7 +73,7 @@ macro_rules! vec {\n /// The same convention is used with [`print!`] and [`write!`] macros,\n /// depending on the intended destination of the string.\n ///\n-/// To convert a single value to a string, use the [`to_string`] method.  This\n+/// To convert a single value to a string, use the [`to_string`] method. This\n /// will use the [`Display`] formatting trait.\n ///\n /// [fmt]: ../std/fmt/index.html"}, {"sha": "4bc21ec7f5e855b291d2085d40c80305b2a3ebb9", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -738,7 +738,7 @@ impl<T> Vec<T> {\n     /// Forces the length of the vector to `new_len`.\n     ///\n     /// This is a low-level operation that maintains none of the normal\n-    /// invariants of the type.  Normally changing the length of a vector\n+    /// invariants of the type. Normally changing the length of a vector\n     /// is done using one of the safe operations instead, such as\n     /// [`truncate`], [`resize`], [`extend`], or [`clear`].\n     ///"}, {"sha": "f49e226a5cb68ed04b5064008cb102f41982ca5c", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -425,7 +425,7 @@ impl fmt::Display for CannotReallocInPlace {\n /// The `GlobalAlloc` trait is an `unsafe` trait for a number of reasons, and\n /// implementors must ensure that they adhere to these contracts:\n ///\n-/// * It's undefined behavior if global allocators unwind.  This restriction may\n+/// * It's undefined behavior if global allocators unwind. This restriction may\n ///   be lifted in the future, but currently a panic from any of these\n ///   functions may lead to memory unsafety.\n ///"}, {"sha": "01ab523a4c3f6ce8bd3c825d2b7c2e735034419b", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -18,7 +18,7 @@\n //!\n //! Consider a situation where we want to log out a value passed to a function.\n //! We know the value we're working on implements Debug, but we don't know its\n-//! concrete type.  We want to give special treatment to certain types: in this\n+//! concrete type. We want to give special treatment to certain types: in this\n //! case printing out the length of String values prior to their value.\n //! We don't know the concrete type of our value at compile time, so we need to\n //! use runtime reflection instead.\n@@ -31,8 +31,8 @@\n //! fn log<T: Any + Debug>(value: &T) {\n //!     let value_any = value as &dyn Any;\n //!\n-//!     // try to convert our value to a String.  If successful, we want to\n-//!     // output the String's length as well as its value.  If not, it's a\n+//!     // Try to convert our value to a `String`. If successful, we want to\n+//!     // output the String`'s length as well as its value. If not, it's a\n //!     // different type: just print it out unadorned.\n //!     match value_any.downcast_ref::<String>() {\n //!         Some(as_string) => {"}, {"sha": "fb8d7e5d088647263b6d696c8d95c719327b99fd", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1133,7 +1133,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as\n-    /// `Ref::clone(...)`.  A `Clone` implementation or a method would interfere\n+    /// `Ref::clone(...)`. A `Clone` implementation or a method would interfere\n     /// with the widespread use of `r.borrow().clone()` to clone the contents of\n     /// a `RefCell`.\n     #[stable(feature = \"cell_extras\", since = \"1.15.0\")]\n@@ -1174,7 +1174,7 @@ impl<'b, T: ?Sized> Ref<'b, T> {\n         }\n     }\n \n-    /// Split a `Ref` into multiple `Ref`s for different components of the\n+    /// Splits a `Ref` into multiple `Ref`s for different components of the\n     /// borrowed data.\n     ///\n     /// The `RefCell` is already immutably borrowed, so this cannot fail.\n@@ -1223,7 +1223,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n     /// The `RefCell` is already mutably borrowed, so this cannot fail.\n     ///\n     /// This is an associated function that needs to be used as\n-    /// `RefMut::map(...)`.  A method would interfere with methods of the same\n+    /// `RefMut::map(...)`. A method would interfere with methods of the same\n     /// name on the contents of a `RefCell` used through `Deref`.\n     ///\n     /// # Examples\n@@ -1253,7 +1253,7 @@ impl<'b, T: ?Sized> RefMut<'b, T> {\n         }\n     }\n \n-    /// Split a `RefMut` into multiple `RefMut`s for different components of the\n+    /// Splits a `RefMut` into multiple `RefMut`s for different components of the\n     /// borrowed data.\n     ///\n     /// The underlying `RefCell` will remain mutably borrowed until both"}, {"sha": "81fcdeee12d29e96614069f3b52e9ae79c2b8790", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -26,7 +26,7 @@ use self::Ordering::*;\n /// relations](http://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n /// This trait allows for partial equality, for types that do not have a full\n-/// equivalence relation.  For example, in floating point numbers `NaN != NaN`,\n+/// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not `Eq`.\n ///\n /// Formally, the equality must be (for all `a`, `b` and `c`):"}, {"sha": "de34e79f597e231bc620df8084f1a162574f1b6a", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -217,7 +217,7 @@ pub trait AsMut<T: ?Sized> {\n ///\n /// There is one exception to implementing `Into`, and it's kind of esoteric.\n /// If the destination type is not part of the current crate, and it uses a\n-/// generic variable, then you can't implement `From` directly.  For example,\n+/// generic variable, then you can't implement `From` directly. For example,\n /// take this crate:\n ///\n /// ```compile_fail"}, {"sha": "c29358c4c4a36a64c83d1a24796368089e982a63", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1,6 +1,6 @@\n-//! rustc compiler intrinsics.\n+//! Compiler intrinsics.\n //!\n-//! The corresponding definitions are in librustc_codegen_llvm/intrinsic.rs.\n+//! The corresponding definitions are in `librustc_codegen_llvm/intrinsic.rs`.\n //!\n //! # Volatiles\n //!\n@@ -697,7 +697,7 @@ extern \"rust-intrinsic\" {\n     /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n-    /// which is unsafe unless T is `Copy`.  Also, even if T is\n+    /// which is unsafe unless `T` is `Copy`. Also, even if T is\n     /// `Copy`, an all-zero value may not correspond to any legitimate\n     /// state for the type in question.\n     pub fn init<T>() -> T;\n@@ -988,7 +988,7 @@ extern \"rust-intrinsic\" {\n     ///   beginning at `dst` with the same size.\n     ///\n     /// Like [`read`], `copy_nonoverlapping` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using *both* the values\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using *both* the values\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///\n@@ -1055,7 +1055,7 @@ extern \"rust-intrinsic\" {\n     /// [`copy_nonoverlapping`] can be used instead.\n     ///\n     /// `copy` is semantically equivalent to C's [`memmove`], but with the argument\n-    /// order swapped.  Copying takes place as if the bytes were copied from `src`\n+    /// order swapped. Copying takes place as if the bytes were copied from `src`\n     /// to a temporary array and then copied from the array to `dst`.\n     ///\n     /// [`copy_nonoverlapping`]: ./fn.copy_nonoverlapping.html\n@@ -1072,7 +1072,7 @@ extern \"rust-intrinsic\" {\n     /// * Both `src` and `dst` must be properly aligned.\n     ///\n     /// Like [`read`], `copy` creates a bitwise copy of `T`, regardless of\n-    /// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the values\n+    /// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the values\n     /// in the region beginning at `*src` and the region beginning at `*dst` can\n     /// [violate memory safety][read-ownership].\n     ///"}, {"sha": "1c86745d9ba404d381ccca310c59d5b86b15db66", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -564,9 +564,9 @@ pub trait Iterator {\n     /// Calls a closure on each element of an iterator.\n     ///\n     /// This is equivalent to using a [`for`] loop on the iterator, although\n-    /// `break` and `continue` are not possible from a closure.  It's generally\n+    /// `break` and `continue` are not possible from a closure. It's generally\n     /// more idiomatic to use a `for` loop, but `for_each` may be more legible\n-    /// when processing items at the end of longer iterator chains.  In some\n+    /// when processing items at the end of longer iterator chains. In some\n     /// cases `for_each` may also be faster than a loop, because it will use\n     /// internal iteration on adaptors like `Chain`.\n     ///\n@@ -1515,7 +1515,7 @@ pub trait Iterator {\n     /// is propagated back to the caller immediately (short-circuiting).\n     ///\n     /// The initial value is the value the accumulator will have on the first\n-    /// call.  If applying the closure succeeded against every element of the\n+    /// call. If applying the closure succeeded against every element of the\n     /// iterator, `try_fold()` returns the final accumulator as success.\n     ///\n     /// Folding is useful whenever you have a collection of something, and want\n@@ -1528,10 +1528,10 @@ pub trait Iterator {\n     /// do something better than the default `for` loop implementation.\n     ///\n     /// In particular, try to have this call `try_fold()` on the internal parts\n-    /// from which this iterator is composed.  If multiple calls are needed,\n+    /// from which this iterator is composed. If multiple calls are needed,\n     /// the `?` operator may be convenient for chaining the accumulator value\n     /// along, but beware any invariants that need to be upheld before those\n-    /// early returns.  This is a `&mut self` method, so iteration needs to be\n+    /// early returns. This is a `&mut self` method, so iteration needs to be\n     /// resumable after hitting an error here.\n     ///\n     /// # Examples"}, {"sha": "d81d309a81a59893cb128c58aee1ea61a05c05c9", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -432,7 +432,7 @@ macro_rules! writeln {\n /// * Iterators that dynamically terminate.\n ///\n /// If the determination that the code is unreachable proves incorrect, the\n-/// program immediately terminates with a [`panic!`].  The function [`unreachable_unchecked`],\n+/// program immediately terminates with a [`panic!`]. The function [`unreachable_unchecked`],\n /// which belongs to the [`std::hint`] module, informs the compiler to\n /// optimize the code out of the release version entirely.\n ///"}, {"sha": "855b8ba7f9646cf70fde8172c3a253f716e0e01d", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1101,7 +1101,7 @@ impl<T> MaybeUninit<T> {\n     }\n \n     /// Create a new `MaybeUninit` in an uninitialized state, with the memory being\n-    /// filled with `0` bytes.  It depends on `T` whether that already makes for\n+    /// filled with `0` bytes. It depends on `T` whether that already makes for\n     /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n     /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n     /// be null.\n@@ -1130,7 +1130,7 @@ impl<T> MaybeUninit<T> {\n         }\n     }\n \n-    /// Extract the value from the `MaybeUninit` container.  This is a great way\n+    /// Extract the value from the `MaybeUninit` container. This is a great way\n     /// to ensure that the data will get dropped, because the resulting `T` is\n     /// subject to the usual drop handling.\n     ///"}, {"sha": "a1bf6f824f67735d731c4eabcccbf03bdb6bb2e9", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -37,7 +37,7 @@\n //!\n //! In addition, there are numerous helper functions that are used in the paper but not available\n //! in Rust (or at least in core). Our version is additionally complicated by the need to handle\n-//! overflow and underflow and the desire to handle subnormal numbers.  Bellerophon and\n+//! overflow and underflow and the desire to handle subnormal numbers. Bellerophon and\n //! Algorithm R have trouble with overflow, subnormals, and underflow. We conservatively switch to\n //! Algorithm M (with the modifications described in section 8 of the paper) well before the\n //! inputs get into the critical region.\n@@ -148,7 +148,7 @@ macro_rules! from_str_float_impl {\n             /// # Return value\n             ///\n             /// `Err(ParseFloatError)` if the string did not represent a valid\n-            /// number.  Otherwise, `Ok(n)` where `n` is the floating-point\n+            /// number. Otherwise, `Ok(n)` where `n` is the floating-point\n             /// number represented by `src`.\n             #[inline]\n             fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n@@ -209,7 +209,7 @@ fn pfe_invalid() -> ParseFloatError {\n     ParseFloatError { kind: FloatErrorKind::Invalid }\n }\n \n-/// Split decimal string into sign and the rest, without inspecting or validating the rest.\n+/// Splits a decimal string into sign and the rest, without inspecting or validating the rest.\n fn extract_sign(s: &str) -> (Sign, &str) {\n     match s.as_bytes()[0] {\n         b'+' => (Sign::Positive, &s[1..]),"}, {"sha": "06d7fb8d1035b214ca9af2884642bb2ba03a3aa1", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -59,10 +59,10 @@ pub trait RawFloat\n     /// Type used by `to_bits` and `from_bits`.\n     type Bits: Add<Output = Self::Bits> + From<u8> + TryFrom<u64>;\n \n-    /// Raw transmutation to integer.\n+    /// Performs a raw transmutation to an integer.\n     fn to_bits(self) -> Self::Bits;\n \n-    /// Raw transmutation from integer.\n+    /// Performs a raw transmutation from an integer.\n     fn from_bits(v: Self::Bits) -> Self;\n \n     /// Returns the category that this number falls into.\n@@ -71,14 +71,14 @@ pub trait RawFloat\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n-    /// Decode the float.\n+    /// Decodes the float.\n     fn unpack(self) -> Unpacked;\n \n-    /// Cast from a small integer that can be represented exactly.  Panic if the integer can't be\n+    /// Casts from a small integer that can be represented exactly. Panic if the integer can't be\n     /// represented, the other code in this module makes sure to never let that happen.\n     fn from_int(x: u64) -> Self;\n \n-    /// Get the value 10<sup>e</sup> from a pre-computed table.\n+    /// Gets the value 10<sup>e</sup> from a pre-computed table.\n     /// Panics for `e >= CEIL_LOG5_OF_MAX_SIG`.\n     fn short_fast_pow10(e: usize) -> Self;\n "}, {"sha": "202beddfcb0b2125e449e933052d7cc0fb62003a", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -518,7 +518,7 @@ pub trait Rem<RHS=Self> {\n \n macro_rules! rem_impl_integer {\n     ($($t:ty)*) => ($(\n-        /// This operation satisfies `n % d == n - (n / d) * d`.  The\n+        /// This operation satisfies `n % d == n - (n / d) * d`. The\n         /// result has the same sign as the left operand.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         impl Rem for $t {"}, {"sha": "9fa2c81954ee16a8ffc4a31bf6cd4f94f525f15f", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1,7 +1,7 @@\n /// A trait for customizing the behavior of the `?` operator.\n ///\n /// A type implementing `Try` is one that has a canonical way to view it\n-/// in terms of a success/failure dichotomy.  This trait allows both\n+/// in terms of a success/failure dichotomy. This trait allows both\n /// extracting those success or failure values from an existing instance and\n /// creating a new instance from a success or failure value.\n #[unstable(feature = \"try_trait\", issue = \"42327\")]"}, {"sha": "209608457180bfae893e3e6ff867131d51e12572", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -12,7 +12,7 @@\n //! to access only a single value, in which case the documentation omits the size\n //! and implicitly assumes it to be `size_of::<T>()` bytes.\n //!\n-//! The precise rules for validity are not determined yet.  The guarantees that are\n+//! The precise rules for validity are not determined yet. The guarantees that are\n //! provided at this point are very minimal:\n //!\n //! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n@@ -104,7 +104,7 @@ pub use intrinsics::write_bytes;\n ///\n /// * `to_drop` must be [valid] for reads.\n ///\n-/// * `to_drop` must be properly aligned.  See the example below for how to drop\n+/// * `to_drop` must be properly aligned. See the example below for how to drop\n ///   an unaligned pointer.\n ///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n@@ -135,7 +135,7 @@ pub use intrinsics::write_bytes;\n /// unsafe {\n ///     // Get a raw pointer to the last element in `v`.\n ///     let ptr = &mut v[1] as *mut _;\n-///     // Shorten `v` to prevent the last item from being dropped.  We do that first,\n+///     // Shorten `v` to prevent the last item from being dropped. We do that first,\n ///     // to prevent issues if the `drop_in_place` below panics.\n ///     v.set_len(1);\n ///     // Without a call `drop_in_place`, the last item would never be dropped,\n@@ -531,7 +531,7 @@ pub unsafe fn replace<T>(dst: *mut T, mut src: T) -> T {\n ///\n /// `read` creates a bitwise copy of `T`, regardless of whether `T` is [`Copy`].\n /// If `T` is not [`Copy`], using both the returned value and the value at\n-/// `*src` can violate memory safety.  Note that assigning to `*src` counts as a\n+/// `*src` can violate memory safety. Note that assigning to `*src` counts as a\n /// use because it will attempt to drop the value at `*src`.\n ///\n /// [`write`] can be used to overwrite data without causing it to be dropped.\n@@ -588,7 +588,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n /// * `src` must be [valid] for reads.\n ///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n ///\n /// Note that even if `T` has size `0`, the pointer must be non-NULL.\n@@ -839,7 +839,7 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// * `src` must be properly aligned.\n ///\n /// Like [`read`], `read_unaligned` creates a bitwise copy of `T`, regardless of\n-/// whether `T` is [`Copy`].  If `T` is not [`Copy`], using both the returned\n+/// whether `T` is [`Copy`]. If `T` is not [`Copy`], using both the returned\n /// value and the value at `*src` can [violate memory safety][read-ownership].\n /// However, storing non-[`Copy`] types in volatile memory is almost certainly\n /// incorrect.\n@@ -1093,7 +1093,7 @@ impl<T: ?Sized> *const T {\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.  If you need to cross object\n+    /// allows the compiler to optimize better. If you need to cross object\n     /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples\n@@ -1712,7 +1712,7 @@ impl<T: ?Sized> *mut T {\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Always use `.offset(count)` instead when possible, because `offset`\n-    /// allows the compiler to optimize better.  If you need to cross object\n+    /// allows the compiler to optimize better. If you need to cross object\n     /// boundaries, cast the pointer to an integer and do the arithmetic there.\n     ///\n     /// # Examples"}, {"sha": "e2129c68e7fbbbcfd198c3f52fec44c655e264fc", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1197,7 +1197,7 @@ impl<T> [T] {\n \n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred` limited to returning at most `n` items. This starts at the end of\n-    /// the slice and works backwards.  The matched element is not contained in\n+    /// the slice and works backwards. The matched element is not contained in\n     /// the subslices.\n     ///\n     /// The last element returned, if any, will contain the remainder of the\n@@ -3145,7 +3145,7 @@ unsafe impl<T: Sync> Sync for Iter<'_, T> {}\n unsafe impl<T: Sync> Send for Iter<'_, T> {}\n \n impl<'a, T> Iter<'a, T> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -3247,7 +3247,7 @@ unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n impl<'a, T> IterMut<'a, T> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// To avoid creating `&mut` references that alias, this is forced\n     /// to consume the iterator."}, {"sha": "9b35b51349a02612de93e6f276f6316a1ab7cfcf", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -26,7 +26,7 @@ impl<T> RawArray<T> {\n }\n \n /// Rotates the range `[mid-left, mid+right)` such that the element at `mid`\n-/// becomes the first element.  Equivalently, rotates the range `left`\n+/// becomes the first element. Equivalently, rotates the range `left`\n /// elements to the left or `right` elements to the right.\n ///\n /// # Safety\n@@ -36,10 +36,10 @@ impl<T> RawArray<T> {\n /// # Algorithm\n ///\n /// For longer rotations, swap the left-most `delta = min(left, right)`\n-/// elements with the right-most `delta` elements.  LLVM vectorizes this,\n+/// elements with the right-most `delta` elements. LLVM vectorizes this,\n /// which is profitable as we only reach this step for a \"large enough\"\n-/// rotation.  Doing this puts `delta` elements on the larger side into the\n-/// correct position, leaving a smaller rotate problem.  Demonstration:\n+/// rotation. Doing this puts `delta` elements on the larger side into the\n+/// correct position, leaving a smaller rotate problem. Demonstration:\n ///\n /// ```text\n /// [ 6 7 8 9 10 11 12 13 . 1 2 3 4 5 ]"}, {"sha": "c43db91688829584357b0b7a3e2e9c43a9a0e084", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -612,7 +612,7 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n impl FusedIterator for Chars<'_> {}\n \n impl<'a> Chars<'a> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -702,7 +702,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n impl FusedIterator for CharIndices<'_> {}\n \n impl<'a> CharIndices<'a> {\n-    /// View the underlying data as a subslice of the original data.\n+    /// Views the underlying data as a subslice of the original data.\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n@@ -1579,9 +1579,9 @@ mod traits {\n \n     /// Implements ordering of strings.\n     ///\n-    /// Strings are ordered  lexicographically by their byte values.  This orders Unicode code\n-    /// points based on their positions in the code charts.  This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale.  Sorting strings according to\n+    /// Strings are ordered  lexicographically by their byte values. This orders Unicode code\n+    /// points based on their positions in the code charts. This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale. Sorting strings according to\n     /// culturally-accepted standards requires locale-specific data that is outside the scope of\n     /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1607,9 +1607,9 @@ mod traits {\n \n     /// Implements comparison operations on strings.\n     ///\n-    /// Strings are compared lexicographically by their byte values.  This compares Unicode code\n-    /// points based on their positions in the code charts.  This is not necessarily the same as\n-    /// \"alphabetical\" order, which varies by language and locale.  Comparing strings according to\n+    /// Strings are compared lexicographically by their byte values. This compares Unicode code\n+    /// points based on their positions in the code charts. This is not necessarily the same as\n+    /// \"alphabetical\" order, which varies by language and locale. Comparing strings according to\n     /// culturally-accepted standards requires locale-specific data that is outside the scope of\n     /// the `str` type.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2643,7 +2643,7 @@ impl str {\n         Bytes(self.as_bytes().iter().cloned())\n     }\n \n-    /// Split a string slice by whitespace.\n+    /// Splits a string slice by whitespace.\n     ///\n     /// The iterator returned will return string slices that are sub-slices of\n     /// the original string slice, separated by any amount of whitespace.\n@@ -2686,7 +2686,7 @@ impl str {\n         SplitWhitespace { inner: self.split(IsWhitespace).filter(IsNotEmpty) }\n     }\n \n-    /// Split a string slice by ASCII whitespace.\n+    /// Splits a string slice by ASCII whitespace.\n     ///\n     /// The iterator returned will return string slices that are sub-slices of\n     /// the original string slice, separated by any amount of ASCII whitespace."}, {"sha": "ee583c829dd1d453f2181ef327c0342813301e79", "filename": "src/libcore/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -43,7 +43,7 @@ pub const NANOSECOND: Duration = Duration::from_nanos(1);\n /// timeouts.\n ///\n /// Each `Duration` is composed of a whole number of seconds and a fractional part\n-/// represented in nanoseconds.  If the underlying system does not support\n+/// represented in nanoseconds. If the underlying system does not support\n /// nanosecond-level precision, APIs binding a system timeout will typically round up\n /// the number of nanoseconds.\n ///"}, {"sha": "6f7965095b638504873c644ccc7a6804234cd6e4", "filename": "src/libproc_macro/bridge/scoped_cell.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -38,7 +38,7 @@ impl<T: LambdaL> ScopedCell<T> {\n         ScopedCell(Cell::new(value))\n     }\n \n-    /// Set the value in `self` to `replacement` while\n+    /// Sets the value in `self` to `replacement` while\n     /// running `f`, which gets the old value, mutably.\n     /// The old value will be restored after `f` exits, even\n     /// by panic, including modifications made to it by `f`.\n@@ -73,7 +73,7 @@ impl<T: LambdaL> ScopedCell<T> {\n         f(RefMutL(put_back_on_drop.value.as_mut().unwrap()))\n     }\n \n-    /// Set the value in `self` to `value` while running `f`.\n+    /// Sets the value in `self` to `value` while running `f`.\n     pub fn set<'a, R>(&self, value: <T as ApplyL<'a>>::Out, f: impl FnOnce() -> R) -> R {\n         self.replace(value, |_| f())\n     }"}, {"sha": "65eebb5ec37374a47fcbf356ac7e5e390d8316b8", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -56,7 +56,7 @@ pub struct Diagnostic {\n \n macro_rules! diagnostic_child_methods {\n     ($spanned:ident, $regular:ident, $level:expr) => (\n-        /// Add a new child diagnostic message to `self` with the level\n+        /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `spans` and\n         /// `message`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n@@ -67,7 +67,7 @@ macro_rules! diagnostic_child_methods {\n             self\n         }\n \n-        /// Add a new child diagnostic message to `self` with the level\n+        /// Adds a new child diagnostic message to `self` with the level\n         /// identified by this method's name with the given `message`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n         pub fn $regular<T: Into<String>>(mut self, message: T) -> Diagnostic {\n@@ -93,7 +93,7 @@ impl<'a> Iterator for Children<'a> {\n \n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n impl Diagnostic {\n-    /// Create a new diagnostic with the given `level` and `message`.\n+    /// Creates a new diagnostic with the given `level` and `message`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn new<T: Into<String>>(level: Level, message: T) -> Diagnostic {\n         Diagnostic {\n@@ -104,7 +104,7 @@ impl Diagnostic {\n         }\n     }\n \n-    /// Create a new diagnostic with the given `level` and `message` pointing to\n+    /// Creates a new diagnostic with the given `level` and `message` pointing to\n     /// the given set of `spans`.\n     #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n     pub fn spanned<S, T>(spans: S, level: Level, message: T) -> Diagnostic"}, {"sha": "bd0a7ec0e1a9d432d15279b0cf20a572d3a662ed", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -88,7 +88,7 @@ impl TokenStream {\n /// or characters not existing in the language.\n /// All tokens in the parsed stream get `Span::call_site()` spans.\n ///\n-/// NOTE: Some errors may cause panics instead of returning `LexError`. We reserve the right to\n+/// NOTE: some errors may cause panics instead of returning `LexError`. We reserve the right to\n /// change these errors into `LexError`s later.\n #[stable(feature = \"proc_macro_lib\", since = \"1.15.0\")]\n impl FromStr for TokenStream {\n@@ -244,7 +244,7 @@ impl !Sync for Span {}\n \n macro_rules! diagnostic_method {\n     ($name:ident, $level:expr) => (\n-        /// Create a new `Diagnostic` with the given `message` at the span\n+        /// Creates a new `Diagnostic` with the given `message` at the span\n         /// `self`.\n         #[unstable(feature = \"proc_macro_diagnostic\", issue = \"54140\")]\n         pub fn $name<T: Into<String>>(self, message: T) -> Diagnostic {\n@@ -290,19 +290,19 @@ impl Span {\n         Span(self.0.source())\n     }\n \n-    /// Get the starting line/column in the source file for this span.\n+    /// Gets the starting line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn start(&self) -> LineColumn {\n         self.0.start()\n     }\n \n-    /// Get the ending line/column in the source file for this span.\n+    /// Gets the ending line/column in the source file for this span.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n     pub fn end(&self) -> LineColumn {\n         self.0.end()\n     }\n \n-    /// Create a new span encompassing `self` and `other`.\n+    /// Creates a new span encompassing `self` and `other`.\n     ///\n     /// Returns `None` if `self` and `other` are from different files.\n     #[unstable(feature = \"proc_macro_span\", issue = \"54725\")]\n@@ -368,7 +368,7 @@ impl !Sync for LineColumn {}\n pub struct SourceFile(bridge::client::SourceFile);\n \n impl SourceFile {\n-    /// Get the path to this source file.\n+    /// Gets the path to this source file.\n     ///\n     /// ### Note\n     /// If the code span associated with this `SourceFile` was generated by an external macro, this"}, {"sha": "7fa7b80751938ec760b8ad16d362b3fff9e5f13a", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -250,7 +250,7 @@ impl f64 {\n     /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n     ///\n     /// In particular, the return value `r` satisfies `0.0 <= r < rhs.abs()` in\n-    /// most cases.  However, due to a floating point round-off error it can\n+    /// most cases. However, due to a floating point round-off error it can\n     /// result in `r == rhs.abs()`, violating the mathematical definition, if\n     /// `self` is much smaller than `rhs.abs()` in magnitude and `self < 0.0`.\n     /// This result is not an element of the function's codomain, but it is the"}, {"sha": "c05c19ae56663598b5aa6cd868fa1da0b6b413b0", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -24,7 +24,7 @@ use sys_common::{AsInner, IntoInner, FromInner};\n ///\n /// `OsString` and [`OsStr`] bridge this gap by simultaneously representing Rust\n /// and platform-native string values, and in particular allowing a Rust string\n-/// to be converted into an \"OS\" string with no cost if possible.  A consequence\n+/// to be converted into an \"OS\" string with no cost if possible. A consequence\n /// of this is that `OsString` instances are *not* `NUL` terminated; in order\n /// to pass to e.g., Unix system call, you should create a [`CStr`].\n ///"}, {"sha": "2837aade82cd245bc7420239198acc8914cb837b", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -222,7 +222,7 @@ fn initial_buffer_size(file: &File) -> usize {\n /// Read the entire contents of a file into a bytes vector.\n ///\n /// This is a convenience function for using [`File::open`] and [`read_to_end`]\n-/// with fewer imports and without an intermediate variable.  It pre-allocates a\n+/// with fewer imports and without an intermediate variable. It pre-allocates a\n /// buffer based on the file size when available, so it is generally faster than\n /// reading into a vector created with `Vec::new()`.\n ///\n@@ -263,7 +263,7 @@ pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n /// Read the entire contents of a file into a string.\n ///\n /// This is a convenience function for using [`File::open`] and [`read_to_string`]\n-/// with fewer imports and without an intermediate variable.  It pre-allocates a\n+/// with fewer imports and without an intermediate variable. It pre-allocates a\n /// buffer based on the file size when available, so it is generally faster than\n /// reading into a string created with `String::new()`.\n ///"}, {"sha": "0615cd59db4eb840a1d04c57fef94cfb02724121", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -16,9 +16,9 @@ use memchr;\n /// the underlying [`Read`] and maintains an in-memory buffer of the results.\n ///\n /// `BufReader` can improve the speed of programs that make *small* and\n-/// *repeated* read calls to the same file or network socket.  It does not\n+/// *repeated* read calls to the same file or network socket. It does not\n /// help when reading very large amounts at once, or reading just one or a few\n-/// times.  It also provides no advantage when reading from a source that is\n+/// times. It also provides no advantage when reading from a source that is\n /// already in memory, like a `Vec<u8>`.\n ///\n /// [`Read`]: ../../std/io/trait.Read.html\n@@ -331,9 +331,9 @@ impl<R: Seek> Seek for BufReader<R> {\n /// writer in large, infrequent batches.\n ///\n /// `BufWriter` can improve the speed of programs that make *small* and\n-/// *repeated* write calls to the same file or network socket.  It does not\n+/// *repeated* write calls to the same file or network socket. It does not\n /// help when writing very large amounts at once, or writing just one or a few\n-/// times.  It also provides no advantage when writing to a destination that is\n+/// times. It also provides no advantage when writing to a destination that is\n /// in memory, like a `Vec<u8>`.\n ///\n /// When the `BufWriter` is dropped, the contents of its buffer will be written"}, {"sha": "d5c2aaea543f4434b0c6e7cdb3b80e15c0f14394", "filename": "src/libstd/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkeyword_docs.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -627,7 +627,7 @@ mod loop_keyword { }\n /// directly accessed and modified.\n ///\n /// Tuple structs are similar to regular structs, but its fields have no names. They are used like\n-/// tuples, with deconstruction possible via `let TupleStruct(x, y) = foo;` syntax.  For accessing\n+/// tuples, with deconstruction possible via `let TupleStruct(x, y) = foo;` syntax. For accessing\n /// individual variables, the same syntax is used as with regular tuples, namely `foo.0`, `foo.1`,\n /// etc, starting at zero.\n ///"}, {"sha": "2ed3377838be35adff2ee94341eb5378d63acb51", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -11,8 +11,8 @@\n /// an unrecoverable problem.\n ///\n /// This macro is the perfect way to assert conditions in example code and in\n-/// tests.  `panic!` is closely tied with the `unwrap` method of both [`Option`]\n-/// and [`Result`][runwrap] enums.  Both implementations call `panic!` when they are set\n+/// tests. `panic!` is closely tied with the `unwrap` method of both [`Option`]\n+/// and [`Result`][runwrap] enums. Both implementations call `panic!` when they are set\n /// to None or Err variants.\n ///\n /// This macro is used to inject panic into a Rust thread, causing the thread to\n@@ -21,7 +21,7 @@\n /// is transmitted.\n ///\n /// [`Result`] enum is often a better solution for recovering from errors than\n-/// using the `panic!` macro.  This macro should be used to avoid proceeding using\n+/// using the `panic!` macro. This macro should be used to avoid proceeding using\n /// incorrect values, such as from external sources. Detailed information about\n /// error handling is found in the [book].\n ///\n@@ -79,7 +79,7 @@ macro_rules! panic {\n /// necessary to use [`io::stdout().flush()`][flush] to ensure the output is emitted\n /// immediately.\n ///\n-/// Use `print!` only for the primary output of your program.  Use\n+/// Use `print!` only for the primary output of your program. Use\n /// [`eprint!`] instead to print error and progress messages.\n ///\n /// [`println!`]: ../std/macro.println.html\n@@ -124,7 +124,7 @@ macro_rules! print {\n /// Use the [`format!`] syntax to write data to the standard output.\n /// See [`std::fmt`] for more information.\n ///\n-/// Use `println!` only for the primary output of your program.  Use\n+/// Use `println!` only for the primary output of your program. Use\n /// [`eprintln!`] instead to print error and progress messages.\n ///\n /// [`format!`]: ../std/macro.format.html\n@@ -154,10 +154,10 @@ macro_rules! println {\n /// Macro for printing to the standard error.\n ///\n /// Equivalent to the [`print!`] macro, except that output goes to\n-/// [`io::stderr`] instead of `io::stdout`.  See [`print!`] for\n+/// [`io::stderr`] instead of `io::stdout`. See [`print!`] for\n /// example usage.\n ///\n-/// Use `eprint!` only for error and progress messages.  Use `print!`\n+/// Use `eprint!` only for error and progress messages. Use `print!`\n /// instead for the primary output of your program.\n ///\n /// [`io::stderr`]: ../std/io/struct.Stderr.html\n@@ -182,10 +182,10 @@ macro_rules! eprint {\n /// Macro for printing to the standard error, with a newline.\n ///\n /// Equivalent to the [`println!`] macro, except that output goes to\n-/// [`io::stderr`] instead of `io::stdout`.  See [`println!`] for\n+/// [`io::stderr`] instead of `io::stdout`. See [`println!`] for\n /// example usage.\n ///\n-/// Use `eprintln!` only for error and progress messages.  Use `println!`\n+/// Use `eprintln!` only for error and progress messages. Use `println!`\n /// instead for the primary output of your program.\n ///\n /// [`io::stderr`]: ../std/io/struct.Stderr.html\n@@ -462,16 +462,16 @@ mod builtin {\n     /// The core macro for formatted string creation & output.\n     ///\n     /// This macro functions by taking a formatting string literal containing\n-    /// `{}` for each additional argument passed.  `format_args!` prepares the\n+    /// `{}` for each additional argument passed. `format_args!` prepares the\n     /// additional parameters to ensure the output can be interpreted as a string\n-    /// and canonicalizes the arguments into a single type.  Any value that implements\n+    /// and canonicalizes the arguments into a single type. Any value that implements\n     /// the [`Display`] trait can be passed to `format_args!`, as can any\n     /// [`Debug`] implementation be passed to a `{:?}` within the formatting string.\n     ///\n     /// This macro produces a value of type [`fmt::Arguments`]. This value can be\n     /// passed to the macros within [`std::fmt`] for performing useful redirection.\n     /// All other formatting macros ([`format!`], [`write!`], [`println!`], etc) are\n-    /// proxied through this one.  `format_args!`, unlike its derived macros, avoids\n+    /// proxied through this one. `format_args!`, unlike its derived macros, avoids\n     /// heap allocations.\n     ///\n     /// You can use the [`fmt::Arguments`] value that `format_args!` returns\n@@ -554,7 +554,7 @@ mod builtin {\n     /// If the named environment variable is present at compile time, this will\n     /// expand into an expression of type `Option<&'static str>` whose value is\n     /// `Some` of the value of the environment variable. If the environment\n-    /// variable is not present, then this will expand to `None`.  See\n+    /// variable is not present, then this will expand to `None`. See\n     /// [`Option<T>`][option] for more information on this type.\n     ///\n     /// A compile time error is never emitted when using this macro regardless\n@@ -904,7 +904,7 @@ mod builtin {\n     /// # Custom Messages\n     ///\n     /// This macro has a second form, where a custom panic message can\n-    /// be provided with or without arguments for formatting.  See [`std::fmt`]\n+    /// be provided with or without arguments for formatting. See [`std::fmt`]\n     /// for syntax for this form.\n     ///\n     /// [`panic!`]: macro.panic.html"}, {"sha": "91167debff3babb4ebce2652dd5152efdbe44f56", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -671,7 +671,7 @@ impl hash::Hash for SocketAddrV6 {\n /// [`SocketAddr`] values.\n ///\n /// This trait is used for generic address resolution when constructing network\n-/// objects.  By default it is implemented for the following types:\n+/// objects. By default it is implemented for the following types:\n ///\n ///  * [`SocketAddr`]: [`to_socket_addrs`] is the identity function.\n ///"}, {"sha": "b0c0a8949dbddf1842d296b71a4324e415513da0", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1062,7 +1062,7 @@ mod prim_ref { }\n /// On top of that, function pointers can vary based on what ABI they use. This is achieved by\n /// adding the `extern` keyword to the type name, followed by the ABI in question. For example,\n /// `fn()` is different from `extern \"C\" fn()`, which itself is different from `extern \"stdcall\"\n-/// fn()`, and so on for the various ABIs that Rust supports.  Non-`extern` functions have an ABI\n+/// fn()`, and so on for the various ABIs that Rust supports. Non-`extern` functions have an ABI\n /// of `\"Rust\"`, and `extern` functions without an explicit ABI have an ABI of `\"C\"`. For more\n /// information, see [the nomicon's section on foreign calling conventions][nomicon-abi].\n ///"}, {"sha": "3b147e059a099fa038f8b6fe6a71842411b62ee7", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -343,13 +343,13 @@ impl Condvar {\n     ///\n     /// Note that the best effort is made to ensure that the time waited is\n     /// measured with a monotonic clock, and not affected by the changes made to\n-    /// the system time.  This function is susceptible to spurious wakeups.\n+    /// the system time. This function is susceptible to spurious wakeups.\n     /// Condition variables normally have a boolean predicate associated with\n     /// them, and the predicate must always be checked each time this function\n-    /// returns to protect against spurious wakeups.  Additionally, it is\n+    /// returns to protect against spurious wakeups. Additionally, it is\n     /// typically desirable for the time-out to not exceed some duration in\n     /// spite of spurious wakes, thus the sleep-duration is decremented by the\n-    /// amount slept.  Alternatively, use the `wait_timeout_until` method\n+    /// amount slept. Alternatively, use the `wait_timeout_until` method\n     /// to wait until a condition is met with a total time-out regardless\n     /// of spurious wakes.\n     ///\n@@ -413,7 +413,7 @@ impl Condvar {\n     }\n \n     /// Waits on this condition variable for a notification, timing out after a\n-    /// specified duration.  Spurious wakes will not cause this function to\n+    /// specified duration. Spurious wakes will not cause this function to\n     /// return.\n     ///\n     /// The semantics of this function are equivalent to [`wait_until`] except"}, {"sha": "d1cd76778f4a3c340d30772e3155de3deb086086", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -789,7 +789,7 @@ impl<T> Sender<T> {\n     /// where the corresponding receiver has already been deallocated. Note\n     /// that a return value of [`Err`] means that the data will never be\n     /// received, but a return value of [`Ok`] does *not* mean that the data\n-    /// will be received.  It is possible for the corresponding receiver to\n+    /// will be received. It is possible for the corresponding receiver to\n     /// hang up immediately after this function returns [`Ok`].\n     ///\n     /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err"}, {"sha": "472df01fee316de16f633fb60c5efc044d4ce690", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -72,11 +72,11 @@ struct SelectInner {\n impl !marker::Send for Select {}\n \n /// A handle to a receiver which is currently a member of a `Select` set of\n-/// receivers.  This handle is used to keep the receiver in the set as well as\n+/// receivers. This handle is used to keep the receiver in the set as well as\n /// interact with the underlying receiver.\n pub struct Handle<'rx, T:Send+'rx> {\n     /// The ID of this handle, used to compare against the return value of\n-    /// `Select::wait()`\n+    /// `Select::wait()`.\n     id: usize,\n     selector: *mut SelectInner,\n     next: *mut Handle<'static, ()>,"}, {"sha": "2b3bcb97d5929024f1687eaff30e971285206f65", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -314,7 +314,7 @@ impl<T: ?Sized> RwLock<T> {\n     /// Determines whether the lock is poisoned.\n     ///\n     /// If another thread is active, the lock can still become poisoned at any\n-    /// time.  You should not trust a `false` value for program correctness\n+    /// time. You should not trust a `false` value for program correctness\n     /// without additional synchronization.\n     ///\n     /// # Examples"}, {"sha": "76fea656d13349325b859b5342cc2d62916db483", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -287,9 +287,9 @@ impl FileTypeExt for fs::FileType {\n /// # Note\n ///\n /// On Windows, you must specify whether a symbolic link points to a file\n-/// or directory.  Use `os::windows::fs::symlink_file` to create a\n+/// or directory. Use `os::windows::fs::symlink_file` to create a\n /// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n-/// symbolic link to a directory.  Additionally, the process must have\n+/// symbolic link to a directory. Additionally, the process must have\n /// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n /// symbolic link.\n ///"}, {"sha": "afeb756806f49835ec63d0c6bced223bcecc2bcb", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -805,9 +805,9 @@ impl DirEntryExt for fs::DirEntry {\n /// # Note\n ///\n /// On Windows, you must specify whether a symbolic link points to a file\n-/// or directory.  Use `os::windows::fs::symlink_file` to create a\n+/// or directory. Use `os::windows::fs::symlink_file` to create a\n /// symbolic link to a file, or `os::windows::fs::symlink_dir` to create a\n-/// symbolic link to a directory.  Additionally, the process must have\n+/// symbolic link to a directory. Additionally, the process must have\n /// `SeCreateSymbolicLinkPrivilege` in order to be able to create a\n /// symbolic link.\n ///"}, {"sha": "6508c0cf447d19a61e300639827f80607c6b46b2", "filename": "src/libstd/sys/windows/ext/ffi.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fffi.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -3,19 +3,19 @@\n //! # Overview\n //!\n //! For historical reasons, the Windows API uses a form of potentially\n-//! ill-formed UTF-16 encoding for strings.  Specifically, the 16-bit\n+//! ill-formed UTF-16 encoding for strings. Specifically, the 16-bit\n //! code units in Windows strings may contain [isolated surrogate code\n-//! points which are not paired together][ill-formed-utf-16].  The\n+//! points which are not paired together][ill-formed-utf-16]. The\n //! Unicode standard requires that surrogate code points (those in the\n //! range U+D800 to U+DFFF) always be *paired*, because in the UTF-16\n //! encoding a *surrogate code unit pair* is used to encode a single\n-//! character.  For compatibility with code that does not enforce\n+//! character. For compatibility with code that does not enforce\n //! these pairings, Windows does not enforce them, either.\n //!\n //! While it is not always possible to convert such a string losslessly into\n //! a valid UTF-16 string (or even UTF-8), it is often desirable to be\n //! able to round-trip such a string from and to Windows APIs\n-//! losslessly.  For example, some Rust code may be \"bridging\" some\n+//! losslessly. For example, some Rust code may be \"bridging\" some\n //! Windows APIs together, just passing `WCHAR` strings among those\n //! APIs without ever really looking into the strings.\n //!\n@@ -28,16 +28,16 @@\n //! # `OsStringExt` and `OsStrExt`\n //!\n //! [`OsString`] is the Rust wrapper for owned strings in the\n-//! preferred representation of the operating system.  On Windows,\n+//! preferred representation of the operating system. On Windows,\n //! this struct gets augmented with an implementation of the\n-//! [`OsStringExt`] trait, which has a [`from_wide`] method.  This\n+//! [`OsStringExt`] trait, which has a [`from_wide`] method. This\n //! lets you create an [`OsString`] from a `&[u16]` slice; presumably\n //! you get such a slice out of a `WCHAR` Windows API.\n //!\n //! Similarly, [`OsStr`] is the Rust wrapper for borrowed strings from\n-//! preferred representation of the operating system.  On Windows, the\n+//! preferred representation of the operating system. On Windows, the\n //! [`OsStrExt`] trait provides the [`encode_wide`] method, which\n-//! outputs an [`EncodeWide`] iterator.  You can [`collect`] this\n+//! outputs an [`EncodeWide`] iterator. You can [`collect`] this\n //! iterator, for example, to obtain a `Vec<u16>`; you can later get a\n //! pointer to this vector's contents and feed it to Windows APIs.\n //!"}, {"sha": "438ea3aa3f6a396f84aefc2872c1aafc7b8b4dc7", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -841,7 +841,7 @@ const NOTIFIED: usize = 2;\n /// let flag2 = Arc::clone(&flag);\n ///\n /// let parked_thread = thread::spawn(move || {\n-///     // We want to wait until the flag is set.  We *could* just spin, but using\n+///     // We want to wait until the flag is set. We *could* just spin, but using\n ///     // park/unpark is more efficient.\n ///     while !flag2.load(Ordering::Acquire) {\n ///         println!(\"Parking thread\");"}, {"sha": "c258e3f1a55feec603e6737c3ff2455a9f9f2dda", "filename": "src/libstd/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -33,7 +33,7 @@ pub use core::time::{SECOND, MILLISECOND, MICROSECOND, NANOSECOND};\n /// instant when created, and are often useful for tasks such as measuring\n /// benchmarks or timing how long an operation takes.\n ///\n-/// Note, however, that instants are not guaranteed to be **steady**.  In other\n+/// Note, however, that instants are not guaranteed to be **steady**. In other\n /// words, each tick of the underlying clock may not be the same length (e.g.\n /// some seconds may be longer than others). An instant may jump forwards or\n /// experience time dilation (slow down or speed up), but it will never go"}, {"sha": "182e6cb45be64575b2e684ba20c03b2a5388eeab", "filename": "src/test/incremental/change_add_field/struct_point.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_add_field%2Fstruct_point.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -60,7 +60,7 @@ pub mod point {\n     }\n }\n \n-/// A fn that has the changed type in its signature; must currently be\n+/// A function that has the changed type in its signature; must currently be\n /// rebuilt.\n ///\n /// You could imagine that, in the future, if the change were\n@@ -76,7 +76,7 @@ pub mod fn_with_type_in_sig {\n     }\n }\n \n-/// Call a fn that has the changed type in its signature; this\n+/// Call a function that has the changed type in its signature; this\n /// currently must also be rebuilt.\n ///\n /// You could imagine that, in the future, if the change were\n@@ -92,7 +92,7 @@ pub mod call_fn_with_type_in_sig {\n     }\n }\n \n-/// A fn that uses the changed type, but only in its body, not its\n+/// A function that uses the changed type, but only in its body, not its\n /// signature.\n ///\n /// You could imagine that, in the future, if the change were\n@@ -108,10 +108,10 @@ pub mod fn_with_type_in_body {\n     }\n }\n \n-/// A fn X that calls a fn Y, where Y uses the changed type in its\n+/// A function `X` that calls a function `Y`, where `Y` uses the changed type in its\n /// body. In this case, the effects of the change should be contained\n-/// to Y; X should not have to be rebuilt, nor should it need to be\n-/// typechecked again.\n+/// to `Y`; `X` should not have to be rebuilt, nor should it need to be\n+/// type-checked again.\n pub mod call_fn_with_type_in_body {\n     use fn_with_type_in_body;\n \n@@ -121,7 +121,7 @@ pub mod call_fn_with_type_in_body {\n     }\n }\n \n-/// A fn item that makes an instance of `Point` but does not invoke methods\n+/// A function item that makes an instance of `Point` but does not invoke methods.\n pub mod fn_make_struct {\n     use point::Point;\n \n@@ -131,7 +131,7 @@ pub mod fn_make_struct {\n     }\n }\n \n-/// A fn item that reads fields from `Point` but does not invoke methods\n+/// A function item that reads fields from `Point` but does not invoke methods.\n pub mod fn_read_field {\n     use point::Point;\n \n@@ -141,7 +141,7 @@ pub mod fn_read_field {\n     }\n }\n \n-/// A fn item that writes to a field of `Point` but does not invoke methods\n+/// A function item that writes to a field of `Point` but does not invoke methods.\n pub mod fn_write_field {\n     use point::Point;\n "}, {"sha": "956bc5ad862caf9f8cfcbbecd5efa21863a99700", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -59,8 +59,8 @@ fn make_x() -> P<Expr> {\n     expr(ExprKind::Path(None, path))\n }\n \n-/// Iterate over exprs of depth up to `depth`.  The goal is to explore all \"interesting\"\n-/// combinations of expression nesting.  For example, we explore combinations using `if`, but not\n+/// Iterate over exprs of depth up to `depth`. The goal is to explore all \"interesting\"\n+/// combinations of expression nesting. For example, we explore combinations using `if`, but not\n /// `while` or `match`, since those should print and parse in much the same way as `if`.\n fn iter_exprs(depth: usize, f: &mut FnMut(P<Expr>)) {\n     if depth == 0 {"}, {"sha": "57029f70888b3e5928aafb7ce2d58b441faa1d08", "filename": "src/test/run-pass/auxiliary/svh-b.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fsvh-b.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1,7 +1,7 @@\n-//! This is a client of the `a` crate defined in \"svn-a-base.rs\".  The\n-//! rpass and cfail tests (such as \"run-pass/svh-add-comment.rs\") use\n+//! This is a client of the `a` crate defined in `svn-a-base.rs`. The\n+//! rpass and cfail tests (such as `run-pass/svh-add-comment.rs`) use\n //! it by swapping in a different object code library crate built from\n-//! some variant of \"svn-a-base.rs\", and then we are checking if the\n+//! some variant of `svn-a-base.rs`, and then we are checking if the\n //! compiler properly ignores or accepts the change, based on whether\n //! the change could affect the downstream crate content or not\n //! (#14132)."}, {"sha": "90eba1706956d47315338a9e63bb9781cc3a4fa4", "filename": "src/test/run-pass/issues/issue-7012.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fissues%2Fissue-7012.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fissues%2Fissue-7012.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-7012.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -5,7 +5,7 @@\n /*\n # Comparison of static arrays\n \n-The expected behaviour would be that test==test1, therefore 'true'\n+The expected behaviour would be that `test == test1`, therefore 'true'\n would be printed, however the below prints false.\n */\n "}, {"sha": "e3ed350f29a94f450aa8e488719d590de9bf87a9", "filename": "src/test/run-pass/item-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -163,7 +163,7 @@ mod test_foreign_items {\n }\n \n \n-// FIXME #623 - these aren't supported yet\n+// FIXME(#623): - these aren't supported yet\n /*mod test_literals {\n     #![str = \"s\"]\n     #![char = 'c']"}, {"sha": "a26f324f7dc05af9cd6310ab32be7ffc269f6da3", "filename": "src/test/run-pass/monomorphize-abi-alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonomorphize-abi-alignment.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -2,7 +2,7 @@\n /*!\n  * On x86_64-linux-gnu and possibly other platforms, structs get 8-byte \"preferred\" alignment,\n  * but their \"ABI\" alignment (i.e., what actually matters for data layout) is the largest alignment\n- * of any field.  (Also, u64 has 8-byte ABI alignment; this is not always true).\n+ * of any field. (Also, `u64` has 8-byte ABI alignment; this is not always true).\n  *\n  * On such platforms, if monomorphize uses the \"preferred\" alignment, then it will unify\n  * `A` and `B`, even though `S<A>` and `S<B>` have the field `t` at different offsets,"}, {"sha": "9a01549ecd24eedaa90c9522de55917a6456ec65", "filename": "src/test/run-pass/numbers-arithmetic/num-wrapping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fnumbers-arithmetic%2Fnum-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frun-pass%2Fnumbers-arithmetic%2Fnum-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnumbers-arithmetic%2Fnum-wrapping.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -175,7 +175,7 @@ fn test_op_assigns() {\n                 assert_eq!(black_box(tmp), Wrapping($ans));\n             }\n \n-            // FIXME(30524): Uncomment this test\n+            // FIXME(30524): uncomment this test\n             /*\n             {\n                 let mut tmp = Wrapping($initial);"}, {"sha": "ed1da253a97329a68a390c5073478211b23599fb", "filename": "src/test/rustdoc/auxiliary/enum_primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frustdoc%2Fauxiliary%2Fenum_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frustdoc%2Fauxiliary%2Fenum_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fauxiliary%2Fenum_primitive.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -22,7 +22,7 @@\n //! This crate exports a macro `enum_from_primitive!` that wraps an\n //! `enum` declaration and automatically adds an implementation of\n //! `num::FromPrimitive` (reexported here), to allow conversion from\n-//! primitive integers to the enum.  It therefore provides an\n+//! primitive integers to the enum. It therefore provides an\n //! alternative to the built-in `#[derive(FromPrimitive)]`, which\n //! requires the unstable `std::num::FromPrimitive` and is disabled in\n //! Rust 1.0."}, {"sha": "77522f1be230785b1e084b931940e0b452f4ad3f", "filename": "src/test/rustdoc/issue-27862.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frustdoc%2Fissue-27862.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Frustdoc%2Fissue-27862.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-27862.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1,4 +1,4 @@\n-/// Test  | Table\n+/// Tests  | Table\n /// ------|-------------\n /// t = b | id = \\|x\\| x\n pub struct Foo; // @has issue_27862/struct.Foo.html //td 'id = |x| x'"}, {"sha": "c33f2ac96ba621f86f92fec3cefb9957176d1402", "filename": "src/test/ui/associated-types/associated-types-coherence-failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-coherence-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-coherence-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-coherence-failure.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -41,7 +41,7 @@ impl ToOwned for u8 {\n pub trait ToOwned {\n     type Owned;\n \n-    /// Create owned data from borrowed data, usually by copying.\n+    /// Creates owned data from borrowed data, usually by copying.\n     fn to_owned(&self) -> Self::Owned;\n }\n "}, {"sha": "e504b4705daf286dd7a0396cf2181341c25b1501", "filename": "src/test/ui/issues/issue-20797.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fissues%2Fissue-20797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fissues%2Fissue-20797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20797.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -17,7 +17,7 @@ impl PathExtensions for PathBuf {}\n /// A strategy for acquiring more subpaths to walk.\n pub trait Strategy {\n     type P: PathExtensions;\n-    /// Get additional subpaths from a given path.\n+    /// Gets additional subpaths from a given path.\n     fn get_more(&self, item: &Self::P) -> io::Result<Vec<Self::P>>;\n     /// Determine whether a path should be walked further.\n     /// This is run against each item from `get_more()`.\n@@ -44,15 +44,15 @@ pub struct Subpaths<S: Strategy> {\n }\n \n impl<S: Strategy> Subpaths<S> {\n-    /// Create a directory walker with a root path and strategy.\n+    /// Creates a directory walker with a root path and strategy.\n     pub fn new(p: &S::P, strategy: S) -> io::Result<Subpaths<S>> {\n         let stack = strategy.get_more(p)?;\n         Ok(Subpaths { stack: stack, strategy: strategy })\n     }\n }\n \n impl<S: Default + Strategy> Subpaths<S> {\n-    /// Create a directory walker with a root path and a default strategy.\n+    /// Creates a directory walker with a root path and a default strategy.\n     pub fn walk(p: &S::P) -> io::Result<Subpaths<S>> {\n         Subpaths::new(p, Default::default())\n     }"}, {"sha": "7d76f9a99be7bd4beb281e34a224094aa29bb9a1", "filename": "src/test/ui/issues/issue-48636.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fissues%2Fissue-48636.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fissues%2Fissue-48636.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-48636.fixed?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -4,7 +4,7 @@\n \n struct S {\n     x: u8,\n-    /// The id of the parent core\n+    /// The ID of the parent core\n     y: u8,\n }\n //~^^^ ERROR found a documentation comment that doesn't document anything"}, {"sha": "371c0ef6732f4a140834116dbd6c7311d3606893", "filename": "src/test/ui/issues/issue-48636.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fissues%2Fissue-48636.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fissues%2Fissue-48636.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-48636.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -4,7 +4,7 @@\n \n struct S {\n     x: u8\n-    /// The id of the parent core\n+    /// The ID of the parent core\n     y: u8,\n }\n //~^^^ ERROR found a documentation comment that doesn't document anything"}, {"sha": "c96cfdf3cd164527d8c8654e6352898ec95a85c9", "filename": "src/test/ui/issues/issue-52126-assign-op-invariance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52126-assign-op-invariance.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -27,7 +27,7 @@ impl<'l> AddAssign for Counter<'l>\n     }\n }\n \n-/// often times crashes, if not prints invalid strings\n+/// Often crashes, if not prints invalid strings.\n pub fn panics() {\n     let mut acc = Counter{map: HashMap::new()};\n     for line in vec![\"123456789\".to_string(), \"12345678\".to_string()] {"}, {"sha": "d7686b9dc9411479d00e658d6a7c1ddf85fb55c2", "filename": "src/test/ui/nll/user-annotations/issue-55241.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fissue-55241.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -18,7 +18,7 @@ pub trait NodeCodec<H: Hasher> {\n }\n \n pub trait Trie<H: Hasher, C: NodeCodec<H>> {\n-    /// Return the root of the trie.\n+    /// Returns the root of the trie.\n     fn root(&self) -> &H::Out;\n \n     /// Is the trie empty?"}, {"sha": "846db63024cfb3415d19eb4db3c3ba5dc86ba6d7", "filename": "src/test/ui/on-unimplemented/bad-annotation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fbad-annotation.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -10,7 +10,7 @@ trait Foo<Bar, Baz, Quux>\n \n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]\n trait MyFromIterator<A> {\n-    /// Build a container with elements from an external iterator.\n+    /// Builds a container with elements from an external iterator.\n     fn my_from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n "}, {"sha": "109cb5ba969428b8a519f46d4b2b6ea50e322346", "filename": "src/test/ui/on-unimplemented/on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-trait.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -15,7 +15,7 @@ fn foobar<U: Clone, T: Foo<u8, U, u32>>() -> T {\n \n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be built from an iterator over elements of type `{A}`\"]\n trait MyFromIterator<A> {\n-    /// Build a container with elements from an external iterator.\n+    /// Builds a container with elements from an external iterator.\n     fn my_from_iter<T: Iterator<Item=A>>(iterator: T) -> Self;\n }\n "}, {"sha": "57029f70888b3e5928aafb7ce2d58b441faa1d08", "filename": "src/test/ui/svh/auxiliary/svh-b.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fsvh%2Fauxiliary%2Fsvh-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b87363e7632b3f20f9b529696ffb5d5d9c3927cd/src%2Ftest%2Fui%2Fsvh%2Fauxiliary%2Fsvh-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsvh%2Fauxiliary%2Fsvh-b.rs?ref=b87363e7632b3f20f9b529696ffb5d5d9c3927cd", "patch": "@@ -1,7 +1,7 @@\n-//! This is a client of the `a` crate defined in \"svn-a-base.rs\".  The\n-//! rpass and cfail tests (such as \"run-pass/svh-add-comment.rs\") use\n+//! This is a client of the `a` crate defined in `svn-a-base.rs`. The\n+//! rpass and cfail tests (such as `run-pass/svh-add-comment.rs`) use\n //! it by swapping in a different object code library crate built from\n-//! some variant of \"svn-a-base.rs\", and then we are checking if the\n+//! some variant of `svn-a-base.rs`, and then we are checking if the\n //! compiler properly ignores or accepts the change, based on whether\n //! the change could affect the downstream crate content or not\n //! (#14132)."}]}