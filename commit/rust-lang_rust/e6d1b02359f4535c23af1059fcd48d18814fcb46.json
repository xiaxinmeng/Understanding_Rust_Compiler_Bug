{"sha": "e6d1b02359f4535c23af1059fcd48d18814fcb46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZDFiMDIzNTlmNDUzNWMyM2FmMTA1OWZjZDQ4ZDE4ODE0ZmNiNDY=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-13T22:18:47Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-14T22:59:32Z"}, "message": "Rename core::comm to core::oldcomm", "tree": {"sha": "a5d3e67cec5ac687551d17f2d8b7fba4edc6eb7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5d3e67cec5ac687551d17f2d8b7fba4edc6eb7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6d1b02359f4535c23af1059fcd48d18814fcb46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d1b02359f4535c23af1059fcd48d18814fcb46", "html_url": "https://github.com/rust-lang/rust/commit/e6d1b02359f4535c23af1059fcd48d18814fcb46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6d1b02359f4535c23af1059fcd48d18814fcb46/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80ef7243ea6e49b24a26185d198839b686419714", "url": "https://api.github.com/repos/rust-lang/rust/commits/80ef7243ea6e49b24a26185d198839b686419714", "html_url": "https://github.com/rust-lang/rust/commit/80ef7243ea6e49b24a26185d198839b686419714"}], "stats": {"total": 1431, "additions": 712, "deletions": 719}, "files": [{"sha": "70d6e0898c73ef5514adaec359cbaa48c2c706b5", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -139,7 +139,7 @@ pub mod send_map;\n \n /* Tasks and communication */\n \n-pub mod comm;\n+pub mod oldcomm;\n #[path = \"task/mod.rs\"]\n pub mod task;\n pub mod pipes;"}, {"sha": "a5b0336ab60d943c46303c98dff18aef75cf8c8c", "filename": "src/libcore/oldcomm.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Foldcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Foldcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foldcomm.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -144,7 +144,7 @@ fn PortPtr<T: Owned>(po: *rust_port) -> PortPtr<T> {\n  * Fails if the port is detached or dead. Fails if the port\n  * is owned by a different task.\n  */\n-fn as_raw_port<T: Owned, U>(ch: comm::Chan<T>, f: fn(*rust_port) -> U) -> U {\n+fn as_raw_port<T: Owned, U>(ch: Chan<T>, f: fn(*rust_port) -> U) -> U {\n \n     struct PortRef {\n         p: *rust_port,\n@@ -205,11 +205,11 @@ pub fn recv<T: Owned>(p: Port<T>) -> T { recv_((**p).po) }\n pub fn peek<T: Owned>(p: Port<T>) -> bool { peek_((**p).po) }\n \n #[doc(hidden)]\n-pub fn recv_chan<T: Owned>(ch: comm::Chan<T>) -> T {\n+pub fn recv_chan<T: Owned>(ch: Chan<T>) -> T {\n     as_raw_port(ch, |x|recv_(x))\n }\n \n-fn peek_chan<T: Owned>(ch: comm::Chan<T>) -> bool {\n+fn peek_chan<T: Owned>(ch: Chan<T>) -> bool {\n     as_raw_port(ch, |x|peek_(x))\n }\n ", "previous_filename": "src/libcore/comm.rs"}, {"sha": "b5e0983a420d1142f51322b0281ec28f377cbe4e", "filename": "src/libcore/os.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -133,36 +133,36 @@ mod global_env {\n     }\n \n     enum Msg {\n-        MsgGetEnv(~str, comm::Chan<Option<~str>>),\n-        MsgSetEnv(~str, ~str, comm::Chan<()>),\n-        MsgEnv(comm::Chan<~[(~str,~str)]>)\n+        MsgGetEnv(~str, oldcomm::Chan<Option<~str>>),\n+        MsgSetEnv(~str, ~str, oldcomm::Chan<()>),\n+        MsgEnv(oldcomm::Chan<~[(~str,~str)]>)\n     }\n \n     pub fn getenv(n: &str) -> Option<~str> {\n         let env_ch = get_global_env_chan();\n-        let po = comm::Port();\n-        comm::send(env_ch, MsgGetEnv(str::from_slice(n),\n-                                     comm::Chan(&po)));\n-        comm::recv(po)\n+        let po = oldcomm::Port();\n+        oldcomm::send(env_ch, MsgGetEnv(str::from_slice(n),\n+                                     oldcomm::Chan(&po)));\n+        oldcomm::recv(po)\n     }\n \n     pub fn setenv(n: &str, v: &str) {\n         let env_ch = get_global_env_chan();\n-        let po = comm::Port();\n-        comm::send(env_ch, MsgSetEnv(str::from_slice(n),\n+        let po = oldcomm::Port();\n+        oldcomm::send(env_ch, MsgSetEnv(str::from_slice(n),\n                                      str::from_slice(v),\n-                                     comm::Chan(&po)));\n-        comm::recv(po)\n+                                     oldcomm::Chan(&po)));\n+        oldcomm::recv(po)\n     }\n \n     pub fn env() -> ~[(~str,~str)] {\n         let env_ch = get_global_env_chan();\n-        let po = comm::Port();\n-        comm::send(env_ch, MsgEnv(comm::Chan(&po)));\n-        comm::recv(po)\n+        let po = oldcomm::Port();\n+        oldcomm::send(env_ch, MsgEnv(oldcomm::Chan(&po)));\n+        oldcomm::recv(po)\n     }\n \n-    fn get_global_env_chan() -> comm::Chan<Msg> {\n+    fn get_global_env_chan() -> oldcomm::Chan<Msg> {\n         let global_ptr = rustrt::rust_global_env_chan_ptr();\n         unsafe {\n             private::chan_from_global_ptr(global_ptr, || {\n@@ -173,19 +173,19 @@ mod global_env {\n         }\n     }\n \n-    fn global_env_task(msg_po: comm::Port<Msg>) {\n+    fn global_env_task(msg_po: oldcomm::Port<Msg>) {\n         unsafe {\n             do private::weaken_task |weak_po| {\n                 loop {\n-                    match comm::select2(msg_po, weak_po) {\n+                    match oldcomm::select2(msg_po, weak_po) {\n                       either::Left(MsgGetEnv(ref n, resp_ch)) => {\n-                        comm::send(resp_ch, impl_::getenv(*n))\n+                        oldcomm::send(resp_ch, impl_::getenv(*n))\n                       }\n                       either::Left(MsgSetEnv(ref n, ref v, resp_ch)) => {\n-                        comm::send(resp_ch, impl_::setenv(*n, *v))\n+                        oldcomm::send(resp_ch, impl_::setenv(*n, *v))\n                       }\n                       either::Left(MsgEnv(resp_ch)) => {\n-                        comm::send(resp_ch, impl_::env())\n+                        oldcomm::send(resp_ch, impl_::env())\n                       }\n                       either::Right(_) => break\n                     }"}, {"sha": "2d597bfb1b5f3271bc026fc17996e75c9d33974b", "filename": "src/libcore/private.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -55,8 +55,8 @@ fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n pub unsafe fn chan_from_global_ptr<T: Owned>(\n     global: GlobalPtr,\n     task_fn: fn() -> task::TaskBuilder,\n-    f: fn~(comm::Port<T>)\n-) -> comm::Chan<T> {\n+    f: fn~(oldcomm::Port<T>)\n+) -> oldcomm::Chan<T> {\n \n     enum Msg {\n         Proceed,\n@@ -74,12 +74,12 @@ pub unsafe fn chan_from_global_ptr<T: Owned>(\n         let (setup2_po, setup2_ch) = pipes::stream();\n \n         // XXX: Ugly type inference hints\n-        let setup1_po: pipes::Port<comm::Chan<T>> = setup1_po;\n+        let setup1_po: pipes::Port<oldcomm::Chan<T>> = setup1_po;\n         let setup2_po: pipes::Port<Msg> = setup2_po;\n \n         do task_fn().spawn |move f, move setup1_ch, move setup2_po| {\n-            let po = comm::Port::<T>();\n-            let ch = comm::Chan(&po);\n+            let po = oldcomm::Port::<T>();\n+            let ch = oldcomm::Chan(&po);\n             setup1_ch.send(ch);\n \n             // Wait to hear if we are the official instance of\n@@ -130,29 +130,29 @@ pub fn test_from_global_chan1() {\n     // Create the global channel, attached to a new task\n     let ch = unsafe {\n         do chan_from_global_ptr(globchanp, task::task) |po| {\n-            let ch = comm::recv(po);\n-            comm::send(ch, true);\n-            let ch = comm::recv(po);\n-            comm::send(ch, true);\n+            let ch = oldcomm::recv(po);\n+            oldcomm::send(ch, true);\n+            let ch = oldcomm::recv(po);\n+            oldcomm::send(ch, true);\n         }\n     };\n     // Talk to it\n-    let po = comm::Port();\n-    comm::send(ch, comm::Chan(&po));\n-    assert comm::recv(po) == true;\n+    let po = oldcomm::Port();\n+    oldcomm::send(ch, oldcomm::Chan(&po));\n+    assert oldcomm::recv(po) == true;\n \n     // This one just reuses the previous channel\n     let ch = unsafe {\n         do chan_from_global_ptr(globchanp, task::task) |po| {\n-            let ch = comm::recv(po);\n-            comm::send(ch, false);\n+            let ch = oldcomm::recv(po);\n+            oldcomm::send(ch, false);\n         }\n     };\n \n     // Talk to the original global task\n-    let po = comm::Port();\n-    comm::send(ch, comm::Chan(&po));\n-    assert comm::recv(po) == true;\n+    let po = oldcomm::Port();\n+    oldcomm::send(ch, oldcomm::Chan(&po));\n+    assert oldcomm::recv(po) == true;\n }\n \n #[test]\n@@ -163,8 +163,8 @@ pub fn test_from_global_chan2() {\n         let globchan = 0;\n         let globchanp = ptr::addr_of(&globchan);\n \n-        let resultpo = comm::Port();\n-        let resultch = comm::Chan(&resultpo);\n+        let resultpo = oldcomm::Port();\n+        let resultch = oldcomm::Chan(&resultpo);\n \n         // Spawn a bunch of tasks that all want to compete to\n         // create the global channel\n@@ -175,23 +175,23 @@ pub fn test_from_global_chan2() {\n                         globchanp, task::task) |po| {\n \n                         for uint::range(0, 10) |_j| {\n-                            let ch = comm::recv(po);\n-                            comm::send(ch, {i});\n+                            let ch = oldcomm::recv(po);\n+                            oldcomm::send(ch, {i});\n                         }\n                     }\n                 };\n-                let po = comm::Port();\n-                comm::send(ch, comm::Chan(&po));\n+                let po = oldcomm::Port();\n+                oldcomm::send(ch, oldcomm::Chan(&po));\n                 // We are The winner if our version of the\n                 // task was installed\n-                let winner = comm::recv(po);\n-                comm::send(resultch, winner == i);\n+                let winner = oldcomm::recv(po);\n+                oldcomm::send(resultch, winner == i);\n             }\n         }\n         // There should be only one winner\n         let mut winners = 0u;\n         for uint::range(0u, 10u) |_i| {\n-            let res = comm::recv(resultpo);\n+            let res = oldcomm::recv(resultpo);\n             if res { winners += 1u };\n         }\n         assert winners == 1u;\n@@ -217,23 +217,23 @@ pub fn test_from_global_chan2() {\n  * * Weak tasks must not be supervised. A supervised task keeps\n  *   a reference to its parent, so the parent will not die.\n  */\n-pub unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+pub unsafe fn weaken_task(f: fn(oldcomm::Port<()>)) {\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n     unsafe {\n         rustrt::rust_task_weaken(cast::reinterpret_cast(&ch));\n     }\n     let _unweaken = Unweaken(ch);\n     f(po);\n \n     struct Unweaken {\n-      ch: comm::Chan<()>,\n+      ch: oldcomm::Chan<()>,\n       drop unsafe {\n         rustrt::rust_task_unweaken(cast::reinterpret_cast(&self.ch));\n       }\n     }\n \n-    fn Unweaken(ch: comm::Chan<()>) -> Unweaken {\n+    fn Unweaken(ch: oldcomm::Chan<()>) -> Unweaken {\n         Unweaken {\n             ch: ch\n         }\n@@ -255,7 +255,7 @@ pub fn test_weaken_task_wait() {\n     do task::spawn_unlinked {\n         unsafe {\n             do weaken_task |po| {\n-                comm::recv(po);\n+                oldcomm::recv(po);\n             }\n         }\n     }\n@@ -275,7 +275,7 @@ pub fn test_weaken_task_stress() {\n             unsafe {\n                 do weaken_task |po| {\n                     // Wait for it to tell us to die\n-                    comm::recv(po);\n+                    oldcomm::recv(po);\n                 }\n             }\n         }"}, {"sha": "3af854236e1fa2a26aeaa53b178259fe9b96877a", "filename": "src/libcore/run.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -307,22 +307,22 @@ pub fn program_output(prog: &str, args: &[~str]) ->\n     // in parallel so we don't deadlock while blocking on one\n     // or the other. FIXME (#2625): Surely there's a much more\n     // clever way to do this.\n-    let p = comm::Port();\n-    let ch = comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let ch = oldcomm::Chan(&p);\n     do task::spawn_sched(task::SingleThreaded) {\n         let errput = readclose(pipe_err.in);\n-        comm::send(ch, (2, move errput));\n+        oldcomm::send(ch, (2, move errput));\n     };\n     do task::spawn_sched(task::SingleThreaded) {\n         let output = readclose(pipe_out.in);\n-        comm::send(ch, (1, move output));\n+        oldcomm::send(ch, (1, move output));\n     };\n     let status = run::waitpid(pid);\n     let mut errs = ~\"\";\n     let mut outs = ~\"\";\n     let mut count = 2;\n     while count > 0 {\n-        let stream = comm::recv(p);\n+        let stream = oldcomm::recv(p);\n         match stream {\n             (1, copy s) => {\n                 outs = move s;"}, {"sha": "3cd12a5ba66ed009dce230bc276659cc8d3f09a2", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -447,18 +447,18 @@ impl TaskBuilder {\n      * Fails if a future_result was already set for this task.\n      */\n     fn try<T: Owned>(f: fn~() -> T) -> Result<T,()> {\n-        let po = comm::Port();\n-        let ch = comm::Chan(&po);\n+        let po = oldcomm::Port();\n+        let ch = oldcomm::Chan(&po);\n         let mut result = None;\n \n         let fr_task_builder = self.future_result(|+r| {\n             result = Some(move r);\n         });\n         do fr_task_builder.spawn |move f| {\n-            comm::send(ch, f());\n+            oldcomm::send(ch, f());\n         }\n         match option::unwrap(move result).recv() {\n-            Success => result::Ok(comm::recv(po)),\n+            Success => result::Ok(oldcomm::recv(po)),\n             Failure => result::Err(())\n         }\n     }\n@@ -679,17 +679,17 @@ fn test_cant_dup_task_builder() {\n \n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n     do spawn_unlinked {\n         do spawn_unlinked {\n             // Give middle task a chance to fail-but-not-kill-us.\n             for iter::repeat(16) { task::yield(); }\n-            comm::send(ch, ()); // If killed first, grandparent hangs.\n+            oldcomm::send(ch, ()); // If killed first, grandparent hangs.\n         }\n         fail; // Shouldn't kill either (grand)parent or (grand)child.\n     }\n-    comm::recv(po);\n+    oldcomm::recv(po);\n }\n #[test] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n@@ -709,8 +709,8 @@ fn test_spawn_unlinked_sup_fail_down() {\n \n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n-    let po = comm::Port::<()>();\n-    let _ch = comm::Chan(&po);\n+    let po = oldcomm::Port::<()>();\n+    let _ch = oldcomm::Chan(&po);\n     // Unidirectional \"parenting\" shouldn't override bidirectional linked.\n     // We have to cheat with opts - the interface doesn't support them because\n     // they don't make sense (redundant with task().supervised()).\n@@ -728,7 +728,7 @@ fn test_spawn_linked_sup_fail_up() { // child fails; parent fails\n         .. b0\n     };\n     do b1.spawn { fail; }\n-    comm::recv(po); // We should get punted awake\n+    oldcomm::recv(po); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n@@ -752,11 +752,11 @@ fn test_spawn_linked_sup_fail_down() { // parent fails; child fails\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_up() { // child fails; parent fails\n-    let po = comm::Port::<()>();\n-    let _ch = comm::Chan(&po);\n+    let po = oldcomm::Port::<()>();\n+    let _ch = oldcomm::Chan(&po);\n     // Default options are to spawn linked & unsupervised.\n     do spawn { fail; }\n-    comm::recv(po); // We should get punted awake\n+    oldcomm::recv(po); // We should get punted awake\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_linked_unsup_fail_down() { // parent fails; child fails\n@@ -824,27 +824,27 @@ fn test_spawn_linked_sup_propagate_sibling() {\n \n #[test]\n fn test_run_basic() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n     do task().spawn {\n-        comm::send(ch, ());\n+        oldcomm::send(ch, ());\n     }\n-    comm::recv(po);\n+    oldcomm::recv(po);\n }\n \n #[test]\n fn test_add_wrapper() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n     let b0 = task();\n     let b1 = do b0.add_wrapper |body| {\n         fn~(move body) {\n             body();\n-            comm::send(ch, ());\n+            oldcomm::send(ch, ());\n         }\n     };\n     do b1.spawn { }\n-    comm::recv(po);\n+    oldcomm::recv(po);\n }\n \n #[test]\n@@ -897,44 +897,44 @@ fn test_spawn_sched_no_threads() {\n \n #[test]\n fn test_spawn_sched() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n \n-    fn f(i: int, ch: comm::Chan<()>) {\n+    fn f(i: int, ch: oldcomm::Chan<()>) {\n         let parent_sched_id = rt::rust_get_sched_id();\n \n         do spawn_sched(SingleThreaded) {\n             let child_sched_id = rt::rust_get_sched_id();\n             assert parent_sched_id != child_sched_id;\n \n             if (i == 0) {\n-                comm::send(ch, ());\n+                oldcomm::send(ch, ());\n             } else {\n                 f(i - 1, ch);\n             }\n         };\n \n     }\n     f(10, ch);\n-    comm::recv(po);\n+    oldcomm::recv(po);\n }\n \n #[test]\n fn test_spawn_sched_childs_on_same_sched() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n \n     do spawn_sched(SingleThreaded) {\n         let parent_sched_id = rt::rust_get_sched_id();\n         do spawn {\n             let child_sched_id = rt::rust_get_sched_id();\n             // This should be on the same scheduler\n             assert parent_sched_id == child_sched_id;\n-            comm::send(ch, ());\n+            oldcomm::send(ch, ());\n         };\n     };\n \n-    comm::recv(po);\n+    oldcomm::recv(po);\n }\n \n #[nolink]\n@@ -955,71 +955,71 @@ fn test_spawn_sched_blocking() {\n     // without affecting other schedulers\n     for iter::repeat(20u) {\n \n-        let start_po = comm::Port();\n-        let start_ch = comm::Chan(&start_po);\n-        let fin_po = comm::Port();\n-        let fin_ch = comm::Chan(&fin_po);\n+        let start_po = oldcomm::Port();\n+        let start_ch = oldcomm::Chan(&start_po);\n+        let fin_po = oldcomm::Port();\n+        let fin_ch = oldcomm::Chan(&fin_po);\n \n         let lock = testrt::rust_dbg_lock_create();\n \n         do spawn_sched(SingleThreaded) {\n             testrt::rust_dbg_lock_lock(lock);\n \n-            comm::send(start_ch, ());\n+            oldcomm::send(start_ch, ());\n \n             // Block the scheduler thread\n             testrt::rust_dbg_lock_wait(lock);\n             testrt::rust_dbg_lock_unlock(lock);\n \n-            comm::send(fin_ch, ());\n+            oldcomm::send(fin_ch, ());\n         };\n \n         // Wait until the other task has its lock\n-        comm::recv(start_po);\n+        oldcomm::recv(start_po);\n \n-        fn pingpong(po: comm::Port<int>, ch: comm::Chan<int>) {\n+        fn pingpong(po: oldcomm::Port<int>, ch: oldcomm::Chan<int>) {\n             let mut val = 20;\n             while val > 0 {\n-                val = comm::recv(po);\n-                comm::send(ch, val - 1);\n+                val = oldcomm::recv(po);\n+                oldcomm::send(ch, val - 1);\n             }\n         }\n \n-        let setup_po = comm::Port();\n-        let setup_ch = comm::Chan(&setup_po);\n-        let parent_po = comm::Port();\n-        let parent_ch = comm::Chan(&parent_po);\n+        let setup_po = oldcomm::Port();\n+        let setup_ch = oldcomm::Chan(&setup_po);\n+        let parent_po = oldcomm::Port();\n+        let parent_ch = oldcomm::Chan(&parent_po);\n         do spawn {\n-            let child_po = comm::Port();\n-            comm::send(setup_ch, comm::Chan(&child_po));\n+            let child_po = oldcomm::Port();\n+            oldcomm::send(setup_ch, oldcomm::Chan(&child_po));\n             pingpong(child_po, parent_ch);\n         };\n \n-        let child_ch = comm::recv(setup_po);\n-        comm::send(child_ch, 20);\n+        let child_ch = oldcomm::recv(setup_po);\n+        oldcomm::send(child_ch, 20);\n         pingpong(parent_po, child_ch);\n         testrt::rust_dbg_lock_lock(lock);\n         testrt::rust_dbg_lock_signal(lock);\n         testrt::rust_dbg_lock_unlock(lock);\n-        comm::recv(fin_po);\n+        oldcomm::recv(fin_po);\n         testrt::rust_dbg_lock_destroy(lock);\n     }\n }\n \n #[cfg(test)]\n fn avoid_copying_the_body(spawnfn: fn(v: fn~())) {\n-    let p = comm::Port::<uint>();\n-    let ch = comm::Chan(&p);\n+    let p = oldcomm::Port::<uint>();\n+    let ch = oldcomm::Chan(&p);\n \n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;\n \n     do spawnfn |move x| {\n         let x_in_child = ptr::addr_of(&(*x)) as uint;\n-        comm::send(ch, x_in_child);\n+        oldcomm::send(ch, x_in_child);\n     }\n \n-    let x_in_child = comm::recv(p);\n+    let x_in_child = oldcomm::recv(p);\n     assert x_in_parent == x_in_child;\n }\n \n@@ -1057,19 +1057,19 @@ fn test_avoid_copying_the_body_unlinked() {\n \n #[test]\n fn test_platform_thread() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n     do task().sched_mode(PlatformThread).spawn {\n-        comm::send(ch, ());\n+        oldcomm::send(ch, ());\n     }\n-    comm::recv(po);\n+    oldcomm::recv(po);\n }\n \n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n fn test_unkillable() {\n-    let po = comm::Port();\n+    let po = oldcomm::Port();\n     let ch = po.chan();\n \n     // We want to do this after failing"}, {"sha": "77acf3967e8e02565d566f6db0090f94b9dbbb74", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -646,12 +646,12 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n \n #[test]\n fn test_spawn_raw_simple() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n     do spawn_raw(default_task_opts()) {\n-        comm::send(ch, ());\n+        oldcomm::send(ch, ());\n     }\n-    comm::recv(po);\n+    oldcomm::recv(po);\n }\n \n #[test]"}, {"sha": "c934b09a7c47b253dede4f9722e97862bd469ec5", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -434,8 +434,8 @@ fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n fn monitor(+f: fn~(diagnostic::emitter)) {\n-    let p = comm::Port();\n-    let ch = comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let ch = oldcomm::Chan(&p);\n \n     match do task::try |move f| {\n \n@@ -444,14 +444,14 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n         let demitter = fn@(cmsp: Option<(@codemap::CodeMap, codemap::span)>,\n                            msg: &str, lvl: diagnostic::level) {\n             if lvl == diagnostic::fatal {\n-                comm::send(ch, fatal);\n+                oldcomm::send(ch, fatal);\n             }\n             diagnostic::emit(cmsp, msg, lvl);\n         };\n \n         struct finally {\n-            ch: comm::Chan<monitor_msg>,\n-            drop { comm::send(self.ch, done); }\n+            ch: oldcomm::Chan<monitor_msg>,\n+            drop { oldcomm::send(self.ch, done); }\n         }\n \n         let _finally = finally { ch: ch };\n@@ -461,7 +461,7 @@ fn monitor(+f: fn~(diagnostic::emitter)) {\n         result::Ok(_) => { /* fallthrough */ }\n         result::Err(_) => {\n             // Task failed without emitting a fatal diagnostic\n-            if comm::recv(p) == done {\n+            if oldcomm::recv(p) == done {\n                 diagnostic::emit(\n                     None,\n                     diagnostic::ice_msg(~\"unexpected failure\"),"}, {"sha": "14b7b52e4d360bd2fdff928f7b98ec484d7663a5", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -46,7 +46,7 @@ enum Msg {\n }\n \n pub enum Srv = {\n-    ch: comm::Chan<Msg>\n+    ch: oldcomm::Chan<Msg>\n };\n \n impl Srv: Clone {\n@@ -70,11 +70,11 @@ fn run<T>(owner: SrvOwner<T>, source: ~str, +parse: Parser) -> T {\n     });\n \n     let res = owner(srv_);\n-    comm::send(srv_.ch, Exit);\n+    oldcomm::send(srv_.ch, Exit);\n     move res\n }\n \n-fn act(po: comm::Port<Msg>, source: ~str, parse: Parser) {\n+fn act(po: oldcomm::Port<Msg>, source: ~str, parse: Parser) {\n     let sess = build_session();\n \n     let ctxt = build_ctxt(\n@@ -84,7 +84,7 @@ fn act(po: comm::Port<Msg>, source: ~str, parse: Parser) {\n \n     let mut keep_going = true;\n     while keep_going {\n-        match comm::recv(po) {\n+        match oldcomm::recv(po) {\n           HandleRequest(f) => {\n             f(ctxt);\n           }\n@@ -99,13 +99,13 @@ pub fn exec<T:Owned>(\n     srv: Srv,\n     +f: fn~(ctxt: Ctxt) -> T\n ) -> T {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n     let msg = HandleRequest(fn~(move f, ctxt: Ctxt) {\n-        comm::send(ch, f(ctxt))\n+        oldcomm::send(ch, f(ctxt))\n     });\n-    comm::send(srv.ch, move msg);\n-    comm::recv(po)\n+    oldcomm::send(srv.ch, move msg);\n+    oldcomm::recv(po)\n }\n \n fn build_ctxt(sess: Session,"}, {"sha": "3328cdd527a86d3422a65a430ee4bcef33151504", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -129,7 +129,7 @@ fn should_request_new_writer_for_each_page() {\n     write_markdown(doc, move writer_factory);\n     // We expect two pages to have been written\n     for iter::repeat(2) {\n-        comm::recv(po);\n+        oldcomm::recv(po);\n     }\n }\n \n@@ -160,7 +160,7 @@ fn should_write_title_for_each_page() {\n     let doc = (page_pass::mk_pass(config::DocPerMod).f)(srv, doc);\n     write_markdown(doc, move writer_factory);\n     for iter::repeat(2) {\n-        let (page, markdown) = comm::recv(po);\n+        let (page, markdown) = oldcomm::recv(po);\n         match page {\n           doc::CratePage(_) => {\n             assert str::contains(markdown, ~\"% Crate core\");\n@@ -304,7 +304,7 @@ fn should_write_full_path_to_mod() {\n     assert str::contains(markdown, ~\"# Module `a::b::c`\");\n }\n \n-fn write_common(\n+fn write_oldcommon(\n     ctxt: &Ctxt,\n     +desc: Option<~str>,\n     sections: &[doc::Section]\n@@ -353,7 +353,7 @@ fn write_mod_contents(\n     ctxt: &Ctxt,\n     +doc: doc::ModDoc\n ) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n+    write_oldcommon(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n         write_index(ctxt, doc.index.get());\n     }\n@@ -456,7 +456,7 @@ fn should_write_index_for_foreign_mods() {\n }\n \n fn write_nmod(ctxt: &Ctxt, +doc: doc::NmodDoc) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n+    write_oldcommon(ctxt, doc.desc(), doc.sections());\n     if doc.index.is_some() {\n         write_index(ctxt, doc.index.get());\n     }\n@@ -507,7 +507,7 @@ fn write_fnlike(\n     sections: &[doc::Section]\n ) {\n     write_sig(ctxt, sig);\n-    write_common(ctxt, desc, sections);\n+    write_oldcommon(ctxt, desc, sections);\n }\n \n fn write_sig(ctxt: &Ctxt, +sig: Option<~str>) {\n@@ -576,7 +576,7 @@ fn write_const(\n     +doc: doc::ConstDoc\n ) {\n     write_sig(ctxt, doc.sig);\n-    write_common(ctxt, doc.desc(), doc.sections());\n+    write_oldcommon(ctxt, doc.desc(), doc.sections());\n }\n \n #[test]\n@@ -597,7 +597,7 @@ fn write_enum(\n     ctxt: &Ctxt,\n     +doc: doc::EnumDoc\n ) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n+    write_oldcommon(ctxt, doc.desc(), doc.sections());\n     write_variants(ctxt, doc.variants);\n }\n \n@@ -678,7 +678,7 @@ fn should_write_variant_list_with_signatures() {\n }\n \n fn write_trait(ctxt: &Ctxt, +doc: doc::TraitDoc) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n+    write_oldcommon(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n@@ -726,7 +726,7 @@ fn should_write_trait_method_signature() {\n }\n \n fn write_impl(ctxt: &Ctxt, +doc: doc::ImplDoc) {\n-    write_common(ctxt, doc.desc(), doc.sections());\n+    write_oldcommon(ctxt, doc.desc(), doc.sections());\n     write_methods(ctxt, doc.methods);\n }\n \n@@ -768,7 +768,7 @@ fn write_type(\n     +doc: doc::TyDoc\n ) {\n     write_sig(ctxt, doc.sig);\n-    write_common(ctxt, doc.desc(), doc.sections());\n+    write_oldcommon(ctxt, doc.desc(), doc.sections());\n }\n \n #[test]\n@@ -795,7 +795,7 @@ fn write_struct(\n     +doc: doc::StructDoc\n ) {\n     write_sig(ctxt, doc.sig);\n-    write_common(ctxt, doc.desc(), doc.sections());\n+    write_oldcommon(ctxt, doc.desc(), doc.sections());\n }\n \n #[test]\n@@ -854,7 +854,7 @@ mod test {\n     ) -> ~str {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         write_markdown(doc, move writer_factory);\n-        return comm::recv(po).second();\n+        return oldcomm::recv(po).second();\n     }\n \n     fn write_markdown_str_srv(\n@@ -864,7 +864,7 @@ mod test {\n         let (writer_factory, po) = markdown_writer::future_writer_factory();\n         let pass = mk_pass(move writer_factory);\n         (pass.f)(srv, doc);\n-        return comm::recv(po).second();\n+        return oldcomm::recv(po).second();\n     }\n \n     #[test]"}, {"sha": "9cf404e0533d5ba5546777d1899c24d18a9114b8", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -151,8 +151,8 @@ fn readclose(fd: libc::c_int) -> ~str {\n fn generic_writer(+process: fn~(+markdown: ~str)) -> Writer {\n     let (setup_po, setup_ch) = pipes::stream();\n     do task::spawn |move process, move setup_ch| {\n-        let po: comm::Port<WriteInstr> = comm::Port();\n-        let ch = comm::Chan(&po);\n+        let po: oldcomm::Port<WriteInstr> = oldcomm::Port();\n+        let ch = oldcomm::Chan(&po);\n         setup_ch.send(ch);\n \n         let mut markdown = ~\"\";\n@@ -168,7 +168,7 @@ fn generic_writer(+process: fn~(+markdown: ~str)) -> Writer {\n     let ch = setup_po.recv();\n \n     fn~(+instr: WriteInstr) {\n-        comm::send(ch, instr);\n+        oldcomm::send(ch, instr);\n     }\n }\n \n@@ -275,16 +275,16 @@ fn write_file(path: &Path, +s: ~str) {\n }\n \n pub fn future_writer_factory(\n-) -> (WriterFactory, comm::Port<(doc::Page, ~str)>) {\n-    let markdown_po = comm::Port();\n-    let markdown_ch = comm::Chan(&markdown_po);\n+) -> (WriterFactory, oldcomm::Port<(doc::Page, ~str)>) {\n+    let markdown_po = oldcomm::Port();\n+    let markdown_ch = oldcomm::Chan(&markdown_po);\n     let writer_factory = fn~(+page: doc::Page) -> Writer {\n         let (writer_po, writer_ch) = pipes::stream();\n         do task::spawn |move writer_ch| {\n             let (writer, future) = future_writer();\n             writer_ch.send(move writer);\n             let s = future.get();\n-            comm::send(markdown_ch, (page, s));\n+            oldcomm::send(markdown_ch, (page, s));\n         }\n         writer_po.recv()\n     };"}, {"sha": "af8ac5f1427efcd9af54e583dce4a73c400dcecb", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -41,22 +41,22 @@ fn run(\n \n     let (result_port, page_chan) = do util::spawn_conversation\n         |page_port, result_chan| {\n-        comm::send(result_chan, make_doc_from_pages(page_port));\n+        oldcomm::send(result_chan, make_doc_from_pages(page_port));\n     };\n \n     find_pages(doc, page_chan);\n-    comm::recv(result_port)\n+    oldcomm::recv(result_port)\n }\n \n-type PagePort = comm::Port<Option<doc::Page>>;\n-type PageChan = comm::Chan<Option<doc::Page>>;\n+type PagePort = oldcomm::Port<Option<doc::Page>>;\n+type PageChan = oldcomm::Chan<Option<doc::Page>>;\n \n type NominalPageChan = NominalOp<PageChan>;\n \n fn make_doc_from_pages(page_port: PagePort) -> doc::Doc {\n     let mut pages = ~[];\n     loop {\n-        let val = comm::recv(page_port);\n+        let val = oldcomm::recv(page_port);\n         if val.is_some() {\n             pages += ~[option::unwrap(move val)];\n         } else {\n@@ -77,7 +77,7 @@ fn find_pages(doc: doc::Doc, page_chan: PageChan) {\n     };\n     (fold.fold_doc)(&fold, doc);\n \n-    comm::send(page_chan, None);\n+    oldcomm::send(page_chan, None);\n }\n \n fn fold_crate(\n@@ -92,7 +92,7 @@ fn fold_crate(\n         .. doc\n     });\n \n-    comm::send(fold.ctxt.op, Some(page));\n+    oldcomm::send(fold.ctxt.op, Some(page));\n \n     doc\n }\n@@ -108,7 +108,7 @@ fn fold_mod(\n \n         let doc = strip_mod(doc);\n         let page = doc::ItemPage(doc::ModTag(doc));\n-        comm::send(fold.ctxt.op, Some(page));\n+        oldcomm::send(fold.ctxt.op, Some(page));\n     }\n \n     doc\n@@ -133,7 +133,7 @@ fn fold_nmod(\n ) -> doc::NmodDoc {\n     let doc = fold::default_seq_fold_nmod(fold, doc);\n     let page = doc::ItemPage(doc::NmodTag(doc));\n-    comm::send(fold.ctxt.op, Some(page));\n+    oldcomm::send(fold.ctxt.op, Some(page));\n     return doc;\n }\n "}, {"sha": "ebeb9346d3c499b496f6938903e600d2f0e695ac", "filename": "src/librustdoc/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibrustdoc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Futil.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -18,23 +18,23 @@ impl<T: Copy> NominalOp<T>: Clone {\n }\n \n pub fn spawn_listener<A: Owned>(\n-    +f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n-    let setup_po = comm::Port();\n-    let setup_ch = comm::Chan(&setup_po);\n+    +f: fn~(oldcomm::Port<A>)) -> oldcomm::Chan<A> {\n+    let setup_po = oldcomm::Port();\n+    let setup_ch = oldcomm::Chan(&setup_po);\n     do task::spawn |move f| {\n-        let po = comm::Port();\n-        let ch = comm::Chan(&po);\n-        comm::send(setup_ch, ch);\n+        let po = oldcomm::Port();\n+        let ch = oldcomm::Chan(&po);\n+        oldcomm::send(setup_ch, ch);\n         f(move po);\n     }\n-    comm::recv(setup_po)\n+    oldcomm::recv(setup_po)\n }\n \n pub fn spawn_conversation<A: Owned, B: Owned>\n-    (+f: fn~(comm::Port<A>, comm::Chan<B>))\n-    -> (comm::Port<B>, comm::Chan<A>) {\n-    let from_child = comm::Port();\n-    let to_parent = comm::Chan(&from_child);\n+    (+f: fn~(oldcomm::Port<A>, oldcomm::Chan<B>))\n+    -> (oldcomm::Port<B>, oldcomm::Chan<A>) {\n+    let from_child = oldcomm::Port();\n+    let to_parent = oldcomm::Chan(&from_child);\n     let to_child = do spawn_listener |move f, from_parent| {\n         f(from_parent, to_parent)\n     };"}, {"sha": "1eb970526c36bca3a6c2460159de12b2013bf087", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -30,7 +30,6 @@ use create_uv_getaddrinfo_t = uv::ll::getaddrinfo_t;\n use set_data_for_req = uv::ll::set_data_for_req;\n use get_data_for_req = uv::ll::get_data_for_req;\n use ll = uv::ll;\n-use comm = core::comm;\n \n /// An IP address\n pub enum IpAddr {\n@@ -108,7 +107,7 @@ enum IpGetAddrErr {\n  */\n pub fn get_addr(node: &str, iotask: iotask)\n         -> result::Result<~[IpAddr], IpGetAddrErr> {\n-    do core::comm::listen |output_ch| {\n+    do oldcomm::listen |output_ch| {\n         do str::as_buf(node) |node_ptr, len| unsafe {\n             log(debug, fmt!(\"slice len %?\", len));\n             let handle = create_uv_getaddrinfo_t();\n@@ -268,7 +267,7 @@ pub mod v6 {\n }\n \n type GetAddrData = {\n-    output_ch: comm::Chan<result::Result<~[IpAddr],IpGetAddrErr>>\n+    output_ch: oldcomm::Chan<result::Result<~[IpAddr],IpGetAddrErr>>\n };\n \n extern fn get_addr_cb(handle: *uv_getaddrinfo_t, status: libc::c_int,"}, {"sha": "c94a7fd1125950947f18da3bb2b523f75cc26266", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 110, "deletions": 111, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -19,7 +19,6 @@ use future_spawn = future::spawn;\n use result::{Result};\n use libc::size_t;\n use io::{Reader, ReaderUtil, Writer};\n-use comm = core::comm;\n \n #[nolink]\n extern mod rustrt {\n@@ -133,19 +132,19 @@ pub enum TcpConnectErrData {\n pub fn connect(input_ip: ip::IpAddr, port: uint,\n            iotask: IoTask)\n     -> result::Result<TcpSocket, TcpConnectErrData> unsafe {\n-    let result_po = core::comm::Port::<ConnAttempt>();\n-    let closed_signal_po = core::comm::Port::<()>();\n+    let result_po = oldcomm::Port::<ConnAttempt>();\n+    let closed_signal_po = oldcomm::Port::<()>();\n     let conn_data = {\n-        result_ch: core::comm::Chan(&result_po),\n-        closed_signal_ch: core::comm::Chan(&closed_signal_po)\n+        result_ch: oldcomm::Chan(&result_po),\n+        closed_signal_ch: oldcomm::Chan(&closed_signal_po)\n     };\n     let conn_data_ptr = ptr::addr_of(&conn_data);\n-    let reader_po = core::comm::Port::<result::Result<~[u8], TcpErrData>>();\n+    let reader_po = oldcomm::Port::<result::Result<~[u8], TcpErrData>>();\n     let stream_handle_ptr = malloc_uv_tcp_t();\n     *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n     let socket_data = @{\n         reader_po: reader_po,\n-        reader_ch: core::comm::Chan(&reader_po),\n+        reader_ch: oldcomm::Chan(&reader_po),\n         stream_handle_ptr: stream_handle_ptr,\n         connect_req: uv::ll::connect_t(),\n         write_req: uv::ll::write_t(),\n@@ -217,7 +216,7 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n                 // immediate connect failure.. probably a garbage\n                 // ip or somesuch\n                 let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                core::comm::send((*conn_data_ptr).result_ch,\n+                oldcomm::send((*conn_data_ptr).result_ch,\n                            ConnFailure(err_data.to_tcp_err()));\n                 uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n                                                conn_data_ptr);\n@@ -228,18 +227,18 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n           _ => {\n             // failure to create a tcp handle\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            core::comm::send((*conn_data_ptr).result_ch,\n+            oldcomm::send((*conn_data_ptr).result_ch,\n                        ConnFailure(err_data.to_tcp_err()));\n           }\n         }\n     };\n-    match core::comm::recv(result_po) {\n+    match oldcomm::recv(result_po) {\n       ConnSuccess => {\n         log(debug, ~\"tcp::connect - received success on result_po\");\n         result::Ok(TcpSocket(socket_data))\n       }\n       ConnFailure(ref err_data) => {\n-        core::comm::recv(closed_signal_po);\n+        oldcomm::recv(closed_signal_po);\n         log(debug, ~\"tcp::connect - received failure on result_po\");\n         // still have to free the malloc'd stream handle..\n         rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n@@ -329,7 +328,7 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n  * `tcp_err_data` record\n  */\n pub fn read_start(sock: &TcpSocket)\n-    -> result::Result<comm::Port<\n+    -> result::Result<oldcomm::Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> unsafe {\n     let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n     read_start_common_impl(socket_data)\n@@ -343,7 +342,7 @@ pub fn read_start(sock: &TcpSocket)\n  * * `sock` - a `net::tcp::tcp_socket` that you wish to stop reading on\n  */\n pub fn read_stop(sock: &TcpSocket,\n-             read_port: comm::Port<result::Result<~[u8], TcpErrData>>) ->\n+             read_port: oldcomm::Port<result::Result<~[u8], TcpErrData>>) ->\n     result::Result<(), TcpErrData> unsafe {\n     log(debug, fmt!(\"taking the read_port out of commission %?\", read_port));\n     let socket_data = ptr::addr_of(&(*sock.socket_data));\n@@ -484,13 +483,13 @@ pub fn accept(new_conn: TcpNewConnection)\n       NewTcpConn(server_handle_ptr) => {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n             server_handle_ptr) as *TcpListenFcData;\n-        let reader_po = core::comm::Port();\n+        let reader_po = oldcomm::Port();\n         let iotask = (*server_data_ptr).iotask;\n         let stream_handle_ptr = malloc_uv_tcp_t();\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n         let client_socket_data = @{\n             reader_po: reader_po,\n-            reader_ch: core::comm::Chan(&reader_po),\n+            reader_ch: oldcomm::Chan(&reader_po),\n             stream_handle_ptr : stream_handle_ptr,\n             connect_req : uv::ll::connect_t(),\n             write_req : uv::ll::write_t(),\n@@ -501,8 +500,8 @@ pub fn accept(new_conn: TcpNewConnection)\n         let client_stream_handle_ptr =\n             (*client_socket_data_ptr).stream_handle_ptr;\n \n-        let result_po = core::comm::Port::<Option<TcpErrData>>();\n-        let result_ch = core::comm::Chan(&result_po);\n+        let result_po = oldcomm::Port::<Option<TcpErrData>>();\n+        let result_ch = oldcomm::Chan(&result_po);\n \n         // UNSAFE LIBUV INTERACTION BEGIN\n         // .. normally this happens within the context of\n@@ -524,23 +523,23 @@ pub fn accept(new_conn: TcpNewConnection)\n                 uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n                                                client_socket_data_ptr\n                                                    as *libc::c_void);\n-                core::comm::send(result_ch, None);\n+                oldcomm::send(result_ch, None);\n               }\n               _ => {\n                 log(debug, ~\"failed to accept client conn\");\n-                core::comm::send(result_ch, Some(\n+                oldcomm::send(result_ch, Some(\n                     uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n               }\n             }\n           }\n           _ => {\n             log(debug, ~\"failed to init client stream\");\n-            core::comm::send(result_ch, Some(\n+            oldcomm::send(result_ch, Some(\n                 uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n           }\n         }\n         // UNSAFE LIBUV INTERACTION END\n-        match core::comm::recv(result_po) {\n+        match oldcomm::recv(result_po) {\n           Some(copy err_data) => result::Err(err_data),\n           None => result::Ok(TcpSocket(client_socket_data))\n         }\n@@ -578,9 +577,9 @@ pub fn accept(new_conn: TcpNewConnection)\n  */\n pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n+          on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n           new_connect_cb: fn~(TcpNewConnection,\n-                               comm::Chan<Option<TcpErrData>>))\n+                               oldcomm::Chan<Option<TcpErrData>>))\n     -> result::Result<(), TcpListenErrData> unsafe {\n     do listen_common(move host_ip, port, backlog, iotask,\n                      move on_establish_cb)\n@@ -596,17 +595,17 @@ pub fn listen(host_ip: ip::IpAddr, port: uint, backlog: uint,\n \n fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n           iotask: IoTask,\n-          on_establish_cb: fn~(comm::Chan<Option<TcpErrData>>),\n+          on_establish_cb: fn~(oldcomm::Chan<Option<TcpErrData>>),\n           on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::Result<(), TcpListenErrData> unsafe {\n-    let stream_closed_po = core::comm::Port::<()>();\n-    let kill_po = core::comm::Port::<Option<TcpErrData>>();\n-    let kill_ch = core::comm::Chan(&kill_po);\n+    let stream_closed_po = oldcomm::Port::<()>();\n+    let kill_po = oldcomm::Port::<Option<TcpErrData>>();\n+    let kill_ch = oldcomm::Chan(&kill_po);\n     let server_stream = uv::ll::tcp_t();\n     let server_stream_ptr = ptr::addr_of(&server_stream);\n     let server_data = {\n         server_stream_ptr: server_stream_ptr,\n-        stream_closed_ch: core::comm::Chan(&stream_closed_po),\n+        stream_closed_ch: oldcomm::Chan(&stream_closed_po),\n         kill_ch: kill_ch,\n         on_connect_cb: move on_connect_cb,\n         iotask: iotask,\n@@ -618,7 +617,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n     };\n     let server_data_ptr = ptr::addr_of(&server_data);\n \n-    let setup_result = do core::comm::listen |setup_ch| {\n+    let setup_result = do oldcomm::listen |setup_ch| {\n         // this is to address a compiler warning about\n         // an implicit copy.. it seems that double nested\n         // will defeat a move sigil, as is done to the host_ip\n@@ -652,25 +651,25 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n                     match uv::ll::listen(server_stream_ptr,\n                                        backlog as libc::c_int,\n                                        tcp_lfc_on_connection_cb) {\n-                      0i32 => core::comm::send(setup_ch, None),\n+                      0i32 => oldcomm::send(setup_ch, None),\n                       _ => {\n                         log(debug, ~\"failure to uv_listen()\");\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        core::comm::send(setup_ch, Some(err_data));\n+                        oldcomm::send(setup_ch, Some(err_data));\n                       }\n                     }\n                   }\n                   _ => {\n                     log(debug, ~\"failure to uv_tcp_bind\");\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    core::comm::send(setup_ch, Some(err_data));\n+                    oldcomm::send(setup_ch, Some(err_data));\n                   }\n                 }\n               }\n               _ => {\n                 log(debug, ~\"failure to uv_tcp_init\");\n                 let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                core::comm::send(setup_ch, Some(err_data));\n+                oldcomm::send(setup_ch, Some(err_data));\n               }\n             }\n         };\n@@ -704,7 +703,7 @@ fn listen_common(host_ip: ip::IpAddr, port: uint, backlog: uint,\n       }\n       None => {\n         on_establish_cb(kill_ch);\n-        let kill_result = core::comm::recv(kill_po);\n+        let kill_result = oldcomm::recv(kill_po);\n         do iotask::interact(iotask) |loop_ptr| unsafe {\n             log(debug, fmt!(\"tcp::listen post-kill recv hl interact %?\",\n                             loop_ptr));\n@@ -745,12 +744,12 @@ pub fn socket_buf(sock: TcpSocket) -> TcpSocketBuf {\n \n /// Convenience methods extending `net::tcp::tcp_socket`\n impl TcpSocket {\n-    pub fn read_start() -> result::Result<comm::Port<\n+    pub fn read_start() -> result::Result<oldcomm::Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n         read_start(&self)\n     }\n     pub fn read_stop(read_port:\n-                 comm::Port<result::Result<~[u8], TcpErrData>>) ->\n+                 oldcomm::Port<result::Result<~[u8], TcpErrData>>) ->\n         result::Result<(), TcpErrData> {\n         read_stop(&self, move read_port)\n     }\n@@ -877,8 +876,8 @@ impl TcpSocketBuf: io::Writer {\n // INTERNAL API\n \n fn tear_down_socket_data(socket_data: @TcpSocketData) unsafe {\n-    let closed_po = core::comm::Port::<()>();\n-    let closed_ch = core::comm::Chan(&closed_po);\n+    let closed_po = oldcomm::Port::<()>();\n+    let closed_ch = oldcomm::Chan(&closed_po);\n     let close_data = {\n         closed_ch: closed_ch\n     };\n@@ -891,7 +890,7 @@ fn tear_down_socket_data(socket_data: @TcpSocketData) unsafe {\n                                        close_data_ptr);\n         uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n     };\n-    core::comm::recv(closed_po);\n+    oldcomm::recv(closed_po);\n     //the line below will most likely crash\n     //log(debug, fmt!(\"about to free socket_data at %?\", socket_data));\n     rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n@@ -915,7 +914,7 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n             timer::recv_timeout(\n                iotask, timeout_msecs, result::get(&rs_result))\n         } else {\n-            Some(core::comm::recv(result::get(&rs_result)))\n+            Some(oldcomm::recv(result::get(&rs_result)))\n         };\n         log(debug, ~\"tcp::read after recv_timeout\");\n         match move read_result {\n@@ -941,35 +940,35 @@ fn read_common_impl(socket_data: *TcpSocketData, timeout_msecs: uint)\n fn read_stop_common_impl(socket_data: *TcpSocketData) ->\n     result::Result<(), TcpErrData> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let stop_po = core::comm::Port::<Option<TcpErrData>>();\n-    let stop_ch = core::comm::Chan(&stop_po);\n+    let stop_po = oldcomm::Port::<Option<TcpErrData>>();\n+    let stop_ch = oldcomm::Chan(&stop_po);\n     do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n         log(debug, ~\"in interact cb for tcp::read_stop\");\n         match uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 => {\n             log(debug, ~\"successfully called uv_read_stop\");\n-            core::comm::send(stop_ch, None);\n+            oldcomm::send(stop_ch, None);\n           }\n           _ => {\n             log(debug, ~\"failure in calling uv_read_stop\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            core::comm::send(stop_ch, Some(err_data.to_tcp_err()));\n+            oldcomm::send(stop_ch, Some(err_data.to_tcp_err()));\n           }\n         }\n     };\n-    match core::comm::recv(stop_po) {\n+    match oldcomm::recv(stop_po) {\n       Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n       None => result::Ok(())\n     }\n }\n \n // shared impl for read_start\n fn read_start_common_impl(socket_data: *TcpSocketData)\n-    -> result::Result<comm::Port<\n+    -> result::Result<oldcomm::Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let start_po = core::comm::Port::<Option<uv::ll::uv_err_data>>();\n-    let start_ch = core::comm::Chan(&start_po);\n+    let start_po = oldcomm::Port::<Option<uv::ll::uv_err_data>>();\n+    let start_ch = oldcomm::Chan(&start_po);\n     log(debug, ~\"in tcp::read_start before interact loop\");\n     do iotask::interact((*socket_data).iotask) |loop_ptr| unsafe {\n         log(debug, fmt!(\"in tcp::read_start interact cb %?\", loop_ptr));\n@@ -978,16 +977,16 @@ fn read_start_common_impl(socket_data: *TcpSocketData)\n                                on_tcp_read_cb) {\n           0i32 => {\n             log(debug, ~\"success doing uv_read_start\");\n-            core::comm::send(start_ch, None);\n+            oldcomm::send(start_ch, None);\n           }\n           _ => {\n             log(debug, ~\"error attempting uv_read_start\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            core::comm::send(start_ch, Some(err_data));\n+            oldcomm::send(start_ch, Some(err_data));\n           }\n         }\n     };\n-    match core::comm::recv(start_po) {\n+    match oldcomm::recv(start_po) {\n       Some(ref err_data) => result::Err(err_data.to_tcp_err()),\n       None => result::Ok((*socket_data).reader_po)\n     }\n@@ -1006,9 +1005,9 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n         vec::raw::to_ptr(raw_write_data),\n         vec::len(raw_write_data)) ];\n     let write_buf_vec_ptr = ptr::addr_of(&write_buf_vec);\n-    let result_po = core::comm::Port::<TcpWriteResult>();\n+    let result_po = oldcomm::Port::<TcpWriteResult>();\n     let write_data = {\n-        result_ch: core::comm::Chan(&result_po)\n+        result_ch: oldcomm::Chan(&result_po)\n     };\n     let write_data_ptr = ptr::addr_of(&write_data);\n     do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| unsafe {\n@@ -1024,7 +1023,7 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n           _ => {\n             log(debug, ~\"error invoking uv_write()\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            core::comm::send((*write_data_ptr).result_ch,\n+            oldcomm::send((*write_data_ptr).result_ch,\n                        TcpWriteError(err_data.to_tcp_err()));\n           }\n         }\n@@ -1033,7 +1032,7 @@ fn write_common_impl(socket_data_ptr: *TcpSocketData,\n     // and waiting here for the write to complete, we should transfer\n     // ownership of everything to the I/O task and let it deal with the\n     // aftermath, so we don't have to sit here blocking.\n-    match core::comm::recv(result_po) {\n+    match oldcomm::recv(result_po) {\n       TcpWriteSuccess => result::Ok(()),\n       TcpWriteError(ref err_data) => result::Err(err_data.to_tcp_err())\n     }\n@@ -1045,8 +1044,8 @@ enum TcpNewConnection {\n \n type TcpListenFcData = {\n     server_stream_ptr: *uv::ll::uv_tcp_t,\n-    stream_closed_ch: comm::Chan<()>,\n-    kill_ch: comm::Chan<Option<TcpErrData>>,\n+    stream_closed_ch: oldcomm::Chan<()>,\n+    kill_ch: oldcomm::Chan<Option<TcpErrData>>,\n     on_connect_cb: fn~(*uv::ll::uv_tcp_t),\n     iotask: IoTask,\n     ipv6: bool,\n@@ -1056,7 +1055,7 @@ type TcpListenFcData = {\n extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let server_data_ptr = uv::ll::get_data_for_uv_handle(\n         handle) as *TcpListenFcData;\n-    core::comm::send((*server_data_ptr).stream_closed_ch, ());\n+    oldcomm::send((*server_data_ptr).stream_closed_ch, ());\n }\n \n extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n@@ -1069,7 +1068,7 @@ extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n           0i32 => ((*server_data_ptr).on_connect_cb)(handle),\n           _ => {\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n-            core::comm::send(kill_ch,\n+            oldcomm::send(kill_ch,\n                        Some(uv::ll::get_last_err_data(loop_ptr)\n                             .to_tcp_err()));\n             (*server_data_ptr).active = false;\n@@ -1094,7 +1093,7 @@ enum TcpWriteResult {\n }\n \n enum TcpReadStartResult {\n-    TcpReadStartSuccess(comm::Port<TcpReadResult>),\n+    TcpReadStartSuccess(oldcomm::Port<TcpReadResult>),\n     TcpReadStartError(TcpErrData)\n }\n \n@@ -1129,7 +1128,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         log(debug, fmt!(\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n                         err_data.err_name, err_data.err_msg));\n         let reader_ch = (*socket_data_ptr).reader_ch;\n-        core::comm::send(reader_ch, result::Err(err_data));\n+        oldcomm::send(reader_ch, result::Err(err_data));\n       }\n       // do nothing .. unneeded buf\n       0 => (),\n@@ -1140,7 +1139,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         let buf_base = uv::ll::get_base_from_buf(buf);\n         let new_bytes = vec::from_buf(buf_base, nread as uint);\n-        core::comm::send(reader_ch, result::Ok(new_bytes));\n+        oldcomm::send(reader_ch, result::Ok(new_bytes));\n       }\n     }\n     uv::ll::free_base_of_buf(buf);\n@@ -1160,14 +1159,14 @@ extern fn on_alloc_cb(handle: *libc::c_void,\n }\n \n type TcpSocketCloseData = {\n-    closed_ch: comm::Chan<()>\n+    closed_ch: oldcomm::Chan<()>\n };\n \n extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let data = uv::ll::get_data_for_uv_handle(handle)\n         as *TcpSocketCloseData;\n     let closed_ch = (*data).closed_ch;\n-    core::comm::send(closed_ch, ());\n+    oldcomm::send(closed_ch, ());\n     log(debug, ~\"tcp_socket_dtor_close_cb exiting..\");\n }\n \n@@ -1177,31 +1176,31 @@ extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n         as *WriteReqData;\n     if status == 0i32 {\n         log(debug, ~\"successful write complete\");\n-        core::comm::send((*write_data_ptr).result_ch, TcpWriteSuccess);\n+        oldcomm::send((*write_data_ptr).result_ch, TcpWriteSuccess);\n     } else {\n         let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n             write_req);\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n         log(debug, ~\"failure to write\");\n-        core::comm::send((*write_data_ptr).result_ch,\n+        oldcomm::send((*write_data_ptr).result_ch,\n                          TcpWriteError(err_data));\n     }\n }\n \n type WriteReqData = {\n-    result_ch: comm::Chan<TcpWriteResult>\n+    result_ch: oldcomm::Chan<TcpWriteResult>\n };\n \n type ConnectReqData = {\n-    result_ch: comm::Chan<ConnAttempt>,\n-    closed_signal_ch: comm::Chan<()>\n+    result_ch: oldcomm::Chan<ConnAttempt>,\n+    closed_signal_ch: oldcomm::Chan<()>\n };\n \n extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let data = uv::ll::get_data_for_uv_handle(handle) as\n         *ConnectReqData;\n-    core::comm::send((*data).closed_signal_ch, ());\n+    oldcomm::send((*data).closed_signal_ch, ());\n     log(debug, fmt!(\"exiting steam_error_close_cb for %?\", handle));\n }\n \n@@ -1220,15 +1219,15 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n     match status {\n       0i32 => {\n         log(debug, ~\"successful tcp connection!\");\n-        core::comm::send(result_ch, ConnSuccess);\n+        oldcomm::send(result_ch, ConnSuccess);\n       }\n       _ => {\n         log(debug, ~\"error in tcp_connect_on_connect_cb\");\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n         log(debug, fmt!(\"err_data %? %?\", err_data.err_name,\n                         err_data.err_msg));\n-        core::comm::send(result_ch, ConnFailure(err_data));\n+        oldcomm::send(result_ch, ConnFailure(err_data));\n         uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n                                        conn_data_ptr);\n         uv::ll::close(tcp_stream_ptr, stream_error_close_cb);\n@@ -1243,8 +1242,8 @@ enum ConnAttempt {\n }\n \n type TcpSocketData = {\n-    reader_po: comm::Port<result::Result<~[u8], TcpErrData>>,\n-    reader_ch: comm::Chan<result::Result<~[u8], TcpErrData>>,\n+    reader_po: oldcomm::Port<result::Result<~[u8], TcpErrData>>,\n+    reader_ch: oldcomm::Chan<result::Result<~[u8], TcpErrData>>,\n     stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n@@ -1337,14 +1336,14 @@ mod test {\n         let expected_req = ~\"ping\";\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = core::comm::Port::<~str>();\n-        let server_result_ch = core::comm::Chan(&server_result_po);\n+        let server_result_po = oldcomm::Port::<~str>();\n+        let server_result_ch = oldcomm::Chan(&server_result_po);\n \n-        let cont_po = core::comm::Port::<()>();\n-        let cont_ch = core::comm::Chan(&cont_po);\n+        let cont_po = oldcomm::Port::<()>();\n+        let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            let actual_req = do comm::listen |server_ch| {\n+            let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n                     server_ip,\n                     server_port,\n@@ -1355,10 +1354,10 @@ mod test {\n             };\n             server_result_ch.send(actual_req);\n         };\n-        core::comm::recv(cont_po);\n+        oldcomm::recv(cont_po);\n         // client\n         log(debug, ~\"server started, firing up client..\");\n-        let actual_resp_result = do core::comm::listen |client_ch| {\n+        let actual_resp_result = do oldcomm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1368,7 +1367,7 @@ mod test {\n         };\n         assert actual_resp_result.is_ok();\n         let actual_resp = actual_resp_result.get();\n-        let actual_req = core::comm::recv(server_result_po);\n+        let actual_req = oldcomm::recv(server_result_po);\n         log(debug, fmt!(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req));\n         log(debug, fmt!(\"RESP: expected: '%s' actual: '%s'\",\n@@ -1382,14 +1381,14 @@ mod test {\n         let server_port = 8887u;\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = core::comm::Port::<~str>();\n-        let server_result_ch = core::comm::Chan(&server_result_po);\n+        let server_result_po = oldcomm::Port::<~str>();\n+        let server_result_ch = oldcomm::Chan(&server_result_po);\n \n-        let cont_po = core::comm::Port::<()>();\n-        let cont_ch = core::comm::Chan(&cont_po);\n+        let cont_po = oldcomm::Port::<()>();\n+        let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            let actual_req = do comm::listen |server_ch| {\n+            let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n                     server_ip,\n                     server_port,\n@@ -1400,10 +1399,10 @@ mod test {\n             };\n             server_result_ch.send(actual_req);\n         };\n-        core::comm::recv(cont_po);\n+        oldcomm::recv(cont_po);\n         // client\n         log(debug, ~\"server started, firing up client..\");\n-        do core::comm::listen |client_ch| {\n+        do oldcomm::listen |client_ch| {\n             let server_ip_addr = ip::v4::parse_addr(server_ip);\n             let iotask = uv::global_loop::get();\n             let connect_result = connect(move server_ip_addr, server_port,\n@@ -1430,7 +1429,7 @@ mod test {\n         let expected_req = ~\"ping\";\n         // client\n         log(debug, ~\"firing up client..\");\n-        let actual_resp_result = do core::comm::listen |client_ch| {\n+        let actual_resp_result = do oldcomm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1450,14 +1449,14 @@ mod test {\n         let expected_req = ~\"ping\";\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = core::comm::Port::<~str>();\n-        let server_result_ch = core::comm::Chan(&server_result_po);\n+        let server_result_po = oldcomm::Port::<~str>();\n+        let server_result_ch = oldcomm::Chan(&server_result_po);\n \n-        let cont_po = core::comm::Port::<()>();\n-        let cont_ch = core::comm::Chan(&cont_po);\n+        let cont_po = oldcomm::Port::<()>();\n+        let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            let actual_req = do comm::listen |server_ch| {\n+            let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n                     server_ip,\n                     server_port,\n@@ -1468,15 +1467,15 @@ mod test {\n             };\n             server_result_ch.send(actual_req);\n         };\n-        core::comm::recv(cont_po);\n+        oldcomm::recv(cont_po);\n         // this one should fail..\n         let listen_err = run_tcp_test_server_fail(\n                             server_ip,\n                             server_port,\n                             hl_loop);\n         // client.. just doing this so that the first server tears down\n         log(debug, ~\"server started, firing up client..\");\n-        do core::comm::listen |client_ch| {\n+        do oldcomm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1574,14 +1573,14 @@ mod test {\n         let expected_req = ~\"GET /\";\n         let expected_resp = ~\"A string\\nwith multiple lines\\n\";\n \n-        let server_result_po = core::comm::Port::<~str>();\n-        let server_result_ch = core::comm::Chan(&server_result_po);\n+        let server_result_po = oldcomm::Port::<~str>();\n+        let server_result_ch = oldcomm::Chan(&server_result_po);\n \n-        let cont_po = core::comm::Port::<()>();\n-        let cont_ch = core::comm::Chan(&cont_po);\n+        let cont_po = oldcomm::Port::<()>();\n+        let cont_ch = oldcomm::Chan(&cont_po);\n         // server\n         do task::spawn_sched(task::ManualThreads(1u)) {\n-            let actual_req = do comm::listen |server_ch| {\n+            let actual_req = do oldcomm::listen |server_ch| {\n                 run_tcp_test_server(\n                     server_ip,\n                     server_port,\n@@ -1592,7 +1591,7 @@ mod test {\n             };\n             server_result_ch.send(actual_req);\n         };\n-        core::comm::recv(cont_po);\n+        oldcomm::recv(cont_po);\n         // client\n         log(debug, ~\"server started, firing up client..\");\n         let server_addr = ip::v4::parse_addr(server_ip);\n@@ -1626,8 +1625,8 @@ mod test {\n     }\n \n     fn run_tcp_test_server(server_ip: &str, server_port: uint, resp: ~str,\n-                          server_ch: comm::Chan<~str>,\n-                          cont_ch: comm::Chan<()>,\n+                          server_ch: oldcomm::Chan<~str>,\n+                          cont_ch: oldcomm::Chan<()>,\n                           iotask: IoTask) -> ~str {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n         let listen_result = listen(move server_ip_addr, server_port, 128,\n@@ -1636,13 +1635,13 @@ mod test {\n             |kill_ch| {\n                 log(debug, fmt!(\"establish_cb %?\",\n                     kill_ch));\n-                core::comm::send(cont_ch, ());\n+                oldcomm::send(cont_ch, ());\n             },\n             // risky to run this on the loop, but some users\n             // will want the POWER\n             |new_conn, kill_ch| {\n             log(debug, ~\"SERVER: new connection!\");\n-            do comm::listen |cont_ch| {\n+            do oldcomm::listen |cont_ch| {\n                 do task::spawn_sched(task::ManualThreads(1u)) {\n                     log(debug, ~\"SERVER: starting worker for new req\");\n \n@@ -1651,7 +1650,7 @@ mod test {\n                     if result::is_err(&accept_result) {\n                         log(debug, ~\"SERVER: error accept connection\");\n                         let err_data = result::get_err(&accept_result);\n-                        core::comm::send(kill_ch, Some(err_data));\n+                        oldcomm::send(kill_ch, Some(err_data));\n                         log(debug,\n                             ~\"SERVER/WORKER: send on err cont ch\");\n                         cont_ch.send(());\n@@ -1677,12 +1676,12 @@ mod test {\n                             log(debug, ~\"SERVER: before write\");\n                             tcp_write_single(&sock, str::to_bytes(resp));\n                             log(debug, ~\"SERVER: after write.. die\");\n-                            core::comm::send(kill_ch, None);\n+                            oldcomm::send(kill_ch, None);\n                           }\n                           result::Err(move err_data) => {\n                             log(debug, fmt!(\"SERVER: error recvd: %s %s\",\n                                 err_data.err_name, err_data.err_msg));\n-                            core::comm::send(kill_ch, Some(err_data));\n+                            oldcomm::send(kill_ch, Some(err_data));\n                             server_ch.send(~\"\");\n                           }\n                         }\n@@ -1738,7 +1737,7 @@ mod test {\n     }\n \n     fn run_tcp_test_client(server_ip: &str, server_port: uint, resp: &str,\n-                          client_ch: comm::Chan<~str>,\n+                          client_ch: oldcomm::Chan<~str>,\n                           iotask: IoTask) -> result::Result<~str,\n                                                     TcpConnectErrData> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);"}, {"sha": "d365077d0639d40a638d5e07efa7dfca7693ac8a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -23,7 +23,6 @@ use result::{Ok, Err};\n use io::WriterUtil;\n use libc::size_t;\n use task::TaskBuilder;\n-use comm = core::comm;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n@@ -289,8 +288,8 @@ fn run_tests(opts: &TestOpts, tests: &[TestDesc],\n     let mut wait_idx = 0;\n     let mut done_idx = 0;\n \n-    let p = core::comm::Port();\n-    let ch = core::comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let ch = oldcomm::Chan(&p);\n \n     while done_idx < total {\n         while wait_idx < concurrency && run_idx < total {\n@@ -306,7 +305,7 @@ fn run_tests(opts: &TestOpts, tests: &[TestDesc],\n             run_idx += 1;\n         }\n \n-        let (test, result) = core::comm::recv(p);\n+        let (test, result) = oldcomm::recv(p);\n         if concurrency != 1 {\n             callback(TeWait(copy test));\n         }\n@@ -383,9 +382,9 @@ fn filter_tests(opts: &TestOpts,\n \n type TestFuture = {test: TestDesc, wait: fn@() -> TestResult};\n \n-fn run_test(test: TestDesc, monitor_ch: comm::Chan<MonitorMsg>) {\n+fn run_test(test: TestDesc, monitor_ch: oldcomm::Chan<MonitorMsg>) {\n     if test.ignore {\n-        core::comm::send(monitor_ch, (copy test, TrIgnored));\n+        oldcomm::send(monitor_ch, (copy test, TrIgnored));\n         return;\n     }\n \n@@ -397,7 +396,7 @@ fn run_test(test: TestDesc, monitor_ch: comm::Chan<MonitorMsg>) {\n         }).spawn(move testfn);\n         let task_result = option::unwrap(move result_future).recv();\n         let test_result = calc_result(&test, task_result == task::Success);\n-        comm::send(monitor_ch, (copy test, test_result));\n+        oldcomm::send(monitor_ch, (copy test, test_result));\n     };\n }\n \n@@ -424,10 +423,10 @@ mod tests {\n             ignore: true,\n             should_fail: false\n         };\n-        let p = core::comm::Port();\n-        let ch = core::comm::Chan(&p);\n+        let p = oldcomm::Port();\n+        let ch = oldcomm::Chan(&p);\n         run_test(desc, ch);\n-        let (_, res) = core::comm::recv(p);\n+        let (_, res) = oldcomm::recv(p);\n         assert res != TrOk;\n     }\n \n@@ -440,10 +439,10 @@ mod tests {\n             ignore: true,\n             should_fail: false\n         };\n-        let p = core::comm::Port();\n-        let ch = core::comm::Chan(&p);\n+        let p = oldcomm::Port();\n+        let ch = oldcomm::Chan(&p);\n         run_test(desc, ch);\n-        let (_, res) = core::comm::recv(p);\n+        let (_, res) = oldcomm::recv(p);\n         assert res == TrIgnored;\n     }\n \n@@ -457,10 +456,10 @@ mod tests {\n             ignore: false,\n             should_fail: true\n         };\n-        let p = core::comm::Port();\n-        let ch = core::comm::Chan(&p);\n+        let p = oldcomm::Port();\n+        let ch = oldcomm::Chan(&p);\n         run_test(desc, ch);\n-        let (_, res) = core::comm::recv(p);\n+        let (_, res) = oldcomm::recv(p);\n         assert res == TrOk;\n     }\n \n@@ -473,10 +472,10 @@ mod tests {\n             ignore: false,\n             should_fail: true\n         };\n-        let p = core::comm::Port();\n-        let ch = core::comm::Chan(&p);\n+        let p = oldcomm::Port();\n+        let ch = oldcomm::Chan(&p);\n         run_test(desc, ch);\n-        let (_, res) = core::comm::recv(p);\n+        let (_, res) = oldcomm::recv(p);\n         assert res == TrFailed;\n     }\n "}, {"sha": "c3a2a11e1f840df1e7549da56679f8560e99cc92", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -14,7 +14,6 @@\n \n use uv::iotask;\n use uv::iotask::IoTask;\n-use comm = core::comm;\n \n /**\n  * Wait for timeout period then send provided value over a channel\n@@ -33,10 +32,10 @@ use comm = core::comm;\n  * * val - a value of type T to send over the provided `ch`\n  */\n pub fn delayed_send<T: Owned>(iotask: IoTask,\n-                                  msecs: uint, ch: comm::Chan<T>, val: T) {\n+                                  msecs: uint, ch: oldcomm::Chan<T>, val: T) {\n         unsafe {\n-            let timer_done_po = core::comm::Port::<()>();\n-            let timer_done_ch = core::comm::Chan(&timer_done_po);\n+            let timer_done_po = oldcomm::Port::<()>();\n+            let timer_done_ch = oldcomm::Chan(&timer_done_po);\n             let timer_done_ch_ptr = ptr::addr_of(&timer_done_ch);\n             let timer = uv::ll::timer_t();\n             let timer_ptr = ptr::addr_of(&timer);\n@@ -62,11 +61,11 @@ pub fn delayed_send<T: Owned>(iotask: IoTask,\n                 }\n             };\n             // delayed_send_cb has been processed by libuv\n-            core::comm::recv(timer_done_po);\n+            oldcomm::recv(timer_done_po);\n             // notify the caller immediately\n-            core::comm::send(ch, move(val));\n+            oldcomm::send(ch, move(val));\n             // uv_close for this timer has been processed\n-            core::comm::recv(timer_done_po);\n+            oldcomm::recv(timer_done_po);\n     };\n }\n \n@@ -82,10 +81,10 @@ pub fn delayed_send<T: Owned>(iotask: IoTask,\n  * * msecs - an amount of time, in milliseconds, for the current task to block\n  */\n pub fn sleep(iotask: IoTask, msecs: uint) {\n-    let exit_po = core::comm::Port::<()>();\n-    let exit_ch = core::comm::Chan(&exit_po);\n+    let exit_po = oldcomm::Port::<()>();\n+    let exit_ch = oldcomm::Chan(&exit_po);\n     delayed_send(iotask, msecs, exit_ch, ());\n-    core::comm::recv(exit_po);\n+    oldcomm::recv(exit_po);\n }\n \n /**\n@@ -110,9 +109,9 @@ pub fn sleep(iotask: IoTask, msecs: uint) {\n  */\n pub fn recv_timeout<T: Copy Owned>(iotask: IoTask,\n                               msecs: uint,\n-                              wait_po: comm::Port<T>) -> Option<T> {\n-    let timeout_po = comm::Port::<()>();\n-    let timeout_ch = comm::Chan(&timeout_po);\n+                              wait_po: oldcomm::Port<T>) -> Option<T> {\n+    let timeout_po = oldcomm::Port::<()>();\n+    let timeout_ch = oldcomm::Chan(&timeout_po);\n     delayed_send(iotask, msecs, timeout_ch, ());\n     // FIXME: This could be written clearer (#2618)\n     either::either(\n@@ -122,7 +121,7 @@ pub fn recv_timeout<T: Copy Owned>(iotask: IoTask,\n             None\n         }, |right_val| {\n             Some(*right_val)\n-        }, &core::comm::select2(timeout_po, wait_po)\n+        }, &oldcomm::select2(timeout_po, wait_po)\n     )\n }\n \n@@ -131,10 +130,10 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n                                 status: libc::c_int) unsafe {\n     log(debug, fmt!(\"delayed_send_cb handle %? status %?\", handle, status));\n     let timer_done_ch =\n-        *(uv::ll::get_data_for_uv_handle(handle) as *comm::Chan<()>);\n+        *(uv::ll::get_data_for_uv_handle(handle) as *oldcomm::Chan<()>);\n     let stop_result = uv::ll::timer_stop(handle);\n     if (stop_result == 0i32) {\n-        core::comm::send(timer_done_ch, ());\n+        oldcomm::send(timer_done_ch, ());\n         uv::ll::close(handle, delayed_send_close_cb);\n     }\n     else {\n@@ -147,8 +146,8 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n extern fn delayed_send_close_cb(handle: *uv::ll::uv_timer_t) unsafe {\n     log(debug, fmt!(\"delayed_send_close_cb handle %?\", handle));\n     let timer_done_ch =\n-        *(uv::ll::get_data_for_uv_handle(handle) as *comm::Chan<()>);\n-    comm::send(timer_done_ch, ());\n+        *(uv::ll::get_data_for_uv_handle(handle) as *oldcomm::Chan<()>);\n+    oldcomm::send(timer_done_ch, ());\n }\n \n #[cfg(test)]\n@@ -170,8 +169,8 @@ mod test {\n \n     #[test]\n     fn test_gl_timer_sleep_stress2() {\n-        let po = core::comm::Port();\n-        let ch = core::comm::Chan(&po);\n+        let po = oldcomm::Port();\n+        let ch = oldcomm::Chan(&po);\n         let hl_loop = uv::global_loop::get();\n \n         let repeat = 20u;\n@@ -193,13 +192,13 @@ mod test {\n                     for iter::repeat(times) {\n                         sleep(hl_loop, rng.next() as uint % maxms);\n                     }\n-                    core::comm::send(ch, ());\n+                    oldcomm::send(ch, ());\n                 }\n             }\n         }\n \n         for iter::repeat(repeat * spec.len()) {\n-            core::comm::recv(po)\n+            oldcomm::recv(po)\n         }\n     }\n \n@@ -248,8 +247,8 @@ mod test {\n \n         for iter::repeat(times as uint) {\n             let expected = rand::Rng().gen_str(16u);\n-            let test_po = core::comm::Port::<~str>();\n-            let test_ch = core::comm::Chan(&test_po);\n+            let test_po = oldcomm::Port::<~str>();\n+            let test_ch = oldcomm::Chan(&test_po);\n \n             do task::spawn() {\n                 delayed_send(hl_loop, 50u, test_ch, expected);"}, {"sha": "2efbfae3da4e26ee5d8f697de0a299c5b7641747", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -17,8 +17,7 @@ use iotask = uv_iotask;\n use get_gl = get;\n use uv_iotask::{IoTask, spawn_iotask};\n use private::{chan_from_global_ptr, weaken_task};\n-use comm = core::comm;\n-use core::comm::{Port, Chan, select2, listen};\n+use core::oldcomm::{Port, Chan, select2, listen};\n use task::TaskBuilder;\n use either::{Left, Right};\n \n@@ -121,9 +120,9 @@ fn spawn_loop() -> IoTask {\n mod test {\n     extern fn simple_timer_close_cb(timer_ptr: *ll::uv_timer_t) unsafe {\n         let exit_ch_ptr = ll::get_data_for_uv_handle(\n-            timer_ptr as *libc::c_void) as *comm::Chan<bool>;\n+            timer_ptr as *libc::c_void) as *oldcomm::Chan<bool>;\n         let exit_ch = *exit_ch_ptr;\n-        core::comm::send(exit_ch, true);\n+        oldcomm::send(exit_ch, true);\n         log(debug, fmt!(\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n                        exit_ch_ptr));\n     }\n@@ -142,8 +141,8 @@ mod test {\n     }\n \n     fn impl_uv_hl_simple_timer(iotask: IoTask) unsafe {\n-        let exit_po = core::comm::Port::<bool>();\n-        let exit_ch = core::comm::Chan(&exit_po);\n+        let exit_po = oldcomm::Port::<bool>();\n+        let exit_ch = oldcomm::Chan(&exit_po);\n         let exit_ch_ptr = ptr::addr_of(&exit_ch);\n         log(debug, fmt!(\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n                        exit_ch_ptr));\n@@ -168,21 +167,21 @@ mod test {\n                 fail ~\"failure on ll::timer_init()\";\n             }\n         };\n-        core::comm::recv(exit_po);\n+        oldcomm::recv(exit_po);\n         log(debug, ~\"global_loop timer test: msg recv on exit_po, done..\");\n     }\n \n     #[test]\n     fn test_gl_uv_global_loop_high_level_global_timer() unsafe {\n         let hl_loop = get_gl();\n-        let exit_po = comm::Port::<()>();\n-        let exit_ch = comm::Chan(&exit_po);\n+        let exit_po = oldcomm::Port::<()>();\n+        let exit_ch = oldcomm::Chan(&exit_po);\n         task::spawn_sched(task::ManualThreads(1u), || {\n             impl_uv_hl_simple_timer(hl_loop);\n-            core::comm::send(exit_ch, ());\n+            oldcomm::send(exit_ch, ());\n         });\n         impl_uv_hl_simple_timer(hl_loop);\n-        core::comm::recv(exit_po);\n+        oldcomm::recv(exit_po);\n     }\n \n     // keeping this test ignored until some kind of stress-test-harness\n@@ -191,17 +190,17 @@ mod test {\n     #[ignore]\n     fn test_stress_gl_uv_global_loop_high_level_global_timer() unsafe {\n         let hl_loop = get_gl();\n-        let exit_po = core::comm::Port::<()>();\n-        let exit_ch = core::comm::Chan(&exit_po);\n+        let exit_po = oldcomm::Port::<()>();\n+        let exit_ch = oldcomm::Chan(&exit_po);\n         let cycles = 5000u;\n         for iter::repeat(cycles) {\n             task::spawn_sched(task::ManualThreads(1u), || {\n                 impl_uv_hl_simple_timer(hl_loop);\n-                core::comm::send(exit_ch, ());\n+                oldcomm::send(exit_ch, ());\n             });\n         };\n         for iter::repeat(cycles) {\n-            core::comm::recv(exit_po);\n+            oldcomm::recv(exit_po);\n         };\n         log(debug, ~\"test_stress_gl_uv_global_loop_high_level_global_timer\"+\n             ~\" exiting sucessfully!\");"}, {"sha": "d778606075d1a122dd6cf1b02575829414cf0e31", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -18,8 +18,7 @@\n \n use libc::c_void;\n use ptr::addr_of;\n-use comm = core::comm;\n-use core::comm::{Port, Chan, listen};\n+use core::oldcomm::{Port, Chan, listen};\n use task::TaskBuilder;\n use ll = uv_ll;\n \n@@ -178,7 +177,7 @@ mod test {\n         log(debug, fmt!(\"async_close_cb handle %?\", handle));\n         let exit_ch = (*(ll::get_data_for_uv_handle(handle)\n                         as *AhData)).exit_ch;\n-        core::comm::send(exit_ch, ());\n+        oldcomm::send(exit_ch, ());\n     }\n     extern fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int)\n         unsafe {\n@@ -187,13 +186,13 @@ mod test {\n     }\n     type AhData = {\n         iotask: IoTask,\n-        exit_ch: comm::Chan<()>\n+        exit_ch: oldcomm::Chan<()>\n     };\n     fn impl_uv_iotask_async(iotask: IoTask) unsafe {\n         let async_handle = ll::async_t();\n         let ah_ptr = ptr::addr_of(&async_handle);\n-        let exit_po = core::comm::Port::<()>();\n-        let exit_ch = core::comm::Chan(&exit_po);\n+        let exit_po = oldcomm::Port::<()>();\n+        let exit_ch = oldcomm::Chan(&exit_po);\n         let ah_data = {\n             iotask: iotask,\n             exit_ch: exit_ch\n@@ -204,19 +203,19 @@ mod test {\n             ll::set_data_for_uv_handle(ah_ptr, ah_data_ptr as *libc::c_void);\n             ll::async_send(ah_ptr);\n         };\n-        core::comm::recv(exit_po);\n+        oldcomm::recv(exit_po);\n     }\n \n     // this fn documents the bear minimum neccesary to roll your own\n     // high_level_loop\n-    unsafe fn spawn_test_loop(exit_ch: comm::Chan<()>) -> IoTask {\n-        let iotask_port = comm::Port::<IoTask>();\n-        let iotask_ch = comm::Chan(&iotask_port);\n+    unsafe fn spawn_test_loop(exit_ch: oldcomm::Chan<()>) -> IoTask {\n+        let iotask_port = oldcomm::Port::<IoTask>();\n+        let iotask_ch = oldcomm::Chan(&iotask_port);\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             run_loop(iotask_ch);\n             exit_ch.send(());\n         };\n-        return core::comm::recv(iotask_port);\n+        return oldcomm::recv(iotask_port);\n     }\n \n     extern fn lifetime_handle_close(handle: *libc::c_void) unsafe {\n@@ -231,8 +230,8 @@ mod test {\n \n     #[test]\n     fn test_uv_iotask_async() unsafe {\n-        let exit_po = core::comm::Port::<()>();\n-        let exit_ch = core::comm::Chan(&exit_po);\n+        let exit_po = oldcomm::Port::<()>();\n+        let exit_ch = oldcomm::Chan(&exit_po);\n         let iotask = spawn_test_loop(exit_ch);\n \n         // using this handle to manage the lifetime of the high_level_loop,\n@@ -241,20 +240,20 @@ mod test {\n         // under race-condition type situations.. this ensures that the loop\n         // lives until, at least, all of the impl_uv_hl_async() runs have been\n         // called, at least.\n-        let work_exit_po = core::comm::Port::<()>();\n-        let work_exit_ch = core::comm::Chan(&work_exit_po);\n+        let work_exit_po = oldcomm::Port::<()>();\n+        let work_exit_ch = oldcomm::Chan(&work_exit_po);\n         for iter::repeat(7u) {\n             do task::spawn_sched(task::ManualThreads(1u)) {\n                 impl_uv_iotask_async(iotask);\n-                core::comm::send(work_exit_ch, ());\n+                oldcomm::send(work_exit_ch, ());\n             };\n         };\n         for iter::repeat(7u) {\n-            core::comm::recv(work_exit_po);\n+            oldcomm::recv(work_exit_po);\n         };\n         log(debug, ~\"sending teardown_loop msg..\");\n         exit(iotask);\n-        core::comm::recv(exit_po);\n+        oldcomm::recv(exit_po);\n         log(debug, ~\"after recv on exit_po.. exiting..\");\n     }\n }"}, {"sha": "65333b41864e52813d01913622b18bfbeef24226", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -33,7 +33,6 @@\n #[allow(non_camel_case_types)]; // C types\n \n use libc::size_t;\n-use comm = core::comm;\n use ptr::to_unsafe_ptr;\n \n // libuv struct mappings\n@@ -1045,7 +1044,7 @@ pub mod test {\n     type request_wrapper = {\n         write_req: *uv_write_t,\n         req_buf: *~[uv_buf_t],\n-        read_chan: *comm::Chan<~str>\n+        read_chan: *oldcomm::Chan<~str>\n     };\n \n     extern fn after_close_cb(handle: *libc::c_void) {\n@@ -1083,7 +1082,7 @@ pub mod test {\n             let bytes = vec::from_buf(buf_base, buf_len as uint);\n             let read_chan = *((*client_data).read_chan);\n             let msg_from_server = str::from_bytes(bytes);\n-            core::comm::send(read_chan, msg_from_server);\n+            oldcomm::send(read_chan, msg_from_server);\n             close(stream as *libc::c_void, after_close_cb)\n         }\n         else if (nread == -1) {\n@@ -1143,7 +1142,7 @@ pub mod test {\n     }\n \n     fn impl_uv_tcp_request(ip: &str, port: int, req_str: &str,\n-                          client_chan: *comm::Chan<~str>) unsafe {\n+                          client_chan: *oldcomm::Chan<~str>) unsafe {\n         let test_loop = loop_new();\n         let tcp_handle = tcp_t();\n         let tcp_handle_ptr = ptr::addr_of(&tcp_handle);\n@@ -1268,7 +1267,7 @@ pub mod test {\n                 log(debug, ~\"SERVER: sending response to client\");\n                 read_stop(client_stream_ptr);\n                 let server_chan = *((*client_data).server_chan);\n-                core::comm::send(server_chan, request_str);\n+                oldcomm::send(server_chan, request_str);\n                 let write_result = write(\n                     write_req,\n                     client_stream_ptr as *libc::c_void,\n@@ -1360,12 +1359,12 @@ pub mod test {\n         server: *uv_tcp_t,\n         server_kill_msg: ~str,\n         server_resp_buf: *~[uv_buf_t],\n-        server_chan: *comm::Chan<~str>,\n+        server_chan: *oldcomm::Chan<~str>,\n         server_write_req: *uv_write_t\n     };\n \n     type async_handle_data = {\n-        continue_chan: *comm::Chan<bool>\n+        continue_chan: *oldcomm::Chan<bool>\n     };\n \n     extern fn async_close_cb(handle: *libc::c_void) {\n@@ -1383,16 +1382,16 @@ pub mod test {\n             async_handle as *libc::c_void) as *async_handle_data;\n         let continue_chan = *((*data).continue_chan);\n         let should_continue = status == 0i32;\n-        core::comm::send(continue_chan, should_continue);\n+        oldcomm::send(continue_chan, should_continue);\n         close(async_handle as *libc::c_void, async_close_cb);\n     }\n \n     fn impl_uv_tcp_server(server_ip: &str,\n                           server_port: int,\n                           +kill_server_msg: ~str,\n                           +server_resp_msg: ~str,\n-                          server_chan: *comm::Chan<~str>,\n-                          continue_chan: *comm::Chan<bool>) unsafe {\n+                          server_chan: *oldcomm::Chan<~str>,\n+                          continue_chan: *oldcomm::Chan<bool>) unsafe {\n         let test_loop = loop_new();\n         let tcp_server = tcp_t();\n         let tcp_server_ptr = ptr::addr_of(&tcp_server);\n@@ -1497,13 +1496,13 @@ pub mod test {\n         let port = 8886;\n         let kill_server_msg = ~\"does a dog have buddha nature?\";\n         let server_resp_msg = ~\"mu!\";\n-        let client_port = core::comm::Port::<~str>();\n-        let client_chan = core::comm::Chan::<~str>(&client_port);\n-        let server_port = core::comm::Port::<~str>();\n-        let server_chan = core::comm::Chan::<~str>(&server_port);\n+        let client_port = oldcomm::Port::<~str>();\n+        let client_chan = oldcomm::Chan::<~str>(&client_port);\n+        let server_port = oldcomm::Port::<~str>();\n+        let server_chan = oldcomm::Chan::<~str>(&server_port);\n \n-        let continue_port = core::comm::Port::<bool>();\n-        let continue_chan = core::comm::Chan::<bool>(&continue_port);\n+        let continue_port = oldcomm::Port::<bool>();\n+        let continue_chan = oldcomm::Chan::<bool>(&continue_port);\n         let continue_chan_ptr = ptr::addr_of(&continue_chan);\n \n         do task::spawn_sched(task::ManualThreads(1)) {\n@@ -1516,7 +1515,7 @@ pub mod test {\n \n         // block until the server up is.. possibly a race?\n         log(debug, ~\"before receiving on server continue_port\");\n-        core::comm::recv(continue_port);\n+        oldcomm::recv(continue_port);\n         log(debug, ~\"received on continue port, set up tcp client\");\n \n         do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -1525,8 +1524,8 @@ pub mod test {\n                                ptr::addr_of(&client_chan));\n         };\n \n-        let msg_from_client = core::comm::recv(server_port);\n-        let msg_from_server = core::comm::recv(client_port);\n+        let msg_from_client = oldcomm::recv(server_port);\n+        let msg_from_server = oldcomm::recv(client_port);\n \n         assert str::contains(msg_from_client, kill_server_msg);\n         assert str::contains(msg_from_server, server_resp_msg);"}, {"sha": "a558de338762917ae6b336f5e53c48244592fc35", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -12,7 +12,7 @@\n \n export foo;\n \n-use core::comm::*;\n+use core::oldcomm::*;\n \n fn foo<T: Owned Copy>(x: T) -> Port<T> {\n     let p = Port();"}, {"sha": "0ae2dc5340e276036cde646895e6e0712e8f436d", "filename": "src/test/auxiliary/test_comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fauxiliary%2Ftest_comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Ftest_comm.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n /*\n-  Minimized version of core::comm for testing. \n+  Minimized version of core::oldcomm for testing. \n \n   Could probably be more minimal.\n  */\n@@ -22,7 +22,7 @@ export recv;\n \n \n /**\n- * A communication endpoint that can receive messages\n+ * A oldcommunication endpoint that can receive messages\n  *\n  * Each port has a unique per-task identity and may not be replicated or\n  * transmitted. If a port value is copied, both copies refer to the same"}, {"sha": "774e0b2e53a7a56828026f69558127e4cd294a3b", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -26,7 +26,7 @@ use std::deque;\n use std::deque::Deque;\n use std::par;\n use io::WriterUtil;\n-use comm::*;\n+use oldcomm::*;\n use int::abs;\n \n type node_id = i64;"}, {"sha": "62226a1c44de1b6b1c5a531995c9342a687de047", "filename": "src/test/bench/msgsend-ring.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fmsgsend-ring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -14,16 +14,16 @@\n // that things will look really good once we get that lock out of the\n // message path.\n \n-use comm::*;\n+use oldcomm::*;\n \n extern mod std;\n use std::time;\n use std::future;\n \n fn thread_ring(i: uint,\n                count: uint,\n-               num_chan: comm::Chan<uint>,\n-               num_port: comm::Port<uint>) {\n+               num_chan: oldcomm::Chan<uint>,\n+               num_port: oldcomm::Port<uint>) {\n     // Send/Receive lots of messages.\n     for uint::range(0u, count) |j| {\n         num_chan.send(i * j);"}, {"sha": "3625dd048b52dd3dd8b3cc2a42a915ba2c059c37", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -95,18 +95,18 @@ fn transform(aa: color, bb: color) -> color {\n fn creature(\n     name: uint,\n     color: color,\n-    from_rendezvous: comm::Port<Option<creature_info>>,\n-    to_rendezvous: comm::Chan<creature_info>,\n-    to_rendezvous_log: comm::Chan<~str>\n+    from_rendezvous: oldcomm::Port<Option<creature_info>>,\n+    to_rendezvous: oldcomm::Chan<creature_info>,\n+    to_rendezvous_log: oldcomm::Chan<~str>\n ) {\n     let mut color = color;\n     let mut creatures_met = 0;\n     let mut evil_clones_met = 0;\n \n     loop {\n         // ask for a pairing\n-        comm::send(to_rendezvous, {name: name, color: color});\n-        let resp = comm::recv(from_rendezvous);\n+        oldcomm::send(to_rendezvous, {name: name, color: color});\n+        let resp = oldcomm::recv(from_rendezvous);\n \n         // log and change, or print and quit\n         match resp {\n@@ -123,7 +123,7 @@ fn creature(\n                 // log creatures met and evil clones of self\n                 let report = fmt!(\"%u\", creatures_met) + ~\" \" +\n                              show_number(evil_clones_met);\n-                comm::send(to_rendezvous_log, report);\n+                oldcomm::send(to_rendezvous_log, report);\n                 break;\n             }\n         }\n@@ -132,28 +132,28 @@ fn creature(\n \n fn rendezvous(nn: uint, set: ~[color]) {\n \n-    pub fn spawn_listener<A: Send>(+f: fn~(comm::Port<A>)) -> comm::Chan<A> {\n-        let setup_po = comm::Port();\n-        let setup_ch = comm::Chan(&setup_po);\n+    pub fn spawn_listener<A: Send>(+f: fn~(oldcomm::Port<A>)) -> oldcomm::Chan<A> {\n+        let setup_po = oldcomm::Port();\n+        let setup_ch = oldcomm::Chan(&setup_po);\n         do task::spawn |move f| {\n-            let po = comm::Port();\n-            let ch = comm::Chan(&po);\n-            comm::send(setup_ch, ch);\n+            let po = oldcomm::Port();\n+            let ch = oldcomm::Chan(&po);\n+            oldcomm::send(setup_ch, ch);\n             f(move po);\n         }\n-        comm::recv(setup_po)\n+        oldcomm::recv(setup_po)\n     }\n \n     // these ports will allow us to hear from the creatures\n-    let from_creatures:     comm::Port<creature_info> = comm::Port();\n-    let from_creatures_log: comm::Port<~str> = comm::Port();\n+    let from_creatures:     oldcomm::Port<creature_info> = oldcomm::Port();\n+    let from_creatures_log: oldcomm::Port<~str> = oldcomm::Port();\n \n     // these channels will be passed to the creatures so they can talk to us\n-    let to_rendezvous     = comm::Chan(&from_creatures);\n-    let to_rendezvous_log = comm::Chan(&from_creatures_log);\n+    let to_rendezvous     = oldcomm::Chan(&from_creatures);\n+    let to_rendezvous_log = oldcomm::Chan(&from_creatures_log);\n \n     // these channels will allow us to talk to each creature by 'name'/index\n-    let to_creature: ~[comm::Chan<Option<creature_info>>] =\n+    let to_creature: ~[oldcomm::Chan<Option<creature_info>>] =\n         vec::mapi(set, |ii, col| {\n             // create each creature as a listener with a port, and\n             // give us a channel to talk to each\n@@ -169,24 +169,24 @@ fn rendezvous(nn: uint, set: ~[color]) {\n \n     // set up meetings...\n     for nn.times {\n-        let fst_creature: creature_info = comm::recv(from_creatures);\n-        let snd_creature: creature_info = comm::recv(from_creatures);\n+        let fst_creature: creature_info = oldcomm::recv(from_creatures);\n+        let snd_creature: creature_info = oldcomm::recv(from_creatures);\n \n         creatures_met += 2;\n \n-        comm::send(to_creature[fst_creature.name], Some(snd_creature));\n-        comm::send(to_creature[snd_creature.name], Some(fst_creature));\n+        oldcomm::send(to_creature[fst_creature.name], Some(snd_creature));\n+        oldcomm::send(to_creature[snd_creature.name], Some(fst_creature));\n     }\n \n     // tell each creature to stop\n     for vec::eachi(to_creature) |_ii, to_one| {\n-        comm::send(*to_one, None);\n+        oldcomm::send(*to_one, None);\n     }\n \n     // save each creature's meeting stats\n     let mut report = ~[];\n     for vec::each(to_creature) |_to_one| {\n-        report.push(comm::recv(from_creatures_log));\n+        report.push(oldcomm::recv(from_creatures_log));\n     }\n \n     // print each color in the set"}, {"sha": "2420a02aa237ea6ce77d7579f7bc3218c5b19ceb", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -129,7 +129,7 @@ fn make_sequence_processor(sz: uint, from_parent: pipes::Port<~[u8]>,\n         _ => { ~\"\" }\n    };\n \n-   //comm::send(to_parent, fmt!(\"yay{%u}\", sz));\n+   //oldcomm::send(to_parent, fmt!(\"yay{%u}\", sz));\n     to_parent.send(move buffer);\n }\n "}, {"sha": "a45138d72d9549b461dda8379d81e2ac4547bfc6", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -87,7 +87,7 @@ fn fillbyte(x: cmplx, incr: f64) -> u8 {\n     rv\n }\n \n-fn chanmb(i: uint, size: uint, ch: comm::Chan<line>) -> ()\n+fn chanmb(i: uint, size: uint, ch: oldcomm::Chan<line>) -> ()\n {\n     let mut crv = ~[];\n     let incr = 2f64/(size as f64);\n@@ -97,7 +97,7 @@ fn chanmb(i: uint, size: uint, ch: comm::Chan<line>) -> ()\n         let x = cmplx {re: xincr*(j as f64) - 1.5f64, im: y};\n         crv.push(fillbyte(x, incr));\n     };\n-    comm::send(ch, {i:i, b:crv});\n+    oldcomm::send(ch, {i:i, b:crv});\n }\n \n type devnull = {dn: int};\n@@ -110,11 +110,11 @@ impl devnull: io::Writer {\n     fn get_type() -> io::WriterType { io::File }\n }\n \n-fn writer(path: ~str, writech: comm::Chan<comm::Chan<line>>, size: uint)\n+fn writer(path: ~str, writech: oldcomm::Chan<oldcomm::Chan<line>>, size: uint)\n {\n-    let p: comm::Port<line> = comm::Port();\n-    let ch = comm::Chan(&p);\n-    comm::send(writech, ch);\n+    let p: oldcomm::Port<line> = oldcomm::Port();\n+    let ch = oldcomm::Chan(&p);\n+    oldcomm::send(writech, ch);\n     let cout: io::Writer = match path {\n         ~\"\" => {\n             {dn: 0} as io::Writer\n@@ -134,7 +134,7 @@ fn writer(path: ~str, writech: comm::Chan<comm::Chan<line>>, size: uint)\n     let mut done = 0_u;\n     let mut i = 0_u;\n     while i < size {\n-        let aline = comm::recv(p);\n+        let aline = oldcomm::recv(p);\n         if aline.i == done {\n             debug!(\"W %u\", aline.i);\n             cout.write(aline.b);\n@@ -178,12 +178,12 @@ fn main() {\n     let size = if vec::len(args) < 2_u { 80_u }\n     else { uint::from_str(args[1]).get() };\n \n-    let writep = comm::Port();\n-    let writech = comm::Chan(&writep);\n+    let writep = oldcomm::Port();\n+    let writech = oldcomm::Chan(&writep);\n     do task::spawn |move path| {\n         writer(copy path, writech, size);\n     };\n-    let ch = comm::recv(writep);\n+    let ch = oldcomm::recv(writep);\n     for uint::range(0_u, size) |j| {\n         task::spawn(|| chanmb(j, size, ch) );\n         if j % yieldevery == 0_u {"}, {"sha": "80bcb8340542dda03cd84d5be2797415b9530938", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -14,7 +14,7 @@\n   A parallel version of fibonacci numbers.\n \n   This version is meant mostly as a way of stressing and benchmarking\n-  the task system. It supports a lot of command-line arguments to\n+  the task system. It supports a lot of oldcommand-line arguments to\n   control how it runs.\n \n */"}, {"sha": "c58f07dad2e482865151b44665fc0417a29a9801", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -20,20 +20,20 @@\n // Creates in the background 'num_tasks' tasks, all blocked forever.\n // Doesn't return until all such tasks are ready, but doesn't block forever itself.\n fn grandchild_group(num_tasks: uint) {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n \n     for num_tasks.times {\n         do task::spawn { // linked\n-            comm::send(ch, ());\n-            comm::recv(comm::Port::<()>()); // block forever\n+            oldcomm::send(ch, ());\n+            oldcomm::recv(oldcomm::Port::<()>()); // block forever\n         }\n     }\n     error!(\"Grandchild group getting started\");\n     for num_tasks.times {\n         // Make sure all above children are fully spawned; i.e., enlisted in\n         // their ancestor groups.\n-        comm::recv(po);\n+        oldcomm::recv(po);\n     }\n     error!(\"Grandchild group ready to go.\");\n     // Master grandchild task exits early."}, {"sha": "e4c7718325ff696fae9ce570d2b29664d3d48428", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -11,14 +11,14 @@\n // Test for concurrent tasks\n \n enum msg {\n-    ready(comm::Chan<msg>),\n+    ready(oldcomm::Chan<msg>),\n     start,\n     done(int),\n }\n \n-fn calc(children: uint, parent_ch: comm::Chan<msg>) {\n-    let port = comm::Port();\n-    let chan = comm::Chan(&port);\n+fn calc(children: uint, parent_ch: oldcomm::Chan<msg>) {\n+    let port = oldcomm::Port();\n+    let chan = oldcomm::Chan(&port);\n     let mut child_chs = ~[];\n     let mut sum = 0;\n \n@@ -29,33 +29,33 @@ fn calc(children: uint, parent_ch: comm::Chan<msg>) {\n     }\n \n     for iter::repeat (children) {\n-        match comm::recv(port) {\n+        match oldcomm::recv(port) {\n           ready(child_ch) => {\n             child_chs.push(child_ch);\n           }\n           _ => fail ~\"task-perf-one-million failed (port not ready)\"\n         }\n     }\n \n-    comm::send(parent_ch, ready(chan));\n+    oldcomm::send(parent_ch, ready(chan));\n \n-    match comm::recv(port) {\n+    match oldcomm::recv(port) {\n         start => {\n             for vec::each(child_chs) |child_ch| {\n-                comm::send(*child_ch, start);\n+                oldcomm::send(*child_ch, start);\n             }\n         }\n         _ => fail ~\"task-perf-one-million failed (port not in start state)\"\n     }\n \n     for iter::repeat (children) {\n-        match comm::recv(port) {\n+        match oldcomm::recv(port) {\n           done(child_sum) => { sum += child_sum; }\n           _ => fail ~\"task-perf-one-million failed (port not done)\"\n         }\n     }\n \n-    comm::send(parent_ch, done(sum + 1));\n+    oldcomm::send(parent_ch, done(sum + 1));\n }\n \n fn main() {\n@@ -69,18 +69,18 @@ fn main() {\n     };\n \n     let children = uint::from_str(args[1]).get();\n-    let port = comm::Port();\n-    let chan = comm::Chan(&port);\n+    let port = oldcomm::Port();\n+    let chan = oldcomm::Chan(&port);\n     do task::spawn {\n         calc(children, chan);\n     };\n-    match comm::recv(port) {\n+    match oldcomm::recv(port) {\n       ready(chan) => {\n-        comm::send(chan, start);\n+        oldcomm::send(chan, start);\n       }\n       _ => fail ~\"task-perf-one-million failed (port not ready)\"\n     }\n-    let sum = match comm::recv(port) {\n+    let sum = match oldcomm::recv(port) {\n       done(sum) => { sum }\n       _ => fail ~\"task-perf-one-million failed (port not done)\"\n     };"}, {"sha": "5c09248b59c1ba910efd5c3f81a93beb57ac3f1c", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -13,7 +13,7 @@\n \n    This is meant primarily to demonstrate Rust's MapReduce framework.\n \n-   It takes a list of files on the command line and outputs a list of\n+   It takes a list of files on the oldcommand line and outputs a list of\n    words along with how many times each word is used.\n \n */\n@@ -32,10 +32,10 @@ use io::{ReaderUtil, WriterUtil};\n \n use std::time;\n \n-use comm::Chan;\n-use comm::Port;\n-use comm::recv;\n-use comm::send;\n+use oldcomm::Chan;\n+use oldcomm::Port;\n+use oldcomm::recv;\n+use oldcomm::send;\n use cmp::Eq;\n use to_bytes::IterBytes;\n "}, {"sha": "98220195e613d90f784fed3cece9ca70e90e79e9", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -12,7 +12,7 @@\n \n extern mod std;\n use std::arc;\n-use comm::*;\n+use oldcomm::*;\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"}, {"sha": "8cb8f31c4897682fd5e9de0b3758c9806441b30d", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,7 +10,7 @@\n \n extern mod std;\n use std::arc;\n-use comm::*;\n+use oldcomm::*;\n \n fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];"}, {"sha": "4dd0df31aab8dad62d560a825d18f40fbb84c7ec", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,20 +10,20 @@\n \n fn main() {\n     struct foo {\n-      _x: comm::Port<()>,\n+      _x: oldcomm::Port<()>,\n     }\n \n     impl foo : Drop {\n         fn finalize(&self) {}\n     }\n \n-    fn foo(x: comm::Port<()>) -> foo {\n+    fn foo(x: oldcomm::Port<()>) -> foo {\n         foo {\n             _x: x\n         }\n     }\n    \n-    let x = ~mut Some(foo(comm::Port()));\n+    let x = ~mut Some(foo(oldcomm::Port()));\n \n     do task::spawn |move x| { //~ ERROR not a sendable value\n         let mut y = None;"}, {"sha": "7f60e3ec87a0320cf2af6b1de66c04d0fa51e378", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -25,7 +25,7 @@ fn foo(i:int, j: @~str) -> foo {\n \n fn main() {\n   let cat = ~\"kitty\";\n-  let po = comm::Port();         //~ ERROR missing `owned`\n-  let ch = comm::Chan(&po);       //~ ERROR missing `owned`\n-  comm::send(ch, foo(42, @(move cat))); //~ ERROR missing `owned`\n+  let po = oldcomm::Port();         //~ ERROR missing `owned`\n+  let ch = oldcomm::Chan(&po);       //~ ERROR missing `owned`\n+  oldcomm::send(ch, foo(42, @(move cat))); //~ ERROR missing `owned`\n }"}, {"sha": "8154329f7ae37fb78fd802e38663aa689c274e35", "filename": "src/test/run-fail/linked-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -12,8 +12,8 @@\n \n // error-pattern:1 == 2\n extern mod std;\n-use comm::Port;\n-use comm::recv;\n+use oldcomm::Port;\n+use oldcomm::recv;\n \n fn child() { assert (1 == 2); }\n "}, {"sha": "1a95118d0a61f569d18386ca3931e668b38bb3d2", "filename": "src/test/run-fail/linked-failure2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Flinked-failure2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure2.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -12,9 +12,9 @@\n \n // error-pattern:fail\n extern mod std;\n-use comm::Chan;\n-use comm::Port;\n-use comm::recv;\n+use oldcomm::Chan;\n+use oldcomm::Port;\n+use oldcomm::recv;\n \n fn child() { fail; }\n "}, {"sha": "5df06ff6f81f81e6668c7776229719163acd221e", "filename": "src/test/run-fail/linked-failure3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Flinked-failure3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure3.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -12,8 +12,8 @@\n \n // error-pattern:fail\n extern mod std;\n-use comm::Port;\n-use comm::recv;\n+use oldcomm::Port;\n+use oldcomm::recv;\n \n fn grandchild() { fail ~\"grandchild dies\"; }\n "}, {"sha": "ea9c9f22e220bb20ec07e88bff70b18e158094a4", "filename": "src/test/run-fail/linked-failure4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Flinked-failure4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure4.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -11,9 +11,9 @@\n \n // error-pattern:1 == 2\n extern mod std;\n-use comm::Chan;\n-use comm::Port;\n-use comm::recv;\n+use oldcomm::Chan;\n+use oldcomm::Port;\n+use oldcomm::recv;\n \n fn child() { assert (1 == 2); }\n "}, {"sha": "bd1541302a40f5369cd262b996e05215fdb531ea", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,10 +10,10 @@\n \n // error-pattern:meep\n extern mod std;\n-use comm::Chan;\n-use comm::Port;\n-use comm::send;\n-use comm::recv;\n+use oldcomm::Chan;\n+use oldcomm::Port;\n+use oldcomm::send;\n+use oldcomm::recv;\n \n fn echo<T: Owned>(c: Chan<T>, oc: Chan<Chan<T>>) {\n     // Tests that the type argument in port gets"}, {"sha": "6c70dd09d57fcf615dd3f5b2b6a4afe01f235273", "filename": "src/test/run-fail/task-comm-recv-block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-comm-recv-block.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -19,9 +19,9 @@ fn goodfail() {\n \n fn main() {\n     task::spawn(|| goodfail() );\n-    let po = comm::Port();\n+    let po = oldcomm::Port();\n     // We shouldn't be able to get past this recv since there's no\n     // message available\n-    let i: int = comm::recv(po);\n+    let i: int = oldcomm::recv(po);\n     fail ~\"badfail\";\n }"}, {"sha": "8f31520557379d682f5b598e6ccf494cd9bcbb6a", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -13,14 +13,14 @@\n \n extern mod std;\n \n-fn f(c: comm::_chan<int>) {\n+fn f(c: oldcomm::_chan<int>) {\n     type t = {_0: int, _1: int, _2: int};\n \n     // Allocate a box.\n     let x: @t = @{_0: 1, _1: 2, _2: 3};\n \n     // Signal parent that we've allocated a box.\n-    comm::send(c, 1);\n+    oldcomm::send(c, 1);\n \n \n     loop {\n@@ -31,12 +31,12 @@ fn f(c: comm::_chan<int>) {\n         // sending to the channel are never received\n         // by the parent, therefore this test cases drops\n         // messages on the floor\n-        comm::send(c, 1);\n+        oldcomm::send(c, 1);\n     }\n }\n \n fn main() {\n-    let p = comm::mk_port();\n+    let p = oldcomm::mk_port();\n     task::_spawn(bind f(p.mk_chan()));\n     let i: int;\n "}, {"sha": "1a0ba61eb19851387b08ae5ed98e8f94b92359a2", "filename": "src/test/run-pass/auto_serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -15,7 +15,7 @@\n extern mod std;\n \n // These tests used to be separate files, but I wanted to refactor all\n-// the common code.\n+// the oldcommon code.\n \n use cmp::Eq;\n use std::ebml;"}, {"sha": "7f7da086df30ce042e169db9bd9131c142f21daa", "filename": "src/test/run-pass/basic-1.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fbasic-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-1.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,25 +10,25 @@\n // except according to those terms.\n \n \n-fn a(c: core::comm::Chan<int>) { core::comm::send(c, 10); }\n+fn a(c: core::oldcomm::Chan<int>) { core::oldcomm::send(c, 10); }\n \n fn main() {\n-    let p = core::comm::Port();\n-    let ch = core::comm::Chan(&p);\n+    let p = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&p);\n     task::spawn(|| a(ch) );\n     task::spawn(|| a(ch) );\n     let mut n: int = 0;\n-    n = core::comm::recv(p);\n-    n = core::comm::recv(p);\n+    n = core::oldcomm::recv(p);\n+    n = core::oldcomm::recv(p);\n     //    debug!(\"Finished.\");\n }\n \n-fn b(c: core::comm::Chan<int>) {\n+fn b(c: core::oldcomm::Chan<int>) {\n     //    debug!(\"task b0\");\n     //    debug!(\"task b1\");\n     //    debug!(\"task b2\");\n     //    debug!(\"task b3\");\n     //    debug!(\"task b4\");\n     //    debug!(\"task b5\");\n-    core::comm::send(c, 10);\n+    core::oldcomm::send(c, 10);\n }"}, {"sha": "36ed4c5162b67f611313333a8ceb83420c863cc1", "filename": "src/test/run-pass/basic-2.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fbasic-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic-2.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,28 +10,28 @@\n // except according to those terms.\n \n \n-fn a(c: core::comm::Chan<int>) {\n+fn a(c: core::oldcomm::Chan<int>) {\n     debug!(\"task a0\");\n     debug!(\"task a1\");\n-    core::comm::send(c, 10);\n+    core::oldcomm::send(c, 10);\n }\n \n fn main() {\n-    let p = core::comm::Port();\n-    let ch = core::comm::Chan(&p);\n+    let p = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&p);\n     task::spawn(|| a(ch) );\n     task::spawn(|| b(ch) );\n     let mut n: int = 0;\n-    n = core::comm::recv(p);\n-    n = core::comm::recv(p);\n+    n = core::oldcomm::recv(p);\n+    n = core::oldcomm::recv(p);\n     debug!(\"Finished.\");\n }\n \n-fn b(c: core::comm::Chan<int>) {\n+fn b(c: core::oldcomm::Chan<int>) {\n     debug!(\"task b0\");\n     debug!(\"task b1\");\n     debug!(\"task b2\");\n     debug!(\"task b2\");\n     debug!(\"task b3\");\n-    core::comm::send(c, 10);\n+    core::oldcomm::send(c, 10);\n }"}, {"sha": "a84bfdcdbb7ee4c8acd585357f6753534ccc9fec", "filename": "src/test/run-pass/basic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,15 +10,15 @@\n // except according to those terms.\n \n \n-fn a(c: core::comm::Chan<int>) {\n+fn a(c: core::oldcomm::Chan<int>) {\n     if true {\n         debug!(\"task a\");\n         debug!(\"task a\");\n         debug!(\"task a\");\n         debug!(\"task a\");\n         debug!(\"task a\");\n     }\n-    core::comm::send(c, 10);\n+    core::oldcomm::send(c, 10);\n }\n \n fn k(x: int) -> int { return 15; }\n@@ -33,19 +33,19 @@ fn g(x: int, y: ~str) -> int {\n fn main() {\n     let mut n: int = 2 + 3 * 7;\n     let s: ~str = ~\"hello there\";\n-    let p = comm::Port();\n-    let ch = core::comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&p);\n     task::spawn(|| a(ch) );\n     task::spawn(|| b(ch) );\n     let mut x: int = 10;\n     x = g(n, s);\n     log(debug, x);\n-    n = core::comm::recv(p);\n-    n = core::comm::recv(p);\n+    n = core::oldcomm::recv(p);\n+    n = core::oldcomm::recv(p);\n     debug!(\"children finished, root finishing\");\n }\n \n-fn b(c: core::comm::Chan<int>) {\n+fn b(c: core::oldcomm::Chan<int>) {\n     if true {\n         debug!(\"task b\");\n         debug!(\"task b\");\n@@ -54,5 +54,5 @@ fn b(c: core::comm::Chan<int>) {\n         debug!(\"task b\");\n         debug!(\"task b\");\n     }\n-    core::comm::send(c, 10);\n+    core::oldcomm::send(c, 10);\n }"}, {"sha": "8f9049ac27b2baa7c8f6186ab83c891b75d68d3a", "filename": "src/test/run-pass/capture_nil.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture_nil.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -24,9 +24,9 @@\n // course preferable, as the value itself is\n // irrelevant).\n \n-fn foo(&&x: ()) -> core::comm::Port<()> {\n-    let p = core::comm::Port();\n-    let c = core::comm::Chan(&p);\n+fn foo(&&x: ()) -> core::oldcomm::Port<()> {\n+    let p = core::oldcomm::Port();\n+    let c = core::oldcomm::Chan(&p);\n     do task::spawn() |copy c, copy x| {\n         c.send(x);\n     }"}, {"sha": "be64fcd8992fade591095fa24403042d740af9ca", "filename": "src/test/run-pass/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcci_capture_clause.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -18,7 +18,7 @@\n \n extern mod cci_capture_clause;\n \n-use comm::recv;\n+use oldcomm::recv;\n \n fn main() {\n     cci_capture_clause::foo(()).recv()"}, {"sha": "bb429a07f39dbc5ea0b9bdf777b8402cf735aac7", "filename": "src/test/run-pass/chan-leak.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fchan-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchan-leak.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,32 +10,32 @@\n \n // Issue #763\n \n-enum request { quit, close(core::comm::Chan<bool>), }\n+enum request { quit, close(core::oldcomm::Chan<bool>), }\n \n-type ctx = core::comm::Chan<request>;\n+type ctx = core::oldcomm::Chan<request>;\n \n-fn request_task(c: core::comm::Chan<ctx>) {\n-    let p = core::comm::Port();\n-    core::comm::send(c, core::comm::Chan(&p));\n+fn request_task(c: core::oldcomm::Chan<ctx>) {\n+    let p = core::oldcomm::Port();\n+    core::oldcomm::send(c, core::oldcomm::Chan(&p));\n     let mut req: request;\n-    req = core::comm::recv(p);\n+    req = core::oldcomm::recv(p);\n     // Need to drop req before receiving it again\n-    req = core::comm::recv(p);\n+    req = core::oldcomm::recv(p);\n }\n \n fn new_cx() -> ctx {\n-    let p = core::comm::Port();\n-    let ch = core::comm::Chan(&p);\n+    let p = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&p);\n     let t = task::spawn(|| request_task(ch) );\n     let mut cx: ctx;\n-    cx = core::comm::recv(p);\n+    cx = core::oldcomm::recv(p);\n     return cx;\n }\n \n fn main() {\n     let cx = new_cx();\n \n-    let p = core::comm::Port::<bool>();\n-    core::comm::send(cx, close(core::comm::Chan(&p)));\n-    core::comm::send(cx, quit);\n+    let p = core::oldcomm::Port::<bool>();\n+    core::oldcomm::send(cx, close(core::oldcomm::Chan(&p)));\n+    core::oldcomm::send(cx, quit);\n }"}, {"sha": "453ae679523191f378ef8d9e296179bd65f786d7", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -11,17 +11,17 @@\n \n \n fn main() {\n-    let p = comm::Port();\n-    let ch = core::comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&p);\n     let t = task::spawn(|| child(ch) );\n-    let y = core::comm::recv(p);\n+    let y = core::oldcomm::recv(p);\n     error!(\"received\");\n     log(error, y);\n     assert (y == 10);\n }\n \n-fn child(c: core::comm::Chan<int>) {\n+fn child(c: core::oldcomm::Chan<int>) {\n     error!(\"sending\");\n-    core::comm::send(c, 10);\n+    core::oldcomm::send(c, 10);\n     error!(\"value sent\");\n }"}, {"sha": "4b4d6a86806d1bc7e812efa75bce5a0f4dda175c", "filename": "src/test/run-pass/decl-with-recv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdecl-with-recv.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -11,12 +11,12 @@\n \n \n fn main() {\n-    let po = core::comm::Port();\n-    let ch = core::comm::Chan(&po);\n-    core::comm::send(ch, 10);\n-    let i = core::comm::recv(po);\n+    let po = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&po);\n+    core::oldcomm::send(ch, 10);\n+    let i = core::oldcomm::recv(po);\n     assert (i == 10);\n-    core::comm::send(ch, 11);\n-    let j = core::comm::recv(po);\n+    core::oldcomm::send(ch, 11);\n+    let j = core::oldcomm::recv(po);\n     assert (j == 11);\n }"}, {"sha": "c8fbb0dd7418ba0a36ef61c4bc814ce7bd392c53", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -20,10 +20,10 @@ extern mod std;\n \n use std::map;\n use std::map::HashMap;\n-use comm::Chan;\n-use comm::Port;\n-use comm::send;\n-use comm::recv;\n+use oldcomm::Chan;\n+use oldcomm::Port;\n+use oldcomm::send;\n+use oldcomm::recv;\n \n fn map(filename: ~str, emit: map_reduce::putter) { emit(filename, ~\"1\"); }\n "}, {"sha": "556e597a86da7c6637433e9c1affc9a306aa0c85", "filename": "src/test/run-pass/issue-507.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fissue-507.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fissue-507.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-507.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -15,19 +15,19 @@\n    https://github.com/graydon/rust/issues/507\n */\n \n-fn grandchild(c: core::comm::Chan<int>) { core::comm::send(c, 42); }\n+fn grandchild(c: core::oldcomm::Chan<int>) { core::oldcomm::send(c, 42); }\n \n-fn child(c: core::comm::Chan<int>) {\n+fn child(c: core::oldcomm::Chan<int>) {\n     task::spawn(|| grandchild(c) )\n }\n \n fn main() {\n-    let p = core::comm::Port();\n-    let ch = core::comm::Chan(&p);\n+    let p = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&p);\n \n     task::spawn(|| child(ch) );\n \n-    let x: int = core::comm::recv(p);\n+    let x: int = core::oldcomm::recv(p);\n \n     log(debug, x);\n "}, {"sha": "9cfec06007c95fd9715109d054bdab9ff2136b6e", "filename": "src/test/run-pass/issue-687.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fissue-687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fissue-687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-687.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,45 +10,45 @@\n \n enum msg { closed, received(~[u8]), }\n \n-fn producer(c: core::comm::Chan<~[u8]>) {\n-    core::comm::send(c, ~[1u8, 2u8, 3u8, 4u8]);\n+fn producer(c: core::oldcomm::Chan<~[u8]>) {\n+    core::oldcomm::send(c, ~[1u8, 2u8, 3u8, 4u8]);\n     let empty: ~[u8] = ~[];\n-    core::comm::send(c, empty);\n+    core::oldcomm::send(c, empty);\n }\n \n-fn packager(cb: core::comm::Chan<core::comm::Chan<~[u8]>>, msg: core::comm::Chan<msg>) {\n-    let p: core::comm::Port<~[u8]> = core::comm::Port();\n-    core::comm::send(cb, core::comm::Chan(&p));\n+fn packager(cb: core::oldcomm::Chan<core::oldcomm::Chan<~[u8]>>, msg: core::oldcomm::Chan<msg>) {\n+    let p: core::oldcomm::Port<~[u8]> = core::oldcomm::Port();\n+    core::oldcomm::send(cb, core::oldcomm::Chan(&p));\n     loop {\n         debug!(\"waiting for bytes\");\n-        let data = core::comm::recv(p);\n+        let data = core::oldcomm::recv(p);\n         debug!(\"got bytes\");\n         if vec::len(data) == 0u {\n             debug!(\"got empty bytes, quitting\");\n             break;\n         }\n         debug!(\"sending non-empty buffer of length\");\n         log(debug, vec::len(data));\n-        core::comm::send(msg, received(data));\n+        core::oldcomm::send(msg, received(data));\n         debug!(\"sent non-empty buffer\");\n     }\n     debug!(\"sending closed message\");\n-    core::comm::send(msg, closed);\n+    core::oldcomm::send(msg, closed);\n     debug!(\"sent closed message\");\n }\n \n fn main() {\n-    let p: core::comm::Port<msg> = core::comm::Port();\n-    let ch = core::comm::Chan(&p);\n-    let recv_reader: core::comm::Port<core::comm::Chan<~[u8]>> = core::comm::Port();\n-    let recv_reader_chan = core::comm::Chan(&recv_reader);\n+    let p: core::oldcomm::Port<msg> = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&p);\n+    let recv_reader: core::oldcomm::Port<core::oldcomm::Chan<~[u8]>> = core::oldcomm::Port();\n+    let recv_reader_chan = core::oldcomm::Chan(&recv_reader);\n     let pack = task::spawn(|| packager(recv_reader_chan, ch) );\n \n-    let source_chan: core::comm::Chan<~[u8]> = core::comm::recv(recv_reader);\n+    let source_chan: core::oldcomm::Chan<~[u8]> = core::oldcomm::recv(recv_reader);\n     let prod = task::spawn(|| producer(source_chan) );\n \n     loop {\n-        let msg = core::comm::recv(p);\n+        let msg = core::oldcomm::recv(p);\n         match msg {\n           closed => { debug!(\"Got close message\"); break; }\n           received(data) => {"}, {"sha": "3820ff770227cedbab120a3cc1e9aadee95c48b9", "filename": "src/test/run-pass/issue-783.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fissue-783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fissue-783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-783.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,14 +10,14 @@\n \n fn a() {\n     fn doit() {\n-        fn b(c: core::comm::Chan<core::comm::Chan<int>>) {\n-            let p = core::comm::Port();\n-            core::comm::send(c, core::comm::Chan(&p));\n+        fn b(c: core::oldcomm::Chan<core::oldcomm::Chan<int>>) {\n+            let p = core::oldcomm::Port();\n+            core::oldcomm::send(c, core::oldcomm::Chan(&p));\n         }\n-        let p = core::comm::Port();\n-        let ch = core::comm::Chan(&p);\n+        let p = core::oldcomm::Port();\n+        let ch = core::oldcomm::Chan(&p);\n         task::spawn(|| b(ch) );\n-        core::comm::recv(p);\n+        core::oldcomm::recv(p);\n     }\n     let mut i = 0;\n     while i < 100 {"}, {"sha": "7066b5f63cd60d774fb5caf627b4062ec99e8736", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -1,13 +1,13 @@\n-fn producer(c: core::comm::Chan<~[u8]>) {\n-    core::comm::send(c,\n+fn producer(c: core::oldcomm::Chan<~[u8]>) {\n+    core::oldcomm::send(c,\n          ~[1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8,\n           13u8]);\n }\n \n fn main() {\n-    let p: core::comm::Port<~[u8]> = core::comm::Port();\n-    let ch = core::comm::Chan(&p);\n+    let p: core::oldcomm::Port<~[u8]> = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&p);\n     let prod = task::spawn(|| producer(ch) );\n \n-    let data: ~[u8] = core::comm::recv(p);\n+    let data: ~[u8] = core::oldcomm::recv(p);\n }"}, {"sha": "34244c2ef01cbb7501887764346f6acb91f59dba", "filename": "src/test/run-pass/lazychan.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,21 +10,21 @@\n // except according to those terms.\n \n fn main() {\n-    let p = core::comm::Port();\n-    let ch = core::comm::Chan(&p);\n+    let p = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&p);\n     let mut y: int;\n \n     task::spawn(|| child(ch) );\n-    y = core::comm::recv(p);\n+    y = core::oldcomm::recv(p);\n     debug!(\"received 1\");\n     log(debug, y);\n     assert (y == 10);\n \n     task::spawn(|| child(ch) );\n-    y = core::comm::recv(p);\n+    y = core::oldcomm::recv(p);\n     debug!(\"received 2\");\n     log(debug, y);\n     assert (y == 10);\n }\n \n-fn child(c: core::comm::Chan<int>) { core::comm::send(c, 10); }\n+fn child(c: core::oldcomm::Chan<int>) { core::oldcomm::send(c, 10); }"}, {"sha": "23153b79cd94bc35489b32686121211fb577a9db", "filename": "src/test/run-pass/many.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -12,23 +12,23 @@\n \n extern mod std;\n \n-fn sub(parent: comm::Chan<int>, id: int) {\n+fn sub(parent: oldcomm::Chan<int>, id: int) {\n     if id == 0 {\n-        comm::send(parent, 0);\n+        oldcomm::send(parent, 0);\n     } else {\n-        let p = comm::Port();\n-        let ch = comm::Chan(&p);\n+        let p = oldcomm::Port();\n+        let ch = oldcomm::Chan(&p);\n         let child = task::spawn(|| sub(ch, id - 1) );\n-        let y = comm::recv(p);\n-        comm::send(parent, y + 1);\n+        let y = oldcomm::recv(p);\n+        oldcomm::send(parent, y + 1);\n     }\n }\n \n fn main() {\n-    let p = comm::Port();\n-    let ch = comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let ch = oldcomm::Chan(&p);\n     let child = task::spawn(|| sub(ch, 200) );\n-    let y = comm::recv(p);\n+    let y = oldcomm::recv(p);\n     debug!(\"transmission complete\");\n     log(debug, y);\n     assert (y == 200);"}, {"sha": "993dea560cf2aaa26845011bad5e6e1c140bc476", "filename": "src/test/run-pass/multiline-comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fmultiline-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fmultiline-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmultiline-comment.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -11,6 +11,6 @@\n \n \n /*\n- * This is a multi-line comment.\n+ * This is a multi-line oldcomment.\n  */\n fn main() { }"}, {"sha": "dca62e0f9dffa6e6a9c72a15308f2a80a25e4920", "filename": "src/test/run-pass/rt-circular-buffer.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-circular-buffer.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -13,7 +13,7 @@\n // Regression tests for circular_buffer when using a unit\n // that has a size that is not a power of two\n \n-// A 12-byte unit to core::comm::send over the channel\n+// A 12-byte unit to core::oldcomm::send over the channel\n type record = {val1: u32, val2: u32, val3: u32};\n \n \n@@ -22,52 +22,52 @@ type record = {val1: u32, val2: u32, val3: u32};\n // power of two so needs to be rounded up. Don't trigger any\n // assertions.\n fn test_init() {\n-    let myport = core::comm::Port();\n-    let mychan = core::comm::Chan(&myport);\n+    let myport = core::oldcomm::Port();\n+    let mychan = core::oldcomm::Chan(&myport);\n     let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n-    core::comm::send(mychan, val);\n+    core::oldcomm::send(mychan, val);\n }\n \n \n // Dump lots of items into the channel so it has to grow.\n // Don't trigger any assertions.\n fn test_grow() {\n-    let myport = core::comm::Port();\n-    let mychan = core::comm::Chan(&myport);\n+    let myport = core::oldcomm::Port();\n+    let mychan = core::oldcomm::Chan(&myport);\n     for uint::range(0u, 100u) |i| {\n         let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n-        core::comm::send(mychan, val);\n+        core::oldcomm::send(mychan, val);\n     }\n }\n \n \n // Don't allow the buffer to shrink below it's original size\n fn test_shrink1() {\n-    let myport = core::comm::Port();\n-    let mychan = core::comm::Chan(&myport);\n-    core::comm::send(mychan, 0i8);\n-    let x = core::comm::recv(myport);\n+    let myport = core::oldcomm::Port();\n+    let mychan = core::oldcomm::Chan(&myport);\n+    core::oldcomm::send(mychan, 0i8);\n+    let x = core::oldcomm::recv(myport);\n }\n \n fn test_shrink2() {\n-    let myport = core::comm::Port();\n-    let mychan = core::comm::Chan(&myport);\n+    let myport = core::oldcomm::Port();\n+    let mychan = core::oldcomm::Chan(&myport);\n     for uint::range(0u, 100u) |_i| {\n         let val: record = {val1: 0u32, val2: 0u32, val3: 0u32};\n-        core::comm::send(mychan, val);\n+        core::oldcomm::send(mychan, val);\n     }\n-    for uint::range(0u, 100u) |_i| { let x = core::comm::recv(myport); }\n+    for uint::range(0u, 100u) |_i| { let x = core::oldcomm::recv(myport); }\n }\n \n \n // Test rotating the buffer when the unit size is not a power of two\n fn test_rotate() {\n-    let myport = core::comm::Port();\n-    let mychan = core::comm::Chan(&myport);\n+    let myport = core::oldcomm::Port();\n+    let mychan = core::oldcomm::Chan(&myport);\n     for uint::range(0u, 100u) |i| {\n         let val = {val1: i as u32, val2: i as u32, val3: i as u32};\n-        core::comm::send(mychan, val);\n-        let x = core::comm::recv(myport);\n+        core::oldcomm::send(mychan, val);\n+        let x = core::oldcomm::recv(myport);\n         assert (x.val1 == i as u32);\n         assert (x.val2 == i as u32);\n         assert (x.val3 == i as u32);\n@@ -78,16 +78,16 @@ fn test_rotate() {\n // Test rotating and growing the buffer when\n // the unit size is not a power of two\n fn test_rotate_grow() {\n-    let myport = core::comm::Port::<record>();\n-    let mychan = core::comm::Chan(&myport);\n+    let myport = core::oldcomm::Port::<record>();\n+    let mychan = core::oldcomm::Chan(&myport);\n     for uint::range(0u, 10u) |j| {\n         for uint::range(0u, 10u) |i| {\n             let val: record =\n                 {val1: i as u32, val2: i as u32, val3: i as u32};\n-            core::comm::send(mychan, val);\n+            core::oldcomm::send(mychan, val);\n         }\n         for uint::range(0u, 10u) |i| {\n-            let x = core::comm::recv(myport);\n+            let x = core::oldcomm::recv(myport);\n             assert (x.val1 == i as u32);\n             assert (x.val2 == i as u32);\n             assert (x.val3 == i as u32);"}, {"sha": "09f9bee75276acec5f0e0b0dae156cd278fc5add", "filename": "src/test/run-pass/rt-sched-1.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Frt-sched-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frt-sched-1.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -25,8 +25,8 @@ extern mod rustrt {\n }\n \n fn main() unsafe {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n     let parent_sched_id = rustrt::rust_get_sched_id();\n     error!(\"parent %?\", parent_sched_id);\n     let num_threads = 1u;\n@@ -39,10 +39,10 @@ fn main() unsafe {\n         error!(\"child_sched_id %?\", child_sched_id);\n         assert child_sched_id != parent_sched_id;\n         assert child_sched_id == new_sched_id;\n-        comm::send(ch, ());\n+        oldcomm::send(ch, ());\n     };\n     let fptr = cast::reinterpret_cast(&ptr::addr_of(&f));\n     rustrt::start_task(new_task_id, fptr);\n     cast::forget(move f);\n-    comm::recv(po);\n+    oldcomm::recv(po);\n }"}, {"sha": "6e6c64f4533cb6d6efb8083de2c3b6af7f578b4d", "filename": "src/test/run-pass/send-iloop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsend-iloop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-iloop.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -17,13 +17,13 @@ fn die() {\n \n fn iloop() {\n     task::spawn(|| die() );\n-    let p = comm::Port::<()>();\n-    let c = comm::Chan(&p);\n+    let p = oldcomm::Port::<()>();\n+    let c = oldcomm::Chan(&p);\n     loop {\n         // Sending and receiving here because these actions yield,\n         // at which point our child can kill us\n-        comm::send(c, ());\n-        comm::recv(p);\n+        oldcomm::send(c, ());\n+        oldcomm::recv(p);\n     }\n }\n "}, {"sha": "a85b01acc8eddb6016893f7b242b19d1428bbc7e", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -23,12 +23,12 @@ fn test(f: int) -> test {\n }\n \n fn main() {\n-    let p = core::comm::Port();\n-    let c = core::comm::Chan(&p);\n+    let p = core::oldcomm::Port();\n+    let c = core::oldcomm::Chan(&p);\n \n     do task::spawn() {\n-        let p = core::comm::Port();\n-        c.send(core::comm::Chan(&p));\n+        let p = core::oldcomm::Port();\n+        c.send(core::oldcomm::Chan(&p));\n \n         let _r = p.recv();\n     }"}, {"sha": "8476e256cd24cf2e505051a19a3c8787ad738ec5", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -11,8 +11,8 @@\n // tests that ctrl's type gets inferred properly\n type command<K: Owned, V: Owned> = {key: K, val: V};\n \n-fn cache_server<K: Owned, V: Owned>(c: core::comm::Chan<core::comm::Chan<command<K, V>>>) {\n-    let ctrl = core::comm::Port();\n-    core::comm::send(c, core::comm::Chan(&ctrl));\n+fn cache_server<K: Owned, V: Owned>(c: oldcomm::Chan<oldcomm::Chan<command<K, V>>>) {\n+    let ctrl = oldcomm::Port();\n+    oldcomm::send(c, oldcomm::Chan(&ctrl));\n }\n fn main() { }"}, {"sha": "e027bddb8f189b13e7d58b22d10aaa6da0d54c7c", "filename": "src/test/run-pass/sendable-class.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendable-class.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -23,7 +23,7 @@ fn foo(i:int, j: char) -> foo {\n }\n \n fn main() {\n-  let po = comm::Port::<foo>();\n-  let ch = comm::Chan(&po);\n-  comm::send(ch, foo(42, 'c'));\n+  let po = oldcomm::Port::<foo>();\n+  let ch = oldcomm::Chan(&po);\n+  oldcomm::send(ch, foo(42, 'c'));\n }\n\\ No newline at end of file"}, {"sha": "1a6cf7e04cccad98759802ab8c8e356863956d4a", "filename": "src/test/run-pass/sendfn-generic-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-generic-fn.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -13,8 +13,8 @@\n \n extern mod std;\n \n-use comm::Chan;\n-use comm::send;\n+use oldcomm::Chan;\n+use oldcomm::send;\n \n fn main() { test05(); }\n "}, {"sha": "78914f0531f8a5d745929961d7506f5871161199", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -17,14 +17,14 @@\n extern mod std;\n \n \n-type ctx = comm::Chan<int>;\n+type ctx = oldcomm::Chan<int>;\n \n fn iotask(cx: ctx, ip: ~str) {\n     assert (ip == ~\"localhost\");\n }\n \n fn main() {\n-    let p = comm::Port::<int>();\n-    let ch = comm::Chan(&p);\n+    let p = oldcomm::Port::<int>();\n+    let ch = oldcomm::Chan(&p);\n     task::spawn(|| iotask(ch, ~\"localhost\") );\n }"}, {"sha": "f2c0c807e82ff2a4d62ef2f129e969639f33f343", "filename": "src/test/run-pass/task-comm-chan-cleanup.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -11,7 +11,7 @@\n extern mod std;\n \n fn main() {\n-    let p = comm::Port();\n-    let c = comm::Chan(&p);\n-    comm::send(c, ~\"coffee\");\n+    let p = oldcomm::Port();\n+    let c = oldcomm::Chan(&p);\n+    oldcomm::send(c, ~\"coffee\");\n }\n\\ No newline at end of file"}, {"sha": "f2c0c807e82ff2a4d62ef2f129e969639f33f343", "filename": "src/test/run-pass/task-comm-chan-cleanup2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup2.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -11,7 +11,7 @@\n extern mod std;\n \n fn main() {\n-    let p = comm::Port();\n-    let c = comm::Chan(&p);\n-    comm::send(c, ~\"coffee\");\n+    let p = oldcomm::Port();\n+    let c = oldcomm::Chan(&p);\n+    oldcomm::send(c, ~\"coffee\");\n }\n\\ No newline at end of file"}, {"sha": "23b87fb7352026296aa8fedd77566c403f7cbf72", "filename": "src/test/run-pass/task-comm-chan-cleanup3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup3.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -12,8 +12,8 @@ extern mod std;\n \n fn main() {\n     let c = {\n-        let p = comm::Port();\n-        comm::Chan(&p)\n+        let p = oldcomm::Port();\n+        oldcomm::Chan(&p)\n     };\n-    comm::send(c, ~\"coffee\");\n+    oldcomm::send(c, ~\"coffee\");\n }\n\\ No newline at end of file"}, {"sha": "2afdcc6326807bade7a71b71a03e3c80ce9f37bd", "filename": "src/test/run-pass/task-comm-chan-cleanup4.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-cleanup4.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -13,16 +13,16 @@ extern mod std;\n // We're trying to trigger a race between send and port destruction that\n // results in the string not being freed\n \n-fn starship(&&ch: comm::Chan<~str>) {\n+fn starship(&&ch: oldcomm::Chan<~str>) {\n     for int::range(0, 10) |_i| {\n-        comm::send(ch, ~\"pew pew\");\n+        oldcomm::send(ch, ~\"pew pew\");\n     }\n }\n \n fn starbase() {\n     for int::range(0, 10) |_i| {\n-        let p = comm::Port();\n-        let c = comm::Chan(&p);\n+        let p = oldcomm::Port();\n+        let c = oldcomm::Chan(&p);\n         task::spawn(|| starship(c) );\n         task::yield();\n     }"}, {"sha": "620262065a5c980cad9d035466605e2373e16f35", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -16,9 +16,9 @@ extern mod std;\n // any size, but rustc currently can because they do have size. Whether\n // or not this is desirable I don't know, but here's a regression test.\n fn main() {\n-    let po = comm::Port();\n-    let ch = comm::Chan(&po);\n-    comm::send(ch, ());\n-    let n: () = comm::recv(po);\n+    let po = oldcomm::Port();\n+    let ch = oldcomm::Chan(&po);\n+    oldcomm::send(ch, ());\n+    let n: () = oldcomm::recv(po);\n     assert (n == ());\n }"}, {"sha": "d95f4af791c654d8fda8f67936b573330cdc6f76", "filename": "src/test/run-pass/task-comm.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -17,12 +17,12 @@ fn main() {\n     test06();\n }\n \n-fn test00_start(ch: core::comm::Chan<int>, message: int, count: int) {\n+fn test00_start(ch: core::oldcomm::Chan<int>, message: int, count: int) {\n     debug!(\"Starting test00_start\");\n     let mut i: int = 0;\n     while i < count {\n         debug!(\"Sending Message\");\n-        core::comm::send(ch, message + 0);\n+        core::oldcomm::send(ch, message + 0);\n         i = i + 1;\n     }\n     debug!(\"Ending test00_start\");\n@@ -33,8 +33,8 @@ fn test00() {\n     let number_of_messages: int = 4;\n     debug!(\"Creating tasks\");\n \n-    let po = core::comm::Port();\n-    let ch = core::comm::Chan(&po);\n+    let po = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&po);\n \n     let mut i: int = 0;\n \n@@ -50,7 +50,7 @@ fn test00() {\n     let mut sum: int = 0;\n     for results.each |r| {\n         i = 0;\n-        while i < number_of_messages { sum += core::comm::recv(po); i = i + 1; }\n+        while i < number_of_messages { sum += core::oldcomm::recv(po); i = i + 1; }\n     }\n \n     for results.each |r| { r.recv(); }\n@@ -63,19 +63,19 @@ fn test00() {\n }\n \n fn test01() {\n-    let p = core::comm::Port();\n+    let p = core::oldcomm::Port();\n     debug!(\"Reading from a port that is never written to.\");\n-    let value: int = core::comm::recv(p);\n+    let value: int = core::oldcomm::recv(p);\n     log(debug, value);\n }\n \n fn test02() {\n-    let p = core::comm::Port();\n-    let c = core::comm::Chan(&p);\n+    let p = core::oldcomm::Port();\n+    let c = core::oldcomm::Chan(&p);\n     debug!(\"Writing to a local task channel.\");\n-    core::comm::send(c, 42);\n+    core::oldcomm::send(c, 42);\n     debug!(\"Reading from a local task port.\");\n-    let value: int = core::comm::recv(p);\n+    let value: int = core::oldcomm::recv(p);\n     log(debug, value);\n }\n \n@@ -93,22 +93,22 @@ fn test04() {\n     debug!(\"Finishing up.\");\n }\n \n-fn test05_start(ch: core::comm::Chan<int>) {\n-    core::comm::send(ch, 10);\n-    core::comm::send(ch, 20);\n-    core::comm::send(ch, 30);\n-    core::comm::send(ch, 30);\n-    core::comm::send(ch, 30);\n+fn test05_start(ch: core::oldcomm::Chan<int>) {\n+    core::oldcomm::send(ch, 10);\n+    core::oldcomm::send(ch, 20);\n+    core::oldcomm::send(ch, 30);\n+    core::oldcomm::send(ch, 30);\n+    core::oldcomm::send(ch, 30);\n }\n \n fn test05() {\n-    let po = core::comm::Port();\n-    let ch = core::comm::Chan(&po);\n+    let po = core::oldcomm::Port();\n+    let ch = core::oldcomm::Chan(&po);\n     task::spawn(|| test05_start(ch) );\n     let mut value: int;\n-    value = core::comm::recv(po);\n-    value = core::comm::recv(po);\n-    value = core::comm::recv(po);\n+    value = core::oldcomm::recv(po);\n+    value = core::oldcomm::recv(po);\n+    value = core::oldcomm::recv(po);\n     log(debug, value);\n }\n "}, {"sha": "fd45910ee88faca6e2d3fa5899195f71d2c1deb4", "filename": "src/test/run-pass/task-compare.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-compare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-compare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-compare.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -18,7 +18,7 @@ extern mod std;\n fn child() { }\n \n struct notify {\n-    ch: comm::Chan<bool>, v: @mut bool,\n+    ch: oldcomm::Chan<bool>, v: @mut bool,\n }\n \n impl notify : Drop {\n@@ -29,19 +29,19 @@ impl notify : Drop {\n                task::failing(),\n                *(self.v));\n         let b = *(self.v);\n-        comm::send(self.ch, b);\n+        oldcomm::send(self.ch, b);\n     }\n }\n \n-fn notify(ch: comm::Chan<bool>, v: @mut bool) -> notify {\n+fn notify(ch: oldcomm::Chan<bool>, v: @mut bool) -> notify {\n     notify {\n         ch: ch,\n         v: v\n     }\n }\n \n-fn joinable(+f: fn~()) -> comm::Port<bool> {\n-    fn wrapper(+c: comm::Chan<bool>, +f: fn()) {\n+fn joinable(+f: fn~()) -> oldcomm::Port<bool> {\n+    fn wrapper(+c: oldcomm::Chan<bool>, +f: fn()) {\n         let b = @mut false;\n         error!(\"wrapper: task=%? allocated v=%x\",\n                task::get_task(),\n@@ -50,14 +50,14 @@ fn joinable(+f: fn~()) -> comm::Port<bool> {\n         f();\n         *b = true;\n     }\n-    let p = comm::Port();\n-    let c = comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let c = oldcomm::Chan(&p);\n     do task::spawn_unlinked { wrapper(c, copy f) };\n     p\n }\n \n-fn join(port: comm::Port<bool>) -> bool {\n-    comm::recv(port)\n+fn join(port: oldcomm::Port<bool>) -> bool {\n+    oldcomm::recv(port)\n }\n \n fn main() {\n@@ -76,15 +76,15 @@ fn main() {\n     let p1;\n     let p2;\n \n-    p1 = comm::Port::<int>();\n-    p2 = comm::Port::<int>();\n+    p1 = oldcomm::Port::<int>();\n+    p2 = oldcomm::Port::<int>();\n \n     assert (p1 == p1);\n     assert (p1 != p2);\n \n     // channels\n-    let c1 = comm::Chan(p1);\n-    let c2 = comm::Chan(p2);\n+    let c1 = oldcomm::Chan(p1);\n+    let c2 = oldcomm::Chan(p2);\n \n     assert (c1 == c1);\n     assert (c1 != c2);"}, {"sha": "029bab51770d4449594f7202d980df0e8781b1fb", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -14,7 +14,7 @@\n // the join.\n \n struct notify {\n-    ch: comm::Chan<bool>, v: @mut bool,\n+    ch: oldcomm::Chan<bool>, v: @mut bool,\n }\n \n impl notify : Drop {\n@@ -25,19 +25,19 @@ impl notify : Drop {\n                task::failing(),\n                *(self.v));\n         let b = *(self.v);\n-        comm::send(self.ch, b);\n+        oldcomm::send(self.ch, b);\n     }\n }\n \n-fn notify(ch: comm::Chan<bool>, v: @mut bool) -> notify {\n+fn notify(ch: oldcomm::Chan<bool>, v: @mut bool) -> notify {\n     notify {\n         ch: ch,\n         v: v\n     }\n }\n \n-fn joinable(+f: fn~()) -> comm::Port<bool> {\n-    fn wrapper(+c: comm::Chan<bool>, +f: fn()) {\n+fn joinable(+f: fn~()) -> oldcomm::Port<bool> {\n+    fn wrapper(+c: oldcomm::Chan<bool>, +f: fn()) {\n         let b = @mut false;\n         error!(\"wrapper: task=%? allocated v=%x\",\n                task::get_task(),\n@@ -46,14 +46,14 @@ fn joinable(+f: fn~()) -> comm::Port<bool> {\n         f();\n         *b = true;\n     }\n-    let p = comm::Port();\n-    let c = comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let c = oldcomm::Chan(&p);\n     do task::spawn_unlinked { wrapper(c, f) };\n     p\n }\n \n-fn join(port: comm::Port<bool>) -> bool {\n-    comm::recv(port)\n+fn join(port: oldcomm::Port<bool>) -> bool {\n+    oldcomm::recv(port)\n }\n \n fn supervised() {"}, {"sha": "4ee2413ab197ee42424060c6ab46b6c23bff472c", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n fn main() {\n-    let p = comm::Port::<uint>();\n-    let ch = comm::Chan(&p);\n+    let p = oldcomm::Port::<uint>();\n+    let ch = oldcomm::Chan(&p);\n \n     let x = ~1;\n     let x_in_parent = ptr::addr_of(&(*x)) as uint;\n@@ -20,17 +20,17 @@ fn main() {\n \n     task::spawn(fn~(copy ch, copy y, move x) {\n         let x_in_child = ptr::addr_of(&(*x)) as uint;\n-        comm::send(ch, x_in_child);\n+        oldcomm::send(ch, x_in_child);\n \n         let y_in_child = ptr::addr_of(&(*y)) as uint;\n-        comm::send(ch, y_in_child);\n+        oldcomm::send(ch, y_in_child);\n     });\n     // Ensure last-use analysis doesn't move y to child.\n     let _q = y;\n \n-    let x_in_child = comm::recv(p);\n+    let x_in_child = oldcomm::recv(p);\n     assert x_in_parent == x_in_child;\n \n-    let y_in_child = comm::recv(p);\n+    let y_in_child = oldcomm::recv(p);\n     assert y_in_parent != y_in_child;\n }"}, {"sha": "c1709f2ca23d10f18bb59819a62deb01b20f7ea8", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -10,13 +10,13 @@\n \n extern mod std;\n \n-fn child(c: comm::Chan<~uint>, i: uint) {\n-    comm::send(c, ~i);\n+fn child(c: oldcomm::Chan<~uint>, i: uint) {\n+    oldcomm::send(c, ~i);\n }\n \n fn main() {\n-    let p = comm::Port();\n-    let ch = comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let ch = oldcomm::Chan(&p);\n     let n = 100u;\n     let mut expected = 0u;\n     for uint::range(0u, n) |i| {\n@@ -26,7 +26,7 @@ fn main() {\n \n     let mut actual = 0u;\n     for uint::range(0u, n) |_i| {\n-        let j = comm::recv(p);\n+        let j = oldcomm::recv(p);\n         actual += *j;\n     }\n "}, {"sha": "6bbfabc875703b2cdf464991f5bebe2761cfa819", "filename": "src/test/run-pass/unique-send.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -11,9 +11,9 @@\n extern mod std;\n \n fn main() {\n-    let p = comm::Port();\n-    let c = comm::Chan(&p);\n-    comm::send(c, ~100);\n-    let v = comm::recv(p);\n+    let p = oldcomm::Port();\n+    let c = oldcomm::Chan(&p);\n+    oldcomm::send(c, ~100);\n+    let v = oldcomm::recv(p);\n     assert v == ~100;\n }\n\\ No newline at end of file"}, {"sha": "263ac090c99c3c900185b610599d5ee0940a34e2", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -12,33 +12,33 @@\n extern mod std;\n \n struct complainer {\n-  c: comm::Chan<bool>,\n+  c: oldcomm::Chan<bool>,\n }\n \n impl complainer : Drop {\n     fn finalize(&self) {\n         error!(\"About to send!\");\n-        comm::send(self.c, true);\n+        oldcomm::send(self.c, true);\n         error!(\"Sent!\");\n     }\n }\n \n-fn complainer(c: comm::Chan<bool>) -> complainer {\n+fn complainer(c: oldcomm::Chan<bool>) -> complainer {\n     error!(\"Hello!\");\n     complainer {\n         c: c\n     }\n }\n \n-fn f(c: comm::Chan<bool>) {\n+fn f(c: oldcomm::Chan<bool>) {\n     let _c = move complainer(c);\n     fail;\n }\n \n fn main() {\n-    let p = comm::Port();\n-    let c = comm::Chan(&p);\n+    let p = oldcomm::Port();\n+    let c = oldcomm::Chan(&p);\n     task::spawn_unlinked(|| f(c) );\n     error!(\"hiiiiiiiii\");\n-    assert comm::recv(p);\n+    assert oldcomm::recv(p);\n }"}, {"sha": "86df25d54963fa1d5f2793745336977cc7f5fab7", "filename": "src/test/run-pass/variant-attributes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fvariant-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d1b02359f4535c23af1059fcd48d18814fcb46/src%2Ftest%2Frun-pass%2Fvariant-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvariant-attributes.rs?ref=e6d1b02359f4535c23af1059fcd48d18814fcb46", "patch": "@@ -15,7 +15,7 @@ enum crew_of_enterprise_d {\n     #[captain]\n     jean_luc_picard,\n \n-    #[commander]\n+    #[oldcommander]\n     william_t_riker,\n \n     #[chief_medical_officer]\n@@ -24,7 +24,7 @@ enum crew_of_enterprise_d {\n     #[ships_councellor]\n     deanna_troi,\n \n-    #[lieutenant_commander]\n+    #[lieutenant_oldcommander]\n     data,\n \n     #[chief_of_security]"}]}