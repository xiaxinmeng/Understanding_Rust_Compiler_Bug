{"sha": "817576ee7001244da68a4ee315ebdc1163d4e648", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNzU3NmVlNzAwMTI0NGRhNjhhNGVlMzE1ZWJkYzExNjNkNGU2NDg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-17T06:34:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-18T18:07:22Z"}, "message": "Register new snapshots", "tree": {"sha": "ffa6ecd790e899105cfa3f2c2da1b4520a062f72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffa6ecd790e899105cfa3f2c2da1b4520a062f72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/817576ee7001244da68a4ee315ebdc1163d4e648", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/817576ee7001244da68a4ee315ebdc1163d4e648", "html_url": "https://github.com/rust-lang/rust/commit/817576ee7001244da68a4ee315ebdc1163d4e648", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/817576ee7001244da68a4ee315ebdc1163d4e648/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e02313a172acca34bd29e10cdd10f7495664694e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e02313a172acca34bd29e10cdd10f7495664694e", "html_url": "https://github.com/rust-lang/rust/commit/e02313a172acca34bd29e10cdd10f7495664694e"}], "stats": {"total": 1695, "additions": 32, "deletions": 1663}, "files": [{"sha": "43a4ecf56168f6a36139eadc7a8acc1491db2a13", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -137,16 +137,6 @@ fn list_dir_sorted(path: &Path) -> ~[Path] {\n /**\n  * A compiled Unix shell style pattern.\n  */\n-#[cfg(stage0)]\n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes)]\n-pub struct Pattern {\n-    priv tokens: ~[PatternToken]\n-}\n-\n-/**\n- * A compiled Unix shell style pattern.\n- */\n-#[cfg(not(stage0))]\n #[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Default)]\n pub struct Pattern {\n     priv tokens: ~[PatternToken]\n@@ -465,39 +455,10 @@ fn is_sep(c: char) -> bool {\n     }\n }\n \n-/**\n- * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n- */\n-#[cfg(stage0)]\n-#[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes)]\n-pub struct MatchOptions {\n-\n-    /**\n-     * Whether or not patterns should be matched in a case-sensitive manner. This\n-     * currently only considers upper/lower case relationships between ASCII characters,\n-     * but in future this might be extended to work with Unicode.\n-     */\n-    case_sensitive: bool,\n-\n-    /**\n-     * If this is true then path-component separator characters (e.g. `/` on Posix)\n-     * must be matched by a literal `/`, rather than by `*` or `?` or `[...]`\n-     */\n-    require_literal_separator: bool,\n-\n-    /**\n-     * If this is true then paths that contain components that start with a `.` will\n-     * not match unless the `.` appears literally in the pattern: `*`, `?` or `[...]`\n-     * will not match. This is useful because such files are conventionally considered\n-     * hidden on Unix systems and it might be desirable to skip them when listing files.\n-     */\n-    require_literal_leading_dot: bool\n-}\n \n /**\n  * Configuration options to modify the behaviour of `Pattern::matches_with(..)`\n  */\n-#[cfg(not(stage0))]\n #[deriving(Clone, Eq, TotalEq, Ord, TotalOrd, IterBytes, Default)]\n pub struct MatchOptions {\n "}, {"sha": "9476bcb8926ee705e9a119c3fea47dc0343b850c", "filename": "src/libextra/rl.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibextra%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibextra%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frl.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -13,25 +13,6 @@ use std::libc::{c_char, c_int};\n use std::{local_data, str, rt};\n use std::unstable::finally::Finally;\n \n-#[cfg(stage0)]\n-pub mod rustrt {\n-    use std::libc::{c_char, c_int};\n-\n-    extern {\n-        fn linenoise(prompt: *c_char) -> *c_char;\n-        fn linenoiseHistoryAdd(line: *c_char) -> c_int;\n-        fn linenoiseHistorySetMaxLen(len: c_int) -> c_int;\n-        fn linenoiseHistorySave(file: *c_char) -> c_int;\n-        fn linenoiseHistoryLoad(file: *c_char) -> c_int;\n-        fn linenoiseSetCompletionCallback(callback: *u8);\n-        fn linenoiseAddCompletion(completions: *(), line: *c_char);\n-\n-        fn rust_take_linenoise_lock();\n-        fn rust_drop_linenoise_lock();\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub mod rustrt {\n     use std::libc::{c_char, c_int};\n \n@@ -109,7 +90,7 @@ pub fn read(prompt: &str) -> Option<~str> {\n \n pub type CompletionCb = @fn(~str, @fn(~str));\n \n-static complete_key: local_data::Key<CompletionCb> = &local_data::Key;\n+local_data_key!(complete_key: CompletionCb)\n \n /// Bind to the main completion callback in the current task.\n ///"}, {"sha": "ee7fbed9e9f1183846e4cd515f93aa75bef2c22f", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -190,7 +190,7 @@ pub mod jit {\n \n     // The stage1 compiler won't work, but that doesn't really matter. TLS\n     // changed only very recently to allow storage of owned values.\n-    static engine_key: local_data::Key<~Engine> = &local_data::Key;\n+    local_data_key!(engine_key: ~Engine)\n \n     fn set_engine(engine: ~Engine) {\n         local_data::set(engine_key, engine)"}, {"sha": "49176c7bc17d53559ab858c81fd85b40092c0303", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -293,50 +293,6 @@ fn mk_std(cx: &TestCtxt) -> ast::view_item {\n     }\n }\n \n-#[cfg(stage0)]\n-fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n-\n-    // Link to extra\n-    let view_items = ~[mk_std(cx)];\n-\n-    // A constant vector of test descriptors.\n-    let tests = mk_tests(cx);\n-\n-    // The synthesized main function which will call the console test runner\n-    // with our list of tests\n-    let ext_cx = cx.ext_cx;\n-    let mainfn = (quote_item!(\n-        pub fn main() {\n-            #[main];\n-            extra::test::test_main_static(::std::os::args(), TESTS);\n-        }\n-    )).unwrap();\n-\n-    let testmod = ast::_mod {\n-        view_items: view_items,\n-        items: ~[mainfn, tests],\n-    };\n-    let item_ = ast::item_mod(testmod);\n-\n-    // This attribute tells resolve to let us call unexported functions\n-    let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(@\"!resolve_unexported\"));\n-\n-    let item = ast::item {\n-        ident: cx.sess.ident_of(\"__test\"),\n-        attrs: ~[resolve_unexported_attr],\n-        id: ast::DUMMY_NODE_ID,\n-        node: item_,\n-        vis: ast::public,\n-        span: dummy_sp(),\n-     };\n-\n-    debug!(\"Synthetic test module:\\n%s\\n\",\n-           pprust::item_to_str(@item.clone(), cx.sess.intr()));\n-\n-    return @item;\n-}\n-#[cfg(not(stage0))]\n fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n \n     // Link to extra\n@@ -407,21 +363,6 @@ fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n     }\n }\n \n-#[cfg(stage0)]\n-fn mk_tests(cx: &TestCtxt) -> @ast::item {\n-\n-    let ext_cx = cx.ext_cx;\n-\n-    // The vector of test_descs for this crate\n-    let test_descs = mk_test_descs(cx);\n-\n-    (quote_item!(\n-        pub static TESTS : &'static [self::extra::test::TestDescAndFn] =\n-            $test_descs\n-        ;\n-    )).unwrap()\n-}\n-#[cfg(not(stage0))]\n fn mk_tests(cx: &TestCtxt) -> @ast::item {\n     // The vector of test_descs for this crate\n     let test_descs = mk_test_descs(cx);\n@@ -461,63 +402,6 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n     }\n }\n \n-#[cfg(stage0)]\n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n-    let span = test.span;\n-    let path = test.path.clone();\n-\n-    let ext_cx = cx.ext_cx;\n-\n-    debug!(\"encoding %s\", ast_util::path_name_i(path));\n-\n-    let name_lit: ast::lit =\n-        nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));\n-\n-    let name_expr = @ast::Expr {\n-          id: ast::DUMMY_NODE_ID,\n-          node: ast::ExprLit(@name_lit),\n-          span: span\n-    };\n-\n-    let fn_path = path_node_global(path);\n-\n-    let fn_expr = @ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprPath(fn_path),\n-        span: span,\n-    };\n-\n-    let t_expr = if test.bench {\n-        quote_expr!( self::extra::test::StaticBenchFn($fn_expr) )\n-    } else {\n-        quote_expr!( self::extra::test::StaticTestFn($fn_expr) )\n-    };\n-\n-    let ignore_expr = if test.ignore {\n-        quote_expr!( true )\n-    } else {\n-        quote_expr!( false )\n-    };\n-\n-    let fail_expr = if test.should_fail {\n-        quote_expr!( true )\n-    } else {\n-        quote_expr!( false )\n-    };\n-\n-    let e = quote_expr!(\n-        self::extra::test::TestDescAndFn {\n-            desc: self::extra::test::TestDesc {\n-                name: self::extra::test::StaticTestName($name_expr),\n-                ignore: $ignore_expr,\n-                should_fail: $fail_expr\n-            },\n-            testfn: $t_expr,\n-        }\n-    );\n-    e\n-}\n-#[cfg(not(stage0))]\n fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();"}, {"sha": "4c679798bce54d11f083eb79f566338d7a909bb3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -92,7 +92,7 @@ use syntax::visit::Visitor;\n \n pub use middle::trans::context::task_llcx;\n \n-static task_local_insn_key: local_data::Key<@~[&'static str]> = &local_data::Key;\n+local_data_key!(task_local_insn_key: @~[&'static str])\n \n pub fn with_insn_ctxt(blk: &fn(&[&'static str])) {\n     let opt = local_data::get(task_local_insn_key, |k| k.map_move(|k| *k));"}, {"sha": "e342bcaf4faf7e6663c6b72d0393aad710c2cb6b", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -287,7 +287,7 @@ impl Drop for CrateContext {\n     }\n }\n \n-static task_local_llcx_key: local_data::Key<@ContextRef> = &local_data::Key;\n+local_data_key!(task_local_llcx_key: @ContextRef)\n \n pub fn task_llcx() -> ContextRef {\n     let opt = local_data::get(task_local_llcx_key, |k| k.map_move(|k| *k));"}, {"sha": "4deaa458f194fd059b2fbbd252a58719f1c6ab49", "filename": "src/librusti/program.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -60,7 +60,7 @@ struct LocalVariable {\n }\n \n type LocalCache = @mut HashMap<~str, @~[u8]>;\n-static tls_key: local_data::Key<LocalCache> = &local_data::Key;\n+local_data_key!(tls_key: LocalCache)\n \n impl Program {\n     pub fn new() -> Program {"}, {"sha": "67b5aff8466047cce860aa4cde4da2334fbe9df4", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -30,9 +30,7 @@ pub enum NullByteResolution {\n \n condition! {\n     // This should be &[u8] but there's a lifetime issue (#5370).\n-    // NOTE: this super::NullByteResolution should be NullByteResolution\n-    // Change this next time the snapshot is updated.\n-    pub null_byte: (~[u8]) -> super::NullByteResolution;\n+    pub null_byte: (~[u8]) -> NullByteResolution;\n }\n \n /// The representation of a C String."}, {"sha": "1a463a499cb41bedee4d31e88e58094bea708b08", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -37,17 +37,6 @@ pub fn console_off() {\n     rt::logging::console_off();\n }\n \n-#[cfg(not(test), stage0)]\n-#[lang=\"log_type\"]\n-#[allow(missing_doc)]\n-pub fn log_type<T>(_level: u32, object: &T) {\n-    use sys;\n-\n-    // XXX: Bad allocation\n-    let msg = sys::log_str(object);\n-    newsched_log_str(msg);\n-}\n-\n fn newsched_log_str(msg: ~str) {\n     use rt::task::Task;\n     use rt::local::Local;"}, {"sha": "e58acf70ca4603190f23d0ade5f12cd330f08b7e", "filename": "src/libstd/os.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -148,18 +148,6 @@ pub mod win32 {\n     }\n }\n \n-#[cfg(stage0)]\n-mod macro_hack {\n-#[macro_escape];\n-macro_rules! externfn(\n-    (fn $name:ident ()) => (\n-        extern {\n-            fn $name();\n-        }\n-    )\n-)\n-}\n-\n /*\n Accessing environment variables is not generally threadsafe.\n Serialize access through a global lock."}, {"sha": "135acb106a17872227acfbd53cec62e3d4c93851", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 4, "deletions": 83, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -16,39 +16,20 @@ use clone::Clone;\n use cmp::Equiv;\n use iter::{range, Iterator};\n use option::{Option, Some, None};\n-#[cfg(stage0)]\n-use sys;\n use unstable::intrinsics;\n use util::swap;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n \n-/// Calculate the offset from a pointer. The count *must* be in bounds or\n-/// otherwise the loads of this address are undefined.\n-#[inline]\n-#[cfg(stage0)]\n-pub unsafe fn offset<T>(ptr: *T, count: int) -> *T {\n-    (ptr as uint + (count as uint) * sys::size_of::<T>()) as *T\n-}\n-\n-/// Calculate the offset from a mut pointer\n-#[inline]\n-#[cfg(stage0)]\n-pub unsafe fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n-    (ptr as uint + (count as uint) * sys::size_of::<T>()) as *mut T\n-}\n-\n /// Calculate the offset from a pointer\n #[inline]\n-#[cfg(not(stage0))]\n pub unsafe fn offset<T>(ptr: *T, count: int) -> *T {\n     intrinsics::offset(ptr, count)\n }\n \n /// Calculate the offset from a mut pointer. The count *must* be in bounds or\n /// otherwise the loads of this address are undefined.\n #[inline]\n-#[cfg(not(stage0))]\n pub unsafe fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     intrinsics::offset(ptr as *T, count) as *mut T\n }\n@@ -383,17 +364,7 @@ impl<T> RawPtr<T> for *mut T {\n }\n \n // Equality for pointers\n-#[cfg(stage0, not(test))]\n-impl<T> Eq for *T {\n-    #[inline]\n-    fn eq(&self, other: &*T) -> bool {\n-        (*self as uint) == (*other as uint)\n-    }\n-    #[inline]\n-    fn ne(&self, other: &*T) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(not(stage0), not(test))]\n+#[cfg(not(test))]\n impl<T> Eq for *T {\n     #[inline]\n     fn eq(&self, other: &*T) -> bool {\n@@ -403,17 +374,7 @@ impl<T> Eq for *T {\n     fn ne(&self, other: &*T) -> bool { !self.eq(other) }\n }\n \n-#[cfg(stage0, not(test))]\n-impl<T> Eq for *mut T {\n-    #[inline]\n-    fn eq(&self, other: &*mut T) -> bool {\n-        (*self as uint) == (*other as uint)\n-    }\n-    #[inline]\n-    fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n-}\n-\n-#[cfg(not(stage0), not(test))]\n+#[cfg(not(test))]\n impl<T> Eq for *mut T {\n     #[inline]\n     fn eq(&self, other: &*mut T) -> bool {\n@@ -480,27 +441,7 @@ mod externfnpointers {\n }\n \n // Comparison for pointers\n-#[cfg(stage0, not(test))]\n-impl<T> Ord for *T {\n-    #[inline]\n-    fn lt(&self, other: &*T) -> bool {\n-        (*self as uint) < (*other as uint)\n-    }\n-    #[inline]\n-    fn le(&self, other: &*T) -> bool {\n-        (*self as uint) <= (*other as uint)\n-    }\n-    #[inline]\n-    fn ge(&self, other: &*T) -> bool {\n-        (*self as uint) >= (*other as uint)\n-    }\n-    #[inline]\n-    fn gt(&self, other: &*T) -> bool {\n-        (*self as uint) > (*other as uint)\n-    }\n-}\n-\n-#[cfg(not(stage0), not(test))]\n+#[cfg(not(test))]\n impl<T> Ord for *T {\n     #[inline]\n     fn lt(&self, other: &*T) -> bool {\n@@ -520,27 +461,7 @@ impl<T> Ord for *T {\n     }\n }\n \n-#[cfg(stage0, not(test))]\n-impl<T> Ord for *mut T {\n-    #[inline]\n-    fn lt(&self, other: &*mut T) -> bool {\n-        (*self as uint) < (*other as uint)\n-    }\n-    #[inline]\n-    fn le(&self, other: &*mut T) -> bool {\n-        (*self as uint) <= (*other as uint)\n-    }\n-    #[inline]\n-    fn ge(&self, other: &*mut T) -> bool {\n-        (*self as uint) >= (*other as uint)\n-    }\n-    #[inline]\n-    fn gt(&self, other: &*mut T) -> bool {\n-        (*self as uint) > (*other as uint)\n-    }\n-}\n-\n-#[cfg(not(stage0), not(test))]\n+#[cfg(not(test))]\n impl<T> Ord for *mut T {\n     #[inline]\n     fn lt(&self, other: &*mut T) -> bool {"}, {"sha": "8ca247edb595823ef27d77805e315cbe2a8fe30b", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -915,7 +915,7 @@ pub fn seed() -> ~[u8] {\n }\n \n // used to make space in TLS for a random number generator\n-static tls_rng_state: local_data::Key<@@mut IsaacRng> = &local_data::Key;\n+local_data_key!(tls_rng_state: @@mut IsaacRng)\n \n /**\n  * Gives back a lazily initialized task-local random number generator,"}, {"sha": "56e0f83e05cf0ea722ae87f93a52dd82f474da9a", "filename": "src/libstd/reflect_stage0.rs", "status": "removed", "additions": 0, "deletions": 493, "changes": 493, "blob_url": "https://github.com/rust-lang/rust/blob/e02313a172acca34bd29e10cdd10f7495664694e/src%2Flibstd%2Freflect_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02313a172acca34bd29e10cdd10f7495664694e/src%2Flibstd%2Freflect_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect_stage0.rs?ref=e02313a172acca34bd29e10cdd10f7495664694e", "patch": "@@ -1,493 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Runtime type reflection\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use unstable::intrinsics::{Opaque, TyDesc, TyVisitor};\n-use libc::c_void;\n-use sys;\n-use unstable::raw;\n-\n-/**\n- * Trait for visitor that wishes to reflect on data. To use this, create a\n- * struct that encapsulates the set of pointers you wish to walk through a\n- * data structure, and implement both `MovePtr` for it as well as `TyVisitor`;\n- * then build a MovePtrAdaptor wrapped around your struct.\n- */\n-pub trait MovePtr {\n-    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void);\n-    fn push_ptr(&self);\n-    fn pop_ptr(&self);\n-}\n-\n-/// Helper function for alignment calculation.\n-#[inline]\n-pub fn align(size: uint, align: uint) -> uint {\n-    ((size + align) - 1u) & !(align - 1u)\n-}\n-\n-/// Adaptor to wrap around visitors implementing MovePtr.\n-pub struct MovePtrAdaptor<V> {\n-    inner: V\n-}\n-pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n-    MovePtrAdaptor { inner: v }\n-}\n-\n-impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n-    #[inline]\n-    pub fn bump(&self, sz: uint) {\n-        do self.inner.move_ptr() |p| {\n-            ((p as uint) + sz) as *c_void\n-        };\n-    }\n-\n-    #[inline]\n-    pub fn align(&self, a: uint) {\n-        do self.inner.move_ptr() |p| {\n-            align(p as uint, a) as *c_void\n-        };\n-    }\n-\n-    #[inline]\n-    pub fn align_to<T>(&self) {\n-        self.align(sys::min_align_of::<T>());\n-    }\n-\n-    #[inline]\n-    pub fn bump_past<T>(&self) {\n-        self.bump(sys::size_of::<T>());\n-    }\n-}\n-\n-/// Abstract type-directed pointer-movement using the MovePtr trait\n-impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n-    fn visit_bot(&self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_bot() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_nil(&self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_nil() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_bool(&self) -> bool {\n-        self.align_to::<bool>();\n-        if ! self.inner.visit_bool() { return false; }\n-        self.bump_past::<bool>();\n-        true\n-    }\n-\n-    fn visit_int(&self) -> bool {\n-        self.align_to::<int>();\n-        if ! self.inner.visit_int() { return false; }\n-        self.bump_past::<int>();\n-        true\n-    }\n-\n-    fn visit_i8(&self) -> bool {\n-        self.align_to::<i8>();\n-        if ! self.inner.visit_i8() { return false; }\n-        self.bump_past::<i8>();\n-        true\n-    }\n-\n-    fn visit_i16(&self) -> bool {\n-        self.align_to::<i16>();\n-        if ! self.inner.visit_i16() { return false; }\n-        self.bump_past::<i16>();\n-        true\n-    }\n-\n-    fn visit_i32(&self) -> bool {\n-        self.align_to::<i32>();\n-        if ! self.inner.visit_i32() { return false; }\n-        self.bump_past::<i32>();\n-        true\n-    }\n-\n-    fn visit_i64(&self) -> bool {\n-        self.align_to::<i64>();\n-        if ! self.inner.visit_i64() { return false; }\n-        self.bump_past::<i64>();\n-        true\n-    }\n-\n-    fn visit_uint(&self) -> bool {\n-        self.align_to::<uint>();\n-        if ! self.inner.visit_uint() { return false; }\n-        self.bump_past::<uint>();\n-        true\n-    }\n-\n-    fn visit_u8(&self) -> bool {\n-        self.align_to::<u8>();\n-        if ! self.inner.visit_u8() { return false; }\n-        self.bump_past::<u8>();\n-        true\n-    }\n-\n-    fn visit_u16(&self) -> bool {\n-        self.align_to::<u16>();\n-        if ! self.inner.visit_u16() { return false; }\n-        self.bump_past::<u16>();\n-        true\n-    }\n-\n-    fn visit_u32(&self) -> bool {\n-        self.align_to::<u32>();\n-        if ! self.inner.visit_u32() { return false; }\n-        self.bump_past::<u32>();\n-        true\n-    }\n-\n-    fn visit_u64(&self) -> bool {\n-        self.align_to::<u64>();\n-        if ! self.inner.visit_u64() { return false; }\n-        self.bump_past::<u64>();\n-        true\n-    }\n-\n-    fn visit_float(&self) -> bool {\n-        self.align_to::<float>();\n-        if ! self.inner.visit_float() { return false; }\n-        self.bump_past::<float>();\n-        true\n-    }\n-\n-    fn visit_f32(&self) -> bool {\n-        self.align_to::<f32>();\n-        if ! self.inner.visit_f32() { return false; }\n-        self.bump_past::<f32>();\n-        true\n-    }\n-\n-    fn visit_f64(&self) -> bool {\n-        self.align_to::<f64>();\n-        if ! self.inner.visit_f64() { return false; }\n-        self.bump_past::<f64>();\n-        true\n-    }\n-\n-    fn visit_char(&self) -> bool {\n-        self.align_to::<char>();\n-        if ! self.inner.visit_char() { return false; }\n-        self.bump_past::<char>();\n-        true\n-    }\n-\n-    fn visit_estr_box(&self) -> bool {\n-        self.align_to::<@str>();\n-        if ! self.inner.visit_estr_box() { return false; }\n-        self.bump_past::<@str>();\n-        true\n-    }\n-\n-    fn visit_estr_uniq(&self) -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner.visit_estr_uniq() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n-    fn visit_estr_slice(&self) -> bool {\n-        self.align_to::<&'static str>();\n-        if ! self.inner.visit_estr_slice() { return false; }\n-        self.bump_past::<&'static str>();\n-        true\n-    }\n-\n-    fn visit_estr_fixed(&self, n: uint,\n-                        sz: uint,\n-                        align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_estr_fixed(n, sz, align) { return false; }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner.visit_box(mtbl, inner) { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n-        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n-        true\n-    }\n-\n-    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n-        if ! self.inner.visit_uniq_managed(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n-        true\n-    }\n-\n-    fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<*u8>();\n-        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*u8>();\n-        true\n-    }\n-\n-    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&'static u8>();\n-        true\n-    }\n-\n-    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<raw::Vec<()>>();\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@[u8]>();\n-        if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n-        self.bump_past::<@[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[@u8]>();\n-        if ! self.inner.visit_evec_uniq_managed(mtbl, inner) { return false; }\n-        self.bump_past::<~[@u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static [u8]>();\n-        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&'static [u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_enter_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_rec_field(&self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_rec(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_class(&self, n_fields: uint, sz: uint, align: uint)\n-                      -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_class(n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(&self, i: uint, name: &str,\n-                         mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_class(&self, n_fields: uint, sz: uint, align: uint)\n-                      -> bool {\n-        if ! self.inner.visit_leave_class(n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_tup_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_tup(&self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_fn(&self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n-            return false\n-        }\n-        true\n-    }\n-\n-    fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_fn(&self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum(&self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                        sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_enum(n_variants, get_disr, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&self, variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n-        self.inner.push_ptr();\n-        self.bump(offset);\n-        if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n-        self.inner.pop_ptr();\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&self, variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                        sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_trait(&self) -> bool {\n-        self.align_to::<@TyVisitor>();\n-        if ! self.inner.visit_trait() { return false; }\n-        self.bump_past::<@TyVisitor>();\n-        true\n-    }\n-\n-    fn visit_param(&self, i: uint) -> bool {\n-        if ! self.inner.visit_param(i) { return false; }\n-        true\n-    }\n-\n-    fn visit_self(&self) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner.visit_self() { return false; }\n-        self.align_to::<&'static u8>();\n-        true\n-    }\n-\n-    fn visit_type(&self) -> bool {\n-        if ! self.inner.visit_type() { return false; }\n-        true\n-    }\n-\n-    fn visit_opaque_box(&self) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner.visit_opaque_box() { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_closure_ptr(&self, ck: uint) -> bool {\n-        self.align_to::<@fn()>();\n-        if ! self.inner.visit_closure_ptr(ck) { return false; }\n-        self.bump_past::<@fn()>();\n-        true\n-    }\n-}"}, {"sha": "cbce2005141b75cfb1b1fc7d536cb96814235275", "filename": "src/libstd/repr_stage0.rs", "status": "removed", "additions": 0, "deletions": 626, "changes": 626, "blob_url": "https://github.com/rust-lang/rust/blob/e02313a172acca34bd29e10cdd10f7495664694e/src%2Flibstd%2Frepr_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02313a172acca34bd29e10cdd10f7495664694e/src%2Flibstd%2Frepr_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr_stage0.rs?ref=e02313a172acca34bd29e10cdd10f7495664694e", "patch": "@@ -1,626 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-More runtime type reflection\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use cast::transmute;\n-use char;\n-use container::Container;\n-use io::{Writer, WriterUtil};\n-use iter::Iterator;\n-use libc::c_void;\n-use option::{Some, None};\n-use ptr;\n-use reflect;\n-use reflect::{MovePtr, align};\n-use str::StrSlice;\n-use to_str::ToStr;\n-use vec::OwnedVector;\n-use unstable::intrinsics::{Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n-use unstable::raw;\n-\n-#[cfg(test)] use io;\n-\n-/// Helpers\n-\n-trait EscapedCharWriter {\n-    fn write_escaped_char(&self, ch: char);\n-}\n-\n-impl EscapedCharWriter for @Writer {\n-    fn write_escaped_char(&self, ch: char) {\n-        match ch {\n-            '\\t' => self.write_str(\"\\\\t\"),\n-            '\\r' => self.write_str(\"\\\\r\"),\n-            '\\n' => self.write_str(\"\\\\n\"),\n-            '\\\\' => self.write_str(\"\\\\\\\\\"),\n-            '\\'' => self.write_str(\"\\\\'\"),\n-            '\"' => self.write_str(\"\\\\\\\"\"),\n-            '\\x20'..'\\x7e' => self.write_char(ch),\n-            _ => {\n-                do char::escape_unicode(ch) |c| {\n-                    self.write_char(c);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Representations\n-\n-trait Repr {\n-    fn write_repr(&self, writer: @Writer);\n-}\n-\n-impl Repr for () {\n-    fn write_repr(&self, writer: @Writer) { writer.write_str(\"()\"); }\n-}\n-\n-impl Repr for bool {\n-    fn write_repr(&self, writer: @Writer) {\n-        writer.write_str(if *self { \"true\" } else { \"false\" })\n-    }\n-}\n-\n-macro_rules! int_repr(($ty:ident) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: @Writer) {\n-        do ::$ty::to_str_bytes(*self, 10u) |bits| {\n-            writer.write(bits);\n-        }\n-    }\n-}))\n-\n-int_repr!(int)\n-int_repr!(i8)\n-int_repr!(i16)\n-int_repr!(i32)\n-int_repr!(i64)\n-int_repr!(uint)\n-int_repr!(u8)\n-int_repr!(u16)\n-int_repr!(u32)\n-int_repr!(u64)\n-\n-macro_rules! num_repr(($ty:ident) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: @Writer) {\n-        let s = self.to_str();\n-        writer.write(s.as_bytes());\n-    }\n-}))\n-\n-num_repr!(float)\n-num_repr!(f32)\n-num_repr!(f64)\n-\n-// New implementation using reflect::MovePtr\n-\n-enum VariantState {\n-    SearchingFor(int),\n-    Matched,\n-    AlreadyFound\n-}\n-\n-pub struct ReprVisitor {\n-    ptr: @mut *c_void,\n-    ptr_stk: @mut ~[*c_void],\n-    var_stk: @mut ~[VariantState],\n-    writer: @Writer\n-}\n-pub fn ReprVisitor(ptr: *c_void, writer: @Writer) -> ReprVisitor {\n-    ReprVisitor {\n-        ptr: @mut ptr,\n-        ptr_stk: @mut ~[],\n-        var_stk: @mut ~[],\n-        writer: writer,\n-    }\n-}\n-\n-impl MovePtr for ReprVisitor {\n-    #[inline]\n-    fn move_ptr(&self, adjustment: &fn(*c_void) -> *c_void) {\n-        *self.ptr = adjustment(*self.ptr);\n-    }\n-    fn push_ptr(&self) {\n-        self.ptr_stk.push(*self.ptr);\n-    }\n-    fn pop_ptr(&self) {\n-        *self.ptr = self.ptr_stk.pop();\n-    }\n-}\n-\n-impl ReprVisitor {\n-    // Various helpers for the TyVisitor impl\n-\n-    #[inline]\n-    pub fn get<T>(&self, f: &fn(&T)) -> bool {\n-        unsafe {\n-            f(transmute::<*c_void,&T>(*self.ptr));\n-        }\n-        true\n-    }\n-\n-    #[inline]\n-    pub fn visit_inner(&self, inner: *TyDesc) -> bool {\n-        self.visit_ptr_inner(*self.ptr, inner)\n-    }\n-\n-    #[inline]\n-    pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n-        unsafe {\n-            let u = ReprVisitor(ptr, self.writer);\n-            let v = reflect::MovePtrAdaptor(u);\n-            visit_tydesc(inner, @v as @TyVisitor);\n-            true\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn write<T:Repr>(&self) -> bool {\n-        do self.get |v:&T| {\n-            v.write_repr(self.writer);\n-        }\n-    }\n-\n-    pub fn write_escaped_slice(&self, slice: &str) {\n-        self.writer.write_char('\"');\n-        for ch in slice.iter() {\n-            self.writer.write_escaped_char(ch);\n-        }\n-        self.writer.write_char('\"');\n-    }\n-\n-    pub fn write_mut_qualifier(&self, mtbl: uint) {\n-        if mtbl == 0 {\n-            self.writer.write_str(\"mut \");\n-        } else if mtbl == 1 {\n-            // skip, this is ast::m_imm\n-        } else {\n-            assert_eq!(mtbl, 2);\n-            self.writer.write_str(\"const \");\n-        }\n-    }\n-\n-    pub fn write_vec_range(&self,\n-                           _mtbl: uint,\n-                           ptr: *(),\n-                           len: uint,\n-                           inner: *TyDesc)\n-                           -> bool {\n-        let mut p = ptr as *u8;\n-        let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n-        self.writer.write_char('[');\n-        let mut first = true;\n-        let mut left = len;\n-        // unit structs have 0 size, and don't loop forever.\n-        let dec = if sz == 0 {1} else {sz};\n-        while left > 0 {\n-            if first {\n-                first = false;\n-            } else {\n-                self.writer.write_str(\", \");\n-            }\n-            self.visit_ptr_inner(p as *c_void, inner);\n-            unsafe {\n-                p = align(ptr::offset(p, sz as int) as uint, al) as *u8;\n-            }\n-            left -= dec;\n-        }\n-        self.writer.write_char(']');\n-        true\n-    }\n-\n-    pub fn write_unboxed_vec_repr(&self,\n-                                  mtbl: uint,\n-                                  v: &raw::Vec<()>,\n-                                  inner: *TyDesc)\n-                                  -> bool {\n-        self.write_vec_range(mtbl, ptr::to_unsafe_ptr(&v.data),\n-                             v.fill, inner)\n-    }\n-}\n-\n-impl TyVisitor for ReprVisitor {\n-    fn visit_bot(&self) -> bool {\n-        self.writer.write_str(\"!\");\n-        true\n-    }\n-    fn visit_nil(&self) -> bool { self.write::<()>() }\n-    fn visit_bool(&self) -> bool { self.write::<bool>() }\n-    fn visit_int(&self) -> bool { self.write::<int>() }\n-    fn visit_i8(&self) -> bool { self.write::<i8>() }\n-    fn visit_i16(&self) -> bool { self.write::<i16>() }\n-    fn visit_i32(&self) -> bool { self.write::<i32>()  }\n-    fn visit_i64(&self) -> bool { self.write::<i64>() }\n-\n-    fn visit_uint(&self) -> bool { self.write::<uint>() }\n-    fn visit_u8(&self) -> bool { self.write::<u8>() }\n-    fn visit_u16(&self) -> bool { self.write::<u16>() }\n-    fn visit_u32(&self) -> bool { self.write::<u32>() }\n-    fn visit_u64(&self) -> bool { self.write::<u64>() }\n-\n-    fn visit_float(&self) -> bool { self.write::<float>() }\n-    fn visit_f32(&self) -> bool { self.write::<f32>() }\n-    fn visit_f64(&self) -> bool { self.write::<f64>() }\n-\n-    fn visit_char(&self) -> bool {\n-        do self.get::<char> |&ch| {\n-            self.writer.write_char('\\'');\n-            self.writer.write_escaped_char(ch);\n-            self.writer.write_char('\\'');\n-        }\n-    }\n-\n-    fn visit_estr_box(&self) -> bool {\n-        do self.get::<@str> |s| {\n-            self.writer.write_char('@');\n-            self.write_escaped_slice(*s);\n-        }\n-    }\n-    fn visit_estr_uniq(&self) -> bool {\n-        do self.get::<~str> |s| {\n-            self.writer.write_char('~');\n-            self.write_escaped_slice(*s);\n-        }\n-    }\n-    fn visit_estr_slice(&self) -> bool {\n-        do self.get::<&str> |s| {\n-            self.write_escaped_slice(*s);\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_estr_fixed(&self, _n: uint, _sz: uint,\n-                        _align: uint) -> bool { fail!(); }\n-\n-    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('@');\n-        self.write_mut_qualifier(mtbl);\n-        do self.get::<&raw::Box<()>> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, inner);\n-        }\n-    }\n-\n-    fn visit_uniq(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('~');\n-        do self.get::<*c_void> |b| {\n-            self.visit_ptr_inner(*b, inner);\n-        }\n-    }\n-\n-    fn visit_uniq_managed(&self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('~');\n-        do self.get::<&raw::Box<()>> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, inner);\n-        }\n-    }\n-\n-    fn visit_ptr(&self, _mtbl: uint, _inner: *TyDesc) -> bool {\n-        do self.get::<*c_void> |p| {\n-            self.writer.write_str(fmt!(\"(0x%x as *())\",\n-                                       *p as uint));\n-        }\n-    }\n-\n-    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('&');\n-        self.write_mut_qualifier(mtbl);\n-        do self.get::<*c_void> |p| {\n-            self.visit_ptr_inner(*p, inner);\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_vec(&self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }\n-\n-\n-    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<raw::Vec<()>> |b| {\n-            self.write_unboxed_vec_repr(mtbl, b, inner);\n-        }\n-    }\n-\n-    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Box<raw::Vec<()>>> |b| {\n-            self.writer.write_char('@');\n-            self.write_mut_qualifier(mtbl);\n-            self.write_unboxed_vec_repr(mtbl, &b.data, inner);\n-        }\n-    }\n-\n-    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Vec<()>> |b| {\n-            self.writer.write_char('~');\n-            self.write_unboxed_vec_repr(mtbl, *b, inner);\n-        }\n-    }\n-\n-    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Box<raw::Vec<()>>> |b| {\n-            self.writer.write_char('~');\n-            self.write_unboxed_vec_repr(mtbl, &b.data, inner);\n-        }\n-    }\n-\n-    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<raw::Slice<()>> |s| {\n-            self.writer.write_char('&');\n-            self.write_vec_range(mtbl, s.data, s.len, inner);\n-        }\n-    }\n-\n-    fn visit_evec_fixed(&self, _n: uint, sz: uint, _align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<()> |b| {\n-            self.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), sz, inner);\n-        }\n-    }\n-\n-    fn visit_enter_rec(&self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('{');\n-        true\n-    }\n-\n-    fn visit_rec_field(&self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            self.writer.write_str(\", \");\n-        }\n-        self.write_mut_qualifier(mtbl);\n-        self.writer.write_str(name);\n-        self.writer.write_str(\": \");\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_rec(&self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('}');\n-        true\n-    }\n-\n-    fn visit_enter_class(&self, _n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('{');\n-        true\n-    }\n-    fn visit_class_field(&self, i: uint, name: &str,\n-                         mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            self.writer.write_str(\", \");\n-        }\n-        self.write_mut_qualifier(mtbl);\n-        self.writer.write_str(name);\n-        self.writer.write_str(\": \");\n-        self.visit_inner(inner);\n-        true\n-    }\n-    fn visit_leave_class(&self, _n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('}');\n-        true\n-    }\n-\n-    fn visit_enter_tup(&self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('(');\n-        true\n-    }\n-    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            self.writer.write_str(\", \");\n-        }\n-        self.visit_inner(inner);\n-        true\n-    }\n-    fn visit_leave_tup(&self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        if _n_fields == 1 {\n-            self.writer.write_char(',');\n-        }\n-        self.writer.write_char(')');\n-        true\n-    }\n-\n-    fn visit_enter_enum(&self,\n-                        _n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                        _sz: uint,\n-                        _align: uint) -> bool {\n-        let var_stk: &mut ~[VariantState] = self.var_stk;\n-        let disr = unsafe {\n-            get_disr(transmute(*self.ptr))\n-        };\n-        var_stk.push(SearchingFor(disr));\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&self, _variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        let mut write = false;\n-        match self.var_stk.pop() {\n-            SearchingFor(sought) => {\n-                if disr_val == sought {\n-                    self.var_stk.push(Matched);\n-                    write = true;\n-                } else {\n-                    self.var_stk.push(SearchingFor(sought));\n-                }\n-            }\n-            Matched | AlreadyFound => {\n-                self.var_stk.push(AlreadyFound);\n-            }\n-        }\n-\n-        if write {\n-            self.writer.write_str(name);\n-            if n_fields > 0 {\n-                self.writer.write_char('(');\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&self,\n-                                i: uint,\n-                                _offset: uint,\n-                                inner: *TyDesc)\n-                                -> bool {\n-        match self.var_stk[self.var_stk.len() - 1] {\n-            Matched => {\n-                if i != 0 {\n-                    self.writer.write_str(\", \");\n-                }\n-                if ! self.visit_inner(inner) {\n-                    return false;\n-                }\n-            }\n-            _ => ()\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&self, _variant: uint,\n-                                _disr_val: int,\n-                                n_fields: uint,\n-                                _name: &str) -> bool {\n-        match self.var_stk[self.var_stk.len() - 1] {\n-            Matched => {\n-                if n_fields > 0 {\n-                    self.writer.write_char(')');\n-                }\n-            }\n-            _ => ()\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&self,\n-                        _n_variants: uint,\n-                        _get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                        _sz: uint,\n-                        _align: uint)\n-                        -> bool {\n-        let var_stk: &mut ~[VariantState] = self.var_stk;\n-        match var_stk.pop() {\n-            SearchingFor(*) => fail!(\"enum value matched no variant\"),\n-            _ => true\n-        }\n-    }\n-\n-    fn visit_enter_fn(&self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(&self, _i: uint, _mode: uint, _inner: *TyDesc) -> bool {\n-        true\n-    }\n-    fn visit_fn_output(&self, _retstyle: uint, _inner: *TyDesc) -> bool {\n-        true\n-    }\n-    fn visit_leave_fn(&self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-\n-    fn visit_trait(&self) -> bool { true }\n-    fn visit_param(&self, _i: uint) -> bool { true }\n-    fn visit_self(&self) -> bool { true }\n-    fn visit_type(&self) -> bool { true }\n-\n-    fn visit_opaque_box(&self) -> bool {\n-        self.writer.write_char('@');\n-        do self.get::<&raw::Box<()>> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, b.type_desc);\n-        }\n-    }\n-\n-    fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n-}\n-\n-pub fn write_repr<T>(writer: @Writer, object: &T) {\n-    unsafe {\n-        let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n-        let tydesc = get_tydesc::<T>();\n-        let u = ReprVisitor(ptr, writer);\n-        let v = reflect::MovePtrAdaptor(u);\n-        visit_tydesc(tydesc, @v as @TyVisitor)\n-    }\n-}\n-\n-#[cfg(test)]\n-struct P {a: int, b: float}\n-\n-#[test]\n-fn test_repr() {\n-\n-    fn exact_test<T>(t: &T, e:&str) {\n-        let s : &str = io::with_str_writer(|w| write_repr(w, t));\n-        if s != e {\n-            error!(\"expected '%s', got '%s'\",\n-                   e, s);\n-        }\n-        assert_eq!(s, e);\n-    }\n-\n-    exact_test(&10, \"10\");\n-    exact_test(&true, \"true\");\n-    exact_test(&false, \"false\");\n-    exact_test(&1.234, \"1.234\");\n-    exact_test(&(&\"hello\"), \"\\\"hello\\\"\");\n-    exact_test(&(@\"hello\"), \"@\\\"hello\\\"\");\n-    exact_test(&(~\"he\\u10f3llo\"), \"~\\\"he\\\\u10f3llo\\\"\");\n-\n-    exact_test(&(@10), \"@10\");\n-    exact_test(&(@mut 10), \"@10\"); // FIXME: #4210: incorrect\n-    exact_test(&((@mut 10, 2)), \"(@mut 10, 2)\");\n-    exact_test(&(~10), \"~10\");\n-    exact_test(&(&10), \"&10\");\n-    let mut x = 10;\n-    exact_test(&(&mut x), \"&mut 10\");\n-    exact_test(&(@mut [1, 2]), \"@mut [1, 2]\");\n-\n-    exact_test(&(1,), \"(1,)\");\n-    exact_test(&(@[1,2,3,4,5,6,7,8]),\n-               \"@[1, 2, 3, 4, 5, 6, 7, 8]\");\n-    exact_test(&(@[1u8,2u8,3u8,4u8]),\n-               \"@[1, 2, 3, 4]\");\n-    exact_test(&(@[\"hi\", \"there\"]),\n-               \"@[\\\"hi\\\", \\\"there\\\"]\");\n-    exact_test(&(~[\"hi\", \"there\"]),\n-               \"~[\\\"hi\\\", \\\"there\\\"]\");\n-    exact_test(&(&[\"hi\", \"there\"]),\n-               \"&[\\\"hi\\\", \\\"there\\\"]\");\n-    exact_test(&(P{a:10, b:1.234}),\n-               \"{a: 10, b: 1.234}\");\n-    exact_test(&(@P{a:10, b:1.234}),\n-               \"@{a: 10, b: 1.234}\");\n-    exact_test(&(~P{a:10, b:1.234}),\n-               \"~{a: 10, b: 1.234}\");\n-    exact_test(&(10_u8, ~\"hello\"),\n-               \"(10, ~\\\"hello\\\")\");\n-    exact_test(&(10_u16, ~\"hello\"),\n-               \"(10, ~\\\"hello\\\")\");\n-    exact_test(&(10_u32, ~\"hello\"),\n-               \"(10, ~\\\"hello\\\")\");\n-    exact_test(&(10_u64, ~\"hello\"),\n-               \"(10, ~\\\"hello\\\")\");\n-\n-    struct Foo;\n-    exact_test(&(~[Foo, Foo, Foo]), \"~[{}, {}, {}]\");\n-}"}, {"sha": "d8317c34f506b108f4eca35c2bb120b6de67d1b4", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -117,18 +117,6 @@ mod imp {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    mod macro_hack {\n-    #[macro_escape];\n-    macro_rules! externfn(\n-        (fn $name:ident () $(-> $ret_ty:ty),*) => (\n-            extern {\n-                fn $name() $(-> $ret_ty),*;\n-            }\n-        )\n-    )\n-    }\n-\n     externfn!(fn rust_take_global_args_lock())\n     externfn!(fn rust_drop_global_args_lock())\n     externfn!(fn rust_get_global_args_ptr() -> *mut Option<~~[~str]>)"}, {"sha": "7988f640687bdd8d0f3272307a39e71b2b3f9950", "filename": "src/libstd/rt/io/buffered.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -126,7 +126,7 @@ impl<R: Reader> Decorator<R> for BufferedReader<R> {\n \n /// Wraps a Writer and buffers output to it\n ///\n-/// NOTE: `BufferedWriter` will NOT flush its buffer when dropped.\n+/// Note that `BufferedWriter` will NOT flush its buffer when dropped.\n pub struct BufferedWriter<W> {\n     priv inner: W,\n     priv buf: ~[u8],\n@@ -204,7 +204,7 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n \n /// Wraps a Stream and buffers input and output to and from it\n ///\n-/// NOTE: `BufferedStream` will NOT flush its output buffer when dropped.\n+/// Note that `BufferedStream` will NOT flush its output buffer when dropped.\n // FIXME #9155 this should be a newtype struct\n pub struct BufferedStream<S> {\n     priv inner: BufferedReader<InternalBufferedWriter<S>>"}, {"sha": "bfec2e9bdf8023748c648e9e519868ac3e78118d", "filename": "src/libstd/rt/io/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmod.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -388,17 +388,13 @@ impl ToStr for IoErrorKind {\n // XXX: Can't put doc comments on macros\n // Raised by `I/O` operations on error.\n condition! {\n-    // NOTE: this super::IoError should be IoError\n-    // Change this next time the snapshot is updated.\n-    pub io_error: super::IoError -> ();\n+    pub io_error: IoError -> ();\n }\n \n // XXX: Can't put doc comments on macros\n // Raised by `read` on error\n condition! {\n-    // NOTE: this super::IoError should be IoError\n-    // Change this next time the snapshot it updated.\n-    pub read_error: super::IoError -> ();\n+    pub read_error: IoError -> ();\n }\n \n /// Helper for wrapper calls where you want to"}, {"sha": "6df857b8d551716ddb812dc81fa75ed81383be1d", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -198,18 +198,6 @@ pub fn start_on_main_thread(argc: int, argv: **u8, crate_map: *u8, main: ~fn())\n     return exit_code;\n }\n \n-#[cfg(stage0)]\n-mod macro_hack {\n-#[macro_escape];\n-macro_rules! externfn(\n-    (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n-        extern {\n-            fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n-        }\n-    )\n-)\n-}\n-\n /// One-time runtime initialization.\n ///\n /// Initializes global state, including frobbing"}, {"sha": "09bd89ec94a181c36cb1ea9235d999e6d1f5792f", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -444,17 +444,10 @@ impl Unwinder {\n         }\n \n         extern {\n-            #[cfg(not(stage0))]\n             #[rust_stack]\n             fn rust_try(f: extern \"C\" fn(*c_void, *c_void),\n                         code: *c_void,\n                         data: *c_void) -> uintptr_t;\n-\n-            #[cfg(stage0)]\n-            #[rust_stack]\n-            fn rust_try(f: *u8,\n-                        code: *c_void,\n-                        data: *c_void) -> uintptr_t;\n         }\n     }\n \n@@ -490,10 +483,10 @@ mod test {\n     fn tls() {\n         use local_data;\n         do run_in_newsched_task() {\n-            static key: local_data::Key<@~str> = &local_data::Key;\n+            local_data_key!(key: @~str)\n             local_data::set(key, @~\"data\");\n             assert!(*local_data::get(key, |k| k.map_move(|k| *k)).unwrap() == ~\"data\");\n-            static key2: local_data::Key<@~str> = &local_data::Key;\n+            local_data_key!(key2: @~str)\n             local_data::set(key2, @~\"data\");\n             assert!(*local_data::get(key2, |k| k.map_move(|k| *k)).unwrap() == ~\"data\");\n         }"}, {"sha": "9591fc82df40588b431cd3308e94ca12ee9ebe39", "filename": "src/libstd/rt/uv/uvll.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvll.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -31,7 +31,6 @@\n \n use c_str::ToCStr;\n use libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n-#[cfg(not(stage0))]\n use libc::ssize_t;\n use libc::{malloc, free};\n use libc;\n@@ -149,73 +148,33 @@ impl uv_stat_t {\n     }\n }\n \n-#[cfg(stage0)]\n-pub type uv_idle_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_alloc_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_read_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_udp_send_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_udp_recv_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_close_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_walk_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_async_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_connect_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_connection_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_timer_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_write_cb = *u8;\n-#[cfg(stage0)]\n-pub type uv_getaddrinfo_cb = *u8;\n-\n-#[cfg(not(stage0))]\n pub type uv_idle_cb = extern \"C\" fn(handle: *uv_idle_t,\n                                     status: c_int);\n-#[cfg(not(stage0))]\n pub type uv_alloc_cb = extern \"C\" fn(stream: *uv_stream_t,\n                                      suggested_size: size_t) -> uv_buf_t;\n-#[cfg(not(stage0))]\n pub type uv_read_cb = extern \"C\" fn(stream: *uv_stream_t,\n                                     nread: ssize_t,\n                                     buf: uv_buf_t);\n-#[cfg(not(stage0))]\n pub type uv_udp_send_cb = extern \"C\" fn(req: *uv_udp_send_t,\n                                         status: c_int);\n-#[cfg(not(stage0))]\n pub type uv_udp_recv_cb = extern \"C\" fn(handle: *uv_udp_t,\n                                         nread: ssize_t,\n                                         buf: uv_buf_t,\n                                         addr: *sockaddr,\n                                         flags: c_uint);\n-#[cfg(not(stage0))]\n pub type uv_close_cb = extern \"C\" fn(handle: *uv_handle_t);\n-#[cfg(not(stage0))]\n pub type uv_walk_cb = extern \"C\" fn(handle: *uv_handle_t,\n                                     arg: *c_void);\n-#[cfg(not(stage0))]\n pub type uv_async_cb = extern \"C\" fn(handle: *uv_async_t,\n                                      status: c_int);\n-#[cfg(not(stage0))]\n pub type uv_connect_cb = extern \"C\" fn(handle: *uv_connect_t,\n                                        status: c_int);\n-#[cfg(not(stage0))]\n pub type uv_connection_cb = extern \"C\" fn(handle: *uv_connection_t,\n                                           status: c_int);\n-#[cfg(not(stage0))]\n pub type uv_timer_cb = extern \"C\" fn(handle: *uv_timer_t,\n                                      status: c_int);\n-#[cfg(not(stage0))]\n pub type uv_write_cb = extern \"C\" fn(handle: *uv_write_t,\n                                      status: c_int);\n-#[cfg(not(stage0))]\n pub type uv_getaddrinfo_cb = extern \"C\" fn(req: *uv_getaddrinfo_t,\n                                            status: c_int,\n                                            res: *addrinfo);"}, {"sha": "7fdee0a7be64e671ee212f70076ba9fe288b9ed1", "filename": "src/libstd/run.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -736,8 +736,6 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: &fn(*c_void) -> T) -> T {\n             let mut tmps = vec::with_capacity(env.len());\n \n             for pair in env.iter() {\n-                // Use of match here is just to workaround limitations\n-                // in the stage0 irrefutable pattern impl.\n                 let kv = fmt!(\"%s=%s\", pair.first(), pair.second());\n                 tmps.push(kv.to_c_str());\n             }"}, {"sha": "e9d5dd416ade329609e1152541185f9dda4f2afd", "filename": "src/libstd/std.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -179,14 +179,8 @@ pub mod run;\n pub mod sys;\n pub mod cast;\n pub mod fmt;\n-#[cfg(stage0)] #[path = \"repr_stage0.rs\"]\n-pub mod repr;\n-#[cfg(not(stage0))]\n pub mod repr;\n pub mod cleanup;\n-#[cfg(stage0)] #[path = \"reflect_stage0.rs\"]\n-pub mod reflect;\n-#[cfg(not(stage0))]\n pub mod reflect;\n pub mod condition;\n pub mod logging;"}, {"sha": "c315c3f9dfc5e1f87257e83e6ebbe29bf43517df", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -14,8 +14,6 @@\n \n use c_str::ToCStr;\n use cast;\n-#[cfg(stage0)]\n-use io;\n use libc;\n use libc::{c_char, size_t};\n use repr;\n@@ -92,7 +90,6 @@ pub fn refcount<T>(t: @T) -> uint {\n     }\n }\n \n-#[cfg(not(stage0))]\n pub fn log_str<T>(t: &T) -> ~str {\n     use rt::io;\n     use rt::io::Decorator;\n@@ -101,12 +98,6 @@ pub fn log_str<T>(t: &T) -> ~str {\n     repr::write_repr(&mut result as &mut io::Writer, t);\n     str::from_utf8_owned(result.inner())\n }\n-#[cfg(stage0)]\n-pub fn log_str<T>(t: &T) -> ~str {\n-    do io::with_str_writer |w| {\n-        repr::write_repr(w, t)\n-    }\n-}\n \n /// Trait for initiating task failure.\n pub trait FailWithCause {"}, {"sha": "349739a5ea63dfc976fee078764815bead29de83", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 100, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -76,103 +76,7 @@ pub struct TyDesc {\n pub enum Opaque { }\n \n #[lang=\"ty_visitor\"]\n-#[cfg(not(test), stage0)]\n-pub trait TyVisitor {\n-    fn visit_bot(&self) -> bool;\n-    fn visit_nil(&self) -> bool;\n-    fn visit_bool(&self) -> bool;\n-\n-    fn visit_int(&self) -> bool;\n-    fn visit_i8(&self) -> bool;\n-    fn visit_i16(&self) -> bool;\n-    fn visit_i32(&self) -> bool;\n-    fn visit_i64(&self) -> bool;\n-\n-    fn visit_uint(&self) -> bool;\n-    fn visit_u8(&self) -> bool;\n-    fn visit_u16(&self) -> bool;\n-    fn visit_u32(&self) -> bool;\n-    fn visit_u64(&self) -> bool;\n-\n-    fn visit_float(&self) -> bool;\n-    fn visit_f32(&self) -> bool;\n-    fn visit_f64(&self) -> bool;\n-\n-    fn visit_char(&self) -> bool;\n-\n-    fn visit_estr_box(&self) -> bool;\n-    fn visit_estr_uniq(&self) -> bool;\n-    fn visit_estr_slice(&self) -> bool;\n-    fn visit_estr_fixed(&self, n: uint, sz: uint, align: uint) -> bool;\n-\n-    fn visit_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_ptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_rptr(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-\n-    fn visit_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_unboxed_vec(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_evec_box(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_evec_uniq(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_evec_uniq_managed(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_evec_slice(&self, mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_evec_fixed(&self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool;\n-\n-    fn visit_enter_rec(&self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-    fn visit_rec_field(&self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_leave_rec(&self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_class(&self, n_fields: uint,\n-                         sz: uint, align: uint) -> bool;\n-    fn visit_class_field(&self, i: uint, name: &str,\n-                         mtbl: uint, inner: *TyDesc) -> bool;\n-    fn visit_leave_class(&self, n_fields: uint,\n-                         sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_tup(&self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-    fn visit_tup_field(&self, i: uint, inner: *TyDesc) -> bool;\n-    fn visit_leave_tup(&self, n_fields: uint,\n-                       sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_enum(&self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                        sz: uint, align: uint) -> bool;\n-    fn visit_enter_enum_variant(&self, variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool;\n-    fn visit_enum_variant_field(&self, i: uint, offset: uint, inner: *TyDesc) -> bool;\n-    fn visit_leave_enum_variant(&self, variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool;\n-    fn visit_leave_enum(&self, n_variants: uint,\n-                        get_disr: extern unsafe fn(ptr: *Opaque) -> int,\n-                        sz: uint, align: uint) -> bool;\n-\n-    fn visit_enter_fn(&self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool;\n-    fn visit_fn_input(&self, i: uint, mode: uint, inner: *TyDesc) -> bool;\n-    fn visit_fn_output(&self, retstyle: uint, inner: *TyDesc) -> bool;\n-    fn visit_leave_fn(&self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool;\n-\n-    fn visit_trait(&self) -> bool;\n-    fn visit_param(&self, i: uint) -> bool;\n-    fn visit_self(&self) -> bool;\n-    fn visit_type(&self) -> bool;\n-    fn visit_opaque_box(&self) -> bool;\n-    fn visit_closure_ptr(&self, ck: uint) -> bool;\n-}\n-\n-#[lang=\"ty_visitor\"]\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n pub trait TyVisitor {\n     fn visit_bot(&mut self) -> bool;\n     fn visit_nil(&mut self) -> bool;\n@@ -424,9 +328,6 @@ extern \"rust-intrinsic\" {\n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n     pub fn contains_managed<T>() -> bool;\n \n-    #[cfg(stage0)]\n-    pub fn visit_tydesc(td: *TyDesc, tv: &TyVisitor);\n-    #[cfg(not(stage0))]\n     pub fn visit_tydesc(td: *TyDesc, tv: &mut TyVisitor);\n \n     pub fn frame_address(f: &once fn(*u8));"}, {"sha": "c2ef2300fc261673ef7c49ff7b15a3b35ddcf13a", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -411,23 +411,6 @@ impl<T:Send> Exclusive<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-mod macro_hack {\n-#[macro_escape];\n-macro_rules! externfn(\n-    (fn $name:ident () $(-> $ret_ty:ty),*) => (\n-        extern {\n-            fn $name() $(-> $ret_ty),*;\n-        }\n-    );\n-    (fn $name:ident ($($arg_name:ident : $arg_ty:ty),*) $(-> $ret_ty:ty),*) => (\n-        extern {\n-            fn $name($($arg_name : $arg_ty),*) $(-> $ret_ty),*;\n-        }\n-    )\n-)\n-}\n-\n externfn!(fn rust_create_little_lock() -> rust_little_lock)\n externfn!(fn rust_destroy_little_lock(lock: rust_little_lock))\n externfn!(fn rust_lock_little_lock(lock: rust_little_lock))"}, {"sha": "f0f86911f5050be8c43ebe1ea4f9d644e5fa52c1", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -804,7 +804,7 @@ pub fn new_sctable_internal() -> SCTable {\n \n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn get_sctable() -> @mut SCTable {\n-    static sctable_key: local_data::Key<@@mut SCTable> = &local_data::Key;\n+    local_data_key!(sctable_key: @@mut SCTable)\n     match local_data::get(sctable_key, |k| k.map_move(|k| *k)) {\n         None => {\n             let new_table = @@mut new_sctable_internal();\n@@ -841,7 +841,7 @@ pub type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n // okay, I admit, putting this in TLS is not so nice:\n // fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn get_resolve_table() -> @mut ResolveTable {\n-    static resolve_table_key: local_data::Key<@@mut ResolveTable> = &local_data::Key;\n+    local_data_key!(resolve_table_key: @@mut ResolveTable)\n     match local_data::get(resolve_table_key, |k| k.map(|&k| *k)) {\n         None => {\n             let new_table = @@mut HashMap::new();"}, {"sha": "5e9714ca5b2de33c90c7ca89ba1a9a27a74097e9", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -187,7 +187,7 @@ fn diagnosticcolor(lvl: level) -> term::color::Color {\n }\n \n fn print_maybe_styled(msg: &str, color: term::attr::Attr) {\n-    static tls_terminal: local_data::Key<@Option<term::Terminal>> = &local_data::Key;\n+    local_data_key!(tls_terminal: @Option<term::Terminal>)\n \n     let stderr = io::stderr();\n "}, {"sha": "889c2a5976eb358e73864716a0fa027dadd45b26", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -644,25 +644,11 @@ impl AstBuilder for @ExtCtxt {\n \n         self.expr(span, ast::ExprFnBlock(fn_decl, blk))\n     }\n-    #[cfg(stage0)]\n-    fn lambda0(&self, _span: Span, blk: ast::Block) -> @ast::Expr {\n-        let ext_cx = *self;\n-        let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n-        quote_expr!(|| $blk_e )\n-    }\n-    #[cfg(not(stage0))]\n     fn lambda0(&self, _span: Span, blk: ast::Block) -> @ast::Expr {\n         let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n         quote_expr!(*self, || $blk_e )\n     }\n \n-    #[cfg(stage0)]\n-    fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::Expr {\n-        let ext_cx = *self;\n-        let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n-        quote_expr!(|$ident| $blk_e )\n-    }\n-    #[cfg(not(stage0))]\n     fn lambda1(&self, _span: Span, blk: ast::Block, ident: ast::Ident) -> @ast::Expr {\n         let blk_e = self.expr(blk.span, ast::ExprBlock(blk.clone()));\n         quote_expr!(*self, |$ident| $blk_e )"}, {"sha": "e97af9cbfb143db6da01824c21d684c7124c966f", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -22,18 +22,6 @@ use ext::build::AstBuilder;\n \n use std::os;\n \n-#[cfg(stage0)]\n-pub fn expand_option_env(ext_cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n-    -> base::MacResult {\n-    let var = get_single_str_from_tts(ext_cx, sp, tts, \"option_env!\");\n-\n-    let e = match os::getenv(var) {\n-      None => quote_expr!(::std::option::None::<&'static str>),\n-      Some(s) => quote_expr!(::std::option::Some($s))\n-    };\n-    MRExpr(e)\n-}\n-#[cfg(not(stage0))]\n pub fn expand_option_env(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let var = get_single_str_from_tts(cx, sp, tts, \"option_env!\");"}, {"sha": "7254e8e775a94a54ace77d0b24553221ba6adedf", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -863,9 +863,7 @@ pub fn std_macros() -> @str {\n \n                 use super::*;\n \n-                static key: ::std::local_data::Key<\n-                    @::std::condition::Handler<$input, $out>> =\n-                    &::std::local_data::Key;\n+                local_data_key!(key: @::std::condition::Handler<$input, $out>)\n \n                 pub static cond :\n                     ::std::condition::Condition<$input,$out> =\n@@ -884,9 +882,7 @@ pub fn std_macros() -> @str {\n \n                 use super::*;\n \n-                static key: ::std::local_data::Key<\n-                    @::std::condition::Handler<$input, $out>> =\n-                    &::std::local_data::Key;\n+                local_data_key!(key: @::std::condition::Handler<$input, $out>)\n \n                 pub static cond :\n                     ::std::condition::Condition<$input,$out> =\n@@ -975,8 +971,6 @@ pub fn std_macros() -> @str {\n         ($($arg:tt)*) => (::std::io::println(format!($($arg)*)))\n     )\n \n-    // NOTE: use this after a snapshot lands to abstract the details\n-    // of the TLS interface.\n     macro_rules! local_data_key (\n         ($name:ident: $ty:ty) => (\n             static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;"}, {"sha": "a8df737e49fcf7db6a727b17a5b44291ef7d360a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -490,8 +490,7 @@ fn mk_fresh_ident_interner() -> @ident_interner {\n // if an interner exists in TLS, return it. Otherwise, prepare a\n // fresh one.\n pub fn get_ident_interner() -> @ident_interner {\n-    static key: local_data::Key<@@::parse::token::ident_interner> =\n-        &local_data::Key;\n+    local_data_key!(key: @@::parse::token::ident_interner)\n     match local_data::get(key, |k| k.map_move(|k| *k)) {\n         Some(interner) => *interner,\n         None => {"}, {"sha": "705cf50632a6acc74a5d661037f29df38a93698e", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/817576ee7001244da68a4ee315ebdc1163d4e648/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=817576ee7001244da68a4ee315ebdc1163d4e648", "patch": "@@ -1,3 +1,11 @@\n+S 2013-09-17 cbd1eef\n+  freebsd-x86_64 9166867a8859076343cb3e57da918b5c0eea720b\n+  linux-i386 38347b579312ff30c36d257a1161660eb0ae8422\n+  linux-x86_64 0c169bba5d6729d0c0f096d61d9274fb082b4b34\n+  macos-i386 1eb229510dd12b91800674566b8dad401a3f80d3\n+  macos-x86_64 1c5d8e29b9671af93963e1b5fa9fcca081124a39\n+  winnt-i386 56baa04a1f02235ebc5a75be05aa65fdc822a4e6\n+\n S 2013-08-14 e7b5729\n   freebsd-x86_64 9de0b5583a5c4413f9e77df7071498385e936dd2\n   linux-i386 29119a9072f74c639c2bad998edc40e582da540e"}]}