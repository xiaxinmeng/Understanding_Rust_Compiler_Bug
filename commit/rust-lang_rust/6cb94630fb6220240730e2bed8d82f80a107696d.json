{"sha": "6cb94630fb6220240730e2bed8d82f80a107696d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYjk0NjMwZmI2MjIwMjQwNzMwZTJiZWQ4ZDgyZjgwYTEwNzY5NmQ=", "commit": {"author": {"name": "Lachezar Lechev", "email": "elpiel93@gmail.com", "date": "2018-08-16T16:20:06Z"}, "committer": {"name": "Lachezar Lechev", "email": "elpiel93@gmail.com", "date": "2018-08-16T16:20:06Z"}, "message": "WIP of #3016 for hardocded suggestion for writeln on empty string", "tree": {"sha": "bdcd449e3eae1cbb991eab30ea9ecea6774064c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdcd449e3eae1cbb991eab30ea9ecea6774064c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cb94630fb6220240730e2bed8d82f80a107696d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb94630fb6220240730e2bed8d82f80a107696d", "html_url": "https://github.com/rust-lang/rust/commit/6cb94630fb6220240730e2bed8d82f80a107696d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cb94630fb6220240730e2bed8d82f80a107696d/comments", "author": {"login": "elpiel", "id": 8925621, "node_id": "MDQ6VXNlcjg5MjU2MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/8925621?v=4", "gravatar_id": "", "url": "https://api.github.com/users/elpiel", "html_url": "https://github.com/elpiel", "followers_url": "https://api.github.com/users/elpiel/followers", "following_url": "https://api.github.com/users/elpiel/following{/other_user}", "gists_url": "https://api.github.com/users/elpiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/elpiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/elpiel/subscriptions", "organizations_url": "https://api.github.com/users/elpiel/orgs", "repos_url": "https://api.github.com/users/elpiel/repos", "events_url": "https://api.github.com/users/elpiel/events{/privacy}", "received_events_url": "https://api.github.com/users/elpiel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "elpiel", "id": 8925621, "node_id": "MDQ6VXNlcjg5MjU2MjE=", "avatar_url": "https://avatars.githubusercontent.com/u/8925621?v=4", "gravatar_id": "", "url": "https://api.github.com/users/elpiel", "html_url": "https://github.com/elpiel", "followers_url": "https://api.github.com/users/elpiel/followers", "following_url": "https://api.github.com/users/elpiel/following{/other_user}", "gists_url": "https://api.github.com/users/elpiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/elpiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/elpiel/subscriptions", "organizations_url": "https://api.github.com/users/elpiel/orgs", "repos_url": "https://api.github.com/users/elpiel/repos", "events_url": "https://api.github.com/users/elpiel/events{/privacy}", "received_events_url": "https://api.github.com/users/elpiel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84aa49935dfc6dc9ddd795d0372dcfe9f342e5c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/84aa49935dfc6dc9ddd795d0372dcfe9f342e5c6", "html_url": "https://github.com/rust-lang/rust/commit/84aa49935dfc6dc9ddd795d0372dcfe9f342e5c6"}], "stats": {"total": 33, "additions": 18, "deletions": 15}, "files": [{"sha": "9b0b25f39215faeed86270db5bf1736e06b1f831", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6cb94630fb6220240730e2bed8d82f80a107696d/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb94630fb6220240730e2bed8d82f80a107696d/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=6cb94630fb6220240730e2bed8d82f80a107696d", "patch": "@@ -179,7 +179,7 @@ impl EarlyLintPass for Pass {\n     fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &Mac) {\n         if mac.node.path == \"println\" {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `println!`\");\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false).0 {\n                 if fmtstr == \"\" {\n                     span_lint_and_sugg(\n                         cx,\n@@ -193,39 +193,40 @@ impl EarlyLintPass for Pass {\n             }\n         } else if mac.node.path == \"print\" {\n             span_lint(cx, PRINT_STDOUT, mac.span, \"use of `print!`\");\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false) {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, false).0 {\n                 if fmtstr.ends_with(\"\\\\n\") && !fmtstr.ends_with(\"\\\\n\\\\n\") {\n                     span_lint(cx, PRINT_WITH_NEWLINE, mac.span,\n                             \"using `print!()` with a format string that ends in a \\\n                             single newline, consider using `println!()` instead\");\n                 }\n             }\n         } else if mac.node.path == \"write\" {\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true).0 {\n                 if fmtstr.ends_with(\"\\\\n\") && !fmtstr.ends_with(\"\\\\n\\\\n\") {\n                     span_lint(cx, WRITE_WITH_NEWLINE, mac.span,\n                             \"using `write!()` with a format string that ends in a \\\n                             single newline, consider using `writeln!()` instead\");\n                 }\n             }\n         } else if mac.node.path == \"writeln\" {\n-            if let Some(fmtstr) = check_tts(cx, &mac.node.tts, true) {\n+            let check_tts = check_tts(cx, &mac.node.tts, true);\n+            if let Some(fmtstr) = check_tts.0 {\n                 if fmtstr == \"\" {\n                     span_lint_and_sugg(\n                         cx,\n                         WRITELN_EMPTY_STRING,\n                         mac.span,\n-                        \"using `writeln!(v, \\\"\\\")`\",\n+                        format!(\"using `writeln!({}, \\\"\\\")`\", check_tts.1).as_str(),\n                         \"replace it with\",\n-                        \"writeln!(v)\".to_string(),\n+                        format!(\"using `writeln!({})`\", check_tts.1),\n                     );\n                 }\n             }\n         }\n     }\n }\n \n-fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> Option<String> {\n+fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -> (Option<String>, Option<Expr>) {\n     let tts = TokenStream::from(tts.clone());\n     let mut parser = parser::Parser::new(\n         &cx.sess.parse_sess,\n@@ -234,20 +235,22 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n         false,\n         false,\n     );\n-    if is_write {\n-        // skip the initial write target\n-        parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n-        // might be `writeln!(foo)`\n-        parser.expect(&token::Comma).map_err(|mut err| err.cancel()).ok()?;\n-    }\n+    // skip the initial write target\n+    let expr: Option<Expr> = match parser.parse_expr().map_err(|mut err| err.cancel()).ok() {\n+        Some(p) => Some(p.into_vec().0),\n+        None => None,\n+    };\n+    // might be `writeln!(foo)`\n+    parser.expect(&token::Comma).map_err(|mut err| err.cancel()).ok()?;\n+\n     let fmtstr = parser.parse_str().map_err(|mut err| err.cancel()).ok()?.0.to_string();\n     use fmt_macros::*;\n     let tmp = fmtstr.clone();\n     let mut args = vec![];\n     let mut fmt_parser = Parser::new(&tmp, None);\n     while let Some(piece) = fmt_parser.next() {\n         if !fmt_parser.errors.is_empty() {\n-            return None;\n+            return (None, expr);\n         }\n         if let Piece::NextArgument(arg) = piece {\n             if arg.format.ty == \"?\" {\n@@ -266,7 +269,7 @@ fn check_tts<'a>(cx: &EarlyContext<'a>, tts: &ThinTokenStream, is_write: bool) -\n     loop {\n         if !parser.eat(&token::Comma) {\n             assert!(parser.eat(&token::Eof));\n-            return Some(fmtstr);\n+            return (Some(fmtstr), expr);\n         }\n         let expr = parser.parse_expr().map_err(|mut err| err.cancel()).ok()?;\n         const SIMPLE: FormatSpec<'_> = FormatSpec {"}]}