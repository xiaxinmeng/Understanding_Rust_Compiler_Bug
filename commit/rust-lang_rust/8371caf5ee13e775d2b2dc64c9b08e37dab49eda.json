{"sha": "8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNzFjYWY1ZWUxM2U3NzVkMmIyZGM2NGM5YjA4ZTM3ZGFiNDllZGE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-02-28T06:17:24Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-16T20:13:15Z"}, "message": "syntax: Do not accidentally treat multi-segment meta-items as single-segment", "tree": {"sha": "630bb9b91f6f46469c6ec3eb51b21733c8e02e46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/630bb9b91f6f46469c6ec3eb51b21733c8e02e46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "html_url": "https://github.com/rust-lang/rust/commit/8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2009ea5ffdacd767ea85d463fbe40d0e8b06951", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2009ea5ffdacd767ea85d463fbe40d0e8b06951", "html_url": "https://github.com/rust-lang/rust/commit/e2009ea5ffdacd767ea85d463fbe40d0e8b06951"}], "stats": {"total": 449, "additions": 236, "deletions": 213}, "files": [{"sha": "1f375452ae6c97218e8bd2d791a19cd175122249", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -166,7 +166,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         // ```\n         let hints: Vec<_> = item.attrs\n             .iter()\n-            .filter(|attr| attr.name() == \"repr\")\n+            .filter(|attr| attr.check_name(\"repr\"))\n             .filter_map(|attr| attr.meta_item_list())\n             .flatten()\n             .collect();\n@@ -177,15 +177,15 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         let mut is_transparent = false;\n \n         for hint in &hints {\n-            let name = if let Some(name) = hint.name() {\n+            let name = if let Some(name) = hint.ident_str() {\n                 name\n             } else {\n                 // Invalid repr hint like repr(42). We don't check for unrecognized hints here\n                 // (libsyntax does that), so just ignore it.\n                 continue;\n             };\n \n-            let (article, allowed_targets) = match &*name.as_str() {\n+            let (article, allowed_targets) = match name {\n                 \"C\" | \"align\" => {\n                     is_c |= name == \"C\";\n                     if target != Target::Struct &&\n@@ -313,7 +313,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n \n     fn check_used(&self, item: &hir::Item, target: Target) {\n         for attr in &item.attrs {\n-            if attr.name() == \"used\" && target != Target::Static {\n+            if attr.check_name(\"used\") && target != Target::Static {\n                 self.tcx.sess\n                     .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n             }"}, {"sha": "0a1dda7a9cffd9d6308ab280564b6d9e33b67dee", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -197,7 +197,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n         let filtered: SmallVec<[&ast::Attribute; 8]> = self\n             .iter()\n             .filter(|attr| {\n-                !attr.is_sugared_doc && !hcx.is_ignored_attr(attr.name())\n+                !attr.is_sugared_doc &&\n+                !attr.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name))\n             })\n             .collect();\n \n@@ -224,7 +225,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ast::Attribute {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n-        debug_assert!(!hcx.is_ignored_attr(self.name()));\n+        debug_assert!(!self.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name)));\n         debug_assert!(!self.is_sugared_doc);\n \n         let ast::Attribute {"}, {"sha": "7ce51d628a4cee31bc233cda20ba364645a83bac", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -194,7 +194,7 @@ impl<'a> LintLevelsBuilder<'a> {\n             struct_span_err!(sess, span, E0452, \"malformed lint attribute\")\n         };\n         for attr in attrs {\n-            let level = match Level::from_str(&attr.name().as_str()) {\n+            let level = match attr.ident_str().and_then(|name| Level::from_str(name)) {\n                 None => continue,\n                 Some(lvl) => lvl,\n             };\n@@ -255,9 +255,9 @@ impl<'a> LintLevelsBuilder<'a> {\n             }\n \n             for li in metas {\n-                let word = match li.word() {\n-                    Some(word) => word,\n-                    None => {\n+                let meta_item = match li.meta_item() {\n+                    Some(meta_item) if meta_item.is_word() => meta_item,\n+                    _ => {\n                         let mut err = bad_attr(li.span);\n                         if let Some(item) = li.meta_item() {\n                             if let ast::MetaItemKind::NameValue(_) = item.node {\n@@ -270,23 +270,24 @@ impl<'a> LintLevelsBuilder<'a> {\n                         continue;\n                     }\n                 };\n-                let tool_name = if let Some(lint_tool) = word.is_scoped() {\n-                    if !attr::is_known_lint_tool(lint_tool) {\n+                let tool_name = if meta_item.ident.segments.len() > 1 {\n+                    let tool_ident = meta_item.ident.segments[0].ident;\n+                    if !attr::is_known_lint_tool(tool_ident) {\n                         span_err!(\n                             sess,\n-                            lint_tool.span,\n+                            tool_ident.span,\n                             E0710,\n                             \"an unknown tool name found in scoped lint: `{}`\",\n-                            word.ident\n+                            meta_item.ident\n                         );\n                         continue;\n                     }\n \n-                    Some(lint_tool.as_str())\n+                    Some(tool_ident.as_str())\n                 } else {\n                     None\n                 };\n-                let name = word.name();\n+                let name = meta_item.ident.segments.last().expect(\"empty lint name\").ident.name;\n                 match store.check_lint_name(&name.as_str(), tool_name) {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintSource::Node(name, li.span, reason);"}, {"sha": "237b00db575a968efc32df021ee078c244ef4cfc", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -65,9 +65,9 @@ impl<'a, 'tcx> LibFeatureCollector<'a, 'tcx> {\n                 for meta in metas {\n                     if let Some(mi) = meta.meta_item() {\n                         // Find the `feature = \"..\"` meta-item.\n-                        match (&*mi.name().as_str(), mi.value_str()) {\n-                            (\"feature\", val) => feature = val,\n-                            (\"since\", val) => since = val,\n+                        match (mi.ident_str(), mi.value_str()) {\n+                            (Some(\"feature\"), val) => feature = val,\n+                            (Some(\"since\"), val) => since = val,\n                             _ => {}\n                         }\n                     }"}, {"sha": "2664d6eaa28572c83c7d41403b813213029a792b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -194,11 +194,12 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n         } else {\n             // Emit errors for non-staged-api crates.\n             for attr in attrs {\n-                let tag = attr.name();\n-                if tag == \"unstable\" || tag == \"stable\" || tag == \"rustc_deprecated\" {\n-                    attr::mark_used(attr);\n-                    self.tcx.sess.span_err(attr.span(), \"stability attributes may not be used \\\n-                                                         outside of the standard library\");\n+                if let Some(tag) = attr.ident_str() {\n+                    if tag == \"unstable\" || tag == \"stable\" || tag == \"rustc_deprecated\" {\n+                        attr::mark_used(attr);\n+                        self.tcx.sess.span_err(attr.span, \"stability attributes may not be used \\\n+                                                           outside of the standard library\");\n+                    }\n                 }\n             }\n "}, {"sha": "6753d4c29d3b8d5892be099580dfac15fe526222", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -1850,7 +1850,8 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String\n                             error!(\"argument value must be a string\");\n                         }\n                         MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n-                            return (meta_item.name(), meta_item.value_str());\n+                            let ident = meta_item.ident().expect(\"multi-segment cfg key\");\n+                            return (ident.name, meta_item.value_str());\n                         }\n                     }\n                 }"}, {"sha": "66c684b137546fddaed62187e383738fa7aa9d1e", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -177,10 +177,12 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n             if let Some(ref condition) = command.condition {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n-                    options.contains(&(\n-                        c.name().as_str().to_string(),\n-                        c.value_str().map(|s| s.as_str().to_string())\n-                    ))\n+                    c.ident_str().map_or(false, |name| {\n+                        options.contains(&(\n+                            name.to_string(),\n+                            c.value_str().map(|s| s.as_str().to_string())\n+                        ))\n+                    })\n                 }) {\n                     debug!(\"evaluate: skipping {:?} due to condition\", command);\n                     continue"}, {"sha": "b7953e9668c788c9a04659cda0fbef78de695f79", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -99,9 +99,9 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     fn argument(&self, attr: &ast::Attribute) -> Option<ast::Name> {\n         let mut value = None;\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n-            match list_item.word() {\n-                Some(word) if value.is_none() =>\n-                    value = Some(word.name()),\n+            match list_item.ident() {\n+                Some(ident) if list_item.is_word() && value.is_none() =>\n+                    value = Some(ident.name),\n                 _ =>\n                     // FIXME better-encapsulate meta_item (don't directly access `node`)\n                     span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node),"}, {"sha": "7e17a6d7dc69feecc40137eb90111970ae3a314f", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -576,7 +576,7 @@ fn expect_associated_value(tcx: TyCtxt<'_, '_, '_>, item: &NestedMetaItem) -> as\n     if let Some(value) = item.value_str() {\n         value\n     } else {\n-        let msg = if let Some(name) = item.name() {\n+        let msg = if let Some(name) = item.ident_str() {\n             format!(\"associated value expected for `{}`\", name)\n         } else {\n             \"expected an associated value\".to_string()"}, {"sha": "eb2bf21c42e53e953d1482c82c8f77c7227d3914", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -760,7 +760,7 @@ impl LintPass for DeprecatedAttr {\n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         for &&(n, _, _, ref g) in &self.depr_attrs {\n-            if attr.name() == n {\n+            if attr.ident_str() == Some(n) {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link, suggestion),\n                                              ref name,\n                                              ref reason,"}, {"sha": "648cae30da6c8f14bbf93f01f612011ec75e0b9f", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -267,19 +267,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n             }\n         }\n \n-        let name = attr.name();\n+        let name = attr.ident_str();\n         if !attr::is_used(attr) {\n             debug!(\"Emitting warning for: {:?}\", attr);\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n             // Is it a builtin attribute that must be used at the crate level?\n             let known_crate = BUILTIN_ATTRIBUTES.iter()\n-                .find(|&&(builtin, ty, ..)| name == builtin && ty == AttributeType::CrateLevel)\n+                .find(|&&(builtin, ty, ..)| {\n+                    name == Some(builtin) && ty == AttributeType::CrateLevel\n+                })\n                 .is_some();\n \n             // Has a plugin registered this attribute as one that must be used at\n             // the crate level?\n             let plugin_crate = plugin_attributes.iter()\n-                .find(|&&(ref x, t)| name == &**x && AttributeType::CrateLevel == t)\n+                .find(|&&(ref x, t)| name == Some(x) && AttributeType::CrateLevel == t)\n                 .is_some();\n             if known_crate || plugin_crate {\n                 let msg = match attr.style {"}, {"sha": "e2a74f5c4285b3d3b225b6e81c2396f0013c26c7", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -53,9 +53,7 @@ impl<'a, 'tcx> VarianceTest<'a, 'tcx> {\n                 // The `..` are the names of fields to dump.\n                 let meta_items = attr.meta_item_list().unwrap_or_default();\n                 for meta_item in meta_items {\n-                    let name = meta_item.word().map(|mi| mi.name().as_str());\n-                    let name = name.as_ref().map(|s| &s[..]).unwrap_or(\"\");\n-\n+                    let name = meta_item.ident_str().unwrap_or(\"\");\n                     match name {\n                         \"abi\" => {\n                             self.tcx"}, {"sha": "2f4332e71237d4b167a226ab807cfa6eb1814182", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -56,10 +56,10 @@ pub fn load_plugins(sess: &Session,\n \n             for plugin in plugins {\n                 // plugins must have a name and can't be key = value\n-                match plugin.name() {\n+                match plugin.ident_str() {\n                     Some(name) if !plugin.is_value_str() => {\n                         let args = plugin.meta_item_list().map(ToOwned::to_owned);\n-                        loader.load_plugin(plugin.span, &name.as_str(), args.unwrap_or_default());\n+                        loader.load_plugin(plugin.span, name, args.unwrap_or_default());\n                     },\n                     _ => call_malformed_plugin_attribute(sess, attr.span),\n                 }"}, {"sha": "de79068cdeb53280d67750a7f0f9f83623e47d32", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -463,10 +463,9 @@ impl<'a> Resolver<'a> {\n                 if let Some(attr) = attr::find_by_name(&item.attrs, \"proc_macro_derive\") {\n                     if let Some(trait_attr) =\n                             attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n-                        if let Some(ident) = trait_attr.name().map(Ident::with_empty_ctxt) {\n-                            let sp = trait_attr.span;\n+                        if let Some(ident) = trait_attr.ident() {\n                             let def = Def::Macro(def.def_id(), MacroKind::ProcMacroStub);\n-                            self.define(parent, ident, MacroNS, (def, vis, sp, expansion));\n+                            self.define(parent, ident, MacroNS, (def, vis, ident.span, expansion));\n                         }\n                     }\n                 }\n@@ -812,9 +811,9 @@ impl<'a> Resolver<'a> {\n                             break;\n                         }\n                         MetaItemKind::List(nested_metas) => for nested_meta in nested_metas {\n-                            match nested_meta.word() {\n-                                Some(word) => single_imports.push((word.name(), word.span)),\n-                                None => ill_formed(nested_meta.span),\n+                            match nested_meta.ident() {\n+                                Some(ident) if nested_meta.is_word() => single_imports.push(ident),\n+                                _ => ill_formed(nested_meta.span),\n                             }\n                         }\n                         MetaItemKind::NameValue(..) => ill_formed(meta.span),\n@@ -850,23 +849,23 @@ impl<'a> Resolver<'a> {\n                 self.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n             });\n         } else {\n-            for (name, span) in single_imports.iter().cloned() {\n-                let ident = Ident::with_empty_ctxt(name);\n+            for ident in single_imports.iter().cloned() {\n                 let result = self.resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n                     ident,\n                     MacroNS,\n                     None,\n                     false,\n-                    span,\n+                    ident.span,\n                 );\n                 if let Ok(binding) = result {\n-                    let directive = macro_use_directive(span);\n+                    let directive = macro_use_directive(ident.span);\n                     self.potentially_unused_imports.push(directive);\n                     let imported_binding = self.import(binding, directive);\n-                    self.legacy_import_macro(name, imported_binding, span, allow_shadowing);\n+                    self.legacy_import_macro(ident.name, imported_binding,\n+                                             ident.span, allow_shadowing);\n                 } else {\n-                    span_err!(self.session, span, E0469, \"imported macro not found\");\n+                    span_err!(self.session, ident.span, E0469, \"imported macro not found\");\n                 }\n             }\n         }"}, {"sha": "7ebcf2cbd912c769592b2e1d1929429343ccc483", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -58,7 +58,13 @@ impl Cfg {\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n     pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n-        let name = cfg.name();\n+        let name = match cfg.ident() {\n+            Some(ident) => ident.name,\n+            None => return Err(InvalidCfgError {\n+                msg: \"expected a single identifier\",\n+                span: cfg.span\n+            }),\n+        };\n         match cfg.node {\n             MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n             MetaItemKind::NameValue(ref lit) => match lit.node {"}, {"sha": "01a9e8e1be778a28e3639bbc17599146c833aa82", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -492,7 +492,7 @@ impl Item {\n \n     pub fn is_non_exhaustive(&self) -> bool {\n         self.attrs.other_attrs.iter()\n-            .any(|a| a.name().as_str() == \"non_exhaustive\")\n+            .any(|a| a.check_name(\"non_exhaustive\"))\n     }\n \n     /// Returns a documentation-level item type from the item.\n@@ -3683,7 +3683,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n     fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n-            a.name() == \"doc\" && match a.meta_item_list() {\n+            a.check_name(\"doc\") && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, \"inline\"),\n                 None => false,\n             }\n@@ -3722,7 +3722,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n         let mut denied = !self.vis.node.is_pub() || self.attrs.iter().any(|a| {\n-            a.name() == \"doc\" && match a.meta_item_list() {\n+            a.check_name(\"doc\") && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n                            attr::list_contains_name(&l, \"hidden\"),\n                 None => false,"}, {"sha": "dca6458c701c589e022a3275f50cd6838f902cea", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -521,8 +521,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             for attr in krate.module.as_ref().unwrap().attrs.lists(\"doc\") {\n                 let diag = ctxt.sess().diagnostic();\n \n-                let name = attr.name().map(|s| s.as_str());\n-                let name = name.as_ref().map(|s| &s[..]);\n+                let name = attr.ident_str();\n                 if attr.is_word() {\n                     if name == Some(\"no_default_passes\") {\n                         report_deprecated_attr(\"no_default_passes\", diag);"}, {"sha": "e8743f55aafd3d2caaaecd559ab1a6ec2f1eeed0", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -562,8 +562,7 @@ pub fn run(mut krate: clean::Crate,\n     // going to emit HTML\n     if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n         for attr in attrs.lists(\"doc\") {\n-            let name = attr.name().map(|s| s.as_str());\n-            match (name.as_ref().map(|s| &s[..]), attr.value_str()) {\n+            match (attr.ident_str(), attr.value_str()) {\n                 (Some(\"html_favicon_url\"), Some(s)) => {\n                     scx.layout.favicon = s.to_string();\n                 }\n@@ -3714,19 +3713,19 @@ fn item_enum(w: &mut fmt::Formatter<'_>, cx: &Context, it: &clean::Item,\n }\n \n fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n-    let name = attr.name();\n+    let path = attr.ident.to_string();\n \n     if attr.is_word() {\n-        Some(name.to_string())\n+        Some(path)\n     } else if let Some(v) = attr.value_str() {\n-        Some(format!(\"{} = {:?}\", name, v.as_str()))\n+        Some(format!(\"{} = {:?}\", path, v.as_str()))\n     } else if let Some(values) = attr.meta_item_list() {\n         let display: Vec<_> = values.iter().filter_map(|attr| {\n             attr.meta_item().and_then(|mi| render_attribute(mi))\n         }).collect();\n \n         if display.len() > 0 {\n-            Some(format!(\"{}({})\", name, display.join(\", \")))\n+            Some(format!(\"{}({})\", path, display.join(\", \")))\n         } else {\n             None\n         }\n@@ -3750,8 +3749,7 @@ fn render_attributes(w: &mut fmt::Formatter<'_>, it: &clean::Item) -> fmt::Resul\n     let mut attrs = String::new();\n \n     for attr in &it.attrs.other_attrs {\n-        let name = attr.name();\n-        if !ATTRIBUTE_WHITELIST.contains(&&*name.as_str()) {\n+        if !attr.ident_str().map_or(false, |name| ATTRIBUTE_WHITELIST.contains(&name)) {\n             continue;\n         }\n         if let Some(s) = render_attribute(&attr.meta().unwrap()) {"}, {"sha": "b4db121fb530ac3bddb5604bf72d32082098cc2a", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -178,9 +178,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(kind) => {\n                 let name = if kind == MacroKind::Derive {\n                     item.attrs.lists(\"proc_macro_derive\")\n-                              .filter_map(|mi| mi.name())\n+                              .filter_map(|mi| mi.ident())\n                               .next()\n                               .expect(\"proc-macro derives require a name\")\n+                              .name\n                 } else {\n                     name\n                 };\n@@ -193,8 +194,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                     if let Some(list) = mi.meta_item_list() {\n                         for inner_mi in list {\n-                            if let Some(name) = inner_mi.name() {\n-                                helpers.push(name);\n+                            if let Some(ident) = inner_mi.ident() {\n+                                helpers.push(ident.name);\n                             }\n                         }\n                     }"}, {"sha": "f3caf16e1a7d023db3b133db8dc7cd1b825b1722", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 46, "deletions": 48, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -1,6 +1,6 @@\n //! Parsing and validation of builtin attributes\n \n-use crate::ast::{self, Attribute, MetaItem, Name, NestedMetaItemKind};\n+use crate::ast::{self, Attribute, MetaItem, NestedMetaItemKind};\n use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n@@ -10,8 +10,8 @@ use syntax_pos::{symbol::Symbol, Span};\n use super::{mark_used, MetaItemKind};\n \n enum AttrError {\n-    MultipleItem(Name),\n-    UnknownMetaItem(Name, &'static [&'static str]),\n+    MultipleItem(String),\n+    UnknownMetaItem(String, &'static [&'static str]),\n     MissingSince,\n     MissingFeature,\n     MultipleStabilityLevels,\n@@ -155,10 +155,7 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n     attrs.iter().any(|item| {\n         item.check_name(\"feature\") &&\n         item.meta_item_list().map(|list| {\n-            list.iter().any(|mi| {\n-                mi.word().map(|w| w.name() == feature_name)\n-                         .unwrap_or(false)\n-            })\n+            list.iter().any(|mi| mi.is_word() && mi.check_name(feature_name))\n         }).unwrap_or(false)\n     })\n }\n@@ -206,7 +203,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(sess, meta.span, AttrError::MultipleItem(meta.name()));\n+                    handle_errors(sess, meta.span, AttrError::MultipleItem(meta.ident.to_string()));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -225,17 +222,17 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     )+\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n+                            match mi.ident_str() {\n                                 $(\n-                                    stringify!($name)\n+                                    Some(stringify!($name))\n                                         => if !get(mi, &mut $name) { continue 'outer },\n                                 )+\n                                 _ => {\n                                     let expected = &[ $( stringify!($name) ),+ ];\n                                     handle_errors(\n                                         sess,\n                                         mi.span,\n-                                        AttrError::UnknownMetaItem(mi.name(), expected),\n+                                        AttrError::UnknownMetaItem(mi.ident.to_string(), expected),\n                                     );\n                                     continue 'outer\n                                 }\n@@ -255,7 +252,7 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                 }\n             }\n \n-            match &*meta.name().as_str() {\n+            match meta.ident_str().expect(\"not a stability level\") {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -309,16 +306,16 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n-                                \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n-                                \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n+                            match mi.ident_str() {\n+                                Some(\"feature\") => if !get(mi, &mut feature) { continue 'outer },\n+                                Some(\"reason\") => if !get(mi, &mut reason) { continue 'outer },\n+                                Some(\"issue\") => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(\n                                         sess,\n                                         meta.span,\n                                         AttrError::UnknownMetaItem(\n-                                            mi.name(),\n+                                            mi.ident.to_string(),\n                                             &[\"feature\", \"reason\", \"issue\"]\n                                         ),\n                                     );\n@@ -380,15 +377,17 @@ fn find_stability_generic<'a, I>(sess: &ParseSess,\n                     for meta in metas {\n                         match &meta.node {\n                             NestedMetaItemKind::MetaItem(mi) => {\n-                                match &*mi.name().as_str() {\n-                                    \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n-                                    \"since\" => if !get(mi, &mut since) { continue 'outer },\n+                                match mi.ident_str() {\n+                                    Some(\"feature\") =>\n+                                        if !get(mi, &mut feature) { continue 'outer },\n+                                    Some(\"since\") =>\n+                                        if !get(mi, &mut since) { continue 'outer },\n                                     _ => {\n                                         handle_errors(\n                                             sess,\n                                             meta.span,\n                                             AttrError::UnknownMetaItem(\n-                                                mi.name(), &[\"since\", \"note\"],\n+                                                mi.ident.to_string(), &[\"since\", \"note\"],\n                                             ),\n                                         );\n                                         continue 'outer\n@@ -502,7 +501,8 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n                 true\n             }\n             MetaItemKind::NameValue(..) | MetaItemKind::Word => {\n-                sess.config.contains(&(cfg.name(), cfg.value_str()))\n+                let ident = cfg.ident().expect(\"multi-segment cfg predicate\");\n+                sess.config.contains(&(ident.name, cfg.value_str()))\n             }\n         }\n     })\n@@ -532,23 +532,24 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &*cfg.name().as_str() {\n-                \"any\" => mis.iter().any(|mi| {\n+            match cfg.ident_str() {\n+                Some(\"any\") => mis.iter().any(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n-                \"all\" => mis.iter().all(|mi| {\n+                Some(\"all\") => mis.iter().all(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n-                \"not\" => {\n+                Some(\"not\") => {\n                     if mis.len() != 1 {\n                         span_err!(sess.span_diagnostic, cfg.span, E0536, \"expected 1 cfg-pattern\");\n                         return false;\n                     }\n \n                     !eval_condition(mis[0].meta_item().unwrap(), sess, eval)\n                 },\n-                p => {\n-                    span_err!(sess.span_diagnostic, cfg.span, E0537, \"invalid predicate `{}`\", p);\n+                _ => {\n+                    span_err!(sess.span_diagnostic, cfg.span, E0537,\n+                              \"invalid predicate `{}`\", cfg.ident);\n                     false\n                 }\n             }\n@@ -602,7 +603,9 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n             MetaItemKind::List(list) => {\n                 let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                     if item.is_some() {\n-                        handle_errors(sess, meta.span, AttrError::MultipleItem(meta.name()));\n+                        handle_errors(\n+                            sess, meta.span, AttrError::MultipleItem(meta.ident.to_string())\n+                        );\n                         return false\n                     }\n                     if let Some(v) = meta.value_str() {\n@@ -632,14 +635,15 @@ fn find_deprecation_generic<'a, I>(sess: &ParseSess,\n                 for meta in list {\n                     match &meta.node {\n                         NestedMetaItemKind::MetaItem(mi) => {\n-                            match &*mi.name().as_str() {\n-                                \"since\" => if !get(mi, &mut since) { continue 'outer },\n-                                \"note\" => if !get(mi, &mut note) { continue 'outer },\n+                            match mi.ident_str() {\n+                                Some(\"since\") => if !get(mi, &mut since) { continue 'outer },\n+                                Some(\"note\") => if !get(mi, &mut note) { continue 'outer },\n                                 _ => {\n                                     handle_errors(\n                                         sess,\n-                                        meta.span,\n-                                        AttrError::UnknownMetaItem(mi.name(), &[\"since\", \"note\"]),\n+                                        meta.span(),\n+                                        AttrError::UnknownMetaItem(mi.ident.to_string(),\n+                                                                   &[\"since\", \"note\"]),\n                                     );\n                                     continue 'outer\n                                 }\n@@ -724,19 +728,13 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                 }\n \n                 let mut recognised = false;\n-                if let Some(mi) = item.word() {\n-                    let word = &*mi.name().as_str();\n-                    let hint = match word {\n-                        \"C\" => Some(ReprC),\n-                        \"packed\" => Some(ReprPacked(1)),\n-                        \"simd\" => Some(ReprSimd),\n-                        \"transparent\" => Some(ReprTransparent),\n-                        _ => match int_type_of_word(word) {\n-                            Some(ity) => Some(ReprInt(ity)),\n-                            None => {\n-                                None\n-                            }\n-                        }\n+                if item.is_word() {\n+                    let hint = match item.ident_str() {\n+                        Some(\"C\") => Some(ReprC),\n+                        Some(\"packed\") => Some(ReprPacked(1)),\n+                        Some(\"simd\") => Some(ReprSimd),\n+                        Some(\"transparent\") => Some(ReprTransparent),\n+                        name => name.and_then(|name| int_type_of_word(name)).map(ReprInt),\n                     };\n \n                     if let Some(h) = hint {\n@@ -782,7 +780,7 @@ pub fn find_repr_attrs(sess: &ParseSess, attr: &Attribute) -> Vec<ReprAttr> {\n                     }\n                 } else {\n                     if let Some(meta_item) = item.meta_item() {\n-                        if meta_item.name() == \"align\" {\n+                        if meta_item.check_name(\"align\") {\n                             if let MetaItemKind::NameValue(ref value) = meta_item.node {\n                                 recognised = true;\n                                 let mut err = struct_span_err!(diagnostic, item.span, E0693,"}, {"sha": "857325681c660b7524a83dd85e96a72903eee0cc", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -90,10 +90,12 @@ impl NestedMetaItem {\n         self.meta_item().map_or(false, |meta_item| meta_item.check_name(name))\n     }\n \n-    /// Returns the name of the meta item, e.g., `foo` in `#[foo]`,\n-    /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n-    pub fn name(&self) -> Option<Name> {\n-        self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n+    /// For a single-segment meta-item returns its name, otherwise returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        self.meta_item().and_then(|meta_item| meta_item.ident())\n+    }\n+    pub fn ident_str(&self) -> Option<&str> {\n+        self.ident().map(|name| name.as_str().get())\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -108,25 +110,14 @@ impl NestedMetaItem {\n             |meta_item| meta_item.meta_item_list().and_then(\n                 |meta_item_list| {\n                     if meta_item_list.len() == 1 {\n-                        let nested_item = &meta_item_list[0];\n-                        if nested_item.is_literal() {\n-                            Some((meta_item.name(), nested_item.literal().unwrap()))\n-                        } else {\n-                            None\n+                        if let Some(ident) = meta_item.ident() {\n+                            if let Some(lit) = meta_item_list[0].literal() {\n+                                return Some((ident.name, lit));\n+                            }\n                         }\n                     }\n-                    else {\n-                        None\n-                    }}))\n-    }\n-\n-    /// Returns a MetaItem if self is a MetaItem with Kind Word.\n-    pub fn word(&self) -> Option<&MetaItem> {\n-        self.meta_item().and_then(|meta_item| if meta_item.is_word() {\n-            Some(meta_item)\n-        } else {\n-            None\n-        })\n+                    None\n+                }))\n     }\n \n     /// Gets a list of inner meta items from a list MetaItem type.\n@@ -146,7 +137,7 @@ impl NestedMetaItem {\n \n     /// Returns `true` if self is a MetaItem and the meta item is a word.\n     pub fn is_word(&self) -> bool {\n-        self.word().is_some()\n+        self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n     }\n \n     /// Returns `true` if self is a MetaItem and the meta item is a ValueString.\n@@ -160,10 +151,6 @@ impl NestedMetaItem {\n     }\n }\n \n-fn name_from_path(path: &Path) -> Name {\n-    path.segments.last().expect(\"empty path in attribute\").ident.name\n-}\n-\n impl Attribute {\n     /// Returns `true` if the attribute's path matches the argument. If it matches, then the\n     /// attribute is marked as used.\n@@ -177,10 +164,16 @@ impl Attribute {\n         matches\n     }\n \n-    /// Returns the **last** segment of the name of this attribute.\n-    /// e.g., `foo` for `#[foo]`, `skip` for `#[rustfmt::skip]`.\n-    pub fn name(&self) -> Name {\n-        name_from_path(&self.path)\n+    /// For a single-segment attribute returns its name, otherwise returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        if self.path.segments.len() == 1 {\n+            Some(self.path.segments[0].ident)\n+        } else {\n+            None\n+        }\n+    }\n+    pub fn ident_str(&self) -> Option<&str> {\n+        self.ident().map(|name| name.as_str().get())\n     }\n \n     pub fn value_str(&self) -> Option<Symbol> {\n@@ -195,7 +188,7 @@ impl Attribute {\n     }\n \n     pub fn is_word(&self) -> bool {\n-        self.path.segments.len() == 1 && self.tokens.is_empty()\n+        self.tokens.is_empty()\n     }\n \n     pub fn span(&self) -> Span {\n@@ -213,8 +206,16 @@ impl Attribute {\n }\n \n impl MetaItem {\n-    pub fn name(&self) -> Name {\n-        name_from_path(&self.ident)\n+    /// For a single-segment meta-item returns its name, otherwise returns `None`.\n+    pub fn ident(&self) -> Option<Ident> {\n+        if self.ident.segments.len() == 1 {\n+            Some(self.ident.segments[0].ident)\n+        } else {\n+            None\n+        }\n+    }\n+    pub fn ident_str(&self) -> Option<&str> {\n+        self.ident().map(|name| name.as_str().get())\n     }\n \n     // #[attribute(name = \"value\")]\n@@ -255,7 +256,7 @@ impl MetaItem {\n     pub fn span(&self) -> Span { self.span }\n \n     pub fn check_name(&self, name: &str) -> bool {\n-        self.name() == name\n+        self.ident == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -265,14 +266,6 @@ impl MetaItem {\n     pub fn is_meta_item_list(&self) -> bool {\n         self.meta_item_list().is_some()\n     }\n-\n-    pub fn is_scoped(&self) -> Option<Ident> {\n-        if self.ident.segments.len() > 1 {\n-            Some(self.ident.segments[0].ident)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n impl Attribute {"}, {"sha": "12912044e4e3dfe93c6787674cc47ba66dca24fa", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -380,9 +380,14 @@ pub fn compile(\n             .map(|attr| attr\n                 .meta_item_list()\n                 .map(|list| list.iter()\n-                    .map(|it| it.name().unwrap_or_else(|| sess.span_diagnostic.span_bug(\n-                        it.span, \"allow internal unstable expects feature names\",\n-                    )))\n+                    .filter_map(|it| {\n+                        let name = it.ident().map(|ident| ident.name);\n+                        if name.is_none() {\n+                            sess.span_diagnostic.span_err(it.span(),\n+                                \"allow internal unstable expects feature names\")\n+                        }\n+                        name\n+                    })\n                     .collect::<Vec<Symbol>>().into()\n                 )\n                 .unwrap_or_else(|| {"}, {"sha": "4acacf2b68ea28e6d636915e377c711c34104691", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -1289,9 +1289,8 @@ pub struct GatedCfg {\n \n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        let name = cfg.name().as_str();\n         GATED_CFGS.iter()\n-                  .position(|info| info.0 == name)\n+                  .position(|info| cfg.check_name(info.0))\n                   .map(|idx| {\n                       GatedCfg {\n                           span: cfg.span,\n@@ -1342,16 +1341,16 @@ macro_rules! gate_feature {\n impl<'a> Context<'a> {\n     fn check_attribute(&self, attr: &ast::Attribute, is_macro: bool) {\n         debug!(\"check_attribute(attr = {:?})\", attr);\n-        let name = attr.name().as_str();\n+        let name = attr.ident_str();\n         for &(n, ty, _template, ref gateage) in BUILTIN_ATTRIBUTES {\n-            if name == n {\n+            if name == Some(n) {\n                 if let Gated(_, name, desc, ref has_feature) = *gateage {\n                     if !attr.span.allows_unstable(name) {\n                         gate_feature_fn!(\n                             self, has_feature, attr.span, name, desc, GateStrength::Hard\n                         );\n                     }\n-                } else if name == \"doc\" {\n+                } else if n == \"doc\" {\n                     if let Some(content) = attr.meta_item_list() {\n                         if content.iter().any(|c| c.check_name(\"include\")) {\n                             gate_feature!(self, external_doc, attr.span,\n@@ -1374,7 +1373,7 @@ impl<'a> Context<'a> {\n             }\n         }\n         if !attr::is_known(attr) {\n-            if name.starts_with(\"rustc_\") {\n+            if name.map_or(false, |name| name.starts_with(\"rustc_\")) {\n                 let msg = \"unless otherwise specified, attributes with the prefix `rustc_` \\\n                            are reserved for internal compiler diagnostics\";\n                 gate_feature!(self, rustc_attrs, attr.span, msg);\n@@ -2055,13 +2054,12 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n         };\n \n         for mi in list {\n-            let name = if let Some(word) = mi.word() {\n-                word.name()\n-            } else {\n-                continue\n+            let name = match mi.ident_str() {\n+                Some(name) if mi.is_word() => name,\n+                _ => continue,\n             };\n \n-            if incomplete_features.iter().any(|f| *f == name.as_str()) {\n+            if incomplete_features.iter().any(|f| *f == name) {\n                 span_handler.struct_span_warn(\n                     mi.span,\n                     &format!(\n@@ -2101,12 +2099,13 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n         };\n \n         for mi in list {\n-            let name = if let Some(word) = mi.word() {\n-                word.name()\n-            } else {\n-                span_err!(span_handler, mi.span, E0556,\n-                          \"malformed feature, expected just one word\");\n-                continue\n+            let name = match mi.ident() {\n+                Some(ident) if mi.is_word() => ident.name,\n+                _ => {\n+                    span_err!(span_handler, mi.span, E0556,\n+                            \"malformed feature, expected just one word\");\n+                    continue\n+                }\n             };\n \n             if let Some(edition) = edition_enabled_features.get(&name) {"}, {"sha": "3afd55899c8f6fa3c9f20a192c96a00190bfd73a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -438,6 +438,9 @@ fn get_test_runner(sd: &errors::Handler, krate: &ast::Crate) -> Option<ast::Path\n             sd.span_fatal(test_attr.span(),\n                 \"#![test_runner(..)] accepts exactly 1 argument\").raise()\n         }\n-        meta_list[0].word().as_ref().unwrap().ident.clone()\n+        match meta_list[0].meta_item() {\n+            Some(meta_item) if meta_item.is_word() => meta_item.ident.clone(),\n+            _ => sd.span_fatal(test_attr.span, \"`test_runner` argument must be a path\").raise()\n+        }\n     })\n }"}, {"sha": "e73110717e97968209e3b82eb5ab1ceeddd68328", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -17,9 +17,11 @@ struct MarkAttrs<'a>(&'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {\n-        if self.0.contains(&attr.name()) {\n-            mark_used(attr);\n-            mark_known(attr);\n+        if let Some(ident) = attr.ident() {\n+            if self.0.contains(&ident.name) {\n+                mark_used(attr);\n+                mark_known(attr);\n+            }\n         }\n     }\n "}, {"sha": "2bb98c1bf625cfb9363b7d86dab8513b98e5da6a", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -463,12 +463,9 @@ impl<'a> TraitDef<'a> {\n                 let mut attrs = newitem.attrs.clone();\n                 attrs.extend(item.attrs\n                     .iter()\n-                    .filter(|a| {\n-                        match &*a.name().as_str() {\n-                            \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n-                            _ => false,\n-                        }\n-                    })\n+                    .filter(|a| a.ident_str().map_or(false, |name| {\n+                        [\"allow\", \"warn\", \"deny\", \"forbid\", \"stable\", \"unstable\"].contains(&name)\n+                    }))\n                     .cloned());\n                 push(Annotatable::Item(P(ast::Item { attrs: attrs, ..(*newitem).clone() })))\n             }"}, {"sha": "4cd42d6d755ed381134985168e704f14f909a5a2", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -113,24 +113,27 @@ impl<'a> CollectProcMacros<'a> {\n                                   \"attribute must have either one or two arguments\");\n             return\n         }\n-        let trait_attr = &list[0];\n-        let attributes_attr = list.get(1);\n-        let trait_name = match trait_attr.name() {\n-            Some(name) => name,\n+        let trait_attr = match list[0].meta_item() {\n+            Some(meta_item) => meta_item,\n             _ => {\n-                self.handler.span_err(trait_attr.span(), \"not a meta item\");\n+                self.handler.span_err(list[0].span(), \"not a meta item\");\n+                return\n+            }\n+        };\n+        let trait_ident = match trait_attr.ident() {\n+            Some(trait_ident) if trait_attr.is_word() => trait_ident,\n+            _ => {\n+                self.handler.span_err(trait_attr.span, \"must only be one word\");\n                 return\n             }\n         };\n-        if !trait_attr.is_word() {\n-            self.handler.span_err(trait_attr.span(), \"must only be one word\");\n-        }\n \n-        if deriving::is_builtin_trait(trait_name) {\n-            self.handler.span_err(trait_attr.span(),\n+        if deriving::is_builtin_trait(trait_ident.name) {\n+            self.handler.span_err(trait_attr.span,\n                                   \"cannot override a built-in #[derive] mode\");\n         }\n \n+        let attributes_attr = list.get(1);\n         let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n             if !attr.check_name(\"attributes\") {\n                 self.handler.span_err(attr.span(), \"second argument must be `attributes`\")\n@@ -141,20 +144,22 @@ impl<'a> CollectProcMacros<'a> {\n                                        `attributes(foo, bar)`\");\n                 &[]\n             }).into_iter().filter_map(|attr| {\n-                let name = match attr.name() {\n-                    Some(name) => name,\n+                let attr = match attr.meta_item() {\n+                    Some(meta_item) => meta_item,\n                     _ => {\n                         self.handler.span_err(attr.span(), \"not a meta item\");\n                         return None;\n                     },\n                 };\n \n-                if !attr.is_word() {\n-                    self.handler.span_err(attr.span(), \"must only be one word\");\n-                    return None;\n-                }\n-\n-                Some(name)\n+                let ident = match attr.ident() {\n+                    Some(ident) if attr.is_word() => ident,\n+                    _ => {\n+                        self.handler.span_err(attr.span, \"must only be one word\");\n+                        return None;\n+                    }\n+                };\n+                Some(ident.name)\n             }).collect()\n         } else {\n             Vec::new()\n@@ -163,7 +168,7 @@ impl<'a> CollectProcMacros<'a> {\n         if self.in_root && item.vis.node.is_pub() {\n             self.derives.push(ProcMacroDerive {\n                 span: item.span,\n-                trait_name,\n+                trait_name: trait_ident.name,\n                 function_name: item.ident,\n                 attrs: proc_attrs,\n             });"}, {"sha": "750f63f9b6b1b2e5dacde22f03ff9f67009e5d5c", "filename": "src/test/ui/proc-macro/attribute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -31,7 +31,7 @@ pub fn foo5(input: TokenStream) -> TokenStream { input }\n pub fn foo6(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(m::d7)]\n-//FIXME ERROR: must only be one word\n+//~^ ERROR: must only be one word\n pub fn foo7(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(d8(a))]\n@@ -64,7 +64,7 @@ pub fn foo13(input: TokenStream) -> TokenStream { input }\n pub fn foo14(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(d15, attributes(m::a))]\n-//FIXME ERROR: must only be one word\n+//~^ ERROR: must only be one word\n pub fn foo15(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(d16, attributes(a(b)))]"}, {"sha": "a1b3a4aaf2923caa54da78d7e940d0b480f60567", "filename": "src/test/ui/proc-macro/attribute.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8371caf5ee13e775d2b2dc64c9b08e37dab49eda/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr?ref=8371caf5ee13e775d2b2dc64c9b08e37dab49eda", "patch": "@@ -22,6 +22,12 @@ error: must only be one word\n LL | #[proc_macro_derive(d6 = \"\")]\n    |                     ^^^^^^^\n \n+error: must only be one word\n+  --> $DIR/attribute.rs:33:21\n+   |\n+LL | #[proc_macro_derive(m::d7)]\n+   |                     ^^^^^\n+\n error: must only be one word\n   --> $DIR/attribute.rs:37:21\n    |\n@@ -64,6 +70,12 @@ error: must only be one word\n LL | #[proc_macro_derive(d14, attributes(a = \"\"))]\n    |                                     ^^^^^^\n \n+error: must only be one word\n+  --> $DIR/attribute.rs:66:37\n+   |\n+LL | #[proc_macro_derive(d15, attributes(m::a))]\n+   |                                     ^^^^\n+\n error: must only be one word\n   --> $DIR/attribute.rs:70:37\n    |\n@@ -82,5 +94,5 @@ error: attribute must be of the form `#[proc_macro_derive(TraitName, /*opt*/ att\n LL | #[proc_macro_derive = \"\"]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 16 previous errors\n "}]}