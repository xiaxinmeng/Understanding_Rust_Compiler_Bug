{"sha": "018440c11e2fb13d96537807c98f6df9222e2fea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxODQ0MGMxMWUyZmIxM2Q5NjUzNzgwN2M5OGY2ZGY5MjIyZTJmZWE=", "commit": {"author": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-06-23T00:18:17Z"}, "committer": {"name": "flip1995", "email": "hello@philkrones.com", "date": "2020-06-23T00:18:17Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "358b6dace7b70e6977b2d633f7947a6e0c196cd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/358b6dace7b70e6977b2d633f7947a6e0c196cd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/018440c11e2fb13d96537807c98f6df9222e2fea", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEqv54U47RUUXZfOLnLO/Nsn7QvnkFAl7xSk0ACgkQLO/Nsn7Q\nvnlo4A/9HFRSV6OHTopBZ1KTIwsy7dlMZnRBsVTSr4vFXKO8Wyz4whN2FzqaqMnW\n4SmxRqTtmuW1fXwxEvDAIv1gT5bULDSm+o7fclsHpzMiNWg4EuVi0oFzBPlPDmIS\n4yH0fNcqHmXb31Y6GqbKE4DE5V9SMGSG/xMiYUvSBQJBNUpW9Yv6MU/7jO3spL+5\nyXRR5rvWObseSJOYGcteBQP7Em7g5moCZlZ5sb00HmjLLdzkTSbAu1SX+GxEOyoR\n1sSm5C8C5VZKtxZqU+YXR0XhJuK8sFDQnuCKTq9mmwmkEud+oVHZm0VkVVS44Euh\nsuXT82MBk/WlCb14sMJ2uYrCtSzmt4mkaC28ay4bZhu0rjBpX0CLY1g73N0Z3z9d\nfp/Q8wdpCpB6PTQpa5HKW0RqcA6Ub7ZYnfEusm+QdpX4Nf//O2vicrtXPFVlMBWs\nevLcU9pr5jO8fULODlrm8mQKl7EMdehOOcO2Ej8Z2u/KuMXLg49s4/jBIAMAng1L\nDP8ckcK/WbrnNi0obOEjHr9vD4l2KV3F9XghX2MiPXeWjhmYQLwhiGwjkPOlflDT\nOmWmmvZz3cmUSWkfcLvXee8mH0RUwR77+t/VV/oeBUXNNYOWRrQKVUaWHz//aPIu\nfCAbJ/DJyNn4o5uAYcKZkpDXpEvEz7Q4J1AwDla3SWI7u+55CPs=\n=7nOw\n-----END PGP SIGNATURE-----", "payload": "tree 358b6dace7b70e6977b2d633f7947a6e0c196cd9\nparent e11b873c70129eb14a49f7f0853a334f838afcce\nparent 742706511c9f33c6a0d4380392e513e5249057e3\nauthor flip1995 <hello@philkrones.com> 1592871497 +0200\ncommitter flip1995 <hello@philkrones.com> 1592871497 +0200\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/018440c11e2fb13d96537807c98f6df9222e2fea", "html_url": "https://github.com/rust-lang/rust/commit/018440c11e2fb13d96537807c98f6df9222e2fea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/018440c11e2fb13d96537807c98f6df9222e2fea/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e11b873c70129eb14a49f7f0853a334f838afcce", "url": "https://api.github.com/repos/rust-lang/rust/commits/e11b873c70129eb14a49f7f0853a334f838afcce", "html_url": "https://github.com/rust-lang/rust/commit/e11b873c70129eb14a49f7f0853a334f838afcce"}, {"sha": "742706511c9f33c6a0d4380392e513e5249057e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/742706511c9f33c6a0d4380392e513e5249057e3", "html_url": "https://github.com/rust-lang/rust/commit/742706511c9f33c6a0d4380392e513e5249057e3"}], "stats": {"total": 467, "additions": 404, "deletions": 63}, "files": [{"sha": "021fbe932d895916e7198b2a3792416bd217c60a", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -1062,7 +1062,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_early_pass(|| box option_env_unwrap::OptionEnvUnwrap);\n     let warn_on_all_wildcard_imports = conf.warn_on_all_wildcard_imports;\n     store.register_late_pass(move || box wildcard_imports::WildcardImports::new(warn_on_all_wildcard_imports));\n-    store.register_early_pass(|| box macro_use::MacroUseImports);\n     store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n@@ -1080,6 +1079,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         single_char_binding_names_threshold,\n     });\n     store.register_early_pass(|| box unnested_or_patterns::UnnestedOrPatterns);\n+    store.register_late_pass(|| box macro_use::MacroUseImports::default());\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),"}, {"sha": "b845b20d2c012c6dc6b4193d36a1b79da03ee2b2", "filename": "clippy_lints/src/macro_use.rs", "status": "modified", "additions": 196, "deletions": 17, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Fmacro_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Fmacro_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmacro_use.rs?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -1,18 +1,21 @@\n-use crate::utils::{snippet, span_lint_and_sugg};\n+use crate::utils::{in_macro, snippet, span_lint_and_sugg};\n+use hir::def::{DefKind, Res};\n use if_chain::if_chain;\n use rustc_ast::ast;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::edition::Edition;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{edition::Edition, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `#[macro_use] use...`.\n     ///\n     /// **Why is this bad?** Since the Rust 2018 edition you can import\n     /// macro's directly, this is considered idiomatic.\n     ///\n-    /// **Known problems:** This lint does not generate an auto-applicable suggestion.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     /// ```rust\n@@ -24,29 +27,205 @@ declare_clippy_lint! {\n     \"#[macro_use] is no longer needed\"\n }\n \n-declare_lint_pass!(MacroUseImports => [MACRO_USE_IMPORTS]);\n+const BRACKETS: &[char] = &['<', '>'];\n \n-impl EarlyLintPass for MacroUseImports {\n-    fn check_item(&mut self, ecx: &EarlyContext<'_>, item: &ast::Item) {\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+struct PathAndSpan {\n+    path: String,\n+    span: Span,\n+}\n+\n+/// `MacroRefData` includes the name of the macro\n+/// and the path from `SourceMap::span_to_filename`.\n+#[derive(Debug, Clone)]\n+pub struct MacroRefData {\n+    name: String,\n+    path: String,\n+}\n+\n+impl MacroRefData {\n+    pub fn new(name: String, callee: Span, cx: &LateContext<'_, '_>) -> Self {\n+        let mut path = cx.sess().source_map().span_to_filename(callee).to_string();\n+\n+        // std lib paths are <::std::module::file type>\n+        // so remove brackets, space and type.\n+        if path.contains('<') {\n+            path = path.replace(BRACKETS, \"\");\n+        }\n+        if path.contains(' ') {\n+            path = path.split(' ').next().unwrap().to_string();\n+        }\n+        Self { name, path }\n+    }\n+}\n+\n+#[derive(Default)]\n+#[allow(clippy::module_name_repetitions)]\n+pub struct MacroUseImports {\n+    /// the actual import path used and the span of the attribute above it.\n+    imports: Vec<(String, Span)>,\n+    /// the span of the macro reference, kept to ensure only one reference is used per macro call.\n+    collected: FxHashSet<Span>,\n+    mac_refs: Vec<MacroRefData>,\n+}\n+\n+impl_lint_pass!(MacroUseImports => [MACRO_USE_IMPORTS]);\n+\n+impl MacroUseImports {\n+    fn push_unique_macro(&mut self, cx: &LateContext<'_, '_>, span: Span) {\n+        let call_site = span.source_callsite();\n+        let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+        if let Some(callee) = span.source_callee() {\n+            if !self.collected.contains(&call_site) {\n+                let name = if name.contains(\"::\") {\n+                    name.split(\"::\").last().unwrap().to_string()\n+                } else {\n+                    name.to_string()\n+                };\n+\n+                self.mac_refs.push(MacroRefData::new(name, callee.def_site, cx));\n+                self.collected.insert(call_site);\n+            }\n+        }\n+    }\n+\n+    fn push_unique_macro_pat_ty(&mut self, cx: &LateContext<'_, '_>, span: Span) {\n+        let call_site = span.source_callsite();\n+        let name = snippet(cx, cx.sess().source_map().span_until_char(call_site, '!'), \"_\");\n+        if let Some(callee) = span.source_callee() {\n+            if !self.collected.contains(&call_site) {\n+                self.mac_refs\n+                    .push(MacroRefData::new(name.to_string(), callee.def_site, cx));\n+                self.collected.insert(call_site);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'l, 'txc> LateLintPass<'l, 'txc> for MacroUseImports {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item<'_>) {\n         if_chain! {\n-            if ecx.sess.opts.edition == Edition::Edition2018;\n-            if let ast::ItemKind::Use(use_tree) = &item.kind;\n+            if cx.sess().opts.edition == Edition::Edition2018;\n+            if let hir::ItemKind::Use(path, _kind) = &item.kind;\n             if let Some(mac_attr) = item\n                 .attrs\n                 .iter()\n                 .find(|attr| attr.ident().map(|s| s.to_string()) == Some(\"macro_use\".to_string()));\n+            if let Res::Def(DefKind::Mod, id) = path.res;\n             then {\n-                let msg = \"`macro_use` attributes are no longer needed in the Rust 2018 edition\";\n-                let help = format!(\"use {}::<macro name>\", snippet(ecx, use_tree.span, \"_\"));\n+                for kid in cx.tcx.item_children(id).iter() {\n+                    if let Res::Def(DefKind::Macro(_mac_type), mac_id) = kid.res {\n+                        let span = mac_attr.span;\n+                        let def_path = cx.tcx.def_path_str(mac_id);\n+                        self.imports.push((def_path, span));\n+                    }\n+                }\n+            } else {\n+                if in_macro(item.span) {\n+                    self.push_unique_macro_pat_ty(cx, item.span);\n+                }\n+            }\n+        }\n+    }\n+    fn check_attribute(&mut self, cx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n+        if in_macro(attr.span) {\n+            self.push_unique_macro(cx, attr.span);\n+        }\n+    }\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>) {\n+        if in_macro(expr.span) {\n+            self.push_unique_macro(cx, expr.span);\n+        }\n+    }\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, stmt: &hir::Stmt<'_>) {\n+        if in_macro(stmt.span) {\n+            self.push_unique_macro(cx, stmt.span);\n+        }\n+    }\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat<'_>) {\n+        if in_macro(pat.span) {\n+            self.push_unique_macro_pat_ty(cx, pat.span);\n+        }\n+    }\n+    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &hir::Ty<'_>) {\n+        if in_macro(ty.span) {\n+            self.push_unique_macro_pat_ty(cx, ty.span);\n+        }\n+    }\n+    #[allow(clippy::too_many_lines)]\n+    fn check_crate_post(&mut self, cx: &LateContext<'_, '_>, _krate: &hir::Crate<'_>) {\n+        let mut used = FxHashMap::default();\n+        let mut check_dup = vec![];\n+        for (import, span) in &self.imports {\n+            let found_idx = self.mac_refs.iter().position(|mac| import.ends_with(&mac.name));\n+\n+            if let Some(idx) = found_idx {\n+                let _ = self.mac_refs.remove(idx);\n+                let seg = import.split(\"::\").collect::<Vec<_>>();\n+\n+                match seg.as_slice() {\n+                    // an empty path is impossible\n+                    // a path should always consist of 2 or more segments\n+                    [] | [_] => return,\n+                    [root, item] => {\n+                        if !check_dup.contains(&(*item).to_string()) {\n+                            used.entry(((*root).to_string(), span))\n+                                .or_insert_with(Vec::new)\n+                                .push((*item).to_string());\n+                            check_dup.push((*item).to_string());\n+                        }\n+                    },\n+                    [root, rest @ ..] => {\n+                        if rest.iter().all(|item| !check_dup.contains(&(*item).to_string())) {\n+                            let filtered = rest\n+                                .iter()\n+                                .filter_map(|item| {\n+                                    if check_dup.contains(&(*item).to_string()) {\n+                                        None\n+                                    } else {\n+                                        Some((*item).to_string())\n+                                    }\n+                                })\n+                                .collect::<Vec<_>>();\n+                            used.entry(((*root).to_string(), span))\n+                                .or_insert_with(Vec::new)\n+                                .push(filtered.join(\"::\"));\n+                            check_dup.extend(filtered);\n+                        } else {\n+                            let rest = rest.to_vec();\n+                            used.entry(((*root).to_string(), span))\n+                                .or_insert_with(Vec::new)\n+                                .push(rest.join(\"::\"));\n+                            check_dup.extend(rest.iter().map(ToString::to_string));\n+                        }\n+                    },\n+                }\n+            }\n+        }\n+\n+        let mut suggestions = vec![];\n+        for ((root, span), path) in used {\n+            if path.len() == 1 {\n+                suggestions.push((span, format!(\"{}::{}\", root, path[0])))\n+            } else {\n+                suggestions.push((span, format!(\"{}::{{{}}}\", root, path.join(\", \"))))\n+            }\n+        }\n+\n+        // If mac_refs is not empty we have encountered an import we could not handle\n+        // such as `std::prelude::v1::foo` or some other macro that expands to an import.\n+        if self.mac_refs.is_empty() {\n+            for (span, import) in suggestions {\n+                let help = format!(\"use {};\", import);\n                 span_lint_and_sugg(\n-                    ecx,\n+                    cx,\n                     MACRO_USE_IMPORTS,\n-                    mac_attr.span,\n-                    msg,\n+                    *span,\n+                    \"`macro_use` attributes are no longer needed in the Rust 2018 edition\",\n                     \"remove the attribute and import the macro directly, try\",\n                     help,\n-                    Applicability::HasPlaceholders,\n-                );\n+                    Applicability::MaybeIncorrect,\n+                )\n             }\n         }\n     }"}, {"sha": "56658cb5abab410098780d686df23c940aef7488", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -40,9 +40,8 @@ declare_clippy_lint! {\n     ///     assert_eq!(v.len(), 42);\n     /// }\n     /// ```\n-    ///\n+    /// should be\n     /// ```rust\n-    /// // should be\n     /// fn foo(v: &[i32]) {\n     ///     assert_eq!(v.len(), 42);\n     /// }\n@@ -173,13 +172,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                     !preds.is_empty() && {\n                         let ty_empty_region = cx.tcx.mk_imm_ref(cx.tcx.lifetimes.re_root_empty, ty);\n                         preds.iter().all(|t| {\n-                            let ty_params = &t\n-                                .skip_binder()\n-                                .trait_ref\n-                                .substs\n-                                .iter()\n-                                .skip(1)\n-                                .collect::<Vec<_>>();\n+                            let ty_params = &t.skip_binder().trait_ref.substs.iter().skip(1).collect::<Vec<_>>();\n                             implements_trait(cx, ty_empty_region, t.def_id(), ty_params)\n                         })\n                     },"}, {"sha": "9a9aa3f94eb4b64ad6bfe491d82aee84442ddd02", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -309,18 +309,15 @@ fn swap_binop<'a>(\n     rhs: &'a Expr<'a>,\n ) -> Option<(BinOpKind, &'a Expr<'a>, &'a Expr<'a>)> {\n     match binop {\n-        BinOpKind::Add\n-        | BinOpKind::Mul\n-        | BinOpKind::Eq\n-        | BinOpKind::Ne\n-        | BinOpKind::BitAnd\n-        | BinOpKind::BitXor\n-        | BinOpKind::BitOr => Some((binop, rhs, lhs)),\n+        BinOpKind::Add | BinOpKind::Eq | BinOpKind::Ne | BinOpKind::BitAnd | BinOpKind::BitXor | BinOpKind::BitOr => {\n+            Some((binop, rhs, lhs))\n+        },\n         BinOpKind::Lt => Some((BinOpKind::Gt, rhs, lhs)),\n         BinOpKind::Le => Some((BinOpKind::Ge, rhs, lhs)),\n         BinOpKind::Ge => Some((BinOpKind::Le, rhs, lhs)),\n         BinOpKind::Gt => Some((BinOpKind::Lt, rhs, lhs)),\n-        BinOpKind::Shl\n+        BinOpKind::Mul // Not always commutative, e.g. with matrices. See issue #5698\n+        | BinOpKind::Shl\n         | BinOpKind::Shr\n         | BinOpKind::Rem\n         | BinOpKind::Sub"}, {"sha": "732f4b28e06e3e1b449b2ff9a0889eb2d87d274e", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -23,7 +23,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// println!(\"\");\n+    ///\n+    /// // Good\n+    /// println!();\n     /// ```\n     pub PRINTLN_EMPTY_STRING,\n     style,\n@@ -32,8 +36,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `print!()` with a format\n-    /// string that\n-    /// ends in a newline.\n+    /// string that ends in a newline.\n     ///\n     /// **Why is this bad?** You should use `println!()` instead, which appends the\n     /// newline.\n@@ -125,7 +128,12 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n+    ///\n+    /// // Bad\n     /// writeln!(buf, \"\");\n+    ///\n+    /// // Good\n+    /// writeln!(buf);\n     /// ```\n     pub WRITELN_EMPTY_STRING,\n     style,\n@@ -147,7 +155,12 @@ declare_clippy_lint! {\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n     /// # let name = \"World\";\n+    ///\n+    /// // Bad\n     /// write!(buf, \"Hello {}!\\n\", name);\n+    ///\n+    /// // Good\n+    /// writeln!(buf, \"Hello {}!\", name);\n     /// ```\n     pub WRITE_WITH_NEWLINE,\n     style,\n@@ -168,7 +181,12 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n+    ///\n+    /// // Bad\n     /// writeln!(buf, \"{}\", \"foo\");\n+    ///\n+    /// // Good\n+    /// writeln!(buf, \"foo\");\n     /// ```\n     pub WRITE_LITERAL,\n     style,\n@@ -279,12 +297,11 @@ impl EarlyLintPass for Write {\n             if let (Some(fmt_str), expr) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let suggestion = match expr {\n-                        Some(expr) => snippet_with_applicability(cx, expr.span, \"v\", &mut applicability),\n-                        None => {\n-                            applicability = Applicability::HasPlaceholders;\n-                            Cow::Borrowed(\"v\")\n-                        },\n+                    let suggestion = if let Some(e) = expr {\n+                        snippet_with_applicability(cx, e.span, \"v\", &mut applicability)\n+                    } else {\n+                        applicability = Applicability::HasPlaceholders;\n+                        Cow::Borrowed(\"v\")\n                     };\n \n                     span_lint_and_sugg("}, {"sha": "99505fc6b29b252f09404680d0e9dd5649e76ae4", "filename": "tests/compile-test.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -155,9 +155,6 @@ fn run_ui_toml(config: &mut compiletest::Config) {\n }\n \n fn run_ui_cargo(config: &mut compiletest::Config) {\n-    if cargo::is_rustc_test_suite() {\n-        return;\n-    }\n     fn run_tests(\n         config: &compiletest::Config,\n         filter: &Option<String>,"}, {"sha": "ecb55d8cb48d5bbcb6f32ba3223d6ef8671793ed", "filename": "tests/ui/auxiliary/macro_use_helper.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_use_helper.rs?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -0,0 +1,60 @@\n+extern crate macro_rules;\n+\n+// STMT\n+#[macro_export]\n+macro_rules! pub_macro {\n+    () => {\n+        let _ = \"hello Mr. Vonnegut\";\n+    };\n+}\n+\n+pub mod inner {\n+    pub use super::*;\n+\n+    // RE-EXPORT\n+    // this will stick in `inner` module\n+    pub use macro_rules::foofoo;\n+    pub use macro_rules::try_err;\n+\n+    pub mod nested {\n+        pub use macro_rules::string_add;\n+    }\n+\n+    // ITEM\n+    #[macro_export]\n+    macro_rules! inner_mod_macro {\n+        () => {\n+            #[allow(dead_code)]\n+            pub struct Tardis;\n+        };\n+    }\n+}\n+\n+// EXPR\n+#[macro_export]\n+macro_rules! function_macro {\n+    () => {\n+        if true {\n+        } else {\n+        }\n+    };\n+}\n+\n+// TYPE\n+#[macro_export]\n+macro_rules! ty_macro {\n+    () => {\n+        Vec<u8>\n+    };\n+}\n+\n+mod extern_exports {\n+    pub(super) mod private_inner {\n+        #[macro_export]\n+        macro_rules! pub_in_private_macro {\n+            ($name:ident) => {\n+                let $name = String::from(\"secrets and lies\");\n+            };\n+        }\n+    }\n+}"}, {"sha": "9c5fe02f7519bd25b178af70bf7b01da77520463", "filename": "tests/ui/if_same_then_else.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fif_same_then_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fif_same_then_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else.rs?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -142,4 +142,16 @@ fn func() {\n \n fn f(val: &[u8]) {}\n \n+mod issue_5698 {\n+    fn mul_not_always_commutative(x: i32, y: i32) -> i32 {\n+        if x == 42 {\n+            x * y\n+        } else if x == 21 {\n+            y * x\n+        } else {\n+            0\n+        }\n+    }\n+}\n+\n fn main() {}"}, {"sha": "91e34c62160a129672ce3c9f08da34e3943ffd04", "filename": "tests/ui/macro_use_imports.fixed", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fmacro_use_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fmacro_use_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.fixed?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -0,0 +1,43 @@\n+// compile-flags: --edition 2018\n+// aux-build:macro_rules.rs\n+// aux-build:macro_use_helper.rs\n+// run-rustfix\n+// ignore-32bit\n+\n+#![allow(unused_imports, unreachable_code, unused_variables, dead_code)]\n+#![allow(clippy::single_component_path_imports)]\n+#![warn(clippy::macro_use_imports)]\n+\n+#[macro_use]\n+extern crate macro_use_helper as mac;\n+\n+#[macro_use]\n+extern crate clippy_mini_macro_test as mini_mac;\n+\n+mod a {\n+    use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro};\n+    use mac;\n+    use mini_mac::ClippyMiniMacroTest;\n+    use mini_mac;\n+    use mac::{inner::foofoo, inner::try_err};\n+    use mac::inner;\n+    use mac::inner::nested::string_add;\n+    use mac::inner::nested;\n+\n+    #[derive(ClippyMiniMacroTest)]\n+    struct Test;\n+\n+    fn test() {\n+        pub_macro!();\n+        inner_mod_macro!();\n+        pub_in_private_macro!(_var);\n+        function_macro!();\n+        let v: ty_macro!() = Vec::default();\n+\n+        inner::try_err!();\n+        inner::foofoo!();\n+        nested::string_add!();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "9c3c50c5d49f29b0a03eea1ca77c583a71686597", "filename": "tests/ui/macro_use_imports.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fmacro_use_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fmacro_use_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.rs?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -1,11 +1,43 @@\n-// edition:2018\n+// compile-flags: --edition 2018\n+// aux-build:macro_rules.rs\n+// aux-build:macro_use_helper.rs\n+// run-rustfix\n+// ignore-32bit\n+\n+#![allow(unused_imports, unreachable_code, unused_variables, dead_code)]\n+#![allow(clippy::single_component_path_imports)]\n #![warn(clippy::macro_use_imports)]\n \n-use std::collections::HashMap;\n #[macro_use]\n-use std::prelude;\n+extern crate macro_use_helper as mac;\n+\n+#[macro_use]\n+extern crate clippy_mini_macro_test as mini_mac;\n+\n+mod a {\n+    #[macro_use]\n+    use mac;\n+    #[macro_use]\n+    use mini_mac;\n+    #[macro_use]\n+    use mac::inner;\n+    #[macro_use]\n+    use mac::inner::nested;\n \n-fn main() {\n-    let _ = HashMap::<u8, u8>::new();\n-    println!();\n+    #[derive(ClippyMiniMacroTest)]\n+    struct Test;\n+\n+    fn test() {\n+        pub_macro!();\n+        inner_mod_macro!();\n+        pub_in_private_macro!(_var);\n+        function_macro!();\n+        let v: ty_macro!() = Vec::default();\n+\n+        inner::try_err!();\n+        inner::foofoo!();\n+        nested::string_add!();\n+    }\n }\n+\n+fn main() {}"}, {"sha": "f8c86c8d9179f8af918b684eb9294c18ea4a7008", "filename": "tests/ui/macro_use_imports.stderr", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fmacro_use_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/018440c11e2fb13d96537807c98f6df9222e2fea/tests%2Fui%2Fmacro_use_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmacro_use_imports.stderr?ref=018440c11e2fb13d96537807c98f6df9222e2fea", "patch": "@@ -1,10 +1,28 @@\n error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n-  --> $DIR/macro_use_imports.rs:5:1\n+  --> $DIR/macro_use_imports.rs:18:5\n    |\n-LL | #[macro_use]\n-   | ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use std::prelude::<macro name>`\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{pub_macro, inner_mod_macro, function_macro, ty_macro, pub_in_private_macro};`\n    |\n    = note: `-D clippy::macro-use-imports` implied by `-D warnings`\n \n-error: aborting due to previous error\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:20:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mini_mac::ClippyMiniMacroTest;`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:22:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::{inner::foofoo, inner::try_err};`\n+\n+error: `macro_use` attributes are no longer needed in the Rust 2018 edition\n+  --> $DIR/macro_use_imports.rs:24:5\n+   |\n+LL |     #[macro_use]\n+   |     ^^^^^^^^^^^^ help: remove the attribute and import the macro directly, try: `use mac::inner::nested::string_add;`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "319de217e0d90170c1bcf7545aef25e1caff11d5", "filename": "util/dev", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e11b873c70129eb14a49f7f0853a334f838afcce/util%2Fdev", "raw_url": "https://github.com/rust-lang/rust/raw/e11b873c70129eb14a49f7f0853a334f838afcce/util%2Fdev", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fdev?ref=e11b873c70129eb14a49f7f0853a334f838afcce", "patch": "@@ -1,7 +0,0 @@\n-#!/bin/sh\n-CARGO_TARGET_DIR=$(pwd)/target/\n-export CARGO_TARGET_DIR\n-\n-echo 'Deprecated! `util/dev` usage is deprecated, please use `cargo dev` instead.'\n-\n-cd clippy_dev && cargo run -- \"$@\""}]}