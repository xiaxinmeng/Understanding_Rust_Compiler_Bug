{"sha": "bf4efa3a204b54d3467521858321ae6e71e9f2bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNGVmYTNhMjA0YjU0ZDM0Njc1MjE4NTgzMjFhZTZlNzFlOWYyYmY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2011-12-17T03:48:19Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2011-12-17T03:48:19Z"}, "message": "Merge pull request #1319 from elly/cargo\n\ncargo: support distributed package indexes", "tree": {"sha": "b4ec69010a1d9fe69e8b45033e4b4f57ff5e0bfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4ec69010a1d9fe69e8b45033e4b4f57ff5e0bfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf4efa3a204b54d3467521858321ae6e71e9f2bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf4efa3a204b54d3467521858321ae6e71e9f2bf", "html_url": "https://github.com/rust-lang/rust/commit/bf4efa3a204b54d3467521858321ae6e71e9f2bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf4efa3a204b54d3467521858321ae6e71e9f2bf/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c758e11fd37f54ddfa9a628466fde7c92c027947", "url": "https://api.github.com/repos/rust-lang/rust/commits/c758e11fd37f54ddfa9a628466fde7c92c027947", "html_url": "https://github.com/rust-lang/rust/commit/c758e11fd37f54ddfa9a628466fde7c92c027947"}, {"sha": "c8427e4ffd59ba6e6347ece491aca43b17207c2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8427e4ffd59ba6e6347ece491aca43b17207c2e", "html_url": "https://github.com/rust-lang/rust/commit/c8427e4ffd59ba6e6347ece491aca43b17207c2e"}], "stats": {"total": 352, "additions": 307, "deletions": 45}, "files": [{"sha": "54267c570fe340cc7f3d2e524798605f3cd849ef", "filename": "src/cargo/cargo.rc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf4efa3a204b54d3467521858321ae6e71e9f2bf/src%2Fcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/bf4efa3a204b54d3467521858321ae6e71e9f2bf/src%2Fcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rc?ref=bf4efa3a204b54d3467521858321ae6e71e9f2bf", "patch": "@@ -2,13 +2,15 @@\n \n // cargo.rs - Rust package manager\n \n-use std;\n-use rustc;\n-\n // Local Variables:\n // fill-column: 78;\n // indent-tabs-mode: nil\n // c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n // compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:\n+\n+#[link(name = \"cargo\",\n+       vers = \"0.1\",\n+       uuid = \"9ff87a04-8fed-4295-9ff8-f99bb802650b\",\n+       url = \"http://rust-lang.org/doc/cargo\")];"}, {"sha": "a982d7473aab27fe5181f21610b072300a9b1688", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 297, "deletions": 42, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/bf4efa3a204b54d3467521858321ae6e71e9f2bf/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf4efa3a204b54d3467521858321ae6e71e9f2bf/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=bf4efa3a204b54d3467521858321ae6e71e9f2bf", "patch": "@@ -1,5 +1,8 @@\n // cargo.rs - Rust package manager\n \n+use rustc;\n+use std;\n+\n import rustc::syntax::{ast, codemap, visit};\n import rustc::syntax::parse::parser;\n \n@@ -9,18 +12,40 @@ import std::io;\n import std::json;\n import option;\n import option::{none, some};\n+import result;\n+import std::map;\n import std::os;\n import std::run;\n import str;\n import std::tempfile;\n import vec;\n \n+tag _src {\n+    /* Break cycles in package <-> source */\n+    _source(source);\n+}\n+\n+type package = {\n+//    source: _src,\n+    name: str,\n+    uuid: str,\n+    url: str,\n+    method: str\n+};\n+\n+type source = {\n+    name: str,\n+    url: str,\n+    mutable packages: [package]\n+};\n+\n type cargo = {\n     root: str,\n     bindir: str,\n     libdir: str,\n     workdir: str,\n-    fetchdir: str\n+    sourcedir: str,\n+    sources: map::hashmap<str, source>\n };\n \n type pkg = {\n@@ -32,6 +57,18 @@ type pkg = {\n     crate_type: option::t<str>\n };\n \n+fn info(msg: str) {\n+    io::stdout().write_line(msg);\n+}\n+\n+fn warn(msg: str) {\n+    io::stdout().write_line(\"warning: \" + msg);\n+}\n+\n+fn error(msg: str) {\n+    io::stdout().write_line(\"error: \" + msg);\n+}\n+\n fn load_link(mis: [@ast::meta_item]) -> (option::t<str>,\n                                          option::t<str>,\n                                          option::t<str>) {\n@@ -118,6 +155,104 @@ fn need_dir(s: str) {\n     }\n }\n \n+fn parse_source(name: str, j: json::json) -> source {\n+    alt j {\n+        json::dict(_j) {\n+            alt _j.find(\"url\") {\n+                some(json::string(u)) {\n+                    ret { name: name, url: u, mutable packages: [] };\n+                }\n+                _ { fail \"Needed 'url' field in source.\"; }\n+            };\n+        }\n+        _ { fail \"Needed dict value in source.\"; }\n+    };\n+}\n+\n+fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n+    if !fs::path_exists(filename)  { ret; }\n+    let c = io::read_whole_file_str(filename);\n+    let j = json::from_str(result::get(c));\n+    alt j {\n+        some(json::dict(_j)) {\n+            _j.items { |k, v|\n+                sources.insert(k, parse_source(k, v));\n+                log #fmt[\"source: %s\", k];\n+            }\n+        }\n+        _ { fail \"malformed sources.json\"; }\n+    }\n+}\n+\n+fn load_one_source_package(&src: source, p: map::hashmap<str, json::json>) {\n+    let name = alt p.find(\"name\") {\n+        some(json::string(_n)) { _n }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name + \" (missing name)\");\n+            ret;\n+        }\n+    };\n+\n+    let uuid = alt p.find(\"uuid\") {\n+        some(json::string(_n)) { _n }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name + \" (missing uuid)\");\n+            ret;\n+        }\n+    };\n+\n+    let url = alt p.find(\"url\") {\n+        some(json::string(_n)) { _n }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name + \" (missing url)\");\n+            ret;\n+        }\n+    };\n+\n+    let method = alt p.find(\"method\") {\n+        some(json::string(_n)) { _n }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name + \" (missing method)\");\n+            ret;\n+        }\n+    };\n+\n+    vec::grow(src.packages, 1u, {\n+        // source: _source(src),\n+        name: name,\n+        uuid: uuid,\n+        url: url,\n+        method: method\n+    });\n+    info(\"  Loaded package: \" + src.name + \"/\" + name);\n+}\n+\n+fn load_source_packages(&c: cargo, &src: source) {\n+    info(\"Loading source: \" + src.name);\n+    let dir = fs::connect(c.sourcedir, src.name);\n+    let pkgfile = fs::connect(dir, \"packages.json\");\n+    if !fs::path_exists(pkgfile) { ret; }\n+    let pkgstr = io::read_whole_file_str(pkgfile);\n+    let j = json::from_str(result::get(pkgstr));\n+    alt j {\n+        some(json::list(js)) {\n+            for _j: json::json in *js {\n+                alt _j {\n+                    json::dict(_p) {\n+                        load_one_source_package(src, _p);\n+                    }\n+                    _ {\n+                        warn(\"Malformed source json: \" + src.name + \" (non-dict pkg)\");\n+                    }\n+                }\n+            }\n+        }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name);\n+        }\n+    };\n+}\n+\n fn configure() -> cargo {\n     let p = alt generic_os::getenv(\"CARGO_ROOT\") {\n         some(_p) { _p }\n@@ -129,25 +264,41 @@ fn configure() -> cargo {\n         }\n     };\n \n-    log #fmt[\"p: %s\", p];\n-\n+    let sources = map::new_str_hash::<source>();\n+    try_parse_sources(fs::connect(p, \"sources.json\"), sources);\n+    try_parse_sources(fs::connect(p, \"local-sources.json\"), sources);\n     let c = {\n         root: p,\n         bindir: fs::connect(p, \"bin\"),\n         libdir: fs::connect(p, \"lib\"),\n         workdir: fs::connect(p, \"work\"),\n-        fetchdir: fs::connect(p, \"fetch\")\n+        sourcedir: fs::connect(p, \"sources\"),\n+        sources: sources\n     };\n \n     need_dir(c.root);\n-    need_dir(c.fetchdir);\n+    need_dir(c.sourcedir);\n     need_dir(c.workdir);\n     need_dir(c.libdir);\n     need_dir(c.bindir);\n \n+    sources.keys { |k|\n+        let s = sources.get(k);\n+        load_source_packages(c, s);\n+        sources.insert(k, s);\n+    };\n+\n     c\n }\n \n+fn for_each_package(c: cargo, b: block(source, package)) {\n+    c.sources.values({ |v|\n+        for p in copy v.packages {\n+            b(v, p);\n+        }\n+    })\n+}\n+\n fn install_one_crate(c: cargo, _path: str, cf: str, _p: pkg) {\n     let name = fs::basename(cf);\n     let ri = str::index(name, '.' as u8);\n@@ -163,7 +314,7 @@ fn install_one_crate(c: cargo, _path: str, cf: str, _p: pkg) {\n     let exec_suffix = os::exec_suffix();\n     for ct: str in created {\n         if (exec_suffix != \"\" && str::ends_with(ct, exec_suffix)) ||\n-            (exec_suffix == \"\" && !str::starts_with(ct, \"lib\")) {\n+            (exec_suffix == \"\" && !str::starts_with(ct, \"./lib\")) {\n             log #fmt[\"  bin: %s\", ct];\n             // FIXME: need libstd fs::copy or something\n             run::run_program(\"cp\", [ct, c.bindir]);\n@@ -199,45 +350,113 @@ fn install_source(c: cargo, path: str) {\n     }\n }\n \n-fn install_git(c: cargo, wd: str, _path: str) {\n-    run::run_program(\"git\", [\"clone\", _path, wd]);\n+fn install_git(c: cargo, wd: str, url: str) {\n+    run::run_program(\"git\", [\"clone\", url, wd]);\n     install_source(c, wd);\n }\n \n-fn install_file(c: cargo, wd: str, _path: str) {\n+fn install_curl(c: cargo, wd: str, url: str) {\n+    let tarpath = fs::connect(wd, \"pkg.tar\");\n+    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n+                                         tarpath, url]);\n+    if p.status != 0 {\n+        fail #fmt[\"Fetch of %s failed: %s\", url, p.err];\n+    }\n     run::run_program(\"tar\", [\"-x\", \"--strip-components=1\",\n-                             \"-C\", wd, \"-f\", _path]);\n+                             \"-C\", wd, \"-f\", tarpath]);\n     install_source(c, wd);\n }\n \n-fn install_resolved(c: cargo, wd: str, key: str) {\n-    fs::remove_dir(wd);\n-    let u = \"https://rust-package-index.appspot.com/pkg/\" + key;\n-    let p = run::program_output(\"curl\", [u]);\n-    if p.status != 0 {\n-        fail #fmt[\"Fetch of %s failed: %s\", u, p.err];\n-    }\n-    let j = json::from_str(p.out);\n-    alt j {\n-        some (json::dict(_j)) {\n-            alt _j.find(\"install\") {\n-                some (json::string(g)) {\n-                    log #fmt[\"Resolved: %s -> %s\", key, g];\n-                    cmd_install(c, [\"cargo\", \"install\", g]);\n-                }\n-                _ { fail #fmt[\"Bogus install: '%s'\", p.out]; }\n-            }\n-        }\n-        _ { fail #fmt[\"Bad json: '%s'\", p.out]; }\n+fn install_file(c: cargo, wd: str, path: str) {\n+    run::run_program(\"tar\", [\"-x\", \"--strip-components=1\",\n+                             \"-C\", wd, \"-f\", path]);\n+    install_source(c, wd);\n+}\n+\n+fn install_package(c: cargo, wd: str, pkg: package) {\n+    info(\"Installing with \" + pkg.method + \" from \" + pkg.url + \"...\");\n+    if pkg.method == \"git\" {\n+        install_git(c, wd, pkg.url);\n+    } else if pkg.method == \"http\" {\n+        install_curl(c, wd, pkg.url);\n+    } else if pkg.method == \"file\" {\n+        install_file(c, wd, pkg.url);\n     }\n }\n \n fn install_uuid(c: cargo, wd: str, uuid: str) {\n-    install_resolved(c, wd, \"by-uuid/\" + uuid);\n+    let ps = [];\n+    for_each_package(c, { |s, p|\n+        info(#fmt[\"%s ? %s\", p.uuid, uuid]);\n+        if p.uuid == uuid {\n+            vec::grow(ps, 1u, (s, p));\n+        }\n+    });\n+    if vec::len(ps) == 1u {\n+        let (_, p) = ps[0];\n+        install_package(c, wd, p);\n+        ret;\n+    } else if vec::len(ps) == 0u {\n+        error(\"No packages.\");\n+        ret;\n+    }\n+    error(\"Found multiple packages:\");\n+    for (s,p) in ps {\n+        info(\"  \" + s.name + \"/\" + p.uuid + \" (\" + p.name + \")\");\n+    }\n }\n \n fn install_named(c: cargo, wd: str, name: str) {\n-    install_resolved(c, wd, \"by-name/\" + name);\n+    let ps = [];\n+    for_each_package(c, { |s, p|\n+        if p.name == name {\n+            vec::grow(ps, 1u, (s, p));\n+        }\n+    });\n+    if vec::len(ps) == 1u {\n+        let (_, p) = ps[0];\n+        install_package(c, wd, p);\n+        ret;\n+    } else if vec::len(ps) == 0u {\n+        error(\"No packages.\");\n+        ret;\n+    }\n+    error(\"Found multiple packages:\");\n+    for (s,p) in ps {\n+        info(\"  \" + s.name + \"/\" + p.uuid + \" (\" + p.name + \")\");\n+    }\n+}\n+\n+fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n+    alt c.sources.find(src) {\n+        some(s) {\n+            if vec::any(copy s.packages, { |p|\n+                if p.uuid == uuid {\n+                    install_package(c, wd, p);\n+                    ret true;\n+                }\n+                ret false;\n+            }) { ret; }\n+        }\n+        _ { }\n+    }\n+    error(\"Can't find package \" + src + \"/\" + uuid);\n+}\n+\n+fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n+    alt c.sources.find(src) {\n+        some(s) {\n+            if vec::any(copy s.packages, { |p|\n+                if p.name == name {\n+                    install_package(c, wd, p);\n+                    ret true;\n+                }\n+                ret false;\n+            }) { ret; }\n+        }\n+        _ { }\n+    }\n+    error(\"Can't find package \" + src + \"/\" + name);\n }\n \n fn cmd_install(c: cargo, argv: [str]) {\n@@ -252,24 +471,59 @@ fn cmd_install(c: cargo, argv: [str]) {\n         none. { fail \"needed temp dir\"; }\n     };\n \n-    if str::starts_with(argv[2], \"git:\") {\n-        install_git(c, wd, argv[2]);\n-    } else if str::starts_with(argv[2], \"github:\") {\n-        let path = rest(argv[2], 7u);\n-        install_git(c, wd, \"git://github.com/\" + path);\n-    } else if str::starts_with(argv[2], \"file:\") {\n-        let path = rest(argv[2], 5u);\n-        install_file(c, wd, path);\n-    } else if str::starts_with(argv[2], \"uuid:\") {\n+    if str::starts_with(argv[2], \"uuid:\") {\n         let uuid = rest(argv[2], 5u);\n-        install_uuid(c, wd, uuid);\n+        let idx = str::index(uuid, '/' as u8);\n+        if idx != -1 {\n+            let source = str::slice(uuid, 0u, idx as uint);\n+            uuid = str::slice(uuid, idx as uint + 1u, str::byte_len(uuid));\n+            install_uuid_specific(c, wd, source, uuid);\n+        } else {\n+            install_uuid(c, wd, uuid);\n+        }\n     } else {\n-        install_named(c, wd, argv[2]);\n+        let name = argv[2];\n+        let idx = str::index(name, '/' as u8);\n+        if idx != -1 {\n+            let source = str::slice(name, 0u, idx as uint);\n+            name = str::slice(name, idx as uint + 1u, str::byte_len(name));\n+            install_named_specific(c, wd, source, name);\n+        } else {\n+            install_named(c, wd, name);\n+        }\n+    }\n+}\n+\n+fn sync_one(c: cargo, name: str, src: source) {\n+    let dir = fs::connect(c.sourcedir, name);\n+    let pkgfile = fs::connect(dir, \"packages.json\");\n+    let url = src.url;\n+    need_dir(dir);\n+    info(#fmt[\"fetching source %s...\", name]);\n+    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", pkgfile, url]);\n+    if p.status != 0 {\n+        warn(#fmt[\"fetch for source %s (url %s) failed\", name, url]);\n+    } else {\n+        info(#fmt[\"fetched source: %s\", name]);\n+    }\n+}\n+\n+fn cmd_sync(c: cargo, argv: [str]) {\n+    if vec::len(argv) == 3u {\n+        sync_one(c, argv[2], c.sources.get(argv[2]));\n+    } else {\n+        c.sources.items { |k, v|\n+            sync_one(c, k, v);\n+        }\n     }\n }\n \n fn cmd_usage() {\n     print(\"Usage: cargo <verb> [args...]\");\n+    print(\"  install [source/]package-name        Install by name\");\n+    print(\"  install uuid:[source/]package-uuid   Install by uuid\");\n+    print(\"  sync                                 Sync all sources\");\n+    print(\"  usage                                This\");\n }\n \n fn main(argv: [str]) {\n@@ -280,6 +534,7 @@ fn main(argv: [str]) {\n     let c = configure();\n     alt argv[1] {\n         \"install\" { cmd_install(c, argv); }\n+        \"sync\" { cmd_sync(c, argv); }\n         \"usage\" { cmd_usage(); }\n         _ { cmd_usage(); }\n     }"}, {"sha": "c76f133e8f21be236cdc72f71d20b271f797e05d", "filename": "src/cargo/sources.json", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bf4efa3a204b54d3467521858321ae6e71e9f2bf/src%2Fcargo%2Fsources.json", "raw_url": "https://github.com/rust-lang/rust/raw/bf4efa3a204b54d3467521858321ae6e71e9f2bf/src%2Fcargo%2Fsources.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fsources.json?ref=bf4efa3a204b54d3467521858321ae6e71e9f2bf", "patch": "@@ -0,0 +1,5 @@\n+{\n+\t\"elly\": {\n+\t\t\"url\": \"https://raw.github.com/elly/rust-packages/master/packages.json\"\n+\t}\n+}"}]}