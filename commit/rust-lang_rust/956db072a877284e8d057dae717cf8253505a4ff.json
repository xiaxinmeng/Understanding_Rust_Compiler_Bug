{"sha": "956db072a877284e8d057dae717cf8253505a4ff", "node_id": "C_kwDOAAsO6NoAKDk1NmRiMDcyYTg3NzI4NGU4ZDA1N2RhZTcxN2NmODI1MzUwNWE0ZmY", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2021-12-08T17:44:50Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-01-12T14:06:11Z"}, "message": "Don't fall back to crate-level opaque type definitions.\n\nThat would just hide bugs, as it works accidentally if the opaque type\nis defined at the crate level.", "tree": {"sha": "b4e9d245a13d3078cb4475ddc8a30b6c363664d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4e9d245a13d3078cb4475ddc8a30b6c363664d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/956db072a877284e8d057dae717cf8253505a4ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/956db072a877284e8d057dae717cf8253505a4ff", "html_url": "https://github.com/rust-lang/rust/commit/956db072a877284e8d057dae717cf8253505a4ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/956db072a877284e8d057dae717cf8253505a4ff/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72e74d7b9cf1a7901650227e74650f1fcc797600", "url": "https://api.github.com/repos/rust-lang/rust/commits/72e74d7b9cf1a7901650227e74650f1fcc797600", "html_url": "https://github.com/rust-lang/rust/commit/72e74d7b9cf1a7901650227e74650f1fcc797600"}], "stats": {"total": 68, "additions": 36, "deletions": 32}, "files": [{"sha": "d3664e53447d04520cbf33233ac907a1dc8e9731", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/956db072a877284e8d057dae717cf8253505a4ff/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956db072a877284e8d057dae717cf8253505a4ff/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=956db072a877284e8d057dae717cf8253505a4ff", "patch": "@@ -10,7 +10,6 @@ pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n \n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n \n-use hir::def_id::CRATE_DEF_ID;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::undo_log::Rollback;\n@@ -291,7 +290,12 @@ pub struct InferCtxt<'a, 'tcx> {\n \n     /// The `DefId` of the item in whose context we are performing inference or typeck.\n     /// It is used to check whether an opaque type use is a defining use.\n-    pub defining_use_anchor: LocalDefId,\n+    ///\n+    /// If it is `None`, we can't resolve opaque types here and need to bubble up\n+    /// the obligation. This frequently happens for\n+    /// short lived InferCtxt within queries. The opaque type obligations are forwarded\n+    /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n+    pub defining_use_anchor: Option<LocalDefId>,\n \n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n@@ -547,7 +551,7 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n-    defining_use_anchor: LocalDefId,\n+    defining_use_anchor: Option<LocalDefId>,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -556,11 +560,7 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder {\n-            tcx: self,\n-            defining_use_anchor: CRATE_DEF_ID,\n-            fresh_typeck_results: None,\n-        }\n+        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n     }\n }\n \n@@ -580,7 +580,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// (via `with_fresh_in_progress_typeck_results`) and for the inference context used\n     /// in mir borrowck.\n     pub fn with_opaque_type_inference(mut self, defining_use_anchor: LocalDefId) -> Self {\n-        self.defining_use_anchor = defining_use_anchor;\n+        self.defining_use_anchor = Some(defining_use_anchor);\n         self\n     }\n "}, {"sha": "11153fbe7896b8d5d7677f5cbc4f56bce8eb3fb5", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/956db072a877284e8d057dae717cf8253505a4ff/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/956db072a877284e8d057dae717cf8253505a4ff/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=956db072a877284e8d057dae717cf8253505a4ff", "patch": "@@ -328,6 +328,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             },\n         });\n     }\n+\n+    fn opaque_type_origin(&self, def_id: LocalDefId) -> Option<hir::OpaqueTyOrigin> {\n+        let tcx = self.tcx;\n+        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let parent_def_id = self.defining_use_anchor?;\n+        let item_kind = &tcx.hir().expect_item(def_id).kind;\n+        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n+            span_bug!(\n+                tcx.def_span(def_id),\n+                \"weird opaque type: {:#?}\",\n+                item_kind\n+            )\n+        };\n+        let in_definition_scope = match *origin {\n+            // Async `impl Trait`\n+            hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n+            // Anonymous `impl Trait`\n+            hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n+            // Named `type Foo = impl Bar;`\n+            hir::OpaqueTyOrigin::TyAlias => {\n+                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n+            }\n+        };\n+        in_definition_scope.then_some(*origin)\n+    }\n }\n \n // Visitor that requires that (almost) all regions in the type visited outlive\n@@ -459,31 +484,10 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // }\n                     // ```\n                     if let Some(def_id) = def_id.as_local() {\n-                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                        let parent_def_id = self.infcx.defining_use_anchor;\n-                        let item_kind = &tcx.hir().expect_item(def_id).kind;\n-                        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n-                            span_bug!(\n-                                self.value_span,\n-                                \"weird opaque type: {:#?}, {:#?}\",\n-                                ty.kind(),\n-                                item_kind\n-                            )\n-                        };\n-                        let in_definition_scope = match *origin {\n-                            // Async `impl Trait`\n-                            hir::OpaqueTyOrigin::AsyncFn(parent) => parent == parent_def_id,\n-                            // Anonymous `impl Trait`\n-                            hir::OpaqueTyOrigin::FnReturn(parent) => parent == parent_def_id,\n-                            // Named `type Foo = impl Bar;`\n-                            hir::OpaqueTyOrigin::TyAlias => {\n-                                may_define_opaque_type(tcx, parent_def_id, opaque_hir_id)\n-                            }\n-                        };\n-                        if in_definition_scope {\n+                        if let Some(origin) = self.infcx.opaque_type_origin(def_id) {\n                             let opaque_type_key =\n                                 OpaqueTypeKey { def_id: def_id.to_def_id(), substs };\n-                            return self.fold_opaque_ty(ty, opaque_type_key, *origin);\n+                            return self.fold_opaque_ty(ty, opaque_type_key, origin);\n                         }\n \n                         debug!("}]}