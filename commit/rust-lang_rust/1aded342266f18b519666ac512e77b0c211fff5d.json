{"sha": "1aded342266f18b519666ac512e77b0c211fff5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZGVkMzQyMjY2ZjE4YjUxOTY2NmFjNTEyZTc3YjBjMjExZmZmNWQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-23T14:13:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-23T14:13:50Z"}, "message": "Merge #2375\n\n2375: Privatise nameres r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "48d78ab757f8df969e334ad9b7f1336f7ecc5f89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48d78ab757f8df969e334ad9b7f1336f7ecc5f89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1aded342266f18b519666ac512e77b0c211fff5d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd2T6eCRBK7hj4Ov3rIwAAdHIIAKrq/e4GqpODBM8sf3idWatE\n1zXGh5SnbEa8x6tP4Mhb4AsqcqD4cSKdchw0EHr/oCl7/IbzI+W3K4ssIL9TayMQ\nZ6gdYLd3xlqE9PJ3vKf3a2pSOhLw+9WsZmUZ7lrP9+9naTFFVJCyrW3nTduqn+2G\ncXQPLLaPpNZYm0epFGnVtrK2MzORmqKhkTwA/ylWLszx1pId7qf7lkP9B/u4mxQ4\n+xjNvFIhYmO1pO5+sE+n15O3yoPIfqg8Pv24Kl3jmgesTvD/TX6qTeqE7uwbYri8\n8YN06jH80toz6sSF9D/QpkD+cNUE54bvGIfZXvWl2LodUO0NThHhkedgFN05lRA=\n=5S1o\n-----END PGP SIGNATURE-----\n", "payload": "tree 48d78ab757f8df969e334ad9b7f1336f7ecc5f89\nparent 87903420968a958e9f420788edb181ddca7b8b31\nparent ffc2325d194d2523456484a7dec1f175c729c1b5\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574518430 +0000\ncommitter GitHub <noreply@github.com> 1574518430 +0000\n\nMerge #2375\n\n2375: Privatise nameres r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1aded342266f18b519666ac512e77b0c211fff5d", "html_url": "https://github.com/rust-lang/rust/commit/1aded342266f18b519666ac512e77b0c211fff5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1aded342266f18b519666ac512e77b0c211fff5d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87903420968a958e9f420788edb181ddca7b8b31", "url": "https://api.github.com/repos/rust-lang/rust/commits/87903420968a958e9f420788edb181ddca7b8b31", "html_url": "https://github.com/rust-lang/rust/commit/87903420968a958e9f420788edb181ddca7b8b31"}, {"sha": "ffc2325d194d2523456484a7dec1f175c729c1b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ffc2325d194d2523456484a7dec1f175c729c1b5", "html_url": "https://github.com/rust-lang/rust/commit/ffc2325d194d2523456484a7dec1f175c729c1b5"}], "stats": {"total": 309, "additions": 151, "deletions": 158}, "files": [{"sha": "fd7776fb79d1aad8e8c2154687193f53b9f9950c", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 68, "deletions": 9, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -9,18 +9,19 @@ use hir_def::{\n     body::scope::ExprScopes,\n     builtin_type::BuiltinType,\n     docs::Documentation,\n-    nameres::{per_ns::PerNs, raw::ImportId},\n+    per_ns::PerNs,\n     resolver::{HasResolver, TypeNs},\n     type_ref::TypeRef,\n-    ContainerId, CrateModuleId, HasModule, ImplId, LocalEnumVariantId, LocalStructFieldId, Lookup,\n-    ModuleId, UnionId,\n+    ContainerId, HasModule, ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId,\n+    LocalStructFieldId, Lookup, ModuleId, UnionId,\n };\n use hir_expand::{\n     diagnostics::DiagnosticSink,\n     name::{self, AsName},\n+    AstId,\n };\n-use ra_db::{CrateId, Edition};\n-use ra_syntax::ast;\n+use ra_db::{CrateId, Edition, FileId, FilePosition};\n+use ra_syntax::{ast, AstNode, SyntaxNode};\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n@@ -78,6 +79,64 @@ impl Crate {\n     }\n }\n \n+pub enum ModuleSource {\n+    SourceFile(ast::SourceFile),\n+    Module(ast::Module),\n+}\n+\n+impl ModuleSource {\n+    pub fn new(\n+        db: &impl DefDatabase,\n+        file_id: Option<FileId>,\n+        decl_id: Option<AstId<ast::Module>>,\n+    ) -> ModuleSource {\n+        match (file_id, decl_id) {\n+            (Some(file_id), _) => {\n+                let source_file = db.parse(file_id).tree();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+            (None, Some(item_id)) => {\n+                let module = item_id.to_node(db);\n+                assert!(module.item_list().is_some(), \"expected inline module\");\n+                ModuleSource::Module(module)\n+            }\n+            (None, None) => panic!(),\n+        }\n+    }\n+\n+    // FIXME: this methods do not belong here\n+    pub fn from_position(db: &impl DefDatabase, position: FilePosition) -> ModuleSource {\n+        let parse = db.parse(position.file_id);\n+        match &ra_syntax::algo::find_node_at_offset::<ast::Module>(\n+            parse.tree().syntax(),\n+            position.offset,\n+        ) {\n+            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n+            _ => {\n+                let source_file = parse.tree();\n+                ModuleSource::SourceFile(source_file)\n+            }\n+        }\n+    }\n+\n+    pub fn from_child_node(db: &impl DefDatabase, child: Source<&SyntaxNode>) -> ModuleSource {\n+        if let Some(m) =\n+            child.value.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n+        {\n+            ModuleSource::Module(m)\n+        } else {\n+            let file_id = child.file_id.original_file(db);\n+            let source_file = db.parse(file_id).tree();\n+            ModuleSource::SourceFile(source_file)\n+        }\n+    }\n+\n+    pub fn from_file_id(db: &impl DefDatabase, file_id: FileId) -> ModuleSource {\n+        let source_file = db.parse(file_id).tree();\n+        ModuleSource::SourceFile(source_file)\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Module {\n     pub(crate) id: ModuleId,\n@@ -109,10 +168,10 @@ impl_froms!(\n     BuiltinType\n );\n \n-pub use hir_def::{attr::Attrs, ModuleSource};\n+pub use hir_def::attr::Attrs;\n \n impl Module {\n-    pub(crate) fn new(krate: Crate, crate_module_id: CrateModuleId) -> Module {\n+    pub(crate) fn new(krate: Crate, crate_module_id: LocalModuleId) -> Module {\n         Module { id: ModuleId { krate: krate.crate_id, module_id: crate_module_id } }\n     }\n \n@@ -222,14 +281,14 @@ impl Module {\n         def_map[self.id.module_id].impls.iter().copied().map(ImplBlock::from).collect()\n     }\n \n-    fn with_module_id(self, module_id: CrateModuleId) -> Module {\n+    fn with_module_id(self, module_id: LocalModuleId) -> Module {\n         Module::new(self.krate(), module_id)\n     }\n }\n \n pub struct Import {\n     pub(crate) parent: Module,\n-    pub(crate) id: ImportId,\n+    pub(crate) id: LocalImportId,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "b7bafe23df703236fe8df41e0260d8d5cfeecaf1", "filename": "crates/ra_hir/src/code_model/src.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model%2Fsrc.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -117,7 +117,9 @@ impl HasSource for Import {\n     fn source(self, db: &impl DefDatabase) -> Source<Self::Ast> {\n         let src = self.parent.definition_source(db);\n         let (_, source_map) = db.raw_items_with_source_map(src.file_id);\n-        src.with_value(source_map.get(&src.value, self.id))\n+        let root = db.parse_or_expand(src.file_id).unwrap();\n+        let ptr = source_map.get(self.id);\n+        src.with_value(ptr.map(|it| it.to_node(&root), |it| it.to_node(&root)))\n     }\n }\n "}, {"sha": "1d195d65d08990e94893eafc231ea53f1fab7343", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 10, "deletions": 65, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -21,95 +21,40 @@ pub mod resolver;\n pub mod data;\n pub mod lang_item;\n pub mod docs;\n+pub mod per_ns;\n \n mod trace;\n+mod nameres;\n \n #[cfg(test)]\n mod test_db;\n #[cfg(test)]\n mod marks;\n \n-// FIXME: this should be private\n-pub mod nameres;\n-\n use std::hash::{Hash, Hasher};\n \n use hir_expand::{ast_id_map::FileAstId, db::AstDatabase, AstId, HirFileId, MacroDefId, Source};\n use ra_arena::{impl_arena_id, map::ArenaMap, RawId};\n-use ra_db::{salsa, CrateId, FileId};\n-use ra_syntax::{ast, AstNode, SyntaxNode};\n+use ra_db::{salsa, CrateId};\n+use ra_syntax::{ast, AstNode};\n \n use crate::{builtin_type::BuiltinType, db::InternDatabase};\n \n-pub enum ModuleSource {\n-    SourceFile(ast::SourceFile),\n-    Module(ast::Module),\n-}\n-\n-impl ModuleSource {\n-    pub fn new(\n-        db: &impl db::DefDatabase,\n-        file_id: Option<FileId>,\n-        decl_id: Option<AstId<ast::Module>>,\n-    ) -> ModuleSource {\n-        match (file_id, decl_id) {\n-            (Some(file_id), _) => {\n-                let source_file = db.parse(file_id).tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-            (None, Some(item_id)) => {\n-                let module = item_id.to_node(db);\n-                assert!(module.item_list().is_some(), \"expected inline module\");\n-                ModuleSource::Module(module)\n-            }\n-            (None, None) => panic!(),\n-        }\n-    }\n-\n-    // FIXME: this methods do not belong here\n-    pub fn from_position(db: &impl db::DefDatabase, position: ra_db::FilePosition) -> ModuleSource {\n-        let parse = db.parse(position.file_id);\n-        match &ra_syntax::algo::find_node_at_offset::<ast::Module>(\n-            parse.tree().syntax(),\n-            position.offset,\n-        ) {\n-            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n-            _ => {\n-                let source_file = parse.tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-        }\n-    }\n-\n-    pub fn from_child_node(db: &impl db::DefDatabase, child: Source<&SyntaxNode>) -> ModuleSource {\n-        if let Some(m) =\n-            child.value.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n-        {\n-            ModuleSource::Module(m)\n-        } else {\n-            let file_id = child.file_id.original_file(db);\n-            let source_file = db.parse(file_id).tree();\n-            ModuleSource::SourceFile(source_file)\n-        }\n-    }\n-\n-    pub fn from_file_id(db: &impl db::DefDatabase, file_id: FileId) -> ModuleSource {\n-        let source_file = db.parse(file_id).tree();\n-        ModuleSource::SourceFile(source_file)\n-    }\n-}\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct LocalImportId(RawId);\n+impl_arena_id!(LocalImportId);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n     pub krate: CrateId,\n-    pub module_id: CrateModuleId,\n+    pub module_id: LocalModuleId,\n }\n \n /// An ID of a module, **local** to a specific crate\n // FIXME: rename to `LocalModuleId`.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct CrateModuleId(RawId);\n-impl_arena_id!(CrateModuleId);\n+pub struct LocalModuleId(RawId);\n+impl_arena_id!(LocalModuleId);\n \n macro_rules! impl_intern_key {\n     ($name:ident) => {"}, {"sha": "3b2e996470aebbef0fe054be97102ace87a20bc8", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -47,8 +47,7 @@\n //! path and, upon success, we run macro expansion and \"collect module\" phase on\n //! the result\n \n-pub mod raw;\n-pub mod per_ns;\n+pub(crate) mod raw;\n mod collector;\n mod mod_resolution;\n mod path_resolution;\n@@ -72,11 +71,10 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use crate::{\n     builtin_type::BuiltinType,\n     db::DefDatabase,\n-    nameres::{\n-        diagnostics::DefDiagnostic, path_resolution::ResolveMode, per_ns::PerNs, raw::ImportId,\n-    },\n+    nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n     path::Path,\n-    AstId, CrateModuleId, FunctionId, ImplId, ModuleDefId, ModuleId, TraitId,\n+    per_ns::PerNs,\n+    AstId, FunctionId, ImplId, LocalImportId, LocalModuleId, ModuleDefId, ModuleId, TraitId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -89,8 +87,8 @@ pub struct CrateDefMap {\n     /// a dependency (`std` or `core`).\n     prelude: Option<ModuleId>,\n     extern_prelude: FxHashMap<Name, ModuleDefId>,\n-    root: CrateModuleId,\n-    modules: Arena<CrateModuleId, ModuleData>,\n+    root: LocalModuleId,\n+    modules: Arena<LocalModuleId, ModuleData>,\n \n     /// Some macros are not well-behavior, which leads to infinite loop\n     /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n@@ -107,17 +105,17 @@ pub struct CrateDefMap {\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n-impl std::ops::Index<CrateModuleId> for CrateDefMap {\n+impl std::ops::Index<LocalModuleId> for CrateDefMap {\n     type Output = ModuleData;\n-    fn index(&self, id: CrateModuleId) -> &ModuleData {\n+    fn index(&self, id: LocalModuleId) -> &ModuleData {\n         &self.modules[id]\n     }\n }\n \n #[derive(Default, Debug, PartialEq, Eq)]\n pub struct ModuleData {\n-    pub parent: Option<CrateModuleId>,\n-    pub children: FxHashMap<Name, CrateModuleId>,\n+    pub parent: Option<LocalModuleId>,\n+    pub children: FxHashMap<Name, LocalModuleId>,\n     pub scope: ModuleScope,\n \n     //  FIXME: these can't be both null, we need a three-state enum here.\n@@ -213,7 +211,7 @@ pub struct Resolution {\n     /// None for unresolved\n     pub def: PerNs,\n     /// ident by which this is imported into local scope.\n-    pub import: Option<ImportId>,\n+    pub import: Option<LocalImportId>,\n }\n \n impl CrateDefMap {\n@@ -227,7 +225,7 @@ impl CrateDefMap {\n         let def_map = {\n             let crate_graph = db.crate_graph();\n             let edition = crate_graph.edition(krate);\n-            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let mut modules: Arena<LocalModuleId, ModuleData> = Arena::default();\n             let root = modules.alloc(ModuleData::default());\n             CrateDefMap {\n                 krate,\n@@ -248,7 +246,7 @@ impl CrateDefMap {\n         self.krate\n     }\n \n-    pub fn root(&self) -> CrateModuleId {\n+    pub fn root(&self) -> LocalModuleId {\n         self.root\n     }\n \n@@ -263,7 +261,7 @@ impl CrateDefMap {\n     pub fn add_diagnostics(\n         &self,\n         db: &impl DefDatabase,\n-        module: CrateModuleId,\n+        module: LocalModuleId,\n         sink: &mut DiagnosticSink,\n     ) {\n         self.diagnostics.iter().for_each(|it| it.add_to(db, module, sink))\n@@ -272,18 +270,18 @@ impl CrateDefMap {\n     pub fn resolve_path(\n         &self,\n         db: &impl DefDatabase,\n-        original_module: CrateModuleId,\n+        original_module: LocalModuleId,\n         path: &Path,\n     ) -> (PerNs, Option<usize>) {\n         let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n         (res.resolved_def, res.segment_index)\n     }\n \n-    pub fn modules(&self) -> impl Iterator<Item = CrateModuleId> + '_ {\n+    pub fn modules(&self) -> impl Iterator<Item = LocalModuleId> + '_ {\n         self.modules.iter().map(|(id, _data)| id)\n     }\n \n-    pub fn modules_for_file(&self, file_id: FileId) -> impl Iterator<Item = CrateModuleId> + '_ {\n+    pub fn modules_for_file(&self, file_id: FileId) -> impl Iterator<Item = LocalModuleId> + '_ {\n         self.modules\n             .iter()\n             .filter(move |(_id, data)| data.definition == Some(file_id))\n@@ -319,12 +317,12 @@ mod diagnostics {\n     use ra_db::RelativePathBuf;\n     use ra_syntax::{ast, AstPtr};\n \n-    use crate::{db::DefDatabase, diagnostics::UnresolvedModule, nameres::CrateModuleId, AstId};\n+    use crate::{db::DefDatabase, diagnostics::UnresolvedModule, nameres::LocalModuleId, AstId};\n \n     #[derive(Debug, PartialEq, Eq)]\n     pub(super) enum DefDiagnostic {\n         UnresolvedModule {\n-            module: CrateModuleId,\n+            module: LocalModuleId,\n             declaration: AstId<ast::Module>,\n             candidate: RelativePathBuf,\n         },\n@@ -334,7 +332,7 @@ mod diagnostics {\n         pub(super) fn add_to(\n             &self,\n             db: &impl DefDatabase,\n-            target_module: CrateModuleId,\n+            target_module: LocalModuleId,\n             sink: &mut DiagnosticSink,\n         ) {\n             match self {"}, {"sha": "b02364e86f6ebff9453abd26348bfafffadb5617", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -16,11 +16,12 @@ use crate::{\n     db::DefDatabase,\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n-        per_ns::PerNs, raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n+        raw, CrateDefMap, ModuleData, Resolution, ResolveMode,\n     },\n     path::{Path, PathKind},\n-    AdtId, AstId, AstItemDef, ConstLoc, ContainerId, CrateModuleId, EnumId, EnumVariantId,\n-    FunctionLoc, ImplId, Intern, LocationCtx, ModuleDefId, ModuleId, StaticId, StructId,\n+    per_ns::PerNs,\n+    AdtId, AstId, AstItemDef, ConstLoc, ContainerId, EnumId, EnumVariantId, FunctionLoc, ImplId,\n+    Intern, LocalImportId, LocalModuleId, LocationCtx, ModuleDefId, ModuleId, StaticId, StructId,\n     StructOrUnionId, TraitId, TypeAliasLoc, UnionId,\n };\n \n@@ -94,10 +95,10 @@ impl MacroStackMonitor {\n struct DefCollector<'a, DB> {\n     db: &'a DB,\n     def_map: CrateDefMap,\n-    glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n-    unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n-    mod_dirs: FxHashMap<CrateModuleId, ModDir>,\n+    glob_imports: FxHashMap<LocalModuleId, Vec<(LocalModuleId, LocalImportId)>>,\n+    unresolved_imports: Vec<(LocalModuleId, LocalImportId, raw::ImportData)>,\n+    unexpanded_macros: Vec<(LocalModuleId, AstId<ast::MacroCall>, Path)>,\n+    mod_dirs: FxHashMap<LocalModuleId, ModDir>,\n \n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stack overflow, we add a deep counter here for prevent that.\n@@ -173,7 +174,7 @@ where\n     /// ```\n     fn define_macro(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         name: Name,\n         macro_: MacroDefId,\n         export: bool,\n@@ -200,15 +201,15 @@ where\n     /// the definition of current module.\n     /// And also, `macro_use` on a module will import all legacy macros visable inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: CrateModuleId, name: Name, macro_: MacroDefId) {\n+    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, macro_: MacroDefId) {\n         // Always shadowing\n         self.def_map.modules[module_id].scope.legacy_macros.insert(name, macro_);\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n     fn import_macros_from_extern_crate(\n         &mut self,\n-        current_module_id: CrateModuleId,\n+        current_module_id: LocalModuleId,\n         import: &raw::ImportData,\n     ) {\n         log::debug!(\n@@ -235,7 +236,7 @@ where\n     /// Exported macros are just all macros in the root module scope.\n     /// Note that it contains not only all `#[macro_export]` macros, but also all aliases\n     /// created by `use` in the root module, ignoring the visibility of `use`.\n-    fn import_all_macros_exported(&mut self, current_module_id: CrateModuleId, krate: CrateId) {\n+    fn import_all_macros_exported(&mut self, current_module_id: LocalModuleId, krate: CrateId) {\n         let def_map = self.db.crate_def_map(krate);\n         for (name, def) in def_map[def_map.root].scope.macros() {\n             // `macro_use` only bring things into legacy scope.\n@@ -265,7 +266,7 @@ where\n \n     fn resolve_import(\n         &self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         import: &raw::ImportData,\n     ) -> (PerNs, ReachedFixedPoint) {\n         log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n@@ -291,9 +292,9 @@ where\n \n     fn record_resolved_import(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         def: PerNs,\n-        import_id: raw::ImportId,\n+        import_id: LocalImportId,\n         import: &raw::ImportData,\n     ) {\n         if import.is_glob {\n@@ -387,17 +388,17 @@ where\n \n     fn update(\n         &mut self,\n-        module_id: CrateModuleId,\n-        import: Option<raw::ImportId>,\n+        module_id: LocalModuleId,\n+        import: Option<LocalImportId>,\n         resolutions: &[(Name, Resolution)],\n     ) {\n         self.update_recursive(module_id, import, resolutions, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n-        module_id: CrateModuleId,\n-        import: Option<raw::ImportId>,\n+        module_id: LocalModuleId,\n+        import: Option<LocalImportId>,\n         resolutions: &[(Name, Resolution)],\n         depth: usize,\n     ) {\n@@ -484,7 +485,7 @@ where\n \n     fn collect_macro_expansion(\n         &mut self,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n         macro_call_id: MacroCallId,\n         macro_def_id: MacroDefId,\n     ) {\n@@ -522,7 +523,7 @@ where\n /// Walks a single module, populating defs, imports and macros\n struct ModCollector<'a, D> {\n     def_collector: D,\n-    module_id: CrateModuleId,\n+    module_id: LocalModuleId,\n     file_id: HirFileId,\n     raw_items: &'a raw::RawItems,\n     mod_dir: ModDir,\n@@ -647,7 +648,7 @@ where\n         name: Name,\n         declaration: AstId<ast::Module>,\n         definition: Option<FileId>,\n-    ) -> CrateModuleId {\n+    ) -> LocalModuleId {\n         let modules = &mut self.def_collector.def_map.modules;\n         let res = modules.alloc(ModuleData::default());\n         modules[res].parent = Some(self.module_id);\n@@ -772,7 +773,7 @@ where\n         self.def_collector.unexpanded_macros.push((self.module_id, ast_id, path));\n     }\n \n-    fn import_all_legacy_macros(&mut self, module_id: CrateModuleId) {\n+    fn import_all_legacy_macros(&mut self, module_id: LocalModuleId) {\n         let macros = self.def_collector.def_map[module_id].scope.legacy_macros.clone();\n         for (name, macro_) in macros {\n             self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_);\n@@ -827,7 +828,7 @@ mod tests {\n \n         let def_map = {\n             let edition = db.crate_graph().edition(krate);\n-            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let mut modules: Arena<LocalModuleId, ModuleData> = Arena::default();\n             let root = modules.alloc(ModuleData::default());\n             CrateDefMap {\n                 krate,"}, {"sha": "9455f22bbd6fe155dd81f2210fcbe227a411e2bd", "filename": "crates/ra_hir_def/src/nameres/path_resolution.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -16,9 +16,10 @@ use test_utils::tested_by;\n \n use crate::{\n     db::DefDatabase,\n-    nameres::{per_ns::PerNs, CrateDefMap},\n+    nameres::CrateDefMap,\n     path::{Path, PathKind},\n-    AdtId, CrateModuleId, EnumVariantId, ModuleDefId, ModuleId,\n+    per_ns::PerNs,\n+    AdtId, EnumVariantId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -65,7 +66,7 @@ impl CrateDefMap {\n         &self,\n         db: &impl DefDatabase,\n         mode: ResolveMode,\n-        original_module: CrateModuleId,\n+        original_module: LocalModuleId,\n         path: &Path,\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n@@ -217,7 +218,7 @@ impl CrateDefMap {\n     fn resolve_name_in_module(\n         &self,\n         db: &impl DefDatabase,\n-        module: CrateModuleId,\n+        module: LocalModuleId,\n         name: &Name,\n     ) -> PerNs {\n         // Resolve in:"}, {"sha": "552cbe5448a9e4b35313cc7f55d04fd5219ff6cc", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "modified", "additions": 10, "deletions": 24, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -12,15 +12,15 @@ use hir_expand::{\n use ra_arena::{impl_arena_id, map::ArenaMap, Arena, RawId};\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner},\n-    AstNode, AstPtr, SourceFile,\n+    AstNode, AstPtr,\n };\n use test_utils::tested_by;\n \n use crate::{\n     attr::{Attr, Attrs},\n     db::DefDatabase,\n     path::Path,\n-    FileAstId, HirFileId, ModuleSource, Source,\n+    FileAstId, HirFileId, LocalImportId, Source,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n@@ -30,7 +30,7 @@ use crate::{\n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct RawItems {\n     modules: Arena<Module, ModuleData>,\n-    imports: Arena<ImportId, ImportData>,\n+    imports: Arena<LocalImportId, ImportData>,\n     defs: Arena<Def, DefData>,\n     macros: Arena<Macro, MacroData>,\n     impls: Arena<Impl, ImplData>,\n@@ -40,28 +40,18 @@ pub struct RawItems {\n \n #[derive(Debug, Default, PartialEq, Eq)]\n pub struct ImportSourceMap {\n-    map: ArenaMap<ImportId, ImportSourcePtr>,\n+    map: ArenaMap<LocalImportId, ImportSourcePtr>,\n }\n \n type ImportSourcePtr = Either<AstPtr<ast::UseTree>, AstPtr<ast::ExternCrateItem>>;\n-type ImportSource = Either<ast::UseTree, ast::ExternCrateItem>;\n-\n-fn to_node(ptr: ImportSourcePtr, file: &SourceFile) -> ImportSource {\n-    ptr.map(|ptr| ptr.to_node(file.syntax()), |ptr| ptr.to_node(file.syntax()))\n-}\n \n impl ImportSourceMap {\n-    fn insert(&mut self, import: ImportId, ptr: ImportSourcePtr) {\n+    fn insert(&mut self, import: LocalImportId, ptr: ImportSourcePtr) {\n         self.map.insert(import, ptr)\n     }\n \n-    pub fn get(&self, source: &ModuleSource, import: ImportId) -> ImportSource {\n-        let file = match source {\n-            ModuleSource::SourceFile(file) => file.clone(),\n-            ModuleSource::Module(m) => m.syntax().ancestors().find_map(SourceFile::cast).unwrap(),\n-        };\n-\n-        to_node(self.map[import], &file)\n+    pub fn get(&self, import: LocalImportId) -> ImportSourcePtr {\n+        self.map[import].clone()\n     }\n }\n \n@@ -106,9 +96,9 @@ impl Index<Module> for RawItems {\n     }\n }\n \n-impl Index<ImportId> for RawItems {\n+impl Index<LocalImportId> for RawItems {\n     type Output = ImportData;\n-    fn index(&self, idx: ImportId) -> &ImportData {\n+    fn index(&self, idx: LocalImportId) -> &ImportData {\n         &self.imports[idx]\n     }\n }\n@@ -143,7 +133,7 @@ pub(super) struct RawItem {\n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub(super) enum RawItemKind {\n     Module(Module),\n-    Import(ImportId),\n+    Import(LocalImportId),\n     Def(Def),\n     Macro(Macro),\n     Impl(Impl),\n@@ -159,10 +149,6 @@ pub(super) enum ModuleData {\n     Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ImportId(RawId);\n-impl_arena_id!(ImportId);\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct ImportData {\n     pub(super) path: Path,"}, {"sha": "f0b86af7c17c45494f382aa400e21ef35c02c377", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -10,7 +10,7 @@ use insta::assert_snapshot;\n use ra_db::{fixture::WithFixture, SourceDatabase};\n use test_utils::covers;\n \n-use crate::{db::DefDatabase, nameres::*, test_db::TestDB, CrateModuleId};\n+use crate::{db::DefDatabase, nameres::*, test_db::TestDB, LocalModuleId};\n \n fn def_map(fixtute: &str) -> String {\n     let dm = compute_crate_def_map(fixtute);\n@@ -28,7 +28,7 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n     go(&mut buf, map, \"\\ncrate\", map.root());\n     return buf.trim().to_string();\n \n-    fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: CrateModuleId) {\n+    fn go(buf: &mut String, map: &CrateDefMap, path: &str, module: LocalModuleId) {\n         *buf += path;\n         *buf += \"\\n\";\n "}, {"sha": "e11530062d2bd8904492510c16a1b23fbf0796c9", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -665,7 +665,7 @@ fn unresolved_module_diagnostics() {\n         @r###\"\n     [\n         UnresolvedModule {\n-            module: CrateModuleId(\n+            module: LocalModuleId(\n                 0,\n             ),\n             declaration: AstId {"}, {"sha": "717ed1ef905a4ebfef8d034c17a29f5ffe2c7f70", "filename": "crates/ra_hir_def/src/per_ns.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fper_ns.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "previous_filename": "crates/ra_hir_def/src/nameres/per_ns.rs"}, {"sha": "b56de44dd7a22600e3a03e1e82dac9425e466186", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aded342266f18b519666ac512e77b0c211fff5d/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=1aded342266f18b519666ac512e77b0c211fff5d", "patch": "@@ -14,11 +14,12 @@ use crate::{\n     db::DefDatabase,\n     expr::{ExprId, PatId},\n     generics::GenericParams,\n-    nameres::{per_ns::PerNs, CrateDefMap},\n+    nameres::CrateDefMap,\n     path::{Path, PathKind},\n-    AdtId, AstItemDef, ConstId, ContainerId, CrateModuleId, DefWithBodyId, EnumId, EnumVariantId,\n-    FunctionId, GenericDefId, ImplId, Lookup, ModuleDefId, ModuleId, StaticId, StructId, TraitId,\n-    TypeAliasId,\n+    per_ns::PerNs,\n+    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n+    GenericDefId, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId, StructId,\n+    TraitId, TypeAliasId,\n };\n \n #[derive(Debug, Clone, Default)]\n@@ -30,7 +31,7 @@ pub struct Resolver {\n #[derive(Debug, Clone)]\n pub(crate) struct ModuleItemMap {\n     crate_def_map: Arc<CrateDefMap>,\n-    module_id: CrateModuleId,\n+    module_id: LocalModuleId,\n }\n \n #[derive(Debug, Clone)]\n@@ -330,7 +331,7 @@ impl Resolver {\n         traits\n     }\n \n-    fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {\n+    fn module(&self) -> Option<(&CrateDefMap, LocalModuleId)> {\n         self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ModuleScope(m) => Some((&*m.crate_def_map, m.module_id)),\n \n@@ -466,7 +467,7 @@ impl Resolver {\n     fn push_module_scope(\n         self,\n         crate_def_map: Arc<CrateDefMap>,\n-        module_id: CrateModuleId,\n+        module_id: LocalModuleId,\n     ) -> Resolver {\n         self.push_scope(Scope::ModuleScope(ModuleItemMap { crate_def_map, module_id }))\n     }"}]}