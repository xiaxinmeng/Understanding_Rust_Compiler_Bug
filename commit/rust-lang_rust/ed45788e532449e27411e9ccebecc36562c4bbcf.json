{"sha": "ed45788e532449e27411e9ccebecc36562c4bbcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNDU3ODhlNTMyNDQ5ZTI3NDExZTljY2ViZWNjMzY1NjJjNGJiY2Y=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-06T20:52:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-06T20:52:45Z"}, "message": "Rollup merge of #59738 - flip1995:match_path_move, r=eddyb,Manishearth\n\nMove match_path from DefId to lint::LateContext\n\ncc https://github.com/rust-lang/rust/pull/59316#discussion_r272351353\n\nr? @eddyb", "tree": {"sha": "e22307c291f0654aaaeb619005eed9312d06efbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e22307c291f0654aaaeb619005eed9312d06efbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed45788e532449e27411e9ccebecc36562c4bbcf", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcqRGdCRBK7hj4Ov3rIwAAdHIIAEt3ILGsHBzG0sKH5y/Zy8h3\nBovm3SV81LHPX5djbVJwgK80qYaUDK6Hd1SPWaOQXIS+rSrpgI+uU+cFjcK73t4y\nl9LwA2IiZHaim2Jgujwgjc03NJ5OHYCdiXj++x6tiM53JIIe793der71C25bx6Ef\n1IgzmB19gGTbjCN6lNhr7NA7RSzgz02ccT5a6uY60mHcWxb1cizrNOyxuup+2d7N\nFVIssjDS+SN0R6JsvoznaS+i0mw04OhWhgMZRenOJadEjODKvArJP+jnQy9/zkam\n5AtQfG3huR7ja73BVLf2asauzBClWR3BkOZe1pP9XN6hplPiCgHIEhEIC+cQ+0o=\n=/e9S\n-----END PGP SIGNATURE-----\n", "payload": "tree e22307c291f0654aaaeb619005eed9312d06efbf\nparent 8159f389f6cc8ec3e3ea009222d6926da77371ec\nparent 278ab1905ce5352db4ccee6e02b85fafc39beeea\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1554583965 +0200\ncommitter GitHub <noreply@github.com> 1554583965 +0200\n\nRollup merge of #59738 - flip1995:match_path_move, r=eddyb,Manishearth\n\nMove match_path from DefId to lint::LateContext\n\ncc https://github.com/rust-lang/rust/pull/59316#discussion_r272351353\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed45788e532449e27411e9ccebecc36562c4bbcf", "html_url": "https://github.com/rust-lang/rust/commit/ed45788e532449e27411e9ccebecc36562c4bbcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed45788e532449e27411e9ccebecc36562c4bbcf/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8159f389f6cc8ec3e3ea009222d6926da77371ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/8159f389f6cc8ec3e3ea009222d6926da77371ec", "html_url": "https://github.com/rust-lang/rust/commit/8159f389f6cc8ec3e3ea009222d6926da77371ec"}, {"sha": "278ab1905ce5352db4ccee6e02b85fafc39beeea", "url": "https://api.github.com/repos/rust-lang/rust/commits/278ab1905ce5352db4ccee6e02b85fafc39beeea", "html_url": "https://github.com/rust-lang/rust/commit/278ab1905ce5352db4ccee6e02b85fafc39beeea"}], "stats": {"total": 221, "additions": 114, "deletions": 107}, "files": [{"sha": "8536f38e48c6d5e0b3483ff9aa65aee8a98b3518", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 2, "deletions": 104, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ed45788e532449e27411e9ccebecc36562c4bbcf/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45788e532449e27411e9ccebecc36562c4bbcf/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=ed45788e532449e27411e9ccebecc36562c4bbcf", "patch": "@@ -1,10 +1,9 @@\n-use crate::ty::{self, print::Printer, subst::Kind, Ty, TyCtxt};\n-use crate::hir::map::definitions::{DisambiguatedDefPathData, FIRST_FREE_HIGH_DEF_INDEX};\n+use crate::ty::{self, TyCtxt};\n+use crate::hir::map::definitions::FIRST_FREE_HIGH_DEF_INDEX;\n use rustc_data_structures::indexed_vec::Idx;\n use serialize;\n use std::fmt;\n use std::u32;\n-use syntax::symbol::{LocalInternedString, Symbol};\n \n newtype_index! {\n     pub struct CrateId {\n@@ -252,107 +251,6 @@ impl DefId {\n             format!(\"module `{}`\", tcx.def_path_str(*self))\n         }\n     }\n-\n-    /// Check if a `DefId`'s path matches the given absolute type path usage.\n-    // Uplifted from rust-lang/rust-clippy\n-    pub fn match_path<'a, 'tcx>(self, tcx: TyCtxt<'a, 'tcx, 'tcx>, path: &[&str]) -> bool {\n-        pub struct AbsolutePathPrinter<'a, 'tcx> {\n-            pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        }\n-\n-        impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n-            type Error = !;\n-\n-            type Path = Vec<LocalInternedString>;\n-            type Region = ();\n-            type Type = ();\n-            type DynExistential = ();\n-\n-            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-                self.tcx\n-            }\n-\n-            fn print_region(self, _region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n-                Ok(())\n-            }\n-\n-            fn print_type(self, _ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n-                Ok(())\n-            }\n-\n-            fn print_dyn_existential(\n-                self,\n-                _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n-                ) -> Result<Self::DynExistential, Self::Error> {\n-                Ok(())\n-            }\n-\n-            fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n-                Ok(vec![self.tcx.original_crate_name(cnum).as_str()])\n-            }\n-\n-            fn path_qualified(\n-                self,\n-                self_ty: Ty<'tcx>,\n-                trait_ref: Option<ty::TraitRef<'tcx>>,\n-                ) -> Result<Self::Path, Self::Error> {\n-                if trait_ref.is_none() {\n-                    if let ty::Adt(def, substs) = self_ty.sty {\n-                        return self.print_def_path(def.did, substs);\n-                    }\n-                }\n-\n-                // This shouldn't ever be needed, but just in case:\n-                Ok(vec![match trait_ref {\n-                    Some(trait_ref) => Symbol::intern(&format!(\"{:?}\", trait_ref)).as_str(),\n-                    None => Symbol::intern(&format!(\"<{}>\", self_ty)).as_str(),\n-                }])\n-            }\n-\n-            fn path_append_impl(\n-                self,\n-                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-                _disambiguated_data: &DisambiguatedDefPathData,\n-                self_ty: Ty<'tcx>,\n-                trait_ref: Option<ty::TraitRef<'tcx>>,\n-                ) -> Result<Self::Path, Self::Error> {\n-                let mut path = print_prefix(self)?;\n-\n-                // This shouldn't ever be needed, but just in case:\n-                path.push(match trait_ref {\n-                    Some(trait_ref) => {\n-                        Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref, self_ty)).as_str()\n-                    },\n-                    None => Symbol::intern(&format!(\"<impl {}>\", self_ty)).as_str(),\n-                });\n-\n-                Ok(path)\n-            }\n-\n-            fn path_append(\n-                self,\n-                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-                disambiguated_data: &DisambiguatedDefPathData,\n-                ) -> Result<Self::Path, Self::Error> {\n-                let mut path = print_prefix(self)?;\n-                path.push(disambiguated_data.data.as_interned_str().as_str());\n-                Ok(path)\n-            }\n-\n-            fn path_generic_args(\n-                self,\n-                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n-                _args: &[Kind<'tcx>],\n-                ) -> Result<Self::Path, Self::Error> {\n-                print_prefix(self)\n-            }\n-        }\n-\n-        let names = AbsolutePathPrinter { tcx }.print_def_path(self, &[]).unwrap();\n-\n-        names.len() == path.len()\n-            && names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n-    }\n }\n \n impl serialize::UseSpecializedEncodable for DefId {}"}, {"sha": "15ea6403e38bab7f7b85c4848a4f69e629fc5966", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 111, "deletions": 2, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/ed45788e532449e27411e9ccebecc36562c4bbcf/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45788e532449e27411e9ccebecc36562c4bbcf/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ed45788e532449e27411e9ccebecc36562c4bbcf", "patch": "@@ -25,7 +25,7 @@ use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n use crate::middle::privacy::AccessLevels;\n use crate::rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use crate::session::{config, early_error, Session};\n-use crate::ty::{self, TyCtxt, Ty};\n+use crate::ty::{self, print::Printer, subst::Kind, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n@@ -36,9 +36,10 @@ use syntax::edition;\n use syntax_pos::{MultiSpan, Span, symbol::{LocalInternedString, Symbol}};\n use errors::DiagnosticBuilder;\n use crate::hir;\n-use crate::hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use crate::hir::intravisit as hir_visit;\n use crate::hir::intravisit::Visitor;\n+use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n \n@@ -752,6 +753,114 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     pub fn current_lint_root(&self) -> hir::HirId {\n         self.last_node_with_lint_attrs\n     }\n+\n+    /// Check if a `DefId`'s path matches the given absolute type path usage.\n+    // Uplifted from rust-lang/rust-clippy\n+    pub fn match_path(&self, def_id: DefId, path: &[&str]) -> bool {\n+        pub struct AbsolutePathPrinter<'a, 'tcx> {\n+            pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        }\n+\n+        impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+            type Error = !;\n+\n+            type Path = Vec<LocalInternedString>;\n+            type Region = ();\n+            type Type = ();\n+            type DynExistential = ();\n+\n+            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+                self.tcx\n+            }\n+\n+            fn print_region(self, _region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn print_type(self, _ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn print_dyn_existential(\n+                self,\n+                _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+                ) -> Result<Self::DynExistential, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n+                Ok(vec![self.tcx.original_crate_name(cnum).as_str()])\n+            }\n+\n+            fn path_qualified(\n+                self,\n+                self_ty: Ty<'tcx>,\n+                trait_ref: Option<ty::TraitRef<'tcx>>,\n+                ) -> Result<Self::Path, Self::Error> {\n+                if trait_ref.is_none() {\n+                    if let ty::Adt(def, substs) = self_ty.sty {\n+                        return self.print_def_path(def.did, substs);\n+                    }\n+                }\n+\n+                // This shouldn't ever be needed, but just in case:\n+                Ok(vec![match trait_ref {\n+                    Some(trait_ref) => Symbol::intern(&format!(\"{:?}\", trait_ref)).as_str(),\n+                    None => Symbol::intern(&format!(\"<{}>\", self_ty)).as_str(),\n+                }])\n+            }\n+\n+            fn path_append_impl(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _disambiguated_data: &DisambiguatedDefPathData,\n+                self_ty: Ty<'tcx>,\n+                trait_ref: Option<ty::TraitRef<'tcx>>,\n+                ) -> Result<Self::Path, Self::Error> {\n+                let mut path = print_prefix(self)?;\n+\n+                // This shouldn't ever be needed, but just in case:\n+                path.push(match trait_ref {\n+                    Some(trait_ref) => {\n+                        Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref, self_ty)).as_str()\n+                    },\n+                    None => Symbol::intern(&format!(\"<impl {}>\", self_ty)).as_str(),\n+                });\n+\n+                Ok(path)\n+            }\n+\n+            fn path_append(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                disambiguated_data: &DisambiguatedDefPathData,\n+                ) -> Result<Self::Path, Self::Error> {\n+                let mut path = print_prefix(self)?;\n+\n+                // Skip `::{{constructor}}` on tuple/unit structs.\n+                match disambiguated_data.data {\n+                    DefPathData::Ctor => return Ok(path),\n+                    _ => {}\n+                }\n+\n+                path.push(disambiguated_data.data.as_interned_str().as_str());\n+                Ok(path)\n+            }\n+\n+            fn path_generic_args(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _args: &[Kind<'tcx>],\n+                ) -> Result<Self::Path, Self::Error> {\n+                print_prefix(self)\n+            }\n+        }\n+\n+        let names = AbsolutePathPrinter { tcx: self.tcx }.print_def_path(def_id, &[]).unwrap();\n+\n+        names.len() == path.len()\n+            && names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n+    }\n }\n \n impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {"}, {"sha": "0bafa93011ec4d1be96dc8d9250d38cebd7b0d0a", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed45788e532449e27411e9ccebecc36562c4bbcf/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed45788e532449e27411e9ccebecc36562c4bbcf/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=ed45788e532449e27411e9ccebecc36562c4bbcf", "patch": "@@ -100,7 +100,7 @@ fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n     if segment.ident.as_str() == \"TyKind\" {\n         if let Some(def) = segment.def {\n             if let Some(did) = def.opt_def_id() {\n-                return did.match_path(cx.tcx, &[\"rustc\", \"ty\", \"sty\", \"TyKind\"]);\n+                return cx.match_path(did, &[\"rustc\", \"ty\", \"sty\", \"TyKind\"]);\n             }\n         }\n     }"}]}