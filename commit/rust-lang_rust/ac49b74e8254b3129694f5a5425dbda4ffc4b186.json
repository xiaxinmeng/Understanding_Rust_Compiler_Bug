{"sha": "ac49b74e8254b3129694f5a5425dbda4ffc4b186", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNDliNzRlODI1NGIzMTI5Njk0ZjVhNTQyNWRiZGE0ZmZjNGIxODY=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-20T00:23:55Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-20T00:23:55Z"}, "message": "socket based UDP io", "tree": {"sha": "f54b743dfb552d0516fc54cd7b7f34c0d5741d60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f54b743dfb552d0516fc54cd7b7f34c0d5741d60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac49b74e8254b3129694f5a5425dbda4ffc4b186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac49b74e8254b3129694f5a5425dbda4ffc4b186", "html_url": "https://github.com/rust-lang/rust/commit/ac49b74e8254b3129694f5a5425dbda4ffc4b186", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac49b74e8254b3129694f5a5425dbda4ffc4b186/comments", "author": null, "committer": null, "parents": [{"sha": "083c692565340791b06ab67d66c4c95d63b222cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/083c692565340791b06ab67d66c4c95d63b222cb", "html_url": "https://github.com/rust-lang/rust/commit/083c692565340791b06ab67d66c4c95d63b222cb"}], "stats": {"total": 227, "additions": 157, "deletions": 70}, "files": [{"sha": "ac5a118f22a59d8d6048fae631769e6f6ac1faf9", "filename": "src/libstd/rt/io/net/udp.rs", "status": "modified", "additions": 77, "deletions": 24, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ac49b74e8254b3129694f5a5425dbda4ffc4b186/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac49b74e8254b3129694f5a5425dbda4ffc4b186/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fudp.rs?ref=ac49b74e8254b3129694f5a5425dbda4ffc4b186", "patch": "@@ -8,47 +8,100 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::{Option};\n+use option::{Option, Some, None};\n+use result::{Ok, Err};\n use rt::io::net::ip::IpAddr;\n-use rt::io::{Reader, Writer, Listener};\n-use rt::rtio::{RtioUdpStreamObject};\n+use rt::io::{Reader, Writer};\n+use rt::io::{io_error, read_error, EndOfFile};\n+use rt::rtio::{RtioUdpSocketObject, RtioUdpSocket, IoFactory, IoFactoryObject};\n+use rt::local::Local;\n+\n+pub struct UdpSocket {\n+    rtsocket: ~RtioUdpSocketObject\n+}\n+\n+impl UdpSocket {\n+    fn new(s: ~RtioUdpSocketObject) -> UdpSocket {\n+        UdpSocket { rtsocket: s }\n+    }\n+\n+    pub fn bind(addr: IpAddr) -> Option<UdpSocket> {\n+        let socket = unsafe {\n+            let io = Local::unsafe_borrow::<IoFactoryObject>();\n+            (*io).udp_bind(addr)\n+        };\n+        match socket {\n+            Ok(s) => { Some(UdpSocket { rtsocket: s }) }\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+                return None;\n+            }\n+        }\n+    }\n+\n+    pub fn recvfrom(&self, buf: &mut [u8]) -> Option<(uint, IpAddr)> {\n+        match (*self.rtsocket).recvfrom(buf) {\n+            Ok((nread, src)) => Some((nread, src)),\n+            Err(ioerr) => {\n+                // EOF is indicated by returning None\n+                // XXX do we ever find EOF reading UDP packets?\n+                if ioerr.kind != EndOfFile {\n+                    read_error::cond.raise(ioerr);\n+                }\n+                None\n+            }\n+        }\n+    }\n+\n+    pub fn sendto(&self, buf: &[u8], dst: IpAddr) {\n+        match (*self.rtsocket).sendto(buf, dst) {\n+            Ok(_) => (),\n+            Err(ioerr) => {\n+                io_error::cond.raise(ioerr);\n+            }\n+        }\n+    }\n+\n+    // XXX convert ~self to self eventually\n+    pub fn connect(~self, other: IpAddr) -> UdpStream {\n+        UdpStream { socket: self, connectedTo: other }\n+    }\n+}\n \n pub struct UdpStream {\n-    rtstream: ~RtioUdpStreamObject\n+    socket: ~UdpSocket,\n+    connectedTo: IpAddr\n }\n \n impl UdpStream {\n-    fn new(s: ~RtioUdpStreamObject) -> UdpStream {\n-        UdpStream {\n-            rtstream: s\n-        }\n+    pub fn as_socket<T>(&self, f: &fn(&UdpSocket) -> T) -> T {\n+        f(self.socket)\n     }\n \n-    pub fn connect(_addr: IpAddr) -> Option<UdpStream> {\n-        fail!()\n+    pub fn disconnect(self) -> ~UdpSocket {\n+        let UdpStream { socket: s, _ } = self;\n+        s\n     }\n }\n \n impl Reader for UdpStream {\n-    fn read(&mut self, _buf: &mut [u8]) -> Option<uint> { fail!() }\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> { \n+        let conn = self.connectedTo;\n+        do self.as_socket |sock| {\n+            sock.recvfrom(buf)\n+                .map_consume(|(nread,src)| if src == conn {nread} else {0})\n+        }\n+    }\n \n     fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for UdpStream {\n-    fn write(&mut self, _buf: &[u8]) { fail!() }\n-\n-    fn flush(&mut self) { fail!() }\n-}\n-\n-pub struct UdpListener;\n-\n-impl UdpListener {\n-    pub fn bind(_addr: IpAddr) -> Option<UdpListener> {\n-        fail!()\n+    fn write(&mut self, buf: &[u8]) {\n+        do self.as_socket |sock| {\n+            sock.sendto(buf, self.connectedTo);\n+        }\n     }\n-}\n \n-impl Listener<UdpStream> for UdpListener {\n-    fn accept(&mut self) -> Option<UdpStream> { fail!() }\n+    fn flush(&mut self) { fail!() }\n }"}, {"sha": "e38c952f744f08a0258fc4085e6610bf8d109ab6", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac49b74e8254b3129694f5a5425dbda4ffc4b186/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac49b74e8254b3129694f5a5425dbda4ffc4b186/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=ac49b74e8254b3129694f5a5425dbda4ffc4b186", "patch": "@@ -22,7 +22,7 @@ pub type RemoteCallbackObject = uvio::UvRemoteCallback;\n pub type IoFactoryObject = uvio::UvIoFactory;\n pub type RtioTcpStreamObject = uvio::UvTcpStream;\n pub type RtioTcpListenerObject = uvio::UvTcpListener;\n-pub type RtioUdpStreamObject = uvio::UvUdpStream;\n+pub type RtioUdpSocketObject = uvio::UvUdpSocket;\n \n pub trait EventLoop {\n     fn run(&mut self);\n@@ -45,19 +45,19 @@ pub trait RemoteCallback {\n pub trait IoFactory {\n     fn tcp_connect(&mut self, addr: IpAddr) -> Result<~RtioTcpStreamObject, IoError>;\n     fn tcp_bind(&mut self, addr: IpAddr) -> Result<~RtioTcpListenerObject, IoError>;\n-    // TODO fn udp_connect(&mut self, addr: IpAddr) -> Result<~RtioUdpStreamObject, IoError>;\n+    fn udp_bind(&mut self, addr: IpAddr) -> Result<~RtioUdpSocketObject, IoError>;\n }\n \n pub trait RtioTcpListener {\n     fn accept(&mut self) -> Result<~RtioTcpStreamObject, IoError>;\n }\n \n pub trait RtioTcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+    fn read(&self, buf: &mut [u8]) -> Result<uint, IoError>;\n+    fn write(&self, buf: &[u8]) -> Result<(), IoError>;\n }\n \n-pub trait RtioUdpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError>;\n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError>;\n+pub trait RtioUdpSocket {\n+    fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError>;\n+    fn sendto(&self, buf: &[u8], dst: IpAddr) -> Result<(), IoError>;\n }"}, {"sha": "828078f48654e8bbdfdcfe64bce37bd087394f0f", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 73, "deletions": 39, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ac49b74e8254b3129694f5a5425dbda4ffc4b186/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac49b74e8254b3129694f5a5425dbda4ffc4b186/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=ac49b74e8254b3129694f5a5425dbda4ffc4b186", "patch": "@@ -25,6 +25,7 @@ use rt::io::{standard_error, OtherIoError};\n use rt::tube::Tube;\n use rt::local::Local;\n use unstable::sync::{Exclusive, exclusive};\n+use rt::uv::net::uv_ip4_to_ip4;\n \n #[cfg(test)] use container::Container;\n #[cfg(test)] use uint;\n@@ -260,6 +261,24 @@ impl IoFactory for UvIoFactory {\n             }\n         }\n     }\n+\n+    fn udp_bind(&mut self, addr: IpAddr) -> Result<~RtioUdpSocketObject, IoError> {\n+        let mut watcher = UdpWatcher::new(self.uv_loop());\n+        match watcher.bind(addr) {\n+            Ok(_) => Ok(~UvUdpSocket { watcher: watcher }),\n+            Err(uverr) => {\n+                let scheduler = Local::take::<Scheduler>();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    let task_cell = Cell::new(task);\n+                    do watcher.close {\n+                        let scheduler = Local::take::<Scheduler>();\n+                        scheduler.resume_task_immediately(task_cell.take());\n+                    }\n+                }\n+                Err(uv_error_to_io_error(uverr))\n+            }\n+        }\n+    }\n }\n \n // FIXME #6090: Prefer newtype structs but Drop doesn't work\n@@ -358,7 +377,7 @@ impl Drop for UvTcpStream {\n }\n \n impl RtioTcpStream for UvTcpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n+    fn read(&self, buf: &mut [u8]) -> Result<uint, IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n \n@@ -403,7 +422,7 @@ impl RtioTcpStream for UvTcpStream {\n         return result_cell.take();\n     }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n+    fn write(&self, buf: &[u8]) -> Result<(), IoError> {\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let scheduler = Local::take::<Scheduler>();\n@@ -433,23 +452,21 @@ impl RtioTcpStream for UvTcpStream {\n     }\n }\n \n-pub struct UvUdpStream {\n-    watcher: UdpWatcher,\n-    address: IpAddr\n+pub struct UvUdpSocket {\n+    watcher: UdpWatcher\n }\n \n-impl UvUdpStream {\n+impl UvUdpSocket {\n     fn watcher(&self) -> UdpWatcher { self.watcher }\n-    fn address(&self) -> IpAddr { self.address }\n }\n \n-impl Drop for UvUdpStream {\n+impl Drop for UvUdpSocket {\n     fn finalize(&self) {\n-        rtdebug!(\"closing udp stream\");\n+        rtdebug!(\"closing udp socket\");\n         let watcher = self.watcher();\n         let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n-            let task_cell = Cell(task);\n+            let task_cell = Cell::new(task);\n             do watcher.close {\n                 let scheduler = Local::take::<Scheduler>();\n                 scheduler.resume_task_immediately(task_cell.take());\n@@ -458,40 +475,31 @@ impl Drop for UvUdpStream {\n     }\n }\n \n-impl RtioUdpStream for UvUdpStream {\n-    fn read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n-        let result_cell = empty_cell();\n-        let result_cell_ptr: *Cell<Result<uint, IoError>> = &result_cell;\n+impl RtioUdpSocket for UvUdpSocket {\n+    fn recvfrom(&self, buf: &mut [u8]) -> Result<(uint, IpAddr), IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(uint, IpAddr), IoError>> = &result_cell;\n \n         let scheduler = Local::take::<Scheduler>();\n         assert!(scheduler.in_task_context());\n         let watcher = self.watcher();\n-        let connection_address = self.address();\n         let buf_ptr: *&mut [u8] = &buf;\n         do scheduler.deschedule_running_task_and_then |sched, task| {\n-            rtdebug!(\"read: entered scheduler context\");\n+            rtdebug!(\"recvfrom: entered scheduler context\");\n             assert!(!sched.in_task_context());\n             let mut watcher = watcher;\n-            let task_cell = Cell(task);\n-            // XXX: see note in RtioTcpStream implementation for UvTcpStream\n-            let alloc: AllocCallback = |_| unsafe {\n-                slice_to_uv_buf(*buf_ptr)\n-            };\n-            do watcher.recv_start(alloc) |watcher, nread, _buf, addr, flags, status| {\n-                let _ = flags; // TODO actually use flags\n+            let task_cell = Cell::new(task);\n+            let alloc: AllocCallback = |_| unsafe { slice_to_uv_buf(*buf_ptr) };\n+            do watcher.recv_start(alloc) |watcher, nread, buf, addr, flags, status| {\n+                let _ = flags; // TODO \n+                let _ = buf; // TODO \n \n-                // XXX: see note in RtioTcpStream implementation for UvTcpStream\n                 let mut watcher = watcher;\n                 watcher.recv_stop();\n \n-                let incoming_address = net::uv_ip4_to_ip4(&addr);\n                 let result = if status.is_none() {\n                     assert!(nread >= 0);\n-                    if incoming_address != connection_address {\n-                        Ok(0u)\n-                    } else {\n-                        Ok(nread as uint)\n-                    }\n+                    Ok((nread as uint, uv_ip4_to_ip4(&addr)))\n                 } else {\n                     Err(uv_error_to_io_error(status.unwrap()))\n                 };\n@@ -505,11 +513,37 @@ impl RtioUdpStream for UvUdpStream {\n \n         assert!(!result_cell.is_empty());\n         return result_cell.take();\n+\n     }\n+    fn sendto(&self, buf: &[u8], dst: IpAddr) -> Result<(), IoError> {\n+        let result_cell = Cell::new_empty();\n+        let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n+        let scheduler = Local::take::<Scheduler>();\n+        assert!(scheduler.in_task_context());\n+        let watcher = self.watcher();\n+        let buf_ptr: *&[u8] = &buf;\n+        do scheduler.deschedule_running_task_and_then |_, task| {\n+            let mut watcher = watcher;\n+            let task_cell = Cell::new(task);\n+            let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n+            do watcher.send(buf, dst) |watcher, status| {\n+                let _ = watcher; // TODO \n+\n+                let result = if status.is_none() {\n+                    Ok(())\n+                } else {\n+                    Err(uv_error_to_io_error(status.unwrap()))\n+                };\n+\n+                unsafe { (*result_cell_ptr).put_back(result); }\n+\n+                let scheduler = Local::take::<Scheduler>();\n+                scheduler.resume_task_immediately(task_cell.take());\n+            }\n+        }\n \n-    fn write(&mut self, buf: &[u8]) -> Result<(), IoError> { \n-        let _ = buf;\n-        fail!() \n+        assert!(!result_cell.is_empty());\n+        return result_cell.take();\n     }\n }\n \n@@ -535,7 +569,7 @@ fn test_simple_tcp_server_and_client() {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let mut stream = listener.accept().unwrap();\n+                let stream = listener.accept().unwrap();\n                 let mut buf = [0, .. 2048];\n                 let nread = stream.read(buf).unwrap();\n                 assert_eq!(nread, 8);\n@@ -549,7 +583,7 @@ fn test_simple_tcp_server_and_client() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             }\n         }\n@@ -564,7 +598,7 @@ fn test_read_and_block() {\n         do spawntask_immediately {\n             let io = unsafe { Local::unsafe_borrow::<IoFactoryObject>() };\n             let mut listener = unsafe { (*io).tcp_bind(addr).unwrap() };\n-            let mut stream = listener.accept().unwrap();\n+            let stream = listener.accept().unwrap();\n             let mut buf = [0, .. 2048];\n \n             let expected = 32;\n@@ -597,7 +631,7 @@ fn test_read_and_block() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let stream = (*io).tcp_connect(addr).unwrap();\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n                 stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -618,7 +652,7 @@ fn test_read_read_read() {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n                 let mut listener = (*io).tcp_bind(addr).unwrap();\n-                let mut stream = listener.accept().unwrap();\n+                let stream = listener.accept().unwrap();\n                 let buf = [1, .. 2048];\n                 let mut total_bytes_written = 0;\n                 while total_bytes_written < MAX {\n@@ -631,7 +665,7 @@ fn test_read_read_read() {\n         do spawntask_immediately {\n             unsafe {\n                 let io = Local::unsafe_borrow::<IoFactoryObject>();\n-                let mut stream = (*io).tcp_connect(addr).unwrap();\n+                let stream = (*io).tcp_connect(addr).unwrap();\n                 let mut buf = [0, .. 2048];\n                 let mut total_bytes_read = 0;\n                 while total_bytes_read < MAX {"}]}