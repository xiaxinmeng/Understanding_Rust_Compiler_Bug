{"sha": "0a19c6d30c3673361489b248a187dc2571873f8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMTljNmQzMGMzNjczMzYxNDg5YjI0OGExODdkYzI1NzE4NzNmOGE=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-08-21T10:59:05Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-08-21T10:59:05Z"}, "message": "Merge pull request #186 from marcusklaas/closures\n\nFormat closures", "tree": {"sha": "e97e9bc952b9dd08a29488824f1daed1225f71fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e97e9bc952b9dd08a29488824f1daed1225f71fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a19c6d30c3673361489b248a187dc2571873f8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a19c6d30c3673361489b248a187dc2571873f8a", "html_url": "https://github.com/rust-lang/rust/commit/0a19c6d30c3673361489b248a187dc2571873f8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a19c6d30c3673361489b248a187dc2571873f8a/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "url": "https://api.github.com/repos/rust-lang/rust/commits/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16", "html_url": "https://github.com/rust-lang/rust/commit/95b6aa0dc8ee4ad5936bb185f5e6179a0c70bd16"}, {"sha": "e0ae162ae12a5efa93739895e41a62893807a2ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ae162ae12a5efa93739895e41a62893807a2ea", "html_url": "https://github.com/rust-lang/rust/commit/e0ae162ae12a5efa93739895e41a62893807a2ea"}], "stats": {"total": 395, "additions": 286, "deletions": 109}, "files": [{"sha": "341f1d45afd0d8aab92eea025cea99f1bbf5cb6e", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -78,4 +78,5 @@ create_config! {\n     report_fixme: ReportTactic,\n     reorder_imports: bool, // Alphabetically, case sensitive.\n     expr_indent_style: BlockIndentStyle,\n+    closure_indent_style: BlockIndentStyle,\n }"}, {"sha": "5792079a407e8e19a9780860a38821ce0cfc9129", "filename": "src/default.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fdefault.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fdefault.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdefault.toml?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -14,3 +14,4 @@ report_todo = \"Always\"\n report_fixme = \"Never\"\n reorder_imports = false\n expr_indent_style = \"Tabbed\"\n+closure_indent_style = \"Visual\""}, {"sha": "b8f94230c2340fad0d5365ea527cc48536718f38", "filename": "src/expr.rs", "status": "modified", "additions": 103, "deletions": 35, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -17,6 +17,7 @@ use visitor::FmtVisitor;\n use config::BlockIndentStyle;\n use comment::{FindUncommented, rewrite_comment};\n use types::rewrite_path;\n+use items::{span_lo_for_arg, span_hi_for_arg, rewrite_fn_input};\n \n use syntax::{ast, ptr};\n use syntax::codemap::{Pos, Span, BytePos, mk_sp};\n@@ -115,11 +116,86 @@ impl Rewrite for ast::Expr {\n                 };\n                 Some(format!(\"continue{}\", id_str))\n             }\n+            ast::Expr_::ExprClosure(capture, ref fn_decl, ref body) => {\n+                rewrite_closure(capture, fn_decl, body, self.span, context, width, offset)\n+            }\n             _ => context.codemap.span_to_snippet(self.span).ok(),\n         }\n     }\n }\n \n+// This functions is pretty messy because of the wrapping and unwrapping of\n+// expressions into and from blocks. See rust issue #27872.\n+fn rewrite_closure(capture: ast::CaptureClause,\n+                   fn_decl: &ast::FnDecl,\n+                   body: &ast::Block,\n+                   span: Span,\n+                   context: &RewriteContext,\n+                   width: usize,\n+                   offset: usize)\n+                   -> Option<String> {\n+    let mover = if capture == ast::CaptureClause::CaptureByValue {\n+        \"move \"\n+    } else {\n+        \"\"\n+    };\n+    let offset = offset + mover.len();\n+\n+    // 4 = \"|| {\".len(), which is overconservative when the closure consists of\n+    // a single expression.\n+    let argument_budget = try_opt!(width.checked_sub(4 + mover.len()));\n+    // 1 = |\n+    let argument_offset = offset + 1;\n+\n+    let arg_items = itemize_list(context.codemap,\n+                                 fn_decl.inputs.iter(),\n+                                 \"|\",\n+                                 |arg| span_lo_for_arg(arg),\n+                                 |arg| span_hi_for_arg(arg),\n+                                 |arg| rewrite_fn_input(arg),\n+                                 span_after(span, \"|\", context.codemap),\n+                                 body.span.lo);\n+\n+    let fmt = ListFormatting::for_fn(argument_budget, argument_offset);\n+    let prefix = format!(\"{}|{}|\", mover, write_list(&arg_items.collect::<Vec<_>>(), &fmt));\n+    let block_indent = closure_block_indent(context, offset);\n+\n+    // Try to format closure body as a single line expression without braces.\n+    if body.stmts.is_empty() {\n+        let expr = body.expr.as_ref().unwrap();\n+        // All closure bodies are blocks in the eyes of the AST, but we may not\n+        // want to unwrap them when they only contain a single expression.\n+        let inner_expr = match expr.node {\n+            ast::Expr_::ExprBlock(ref inner) if inner.stmts.is_empty() && inner.expr.is_some() => {\n+                inner.expr.as_ref().unwrap()\n+            }\n+            _ => expr,\n+        };\n+\n+        // 1 = the separating space between arguments and the body.\n+        let extra_offset = extra_offset(&prefix, offset) + 1;\n+        let rewrite = inner_expr.rewrite(context, width - extra_offset, offset + extra_offset);\n+\n+        // Checks if rewrite succeeded and fits on a single line.\n+        let accept_rewrite = rewrite.as_ref().map(|result| !result.contains('\\n')).unwrap_or(false);\n+\n+        if accept_rewrite {\n+            return Some(format!(\"{} {}\", prefix, rewrite.unwrap()));\n+        }\n+    }\n+\n+    // We couldn't format the closure body as a single line expression; fall\n+    // back to block formatting.\n+    let inner_context = &RewriteContext { block_indent: block_indent, ..*context };\n+    let body_rewrite = if let ast::Expr_::ExprBlock(ref inner) = body.expr.as_ref().unwrap().node {\n+        inner.rewrite(inner_context, 0, 0)\n+    } else {\n+        body.rewrite(inner_context, 0, 0)\n+    };\n+\n+    Some(format!(\"{} {}\", prefix, try_opt!(body_rewrite)))\n+}\n+\n impl Rewrite for ast::Block {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         let user_str = context.codemap.span_to_snippet(self.span).unwrap();\n@@ -674,33 +750,33 @@ fn rewrite_call(context: &RewriteContext,\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n                              // Take old span when rewrite fails.\n-                             |item| item.rewrite(inner_context, remaining_width, offset)\n-                                        .unwrap_or(context.codemap.span_to_snippet(item.span)\n-                                                                  .unwrap()),\n+                             |item| {\n+                                 item.rewrite(inner_context, remaining_width, offset)\n+                                     .unwrap_or(context.codemap.span_to_snippet(item.span).unwrap())\n+                             },\n                              callee.span.hi + BytePos(1),\n                              span.hi);\n \n-    let fmt = ListFormatting {\n-        tactic: ListTactic::HorizontalVertical,\n-        separator: \",\",\n-        trailing_separator: SeparatorTactic::Never,\n-        indent: offset,\n-        h_width: remaining_width,\n-        v_width: remaining_width,\n-        ends_with_newline: false,\n-    };\n+    let fmt = ListFormatting::for_fn(remaining_width, offset);\n \n     Some(format!(\"{}({})\", callee_str, write_list(&items.collect::<Vec<_>>(), &fmt)))\n }\n \n-fn expr_block_indent(context: &RewriteContext, offset: usize) -> usize {\n-    match context.config.expr_indent_style {\n-        BlockIndentStyle::Inherit => context.block_indent,\n-        BlockIndentStyle::Tabbed => context.block_indent + context.config.tab_spaces,\n-        BlockIndentStyle::Visual => offset,\n-    }\n+macro_rules! block_indent_helper {\n+    ($name:ident, $option:ident) => (\n+        fn $name(context: &RewriteContext, offset: usize) -> usize {\n+            match context.config.$option {\n+                BlockIndentStyle::Inherit => context.block_indent,\n+                BlockIndentStyle::Tabbed => context.block_indent + context.config.tab_spaces,\n+                BlockIndentStyle::Visual => offset,\n+            }\n+        }\n+    );\n }\n \n+block_indent_helper!(expr_block_indent, expr_indent_style);\n+block_indent_helper!(closure_block_indent, closure_indent_style);\n+\n fn rewrite_paren(context: &RewriteContext,\n                  subexpr: &ast::Expr,\n                  width: usize,\n@@ -760,13 +836,13 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => field.span.lo,\n                                      // 2 = ..\n-                                     StructLitField::Base(ref expr) => expr.span.lo - BytePos(2)\n+                                     StructLitField::Base(ref expr) => expr.span.lo - BytePos(2),\n                                  }\n                              },\n                              |item| {\n                                  match *item {\n                                      StructLitField::Regular(ref field) => field.span.hi,\n-                                     StructLitField::Base(ref expr) => expr.span.hi\n+                                     StructLitField::Base(ref expr) => expr.span.hi,\n                                  }\n                              },\n                              |item| {\n@@ -775,7 +851,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                          rewrite_field(inner_context, &field, h_budget, indent)\n                                             .unwrap_or(context.codemap.span_to_snippet(field.span)\n                                                                       .unwrap())\n-                                     },\n+                                     }\n                                      StructLitField::Base(ref expr) => {\n                                          // 2 = ..\n                                          expr.rewrite(inner_context, h_budget - 2, indent + 2)\n@@ -846,23 +922,15 @@ fn rewrite_tuple_lit(context: &RewriteContext,\n                              \")\",\n                              |item| item.span.lo,\n                              |item| item.span.hi,\n-                             |item| item.rewrite(context,\n-                                                 context.config.max_width - indent - 1,\n-                                                 indent)\n-                                        .unwrap_or(context.codemap.span_to_snippet(item.span)\n-                                                                  .unwrap()),\n+                             |item| {\n+                                 let inner_width = context.config.max_width - indent - 1;\n+                                 item.rewrite(context, inner_width, indent)\n+                                     .unwrap_or(context.codemap.span_to_snippet(item.span).unwrap())\n+                             },\n                              span.lo + BytePos(1), // Remove parens\n                              span.hi - BytePos(1));\n \n-    let fmt = ListFormatting {\n-        tactic: ListTactic::HorizontalVertical,\n-        separator: \",\",\n-        trailing_separator: SeparatorTactic::Never,\n-        indent: indent,\n-        h_width: width - 2,\n-        v_width: width - 2,\n-        ends_with_newline: false,\n-    };\n+    let fmt = ListFormatting::for_fn(width - 2, indent);\n \n     Some(format!(\"({})\", write_list(&items.collect::<Vec<_>>(), &fmt)))\n }"}, {"sha": "a0ba88de6f2ba085088e90cff83ece941e23dc16", "filename": "src/imports.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -117,13 +117,15 @@ pub fn rewrite_use_list(width: usize,\n                                 \"}\",\n                                 |vpi| vpi.span.lo,\n                                 |vpi| vpi.span.hi,\n-                                |vpi| match vpi.node {\n-                                     ast::PathListItem_::PathListIdent{ name, .. } => {\n-                                         name.to_string()\n-                                     }\n-                                     ast::PathListItem_::PathListMod{ .. } => {\n-                                         \"self\".to_owned()\n-                                     }\n+                                |vpi| {\n+                                    match vpi.node {\n+                                        ast::PathListItem_::PathListIdent{ name, .. } => {\n+                                            name.to_string()\n+                                        }\n+                                        ast::PathListItem_::PathListMod{ .. } => {\n+                                            \"self\".to_owned()\n+                                        }\n+                                    }\n                                 },\n                                 span_after(span, \"{\", context.codemap),\n                                 span.hi);"}, {"sha": "e853dc90c30719edd781a4327e73a44164c99050", "filename": "src/items.rs", "status": "modified", "additions": 35, "deletions": 42, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -232,7 +232,7 @@ impl<'a> FmtVisitor<'a> {\n                     arg_indent: usize,\n                     span: Span)\n                     -> String {\n-        let mut arg_item_strs: Vec<_> = args.iter().map(|a| self.rewrite_fn_input(a)).collect();\n+        let mut arg_item_strs: Vec<_> = args.iter().map(rewrite_fn_input).collect();\n         // Account for sugary self.\n         // FIXME: the comment for the self argument is dropped. This is blocked\n         // on rust issue #27522.\n@@ -512,13 +512,12 @@ impl<'a> FmtVisitor<'a> {\n                                  struct_def.fields.iter(),\n                                  terminator,\n                                  |field| {\n-                                      // Include attributes and doc comments,\n-                                      // if present\n-                                      if field.node.attrs.len() > 0 {\n-                                          field.node.attrs[0].span.lo\n-                                      } else {\n-                                          field.span.lo\n-                                      }\n+                                     // Include attributes and doc comments, if present\n+                                     if field.node.attrs.len() > 0 {\n+                                         field.node.attrs[0].span.lo\n+                                     } else {\n+                                         field.span.lo\n+                                     }\n                                  },\n                                  |field| field.node.ty.span.hi,\n                                  |field| self.format_field(field),\n@@ -650,16 +649,14 @@ impl<'a> FmtVisitor<'a> {\n     fn rewrite_generics(&self, generics: &ast::Generics, offset: usize, span: Span) -> String {\n         // FIXME convert bounds to where clauses where they get too big or if\n         // there is a where clause at all.\n-        let mut result = String::new();\n         let lifetimes: &[_] = &generics.lifetimes;\n         let tys: &[_] = &generics.ty_params;\n         if lifetimes.len() + tys.len() == 0 {\n-            return result;\n+            return String::new();\n         }\n \n         let budget = self.config.max_width - offset - 2;\n         // TODO might need to insert a newline if the generics are really long\n-        result.push('<');\n \n         // Strings for the generics.\n         // 1 = <\n@@ -697,20 +694,9 @@ impl<'a> FmtVisitor<'a> {\n             item.item = ty;\n         }\n \n-        let fmt = ListFormatting {\n-            tactic: ListTactic::HorizontalVertical,\n-            separator: \",\",\n-            trailing_separator: SeparatorTactic::Never,\n-            indent: offset + 1,\n-            h_width: budget,\n-            v_width: budget,\n-            ends_with_newline: false,\n-        };\n-        result.push_str(&write_list(&items, &fmt));\n-\n-        result.push('>');\n+        let fmt = ListFormatting::for_fn(budget, offset + 1);\n \n-        result\n+        format!(\"<{}>\", write_list(&items, &fmt))\n     }\n \n     fn rewrite_where_clause(&self,\n@@ -719,15 +705,10 @@ impl<'a> FmtVisitor<'a> {\n                             indent: usize,\n                             span_end: BytePos)\n                             -> String {\n-        let mut result = String::new();\n         if where_clause.predicates.len() == 0 {\n-            return result;\n+            return String::new();\n         }\n \n-        result.push('\\n');\n-        result.push_str(&make_indent(indent + config.tab_spaces));\n-        result.push_str(\"where \");\n-\n         let context = self.get_context();\n         // 6 = \"where \".len()\n         let offset = indent + config.tab_spaces + 6;\n@@ -752,11 +733,12 @@ impl<'a> FmtVisitor<'a> {\n             indent: offset,\n             h_width: budget,\n             v_width: budget,\n-            ends_with_newline: false,\n+            ends_with_newline: true,\n         };\n-        result.push_str(&write_list(&items.collect::<Vec<_>>(), &fmt));\n \n-        result\n+        format!(\"\\n{}where {}\",\n+                make_indent(indent + config.tab_spaces),\n+                write_list(&items.collect::<Vec<_>>(), &fmt))\n     }\n \n     fn rewrite_return(&self, ret: &ast::FunctionRetTy) -> String {\n@@ -766,17 +748,21 @@ impl<'a> FmtVisitor<'a> {\n             ast::FunctionRetTy::Return(ref ty) => \"-> \".to_owned() + &pprust::ty_to_string(ty),\n         }\n     }\n+}\n \n-    // TODO we farm this out, but this could spill over the column limit, so we\n-    // ought to handle it properly.\n-    fn rewrite_fn_input(&self, arg: &ast::Arg) -> String {\n-        if is_named_arg(arg) {\n-            format!(\"{}: {}\",\n-                    pprust::pat_to_string(&arg.pat),\n-                    pprust::ty_to_string(&arg.ty))\n+// TODO we farm this out, but this could spill over the column limit, so we\n+// ought to handle it properly.\n+pub fn rewrite_fn_input(arg: &ast::Arg) -> String {\n+    if is_named_arg(arg) {\n+        if let ast::Ty_::TyInfer = arg.ty.node {\n+            pprust::pat_to_string(&arg.pat)\n         } else {\n-            pprust::ty_to_string(&arg.ty)\n+            format!(\"{}: {}\",\n+                pprust::pat_to_string(&arg.pat),\n+                pprust::ty_to_string(&arg.ty))\n         }\n+    } else {\n+        pprust::ty_to_string(&arg.ty)\n     }\n }\n \n@@ -810,14 +796,21 @@ fn rewrite_explicit_self(explicit_self: &ast::ExplicitSelf, args: &[ast::Arg]) -\n     }\n }\n \n-fn span_lo_for_arg(arg: &ast::Arg) -> BytePos {\n+pub fn span_lo_for_arg(arg: &ast::Arg) -> BytePos {\n     if is_named_arg(arg) {\n         arg.pat.span.lo\n     } else {\n         arg.ty.span.lo\n     }\n }\n \n+pub fn span_hi_for_arg(arg: &ast::Arg) -> BytePos {\n+    match arg.ty.node {\n+        ast::Ty_::TyInfer if is_named_arg(arg) => arg.pat.span.hi,\n+        _ => arg.ty.span.hi,\n+    }\n+}\n+\n fn is_named_arg(arg: &ast::Arg) -> bool {\n     if let ast::Pat_::PatIdent(_, ident, _) = arg.pat.node {\n         ident.node != token::special_idents::invalid"}, {"sha": "dd1a489b84759560312c7f24dbec6eb7713cd5f9", "filename": "src/lists.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -52,6 +52,20 @@ pub struct ListFormatting<'a> {\n     pub ends_with_newline: bool,\n }\n \n+impl<'a> ListFormatting<'a> {\n+    pub fn for_fn(width: usize, offset: usize) -> ListFormatting<'a> {\n+        ListFormatting {\n+            tactic: ListTactic::HorizontalVertical,\n+            separator: \",\",\n+            trailing_separator: SeparatorTactic::Never,\n+            indent: offset,\n+            h_width: width,\n+            v_width: width,\n+            ends_with_newline: false,\n+        }\n+    }\n+}\n+\n pub struct ListItem {\n     pub pre_comment: Option<String>,\n     // Item should include attributes and doc comments"}, {"sha": "fa3d61603b8cdcc9e8683e652d1d1e3584df0b97", "filename": "src/types.rs", "status": "modified", "additions": 4, "deletions": 21, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -14,7 +14,7 @@ use syntax::ast;\n use syntax::print::pprust;\n use syntax::codemap::{self, Span, BytePos, CodeMap};\n \n-use lists::{itemize_list, write_list, ListTactic, SeparatorTactic, ListFormatting};\n+use lists::{itemize_list, write_list, ListFormatting};\n use rewrite::{Rewrite, RewriteContext};\n use utils::{extra_offset, span_after};\n \n@@ -218,16 +218,7 @@ fn rewrite_segment(segment: &ast::PathSegment,\n             let extra_offset = 1 + separator.len();\n             // 1 for >\n             let list_width = try_opt!(width.checked_sub(extra_offset + 1));\n-\n-            let fmt = ListFormatting {\n-                tactic: ListTactic::HorizontalVertical,\n-                separator: \",\",\n-                trailing_separator: SeparatorTactic::Never,\n-                indent: offset + extra_offset,\n-                h_width: list_width,\n-                v_width: list_width,\n-                ends_with_newline: false,\n-            };\n+            let fmt = ListFormatting::for_fn(list_width, offset + extra_offset);\n \n             // update pos\n             *span_lo = next_span_lo;\n@@ -253,16 +244,8 @@ fn rewrite_segment(segment: &ast::PathSegment,\n             // 2 for ()\n             let budget = try_opt!(width.checked_sub(output.len() + 2));\n \n-            let fmt = ListFormatting {\n-                tactic: ListTactic::HorizontalVertical,\n-                separator: \",\",\n-                trailing_separator: SeparatorTactic::Never,\n-                // 1 for (\n-                indent: offset + 1,\n-                h_width: budget,\n-                v_width: budget,\n-                ends_with_newline: false,\n-            };\n+            // 1 for (\n+            let fmt = ListFormatting::for_fn(budget, offset + 1);\n \n             // update pos\n             *span_lo = data.inputs.last().unwrap().span.hi + BytePos(1);"}, {"sha": "2489a8c1a9d5cdd951c768d4ff8662576f4d50ed", "filename": "src/visitor.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -68,9 +68,18 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                self.codemap.lookup_char_pos(b.span.lo),\n                self.codemap.lookup_char_pos(b.span.hi));\n \n-        self.buffer.push_str(\"{\");\n-        self.last_pos = self.last_pos + BytePos(1);\n+        // Check if this block has braces.\n+        let snippet = self.snippet(b.span);\n+        let has_braces = snippet.chars().next().unwrap() == '{' || &snippet[..6] == \"unsafe\";\n+        let brace_compensation = if has_braces {\n+            BytePos(1)\n+        } else {\n+            BytePos(0)\n+        };\n+\n+        self.last_pos = self.last_pos + brace_compensation;\n         self.block_indent += self.config.tab_spaces;\n+        self.buffer.push_str(\"{\");\n \n         for stmt in &b.stmts {\n             self.visit_stmt(&stmt)\n@@ -86,7 +95,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n \n         self.block_indent -= self.config.tab_spaces;\n         // TODO we should compress any newlines here to just one\n-        self.format_missing_with_indent(b.span.hi - BytePos(1));\n+        self.format_missing_with_indent(b.span.hi - brace_compensation);\n         self.buffer.push_str(\"}\");\n         self.last_pos = b.span.hi;\n     }"}, {"sha": "2aff85506a4ce2094c7aa2da595c929b9806daed", "filename": "tests/config/small_tabs.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/tests%2Fconfig%2Fsmall_tabs.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/tests%2Fconfig%2Fsmall_tabs.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconfig%2Fsmall_tabs.toml?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -14,3 +14,4 @@ report_todo = \"Always\"\n report_fixme = \"Never\"\n reorder_imports = false\n expr_indent_style = \"Tabbed\"\n+closure_indent_style = \"Visual\""}, {"sha": "06b10758011854aad2fd35ccc250092d6a0b5418", "filename": "tests/source/closure.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/tests%2Fsource%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/tests%2Fsource%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fclosure.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -0,0 +1,39 @@\n+// Closures\n+\n+fn main() {\n+    let square = ( |i:  i32 | i  *  i );\n+\n+    let commented = |/* first */ a /*argument*/, /* second*/ b: WithType /* argument*/, /* ignored */ _ |\n+        (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbb);\n+\n+    let commented = |/* first */ a /*argument*/, /* second*/ b: WithType /* argument*/, /* ignored */ _ |\n+        (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb);\n+\n+    let block_body = move   |xxxxxxxxxxxxxxxxxxxxxxxxxxxxx,  ref  yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy| {\n+            xxxxxxxxxxxxxxxxxxxxxxxxxxxxx + yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\n+        };\n+\n+    let loooooooooooooong_name = |field| {\n+             // TODO(#27): format comments.\n+             if field.node.attrs.len() > 0 { field.node.attrs[0].span.lo\n+             } else {\n+                 field.span.lo\n+             }};\n+\n+    let block_me = |field| if true_story() { 1 } else { 2 };\n+\n+    let unblock_me = |trivial| {\n+                         closure()\n+                     };\n+\n+    let empty = |arg|    {};\n+\n+    let test = |  | { do_something(); do_something_else(); };\n+\n+    let arg_test = |big_argument_name, test123| looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame();\n+\n+    let arg_test = |big_argument_name, test123| {looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()};\n+\n+    |arg1, arg2, _, _, arg3, arg4| { let temp = arg4 + arg3;\n+                                     arg2 * arg1 - temp }\n+}"}, {"sha": "5042f1d037aee8b00bef4c59ba6f1c25d06ccf61", "filename": "tests/target/closure.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/tests%2Ftarget%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/tests%2Ftarget%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fclosure.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -0,0 +1,66 @@\n+// Closures\n+\n+fn main() {\n+    let square = (|i: i32| i * i);\n+\n+    let commented = |// first\n+                     a, // argument\n+                     // second\n+                     b: WithType, // argument\n+                     // ignored\n+                     _| (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, bbbbbbbbbbbbbbbbbbbbbbbbbbb);\n+\n+    let commented = |// first\n+                     a, // argument\n+                     // second\n+                     b: WithType, // argument\n+                     // ignored\n+                     _| {\n+                        (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+                         bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb)\n+                    };\n+\n+    let block_body = move |xxxxxxxxxxxxxxxxxxxxxxxxxxxxx,\n+                           ref yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy| {\n+                              xxxxxxxxxxxxxxxxxxxxxxxxxxxxx + yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\n+                          };\n+\n+    let loooooooooooooong_name = |field| {\n+             // TODO(#27): format comments.\n+                                     if field.node.attrs.len() > 0 {\n+                                         field.node.attrs[0].span.lo\n+                                     } else {\n+                                         field.span.lo\n+                                     }\n+                                 };\n+\n+    let block_me = |field| {\n+                       if true_story() {\n+                           1\n+                       } else {\n+                           2\n+                       }\n+                   };\n+\n+    let unblock_me = |trivial| closure();\n+\n+    let empty = |arg| {};\n+\n+    let test = || {\n+                   do_something();\n+                   do_something_else();\n+               };\n+\n+    let arg_test = |big_argument_name, test123| {\n+                       looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()\n+                   };\n+\n+    let arg_test = |big_argument_name, test123| {\n+                       looooooooooooooooooong_function_naaaaaaaaaaaaaaaaame()\n+                   };\n+\n+    |arg1, arg2, _, _, arg3, arg4| {\n+        let temp = arg4 + arg3;\n+        arg2 * arg1 - temp\n+    }\n+}"}, {"sha": "57b6ae63381021d1a028a1bf5f83770bb3dbd07d", "filename": "tests/target/comments-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a19c6d30c3673361489b248a187dc2571873f8a/tests%2Ftarget%2Fcomments-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a19c6d30c3673361489b248a187dc2571873f8a/tests%2Ftarget%2Fcomments-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomments-fn.rs?ref=0a19c6d30c3673361489b248a187dc2571873f8a", "patch": "@@ -11,7 +11,7 @@ fn foo<F, G>(a: aaaaaaaaaaaaa, // A comment\n              e: eeeeeeeeeeeee /* comment before paren */)\n              -> bar\n     where F: Foo, // COmment after where clause\n-          G: Goo /* final comment */\n+          G: Goo // final comment\n {\n \n }"}]}