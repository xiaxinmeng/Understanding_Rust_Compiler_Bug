{"sha": "e4638def7aedd8d69ec2670abf6a08b876ad75d9", "node_id": "C_kwDOAAsO6NoAKGU0NjM4ZGVmN2FlZGQ4ZDY5ZWMyNjcwYWJmNmEwOGI4NzZhZDc1ZDk", "commit": {"author": {"name": "Dorian Scheidt", "email": "dorian.scheidt@gmail.com", "date": "2022-07-20T18:02:21Z"}, "committer": {"name": "Dorian Scheidt", "email": "dorian.scheidt@gmail.com", "date": "2022-08-02T18:37:12Z"}, "message": "Support record fields in generate_enum_variant", "tree": {"sha": "928ec1b8bc526fe7eb962daf5927ed664e2213a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/928ec1b8bc526fe7eb962daf5927ed664e2213a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4638def7aedd8d69ec2670abf6a08b876ad75d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4638def7aedd8d69ec2670abf6a08b876ad75d9", "html_url": "https://github.com/rust-lang/rust/commit/e4638def7aedd8d69ec2670abf6a08b876ad75d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4638def7aedd8d69ec2670abf6a08b876ad75d9/comments", "author": {"login": "DorianListens", "id": 5692947, "node_id": "MDQ6VXNlcjU2OTI5NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5692947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DorianListens", "html_url": "https://github.com/DorianListens", "followers_url": "https://api.github.com/users/DorianListens/followers", "following_url": "https://api.github.com/users/DorianListens/following{/other_user}", "gists_url": "https://api.github.com/users/DorianListens/gists{/gist_id}", "starred_url": "https://api.github.com/users/DorianListens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DorianListens/subscriptions", "organizations_url": "https://api.github.com/users/DorianListens/orgs", "repos_url": "https://api.github.com/users/DorianListens/repos", "events_url": "https://api.github.com/users/DorianListens/events{/privacy}", "received_events_url": "https://api.github.com/users/DorianListens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DorianListens", "id": 5692947, "node_id": "MDQ6VXNlcjU2OTI5NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5692947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DorianListens", "html_url": "https://github.com/DorianListens", "followers_url": "https://api.github.com/users/DorianListens/followers", "following_url": "https://api.github.com/users/DorianListens/following{/other_user}", "gists_url": "https://api.github.com/users/DorianListens/gists{/gist_id}", "starred_url": "https://api.github.com/users/DorianListens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DorianListens/subscriptions", "organizations_url": "https://api.github.com/users/DorianListens/orgs", "repos_url": "https://api.github.com/users/DorianListens/repos", "events_url": "https://api.github.com/users/DorianListens/events{/privacy}", "received_events_url": "https://api.github.com/users/DorianListens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15d8049fa9a9cd3ecbd19401336c4c150606522c", "url": "https://api.github.com/repos/rust-lang/rust/commits/15d8049fa9a9cd3ecbd19401336c4c150606522c", "html_url": "https://github.com/rust-lang/rust/commit/15d8049fa9a9cd3ecbd19401336c4c150606522c"}], "stats": {"total": 165, "additions": 156, "deletions": 9}, "files": [{"sha": "afbfc74b72a25fcd79b66ae799f73b61d2478899", "filename": "crates/ide-assists/src/handlers/generate_enum_variant.rs", "status": "modified", "additions": 156, "deletions": 9, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/e4638def7aedd8d69ec2670abf6a08b876ad75d9/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4638def7aedd8d69ec2670abf6a08b876ad75d9/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_enum_variant.rs?ref=e4638def7aedd8d69ec2670abf6a08b876ad75d9", "patch": "@@ -32,8 +32,7 @@ use crate::assist_context::{AssistContext, Assists};\n // }\n // ```\n pub(crate) fn generate_enum_variant(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()> {\n-    let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n-    let path = path_expr.path()?;\n+    let path: ast::Path = ctx.find_node_at_offset()?;\n \n     if ctx.sema.resolve_path(&path).is_some() {\n         // No need to generate anything if the path resolves\n@@ -95,30 +94,69 @@ fn make_field_list(ctx: &AssistContext<'_>, path: &ast::Path) -> Option<ast::Fie\n         path.syntax().parent().and_then(|it| it.parent()).and_then(ast::CallExpr::cast)\n     {\n         make_tuple_field_list(call_expr, ctx, &scope)\n+    } else if let Some(record_expr) = path.syntax().parent().and_then(ast::RecordExpr::cast) {\n+        make_record_field_list(record_expr, ctx, &scope)\n     } else {\n         None\n     }\n }\n \n+fn make_record_field_list(\n+    record: ast::RecordExpr,\n+    ctx: &AssistContext<'_>,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::FieldList> {\n+    let fields = record.record_expr_field_list()?.fields();\n+    let record_fields = fields.map(|field| {\n+        let name = name_from_field(&field);\n+\n+        let ty = field\n+            .expr()\n+            .and_then(|it| expr_ty(ctx, it, scope))\n+            .unwrap_or_else(make::ty_placeholder);\n+\n+        make::record_field(None, name, ty)\n+    });\n+    Some(make::record_field_list(record_fields).into())\n+}\n+\n+fn name_from_field(field: &ast::RecordExprField) -> ast::Name {\n+    let text = match field.name_ref() {\n+        Some(it) => it.to_string(),\n+        None => name_from_field_shorthand(field).unwrap_or(\"unknown\".to_string()),\n+    };\n+    make::name(&text)\n+}\n+\n+fn name_from_field_shorthand(field: &ast::RecordExprField) -> Option<String> {\n+    let path = match field.expr()? {\n+        ast::Expr::PathExpr(path_expr) => path_expr.path(),\n+        _ => None,\n+    }?;\n+    Some(path.as_single_name_ref()?.to_string())\n+}\n+\n fn make_tuple_field_list(\n     call_expr: ast::CallExpr,\n     ctx: &AssistContext<'_>,\n     scope: &hir::SemanticsScope<'_>,\n ) -> Option<ast::FieldList> {\n     let args = call_expr.arg_list()?.args();\n     let tuple_fields = args.map(|arg| {\n-        let ty = expr_ty(ctx, arg, &scope);\n+        let ty = expr_ty(ctx, arg, &scope).unwrap_or_else(make::ty_placeholder);\n         make::tuple_field(None, ty)\n     });\n     Some(make::tuple_field_list(tuple_fields).into())\n }\n \n-fn expr_ty(ctx: &AssistContext<'_>, arg: ast::Expr, scope: &hir::SemanticsScope<'_>) -> ast::Type {\n-    let ty = ctx.sema.type_of_expr(&arg).map(|it| it.adjusted());\n-    let text = ty\n-        .and_then(|it| it.display_source_code(ctx.db(), scope.module().into()).ok())\n-        .unwrap_or_else(|| \"_\".to_string());\n-    make::ty(&text)\n+fn expr_ty(\n+    ctx: &AssistContext<'_>,\n+    arg: ast::Expr,\n+    scope: &hir::SemanticsScope<'_>,\n+) -> Option<ast::Type> {\n+    let ty = ctx.sema.type_of_expr(&arg).map(|it| it.adjusted())?;\n+    let text = ty.display_source_code(ctx.db(), scope.module().into()).ok()?;\n+    Some(make::ty(&text))\n }\n \n #[cfg(test)]\n@@ -318,6 +356,115 @@ enum Foo {\n fn main() {\n     Foo::Bar(true, x, Struct {})\n }\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x: true }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: bool },\n+}\n+fn main() {\n+    Foo::Bar { x: true }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x: y }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: _ },\n+}\n+fn main() {\n+    Foo::Bar { x: y }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_shorthand() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    let x = true;\n+    Foo::$0Bar { x }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: bool },\n+}\n+fn main() {\n+    let x = true;\n+    Foo::Bar { x }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_shorthand_unknown_type() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x }\n+}\n+\",\n+            r\"\n+enum Foo {\n+    Bar { x: _ },\n+}\n+fn main() {\n+    Foo::Bar { x }\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn associated_record_field_multiple_fields() {\n+        check_assist(\n+            generate_enum_variant,\n+            r\"\n+struct Struct {}\n+enum Foo {}\n+fn main() {\n+    Foo::$0Bar { x, y: x, s: Struct {} }\n+}\n+\",\n+            r\"\n+struct Struct {}\n+enum Foo {\n+    Bar { x: _, y: _, s: Struct },\n+}\n+fn main() {\n+    Foo::Bar { x, y: x, s: Struct {} }\n+}\n \",\n         )\n     }"}]}