{"sha": "800221b5b8f52c59e12e9aae282288c60c87285c", "node_id": "C_kwDOAAsO6NoAKDgwMDIyMWI1YjhmNTJjNTllMTJlOWFhZTI4MjI4OGM2MGM4NzI4NWM", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-02-06T20:16:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-06T20:16:39Z"}, "message": "Rollup merge of #106477 - Nathan-Fenner:nathanf/refined-error-span-trait-impl, r=compiler-errors\n\nRefine error spans for \"The trait bound `T: Trait` is not satisfied\" when passing literal structs/tuples\n\nThis PR adds a new heuristic which refines the error span reported for \"`T: Trait` is not satisfied\" errors, by \"drilling down\" into individual fields of structs/enums/tuples to point to the \"problematic\" value.\n\nHere's a self-contained example of the difference in error span:\n\n```rs\nstruct Burrito<Filling> {\n    filling: Filling,\n}\nimpl <Filling: Delicious> Delicious for Burrito<Filling> {}\nfn eat_delicious_food<Food: Delicious>(food: Food) {}\nfn will_type_error() {\n    eat_delicious_food(Burrito { filling: Kale });\n    //                 ^~~~~~~~~~~~~~~~~~~~~~~~~ (before) The trait bound `Kale: Delicious` is not satisfied\n    //                                    ^~~~   (after)  The trait bound `Kale: Delicious` is not satisfied\n}\n```\n(kale is fine, this is just a silly food-based example)\n\nBefore this PR, the error span is identified as the entire argument to the generic function `eat_delicious_food`. However, since only `Kale` is the \"problematic\" part, we can point at it specifically. In particular, the primary error message itself mentions the missing `Kale: Delicious` trait bound, so it's much clearer if this part is called out explicitly.\n\n---\n\nThe _existing_ heuristic tries to label the right function argument in `point_at_arg_if_possible`. It goes something like this:\n- Look at the broken base trait `Food: Delicious` and find which generics it mentions (in this case, only `Food`)\n- Look at the parameter type definitions and find which of them mention `Filling` (in this case, only `food`)\n- If there is exactly one relevant parameter, label the corresponding argument with the error span, instead of the entire call\n\nThis PR extends this heuristic by further refining the resulting expression span in the new `point_at_specific_expr_if_possible` function. For each `impl` in the (broken) chain, we apply the following strategy:\n\nThe strategy to determine this span involves connecting information about our generic `impl`\nwith information about our (struct) type and the (struct) literal expression:\n- Find the `impl` (`impl <Filling: Delicious> Delicious for Burrito<Filling>`)\n  that links our obligation (`Kale: Delicious`) with the parent obligation (`Burrito<Kale>: Delicious`)\n- Find the \"original\" predicate constraint in the impl (`Filling: Delicious`) which produced our obligation.\n- Find all of the generics that are mentioned in the predicate (`Filling`).\n- Examine the `Self` type in the `impl`, and see which of its type argument(s) mention any of those generics.\n- Examing the definition for the `Self` type, and identify (for each of its variants) if there's a unique field\n  which uses those generic arguments.\n- If there is a unique field mentioning the \"blameable\" arguments, use that field for the error span.\n\nBefore we do any of this logic, we recursively call `point_at_specific_expr_if_possible` on the parent\nobligation. Hence we refine the `expr` \"outwards-in\" and bail at the first kind of expression/impl we don't recognize.\n\nThis function returns a `Result<&Expr, &Expr>` - either way, it returns the `Expr` whose span should be\nreported as an error. If it is `Ok`, then it means it refined successfull. If it is `Err`, then it may be\nonly a partial success - but it cannot be refined even further.\n\n---\n\nI added a new test file which exercises this new behavior. A few existing tests were affected, since their error spans are now different. In one case, this leads to a different code suggestion for the autofix - although the new suggestion isn't _wrong_, it is different from what used to be.\n\nThis change doesn't create any new errors or remove any existing ones, it just adjusts the spans where they're presented.\n\n---\n\nSome considerations: right now, this check occurs in addition to some similar logic in `adjust_fulfillment_error_for_expr_obligation` function, which tidies up various kinds of error spans (not just trait-fulfillment error). It's possible that this new code would be better integrated into that function (or another one) - but I haven't looked into this yet.\n\nAlthough this code only occurs when there's a type error, it's definitely not as efficient as possible. In particular, there are definitely some cases where it degrades to quadratic performance (e.g. for a trait `impl` with 100+ generic parameters or 100 levels deep nesting of generic types). I'm not sure if these are realistic enough to worry about optimizing yet.\n\nThere's also still a lot of repetition in some of the logic, where the behavior for different types (namely, `struct` vs `enum` variant) is _similar_ but not the same.\n\n---\n\nI think the biggest win here is better targeting for tuples; in particular, if you're using tuples + traits to express variadic-like functions, the compiler can't tell you which part of a tuple has the wrong type, since the span will cover the entire argument. This change allows the individual field in the tuple to be highlighted, as in this example:\n\n```\n// NEW\nLL |     want(Wrapper { value: (3, q) });\n   |     ----                      ^ the trait `T3` is not implemented for `Q`\n\n// OLD\nLL |     want(Wrapper { value: (3, q) });\n   |     ---- ^~~~~~~~~~~~~~~~~~~~~~~~~ the trait `T3` is not implemented for `Q`\n```\nEspecially with large tuples, the existing error spans are not very effective at quickly narrowing down the source of the problem.", "tree": {"sha": "1de2c12f9ee87a3f1da0cec7c9195e334271f844", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1de2c12f9ee87a3f1da0cec7c9195e334271f844"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/800221b5b8f52c59e12e9aae282288c60c87285c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj4WAnCRBK7hj4Ov3rIwAA6ZAIAJ6Vz4ky2I62GqlZ6HL7KbB6\n+1tVJwYurL9N8pe5J9dY+f0EWLVkCeu9IBXwyklZQ1mtU3CMhALwW6kSXW7dg+tM\nqeFs502vhyzF6aLnaV/calfPguxCtOwJB5kT8UU6/IyBZZevLDBa7Y205ZRTU0Pm\nOpYS021exs5gglvTY3SXB2u2kHozzMZz9JSXBFWXV0feRvOIlTeSNSPZhrqxUa82\n77cny9rIiFIgK+ZEtDe4tHPmlofqgFTZ7N+U8VTmO+TY+ZmXrEqS0x8/MMMF/9Xj\nhrLE5XfHUaIjDN0GEw3cLkSRS2Ty20cOlmpuSvs8GdlpVlJFlKBk7qgpDWY0n/s=\n=2Rmd\n-----END PGP SIGNATURE-----\n", "payload": "tree 1de2c12f9ee87a3f1da0cec7c9195e334271f844\nparent 7ff69b49dfcc0f7d37ee17e36f67c57168c44073\nparent 99638a68175c8f8483f58dc6878fe836929fde77\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1675714599 +0100\ncommitter GitHub <noreply@github.com> 1675714599 +0100\n\nRollup merge of #106477 - Nathan-Fenner:nathanf/refined-error-span-trait-impl, r=compiler-errors\n\nRefine error spans for \"The trait bound `T: Trait` is not satisfied\" when passing literal structs/tuples\n\nThis PR adds a new heuristic which refines the error span reported for \"`T: Trait` is not satisfied\" errors, by \"drilling down\" into individual fields of structs/enums/tuples to point to the \"problematic\" value.\n\nHere's a self-contained example of the difference in error span:\n\n```rs\nstruct Burrito<Filling> {\n    filling: Filling,\n}\nimpl <Filling: Delicious> Delicious for Burrito<Filling> {}\nfn eat_delicious_food<Food: Delicious>(food: Food) {}\nfn will_type_error() {\n    eat_delicious_food(Burrito { filling: Kale });\n    //                 ^~~~~~~~~~~~~~~~~~~~~~~~~ (before) The trait bound `Kale: Delicious` is not satisfied\n    //                                    ^~~~   (after)  The trait bound `Kale: Delicious` is not satisfied\n}\n```\n(kale is fine, this is just a silly food-based example)\n\nBefore this PR, the error span is identified as the entire argument to the generic function `eat_delicious_food`. However, since only `Kale` is the \"problematic\" part, we can point at it specifically. In particular, the primary error message itself mentions the missing `Kale: Delicious` trait bound, so it's much clearer if this part is called out explicitly.\n\n---\n\nThe _existing_ heuristic tries to label the right function argument in `point_at_arg_if_possible`. It goes something like this:\n- Look at the broken base trait `Food: Delicious` and find which generics it mentions (in this case, only `Food`)\n- Look at the parameter type definitions and find which of them mention `Filling` (in this case, only `food`)\n- If there is exactly one relevant parameter, label the corresponding argument with the error span, instead of the entire call\n\nThis PR extends this heuristic by further refining the resulting expression span in the new `point_at_specific_expr_if_possible` function. For each `impl` in the (broken) chain, we apply the following strategy:\n\nThe strategy to determine this span involves connecting information about our generic `impl`\nwith information about our (struct) type and the (struct) literal expression:\n- Find the `impl` (`impl <Filling: Delicious> Delicious for Burrito<Filling>`)\n  that links our obligation (`Kale: Delicious`) with the parent obligation (`Burrito<Kale>: Delicious`)\n- Find the \"original\" predicate constraint in the impl (`Filling: Delicious`) which produced our obligation.\n- Find all of the generics that are mentioned in the predicate (`Filling`).\n- Examine the `Self` type in the `impl`, and see which of its type argument(s) mention any of those generics.\n- Examing the definition for the `Self` type, and identify (for each of its variants) if there's a unique field\n  which uses those generic arguments.\n- If there is a unique field mentioning the \"blameable\" arguments, use that field for the error span.\n\nBefore we do any of this logic, we recursively call `point_at_specific_expr_if_possible` on the parent\nobligation. Hence we refine the `expr` \"outwards-in\" and bail at the first kind of expression/impl we don't recognize.\n\nThis function returns a `Result<&Expr, &Expr>` - either way, it returns the `Expr` whose span should be\nreported as an error. If it is `Ok`, then it means it refined successfull. If it is `Err`, then it may be\nonly a partial success - but it cannot be refined even further.\n\n---\n\nI added a new test file which exercises this new behavior. A few existing tests were affected, since their error spans are now different. In one case, this leads to a different code suggestion for the autofix - although the new suggestion isn't _wrong_, it is different from what used to be.\n\nThis change doesn't create any new errors or remove any existing ones, it just adjusts the spans where they're presented.\n\n---\n\nSome considerations: right now, this check occurs in addition to some similar logic in `adjust_fulfillment_error_for_expr_obligation` function, which tidies up various kinds of error spans (not just trait-fulfillment error). It's possible that this new code would be better integrated into that function (or another one) - but I haven't looked into this yet.\n\nAlthough this code only occurs when there's a type error, it's definitely not as efficient as possible. In particular, there are definitely some cases where it degrades to quadratic performance (e.g. for a trait `impl` with 100+ generic parameters or 100 levels deep nesting of generic types). I'm not sure if these are realistic enough to worry about optimizing yet.\n\nThere's also still a lot of repetition in some of the logic, where the behavior for different types (namely, `struct` vs `enum` variant) is _similar_ but not the same.\n\n---\n\nI think the biggest win here is better targeting for tuples; in particular, if you're using tuples + traits to express variadic-like functions, the compiler can't tell you which part of a tuple has the wrong type, since the span will cover the entire argument. This change allows the individual field in the tuple to be highlighted, as in this example:\n\n```\n// NEW\nLL |     want(Wrapper { value: (3, q) });\n   |     ----                      ^ the trait `T3` is not implemented for `Q`\n\n// OLD\nLL |     want(Wrapper { value: (3, q) });\n   |     ---- ^~~~~~~~~~~~~~~~~~~~~~~~~ the trait `T3` is not implemented for `Q`\n```\nEspecially with large tuples, the existing error spans are not very effective at quickly narrowing down the source of the problem.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/800221b5b8f52c59e12e9aae282288c60c87285c", "html_url": "https://github.com/rust-lang/rust/commit/800221b5b8f52c59e12e9aae282288c60c87285c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/800221b5b8f52c59e12e9aae282288c60c87285c/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ff69b49dfcc0f7d37ee17e36f67c57168c44073", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ff69b49dfcc0f7d37ee17e36f67c57168c44073", "html_url": "https://github.com/rust-lang/rust/commit/7ff69b49dfcc0f7d37ee17e36f67c57168c44073"}, {"sha": "99638a68175c8f8483f58dc6878fe836929fde77", "url": "https://api.github.com/repos/rust-lang/rust/commits/99638a68175c8f8483f58dc6878fe836929fde77", "html_url": "https://github.com/rust-lang/rust/commit/99638a68175c8f8483f58dc6878fe836929fde77"}], "stats": {"total": 1201, "additions": 1120, "deletions": 81}, "files": [{"sha": "2eab68050d43043d6395205cbb863cb908445677", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "added", "additions": 457, "deletions": 0, "changes": 457, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -0,0 +1,457 @@\n+use crate::FnCtxt;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_trait_selection::traits;\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /**\n+     * Recursively searches for the most-specific blamable expression.\n+     * For example, if you have a chain of constraints like:\n+     * - want `Vec<i32>: Copy`\n+     * - because `Option<Vec<i32>>: Copy` needs `Vec<i32>: Copy` because `impl <T: Copy> Copy for Option<T>`\n+     * - because `(Option<Vec<i32>, bool)` needs `Option<Vec<i32>>: Copy` because `impl <A: Copy, B: Copy> Copy for (A, B)`\n+     * then if you pass in `(Some(vec![1, 2, 3]), false)`, this helper `point_at_specific_expr_if_possible`\n+     * will find the expression `vec![1, 2, 3]` as the \"most blameable\" reason for this missing constraint.\n+     *\n+     * This function only updates the error span.\n+     */\n+    pub fn blame_specific_expr_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) {\n+        // Whether it succeeded or failed, it likely made some amount of progress.\n+        // In the very worst case, it's just the same `expr` we originally passed in.\n+        let expr = match self.blame_specific_expr_if_possible_for_obligation_cause_code(\n+            &error.obligation.cause.code(),\n+            expr,\n+        ) {\n+            Ok(expr) => expr,\n+            Err(expr) => expr,\n+        };\n+\n+        // Either way, use this expression to update the error span.\n+        // If it doesn't overlap the existing span at all, use the original span.\n+        // FIXME: It would possibly be better to do this more continuously, at each level...\n+        error.obligation.cause.span = expr\n+            .span\n+            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+            .unwrap_or(error.obligation.cause.span);\n+    }\n+\n+    fn blame_specific_expr_if_possible_for_obligation_cause_code(\n+        &self,\n+        obligation_cause_code: &traits::ObligationCauseCode<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        match obligation_cause_code {\n+            traits::ObligationCauseCode::ExprBindingObligation(_, _, _, _) => {\n+                // This is the \"root\"; we assume that the `expr` is already pointing here.\n+                // Therefore, we return `Ok` so that this `expr` can be refined further.\n+                Ok(expr)\n+            }\n+            traits::ObligationCauseCode::ImplDerivedObligation(impl_derived) => self\n+                .blame_specific_expr_if_possible_for_derived_predicate_obligation(\n+                    impl_derived,\n+                    expr,\n+                ),\n+            _ => {\n+                // We don't recognize this kind of constraint, so we cannot refine the expression\n+                // any further.\n+                Err(expr)\n+            }\n+        }\n+    }\n+\n+    /// We want to achieve the error span in the following example:\n+    ///\n+    /// ```ignore (just for demonstration)\n+    /// struct Burrito<Filling> {\n+    ///   filling: Filling,\n+    /// }\n+    /// impl <Filling: Delicious> Delicious for Burrito<Filling> {}\n+    /// fn eat_delicious_food<Food: Delicious>(_food: Food) {}\n+    ///\n+    /// fn will_type_error() {\n+    ///   eat_delicious_food(Burrito { filling: Kale });\n+    /// } //                                    ^--- The trait bound `Kale: Delicious`\n+    ///   //                                         is not satisfied\n+    /// ```\n+    ///\n+    /// Without calling this function, the error span will cover the entire argument expression.\n+    ///\n+    /// Before we do any of this logic, we recursively call `point_at_specific_expr_if_possible` on the parent\n+    /// obligation. Hence we refine the `expr` \"outwards-in\" and bail at the first kind of expression/impl we don't recognize.\n+    ///\n+    /// This function returns a `Result<&Expr, &Expr>` - either way, it returns the `Expr` whose span should be\n+    /// reported as an error. If it is `Ok`, then it means it refined successfull. If it is `Err`, then it may be\n+    /// only a partial success - but it cannot be refined even further.\n+    fn blame_specific_expr_if_possible_for_derived_predicate_obligation(\n+        &self,\n+        obligation: &traits::ImplDerivedObligationCause<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        // First, we attempt to refine the `expr` for our span using the parent obligation.\n+        // If this cannot be done, then we are already stuck, so we stop early (hence the use\n+        // of the `?` try operator here).\n+        let expr = self.blame_specific_expr_if_possible_for_obligation_cause_code(\n+            &*obligation.derived.parent_code,\n+            expr,\n+        )?;\n+\n+        // This is the \"trait\" (meaning, the predicate \"proved\" by this `impl`) which provides the `Self` type we care about.\n+        // For the purposes of this function, we hope that it is a `struct` type, and that our current `expr` is a literal of\n+        // that struct type.\n+        let impl_trait_self_ref: Option<ty::TraitRef<'tcx>> =\n+            self.tcx.impl_trait_ref(obligation.impl_def_id).map(|impl_def| impl_def.skip_binder());\n+\n+        let Some(impl_trait_self_ref) = impl_trait_self_ref else {\n+            // It is possible that this is absent. In this case, we make no progress.\n+            return Err(expr);\n+        };\n+\n+        // We only really care about the `Self` type itself, which we extract from the ref.\n+        let impl_self_ty: Ty<'tcx> = impl_trait_self_ref.self_ty();\n+\n+        let impl_predicates: ty::GenericPredicates<'tcx> =\n+            self.tcx.predicates_of(obligation.impl_def_id);\n+        let Some(impl_predicate_index) = obligation.impl_def_predicate_index else {\n+            // We don't have the index, so we can only guess.\n+            return Err(expr);\n+        };\n+\n+        if impl_predicate_index >= impl_predicates.predicates.len() {\n+            // This shouldn't happen, but since this is only a diagnostic improvement, avoid breaking things.\n+            return Err(expr);\n+        }\n+        let relevant_broken_predicate: ty::PredicateKind<'tcx> =\n+            impl_predicates.predicates[impl_predicate_index].0.kind().skip_binder();\n+\n+        match relevant_broken_predicate {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(broken_trait)) => {\n+                // ...\n+                self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                    broken_trait.trait_ref.self_ty().into(),\n+                    expr,\n+                    impl_self_ty.into(),\n+                )\n+            }\n+            _ => Err(expr),\n+        }\n+    }\n+\n+    /// Drills into `expr` to arrive at the equivalent location of `find_generic_param` in `in_ty`.\n+    /// For example, given\n+    /// - expr: `(Some(vec![1, 2, 3]), false)`\n+    /// - param: `T`\n+    /// - in_ty: `(Option<Vec<T>, bool)`\n+    /// we would drill until we arrive at `vec![1, 2, 3]`.\n+    ///\n+    /// If successful, we return `Ok(refined_expr)`. If unsuccesful, we return `Err(partially_refined_expr`),\n+    /// which will go as far as possible. For example, given `(foo(), false)` instead, we would drill to\n+    /// `foo()` and then return `Err(\"foo()\")`.\n+    ///\n+    /// This means that you can (and should) use the `?` try operator to chain multiple calls to this\n+    /// function with different types, since you can only continue drilling the second time if you\n+    /// succeeded the first time.\n+    fn blame_specific_part_of_expr_corresponding_to_generic_param(\n+        &self,\n+        param: ty::GenericArg<'tcx>,\n+        expr: &'tcx hir::Expr<'tcx>,\n+        in_ty: ty::GenericArg<'tcx>,\n+    ) -> Result<&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>> {\n+        if param == in_ty {\n+            // The types match exactly, so we have drilled as far as we can.\n+            return Ok(expr);\n+        }\n+\n+        let ty::GenericArgKind::Type(in_ty) = in_ty.unpack() else {\n+            return Err(expr);\n+        };\n+\n+        if let (hir::ExprKind::Tup(expr_elements), ty::Tuple(in_ty_elements)) =\n+            (&expr.kind, in_ty.kind())\n+        {\n+            if in_ty_elements.len() != expr_elements.len() {\n+                return Err(expr);\n+            }\n+            // Find out which of `in_ty_elements` refer to `param`.\n+            // FIXME: It may be better to take the first if there are multiple,\n+            // just so that the error points to a smaller expression.\n+            let Some((drill_expr, drill_ty)) = Self::is_iterator_singleton(expr_elements.iter().zip( in_ty_elements.iter()).filter(|(_expr_elem, in_ty_elem)| {\n+                Self::find_param_in_ty((*in_ty_elem).into(), param)\n+            })) else {\n+                // The param is not mentioned, or it is mentioned in multiple indexes.\n+                return Err(expr);\n+            };\n+\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                drill_expr,\n+                drill_ty.into(),\n+            );\n+        }\n+\n+        if let (\n+            hir::ExprKind::Struct(expr_struct_path, expr_struct_fields, _expr_struct_rest),\n+            ty::Adt(in_ty_adt, in_ty_adt_generic_args),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            // First, confirm that this struct is the same one as in the types, and if so,\n+            // find the right variant.\n+            let Res::Def(expr_struct_def_kind, expr_struct_def_id) = self.typeck_results.borrow().qpath_res(expr_struct_path, expr.hir_id) else {\n+                return Err(expr);\n+            };\n+\n+            let variant_def_id = match expr_struct_def_kind {\n+                hir::def::DefKind::Struct => {\n+                    if in_ty_adt.did() != expr_struct_def_id {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_struct_def_id\n+                }\n+                hir::def::DefKind::Variant => {\n+                    // If this is a variant, its parent is the type definition.\n+                    if in_ty_adt.did() != self.tcx.parent(expr_struct_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_struct_def_id\n+                }\n+                _ => {\n+                    return Err(expr);\n+                }\n+            };\n+\n+            // We need to know which of the generic parameters mentions our target param.\n+            // We expect that at least one of them does, since it is expected to be mentioned.\n+            let Some((drill_generic_index, generic_argument_type)) =\n+                Self::is_iterator_singleton(\n+                    in_ty_adt_generic_args.iter().enumerate().filter(\n+                        |(_index, in_ty_generic)| {\n+                            Self::find_param_in_ty(*in_ty_generic, param)\n+                        },\n+                    ),\n+                ) else {\n+                    return Err(expr);\n+                };\n+\n+            let struct_generic_parameters: &ty::Generics = self.tcx.generics_of(in_ty_adt.did());\n+            if drill_generic_index >= struct_generic_parameters.params.len() {\n+                return Err(expr);\n+            }\n+\n+            let param_to_point_at_in_struct = self.tcx.mk_param_from_def(\n+                struct_generic_parameters.param_at(drill_generic_index, self.tcx),\n+            );\n+\n+            // We make 3 steps:\n+            // Suppose we have a type like\n+            // ```ignore (just for demonstration)\n+            // struct ExampleStruct<T> {\n+            //   enabled: bool,\n+            //   item: Option<(usize, T, bool)>,\n+            // }\n+            //\n+            // f(ExampleStruct {\n+            //   enabled: false,\n+            //   item: Some((0, Box::new(String::new()), 1) }, true)),\n+            // });\n+            // ```\n+            // Here, `f` is passed a `ExampleStruct<Box<String>>`, but it wants\n+            // for `String: Copy`, which isn't true here.\n+            //\n+            // (1) First, we drill into `.item` and highlight that expression\n+            // (2) Then we use the template type `Option<(usize, T, bool)>` to\n+            //     drill into the `T`, arriving at a `Box<String>` expression.\n+            // (3) Then we keep going, drilling into this expression using our\n+            //     outer contextual information.\n+\n+            // (1) Find the (unique) field which mentions the type in our constraint:\n+            let (field_expr, field_type) = self\n+                .point_at_field_if_possible(\n+                    in_ty_adt.did(),\n+                    param_to_point_at_in_struct,\n+                    variant_def_id,\n+                    expr_struct_fields,\n+                )\n+                .ok_or(expr)?;\n+\n+            // (2) Continue drilling into the struct, ignoring the struct's\n+            // generic argument types.\n+            let expr = self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param_to_point_at_in_struct,\n+                field_expr,\n+                field_type.into(),\n+            )?;\n+\n+            // (3) Continue drilling into the expression, having \"passed\n+            // through\" the struct entirely.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                expr,\n+                generic_argument_type,\n+            );\n+        }\n+\n+        if let (\n+            hir::ExprKind::Call(expr_callee, expr_args),\n+            ty::Adt(in_ty_adt, in_ty_adt_generic_args),\n+        ) = (&expr.kind, in_ty.kind())\n+        {\n+            let hir::ExprKind::Path(expr_callee_path) = &expr_callee.kind else {\n+                // FIXME: This case overlaps with another one worth handling,\n+                // which should happen above since it applies to non-ADTs:\n+                // we can drill down into regular generic functions.\n+                return Err(expr);\n+            };\n+            // This is (possibly) a constructor call, like `Some(...)` or `MyStruct(a, b, c)`.\n+\n+            let Res::Def(expr_struct_def_kind, expr_ctor_def_id) = self.typeck_results.borrow().qpath_res(expr_callee_path, expr_callee.hir_id) else {\n+                return Err(expr);\n+            };\n+\n+            let variant_def_id = match expr_struct_def_kind {\n+                hir::def::DefKind::Ctor(hir::def::CtorOf::Struct, hir::def::CtorKind::Fn) => {\n+                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    self.tcx.parent(expr_ctor_def_id)\n+                }\n+                hir::def::DefKind::Ctor(hir::def::CtorOf::Variant, hir::def::CtorKind::Fn) => {\n+                    // If this is a variant, its parent is the type definition.\n+                    if in_ty_adt.did() != self.tcx.parent(expr_ctor_def_id) {\n+                        // FIXME: Deal with type aliases?\n+                        return Err(expr);\n+                    }\n+                    expr_ctor_def_id\n+                }\n+                _ => {\n+                    return Err(expr);\n+                }\n+            };\n+\n+            // We need to know which of the generic parameters mentions our target param.\n+            // We expect that at least one of them does, since it is expected to be mentioned.\n+            let Some((drill_generic_index, generic_argument_type)) =\n+                Self::is_iterator_singleton(\n+                    in_ty_adt_generic_args.iter().enumerate().filter(\n+                        |(_index, in_ty_generic)| {\n+                            Self::find_param_in_ty(*in_ty_generic, param)\n+                        },\n+                    ),\n+                ) else {\n+                    return Err(expr);\n+                };\n+\n+            let struct_generic_parameters: &ty::Generics = self.tcx.generics_of(in_ty_adt.did());\n+            if drill_generic_index >= struct_generic_parameters.params.len() {\n+                return Err(expr);\n+            }\n+\n+            let param_to_point_at_in_struct = self.tcx.mk_param_from_def(\n+                struct_generic_parameters.param_at(drill_generic_index, self.tcx),\n+            );\n+\n+            // We make 3 steps:\n+            // Suppose we have a type like\n+            // ```ignore (just for demonstration)\n+            // struct ExampleStruct<T> {\n+            //   enabled: bool,\n+            //   item: Option<(usize, T, bool)>,\n+            // }\n+            //\n+            // f(ExampleStruct {\n+            //   enabled: false,\n+            //   item: Some((0, Box::new(String::new()), 1) }, true)),\n+            // });\n+            // ```\n+            // Here, `f` is passed a `ExampleStruct<Box<String>>`, but it wants\n+            // for `String: Copy`, which isn't true here.\n+            //\n+            // (1) First, we drill into `.item` and highlight that expression\n+            // (2) Then we use the template type `Option<(usize, T, bool)>` to\n+            //     drill into the `T`, arriving at a `Box<String>` expression.\n+            // (3) Then we keep going, drilling into this expression using our\n+            //     outer contextual information.\n+\n+            // (1) Find the (unique) field index which mentions the type in our constraint:\n+            let Some((field_index, field_type)) = Self::is_iterator_singleton(\n+                in_ty_adt\n+                    .variant_with_id(variant_def_id)\n+                    .fields\n+                    .iter()\n+                    .map(|field| field.ty(self.tcx, *in_ty_adt_generic_args))\n+                    .enumerate()\n+                    .filter(|(_index, field_type)| Self::find_param_in_ty((*field_type).into(), param))\n+            ) else {\n+                return Err(expr);\n+            };\n+\n+            if field_index >= expr_args.len() {\n+                return Err(expr);\n+            }\n+\n+            // (2) Continue drilling into the struct, ignoring the struct's\n+            // generic argument types.\n+            let expr = self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param_to_point_at_in_struct,\n+                &expr_args[field_index],\n+                field_type.into(),\n+            )?;\n+\n+            // (3) Continue drilling into the expression, having \"passed\n+            // through\" the struct entirely.\n+            return self.blame_specific_part_of_expr_corresponding_to_generic_param(\n+                param,\n+                expr,\n+                generic_argument_type,\n+            );\n+        }\n+\n+        // At this point, none of the basic patterns matched.\n+        // One major possibility which remains is that we have a function call.\n+        // In this case, it's often possible to dive deeper into the call to find something to blame,\n+        // but this is not always possible.\n+\n+        Err(expr)\n+    }\n+\n+    // FIXME: This can be made into a private, non-impl function later.\n+    /// Traverses the given ty (either a `ty::Ty` or a `ty::GenericArg`) and searches for references\n+    /// to the given `param_to_point_at`. Returns `true` if it finds any use of the param.\n+    pub fn find_param_in_ty(\n+        ty: ty::GenericArg<'tcx>,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+    ) -> bool {\n+        let mut walk = ty.walk();\n+        while let Some(arg) = walk.next() {\n+            if arg == param_to_point_at {\n+            return true;\n+        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+            && let ty::Alias(ty::Projection, ..) = ty.kind()\n+        {\n+            // This logic may seem a bit strange, but typically when\n+            // we have a projection type in a function signature, the\n+            // argument that's being passed into that signature is\n+            // not actually constraining that projection's substs in\n+            // a meaningful way. So we skip it, and see improvements\n+            // in some UI tests.\n+            walk.skip_current_subtree();\n+        }\n+        }\n+        false\n+    }\n+\n+    // FIXME: This can be made into a private, non-impl function later.\n+    /// Returns `Some(iterator.next())` if it has exactly one item, and `None` otherwise.\n+    pub fn is_iterator_singleton<T>(mut iterator: impl Iterator<Item = T>) -> Option<T> {\n+        match (iterator.next(), iterator.next()) {\n+            (_, Some(_)) => None,\n+            (first, _) => first,\n+        }\n+    }\n+}"}, {"sha": "1055ee953eae6f554036ddd90007e0813e7f312a", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -34,9 +34,10 @@ use rustc_trait_selection::traits::{self, ObligationCauseCode, SelectionContext}\n \n use std::iter;\n use std::mem;\n-use std::ops::ControlFlow;\n use std::slice;\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&mut self) {\n         // don't hold the borrow to deferred_cast_checks while checking to avoid borrow checker errors\n@@ -1843,7 +1844,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .into_iter()\n                         .flatten()\n                     {\n-                        if self.point_at_arg_if_possible(\n+                        if self.blame_specific_arg_if_possible(\n                                 error,\n                                 def_id,\n                                 param,\n@@ -1873,7 +1874,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     .into_iter()\n                     .flatten()\n                 {\n-                    if self.point_at_arg_if_possible(\n+                    if self.blame_specific_arg_if_possible(\n                         error,\n                         def_id,\n                         param,\n@@ -1898,16 +1899,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     for param in\n                         [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n                     {\n-                        if let Some(param) = param\n-                            && self.point_at_field_if_possible(\n-                                error,\n+                        if let Some(param) = param {\n+                            let refined_expr = self.point_at_field_if_possible(\n                                 def_id,\n                                 param,\n                                 variant_def_id,\n                                 fields,\n-                            )\n-                        {\n-                            return true;\n+                            );\n+\n+                            match refined_expr {\n+                                None => {}\n+                                Some((refined_expr, _)) => {\n+                                    error.obligation.cause.span = refined_expr\n+                                        .span\n+                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+                                        .unwrap_or(refined_expr.span);\n+                                    return true;\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -1940,7 +1949,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn point_at_arg_if_possible(\n+    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n+    /// looking for the most-specific-possible span to blame.\n+    ///\n+    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n+    /// expression mentioned.\n+    ///\n+    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n+    /// the provided function call expression, and mark it as responsible for the fullfillment\n+    /// error.\n+    fn blame_specific_arg_if_possible(\n         &self,\n         error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n@@ -1959,13 +1977,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .inputs()\n             .iter()\n             .enumerate()\n-            .filter(|(_, ty)| find_param_in_ty(**ty, param_to_point_at))\n+            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n             .collect();\n         // If there's one field that references the given generic, great!\n         if let [(idx, _)] = args_referencing_param.as_slice()\n             && let Some(arg) = receiver\n                 .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n+\n             error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n+\n+            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n+                // This is more specific than pointing at the entire argument.\n+                self.blame_specific_expr_if_possible(error, arg_expr)\n+            }\n+\n             error.obligation.cause.map_code(|parent_code| {\n                 ObligationCauseCode::FunctionArgumentObligation {\n                     arg_hir_id: arg.hir_id,\n@@ -1983,14 +2008,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn point_at_field_if_possible(\n+    // FIXME: Make this private and move to mod adjust_fulfillment_errors\n+    pub fn point_at_field_if_possible(\n         &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n         def_id: DefId,\n         param_to_point_at: ty::GenericArg<'tcx>,\n         variant_def_id: DefId,\n         expr_fields: &[hir::ExprField<'tcx>],\n-    ) -> bool {\n+    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n         let def = self.tcx.adt_def(def_id);\n \n         let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n@@ -2000,7 +2025,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .iter()\n             .filter(|field| {\n                 let field_ty = field.ty(self.tcx, identity_substs);\n-                find_param_in_ty(field_ty, param_to_point_at)\n+                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n             })\n             .collect();\n \n@@ -2010,17 +2035,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // same rules that check_expr_struct uses for macro hygiene.\n                 if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n                 {\n-                    error.obligation.cause.span = expr_field\n-                        .expr\n-                        .span\n-                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-                        .unwrap_or(expr_field.span);\n-                    return true;\n+                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n                 }\n             }\n         }\n \n-        false\n+        None\n     }\n \n     fn point_at_path_if_possible(\n@@ -2240,23 +2260,3 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n-\n-fn find_param_in_ty<'tcx>(ty: Ty<'tcx>, param_to_point_at: ty::GenericArg<'tcx>) -> bool {\n-    let mut walk = ty.walk();\n-    while let Some(arg) = walk.next() {\n-        if arg == param_to_point_at {\n-            return true;\n-        } else if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-            && let ty::Alias(ty::Projection, ..) = ty.kind()\n-        {\n-            // This logic may seem a bit strange, but typically when\n-            // we have a projection type in a function signature, the\n-            // argument that's being passed into that signature is\n-            // not actually constraining that projection's substs in\n-            // a meaningful way. So we skip it, and see improvements\n-            // in some UI tests.\n-            walk.skip_current_subtree();\n-        }\n-    }\n-    false\n-}"}, {"sha": "1e14eddd4c86ef511732e116a9dfeafe69b2ba8e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -1,4 +1,5 @@\n mod _impl;\n+mod adjust_fulfillment_errors;\n mod arg_matrix;\n mod checks;\n mod suggestions;"}, {"sha": "9ab29a6778fc91eceb2a99bd4ae9f9cbba5683ca", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -1563,6 +1563,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                                     traits::ImplDerivedObligationCause {\n                                         derived,\n                                         impl_def_id,\n+                                        impl_def_predicate_index: None,\n                                         span,\n                                     },\n                                 ))"}, {"sha": "18a966449aa72f2e9432ab3c833d8bdc1ba22bae", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -145,30 +145,32 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n-                let obligations = predicates.predicates.iter().map(|&(mut pred, span)| {\n-                    // when parent predicate is non-const, elaborate it to non-const predicates.\n-                    if data.constness == ty::BoundConstness::NotConst {\n-                        pred = pred.without_const(tcx);\n-                    }\n-\n-                    let cause = obligation.cause.clone().derived_cause(\n-                        bound_predicate.rebind(data),\n-                        |derived| {\n-                            traits::ImplDerivedObligation(Box::new(\n-                                traits::ImplDerivedObligationCause {\n-                                    derived,\n-                                    impl_def_id: data.def_id(),\n-                                    span,\n-                                },\n-                            ))\n-                        },\n-                    );\n-                    predicate_obligation(\n-                        pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n-                        obligation.param_env,\n-                        cause,\n-                    )\n-                });\n+                let obligations =\n+                    predicates.predicates.iter().enumerate().map(|(index, &(mut pred, span))| {\n+                        // when parent predicate is non-const, elaborate it to non-const predicates.\n+                        if data.constness == ty::BoundConstness::NotConst {\n+                            pred = pred.without_const(tcx);\n+                        }\n+\n+                        let cause = obligation.cause.clone().derived_cause(\n+                            bound_predicate.rebind(data),\n+                            |derived| {\n+                                traits::ImplDerivedObligation(Box::new(\n+                                    traits::ImplDerivedObligationCause {\n+                                        derived,\n+                                        impl_def_id: data.def_id(),\n+                                        impl_def_predicate_index: Some(index),\n+                                        span,\n+                                    },\n+                                ))\n+                            },\n+                        );\n+                        predicate_obligation(\n+                            pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n+                            obligation.param_env,\n+                            cause,\n+                        )\n+                    });\n                 debug!(?data, ?obligations, \"super_predicates\");\n \n                 // Only keep those bounds that we haven't already seen."}, {"sha": "c528929e7561dacb8572e7185a1d2dd3a6bacb5d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -475,6 +475,8 @@ pub enum WellFormedLoc {\n pub struct ImplDerivedObligationCause<'tcx> {\n     pub derived: DerivedObligationCause<'tcx>,\n     pub impl_def_id: DefId,\n+    /// The index of the derived predicate in the parent impl's predicates.\n+    pub impl_def_predicate_index: Option<usize>,\n     pub span: Span,\n }\n "}, {"sha": "94d9eb8f587a70ebbd9383cccdab5c516cdbca04", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -1190,6 +1190,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n                     impl_def_id,\n+                    impl_def_predicate_index: None,\n                     span: obligation.cause.span,\n                 }))\n             });"}, {"sha": "0c6b2406bbdafb0cd0e547a405e72cc988e9a494", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -2608,11 +2608,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         assert_eq!(predicates.parent, None);\n         let predicates = predicates.instantiate_own(tcx, substs);\n         let mut obligations = Vec::with_capacity(predicates.len());\n-        for (predicate, span) in predicates {\n+        for (index, (predicate, span)) in predicates.into_iter().enumerate() {\n             let cause = cause.clone().derived_cause(parent_trait_pred, |derived| {\n                 ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n                     derived,\n                     impl_def_id: def_id,\n+                    impl_def_predicate_index: Some(index),\n                     span,\n                 }))\n             });"}, {"sha": "c0c2215c04adb44d520aa84fe983587948d661a0", "filename": "tests/ui/derives/deriving-copyclone.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Fderives%2Fderiving-copyclone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Fderives%2Fderiving-copyclone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fderives%2Fderiving-copyclone.stderr?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `B<C>: Copy` is not satisfied\n-  --> $DIR/deriving-copyclone.rs:31:13\n+  --> $DIR/deriving-copyclone.rs:31:26\n    |\n LL |     is_copy(B { a: 1, b: C });\n-   |     ------- ^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `B<C>`\n+   |     -------              ^ the trait `Copy` is not implemented for `B<C>`\n    |     |\n    |     required by a bound introduced by this call\n    |\n@@ -19,14 +19,14 @@ LL | fn is_copy<T: Copy>(_: T) {}\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider borrowing here\n    |\n-LL |     is_copy(&B { a: 1, b: C });\n-   |             +\n+LL |     is_copy(B { a: 1, b: &C });\n+   |                          +\n \n error[E0277]: the trait bound `B<C>: Clone` is not satisfied\n-  --> $DIR/deriving-copyclone.rs:32:14\n+  --> $DIR/deriving-copyclone.rs:32:27\n    |\n LL |     is_clone(B { a: 1, b: C });\n-   |     -------- ^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `B<C>`\n+   |     --------              ^ the trait `Clone` is not implemented for `B<C>`\n    |     |\n    |     required by a bound introduced by this call\n    |\n@@ -43,14 +43,14 @@ LL | fn is_clone<T: Clone>(_: T) {}\n    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider borrowing here\n    |\n-LL |     is_clone(&B { a: 1, b: C });\n-   |              +\n+LL |     is_clone(B { a: 1, b: &C });\n+   |                           +\n \n error[E0277]: the trait bound `B<D>: Copy` is not satisfied\n-  --> $DIR/deriving-copyclone.rs:35:13\n+  --> $DIR/deriving-copyclone.rs:35:26\n    |\n LL |     is_copy(B { a: 1, b: D });\n-   |     ------- ^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `B<D>`\n+   |     -------              ^ the trait `Copy` is not implemented for `B<D>`\n    |     |\n    |     required by a bound introduced by this call\n    |\n@@ -67,8 +67,8 @@ LL | fn is_copy<T: Copy>(_: T) {}\n    = note: this error originates in the derive macro `Copy` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider borrowing here\n    |\n-LL |     is_copy(&B { a: 1, b: D });\n-   |             +\n+LL |     is_copy(B { a: 1, b: &D });\n+   |                          +\n \n error: aborting due to 3 previous errors\n "}, {"sha": "5134c672f5f4ed70c5e53e73b0aa28bb32ec4681", "filename": "tests/ui/errors/trait-bound-error-spans/blame-trait-error.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -0,0 +1,28 @@\n+trait T1 {}\n+trait T2 {}\n+trait T3 {}\n+trait T4 {}\n+\n+impl<B: T2> T1 for Wrapper<B> {}\n+\n+impl T2 for i32 {}\n+impl T3 for i32 {}\n+\n+impl<A: T3> T2 for Burrito<A> {}\n+\n+struct Wrapper<W> {\n+    value: W,\n+}\n+\n+struct Burrito<F> {\n+    filling: F,\n+}\n+\n+fn want<V: T1>(_x: V) {}\n+\n+fn example<Q>(q: Q) {\n+    want(Wrapper { value: Burrito { filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+}\n+\n+fn main() {}"}, {"sha": "27b002db1306a5a4c44a79a49fbd145d50bd892e", "filename": "tests/ui/errors/trait-bound-error-spans/blame-trait-error.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftrait-bound-error-spans%2Fblame-trait-error.stderr?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -0,0 +1,35 @@\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error.rs:24:46\n+   |\n+LL |     want(Wrapper { value: Burrito { filling: q } });\n+   |     ----                                     ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Burrito<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error.rs:11:13\n+   |\n+LL | impl<A: T3> T2 for Burrito<A> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<Burrito<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error.rs:6:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error.rs:21:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "2b75f43241289f1c41a70f5626f7113f6dfb327a", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.rs?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -0,0 +1,131 @@\n+// This test examines the error spans reported when a generic `impl` fails.\n+// For example, if a function wants an `Option<T>` where `T: Copy` but you pass `Some(vec![1, 2])`,\n+// then we want to point at the `vec![1, 2]` and not the `Some( ... )` expression.\n+\n+trait T1 {}\n+trait T2 {}\n+trait T3 {}\n+trait T4 {}\n+\n+impl T2 for i32 {}\n+impl T3 for i32 {}\n+\n+struct Wrapper<W> {\n+    value: W,\n+}\n+impl<B: T2> T1 for Wrapper<B> {}\n+\n+struct Burrito<F> {\n+    spicy: bool,\n+    filling: F,\n+}\n+impl<A: T3> T2 for Burrito<A> {}\n+\n+struct BurritoTuple<F>(F);\n+impl<C: T3> T2 for BurritoTuple<C> {}\n+\n+enum BurritoKinds<G> {\n+    SmallBurrito { spicy: bool, small_filling: G },\n+    LargeBurrito { spicy: bool, large_filling: G },\n+    MultiBurrito { first_filling: G, second_filling: G },\n+}\n+impl<D: T3> T2 for BurritoKinds<D> {}\n+\n+struct Taco<H>(bool, H);\n+impl<E: T3> T2 for Taco<E> {}\n+\n+enum TacoKinds<H> {\n+    OneTaco(bool, H),\n+    TwoTacos(bool, H, H),\n+}\n+impl<F: T3> T2 for TacoKinds<F> {}\n+\n+struct GenericBurrito<Spiciness, Filling> {\n+    spiciness: Spiciness,\n+    filling: Filling,\n+}\n+impl<X, Y: T3> T2 for GenericBurrito<X, Y> {}\n+struct NotSpicy;\n+\n+impl<A: T3, B: T3> T2 for (A, B) {}\n+impl<A: T2, B: T2> T1 for (A, B) {}\n+\n+fn want<V: T1>(_x: V) {}\n+\n+// Some more-complex examples:\n+type AliasBurrito<T> = GenericBurrito<T, T>;\n+\n+// The following example is fairly confusing. The idea is that we want to \"misdirect\" the location\n+// of the error.\n+\n+struct Two<A, B> {\n+    a: A,\n+    b: B,\n+}\n+\n+impl<X, Y: T1, Z> T1 for Two<Two<X, Y>, Z> {}\n+\n+struct DoubleWrapper<T> {\n+    item: Wrapper<T>,\n+}\n+\n+impl<T: T1> T1 for DoubleWrapper<T> {}\n+\n+fn example<Q>(q: Q) {\n+    // In each of the following examples, we expect the error span to point at the 'q' variable,\n+    // since the missing constraint is `Q: T3`.\n+\n+    // Verifies for struct:\n+    want(Wrapper { value: Burrito { spicy: false, filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for enum with named fields in variant:\n+    want(Wrapper { value: BurritoKinds::SmallBurrito { spicy: true, small_filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for tuple struct:\n+    want(Wrapper { value: Taco(false, q) });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for tuple enum variant:\n+    want(Wrapper { value: TacoKinds::OneTaco(false, q) });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for generic type with multiple parameters:\n+    want(Wrapper { value: GenericBurrito { spiciness: NotSpicy, filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for tuple:\n+    want((3, q));\n+    //~^ ERROR the trait bound `Q: T2` is not satisfied [E0277]\n+\n+    // Verifies for nested tuple:\n+    want(Wrapper { value: (3, q) });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    // Verifies for nested tuple:\n+    want(((3, q), 5));\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    want(DoubleWrapper { item: Wrapper { value: q } });\n+    //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+\n+    want(DoubleWrapper { item: Wrapper { value: DoubleWrapper { item: Wrapper { value: q } } } });\n+    //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+\n+    // Verifies for type alias to struct:\n+    want(Wrapper { value: AliasBurrito { spiciness: q, filling: q } });\n+    //~^ ERROR the trait bound `Q: T3` is not satisfied [E0277]\n+\n+    want(Two { a: Two { a: (), b: q }, b: () });\n+    //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+\n+    // We *should* blame the 'q'.\n+    // FIXME: Right now, the wrong field is blamed.\n+    want(\n+        Two { a: Two { a: (), b: Two { a: Two { a: (), b: q }, b: () } }, b: () },\n+        //~^ ERROR the trait bound `Q: T1` is not satisfied [E0277]\n+    );\n+}\n+\n+fn main() {}"}, {"sha": "5f87c670d8acd7ef3df6dc900d77bc1aff9e322b", "filename": "tests/ui/errors/traits/blame-trait-error-spans-on-exprs.stderr", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ferrors%2Ftraits%2Fblame-trait-error-spans-on-exprs.stderr?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -0,0 +1,380 @@\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:79:60\n+   |\n+LL |     want(Wrapper { value: Burrito { spicy: false, filling: q } });\n+   |     ---- required by a bound introduced by this call       ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `Burrito<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:22:13\n+   |\n+LL | impl<A: T3> T2 for Burrito<A> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<Burrito<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:83:84\n+   |\n+LL |     want(Wrapper { value: BurritoKinds::SmallBurrito { spicy: true, small_filling: q } });\n+   |     ---- required by a bound introduced by this call                               ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `BurritoKinds<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:32:13\n+   |\n+LL | impl<D: T3> T2 for BurritoKinds<D> {}\n+   |         --  ^^     ^^^^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<BurritoKinds<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:87:39\n+   |\n+LL |     want(Wrapper { value: Taco(false, q) });\n+   |     ----                              ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Taco<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:35:13\n+   |\n+LL | impl<E: T3> T2 for Taco<E> {}\n+   |         --  ^^     ^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<Taco<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:91:27\n+   |\n+LL |     want(Wrapper { value: TacoKinds::OneTaco(false, q) });\n+   |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `TacoKinds<Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:41:13\n+   |\n+LL | impl<F: T3> T2 for TacoKinds<F> {}\n+   |         --  ^^     ^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required for `Wrapper<TacoKinds<Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:95:74\n+   |\n+LL |     want(Wrapper { value: GenericBurrito { spiciness: NotSpicy, filling: q } });\n+   |     ---- required by a bound introduced by this call                     ^ the trait `T3` is not implemented for `Q`\n+   |\n+note: required for `GenericBurrito<NotSpicy, Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:47:16\n+   |\n+LL | impl<X, Y: T3> T2 for GenericBurrito<X, Y> {}\n+   |            --  ^^     ^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+note: required for `Wrapper<GenericBurrito<NotSpicy, Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T2` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:99:14\n+   |\n+LL |     want((3, q));\n+   |     ----     ^ the trait `T2` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `(i32, Q)` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:51:20\n+   |\n+LL | impl<A: T2, B: T2> T1 for (A, B) {}\n+   |                --  ^^     ^^^^^^\n+   |                |\n+   |                unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T2>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:103:31\n+   |\n+LL |     want(Wrapper { value: (3, q) });\n+   |     ----                      ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `(i32, Q)` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:50:20\n+   |\n+LL | impl<A: T3, B: T3> T2 for (A, B) {}\n+   |                --  ^^     ^^^^^^\n+   |                |\n+   |                unsatisfied trait bound introduced here\n+note: required for `Wrapper<(i32, Q)>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:107:15\n+   |\n+LL |     want(((3, q), 5));\n+   |     ----      ^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `(i32, Q)` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:50:20\n+   |\n+LL | impl<A: T3, B: T3> T2 for (A, B) {}\n+   |                --  ^^     ^^^^^^\n+   |                |\n+   |                unsatisfied trait bound introduced here\n+note: required for `((i32, Q), i32)` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:51:20\n+   |\n+LL | impl<A: T2, B: T2> T1 for (A, B) {}\n+   |         --         ^^     ^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:110:49\n+   |\n+LL |     want(DoubleWrapper { item: Wrapper { value: q } });\n+   |     ----                                        ^ the trait `T1` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `DoubleWrapper<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:72:13\n+   |\n+LL | impl<T: T1> T1 for DoubleWrapper<T> {}\n+   |         --  ^^     ^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:113:88\n+   |\n+LL |     want(DoubleWrapper { item: Wrapper { value: DoubleWrapper { item: Wrapper { value: q } } } });\n+   |     ---- required by a bound introduced by this call                                   ^ the trait `T1` is not implemented for `Q`\n+   |\n+note: required for `DoubleWrapper<Q>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:72:13\n+   |\n+LL | impl<T: T1> T1 for DoubleWrapper<T> {}\n+   |         --  ^^     ^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `DoubleWrapper<DoubleWrapper<Q>>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T3` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:117:27\n+   |\n+LL |     want(Wrapper { value: AliasBurrito { spiciness: q, filling: q } });\n+   |     ----                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `T3` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `GenericBurrito<Q, Q>` to implement `T2`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:47:16\n+   |\n+LL | impl<X, Y: T3> T2 for GenericBurrito<X, Y> {}\n+   |            --  ^^     ^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+note: required for `Wrapper<GenericBurrito<Q, Q>>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:16:13\n+   |\n+LL | impl<B: T2> T1 for Wrapper<B> {}\n+   |         --  ^^     ^^^^^^^^^^\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T3>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:120:35\n+   |\n+LL |     want(Two { a: Two { a: (), b: q }, b: () });\n+   |     ----                          ^ the trait `T1` is not implemented for `Q`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required for `Two<Two<(), Q>, ()>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:66:19\n+   |\n+LL | impl<X, Y: T1, Z> T1 for Two<Two<X, Y>, Z> {}\n+   |            --     ^^     ^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error[E0277]: the trait bound `Q: T1` is not satisfied\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:126:59\n+   |\n+LL |     want(\n+   |     ---- required by a bound introduced by this call\n+LL |         Two { a: Two { a: (), b: Two { a: Two { a: (), b: q }, b: () } }, b: () },\n+   |                                                           ^ the trait `T1` is not implemented for `Q`\n+   |\n+note: required for `Two<Two<(), Q>, ()>` to implement `T1`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:66:19\n+   |\n+LL | impl<X, Y: T1, Z> T1 for Two<Two<X, Y>, Z> {}\n+   |            --     ^^     ^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            unsatisfied trait bound introduced here\n+   = note: 1 redundant requirement hidden\n+   = note: required for `Two<Two<(), Two<Two<(), Q>, ()>>, ()>` to implement `T1`\n+note: required by a bound in `want`\n+  --> $DIR/blame-trait-error-spans-on-exprs.rs:53:12\n+   |\n+LL | fn want<V: T1>(_x: V) {}\n+   |            ^^ required by this bound in `want`\n+help: consider restricting type parameter `Q`\n+   |\n+LL | fn example<Q: T1>(q: Q) {\n+   |             ++++\n+\n+error: aborting due to 13 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "b680ce7f99013d67848469be9943f8771331ee39", "filename": "tests/ui/traits/negative-impls/negated-auto-traits-error.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ftraits%2Fnegative-impls%2Fnegated-auto-traits-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/800221b5b8f52c59e12e9aae282288c60c87285c/tests%2Fui%2Ftraits%2Fnegative-impls%2Fnegated-auto-traits-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnegative-impls%2Fnegated-auto-traits-error.stderr?ref=800221b5b8f52c59e12e9aae282288c60c87285c", "patch": "@@ -101,10 +101,10 @@ LL | fn is_send<T: Send>(_: T) {}\n    |               ^^^^ required by this bound in `is_send`\n \n error[E0277]: `main::TestType` cannot be sent between threads safely\n-  --> $DIR/negated-auto-traits-error.rs:66:13\n+  --> $DIR/negated-auto-traits-error.rs:66:20\n    |\n LL |     is_sync(Outer2(TestType));\n-   |     ------- ^^^^^^^^^^^^^^^^ `main::TestType` cannot be sent between threads safely\n+   |     -------        ^^^^^^^^ `main::TestType` cannot be sent between threads safely\n    |     |\n    |     required by a bound introduced by this call\n    |"}]}