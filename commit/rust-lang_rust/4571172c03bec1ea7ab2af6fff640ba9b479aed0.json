{"sha": "4571172c03bec1ea7ab2af6fff640ba9b479aed0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NzExNzJjMDNiZWMxZWE3YWIyYWY2ZmZmNjQwYmE5YjQ3OWFlZDA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-08T19:23:44Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-06-08T19:24:05Z"}, "message": "rustc: Remove pushdown. 15 second improvement.", "tree": {"sha": "5d9412f755ddf1df92c6ed81062eeb3ec5b40827", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d9412f755ddf1df92c6ed81062eeb3ec5b40827"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4571172c03bec1ea7ab2af6fff640ba9b479aed0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4571172c03bec1ea7ab2af6fff640ba9b479aed0", "html_url": "https://github.com/rust-lang/rust/commit/4571172c03bec1ea7ab2af6fff640ba9b479aed0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4571172c03bec1ea7ab2af6fff640ba9b479aed0/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f54f2799c33729f124332d69deb7205237a0f018", "url": "https://api.github.com/repos/rust-lang/rust/commits/f54f2799c33729f124332d69deb7205237a0f018", "html_url": "https://github.com/rust-lang/rust/commit/f54f2799c33729f124332d69deb7205237a0f018"}], "stats": {"total": 473, "additions": 30, "deletions": 443}, "files": [{"sha": "97c2157b20ac108a0ae475f724ef944db205ee6b", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4571172c03bec1ea7ab2af6fff640ba9b479aed0/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4571172c03bec1ea7ab2af6fff640ba9b479aed0/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=4571172c03bec1ea7ab2af6fff640ba9b479aed0", "patch": "@@ -2574,9 +2574,11 @@ mod unify {\n \n     fn resolve_type_var(&ty_ctxt tcx, &@var_bindings vb, int vid)\n             -> fixup_result {\n+        if ((vid as uint) >= ufind::set_count(vb.sets)) { ret fix_err(vid); }\n+\n         auto root_id = ufind::find(vb.sets, vid as uint);\n         alt (smallintmap::find[t](vb.types, root_id)) {\n-            case (none[t]) { ret fix_ok(mk_var(tcx, vid)); }\n+            case (none[t]) { ret fix_err(vid); }\n             case (some[t](?rt)) { ret fixup_vars(tcx, vb, rt); }\n         }\n     }"}, {"sha": "276c08f3094697354ed61e458ff905ab0b9a46af", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 27, "deletions": 442, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/4571172c03bec1ea7ab2af6fff640ba9b479aed0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4571172c03bec1ea7ab2af6fff640ba9b479aed0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=4571172c03bec1ea7ab2af6fff640ba9b479aed0", "patch": "@@ -978,381 +978,6 @@ fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n }\n \n \n-// The \"push-down\" phase, which takes a typed grammar production and pushes\n-// its type down into its constituent parts.\n-//\n-// For example, consider \"auto x; x = 352;\". check_expr() doesn't know the\n-// type of \"x\" at the time it sees it, so that function will simply store a\n-// type variable for the type of \"x\". However, after checking the entire\n-// assignment expression, check_expr() will assign the type of int to the\n-// expression \"x = 352\" as a whole. In this case, then, the job of these\n-// functions is to clean up by assigning the type of int to both sides of the\n-// assignment expression.\n-//\n-// TODO: We only need to do this once per statement: check_expr() bubbles the\n-// types up, and pushdown_expr() pushes the types down. However, in many cases\n-// we're more eager than we need to be, calling pushdown_expr() and friends\n-// directly inside check_expr(). This results in a quadratic algorithm.\n-\n-mod pushdown {\n-    // Push-down over typed expressions. Note that the expression that you\n-    // pass to this function must have been passed to check_expr() first.\n-    //\n-    // TODO: enforce this via a predicate.\n-    // TODO: This function is incomplete.\n-\n-    fn pushdown_expr(&@fn_ctxt fcx, &ty::t expected, &@ast::expr e) {\n-        be pushdown_expr_full(fcx, expected, e, NO_AUTODEREF);\n-    }\n-\n-    fn pushdown_expr_full(&@fn_ctxt fcx, &ty::t expected, &@ast::expr e,\n-                          autoderef_kind adk) {\n-        alt (e.node) {\n-            case (ast::expr_vec(?es_0, ?mut, ?ann)) {\n-                // TODO: enforce mutability\n-\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                alt (struct(fcx.ccx.tcx, t)) {\n-                    case (ty::ty_vec(?mt)) {\n-                        for (@ast::expr e_0 in es_0) {\n-                            pushdown_expr(fcx, mt.ty, e_0);\n-                        }\n-                    }\n-                    case (_) {\n-                        log_err \"vec expr doesn't have a vec type!\";\n-                        fail;\n-                    }\n-                }\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_tup(?es_0, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                alt (struct(fcx.ccx.tcx, t)) {\n-                    case (ty::ty_tup(?mts)) {\n-                        auto i = 0u;\n-                        for (ast::elt elt_0 in es_0) {\n-                            pushdown_expr(fcx, mts.(i).ty, elt_0.expr);\n-                            i += 1u;\n-                        }\n-                    }\n-                    case (_) {\n-                        log_err \"tup expr doesn't have a tup type!\";\n-                        fail;\n-                    }\n-                }\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_rec(?fields_0, ?base_0, ?ann)) {\n-\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                alt (struct(fcx.ccx.tcx, t)) {\n-                    case (ty::ty_rec(?field_mts)) {\n-                        alt (base_0) {\n-                            case (none) {\n-                                auto i = 0u;\n-                                for (ast::field field_0 in fields_0) {\n-                                    assert (str::eq(field_0.node.ident,\n-                                                    field_mts.(i).ident));\n-                                    pushdown_expr(fcx,\n-                                                  field_mts.(i).mt.ty,\n-                                                  field_0.node.expr);\n-                                    i += 1u;\n-                                }\n-                            }\n-                            case (some(?bx)) {\n-\n-                                let vec[field] base_fields = [];\n-\n-                                for (ast::field field_0 in fields_0) {\n-\n-                                    for (ty::field ft in field_mts) {\n-                                        if (str::eq(field_0.node.ident,\n-                                                    ft.ident)) {\n-                                            pushdown_expr(fcx, ft.mt.ty,\n-                                                          field_0.node.expr);\n-                                        }\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                    case (_) {\n-                        log_err \"rec expr doesn't have a rec type!\";\n-                        fail;\n-                    }\n-                }\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_bind(?sube, ?es, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_call(?sube, ?es, ?ann)) {\n-                // NB: we call 'demand::autoderef' and pass in adk only in\n-                // cases where e is an expression that could *possibly*\n-                // produce a box; things like expr_binary or expr_bind can't,\n-                // so there's no need.\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_self_method(?id, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_unary(?uop, ?sube, ?ann)) {\n-                // See note in expr_unary for why we're calling\n-                // demand::autoderef.\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-\n-                /* The following is a bit special-cased, but takes care of\n-                   the case where we say let @vec[whatever] v = @[]; */\n-                auto inner_ty = t;\n-                alt (uop) {\n-                    case (ast::box(?mut)) {\n-                        alt (struct(fcx.ccx.tcx, t)) {\n-                            case (ty::ty_box(?inner)) { inner_ty = inner.ty; }\n-                            case (_) { \n-                                fcx.ccx.tcx.sess.span_err(e.span,\n-                                    \"Expecting an application of box \" +\n-                                    \"to have a box type; it had type \" +\n-                                    ty::ty_to_str(fcx.ccx.tcx, t));\n-                            }\n-                        }\n-                    }\n-                    case (ast::deref) {\n-                        inner_ty = ty::mk_box(fcx.ccx.tcx,\n-                        // maybe_mut should work because it'll unify with\n-                        // the existing type?\n-                                   rec(ty=t, mut=ast::maybe_mut));\n-                    }\n-                    case (_) { inner_ty = strip_boxes(fcx.ccx.tcx, t); }\n-                }\n-\n-                pushdown_expr(fcx, inner_ty, sube);\n-            }\n-            case (ast::expr_lit(?lit, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_cast(?sube, ?ast_ty, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-\n-                auto then_t = ty::block_ty(fcx.ccx.tcx, then_0);\n-                pushdown_block(fcx, expected, then_0);\n-\n-                alt (else_0) {\n-                    case (none) { /* no-op */ }\n-                    case (some(?e_0)) {\n-                        auto else_t = ty::expr_ty(fcx.ccx.tcx, e_0);\n-                        pushdown_expr(fcx, expected, e_0);\n-                    }\n-                }\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_for(?decl, ?seq, ?bloc, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_while(?cond, ?bloc, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_do_while(?bloc, ?cond, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_block(?bloc, ?ann)) {\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-                pushdown_block(fcx, t, bloc);\n-            }\n-            case (ast::expr_move(?lhs_0, ?rhs_0, ?ann)) {\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                pushdown_expr(fcx, expected, lhs_0);\n-                pushdown_expr(fcx, expected, rhs_0);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                pushdown_expr(fcx, expected, lhs_0);\n-                pushdown_expr(fcx, expected, rhs_0);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                pushdown_expr(fcx, expected, lhs_0);\n-                pushdown_expr(fcx, expected, rhs_0);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_field(?lhs, ?rhs, ?ann)) {\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_index(?base, ?index, ?ann)) {\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            case (ast::expr_path(?pth, ?ann)) {\n-                auto tp_substs_0 =\n-                    ty::ann_to_type_params(fcx.ccx.tcx, ann);\n-                auto t_0 = ty::ann_to_monotype(fcx.ccx.tcx, ann);\n-\n-                auto result_0 = demand::full(fcx, e.span, expected, t_0,\n-                                             tp_substs_0, adk);\n-                auto t = ann_to_type(fcx.ccx.tcx, ann);\n-\n-                // Fill in the type parameter substitutions if they weren't\n-                // provided by the programmer.\n-                auto ty_params_opt;\n-\n-                alt (ty::ann_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx,\n-                                                           ann)._0) {\n-                    case (none) {\n-                        ty_params_opt = none[vec[ty::t]];\n-                    }\n-                    case (some(?tps)) {\n-                        ty_params_opt = some[vec[ty::t]](tps);\n-                    }\n-                }\n-\n-                write::ty_fixup(fcx, ann.id, tup(ty_params_opt, t));\n-            }\n-            case (ast::expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-            /* FIXME: should this check the type annotations? */\n-            case (ast::expr_fail(_,_))  { /* no-op */ }\n-            case (ast::expr_log(_,_,_)) { /* no-op */ }\n-            case (ast::expr_break(_)) { /* no-op */ }\n-            case (ast::expr_cont(_))  { /* no-op */ }\n-            case (ast::expr_ret(_,_)) { /* no-op */ }\n-            case (ast::expr_put(_,_)) { /* no-op */ }\n-            case (ast::expr_be(_,_))  { /* no-op */ }\n-            case (ast::expr_check(_,_)) { /* no-op */ }\n-            case (ast::expr_assert(_,_)) { /* no-op */ }\n-\n-            case (ast::expr_port(?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-\n-            case (ast::expr_chan(?es, ?ann)) {\n-                auto t = demand::simple(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann));\n-                alt (struct(fcx.ccx.tcx, t)) {\n-                    case (ty::ty_chan(?subty)) {\n-                        auto pt = ty::mk_port(fcx.ccx.tcx, subty);\n-                        pushdown_expr(fcx, pt, es);\n-                    }\n-                    case (_) {\n-                        log \"chan expr doesn't have a chan type!\";\n-                        fail;\n-                    }\n-                }\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-\n-            case (ast::expr_alt(?discrim, ?arms_0, ?ann)) {\n-                auto t = expected;\n-                for (ast::arm arm_0 in arms_0) {\n-                    pushdown_block(fcx, expected, arm_0.block);\n-                    auto bty = block_ty(fcx.ccx.tcx, arm_0.block);\n-                    t = demand::simple(fcx, e.span, t, bty);\n-                }\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-\n-            case (ast::expr_recv(?lval, ?expr, ?ann)) {\n-                pushdown_expr(fcx, next_ty_var(fcx), lval);\n-                auto t = expr_ty(fcx.ccx.tcx, lval);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-\n-            case (ast::expr_send(?lval, ?expr, ?ann)) {\n-                pushdown_expr(fcx, next_ty_var(fcx), expr);\n-                auto t = expr_ty(fcx.ccx.tcx, expr);\n-                pushdown_expr(fcx, ty::mk_chan(fcx.ccx.tcx, t), lval);\n-            }\n-\n-            case (ast::expr_spawn(?dom, ?name, ?func, ?args, ?ann)) {\n-                // NB: we call 'demand::autoderef' and pass in adk only in\n-                // cases where e is an expression that could *possibly*\n-                // produce a box; things like expr_binary or expr_bind can't,\n-                // so there's no need.\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-\n-            case (ast::expr_anon_obj(?anon_obj, ?tps, ?odid, ?ann)) {\n-                // NB: Not sure if this is correct, but not worrying too much\n-                // about it since pushdown is going away anyway.\n-                auto t = demand::autoderef(fcx, e.span, expected,\n-                    ann_to_type(fcx.ccx.tcx, ann), adk);\n-                write::ty_only_fixup(fcx, ann.id, t);\n-            }\n-\n-            case (_) {\n-                fcx.ccx.tcx.sess.span_unimpl(e.span,\n-                    #fmt(\"type unification for expression variant: %s\",\n-                         pretty::pprust::expr_to_str(e)));\n-            }\n-        }\n-    }\n-\n-    // Push-down over typed blocks.\n-    fn pushdown_block(&@fn_ctxt fcx, &ty::t expected, &ast::block bloc) {\n-        alt (bloc.node.expr) {\n-            case (some(?e_0)) {\n-                pushdown_expr(fcx, expected, e_0);\n-            }\n-            case (none) {\n-                /* empty */\n-            }\n-        }\n-        demand::simple(fcx, bloc.span, expected, ann_to_type(fcx.ccx.tcx,\n-                                                             bloc.node.a));\n-    }\n-}\n-\n-\n // Type resolution: the phase that finds all the types in the AST with\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n@@ -1825,19 +1450,14 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n     }\n \n     // A generic function for checking assignment expressions\n-    fn check_assignment(&@fn_ctxt fcx, &@ast::expr lhs, &@ast::expr rhs,\n-                        &ast::ann a) {\n+    fn check_assignment(&@fn_ctxt fcx, &span sp, &@ast::expr lhs,\n+                        &@ast::expr rhs, &ast::ann a) {\n         check_expr(fcx, lhs);\n         check_expr(fcx, rhs);\n-        auto lhs_t0 = expr_ty(fcx.ccx.tcx, lhs);\n-        auto rhs_t0 = expr_ty(fcx.ccx.tcx, rhs);\n-\n-        pushdown::pushdown_expr(fcx, rhs_t0, lhs);\n-        auto lhs_t1 = expr_ty(fcx.ccx.tcx, lhs);\n-        pushdown::pushdown_expr(fcx, lhs_t1, rhs);\n-        auto rhs_t1 = expr_ty(fcx.ccx.tcx, rhs);\n-\n-        write::ty_only_fixup(fcx, a.id, rhs_t1);\n+        auto typ = demand::simple(fcx, sp,\n+                                  expr_ty(fcx.ccx.tcx, lhs),\n+                                  expr_ty(fcx.ccx.tcx, rhs));\n+        write::ty_only_fixup(fcx, a.id, typ);\n     }\n \n     // A generic function for checking call expressions\n@@ -1876,15 +1496,11 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n         case (ast::expr_binary(?binop, ?lhs, ?rhs, ?a)) {\n             check_expr(fcx, lhs);\n             check_expr(fcx, rhs);\n-            auto lhs_t0 = expr_ty(fcx.ccx.tcx, lhs);\n-            auto rhs_t0 = expr_ty(fcx.ccx.tcx, rhs);\n \n-            // FIXME: Binops have a bit more subtlety than this.\n-            pushdown::pushdown_expr_full(fcx, rhs_t0, lhs, AUTODEREF_OK);\n-            auto lhs_t1 = expr_ty(fcx.ccx.tcx, lhs);\n-            pushdown::pushdown_expr_full(fcx, lhs_t1, rhs, AUTODEREF_OK);\n+            auto lhs_t = expr_ty(fcx.ccx.tcx, lhs);\n \n-            auto t = strip_boxes(fcx.ccx.tcx, lhs_t0);\n+            // FIXME: Binops have a bit more subtlety than this.\n+            auto t = strip_boxes(fcx.ccx.tcx, lhs_t);\n             alt (binop) {\n                 case (ast::eq) { t = ty::mk_bool(fcx.ccx.tcx); }\n                 case (ast::lt) { t = ty::mk_bool(fcx.ccx.tcx); }\n@@ -1979,9 +1595,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n                 case (some(?e)) {\n                     check_expr(fcx, e);\n-\n-                    pushdown::pushdown_expr(fcx, fcx.ret_ty, e);\n-\n+                    demand::simple(fcx, expr.span, fcx.ret_ty,\n+                                   expr_ty(fcx.ccx.tcx, e));\n                     write::bot_ty(fcx.ccx.tcx, a.id);\n                 }\n             }\n@@ -2003,8 +1618,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n                 case (some(?e)) {\n                     check_expr(fcx, e);\n-                    pushdown::pushdown_expr(fcx, fcx.ret_ty, e);\n-\n                     write::nil_ty(fcx.ccx.tcx, a.id);\n                 }\n             }\n@@ -2015,8 +1628,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             assert (ast::is_call_expr(e));\n \n             check_expr(fcx, e);\n-            pushdown::pushdown_expr(fcx, fcx.ret_ty, e);\n-\n             write::nil_ty(fcx.ccx.tcx, a.id);\n         }\n \n@@ -2076,17 +1687,17 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n         case (ast::expr_move(?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-            check_assignment(fcx, lhs, rhs, a);\n+            check_assignment(fcx, expr.span, lhs, rhs, a);\n         }\n \n         case (ast::expr_assign(?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-            check_assignment(fcx, lhs, rhs, a);\n+            check_assignment(fcx, expr.span, lhs, rhs, a);\n         }\n \n         case (ast::expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n-            check_assignment(fcx, lhs, rhs, a);\n+            check_assignment(fcx, expr.span, lhs, rhs, a);\n         }\n \n         case (ast::expr_send(?lhs, ?rhs, ?a)) {\n@@ -2097,14 +1708,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             auto rhs_t = expr_ty(fcx.ccx.tcx, rhs);\n \n             auto chan_t = ty::mk_chan(fcx.ccx.tcx, rhs_t);\n-            pushdown::pushdown_expr(fcx, chan_t, lhs);\n+\n             auto item_t;\n             auto lhs_t = expr_ty(fcx.ccx.tcx, lhs);\n             alt (struct(fcx.ccx.tcx, lhs_t)) {\n                 case (ty::ty_chan(?it)) { item_t = it; }\n                 case (_) { fail; }\n             }\n-            pushdown::pushdown_expr(fcx, item_t, rhs);\n \n             write::ty_only_fixup(fcx, a.id, chan_t);\n         }\n@@ -2114,26 +1724,16 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n             check_expr(fcx, lhs);\n             check_expr(fcx, rhs);\n-            auto lhs_t1 = expr_ty(fcx.ccx.tcx, lhs);\n \n-            auto port_t = ty::mk_port(fcx.ccx.tcx, lhs_t1);\n-            pushdown::pushdown_expr(fcx, port_t, rhs);\n-            auto item_t;\n-            auto rhs_t = expr_ty(fcx.ccx.tcx, rhs);\n-            alt (struct(fcx.ccx.tcx, rhs_t)) {\n-                case (ty::ty_port(?it)) { item_t = it; }\n-                case (_) { fail; }\n-            }\n-            pushdown::pushdown_expr(fcx, item_t, lhs);\n+            auto item_t = expr_ty(fcx.ccx.tcx, lhs);\n+            auto port_t = ty::mk_port(fcx.ccx.tcx, item_t);\n+            demand::simple(fcx, expr.span, port_t, expr_ty(fcx.ccx.tcx, rhs));\n \n             write::ty_only_fixup(fcx, a.id, item_t);\n         }\n \n         case (ast::expr_if(?cond, ?thn, ?elsopt, ?a)) {\n             check_expr(fcx, cond);\n-            pushdown::pushdown_expr(fcx, ty::mk_bool(fcx.ccx.tcx),\n-                                    cond);\n-\n             check_block(fcx, thn);\n \n             auto if_t = alt (elsopt) {\n@@ -2188,7 +1788,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n         case (ast::expr_while(?cond, ?body, ?a)) {\n             check_expr(fcx, cond);\n-            pushdown::pushdown_expr(fcx, ty::mk_bool(fcx.ccx.tcx), cond);\n             check_block(fcx, body);\n \n             auto typ = ty::mk_nil(fcx.ccx.tcx);\n@@ -2197,7 +1796,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n \n         case (ast::expr_do_while(?body, ?cond, ?a)) {\n             check_expr(fcx, cond);\n-            pushdown::pushdown_expr(fcx, ty::mk_bool(fcx.ccx.tcx), cond);\n             check_block(fcx, body);\n \n             auto typ = block_ty(fcx.ccx.tcx, body);\n@@ -2232,13 +1830,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                 }\n             }\n \n-            auto i = 0u;\n-            for (ast::block bloc in blocks) {\n-                pushdown::pushdown_block(fcx, result_ty, bloc);\n-            }\n-\n-            pushdown::pushdown_expr(fcx, pattern_ty, expr);\n-\n             write::ty_only_fixup(fcx, a.id, result_ty);\n         }\n \n@@ -2682,14 +2273,17 @@ fn check_decl_initializer(&@fn_ctxt fcx, &ast::def_id lid,\n     auto lty = ty::mk_var(fcx.ccx.tcx, fcx.locals.get(lid));\n     alt (init.op) {\n         case (ast::init_assign) {\n-            pushdown::pushdown_expr(fcx, lty, init.expr);\n+            demand::simple(fcx, init.expr.span, lty,\n+                           expr_ty(fcx.ccx.tcx, init.expr));\n         }\n         case (ast::init_move) {\n-            pushdown::pushdown_expr(fcx, lty, init.expr);\n+            demand::simple(fcx, init.expr.span, lty,\n+                           expr_ty(fcx.ccx.tcx, init.expr));\n         }\n         case (ast::init_recv) {\n             auto port_ty = ty::mk_port(fcx.ccx.tcx, lty);\n-            pushdown::pushdown_expr(fcx, port_ty, init.expr);\n+            demand::simple(fcx, init.expr.span, port_ty,\n+                           expr_ty(fcx.ccx.tcx, init.expr));\n         }\n     }\n }\n@@ -2714,12 +2308,6 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast::decl decl) -> @ast::decl {\n     }\n }\n \n-fn check_and_pushdown_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n-    check_expr(fcx, expr);\n-    auto ety = expr_ty(fcx.ccx.tcx, expr);\n-    pushdown::pushdown_expr(fcx, ety, expr);\n-}\n-\n fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) {\n     auto node_id;\n     alt (stmt.node) {\n@@ -2732,7 +2320,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast::stmt stmt) {\n         }\n         case (ast::stmt_expr(?expr,?a)) {\n             node_id = a.id;\n-            check_and_pushdown_expr(fcx, expr);\n+            check_expr(fcx, expr);\n         }\n     }\n \n@@ -2743,13 +2331,10 @@ fn check_block(&@fn_ctxt fcx, &ast::block block) {\n     for (@ast::stmt s in block.node.stmts) { check_stmt(fcx, s); }\n \n     alt (block.node.expr) {\n-        case (none) {\n-            write::nil_ty(fcx.ccx.tcx, block.node.a.id);\n-        }\n+        case (none) { write::nil_ty(fcx.ccx.tcx, block.node.a.id); }\n         case (some(?e)) {\n             check_expr(fcx, e);\n             auto ety = expr_ty(fcx.ccx.tcx, e);\n-            pushdown::pushdown_expr(fcx, ety, e);\n             write::ty_only_fixup(fcx, block.node.a.id, ety);\n         }\n     }\n@@ -2770,7 +2355,7 @@ fn check_const(&@crate_ctxt ccx, &span sp, &@ast::expr e, &ast::ann ann) {\n                             mutable fixups=fixups,\n                             ccx=ccx);\n \n-    check_and_pushdown_expr(fcx, e);\n+    check_expr(fcx, e);\n }\n \n fn check_fn(&@crate_ctxt ccx, &ast::fn_decl decl, ast::proto proto,"}]}