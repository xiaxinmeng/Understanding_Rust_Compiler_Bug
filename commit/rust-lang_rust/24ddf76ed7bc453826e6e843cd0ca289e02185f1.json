{"sha": "24ddf76ed7bc453826e6e843cd0ca289e02185f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0ZGRmNzZlZDdiYzQ1MzgyNmU2ZTg0M2NkMGNhMjg5ZTAyMTg1ZjE=", "commit": {"author": {"name": "Tim Diekmann", "email": "21277928+TimDiekmann@users.noreply.github.com", "date": "2020-08-03T00:18:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-03T00:18:20Z"}, "message": "Merge branch 'master' into remove-in-place-alloc", "tree": {"sha": "2833654479a3749e6646890af4bdbc071b181f3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2833654479a3749e6646890af4bdbc071b181f3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24ddf76ed7bc453826e6e843cd0ca289e02185f1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfJ1fMCRBK7hj4Ov3rIwAAdHIIAFzi5fNXGR7U5qY0gp1RSbZT\nud2US+hFCM0woGIbMiJ0K/JOnX2BirC13CAOR40zymfRNEqGBGA4w+Pdfro2cU4m\n+yUZ/6va3pKJWTwPpZhIKAh+Nw1zbOyzcLszSsI0o13MtQN2ccEJw7OaLZwiHvB6\nW3F2k7xHeeRkct8wokXS4WTgHQ1pwjvjECzms9yJ7e8EGrI3aSBoCqrS01BT4Wmz\n5SlGhV33IeYtScUDnstBnheCIusm8bBx/7qg+Dq9fuzDa4KCXkZ4i9TeCwFLfxda\nHbSnrap/nPkY2j5U33ozf332npFyyG5Lmpf0GEGOtxWveA+P30VBvWkQgXBQG5w=\n=cKS7\n-----END PGP SIGNATURE-----\n", "payload": "tree 2833654479a3749e6646890af4bdbc071b181f3b\nparent db7d07b83bee302be977468caa6931f651b4f77a\nparent 81e754c359c471f91263813c46c67955071716a7\nauthor Tim Diekmann <21277928+TimDiekmann@users.noreply.github.com> 1596413900 +0200\ncommitter GitHub <noreply@github.com> 1596413900 +0200\n\nMerge branch 'master' into remove-in-place-alloc"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24ddf76ed7bc453826e6e843cd0ca289e02185f1", "html_url": "https://github.com/rust-lang/rust/commit/24ddf76ed7bc453826e6e843cd0ca289e02185f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24ddf76ed7bc453826e6e843cd0ca289e02185f1/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db7d07b83bee302be977468caa6931f651b4f77a", "url": "https://api.github.com/repos/rust-lang/rust/commits/db7d07b83bee302be977468caa6931f651b4f77a", "html_url": "https://github.com/rust-lang/rust/commit/db7d07b83bee302be977468caa6931f651b4f77a"}, {"sha": "81e754c359c471f91263813c46c67955071716a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/81e754c359c471f91263813c46c67955071716a7", "html_url": "https://github.com/rust-lang/rust/commit/81e754c359c471f91263813c46c67955071716a7"}], "stats": {"total": 14596, "additions": 8577, "deletions": 6019}, "files": [{"sha": "86f60349c67771dcd0fc0f0fb504948382e16067", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -406,7 +406,7 @@ jobs:\n             os: windows-latest-xl\n           - name: x86_64-msvc-cargo\n             env:\n-              SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n+              SCRIPT: python x.py --stage 2 test src/tools/cargotest src/tools/cargo\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-pc-windows-msvc --enable-lld\"\n               VCVARS_BAT: vcvars64.bat\n               NO_DEBUG_ASSERTIONS: 1\n@@ -577,6 +577,11 @@ jobs:\n     strategy:\n       matrix:\n         include:\n+          - name: aarch64-gnu\n+            os:\n+              - self-hosted\n+              - ARM64\n+              - linux\n           - name: dist-x86_64-apple\n             env:\n               SCRIPT: \"./x.py dist\"\n@@ -598,7 +603,7 @@ jobs:\n             os: macos-latest\n           - name: x86_64-apple\n             env:\n-              SCRIPT: \"./x.py test\"\n+              SCRIPT: \"./x.py --stage 2 test\"\n               RUST_CONFIGURE_ARGS: \"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.8"}, {"sha": "a327aaa8d5a34501ae7c78625f95340cfbd77b06", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -44,3 +44,6 @@\n [submodule \"src/tools/rust-analyzer\"]\n \tpath = src/tools/rust-analyzer\n \turl = https://github.com/rust-analyzer/rust-analyzer.git\n+[submodule \"library/backtrace\"]\n+\tpath = library/backtrace\n+\turl = https://github.com/rust-lang/backtrace-rs.git"}, {"sha": "142ac9eceebcc54cc8e1da9883e546602f67920f", "filename": "Cargo.lock", "status": "modified", "additions": 308, "deletions": 308, "changes": 616, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,10 +1,26 @@\n # This file is automatically @generated by Cargo.\n # It is not intended for manual editing.\n [[package]]\n-name = \"adler32\"\n-version = \"1.0.3\"\n+name = \"addr2line\"\n+version = \"0.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e522997b529f05601e05166c07ed17789691f562762c7f3b987263d2dedee5c\"\n+checksum = \"1b6a2d3371669ab3ca9797670853d61402b03d0b4b9ebf33d677dfa720203072\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"gimli\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n+[[package]]\n+name = \"adler\"\n+version = \"0.2.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+]\n \n [[package]]\n name = \"aho-corasick\"\n@@ -21,19 +37,20 @@ version = \"0.0.0\"\n dependencies = [\n  \"compiler_builtins\",\n  \"core\",\n- \"rand 0.7.3\",\n- \"rand_xorshift 0.2.0\",\n+ \"rand\",\n+ \"rand_xorshift\",\n ]\n \n [[package]]\n name = \"ammonia\"\n-version = \"3.0.0\"\n+version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9e266e1f4be5ffa05309f650e2586fe1d3ae6034eb24025a7ae1dfecc330823a\"\n+checksum = \"89eac85170f4b3fb3dc5e442c1cfb036cb8eecf9dbbd431a161ffad15d90ea3b\"\n dependencies = [\n  \"html5ever\",\n  \"lazy_static\",\n  \"maplit\",\n+ \"markup5ever_rcdom\",\n  \"matches\",\n  \"tendril\",\n  \"url 2.1.0\",\n@@ -45,7 +62,7 @@ version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"c7021ce4924a3f25f802b2cccd1af585e39ea1a363a1aa2e72afe54b67a3a7a7\"\n dependencies = [\n- \"ansi_term\",\n+ \"ansi_term 0.11.0\",\n ]\n \n [[package]]\n@@ -63,6 +80,15 @@ dependencies = [\n  \"winapi 0.3.8\",\n ]\n \n+[[package]]\n+name = \"ansi_term\"\n+version = \"0.12.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d52a9bb7ec0cf484c551830a7ce27bd20d67eac647e1befb56b0be4ee39a55d2\"\n+dependencies = [\n+ \"winapi 0.3.8\",\n+]\n+\n [[package]]\n name = \"anyhow\"\n version = \"1.0.31\"\n@@ -125,28 +151,14 @@ checksum = \"f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d\"\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.46\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b1e692897359247cc6bb902933361652380af0f1b7651ae5c5013407f30e109e\"\n+version = \"0.3.50\"\n dependencies = [\n- \"backtrace-sys\",\n+ \"addr2line\",\n  \"cfg-if\",\n- \"compiler_builtins\",\n  \"libc\",\n+ \"miniz_oxide\",\n+ \"object\",\n  \"rustc-demangle\",\n- \"rustc-std-workspace-core\",\n-]\n-\n-[[package]]\n-name = \"backtrace-sys\"\n-version = \"0.1.37\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"18fbebbe1c9d1f383a9cc7e8ccdb471b91c8d024ee9c2ca5b5346121fe8b4399\"\n-dependencies = [\n- \"cc\",\n- \"compiler_builtins\",\n- \"libc\",\n- \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n@@ -332,7 +344,7 @@ dependencies = [\n  \"termcolor\",\n  \"toml\",\n  \"unicode-width\",\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n  \"url 2.1.0\",\n  \"walkdir\",\n  \"winapi 0.3.8\",\n@@ -433,9 +445,9 @@ version = \"0.14.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"d463e01905d607e181de72e8608721d3269f29176c9a14ce037011316ae7131d\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -494,7 +506,7 @@ version = \"2.33.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n dependencies = [\n- \"ansi_term\",\n+ \"ansi_term 0.11.0\",\n  \"atty\",\n  \"bitflags\",\n  \"strsim\",\n@@ -536,12 +548,12 @@ dependencies = [\n  \"lazy_static\",\n  \"pulldown-cmark\",\n  \"quine-mc_cluskey\",\n- \"quote 1.0.2\",\n+ \"quote\",\n  \"regex-syntax\",\n  \"semver 0.9.0\",\n  \"serde\",\n  \"smallvec 1.4.0\",\n- \"syn 1.0.11\",\n+ \"syn\",\n  \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n@@ -611,14 +623,15 @@ dependencies = [\n  \"diff\",\n  \"env_logger 0.7.1\",\n  \"getopts\",\n+ \"glob\",\n  \"lazy_static\",\n  \"libc\",\n- \"log\",\n  \"miow 0.3.3\",\n  \"regex\",\n  \"rustfix\",\n  \"serde\",\n  \"serde_json\",\n+ \"tracing\",\n  \"walkdir\",\n  \"winapi 0.3.8\",\n ]\n@@ -655,7 +668,7 @@ checksum = \"8ff012e225ce166d4422e0e78419d901719760f62ae2b7969ca6b564d1b54a9e\"\n name = \"core\"\n version = \"0.0.0\"\n dependencies = [\n- \"rand 0.7.3\",\n+ \"rand\",\n ]\n \n [[package]]\n@@ -688,9 +701,9 @@ dependencies = [\n \n [[package]]\n name = \"crc32fast\"\n-version = \"1.1.2\"\n+version = \"1.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e91d5240c6975ef33aeb5f148f35275c25eda8e8a5f95abe421978b05b8bf192\"\n+checksum = \"ba125de2af0df55319f41944744ad91c71113bf74a4646efff39afe1f6842db1\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -776,8 +789,8 @@ version = \"0.1.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"47c5e5ac752e18207b12e16b10631ae5f7f68f8805f335f9b817ead83d9ffce1\"\n dependencies = [\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -823,9 +836,9 @@ version = \"0.5.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"71f31892cd5c62e414316f2963c5689242c43d8e7bbcaaeca97e5e28c95d91d9\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -834,9 +847,9 @@ version = \"0.99.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2159be042979966de68315bce7034bb000c775f22e3e834e1c52ff78f041cae8\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -911,9 +924,9 @@ checksum = \"3be565ca5c557d7f59e7cfcf1844f9e3033650c929c6566f511e8005f205c1d0\"\n \n [[package]]\n name = \"elasticlunr-rs\"\n-version = \"2.3.4\"\n+version = \"2.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a99a310cd1f9770e7bf8e48810c7bcbb0e078c8fb23a8c7bcf0da4c2bf61a455\"\n+checksum = \"35622eb004c8f0c5e7e2032815f3314a93df0db30a1ce5c94e62c1ecc81e22b9\"\n dependencies = [\n  \"lazy_static\",\n  \"regex\",\n@@ -991,9 +1004,9 @@ version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"aa4da3c766cd7a0db8242e326e9e4e081edd567072893ed320008189715366a4\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -1023,9 +1036,9 @@ checksum = \"37ab347416e802de484e4d03c7316c48f1ecb56574dfd4a46a80f173ce1de04d\"\n \n [[package]]\n name = \"flate2\"\n-version = \"1.0.12\"\n+version = \"1.0.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ad3c5233c9a940c8719031b423d7e6c16af66e031cb0420b0896f5245bf181d3\"\n+checksum = \"68c90b0fc46cf89d227cc78b40e494ff81287a92dd07631e5af0d06fe3cf885e\"\n dependencies = [\n  \"cfg-if\",\n  \"crc32fast\",\n@@ -1120,9 +1133,9 @@ checksum = \"45dc39533a6cae6da2b56da48edae506bb767ec07370f86f70fc062e9d435869\"\n \n [[package]]\n name = \"fwdansi\"\n-version = \"1.0.1\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34dd4c507af68d37ffef962063dfa1944ce0dd4d5b82043dbab1dabe088610c3\"\n+checksum = \"08c1f5787fe85505d1f7777268db5103d80a7a374d2316a7ce262e57baf8f208\"\n dependencies = [\n  \"memchr\",\n  \"termcolor\",\n@@ -1159,6 +1172,17 @@ dependencies = [\n  \"wasi\",\n ]\n \n+[[package]]\n+name = \"gimli\"\n+version = \"0.22.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aaf91faf136cb47367fa430cd46e37a788775e7fa104f8b4bcb3861dc389b724\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"git2\"\n version = \"0.13.5\"\n@@ -1275,16 +1299,16 @@ dependencies = [\n \n [[package]]\n name = \"html5ever\"\n-version = \"0.24.1\"\n+version = \"0.25.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"025483b0a1e4577bb28578318c886ee5f817dda6eb62473269349044406644cb\"\n+checksum = \"aafcf38a1a36118242d29b92e1b08ef84e67e4a5ed06e0a80be20e6a32bfed6b\"\n dependencies = [\n  \"log\",\n  \"mac\",\n  \"markup5ever\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -1492,9 +1516,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8609af8f63b626e8e211f52441fcdb6ec54f1a446606b10d5c89ae9bf8a20058\"\n dependencies = [\n  \"proc-macro-crate\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -1563,9 +1587,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.73\"\n+version = \"0.2.74\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bd7d4bd64732af4bf3a67f367c27df8520ad7e230c5817b8ff485864d80242b9\"\n+checksum = \"a2f02823cf78b754822df5f7f268fb59822e7296276d3e069d8e8cb26a14bd10\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1712,9 +1736,9 @@ checksum = \"08cbb6b4fef96b6d77bfc40ec491b1690c779e77b05cd9f07f787ed376fd4c43\"\n \n [[package]]\n name = \"markup5ever\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"65381d9d47506b8592b97c4efd936afcf673b09b059f2bef39c7211ee78b9d03\"\n+checksum = \"aae38d669396ca9b707bfc3db254bc382ddb94f57cc5c235f34623a669a01dab\"\n dependencies = [\n  \"log\",\n  \"phf\",\n@@ -1727,6 +1751,27 @@ dependencies = [\n  \"tendril\",\n ]\n \n+[[package]]\n+name = \"markup5ever_rcdom\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f015da43bcd8d4f144559a3423f4591d69b8ce0652c905374da7205df336ae2b\"\n+dependencies = [\n+ \"html5ever\",\n+ \"markup5ever\",\n+ \"tendril\",\n+ \"xml5ever\",\n+]\n+\n+[[package]]\n+name = \"matchers\"\n+version = \"0.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f099785f7595cc4b4553a174ce30dd7589ef93391ff414dbb67f62392b9e0ce1\"\n+dependencies = [\n+ \"regex-automata\",\n+]\n+\n [[package]]\n name = \"matches\"\n version = \"0.1.8\"\n@@ -1819,11 +1864,14 @@ dependencies = [\n \n [[package]]\n name = \"miniz_oxide\"\n-version = \"0.3.5\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f3f74f726ae935c3f514300cc6773a0c9492abc5e972d42ba0c0ebb88757625\"\n+checksum = \"be0f75932c1f6cfae3c04000e40114adf955636e19040f9c0a2c380702aa1c7f\"\n dependencies = [\n- \"adler32\",\n+ \"adler\",\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n ]\n \n [[package]]\n@@ -1902,7 +1950,7 @@ dependencies = [\n  \"hex 0.4.0\",\n  \"libc\",\n  \"log\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n@@ -1955,6 +2003,17 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"object\"\n+version = \"0.20.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1ab52be62400ca80aa00285d25253d7f7c437b7375c4de678f5405d3afe82ca5\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"once_cell\"\n version = \"1.1.0\"\n@@ -2085,7 +2144,7 @@ dependencies = [\n  \"log\",\n  \"mio-named-pipes\",\n  \"miow 0.3.3\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"tokio\",\n  \"tokio-named-pipes\",\n  \"tokio-uds\",\n@@ -2187,9 +2246,9 @@ checksum = \"99b8db626e31e5b81787b9783425769681b347011cc59471e33ea46d2ea0cf55\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -2215,38 +2274,38 @@ dependencies = [\n \n [[package]]\n name = \"phf\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b3da44b85f8e8dfaec21adae67f95d93244b2ecf6ad2a692320598dcc8e6dd18\"\n+checksum = \"3dfb61232e34fcb633f43d12c58f83c1df82962dcdfa565a4e866ffc17dafe12\"\n dependencies = [\n  \"phf_shared\",\n ]\n \n [[package]]\n name = \"phf_codegen\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b03e85129e324ad4166b06b2c7491ae27fe3ec353af72e72cd1654c7225d517e\"\n+checksum = \"cbffee61585b0411840d3ece935cce9cb6321f01c45477d30066498cd5e1a815\"\n dependencies = [\n  \"phf_generator\",\n  \"phf_shared\",\n ]\n \n [[package]]\n name = \"phf_generator\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"09364cc93c159b8b06b1f4dd8a4398984503483891b0c26b867cf431fb132662\"\n+checksum = \"17367f0cc86f2d25802b2c26ee58a7b23faeccf78a396094c13dced0d0182526\"\n dependencies = [\n  \"phf_shared\",\n- \"rand 0.6.1\",\n+ \"rand\",\n ]\n \n [[package]]\n name = \"phf_shared\"\n-version = \"0.7.24\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"234f71a15de2288bcb7e3b6515828d22af7ec8598ee6d24c3b526fa0a80b67a0\"\n+checksum = \"c00cf8b9eafe68dde5e9eaa2cef8ee84a9336a47d566ec55ca16589633b65af7\"\n dependencies = [\n  \"siphasher\",\n ]\n@@ -2286,7 +2345,7 @@ version = \"0.6.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3f81e1644e1b54f5a68959a29aa86cde704219254669da328ecfdf6a1f09d427\"\n dependencies = [\n- \"ansi_term\",\n+ \"ansi_term 0.11.0\",\n  \"ctor\",\n  \"difference\",\n  \"output_vt100\",\n@@ -2317,18 +2376,9 @@ version = \"0.2.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"aeccfe4d5d8ea175d5f0e4a2ad0637e0f4121d63bd99d356fb1f39ab2e7c6097\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n-]\n-\n-[[package]]\n-name = \"proc-macro2\"\n-version = \"0.4.30\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759\"\n-dependencies = [\n- \"unicode-xid 0.1.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -2337,7 +2387,7 @@ version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n dependencies = [\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -2395,22 +2445,13 @@ version = \"0.2.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \n-[[package]]\n-name = \"quote\"\n-version = \"0.6.12\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db\"\n-dependencies = [\n- \"proc-macro2 0.4.30\",\n-]\n-\n [[package]]\n name = \"quote\"\n version = \"1.0.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n+ \"proc-macro2\",\n ]\n \n [[package]]\n@@ -2436,25 +2477,6 @@ dependencies = [\n  \"rustc-ap-rustc_span\",\n ]\n \n-[[package]]\n-name = \"rand\"\n-version = \"0.6.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ae9d223d52ae411a33cf7e54ec6034ec165df296ccd23533d671a28252b6f66a\"\n-dependencies = [\n- \"cloudabi\",\n- \"fuchsia-zircon\",\n- \"libc\",\n- \"rand_chacha 0.1.0\",\n- \"rand_core 0.3.0\",\n- \"rand_hc 0.1.0\",\n- \"rand_isaac\",\n- \"rand_pcg\",\n- \"rand_xorshift 0.1.0\",\n- \"rustc_version\",\n- \"winapi 0.3.8\",\n-]\n-\n [[package]]\n name = \"rand\"\n version = \"0.7.3\"\n@@ -2463,19 +2485,10 @@ checksum = \"6a6b1679d49b24bbfe0c803429aa1874472f50d9b363131f0e89fc356b544d03\"\n dependencies = [\n  \"getrandom\",\n  \"libc\",\n- \"rand_chacha 0.2.2\",\n+ \"rand_chacha\",\n  \"rand_core 0.5.1\",\n- \"rand_hc 0.2.0\",\n-]\n-\n-[[package]]\n-name = \"rand_chacha\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"771b009e3a508cb67e8823dda454aaa5368c7bc1c16829fb77d3e980440dd34a\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n- \"rustc_version\",\n+ \"rand_hc\",\n+ \"rand_pcg\",\n ]\n \n [[package]]\n@@ -2509,15 +2522,6 @@ dependencies = [\n  \"getrandom\",\n ]\n \n-[[package]]\n-name = \"rand_hc\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n-]\n-\n [[package]]\n name = \"rand_hc\"\n version = \"0.2.0\"\n@@ -2527,15 +2531,6 @@ dependencies = [\n  \"rand_core 0.5.1\",\n ]\n \n-[[package]]\n-name = \"rand_isaac\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n-]\n-\n [[package]]\n name = \"rand_os\"\n version = \"0.1.3\"\n@@ -2552,21 +2547,11 @@ dependencies = [\n \n [[package]]\n name = \"rand_pcg\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"086bd09a33c7044e56bb44d5bdde5a60e7f119a9e95b0775f545de759a32fe05\"\n-dependencies = [\n- \"rand_core 0.3.0\",\n- \"rustc_version\",\n-]\n-\n-[[package]]\n-name = \"rand_xorshift\"\n-version = \"0.1.0\"\n+version = \"0.2.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"effa3fcaa47e18db002bdde6060944b6d2f9cfd8db471c30e873448ad9187be3\"\n+checksum = \"16abd0c1b639e9eb4d7c50c0b8100b0d0f849be2349829c740fe8e6eb4816429\"\n dependencies = [\n- \"rand_core 0.3.0\",\n+ \"rand_core 0.5.1\",\n ]\n \n [[package]]\n@@ -2650,6 +2635,16 @@ dependencies = [\n  \"thread_local\",\n ]\n \n+[[package]]\n+name = \"regex-automata\"\n+version = \"0.1.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ae1ded71d66a4a97f5e961fd0cb25a5f366a42a41570d16a763a69c092c26ae4\"\n+dependencies = [\n+ \"byteorder\",\n+ \"regex-syntax\",\n+]\n+\n [[package]]\n name = \"regex-syntax\"\n version = \"0.6.17\"\n@@ -2696,7 +2691,7 @@ dependencies = [\n  \"num_cpus\",\n  \"ordslice\",\n  \"racer\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rayon\",\n  \"regex\",\n  \"rls-analysis\",\n@@ -2768,7 +2763,7 @@ dependencies = [\n  \"env_logger 0.7.1\",\n  \"futures\",\n  \"log\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rls-data\",\n  \"rls-ipc\",\n  \"serde\",\n@@ -2995,7 +2990,7 @@ version = \"669.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"456af5f09c006cf6c22c1a433ee0232c4bb74bdc6c647a010166a47c94ed2a63\"\n dependencies = [\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -3004,9 +2999,9 @@ version = \"669.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"64f6acd192f313047759a346b892998b626466b93fe04f415da5f38906bb3b4c\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -3168,13 +3163,13 @@ name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n  \"crossbeam-utils 0.7.2\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n+ \"proc-macro2\",\n+ \"quote\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec 0.6.10\",\n  \"smallvec 1.4.0\",\n- \"syn 1.0.11\",\n+ \"syn\",\n  \"url 2.1.0\",\n  \"winapi 0.3.8\",\n ]\n@@ -3200,7 +3195,6 @@ name = \"rustc_ast\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"log\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n@@ -3209,13 +3203,13 @@ dependencies = [\n  \"rustc_span\",\n  \"scoped-tls\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_ast_lowering\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n@@ -3227,14 +3221,14 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_ast_passes\"\n version = \"0.0.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_attr\",\n@@ -3244,16 +3238,17 @@ dependencies = [\n  \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_ast_pretty\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3276,7 +3271,6 @@ dependencies = [\n name = \"rustc_builtin_macros\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_attr\",\n@@ -3290,6 +3284,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3299,7 +3294,6 @@ dependencies = [\n  \"bitflags\",\n  \"flate2\",\n  \"libc\",\n- \"log\",\n  \"measureme\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n@@ -3319,6 +3313,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3329,7 +3324,6 @@ dependencies = [\n  \"cc\",\n  \"jobserver\",\n  \"libc\",\n- \"log\",\n  \"memmap\",\n  \"num_cpus\",\n  \"pathdiff\",\n@@ -3349,6 +3343,7 @@ dependencies = [\n  \"rustc_symbol_mangling\",\n  \"rustc_target\",\n  \"tempfile\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3363,7 +3358,6 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static\",\n  \"libc\",\n- \"log\",\n  \"measureme\",\n  \"once_cell\",\n  \"parking_lot 0.10.2\",\n@@ -3376,17 +3370,16 @@ dependencies = [\n  \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n  \"stacker\",\n+ \"tracing\",\n  \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"env_logger 0.7.1\",\n  \"lazy_static\",\n  \"libc\",\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_codegen_ssa\",\n@@ -3408,6 +3401,8 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -3421,12 +3416,12 @@ version = \"0.0.0\"\n dependencies = [\n  \"annotate-snippets 0.8.0\",\n  \"atty\",\n- \"log\",\n  \"rustc_data_structures\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"termcolor\",\n  \"termize\",\n+ \"tracing\",\n  \"unicode-width\",\n  \"winapi 0.3.8\",\n ]\n@@ -3435,7 +3430,6 @@ dependencies = [\n name = \"rustc_expand\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_ast_passes\",\n  \"rustc_ast_pretty\",\n@@ -3449,6 +3443,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3473,7 +3468,6 @@ name = \"rustc_hir\"\n version = \"0.0.0\"\n dependencies = [\n  \"lazy_static\",\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n@@ -3482,6 +3476,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3499,8 +3494,7 @@ dependencies = [\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n@@ -3510,6 +3504,7 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3524,7 +3519,6 @@ dependencies = [\n name = \"rustc_infer\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -3538,14 +3532,14 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n- \"log\",\n  \"once_cell\",\n  \"rustc-rayon\",\n  \"rustc_ast\",\n@@ -3581,21 +3575,21 @@ dependencies = [\n  \"rustc_typeck\",\n  \"smallvec 1.4.0\",\n  \"tempfile\",\n+ \"tracing\",\n  \"winapi 0.3.8\",\n ]\n \n [[package]]\n name = \"rustc_lexer\"\n version = \"0.1.0\"\n dependencies = [\n- \"unicode-xid 0.2.0\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n name = \"rustc_lint\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_attr\",\n@@ -3609,6 +3603,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n+ \"tracing\",\n  \"unicode-security\",\n ]\n \n@@ -3625,9 +3620,9 @@ dependencies = [\n name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n  \"synstructure\",\n ]\n \n@@ -3637,7 +3632,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"flate2\",\n  \"libc\",\n- \"log\",\n  \"memmap\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3654,6 +3648,7 @@ dependencies = [\n  \"rustc_target\",\n  \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n+ \"tracing\",\n  \"winapi 0.3.8\",\n ]\n \n@@ -3664,7 +3659,6 @@ dependencies = [\n  \"bitflags\",\n  \"byteorder\",\n  \"chalk-ir\",\n- \"log\",\n  \"measureme\",\n  \"polonius-engine\",\n  \"rustc-rayon-core\",\n@@ -3685,6 +3679,7 @@ dependencies = [\n  \"rustc_target\",\n  \"scoped-tls\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3693,7 +3688,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"either\",\n  \"itertools 0.8.0\",\n- \"log\",\n  \"log_settings\",\n  \"polonius-engine\",\n  \"rustc_apfloat\",\n@@ -3714,13 +3708,13 @@ dependencies = [\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_mir_build\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_apfloat\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n@@ -3737,14 +3731,14 @@ dependencies = [\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_parse\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n@@ -3753,6 +3747,8 @@ dependencies = [\n  \"rustc_lexer\",\n  \"rustc_session\",\n  \"rustc_span\",\n+ \"smallvec 1.4.0\",\n+ \"tracing\",\n  \"unicode-normalization\",\n ]\n \n@@ -3768,7 +3764,6 @@ dependencies = [\n name = \"rustc_passes\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -3780,6 +3775,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3800,7 +3796,6 @@ dependencies = [\n name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n@@ -3809,13 +3804,13 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_typeck\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_query_system\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"parking_lot 0.10.2\",\n  \"rustc-rayon-core\",\n  \"rustc_arena\",\n@@ -3825,14 +3820,14 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_resolve\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"log\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_ast_lowering\",\n@@ -3849,13 +3844,13 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_save_analysis\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rls-data\",\n  \"rls-span\",\n  \"rustc_ast\",\n@@ -3868,6 +3863,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"serde_json\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3884,7 +3880,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n  \"getopts\",\n- \"log\",\n  \"num_cpus\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n@@ -3894,14 +3889,14 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_span\"\n version = \"0.0.0\"\n dependencies = [\n  \"cfg-if\",\n- \"log\",\n  \"md-5\",\n  \"rustc_arena\",\n  \"rustc_data_structures\",\n@@ -3910,14 +3905,14 @@ dependencies = [\n  \"rustc_serialize\",\n  \"scoped-tls\",\n  \"sha-1\",\n+ \"tracing\",\n  \"unicode-width\",\n ]\n \n [[package]]\n name = \"rustc_symbol_mangling\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"punycode\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n@@ -3927,19 +3922,20 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_target\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"log\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3956,7 +3952,6 @@ checksum = \"b725dadae9fabc488df69a287f5a99c5eaf5d10853842a8a3dfac52476f544ee\"\n name = \"rustc_trait_selection\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n@@ -3971,6 +3966,7 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -3979,7 +3975,6 @@ version = \"0.0.0\"\n dependencies = [\n  \"chalk-ir\",\n  \"chalk-solve\",\n- \"log\",\n  \"rustc_ast\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n@@ -3989,13 +3984,13 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_trait_selection\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_ty\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n@@ -4005,13 +4000,13 @@ dependencies = [\n  \"rustc_span\",\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n+ \"tracing\",\n ]\n \n [[package]]\n name = \"rustc_typeck\"\n version = \"0.0.0\"\n dependencies = [\n- \"log\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -4027,6 +4022,7 @@ dependencies = [\n  \"rustc_target\",\n  \"rustc_trait_selection\",\n  \"smallvec 1.4.0\",\n+ \"tracing\",\n ]\n \n [[package]]\n@@ -4078,10 +4074,10 @@ dependencies = [\n name = \"rustfmt-config_proc_macro\"\n version = \"0.2.0\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n+ \"proc-macro2\",\n+ \"quote\",\n  \"serde\",\n- \"syn 1.0.11\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4208,9 +4204,9 @@ version = \"1.0.106\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4239,9 +4235,9 @@ version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cd02c7587ec314570041b2754829f84d873ced14a96d1fd1823531e11db40573\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4256,6 +4252,15 @@ dependencies = [\n  \"opaque-debug\",\n ]\n \n+[[package]]\n+name = \"sharded-slab\"\n+version = \"0.0.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"06d5a3f5166fb5b42a5439f2eee8b9de149e235961e3eb21c5808fc3ea17ff3e\"\n+dependencies = [\n+ \"lazy_static\",\n+]\n+\n [[package]]\n name = \"shell-escape\"\n version = \"0.1.4\"\n@@ -4280,9 +4285,9 @@ dependencies = [\n \n [[package]]\n name = \"siphasher\"\n-version = \"0.2.2\"\n+version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0df90a788073e8d0235a67e50441d47db7c8ad9debd91cbf43736a2a92d36537\"\n+checksum = \"fa8f3741c7372e75519bd9346068370c9cdaabcc1f9599cbcf2a2719352286b7\"\n \n [[package]]\n name = \"sized-chunks\"\n@@ -4347,8 +4352,8 @@ dependencies = [\n name = \"std\"\n version = \"0.0.0\"\n dependencies = [\n+ \"addr2line\",\n  \"alloc\",\n- \"backtrace\",\n  \"cfg-if\",\n  \"compiler_builtins\",\n  \"core\",\n@@ -4357,48 +4362,42 @@ dependencies = [\n  \"hashbrown\",\n  \"hermit-abi\",\n  \"libc\",\n+ \"miniz_oxide\",\n+ \"object\",\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand 0.7.3\",\n+ \"rand\",\n+ \"rustc-demangle\",\n  \"unwind\",\n  \"wasi\",\n ]\n \n [[package]]\n name = \"string_cache\"\n-version = \"0.7.3\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"25d70109977172b127fe834e5449e5ab1740b9ba49fa18a2020f509174f25423\"\n+checksum = \"2940c75beb4e3bf3a494cef919a747a2cb81e52571e212bfbd185074add7208a\"\n dependencies = [\n  \"lazy_static\",\n  \"new_debug_unreachable\",\n  \"phf_shared\",\n  \"precomputed-hash\",\n  \"serde\",\n- \"string_cache_codegen\",\n- \"string_cache_shared\",\n ]\n \n [[package]]\n name = \"string_cache_codegen\"\n-version = \"0.4.2\"\n+version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n+checksum = \"f24c8e5e19d22a726626f1a5e16fe15b132dcf21d10177fa5a45ce7962996b97\"\n dependencies = [\n  \"phf_generator\",\n  \"phf_shared\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"string_cache_shared\",\n+ \"proc-macro2\",\n+ \"quote\",\n ]\n \n-[[package]]\n-name = \"string_cache_shared\"\n-version = \"0.3.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b1884d1bc09741d466d9b14e6d37ac89d6909cbcac41dd9ae982d4d063bbedfc\"\n-\n [[package]]\n name = \"strip-ansi-escapes\"\n version = \"0.1.0\"\n@@ -4432,38 +4431,27 @@ checksum = \"2ae9e5165d463a0dea76967d021f8d0f9316057bf5163aa2a4843790e842ff37\"\n dependencies = [\n  \"heck\",\n  \"proc-macro-error\",\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n name = \"strum\"\n-version = \"0.11.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f6c3a2071519ab6a48f465808c4c1ffdd00dfc8e93111d02b4fc5abab177676e\"\n+checksum = \"57bd81eb48f4c437cadc685403cad539345bf703d78e63707418431cecd4522b\"\n \n [[package]]\n name = \"strum_macros\"\n-version = \"0.11.0\"\n+version = \"0.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8baacebd7b7c9b864d83a6ba7a246232983e277b86fa5cdec77f565715a4b136\"\n+checksum = \"87c85aa3f8ea653bfd3ddf25f7ee357ee4d204731f6aa9ad04002306f6e2774c\"\n dependencies = [\n  \"heck\",\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"syn 0.15.35\",\n-]\n-\n-[[package]]\n-name = \"syn\"\n-version = \"0.15.35\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"641e117d55514d6d918490e47102f7e08d096fdde360247e4a10f7a91a8478d3\"\n-dependencies = [\n- \"proc-macro2 0.4.30\",\n- \"quote 0.6.12\",\n- \"unicode-xid 0.1.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4472,9 +4460,9 @@ version = \"1.0.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dff0acdb207ae2fe6d5976617f887eb1e35a2ba52c13c7234c790960cdad9238\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"unicode-xid 0.2.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -4483,10 +4471,10 @@ version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3f085a5855930c0441ca1288cf044ea4aecf4f43a91668abdb870b4ba546a203\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n- \"unicode-xid 0.2.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+ \"unicode-xid\",\n ]\n \n [[package]]\n@@ -4509,7 +4497,7 @@ checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"rand 0.7.3\",\n+ \"rand\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n  \"winapi 0.3.8\",\n@@ -4547,11 +4535,11 @@ dependencies = [\n \n [[package]]\n name = \"termcolor\"\n-version = \"1.0.4\"\n+version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4096add70612622289f2fdcdbd5086dc81c1e2675e6ae58d6c4f62a16c6d7f2f\"\n+checksum = \"bb6bfa289a4d7c5766392812c0a1f4c1ba45afa1ad47803c11e1f407d846d75f\"\n dependencies = [\n- \"wincolor\",\n+ \"winapi-util\",\n ]\n \n [[package]]\n@@ -4614,9 +4602,9 @@ version = \"1.0.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"24069c0ba08aab54289d6a25f5036d94afc61e1538bbc42ae5501df141c9027d\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n@@ -4900,9 +4888,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing\"\n-version = \"0.1.15\"\n+version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a41f40ed0e162c911ac6fcb53ecdc8134c46905fdbbae8c50add462a538b495f\"\n+checksum = \"f0aae59226cf195d8e74d4b34beae1859257efb4e5fed3f147d2dc2c7d372178\"\n dependencies = [\n  \"cfg-if\",\n  \"tracing-attributes\",\n@@ -4911,24 +4899,40 @@ dependencies = [\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"99bbad0de3fd923c9c3232ead88510b783e5a4d16a6154adffa3d53308de984c\"\n+checksum = \"f0693bf8d6f2bf22c690fc61a9d21ac69efdbb894a17ed596b9af0f01e64b84b\"\n dependencies = [\n- \"proc-macro2 1.0.3\",\n- \"quote 1.0.2\",\n- \"syn 1.0.11\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n ]\n \n [[package]]\n name = \"tracing-core\"\n-version = \"0.1.10\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0aa83a9a47081cd522c09c81b31aec2c9273424976f922ad61c053b58350b715\"\n+checksum = \"b2734b5a028fa697686f16c6d18c2c6a3c7e41513f9a213abb6754c4acb3c8d7\"\n dependencies = [\n  \"lazy_static\",\n ]\n \n+[[package]]\n+name = \"tracing-subscriber\"\n+version = \"0.2.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f7b33f8b2ef2ab0c3778c12646d9c42a24f7772bee4cdafc72199644a9f58fdc\"\n+dependencies = [\n+ \"ansi_term 0.12.1\",\n+ \"lazy_static\",\n+ \"matchers\",\n+ \"parking_lot 0.9.0\",\n+ \"regex\",\n+ \"sharded-slab\",\n+ \"smallvec 1.4.0\",\n+ \"tracing-core\",\n+]\n+\n [[package]]\n name = \"typenum\"\n version = \"1.12.0\"\n@@ -5018,12 +5022,6 @@ dependencies = [\n  \"rustc-std-workspace-std\",\n ]\n \n-[[package]]\n-name = \"unicode-xid\"\n-version = \"0.1.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc\"\n-\n [[package]]\n name = \"unicode-xid\"\n version = \"0.2.0\"\n@@ -5179,9 +5177,9 @@ checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n \n [[package]]\n name = \"winapi-util\"\n-version = \"0.1.2\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7168bab6e1daee33b4557efd0e95d5ca70a03706d39fa5f3fe7a236f584b03c9\"\n+checksum = \"70ec6ce85bb158151cae5e5c87f95a8e97d2c0c4b001223f33a334e3ce5de178\"\n dependencies = [\n  \"winapi 0.3.8\",\n ]\n@@ -5192,16 +5190,6 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n-[[package]]\n-name = \"wincolor\"\n-version = \"1.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"561ed901ae465d6185fa7864d63fbd5720d0ef718366c9a4dc83cf6170d7e9ba\"\n-dependencies = [\n- \"winapi 0.3.8\",\n- \"winapi-util\",\n-]\n-\n [[package]]\n name = \"ws2_32-sys\"\n version = \"0.2.1\"\n@@ -5221,6 +5209,18 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"xml5ever\"\n+version = \"0.16.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0b1b52e6e8614d4a58b8e70cf51ec0cc21b256ad8206708bcff8139b5bbd6a59\"\n+dependencies = [\n+ \"log\",\n+ \"mac\",\n+ \"markup5ever\",\n+ \"time\",\n+]\n+\n [[package]]\n name = \"xz2\"\n version = \"0.1.5\""}, {"sha": "1936e35aa4c5d252e64a06244b4f869ed53352da", "filename": "Cargo.toml", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -56,6 +56,18 @@ overflow-checks = false\n # per-crate configuration isn't specifiable in the environment.\n codegen-units = 10000\n \n+# These dependencies of the standard library implement symbolication for\n+# backtraces on most platforms. Their debuginfo causes both linking to be slower\n+# (more data to chew through) and binaries to be larger without really all that\n+# much benefit. This section turns them all to down to have no debuginfo which\n+# helps to improve link times a little bit.\n+[profile.release.package]\n+addr2line.debug = 0\n+adler.debug = 0\n+gimli.debug = 0\n+miniz_oxide.debug = 0\n+object.debug = 0\n+\n # We want the RLS to use the version of Cargo that we've got vendored in this\n # repository to ensure that the same exact version of Cargo is used by both the\n # RLS and the Cargo binary itself. The RLS depends on Cargo as a git repository\n@@ -80,5 +92,11 @@ rustc-std-workspace-core = { path = 'library/rustc-std-workspace-core' }\n rustc-std-workspace-alloc = { path = 'library/rustc-std-workspace-alloc' }\n rustc-std-workspace-std = { path = 'library/rustc-std-workspace-std' }\n \n+# This crate's integration with libstd is a bit wonky, so we use a submodule\n+# instead of a crates.io dependency. Make sure everything else in the repo is\n+# also using the submodule, however, so we can avoid duplicate copies of the\n+# source code for this crate.\n+backtrace = { path = \"library/backtrace\" }\n+\n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }"}, {"sha": "4859532f7a1f72505b5bf15fe1fba88e8c4b80d6", "filename": "RELEASES.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,3 +1,25 @@\n+Version 1.45.2 (2020-08-03)\n+==========================\n+\n+* [Fix bindings in tuple struct patterns][74954]\n+* [Fix track_caller integration with trait objects][74784]\n+\n+[74954]: https://github.com/rust-lang/rust/issues/74954\n+[74784]: https://github.com/rust-lang/rust/issues/74784\n+\n+Version 1.45.1 (2020-07-30)\n+==========================\n+\n+* [Fix const propagation with references.][73613]\n+* [rustfmt accepts rustfmt_skip in cfg_attr again.][73078]\n+* [Avoid spurious implicit region bound.][74509]\n+* [Install clippy on x.py install][74457]\n+\n+[73613]: https://github.com/rust-lang/rust/pull/73613\n+[73078]: https://github.com/rust-lang/rust/issues/73078\n+[74509]: https://github.com/rust-lang/rust/pull/74509\n+[74457]: https://github.com/rust-lang/rust/pull/74457\n+\n Version 1.45.0 (2020-07-16)\n ==========================\n "}, {"sha": "8ecd8d88d4895a8ddd082c6342efd6e9ffaefc2b", "filename": "config.toml.example", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -341,7 +341,10 @@\n # Debuginfo for tests run with compiletest is not controlled by this option\n # and needs to be enabled separately with `debuginfo-level-tests`.\n #\n-# Defaults to 2 if debug is true\n+# Note that debuginfo-level = 2 generates several gigabytes of debuginfo\n+# and will slow down the linking process significantly.\n+#\n+# Defaults to 1 if debug is true\n #debuginfo-level = 0\n \n # Debuginfo level for the compiler.\n@@ -453,8 +456,7 @@\n # instead of LLVM's default of 100.\n #thin-lto-import-instr-limit = 100\n \n-# Map all debuginfo paths for libstd and crates to `/rust/$sha/$crate/...`,\n-# generally only set for releases\n+# Map debuginfo paths to `/rust/$sha/...`, generally only set for releases\n #remap-debuginfo = false\n \n # Link the compiler against `jemalloc`, where on Linux and OSX it should"}, {"sha": "7c2e5694a62fc4249859748c47d16499752ad066", "filename": "library/alloc/benches/btree/map.rs", "status": "modified", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fmap.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -282,3 +282,305 @@ pub fn iter_10k(b: &mut Bencher) {\n pub fn iter_1m(b: &mut Bencher) {\n     bench_iter(b, 1_000, 1_000_000);\n }\n+\n+const FAT: usize = 256;\n+\n+// The returned map has small keys and values.\n+// Benchmarks on it have a counterpart in set.rs with the same keys and no values at all.\n+fn slim_map(n: usize) -> BTreeMap<usize, usize> {\n+    (0..n).map(|i| (i, i)).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has small keys and large values.\n+fn fat_val_map(n: usize) -> BTreeMap<usize, [usize; FAT]> {\n+    (0..n).map(|i| (i, [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+// The returned map has large keys and values.\n+fn fat_map(n: usize) -> BTreeMap<[usize; FAT], [usize; FAT]> {\n+    (0..n).map(|i| ([i; FAT], [i; FAT])).collect::<BTreeMap<_, _>>()\n+}\n+\n+#[bench]\n+pub fn clone_slim_100(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_clear(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_100_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_clear(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_drain_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(map.len(), 10_000 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_into_iter(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_pop_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_all(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_slim_10k_and_remove_half(b: &mut Bencher) {\n+    let src = slim_map(10_000);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..10_000).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 10_000 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_clear(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_val_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_val_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&i);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_clear(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().clear())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().drain_filter(|_, _| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_drain_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        assert_eq!(map.drain_filter(|i, _| i[0] % 2 == 0).count(), 100 / 2);\n+        assert_eq!(map.len(), 100 / 2);\n+    })\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_into_iter(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| src.clone().into_iter().count())\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_pop_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while map.pop_first().is_some() {}\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_all(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        while let Some(elt) = map.iter().map(|(&i, _)| i).next() {\n+            let v = map.remove(&elt);\n+            debug_assert!(v.is_some());\n+        }\n+        map\n+    });\n+}\n+\n+#[bench]\n+pub fn clone_fat_100_and_remove_half(b: &mut Bencher) {\n+    let src = fat_map(100);\n+    b.iter(|| {\n+        let mut map = src.clone();\n+        for i in (0..100).step_by(2) {\n+            let v = map.remove(&[i; FAT]);\n+            debug_assert!(v.is_some());\n+        }\n+        assert_eq!(map.len(), 100 / 2);\n+        map\n+    })\n+}"}, {"sha": "07bf5093727c04b4589f7260416a1e275f0ce717", "filename": "library/alloc/benches/btree/set.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fbtree%2Fset.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -50,27 +50,31 @@ macro_rules! set_bench {\n     };\n }\n \n+fn slim_set(n: usize) -> BTreeSet<usize> {\n+    (0..n).collect::<BTreeSet<_>>()\n+}\n+\n #[bench]\n pub fn clone_100(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_100_and_clear(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_100_and_drain_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_100_and_drain_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n@@ -80,13 +84,13 @@ pub fn clone_100_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_100_and_pop_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -96,23 +100,25 @@ pub fn clone_100_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_100_and_remove_all(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_100_and_remove_half(b: &mut Bencher) {\n-    let src = pos(100);\n+    let src = slim_set(100);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=100 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..100).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 100 / 2);\n         set\n@@ -121,25 +127,25 @@ pub fn clone_100_and_remove_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone())\n }\n \n #[bench]\n pub fn clone_10k_and_clear(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().clear())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().drain_filter(|_| true).count())\n }\n \n #[bench]\n pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n@@ -149,13 +155,13 @@ pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| src.clone().into_iter().count())\n }\n \n #[bench]\n pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while set.pop_first().is_some() {}\n@@ -165,23 +171,25 @@ pub fn clone_10k_and_pop_all(b: &mut Bencher) {\n \n #[bench]\n pub fn clone_10k_and_remove_all(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n         while let Some(elt) = set.iter().copied().next() {\n-            set.remove(&elt);\n+            let ok = set.remove(&elt);\n+            debug_assert!(ok);\n         }\n         set\n     });\n }\n \n #[bench]\n pub fn clone_10k_and_remove_half(b: &mut Bencher) {\n-    let src = pos(10_000);\n+    let src = slim_set(10_000);\n     b.iter(|| {\n         let mut set = src.clone();\n-        for i in (2..=10_000 as i32).step_by(2) {\n-            set.remove(&i);\n+        for i in (0..10_000).step_by(2) {\n+            let ok = set.remove(&i);\n+            debug_assert!(ok);\n         }\n         assert_eq!(set.len(), 10_000 / 2);\n         set"}, {"sha": "cff219ec29da063fad699de6514e92d24ba730ae", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -143,7 +143,7 @@ use core::ops::{\n     CoerceUnsized, Deref, DerefMut, DispatchFromDyn, Generator, GeneratorState, Receiver,\n };\n use core::pin::Pin;\n-use core::ptr::{self, NonNull, Unique};\n+use core::ptr::{self, Unique};\n use core::task::{Context, Poll};\n \n use crate::alloc::{self, AllocRef, Global};\n@@ -448,50 +448,6 @@ impl<T: ?Sized> Box<T> {\n         Box::leak(b) as *mut T\n     }\n \n-    /// Consumes the `Box`, returning the wrapped pointer as `NonNull<T>`.\n-    ///\n-    /// After calling this function, the caller is responsible for the\n-    /// memory previously managed by the `Box`. In particular, the\n-    /// caller should properly destroy `T` and release the memory. The\n-    /// easiest way to do so is to convert the `NonNull<T>` pointer\n-    /// into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n-    /// function.\n-    ///\n-    /// Note: this is an associated function, which means that you have\n-    /// to call it as `Box::into_raw_non_null(b)`\n-    /// instead of `b.into_raw_non_null()`. This\n-    /// is so that there is no conflict with a method on the inner type.\n-    ///\n-    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(box_into_raw_non_null)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// let x = Box::new(5);\n-    /// let ptr = Box::into_raw_non_null(x);\n-    ///\n-    /// // Clean up the memory by converting the NonNull pointer back\n-    /// // into a Box and letting the Box be dropped.\n-    /// let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n-    /// ```\n-    #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n-    #[rustc_deprecated(\n-        since = \"1.44.0\",\n-        reason = \"use `Box::leak(b).into()` or `NonNull::from(Box::leak(b))` instead\"\n-    )]\n-    #[inline]\n-    pub fn into_raw_non_null(b: Box<T>) -> NonNull<T> {\n-        // Box is recognized as a \"unique pointer\" by Stacked Borrows, but internally it is a\n-        // raw pointer for the type system. Turning it directly into a raw pointer would not be\n-        // recognized as \"releasing\" the unique pointer to permit aliased raw accesses,\n-        // so all raw pointer methods go through `leak` which creates a (unique)\n-        // mutable reference. Turning *that* to a raw pointer behaves correctly.\n-        Box::leak(b).into()\n-    }\n-\n     #[unstable(\n         feature = \"ptr_internals\",\n         issue = \"none\","}, {"sha": "6184051316ef801584398bd5083d8d2b02229967", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 64, "deletions": 23, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -174,7 +174,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n \n                     {\n                         let out_root = BTreeMap::ensure_is_owned(&mut out_tree.root);\n-                        let mut out_node = out_root.push_level();\n+                        let mut out_node = out_root.push_internal_level();\n                         let mut in_edge = internal.first_edge();\n                         while let Ok(kv) = in_edge.right_kv() {\n                             let (k, v) = kv.into_kv();\n@@ -1080,9 +1080,9 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                                 test_node = parent.forget_type();\n                             }\n                         }\n-                        Err(node) => {\n+                        Err(_) => {\n                             // We are at the top, create a new root node and push there.\n-                            open_node = node.into_root_mut().push_level();\n+                            open_node = root.push_internal_level();\n                             break;\n                         }\n                     }\n@@ -1092,7 +1092,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 let tree_height = open_node.height() - 1;\n                 let mut right_tree = node::Root::new_leaf();\n                 for _ in 0..tree_height {\n-                    right_tree.push_level();\n+                    right_tree.push_internal_level();\n                 }\n                 open_node.push(key, value, right_tree);\n \n@@ -1171,7 +1171,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut right = Self::new();\n         let right_root = Self::ensure_is_owned(&mut right.root);\n         for _ in 0..left_root.height() {\n-            right_root.push_level();\n+            right_root.push_internal_level();\n         }\n \n         {\n@@ -1255,7 +1255,11 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     }\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n         let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n-        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+        DrainFilterInner {\n+            length: &mut self.length,\n+            cur_leaf_edge: front,\n+            emptied_internal_root: false,\n+        }\n     }\n \n     /// Calculates the number of elements if it is incorrect.\n@@ -1625,6 +1629,7 @@ where\n pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+    emptied_internal_root: bool,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n@@ -1665,6 +1670,17 @@ where\n     }\n }\n \n+impl<K, V> Drop for DrainFilterInner<'_, K, V> {\n+    fn drop(&mut self) {\n+        if self.emptied_internal_root {\n+            if let Some(handle) = self.cur_leaf_edge.take() {\n+                let root = handle.into_node().into_root_mut();\n+                root.pop_internal_level();\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n     /// Allow Debug implementations to predict the next element.\n     pub(super) fn peek(&self) -> Option<(&K, &V)> {\n@@ -1681,9 +1697,10 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n-                self.cur_leaf_edge = Some(leaf_edge_location);\n-                return Some((k, v));\n+                let RemoveResult { old_kv, pos, emptied_internal_root } = kv.remove_kv_tracking();\n+                self.cur_leaf_edge = Some(pos);\n+                self.emptied_internal_root |= emptied_internal_root;\n+                return Some(old_kv);\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n         }\n@@ -2477,7 +2494,7 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n                     }\n                 },\n                 Err(root) => {\n-                    root.push_level().push(ins_k, ins_v, ins_edge);\n+                    root.push_internal_level().push(ins_k, ins_v, ins_edge);\n                     return unsafe { &mut *out_ptr };\n                 }\n             }\n@@ -2647,20 +2664,35 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         self.remove_kv().1\n     }\n \n+    // Body of `remove_entry`, separate to keep the above implementations short.\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n-        (old_key, old_val)\n+        let RemoveResult { old_kv, pos, emptied_internal_root } = self.handle.remove_kv_tracking();\n+        let root = pos.into_node().into_root_mut();\n+        if emptied_internal_root {\n+            root.pop_internal_level();\n+        }\n+        old_kv\n     }\n }\n \n+struct RemoveResult<'a, K, V> {\n+    // Key and value removed.\n+    old_kv: (K, V),\n+    // Unique location at the leaf level that the removed KV lopgically collapsed into.\n+    pos: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    // Whether the remove left behind and empty internal root node, that should be removed\n+    // using `pop_internal_level`.\n+    emptied_internal_root: bool,\n+}\n+\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the leaf edge corresponding to that former pair.\n-    fn remove_kv_tracking(\n-        self,\n-    ) -> (K, V, Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+    /// Removes a key/value-pair from the tree, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair. It's possible this leaves\n+    /// an empty internal root node, which the caller should subsequently pop from\n+    /// the map holding the tree. The caller should also decrement the map's length.\n+    fn remove_kv_tracking(self) -> RemoveResult<'a, K, V> {\n         let (mut pos, old_key, old_val, was_internal) = match self.force() {\n             Leaf(leaf) => {\n                 let (hole, old_key, old_val) = leaf.remove();\n@@ -2689,6 +2721,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n         };\n \n         // Handle underflow\n+        let mut emptied_internal_root = false;\n         let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n         let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n@@ -2709,8 +2742,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n \n                     let parent = edge.into_node();\n                     if parent.len() == 0 {\n-                        // We must be at the root\n-                        parent.into_root_mut().pop_level();\n+                        // This empty parent must be the root, and should be popped off the tree.\n+                        emptied_internal_root = true;\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n@@ -2737,15 +2770,15 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n             pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n         }\n \n-        (old_key, old_val, pos)\n+        RemoveResult { old_kv: (old_key, old_val), pos, emptied_internal_root }\n     }\n }\n \n impl<K, V> node::Root<K, V> {\n     /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n     fn fix_top(&mut self) {\n         while self.height() > 0 && self.as_ref().len() == 0 {\n-            self.pop_level();\n+            self.pop_internal_level();\n         }\n     }\n \n@@ -2817,8 +2850,16 @@ fn handle_underfull_node<K, V>(\n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n         Err(parent) => {\n-            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n-            (false, right)\n+            match parent.right_kv() {\n+                Ok(right) => (false, right),\n+                Err(_) => {\n+                    // The underfull node has an empty parent, so it is the only child\n+                    // of an empty root. It is destined to become the new root, thus\n+                    // allowed to be underfull. The empty parent should be removed later\n+                    // by `pop_internal_level`.\n+                    return AtRoot;\n+                }\n+            }\n         }\n     };\n "}, {"sha": "0dcb593096467be93aa45c28839f86d143939fc3", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -19,7 +19,7 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::E\n                 Ok(internal_kv) => return Ok(internal_kv),\n                 Err(last_edge) => match last_edge.into_node().ascend() {\n                     Ok(parent_edge) => parent_edge.forget_node_type(),\n-                    Err(root) => return Err(root.forget_type()),\n+                    Err(root) => return Err(root),\n                 },\n             }\n         }\n@@ -40,7 +40,7 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::E\n                 Ok(internal_kv) => return Ok(internal_kv),\n                 Err(last_edge) => match last_edge.into_node().ascend() {\n                     Ok(parent_edge) => parent_edge.forget_node_type(),\n-                    Err(root) => return Err(root.forget_type()),\n+                    Err(root) => return Err(root),\n                 },\n             }\n         }"}, {"sha": "b767d9ebed72303cdfc03d05542d5caa519bfb15", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -191,8 +191,9 @@ impl<K, V> Root<K, V> {\n     }\n \n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n-    /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n-    pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n+    /// new node the root. This increases the height by 1 and is the opposite of\n+    /// `pop_internal_level`.\n+    pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n@@ -213,11 +214,12 @@ impl<K, V> Root<K, V> {\n         ret\n     }\n \n-    /// Removes the root node, using its first child as the new root. This cannot be called when\n-    /// the tree consists only of a leaf node. As it is intended only to be called when the root\n-    /// has only one edge, no cleanup is done on any of the other children of the root.\n-    /// This decreases the height by 1 and is the opposite of `push_level`.\n-    pub fn pop_level(&mut self) {\n+    /// Removes the internal root node, using its first child as the new root.\n+    /// As it is intended only to be called when the root has only one child,\n+    /// no cleanup is done on any of the other children of the root.\n+    /// This decreases the height by 1 and is the opposite of `push_internal_level`.\n+    /// Panics if there is no internal level, i.e. if the root is a leaf.\n+    pub fn pop_internal_level(&mut self) {\n         assert!(self.height > 0);\n \n         let top = self.node.ptr;\n@@ -305,12 +307,6 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         self.height\n     }\n \n-    /// Removes any static information about whether this node is a `Leaf` or an\n-    /// `Internal` node.\n-    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n-        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n-    }\n-\n     /// Temporarily takes out another, immutable reference to the same node.\n     fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n@@ -466,12 +462,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_val_slice(self) -> &'a [V] {\n         unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n-\n-    fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        // SAFETY: equivalent to reborrow() except not requiring Type: 'a\n-        let k = unsafe { ptr::read(&self) };\n-        (k.into_key_slice(), self.into_val_slice())\n-    }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n@@ -980,10 +970,9 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marke\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Immut<'a>, K, V, NodeType>, marker::KV> {\n     pub fn into_kv(self) -> (&'a K, &'a V) {\n-        unsafe {\n-            let (keys, vals) = self.node.into_slices();\n-            (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx))\n-        }\n+        let keys = self.node.into_key_slice();\n+        let vals = self.node.into_val_slice();\n+        unsafe { (keys.get_unchecked(self.idx), vals.get_unchecked(self.idx)) }\n     }\n }\n \n@@ -1362,6 +1351,20 @@ unsafe fn move_edges<K, V>(\n     }\n }\n \n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Leaf> {\n+    /// Removes any static information asserting that this node is a `Leaf` node.\n+    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+    }\n+}\n+\n+impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n+    /// Removes any static information asserting that this node is an `Internal` node.\n+    pub fn forget_type(self) -> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n+        NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n+    }\n+}\n+\n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     pub fn forget_node_type(\n         self,"}, {"sha": "02a746f0e24880893ff89f1983bada892057ae41", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 10, "deletions": 35, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1110,32 +1110,17 @@ impl<T> IterMut<'_, T> {\n     /// Inserts the given element just after the element most recently returned by `.next()`.\n     /// The inserted element does not appear in the iteration.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(linked_list_extras)]\n-    ///\n-    /// use std::collections::LinkedList;\n-    ///\n-    /// let mut list: LinkedList<_> = vec![1, 3, 4].into_iter().collect();\n-    ///\n-    /// {\n-    ///     let mut it = list.iter_mut();\n-    ///     assert_eq!(it.next().unwrap(), &1);\n-    ///     // insert `2` after `1`\n-    ///     it.insert_next(2);\n-    /// }\n-    /// {\n-    ///     let vec: Vec<_> = list.into_iter().collect();\n-    ///     assert_eq!(vec, [1, 2, 3, 4]);\n-    /// }\n-    /// ```\n+    /// This method will be removed soon.\n     #[inline]\n     #[unstable(\n         feature = \"linked_list_extras\",\n         reason = \"this is probably better handled by a cursor type -- we'll see\",\n         issue = \"27794\"\n     )]\n+    #[rustc_deprecated(\n+        reason = \"Deprecated in favor of CursorMut methods. This method will be removed soon.\",\n+        since = \"1.47.0\"\n+    )]\n     pub fn insert_next(&mut self, element: T) {\n         match self.head {\n             // `push_back` is okay with aliasing `element` references\n@@ -1163,27 +1148,17 @@ impl<T> IterMut<'_, T> {\n \n     /// Provides a reference to the next element, without changing the iterator.\n     ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(linked_list_extras)]\n-    ///\n-    /// use std::collections::LinkedList;\n-    ///\n-    /// let mut list: LinkedList<_> = vec![1, 2, 3].into_iter().collect();\n-    ///\n-    /// let mut it = list.iter_mut();\n-    /// assert_eq!(it.next().unwrap(), &1);\n-    /// assert_eq!(it.peek_next().unwrap(), &2);\n-    /// // We just peeked at 2, so it was not consumed from the iterator.\n-    /// assert_eq!(it.next().unwrap(), &2);\n-    /// ```\n+    /// This method will be removed soon.\n     #[inline]\n     #[unstable(\n         feature = \"linked_list_extras\",\n         reason = \"this is probably better handled by a cursor type -- we'll see\",\n         issue = \"27794\"\n     )]\n+    #[rustc_deprecated(\n+        reason = \"Deprecated in favor of CursorMut methods. This method will be removed soon.\",\n+        since = \"1.47.0\"\n+    )]\n     pub fn peek_next(&mut self) -> Option<&mut T> {\n         if self.len == 0 {\n             None"}, {"sha": "ad643a7bdf1941ad15e2c65dca218cf8e0f80a9f", "filename": "library/alloc/src/collections/linked_list/tests.rs", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list%2Ftests.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -153,33 +153,6 @@ fn test_clone_from() {\n     }\n }\n \n-#[test]\n-fn test_insert_prev() {\n-    let mut m = list_from(&[0, 2, 4, 6, 8]);\n-    let len = m.len();\n-    {\n-        let mut it = m.iter_mut();\n-        it.insert_next(-2);\n-        loop {\n-            match it.next() {\n-                None => break,\n-                Some(elt) => {\n-                    it.insert_next(*elt + 1);\n-                    match it.peek_next() {\n-                        Some(x) => assert_eq!(*x, *elt + 2),\n-                        None => assert_eq!(8, *elt),\n-                    }\n-                }\n-            }\n-        }\n-        it.insert_next(0);\n-        it.insert_next(1);\n-    }\n-    check_links(&m);\n-    assert_eq!(m.len(), 3 + len * 2);\n-    assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n-}\n-\n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n fn test_send() {"}, {"sha": "d74f91c752c0407778b18520da2a7d335764df54", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -107,7 +107,8 @@ fn test_insert() {\n     let cap = tester.capacity();\n \n     // len is the length *after* insertion\n-    for len in 1..cap {\n+    let minlen = if cfg!(miri) { cap - 1 } else { 1 }; // Miri is too slow\n+    for len in minlen..cap {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n         for tail_pos in 0..cap {\n@@ -221,7 +222,8 @@ fn test_remove() {\n     let cap = tester.capacity();\n \n     // len is the length *after* removal\n-    for len in 0..cap - 1 {\n+    let minlen = if cfg!(miri) { cap - 2 } else { 0 }; // Miri is too slow\n+    for len in minlen..cap - 1 {\n         // 0, 1, 2, .., len - 1\n         let expected = (0..).take(len).collect::<VecDeque<_>>();\n         for tail_pos in 0..cap {\n@@ -251,7 +253,8 @@ fn test_range() {\n     let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n \n     let cap = tester.capacity();\n-    for len in 0..=cap {\n+    let minlen = if cfg!(miri) { cap - 1 } else { 0 }; // Miri is too slow\n+    for len in minlen..=cap {\n         for tail in 0..=cap {\n             for start in 0..=len {\n                 for end in start..=len {\n@@ -384,7 +387,8 @@ fn test_split_off() {\n     let cap = tester.capacity();\n \n     // len is the length *before* splitting\n-    for len in 0..cap {\n+    let minlen = if cfg!(miri) { cap - 1 } else { 0 }; // Miri is too slow\n+    for len in minlen..cap {\n         // index to split at\n         for at in 0..=len {\n             // 0, 1, 2, .., at - 1 (may be empty)\n@@ -495,8 +499,9 @@ fn test_vec_from_vecdeque() {\n fn test_clone_from() {\n     let m = vec![1; 8];\n     let n = vec![2; 12];\n-    for pfv in 0..8 {\n-        for pfu in 0..8 {\n+    let limit = if cfg!(miri) { 4 } else { 8 }; // Miri is too slow\n+    for pfv in 0..limit {\n+        for pfu in 0..limit {\n             for longer in 0..2 {\n                 let (vr, ur) = if longer == 0 { (&m, &n) } else { (&n, &m) };\n                 let mut v = VecDeque::from(vr.clone());"}, {"sha": "b83b3024295b46178764eebf01c29f017ede49df", "filename": "library/alloc/src/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Ffmt.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -83,7 +83,7 @@\n //! # Formatting Parameters\n //!\n //! Each argument being formatted can be transformed by a number of formatting\n-//! parameters (corresponding to `format_spec` in the syntax above). These\n+//! parameters (corresponding to `format_spec` in [the syntax](#syntax)). These\n //! parameters affect the string representation of what's being formatted.\n //!\n //! ## Width"}, {"sha": "097db30d634cce9d154a045f00acb38f6dba558a", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -69,13 +69,13 @@\n #![warn(deprecated_in_future)]\n #![warn(missing_docs)]\n #![warn(missing_debug_implementations)]\n-#![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n #![deny(unsafe_op_in_unsafe_fn)]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n #![feature(allocator_api)]\n+#![feature(array_chunks)]\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n #![feature(box_patterns)]"}, {"sha": "c0c638292bb598610d418e322e0545e765a0d322", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 12, "deletions": 33, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -645,29 +645,6 @@ impl<T: ?Sized> Rc<T> {\n         unsafe { Self::from_ptr(rc_ptr) }\n     }\n \n-    /// Consumes the `Rc`, returning the wrapped pointer as `NonNull<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(rc_into_raw_non_null)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::rc::Rc;\n-    ///\n-    /// let x = Rc::new(\"hello\".to_owned());\n-    /// let ptr = Rc::into_raw_non_null(x);\n-    /// let deref = unsafe { ptr.as_ref() };\n-    /// assert_eq!(deref, \"hello\");\n-    /// ```\n-    #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n-    #[rustc_deprecated(since = \"1.44.0\", reason = \"use `Rc::into_raw` instead\")]\n-    #[inline]\n-    pub fn into_raw_non_null(this: Self) -> NonNull<T> {\n-        // safe because Rc guarantees its pointer is non-null\n-        unsafe { NonNull::new_unchecked(Rc::into_raw(this) as *mut _) }\n-    }\n-\n     /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n@@ -1713,8 +1690,9 @@ impl<T> Weak<T> {\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n     ///\n-    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n-    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    /// This converts the weak pointer into a raw pointer, while still preserving the ownership of\n+    /// one weak reference (the weak count is not modified by this operation). It can be turned\n+    /// back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n     /// [`as_ptr`] apply.\n@@ -1749,17 +1727,18 @@ impl<T> Weak<T> {\n     /// This can be used to safely get a strong reference (by calling [`upgrade`]\n     /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n     ///\n-    /// It takes ownership of one weak count (with the exception of pointers created by [`new`],\n-    /// as these don't have any corresponding weak count).\n+    /// It takes ownership of one weak reference (with the exception of pointers created by [`new`],\n+    /// as these don't own anything; the method still works on them).\n     ///\n     /// # Safety\n     ///\n-    /// The pointer must have originated from the [`into_raw`]  and must still own its potential\n-    /// weak reference count.\n+    /// The pointer must have originated from the [`into_raw`] and must still own its potential\n+    /// weak reference.\n     ///\n-    /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n-    /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n-    /// by [`new`]).\n+    /// It is allowed for the strong count to be 0 at the time of calling this. Nevertheless, this\n+    /// takes ownership of one weak reference currently represented as a raw pointer (the weak\n+    /// count is not modified by this operation) and therefore it must be paired with a previous\n+    /// call to [`into_raw`].\n     ///\n     /// # Examples\n     ///\n@@ -2120,7 +2099,7 @@ impl<T: ?Sized> Unpin for Rc<T> {}\n ///\n /// - This function is safe for any argument if `T` is sized, and\n /// - if `T` is unsized, the pointer must have appropriate pointer metadata\n-///   aquired from the real instance that you are getting this offset for.\n+///   acquired from the real instance that you are getting this offset for.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Align the unsized value to the end of the `RcBox`.\n     // Because it is ?Sized, it will always be the last field in memory."}, {"sha": "b791c775548cda7f8f81f013ad0f38e566e493da", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -95,6 +95,8 @@ use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+pub use core::slice::ArrayChunks;\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use core::slice::SliceIndex;\n #[stable(feature = \"from_ref\", since = \"1.28.0\")]"}, {"sha": "d7d7b6bd157bc2efc3b9e44bdb8db49c54d1b584", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -2196,6 +2196,9 @@ pub trait ToString {\n /// since `fmt::Write for String` never returns an error itself.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> ToString for T {\n+    // A common guideline is to not inline generic functions. However,\n+    // remove `#[inline]` from this method causes non-negligible regression.\n+    // See <https://github.com/rust-lang/rust/pull/74852> as last attempt try to remove it.\n     #[inline]\n     default fn to_string(&self) -> String {\n         use fmt::Write;"}, {"sha": "7d5f24ec4ad9b2672460546c9f87a63bb53de499", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 12, "deletions": 35, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -646,29 +646,6 @@ impl<T: ?Sized> Arc<T> {\n         }\n     }\n \n-    /// Consumes the `Arc`, returning the wrapped pointer as `NonNull<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(rc_into_raw_non_null)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// use std::sync::Arc;\n-    ///\n-    /// let x = Arc::new(\"hello\".to_owned());\n-    /// let ptr = Arc::into_raw_non_null(x);\n-    /// let deref = unsafe { ptr.as_ref() };\n-    /// assert_eq!(deref, \"hello\");\n-    /// ```\n-    #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n-    #[rustc_deprecated(since = \"1.44.0\", reason = \"use `Arc::into_raw` instead\")]\n-    #[inline]\n-    pub fn into_raw_non_null(this: Self) -> NonNull<T> {\n-        // safe because Arc guarantees its pointer is non-null\n-        unsafe { NonNull::new_unchecked(Arc::into_raw(this) as *mut _) }\n-    }\n-\n     /// Creates a new [`Weak`][weak] pointer to this allocation.\n     ///\n     /// [weak]: struct.Weak.html\n@@ -1483,8 +1460,9 @@ impl<T> Weak<T> {\n \n     /// Consumes the `Weak<T>` and turns it into a raw pointer.\n     ///\n-    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n-    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    /// This converts the weak pointer into a raw pointer, while still preserving the ownership of\n+    /// one weak reference (the weak count is not modified by this operation). It can be turned\n+    /// back into the `Weak<T>` with [`from_raw`].\n     ///\n     /// The same restrictions of accessing the target of the pointer as with\n     /// [`as_ptr`] apply.\n@@ -1514,24 +1492,23 @@ impl<T> Weak<T> {\n         result\n     }\n \n-    /// Converts a raw pointer previously created by [`into_raw`] back into\n-    /// `Weak<T>`.\n+    /// Converts a raw pointer previously created by [`into_raw`] back into `Weak<T>`.\n     ///\n     /// This can be used to safely get a strong reference (by calling [`upgrade`]\n     /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n     ///\n-    /// It takes ownership of one weak count (with the exception of pointers created by [`new`],\n-    /// as these don't have any corresponding weak count).\n+    /// It takes ownership of one weak reference (with the exception of pointers created by [`new`],\n+    /// as these don't own anything; the method still works on them).\n     ///\n     /// # Safety\n     ///\n     /// The pointer must have originated from the [`into_raw`] and must still own its potential\n-    /// weak reference count.\n-    ///\n-    /// It is allowed for the strong count to be 0 at the time of calling this, but the weak count\n-    /// must be non-zero or the pointer must have originated from a dangling `Weak<T>` (one created\n-    /// by [`new`]).\n+    /// weak reference.\n     ///\n+    /// It is allowed for the strong count to be 0 at the time of calling this. Nevertheless, this\n+    /// takes ownership of one weak reference currently represented as a raw pointer (the weak\n+    /// count is not modified by this operation) and therefore it must be paired with a previous\n+    /// call to [`into_raw`].\n     /// # Examples\n     ///\n     /// ```\n@@ -2276,7 +2253,7 @@ impl<T: ?Sized> Unpin for Arc<T> {}\n ///\n /// - This function is safe for any argument if `T` is sized, and\n /// - if `T` is unsized, the pointer must have appropriate pointer metadata\n-///   aquired from the real instance that you are getting this offset for.\n+///   acquired from the real instance that you are getting this offset for.\n unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n     // Align the unsized value to the end of the `ArcInner`.\n     // Because it is `?Sized`, it will always be the last field in memory."}, {"sha": "786d1b6ba82f2fd894965c5d3a0b650ee944f53d", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -65,7 +65,7 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n-use core::mem::{self, ManuallyDrop};\n+use core::mem::{self, ManuallyDrop, MaybeUninit};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Index, IndexMut, RangeBounds};\n use core::ptr::{self, NonNull};\n@@ -1510,20 +1510,59 @@ impl<T> Vec<T> {\n     /// Simple usage:\n     ///\n     /// ```\n-    /// #![feature(vec_leak)]\n-    ///\n     /// let x = vec![1, 2, 3];\n-    /// let static_ref: &'static mut [usize] = Vec::leak(x);\n+    /// let static_ref: &'static mut [usize] = x.leak();\n     /// static_ref[0] += 1;\n     /// assert_eq!(static_ref, &[2, 2, 3]);\n     /// ```\n-    #[unstable(feature = \"vec_leak\", issue = \"62195\")]\n+    #[stable(feature = \"vec_leak\", since = \"1.47.0\")]\n     #[inline]\n-    pub fn leak<'a>(vec: Vec<T>) -> &'a mut [T]\n+    pub fn leak<'a>(self) -> &'a mut [T]\n     where\n         T: 'a, // Technically not needed, but kept to be explicit.\n     {\n-        Box::leak(vec.into_boxed_slice())\n+        Box::leak(self.into_boxed_slice())\n+    }\n+\n+    /// Returns the remaining spare capacity of the vector as a slice of\n+    /// `MaybeUninit<T>`.\n+    ///\n+    /// The returned slice can be used to fill the vector with data (e.g. by\n+    /// reading from a file) before marking the data as initialized using the\n+    /// [`set_len`] method.\n+    ///\n+    /// [`set_len`]: #method.set_len\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_spare_capacity, maybe_uninit_extra)]\n+    ///\n+    /// // Allocate vector big enough for 10 elements.\n+    /// let mut v = Vec::with_capacity(10);\n+    ///\n+    /// // Fill in the first 3 elements.\n+    /// let uninit = v.spare_capacity_mut();\n+    /// uninit[0].write(0);\n+    /// uninit[1].write(1);\n+    /// uninit[2].write(2);\n+    ///\n+    /// // Mark the first 3 elements of the vector as being initialized.\n+    /// unsafe {\n+    ///     v.set_len(3);\n+    /// }\n+    ///\n+    /// assert_eq!(&v, &[0, 1, 2]);\n+    /// ```\n+    #[unstable(feature = \"vec_spare_capacity\", issue = \"75017\")]\n+    #[inline]\n+    pub fn spare_capacity_mut(&mut self) -> &mut [MaybeUninit<T>] {\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                self.as_mut_ptr().add(self.len) as *mut MaybeUninit<T>,\n+                self.buf.capacity() - self.len,\n+            )\n+        }\n     }\n }\n "}, {"sha": "851ca17a365484370abe8d14971221533330ac84", "filename": "library/alloc/tests/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fboxed.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -37,7 +37,7 @@ fn box_clone_and_clone_from_equivalence() {\n /// This test might give a false positive in case the box realocates, but the alocator keeps the\n /// original pointer.\n ///\n-/// On the other hand it won't give a false negative, if it fails than the memory was definitly not\n+/// On the other hand it won't give a false negative, if it fails than the memory was definitely not\n /// reused\n #[test]\n fn box_clone_from_ptr_stability() {"}, {"sha": "fa20a46671591f4aef2c91dc1735ffc533d5a058", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -6,6 +6,7 @@\n #![feature(map_first_last)]\n #![feature(new_uninit)]\n #![feature(pattern)]\n+#![feature(str_split_once)]\n #![feature(trusted_len)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]"}, {"sha": "147f7f7d0c72956156c39fbaea656556ddb62994", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1721,8 +1721,8 @@ fn panic_safe() {\n \n     let mut rng = thread_rng();\n \n-    // Miri is too slow\n-    let lens = if cfg!(miri) { (1..10).chain(20..21) } else { (1..20).chain(70..MAX_LEN) };\n+    // Miri is too slow (but still need to `chain` to make the types match)\n+    let lens = if cfg!(miri) { (1..10).chain(0..0) } else { (1..20).chain(70..MAX_LEN) };\n     let moduli: &[u32] = if cfg!(miri) { &[5] } else { &[5, 20, 50] };\n \n     for len in lens {"}, {"sha": "b20cf076aca3cac5dacea42cfc143ea5525b93fd", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1318,6 +1318,30 @@ fn test_rsplitn() {\n     assert_eq!(split, [\"mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\"]);\n }\n \n+#[test]\n+fn test_split_once() {\n+    assert_eq!(\"\".split_once(\"->\"), None);\n+    assert_eq!(\"-\".split_once(\"->\"), None);\n+    assert_eq!(\"->\".split_once(\"->\"), Some((\"\", \"\")));\n+    assert_eq!(\"a->\".split_once(\"->\"), Some((\"a\", \"\")));\n+    assert_eq!(\"->b\".split_once(\"->\"), Some((\"\", \"b\")));\n+    assert_eq!(\"a->b\".split_once(\"->\"), Some((\"a\", \"b\")));\n+    assert_eq!(\"a->b->c\".split_once(\"->\"), Some((\"a\", \"b->c\")));\n+    assert_eq!(\"---\".split_once(\"--\"), Some((\"\", \"-\")));\n+}\n+\n+#[test]\n+fn test_rsplit_once() {\n+    assert_eq!(\"\".rsplit_once(\"->\"), None);\n+    assert_eq!(\"-\".rsplit_once(\"->\"), None);\n+    assert_eq!(\"->\".rsplit_once(\"->\"), Some((\"\", \"\")));\n+    assert_eq!(\"a->\".rsplit_once(\"->\"), Some((\"a\", \"\")));\n+    assert_eq!(\"->b\".rsplit_once(\"->\"), Some((\"\", \"b\")));\n+    assert_eq!(\"a->b\".rsplit_once(\"->\"), Some((\"a\", \"b\")));\n+    assert_eq!(\"a->b->c\".rsplit_once(\"->\"), Some((\"a->b\", \"c\")));\n+    assert_eq!(\"---\".rsplit_once(\"--\"), Some((\"-\", \"\")));\n+}\n+\n #[test]\n fn test_split_whitespace() {\n     let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "4083a90168d605b682ba166a0c01f86b3384e474", "filename": "library/backtrace", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fbacktrace?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -0,0 +1 @@\n+Subproject commit 4083a90168d605b682ba166a0c01f86b3384e474"}, {"sha": "b28471337c6be929b53a64eab7bf056a3c9409f4", "filename": "library/core/src/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fany.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -435,7 +435,7 @@ impl TypeId {\n     /// assert_eq!(is_string(&\"cookie monster\".to_string()), true);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"41875\")]\n+    #[rustc_const_stable(feature = \"const_type_id\", since = \"1.46.0\")]\n     pub const fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId { t: intrinsics::type_id::<T>() }\n     }"}, {"sha": "44b86438f2a89534932e1a40075e1100bb782065", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1004,11 +1004,13 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::size_of_val`](../../std/mem/fn.size_of_val.html).\n+    #[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n     /// The required alignment of the referenced value.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::mem::align_of_val`](../../std/mem/fn.align_of_val.html).\n+    #[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n@@ -1024,7 +1026,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`std::any::TypeId::of`](../../std/any/struct.TypeId.html#method.of)\n-    #[rustc_const_unstable(feature = \"const_type_id\", issue = \"41875\")]\n+    #[rustc_const_stable(feature = \"const_type_id\", since = \"1.46.0\")]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:"}, {"sha": "fcf5454308b475a73a412bc720bddc4e905d3892", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -61,7 +61,6 @@\n #![warn(deprecated_in_future)]\n #![warn(missing_docs)]\n #![warn(missing_debug_implementations)]\n-#![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n #![feature(allow_internal_unstable)]\n@@ -82,12 +81,15 @@\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n #![feature(const_option)]\n+#![feature(const_precise_live_drops)]\n #![feature(const_ptr_offset)]\n #![feature(const_ptr_offset_from)]\n #![feature(const_raw_ptr_comparison)]\n #![feature(const_result)]\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_slice_ptr_len)]\n+#![feature(const_size_of_val)]\n+#![feature(const_align_of_val)]\n #![feature(const_type_name)]\n #![feature(const_likely)]\n #![feature(const_unreachable_unchecked)]\n@@ -145,12 +147,10 @@\n #![feature(maybe_uninit_slice)]\n #![feature(external_doc)]\n #![feature(associated_type_bounds)]\n-#![feature(const_type_id)]\n #![feature(const_caller_location)]\n #![feature(slice_ptr_get)]\n #![feature(no_niche)] // rust-lang/rust#68303\n #![feature(unsafe_block_in_unsafe_fn)]\n-#![deny(intra_doc_link_resolution_failure)]\n #![deny(unsafe_op_in_unsafe_fn)]\n \n #[prelude_import]"}, {"sha": "cf721b01ce3c681c4090e4ba9d718604158de9fd", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -336,8 +336,8 @@ impl<T> MaybeUninit<T> {\n     /// assert_eq!(x, (0, false));\n     /// ```\n     ///\n-    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n-    /// cannot hold 0 as a valid value.\n+    /// *Incorrect* usage of this function: calling `x.zeroed().assume_init()`\n+    /// when `0` is not a valid bit-pattern for the type:\n     ///\n     /// ```rust,no_run\n     /// use std::mem::MaybeUninit;"}, {"sha": "4e58e118562ef92a082299d74dba4ad92b4b4101", "filename": "library/core/src/mem/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -332,7 +332,8 @@ pub const fn size_of<T>() -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n+#[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\n+pub const fn size_of_val<T: ?Sized>(val: &T) -> usize {\n     intrinsics::size_of_val(val)\n }\n \n@@ -466,9 +467,10 @@ pub const fn align_of<T>() -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n #[allow(deprecated)]\n-pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n-    min_align_of_val(val)\n+pub const fn align_of_val<T: ?Sized>(val: &T) -> usize {\n+    intrinsics::min_align_of_val(val)\n }\n \n /// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to."}, {"sha": "3c7211fe040dcd384226f59d85ebedd29d9ed00c", "filename": "library/core/src/option.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -380,7 +380,8 @@ impl<T> Option<T> {\n     #[inline]\n     #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap(self) -> T {\n+    #[rustc_const_unstable(feature = \"const_option\", issue = \"67441\")]\n+    pub const fn unwrap(self) -> T {\n         match self {\n             Some(val) => val,\n             None => panic!(\"called `Option::unwrap()` on a `None` value\"),"}, {"sha": "93608a1ce4864c8180371146e81e05c7b23c979e", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 148, "deletions": 5, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -680,7 +680,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn windows(&self, size: usize) -> Windows<'_, T> {\n-        assert!(size != 0);\n+        assert_ne!(size, 0);\n         Windows { v: self, size }\n     }\n \n@@ -714,7 +714,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n-        assert!(chunk_size != 0);\n+        assert_ne!(chunk_size, 0);\n         Chunks { v: self, chunk_size }\n     }\n \n@@ -752,7 +752,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<'_, T> {\n-        assert!(chunk_size != 0);\n+        assert_ne!(chunk_size, 0);\n         ChunksMut { v: self, chunk_size }\n     }\n \n@@ -789,7 +789,7 @@ impl<T> [T] {\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<'_, T> {\n-        assert!(chunk_size != 0);\n+        assert_ne!(chunk_size, 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at(len);\n@@ -834,13 +834,52 @@ impl<T> [T] {\n     #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n     #[inline]\n     pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<'_, T> {\n-        assert!(chunk_size != 0);\n+        assert_ne!(chunk_size, 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at_mut(len);\n         ChunksExactMut { v: fst, rem: snd, chunk_size }\n     }\n \n+    /// Returns an iterator over `N` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n+    ///\n+    /// The chunks are slices and do not overlap. If `N` does not divide the length of the\n+    /// slice, then the last up to `N-1` elements will be omitted and can be retrieved\n+    /// from the `remainder` function of the iterator.\n+    ///\n+    /// This method is the const generic equivalent of [`chunks_exact`].\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n+    /// error before this method gets stabilized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_chunks)]\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.array_chunks();\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert!(iter.next().is_none());\n+    /// assert_eq!(iter.remainder(), &['m']);\n+    /// ```\n+    ///\n+    /// [`chunks_exact`]: #method.chunks_exact\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    #[inline]\n+    pub fn array_chunks<const N: usize>(&self) -> ArrayChunks<'_, T, N> {\n+        assert_ne!(N, 0);\n+        let len = self.len() / N;\n+        let (fst, snd) = self.split_at(len * N);\n+        // SAFETY: We cast a slice of `len * N` elements into\n+        // a slice of `len` many `N` elements chunks.\n+        let array_slice: &[[T; N]] = unsafe { from_raw_parts(fst.as_ptr().cast(), len) };\n+        ArrayChunks { iter: array_slice.iter(), rem: snd }\n+    }\n+\n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n     /// of the slice.\n     ///\n@@ -5432,6 +5471,110 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     }\n }\n \n+/// An iterator over a slice in (non-overlapping) chunks (`N` elements at a\n+/// time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// the [`remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`array_chunks`] method on [slices].\n+///\n+/// [`array_chunks`]: ../../std/primitive.slice.html#method.array_chunks\n+/// [`remainder`]: ../../std/slice/struct.ArrayChunks.html#method.remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n+    iter: Iter<'a, [T; N]>,\n+    rem: &'a [T],\n+}\n+\n+impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+    pub fn remainder(&self) -> &'a [T] {\n+        self.rem\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> Clone for ArrayChunks<'_, T, N> {\n+    fn clone(&self) -> Self {\n+        ArrayChunks { iter: self.iter.clone(), rem: self.rem }\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> Iterator for ArrayChunks<'a, T, N> {\n+    type Item = &'a [T; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T; N]> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        self.iter.last()\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunks<'a, T, N> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T; N]> {\n+        self.iter.next_back()\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.iter.nth_back(n)\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> ExactSizeIterator for ArrayChunks<'_, T, N> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, const N: usize> TrustedLen for ArrayChunks<'_, T, N> {}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+impl<T, const N: usize> FusedIterator for ArrayChunks<'_, T, N> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"array_chunks\", issue = \"74985\")]\n+unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n+        unsafe { self.iter.get_unchecked(i) }\n+    }\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n /// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n /// time), starting at the end of the slice.\n ///"}, {"sha": "9d7e38d0e183100b6cd79dbd775dfd39f4dc5852", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -3610,6 +3610,47 @@ impl str {\n         RSplitN(self.splitn(n, pat).0)\n     }\n \n+    /// Splits the string on the first occurrence of the specified delimiter and\n+    /// returns prefix before delimiter and suffix after delimiter.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_split_once)]\n+    ///\n+    /// assert_eq!(\"cfg\".split_once('='), None);\n+    /// assert_eq!(\"cfg=foo\".split_once('='), Some((\"cfg\", \"foo\")));\n+    /// assert_eq!(\"cfg=foo=bar\".split_once('='), Some((\"cfg\", \"foo=bar\")));\n+    /// ```\n+    #[unstable(feature = \"str_split_once\", reason = \"newly added\", issue = \"74773\")]\n+    #[inline]\n+    pub fn split_once<'a, P: Pattern<'a>>(&'a self, delimiter: P) -> Option<(&'a str, &'a str)> {\n+        let (start, end) = delimiter.into_searcher(self).next_match()?;\n+        Some((&self[..start], &self[end..]))\n+    }\n+\n+    /// Splits the string on the last occurrence of the specified delimiter and\n+    /// returns prefix before delimiter and suffix after delimiter.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(str_split_once)]\n+    ///\n+    /// assert_eq!(\"cfg\".rsplit_once('='), None);\n+    /// assert_eq!(\"cfg=foo\".rsplit_once('='), Some((\"cfg\", \"foo\")));\n+    /// assert_eq!(\"cfg=foo=bar\".rsplit_once('='), Some((\"cfg=foo\", \"bar\")));\n+    /// ```\n+    #[unstable(feature = \"str_split_once\", reason = \"newly added\", issue = \"74773\")]\n+    #[inline]\n+    pub fn rsplit_once<'a, P>(&'a self, delimiter: P) -> Option<(&'a str, &'a str)>\n+    where\n+        P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n+    {\n+        let (start, end) = delimiter.into_searcher(self).next_match_back()?;\n+        Some((&self[..start], &self[end..]))\n+    }\n+\n     /// An iterator over the disjoint matches of a pattern within the given string\n     /// slice.\n     ///"}, {"sha": "f31a4a0b7518de4b9af61de602f90b894d52595a", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -2649,7 +2649,8 @@ unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n ///     }\n ///\n ///     pub fn lock(&self) {\n-///         while !self.flag.compare_and_swap(false, true, Ordering::Relaxed) {}\n+///         // Wait until the old value is `false`.\n+///         while self.flag.compare_and_swap(false, true, Ordering::Relaxed) != false {}\n ///         // This fence synchronizes-with store in `unlock`.\n ///         fence(Ordering::Acquire);\n ///     }"}, {"sha": "92057209d8bfdf848ce9f0354ae6ad2ac1372dac", "filename": "library/core/src/task/wake.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -37,6 +37,7 @@ impl RawWaker {\n     /// The `vtable` customizes the behavior of a `Waker` which gets created\n     /// from a `RawWaker`. For each operation on the `Waker`, the associated\n     /// function in the `vtable` of the underlying `RawWaker` will be called.\n+    #[inline]\n     #[rustc_promotable]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     #[rustc_const_stable(feature = \"futures_api\", since = \"1.36.0\")]"}, {"sha": "6b28a815f033ae1889ee36b9c545bacf7b7738a3", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,4 +1,5 @@\n #![feature(alloc_layout_extra)]\n+#![feature(array_chunks)]\n #![feature(bool_to_option)]\n #![feature(bound_cloned)]\n #![feature(box_syntax)]"}, {"sha": "e5656eb204c733ab8933f0ddd21be3463e0b75d8", "filename": "library/core/tests/num/flt2dec/random.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -188,7 +188,7 @@ fn exact_f32_random_equivalence_test() {\n fn exact_f64_random_equivalence_test() {\n     use core::num::flt2dec::strategy::dragon::format_exact as fallback;\n     // Miri is too slow\n-    let n = if cfg!(miri) { 3 } else { 1_000 };\n+    let n = if cfg!(miri) { 2 } else { 1_000 };\n \n     for k in 1..21 {\n         f64_random_equivalence_test("}, {"sha": "7e6c8add3339d2d0052fc800fbbb7ce5e2eeda61", "filename": "library/core/tests/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -2,6 +2,7 @@ use super::super::*;\n use core::num::flt2dec::strategy::grisu::*;\n \n #[test]\n+#[cfg_attr(miri, ignore)] // Miri is too slow\n fn test_cached_power() {\n     assert_eq!(CACHED_POW10.first().unwrap().1, CACHED_POW10_FIRST_E);\n     assert_eq!(CACHED_POW10.last().unwrap().1, CACHED_POW10_LAST_E);"}, {"sha": "42b483f33ba44a2dc1c123d5a070697589bcb8f1", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 94, "deletions": 3, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -473,6 +473,97 @@ fn test_chunks_exact_mut_zip() {\n     assert_eq!(v1, [13, 14, 19, 20, 4]);\n }\n \n+#[test]\n+fn test_array_chunks_infer() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, -4];\n+    let c = v.array_chunks();\n+    for &[a, b, c] in c {\n+        assert_eq!(a + b + c, 3);\n+    }\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n+    let total = v2.array_chunks().map(|&[a, b]| a * b).sum::<i32>();\n+    assert_eq!(total, 2 * 3 + 4 * 5);\n+}\n+\n+#[test]\n+fn test_array_chunks_count() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.array_chunks::<3>();\n+    assert_eq!(c.count(), 2);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.array_chunks::<2>();\n+    assert_eq!(c2.count(), 2);\n+\n+    let v3: &[i32] = &[];\n+    let c3 = v3.array_chunks::<2>();\n+    assert_eq!(c3.count(), 0);\n+}\n+\n+#[test]\n+fn test_array_chunks_nth() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.array_chunks::<2>();\n+    assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n+    let mut c2 = v2.array_chunks::<3>();\n+    assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n+    assert_eq!(c2.next(), None);\n+}\n+\n+#[test]\n+fn test_array_chunks_nth_back() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let mut c = v.array_chunks::<2>();\n+    assert_eq!(c.nth_back(1).unwrap(), &[2, 3]);\n+    assert_eq!(c.next().unwrap(), &[0, 1]);\n+    assert_eq!(c.next(), None);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c2 = v2.array_chunks::<3>();\n+    assert_eq!(c2.nth_back(0).unwrap(), &[0, 1, 2]);\n+    assert_eq!(c2.next(), None);\n+    assert_eq!(c2.next_back(), None);\n+\n+    let v3: &[i32] = &[0, 1, 2, 3, 4];\n+    let mut c3 = v3.array_chunks::<10>();\n+    assert_eq!(c3.nth_back(0), None);\n+}\n+\n+#[test]\n+fn test_array_chunks_last() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    let c = v.array_chunks::<2>();\n+    assert_eq!(c.last().unwrap(), &[4, 5]);\n+\n+    let v2: &[i32] = &[0, 1, 2, 3, 4];\n+    let c2 = v2.array_chunks::<2>();\n+    assert_eq!(c2.last().unwrap(), &[2, 3]);\n+}\n+\n+#[test]\n+fn test_array_chunks_remainder() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4];\n+    let c = v.array_chunks::<2>();\n+    assert_eq!(c.remainder(), &[4]);\n+}\n+\n+#[test]\n+fn test_array_chunks_zip() {\n+    let v1: &[i32] = &[0, 1, 2, 3, 4];\n+    let v2: &[i32] = &[6, 7, 8, 9, 10];\n+\n+    let res = v1\n+        .array_chunks::<2>()\n+        .zip(v2.array_chunks::<2>())\n+        .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n+        .collect::<Vec<_>>();\n+    assert_eq!(res, vec![14, 22]);\n+}\n+\n #[test]\n fn test_rchunks_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n@@ -1267,15 +1358,15 @@ fn sort_unstable() {\n     use core::slice::heapsort;\n     use rand::{rngs::StdRng, seq::SliceRandom, Rng, SeedableRng};\n \n-    // Miri is too slow\n-    let large_range = if cfg!(miri) { 0..0 } else { 500..510 };\n+    // Miri is too slow (but still need to `chain` to make the types match)\n+    let lens = if cfg!(miri) { (2..20).chain(0..0) } else { (2..25).chain(500..510) };\n     let rounds = if cfg!(miri) { 1 } else { 100 };\n \n     let mut v = [0; 600];\n     let mut tmp = [0; 600];\n     let mut rng = StdRng::from_entropy();\n \n-    for len in (2..25).chain(large_range) {\n+    for len in lens {\n         let v = &mut v[0..len];\n         let tmp = &mut tmp[0..len];\n "}, {"sha": "474765d8638116fd6b3740a32842b618fb4210a1", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -22,11 +22,15 @@ profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }\n hashbrown = { version = \"0.6.2\", default-features = false, features = ['rustc-dep-of-std'] }\n \n-[dependencies.backtrace_rs]\n-package = \"backtrace\"\n-version = \"0.3.46\"\n-default-features = false # without the libstd `backtrace` feature, stub out everything\n-features = [ \"rustc-dep-of-std\" ] # enable build support for integrating into libstd\n+# Dependencies of the `backtrace` crate\n+addr2line = { version = \"0.13.0\", optional = true, default-features = false }\n+rustc-demangle = { version = \"0.1.4\", features = ['rustc-dep-of-std'] }\n+miniz_oxide = { version = \"0.4.0\", optional = true, default-features = false }\n+[dependencies.object]\n+version = \"0.20\"\n+optional = true\n+default-features = false\n+features = ['read_core', 'elf', 'macho', 'pe']\n \n [dev-dependencies]\n rand = \"0.7\"\n@@ -45,11 +49,12 @@ wasi = { version = \"0.9.0\", features = ['rustc-dep-of-std'], default-features =\n \n [features]\n backtrace = [\n-  \"backtrace_rs/dbghelp\",          # backtrace/symbolize on MSVC\n-  \"backtrace_rs/libbacktrace\",     # symbolize on most platforms\n-  \"backtrace_rs/libunwind\",        # backtrace on most platforms\n-  \"backtrace_rs/dladdr\",           # symbolize on platforms w/o libbacktrace\n+  \"gimli-symbolize\",\n+  'addr2line/rustc-dep-of-std',\n+  'object/rustc-dep-of-std',\n+  'miniz_oxide/rustc-dep-of-std',\n ]\n+gimli-symbolize = []\n \n panic-unwind = [\"panic_unwind\"]\n profiler = [\"profiler_builtins\"]"}, {"sha": "83073cc77dd1a12354ce6b9e535804e83f33e27e", "filename": "library/std/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fbuild.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -88,4 +88,5 @@ fn main() {\n         println!(\"cargo:rustc-cfg=feature=\\\"restricted-std\\\"\");\n     }\n     println!(\"cargo:rustc-env=STD_ENV_ARCH={}\", env::var(\"CARGO_CFG_TARGET_ARCH\").unwrap());\n+    println!(\"cargo:rustc-cfg=backtrace_in_libstd\");\n }"}, {"sha": "09f83ea5fca81c5eb42c2fa9dfd4218933699c1e", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -91,15 +91,14 @@\n // `Backtrace`, but that's a relatively small price to pay relative to capturing\n // a backtrace or actually symbolizing it.\n \n+use crate::backtrace_rs::{self, BytesOrWideString};\n use crate::env;\n use crate::ffi::c_void;\n use crate::fmt;\n use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n use crate::sync::Mutex;\n use crate::sys_common::backtrace::{lock, output_filename};\n use crate::vec::Vec;\n-use backtrace::BytesOrWideString;\n-use backtrace_rs as backtrace;\n \n /// A captured OS thread stack backtrace.\n ///\n@@ -150,7 +149,7 @@ struct BacktraceFrame {\n }\n \n enum RawFrame {\n-    Actual(backtrace::Frame),\n+    Actual(backtrace_rs::Frame),\n     #[cfg(test)]\n     Fake,\n }\n@@ -197,7 +196,7 @@ impl fmt::Debug for BacktraceSymbol {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"{{ \")?;\n \n-        if let Some(fn_name) = self.name.as_ref().map(|b| backtrace::SymbolName::new(b)) {\n+        if let Some(fn_name) = self.name.as_ref().map(|b| backtrace_rs::SymbolName::new(b)) {\n             write!(fmt, \"fn: \\\"{:#}\\\"\", fn_name)?;\n         } else {\n             write!(fmt, \"fn: <unknown>\")?;\n@@ -223,7 +222,7 @@ impl fmt::Debug for BytesOrWide {\n                 BytesOrWide::Bytes(w) => BytesOrWideString::Bytes(w),\n                 BytesOrWide::Wide(w) => BytesOrWideString::Wide(w),\n             },\n-            backtrace::PrintFmt::Short,\n+            backtrace_rs::PrintFmt::Short,\n             crate::env::current_dir().as_ref().ok(),\n         )\n     }\n@@ -305,7 +304,7 @@ impl Backtrace {\n         let mut frames = Vec::new();\n         let mut actual_start = None;\n         unsafe {\n-            backtrace::trace_unsynchronized(|frame| {\n+            backtrace_rs::trace_unsynchronized(|frame| {\n                 frames.push(BacktraceFrame {\n                     frame: RawFrame::Actual(frame.clone()),\n                     symbols: Vec::new(),\n@@ -356,9 +355,9 @@ impl fmt::Display for Backtrace {\n \n         let full = fmt.alternate();\n         let (frames, style) = if full {\n-            (&capture.frames[..], backtrace::PrintFmt::Full)\n+            (&capture.frames[..], backtrace_rs::PrintFmt::Full)\n         } else {\n-            (&capture.frames[capture.actual_start..], backtrace::PrintFmt::Short)\n+            (&capture.frames[capture.actual_start..], backtrace_rs::PrintFmt::Short)\n         };\n \n         // When printing paths we try to strip the cwd if it exists, otherwise\n@@ -370,7 +369,7 @@ impl fmt::Display for Backtrace {\n             output_filename(fmt, path, style, cwd.as_ref().ok())\n         };\n \n-        let mut f = backtrace::BacktraceFmt::new(fmt, style, &mut print_path);\n+        let mut f = backtrace_rs::BacktraceFmt::new(fmt, style, &mut print_path);\n         f.add_context()?;\n         for frame in frames {\n             let mut f = f.frame();\n@@ -380,7 +379,7 @@ impl fmt::Display for Backtrace {\n                 for symbol in frame.symbols.iter() {\n                     f.print_raw(\n                         frame.frame.ip(),\n-                        symbol.name.as_ref().map(|b| backtrace::SymbolName::new(b)),\n+                        symbol.name.as_ref().map(|b| backtrace_rs::SymbolName::new(b)),\n                         symbol.filename.as_ref().map(|b| match b {\n                             BytesOrWide::Bytes(w) => BytesOrWideString::Bytes(w),\n                             BytesOrWide::Wide(w) => BytesOrWideString::Wide(w),\n@@ -415,7 +414,7 @@ impl Capture {\n                 RawFrame::Fake => unimplemented!(),\n             };\n             unsafe {\n-                backtrace::resolve_frame_unsynchronized(frame, |symbol| {\n+                backtrace_rs::resolve_frame_unsynchronized(frame, |symbol| {\n                     symbols.push(BacktraceSymbol {\n                         name: symbol.name().map(|m| m.as_bytes().to_vec()),\n                         filename: symbol.filename_raw().map(|b| match b {"}, {"sha": "047478fcc855a62294e12ab0099c0aa85a45bb4b", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1574,6 +1574,7 @@ impl AsInner<fs_imp::DirEntry> for DirEntry {\n /// limited to just these cases:\n ///\n /// * `path` points to a directory.\n+/// * The file doesn't exist.\n /// * The user lacks permissions to remove the file.\n ///\n /// # Examples"}, {"sha": "c98008688ab4f078d39f7511e3b522faddb8601a", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1363,7 +1363,7 @@ mod self_upper_keyword {}\n ///\n /// let r1 = &FOO as *const _;\n /// let r2 = &FOO as *const _;\n-/// // With a strictly read-only static, references will have the same adress\n+/// // With a strictly read-only static, references will have the same address\n /// assert_eq!(r1, r2);\n /// // A static item can be used just like a variable in many cases\n /// println!(\"{:?}\", FOO);"}, {"sha": "60eba96bcc0156f8f0357ce1dbb25fc304d5e95d", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -451,7 +451,9 @@ unsafe impl<T, F: Send> Sync for SyncLazy<T, F> where SyncOnceCell<T>: Sync {}\n // auto-derived `Send` impl is OK.\n \n #[unstable(feature = \"once_cell\", issue = \"74465\")]\n-impl<T, F: RefUnwindSafe> RefUnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: RefUnwindSafe {}\n+impl<T, F: UnwindSafe> RefUnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: RefUnwindSafe {}\n+#[unstable(feature = \"once_cell\", issue = \"74465\")]\n+impl<T, F: UnwindSafe> UnwindSafe for SyncLazy<T, F> where SyncOnceCell<T>: UnwindSafe {}\n \n impl<T, F> SyncLazy<T, F> {\n     /// Creates a new lazy value with the given initializing"}, {"sha": "c81b949af656691364182ee2b5b026567eea07e8", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -212,7 +212,6 @@\n #![warn(deprecated_in_future)]\n #![warn(missing_docs)]\n #![warn(missing_debug_implementations)]\n-#![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n #![allow(explicit_outlives_requirements)]\n #![allow(unused_lifetimes)]\n // Tell the compiler to link to either panic_abort or panic_unwind\n@@ -511,6 +510,10 @@ mod panicking;\n // compiler\n pub mod rt;\n \n+#[path = \"../../backtrace/src/lib.rs\"]\n+#[allow(dead_code, unused_attributes)]\n+mod backtrace_rs;\n+\n // Pull in the `std_detect` crate directly into libstd. The contents of\n // `std_detect` are in a different repository: rust-lang/stdarch.\n //"}, {"sha": "a64b43ca3ad45f92a8991659f310f2f538734699", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1265,15 +1265,15 @@ impl Ipv6Addr {\n     /// # See also\n     ///\n     /// - [IETF RFC 4291 section 2.5.6]\n-    /// - [RFC 4291 errata 4406]\n+    /// - [RFC 4291 errata 4406] (which has been rejected but provides useful\n+    ///   insight)\n     /// - [`is_unicast_link_local()`]\n     ///\n     /// [IETF RFC 4291]: https://tools.ietf.org/html/rfc4291\n     /// [IETF RFC 4291 section 2.5.6]: https://tools.ietf.org/html/rfc4291#section-2.5.6\n     /// [`true`]: ../../std/primitive.bool.html\n     /// [RFC 4291 errata 4406]: https://www.rfc-editor.org/errata/eid4406\n     /// [`is_unicast_link_local()`]: ../../std/net/struct.Ipv6Addr.html#method.is_unicast_link_local\n-    ///\n     pub fn is_unicast_link_local_strict(&self) -> bool {\n         (self.segments()[0] & 0xffff) == 0xfe80\n             && (self.segments()[1] & 0xffff) == 0\n@@ -1324,13 +1324,13 @@ impl Ipv6Addr {\n     /// # See also\n     ///\n     /// - [IETF RFC 4291 section 2.4]\n-    /// - [RFC 4291 errata 4406]\n+    /// - [RFC 4291 errata 4406] (which has been rejected but provides useful\n+    ///   insight)\n     ///\n     /// [IETF RFC 4291 section 2.4]: https://tools.ietf.org/html/rfc4291#section-2.4\n     /// [`true`]: ../../std/primitive.bool.html\n     /// [RFC 4291 errata 4406]: https://www.rfc-editor.org/errata/eid4406\n     /// [`is_unicast_link_local_strict()`]: ../../std/net/struct.Ipv6Addr.html#method.is_unicast_link_local_strict\n-    ///\n     pub fn is_unicast_link_local(&self) -> bool {\n         (self.segments()[0] & 0xffc0) == 0xfe80\n     }"}, {"sha": "ab2a60103069d6571179c20c565f5e64800d6f0b", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -171,7 +171,7 @@ fn default_hook(info: &PanicInfo<'_>) {\n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n     let backtrace_env = if panic_count::get() >= 2 {\n-        RustBacktrace::Print(backtrace_rs::PrintFmt::Full)\n+        RustBacktrace::Print(crate::backtrace_rs::PrintFmt::Full)\n     } else {\n         backtrace::rust_backtrace_env()\n     };"}, {"sha": "714ec3e878617adfad8c2308741d9f599d8e2c84", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -81,7 +81,7 @@\n //   see the changes to drop the `Waiter` struct correctly.\n // * There is one place where the two atomics `Once.state_and_queue` and\n //   `Waiter.signaled` come together, and might be reordered by the compiler or\n-//   processor. Because both use Aquire ordering such a reordering is not\n+//   processor. Because both use Acquire ordering such a reordering is not\n //   allowed, so no need for SeqCst.\n \n use crate::cell::Cell;"}, {"sha": "6782d845bb056cf841ed32a00c30e6a4af337319", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -331,6 +331,7 @@ impl OpenOptions {\n         // FIXME: some of these should probably be read-only or write-only...\n         base |= wasi::RIGHTS_FD_ADVISE;\n         base |= wasi::RIGHTS_FD_FDSTAT_SET_FLAGS;\n+        base |= wasi::RIGHTS_FD_FILESTAT_GET;\n         base |= wasi::RIGHTS_FD_FILESTAT_SET_TIMES;\n         base |= wasi::RIGHTS_FD_SEEK;\n         base |= wasi::RIGHTS_FD_SYNC;"}, {"sha": "d86bb60507be2c0d9bd0f410bd3b8048a4d2f052", "filename": "library/std/src/sys/wasm/condvar_atomics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -42,13 +42,13 @@ impl Condvar {\n \n     pub unsafe fn notify_one(&self) {\n         self.cnt.fetch_add(1, SeqCst);\n-        wasm32::atomic_notify(self.ptr(), 1);\n+        wasm32::memory_atomic_notify(self.ptr(), 1);\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n         self.cnt.fetch_add(1, SeqCst);\n-        wasm32::atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n+        wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n@@ -62,7 +62,7 @@ impl Condvar {\n         // wake us up once we're asleep.\n         let ticket = self.cnt.load(SeqCst) as i32;\n         mutex.unlock();\n-        let val = wasm32::i32_atomic_wait(self.ptr(), ticket, -1);\n+        let val = wasm32::memory_atomic_wait32(self.ptr(), ticket, -1);\n         // 0 == woken, 1 == not equal to `ticket`, 2 == timeout (shouldn't happen)\n         debug_assert!(val == 0 || val == 1);\n         mutex.lock();\n@@ -76,7 +76,7 @@ impl Condvar {\n \n         // If the return value is 2 then a timeout happened, so we return\n         // `false` as we weren't actually notified.\n-        let ret = wasm32::i32_atomic_wait(self.ptr(), ticket, nanos as i64) != 2;\n+        let ret = wasm32::memory_atomic_wait32(self.ptr(), ticket, nanos as i64) != 2;\n         mutex.lock();\n         return ret;\n     }"}, {"sha": "4b1a7c9b48141c04632f09560d64cacbeed77f4e", "filename": "library/std/src/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -26,7 +26,7 @@ impl Mutex {\n \n     pub unsafe fn lock(&self) {\n         while !self.try_lock() {\n-            let val = wasm32::i32_atomic_wait(\n+            let val = wasm32::memory_atomic_wait32(\n                 self.ptr(),\n                 1,  // we expect our mutex is locked\n                 -1, // wait infinitely\n@@ -40,7 +40,7 @@ impl Mutex {\n     pub unsafe fn unlock(&self) {\n         let prev = self.locked.swap(0, SeqCst);\n         debug_assert_eq!(prev, 1);\n-        wasm32::atomic_notify(self.ptr(), 1); // wake up one waiter, if any\n+        wasm32::memory_atomic_notify(self.ptr(), 1); // wake up one waiter, if any\n     }\n \n     #[inline]\n@@ -91,7 +91,7 @@ impl ReentrantMutex {\n     pub unsafe fn lock(&self) {\n         let me = thread::my_id();\n         while let Err(owner) = self._try_lock(me) {\n-            let val = wasm32::i32_atomic_wait(self.ptr(), owner as i32, -1);\n+            let val = wasm32::memory_atomic_wait32(self.ptr(), owner as i32, -1);\n             debug_assert!(val == 0 || val == 1);\n         }\n     }\n@@ -130,7 +130,7 @@ impl ReentrantMutex {\n         match *self.recursions.get() {\n             0 => {\n                 self.owner.swap(0, SeqCst);\n-                wasm32::atomic_notify(self.ptr() as *mut i32, 1); // wake up one waiter, if any\n+                wasm32::memory_atomic_notify(self.ptr() as *mut i32, 1); // wake up one waiter, if any\n             }\n             ref mut n => *n -= 1,\n         }"}, {"sha": "95a9230aa7888a4cc5ce474b977d54053f1bbb22", "filename": "library/std/src/sys/wasm/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fthread.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -40,7 +40,7 @@ impl Thread {\n         while nanos > 0 {\n             let amt = cmp::min(i64::MAX as u128, nanos);\n             let mut x = 0;\n-            let val = unsafe { wasm32::i32_atomic_wait(&mut x, 0, amt as i64) };\n+            let val = unsafe { wasm32::memory_atomic_wait32(&mut x, 0, amt as i64) };\n             debug_assert_eq!(val, 2);\n             nanos -= amt;\n         }"}, {"sha": "d386a656e4ffdc896aa93fdceb53060d1c75a71c", "filename": "library/std/src/sys_common/backtrace.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fbacktrace.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,3 +1,4 @@\n+use crate::backtrace_rs::{self, BacktraceFmt, BytesOrWideString, PrintFmt};\n use crate::borrow::Cow;\n /// Common code for printing the backtrace in the same way across the different\n /// supported platforms.\n@@ -9,8 +10,6 @@ use crate::path::{self, Path, PathBuf};\n use crate::sync::atomic::{self, Ordering};\n use crate::sys::mutex::Mutex;\n \n-use backtrace_rs::{BacktraceFmt, BytesOrWideString, PrintFmt};\n-\n /// Max number of frames to print.\n const MAX_NB_FRAMES: usize = 100;\n "}, {"sha": "d6822f9c433bd70f786b157f17beaf64ee28d83a", "filename": "library/stdarch", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstdarch?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1 +1 @@\n-Subproject commit 45340c0e2fdadf2f131ef43cb683b5cafab0ff15\n+Subproject commit d6822f9c433bd70f786b157f17beaf64ee28d83a"}, {"sha": "26cdcfff2a316a5ff80d20ee544b30b639d2e7cb", "filename": "rustfmt.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -14,6 +14,7 @@ ignore = [\n     \"src/test\",\n \n     # do not format submodules\n+    \"library/backtrace\",\n     \"library/stdarch\",\n     \"src/doc/book\",\n     \"src/doc/edition-guide\","}, {"sha": "2f8e9da179afaaedf4795bb106c084f222e879a3", "filename": "src/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,6 +1,6 @@\n This directory contains the source code of the rust project, including:\n - `rustc` and its tests\n-- `libstd`\n+- The bootstrapping build system\n - Various submodules for tools, like rustdoc, rls, etc.\n \n For more information on how various parts of the compiler work, see the [rustc dev guide]."}, {"sha": "4dd71ebade1a416a54f643bd248ccaa530ef2467", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -171,7 +171,9 @@ fn main() {\n         // note: everything below here is unreachable. do not put code that\n         // should run on success, after this block.\n     }\n-    println!(\"\\nDid not run successfully: {}\\n{:?}\\n-------------\", status, cmd);\n+    if verbose > 0 {\n+        println!(\"\\nDid not run successfully: {}\\n{:?}\\n-------------\", status, cmd);\n+    }\n \n     if let Some(mut on_fail) = on_fail {\n         on_fail.status().expect(\"Could not run the on_fail command\");"}, {"sha": "144e146685fb20658d051a1a92a9da41a4e5644a", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 41, "deletions": 19, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -232,7 +232,7 @@ impl StepDescription {\n                 }\n \n                 if !attempted_run {\n-                    panic!(\"Error: no rules matched {}.\", path.display());\n+                    panic!(\"error: no rules matched {}\", path.display());\n                 }\n             }\n         }\n@@ -501,16 +501,7 @@ impl<'a> Builder<'a> {\n             _ => return None,\n         };\n \n-        let builder = Builder {\n-            build,\n-            top_stage: build.config.stage.unwrap_or(2),\n-            kind,\n-            cache: Cache::new(),\n-            stack: RefCell::new(Vec::new()),\n-            time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n-            paths: vec![],\n-        };\n-\n+        let builder = Self::new_internal(build, kind, vec![]);\n         let builder = &builder;\n         let mut should_run = ShouldRun::new(builder);\n         for desc in Builder::get_step_descriptions(builder.kind) {\n@@ -535,6 +526,32 @@ impl<'a> Builder<'a> {\n         Some(help)\n     }\n \n+    fn new_internal(build: &Build, kind: Kind, paths: Vec<PathBuf>) -> Builder<'_> {\n+        let top_stage = if let Some(explicit_stage) = build.config.stage {\n+            explicit_stage\n+        } else {\n+            // See https://github.com/rust-lang/compiler-team/issues/326\n+            match kind {\n+                Kind::Doc => 0,\n+                Kind::Build | Kind::Test => 1,\n+                Kind::Bench | Kind::Dist | Kind::Install => 2,\n+                // These are all bootstrap tools, which don't depend on the compiler.\n+                // The stage we pass shouldn't matter, but use 0 just in case.\n+                Kind::Check | Kind::Clippy | Kind::Fix | Kind::Run | Kind::Format => 0,\n+            }\n+        };\n+\n+        Builder {\n+            build,\n+            top_stage,\n+            kind,\n+            cache: Cache::new(),\n+            stack: RefCell::new(Vec::new()),\n+            time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n+            paths,\n+        }\n+    }\n+\n     pub fn new(build: &Build) -> Builder<'_> {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n@@ -550,15 +567,20 @@ impl<'a> Builder<'a> {\n             Subcommand::Format { .. } | Subcommand::Clean { .. } => panic!(),\n         };\n \n-        Builder {\n-            build,\n-            top_stage: build.config.stage.unwrap_or(2),\n-            kind,\n-            cache: Cache::new(),\n-            stack: RefCell::new(Vec::new()),\n-            time_spent_on_dependencies: Cell::new(Duration::new(0, 0)),\n-            paths: paths.to_owned(),\n+        let this = Self::new_internal(build, kind, paths.to_owned());\n+\n+        // CI should always run stage 2 builds, unless it specifically states otherwise\n+        #[cfg(not(test))]\n+        if build.config.stage.is_none() && build.ci_env != crate::CiEnv::None {\n+            match kind {\n+                Kind::Test | Kind::Doc | Kind::Build | Kind::Bench | Kind::Dist | Kind::Install => {\n+                    assert_eq!(this.top_stage, 2)\n+                }\n+                Kind::Check | Kind::Clippy | Kind::Fix | Kind::Run | Kind::Format => {}\n+            }\n         }\n+\n+        this\n     }\n \n     pub fn execute_cli(&self) {"}, {"sha": "111971534ba5e903026bb9b1b60a973727cfde43", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 556, "deletions": 459, "changes": 1015, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -2,8 +2,6 @@ use super::*;\n use crate::config::{Config, TargetSelection};\n use std::thread;\n \n-use pretty_assertions::assert_eq;\n-\n fn configure(host: &[&str], target: &[&str]) -> Config {\n     let mut config = Config::default_opts();\n     // don't save toolstates\n@@ -35,463 +33,562 @@ fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n     v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n }\n \n-#[test]\n-fn dist_baseline() {\n-    let build = Build::new(configure(&[], &[]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-\n-    assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n-    assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    // Make sure rustdoc is only built once.\n-    assert_eq!(\n-        first(builder.cache.all::<tool::Rustdoc>()),\n-        &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n-    );\n-}\n-\n-#[test]\n-fn dist_with_targets() {\n-    let build = Build::new(configure(&[], &[\"B\"]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-}\n-\n-#[test]\n-fn dist_with_hosts() {\n-    let build = Build::new(configure(&[\"B\"], &[]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-}\n-\n-#[test]\n-fn dist_only_cross_host() {\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let mut build = Build::new(configure(&[\"B\"], &[]));\n-    build.config.docs = false;\n-    build.config.extended = true;\n-    build.hosts = vec![b];\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[dist::Rustc { compiler: Compiler { host: b, stage: 2 } },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Rustc>()),\n-        &[\n-            compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n-        ]\n-    );\n-}\n-\n-#[test]\n-fn dist_with_targets_and_hosts() {\n-    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let c = TargetSelection::from_user(\"C\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-}\n-\n-#[test]\n-fn dist_with_target_flag() {\n-    let mut config = configure(&[\"B\"], &[\"C\"]);\n-    config.skip_only_host_steps = true; // as-if --target=C was passed\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let c = TargetSelection::from_user(\"C\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n-}\n-\n-#[test]\n-fn dist_with_same_targets_and_hosts() {\n-    let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Docs>()),\n-        &[dist::Docs { host: a }, dist::Docs { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Mingw>()),\n-        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Rustc>()),\n-        &[\n-            dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n-            dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<dist::Std>()),\n-        &[\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-        ]\n-    );\n-    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Std>()),\n-        &[\n-            compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Assemble>()),\n-        &[\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n-            compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-}\n-\n-#[test]\n-fn build_default() {\n-    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let c = TargetSelection::from_user(\"C\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Std>()),\n-        &[\n-            compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n-        ]\n-    );\n-    assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Rustc>()),\n-        &[\n-            compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: b },\n-            compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: b },\n-        ]\n-    );\n-}\n-\n-#[test]\n-fn build_with_target_flag() {\n-    let mut config = configure(&[\"B\"], &[\"C\"]);\n-    config.skip_only_host_steps = true;\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-    let a = TargetSelection::from_user(\"A\");\n-    let b = TargetSelection::from_user(\"B\");\n-    let c = TargetSelection::from_user(\"C\");\n-\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Std>()),\n-        &[\n-            compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n-            compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n-            compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n-            compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Assemble>()),\n-        &[\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n-            compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n-            compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n-        ]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Rustc>()),\n-        &[\n-            compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n-            compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n-        ]\n-    );\n-}\n-\n-#[test]\n-fn test_with_no_doc_stage0() {\n-    let mut config = configure(&[], &[]);\n-    config.stage = Some(0);\n-    config.cmd = Subcommand::Test {\n-        paths: vec![\"library/std\".into()],\n-        test_args: vec![],\n-        rustc_args: vec![],\n-        fail_fast: true,\n-        doc_tests: DocTests::No,\n-        bless: false,\n-        compare_mode: None,\n-        rustfix_coverage: false,\n-        pass: None,\n-    };\n-\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-\n-    let host = TargetSelection::from_user(\"A\");\n-\n-    builder\n-        .run_step_descriptions(&[StepDescription::from::<test::Crate>()], &[\"library/std\".into()]);\n-\n-    // Ensure we don't build any compiler artifacts.\n-    assert!(!builder.cache.contains::<compile::Rustc>());\n-    assert_eq!(\n-        first(builder.cache.all::<test::Crate>()),\n-        &[test::Crate {\n-            compiler: Compiler { host, stage: 0 },\n-            target: host,\n-            mode: Mode::Std,\n-            test_kind: test::TestKind::Test,\n-            krate: INTERNER.intern_str(\"std\"),\n-        },]\n-    );\n-}\n-\n-#[test]\n-fn test_exclude() {\n-    let mut config = configure(&[], &[]);\n-    config.exclude = vec![\"src/tools/tidy\".into()];\n-    config.cmd = Subcommand::Test {\n-        paths: Vec::new(),\n-        test_args: Vec::new(),\n-        rustc_args: Vec::new(),\n-        fail_fast: true,\n-        doc_tests: DocTests::No,\n-        bless: false,\n-        compare_mode: None,\n-        rustfix_coverage: false,\n-        pass: None,\n-    };\n-\n-    let build = Build::new(config);\n-    let builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-\n-    // Ensure we have really excluded tidy\n-    assert!(!builder.cache.contains::<test::Tidy>());\n-\n-    // Ensure other tests are not affected.\n-    assert!(builder.cache.contains::<test::RustdocUi>());\n-}\n-\n-#[test]\n-fn doc_default() {\n-    let mut config = configure(&[], &[]);\n-    config.compiler_docs = true;\n-    config.cmd = Subcommand::Doc { paths: Vec::new(), open: false };\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n-    let a = TargetSelection::from_user(\"A\");\n-\n-    // error_index_generator uses stage 1 to share rustdoc artifacts with the\n-    // rustdoc tool.\n-    assert_eq!(\n-        first(builder.cache.all::<doc::ErrorIndex>()),\n-        &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<tool::ErrorIndex>()),\n-        &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n-    );\n-    // This is actually stage 1, but Rustdoc::run swaps out the compiler with\n-    // stage minus 1 if --stage is not 0. Very confusing!\n-    assert_eq!(\n-        first(builder.cache.all::<tool::Rustdoc>()),\n-        &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n-    );\n+mod defaults {\n+    use super::{configure, first};\n+    use crate::builder::*;\n+    use crate::Config;\n+    use pretty_assertions::assert_eq;\n+\n+    #[test]\n+    fn build_default() {\n+        let build = Build::new(configure(&[], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+            ]\n+        );\n+        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        // Make sure rustdoc is only built once.\n+        assert_eq!(\n+            first(builder.cache.all::<tool::Rustdoc>()),\n+            // Recall that rustdoc stages are off-by-one\n+            // - this is the compiler it's _linked_ to, not built with.\n+            &[tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } }],\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },]\n+        );\n+    }\n+\n+    #[test]\n+    fn build_stage_0() {\n+        let config = Config { stage: Some(0), ..configure(&[], &[]) };\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },]\n+        );\n+        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert_eq!(\n+            first(builder.cache.all::<tool::Rustdoc>()),\n+            // This is the beta rustdoc.\n+            // Add an assert here to make sure this is the only rustdoc built.\n+            &[tool::Rustdoc { compiler: Compiler { host: a, stage: 0 } }],\n+        );\n+        assert!(builder.cache.all::<compile::Rustc>().is_empty());\n+    }\n+\n+    #[test]\n+    fn doc_default() {\n+        let mut config = configure(&[], &[]);\n+        config.compiler_docs = true;\n+        config.cmd = Subcommand::Doc { paths: Vec::new(), open: false };\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n+        let a = TargetSelection::from_user(\"A\");\n+\n+        // error_index_generator uses stage 0 to share rustdoc artifacts with the\n+        // rustdoc tool.\n+        assert_eq!(\n+            first(builder.cache.all::<doc::ErrorIndex>()),\n+            &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 0 }, target: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<tool::ErrorIndex>()),\n+            &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 0 } }]\n+        );\n+        // docs should be built with the beta compiler, not with the stage0 artifacts.\n+        // recall that rustdoc is off-by-one: `stage` is the compiler rustdoc is _linked_ to,\n+        // not the one it was built by.\n+        assert_eq!(\n+            first(builder.cache.all::<tool::Rustdoc>()),\n+            &[tool::Rustdoc { compiler: Compiler { host: a, stage: 0 } },]\n+        );\n+    }\n }\n \n-//FIXME(mark-i-m): reinstate this test when things are fixed...\n-//#[test]\n-#[allow(dead_code)]\n-fn test_docs() {\n-    // Behavior of `x.py test` doing various documentation tests.\n-    let mut config = configure(&[], &[]);\n-    config.cmd = Subcommand::Test {\n-        paths: vec![],\n-        test_args: vec![],\n-        rustc_args: vec![],\n-        fail_fast: true,\n-        doc_tests: DocTests::Yes,\n-        bless: false,\n-        compare_mode: None,\n-        rustfix_coverage: false,\n-        pass: None,\n-    };\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-    let a = TargetSelection::from_user(\"A\");\n-\n-    // error_index_generator uses stage 1 to share rustdoc artifacts with the\n-    // rustdoc tool.\n-    assert_eq!(\n-        first(builder.cache.all::<doc::ErrorIndex>()),\n-        &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n-    );\n-    assert_eq!(\n-        first(builder.cache.all::<tool::ErrorIndex>()),\n-        &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n-    );\n-    // Unfortunately rustdoc is built twice. Once from stage1 for compiletest\n-    // (and other things), and once from stage0 for std crates. Ideally it\n-    // would only be built once. If someone wants to fix this, it might be\n-    // worth investigating if it would be possible to test std from stage1.\n-    // Note that the stages here are +1 than what they actually are because\n-    // Rustdoc::run swaps out the compiler with stage minus 1 if --stage is\n-    // not 0.\n-    assert_eq!(\n-        first(builder.cache.all::<tool::Rustdoc>()),\n-        &[\n-            tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } },\n-            tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },\n-        ]\n-    );\n+mod dist {\n+    use super::{first, Config};\n+    use crate::builder::*;\n+    use pretty_assertions::assert_eq;\n+\n+    fn configure(host: &[&str], target: &[&str]) -> Config {\n+        Config { stage: Some(2), ..super::configure(host, target) }\n+    }\n+\n+    #[test]\n+    fn dist_baseline() {\n+        let build = Build::new(configure(&[], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+\n+        assert_eq!(first(builder.cache.all::<dist::Docs>()), &[dist::Docs { host: a },]);\n+        assert_eq!(first(builder.cache.all::<dist::Mingw>()), &[dist::Mingw { host: a },]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        // Make sure rustdoc is only built once.\n+        assert_eq!(\n+            first(builder.cache.all::<tool::Rustdoc>()),\n+            &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n+        );\n+    }\n+\n+    #[test]\n+    fn dist_with_targets() {\n+        let build = Build::new(configure(&[], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc { compiler: Compiler { host: a, stage: 2 } },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+                dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_only_cross_host() {\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let mut build = Build::new(configure(&[\"B\"], &[]));\n+        build.config.docs = false;\n+        build.config.extended = true;\n+        build.hosts = vec![b];\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[dist::Rustc { compiler: Compiler { host: b, stage: 2 } },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn dist_with_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let c = TargetSelection::from_user(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+                dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    }\n+\n+    #[test]\n+    fn dist_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.skip_only_host_steps = true; // as-if --target=C was passed\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let c = TargetSelection::from_user(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b }, dist::Docs { host: c },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b }, dist::Mingw { host: c },]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                dist::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+    }\n+\n+    #[test]\n+    fn dist_with_same_targets_and_hosts() {\n+        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Docs>()),\n+            &[dist::Docs { host: a }, dist::Docs { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Mingw>()),\n+            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Rustc>()),\n+            &[\n+                dist::Rustc { compiler: Compiler { host: a, stage: 2 } },\n+                dist::Rustc { compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<dist::Std>()),\n+            &[\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                dist::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            ]\n+        );\n+        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n+                compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn build_all() {\n+        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(\n+            &Builder::get_step_descriptions(Kind::Build),\n+            &[\"src/rustc\".into(), \"library/std\".into()],\n+        );\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let c = TargetSelection::from_user(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n+            ]\n+        );\n+        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 2 }, target: b },\n+                compile::Rustc { compiler: Compiler { host: b, stage: 2 }, target: b },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn build_with_target_flag() {\n+        let mut config = configure(&[\"B\"], &[\"C\"]);\n+        config.skip_only_host_steps = true;\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+        let a = TargetSelection::from_user(\"A\");\n+        let b = TargetSelection::from_user(\"B\");\n+        let c = TargetSelection::from_user(\"C\");\n+\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Std>()),\n+            &[\n+                compile::Std { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: a },\n+                compile::Std { compiler: Compiler { host: a, stage: 1 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: b },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: b },\n+                compile::Std { compiler: Compiler { host: a, stage: 2 }, target: c },\n+                compile::Std { compiler: Compiler { host: b, stage: 2 }, target: c },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Assemble>()),\n+            &[\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 0 } },\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 1 } },\n+                compile::Assemble { target_compiler: Compiler { host: a, stage: 2 } },\n+                compile::Assemble { target_compiler: Compiler { host: b, stage: 2 } },\n+            ]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<compile::Rustc>()),\n+            &[\n+                compile::Rustc { compiler: Compiler { host: a, stage: 0 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: a },\n+                compile::Rustc { compiler: Compiler { host: a, stage: 1 }, target: b },\n+            ]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_with_no_doc_stage0() {\n+        let mut config = configure(&[], &[]);\n+        config.stage = Some(0);\n+        config.cmd = Subcommand::Test {\n+            paths: vec![\"library/std\".into()],\n+            test_args: vec![],\n+            rustc_args: vec![],\n+            fail_fast: true,\n+            doc_tests: DocTests::No,\n+            bless: false,\n+            compare_mode: None,\n+            rustfix_coverage: false,\n+            pass: None,\n+        };\n+\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+\n+        let host = TargetSelection::from_user(\"A\");\n+\n+        builder.run_step_descriptions(\n+            &[StepDescription::from::<test::Crate>()],\n+            &[\"library/std\".into()],\n+        );\n+\n+        // Ensure we don't build any compiler artifacts.\n+        assert!(!builder.cache.contains::<compile::Rustc>());\n+        assert_eq!(\n+            first(builder.cache.all::<test::Crate>()),\n+            &[test::Crate {\n+                compiler: Compiler { host, stage: 0 },\n+                target: host,\n+                mode: Mode::Std,\n+                test_kind: test::TestKind::Test,\n+                krate: INTERNER.intern_str(\"std\"),\n+            },]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_exclude() {\n+        let mut config = configure(&[], &[]);\n+        config.exclude = vec![\"src/tools/tidy\".into()];\n+        config.cmd = Subcommand::Test {\n+            paths: Vec::new(),\n+            test_args: Vec::new(),\n+            rustc_args: Vec::new(),\n+            fail_fast: true,\n+            doc_tests: DocTests::No,\n+            bless: false,\n+            compare_mode: None,\n+            rustfix_coverage: false,\n+            pass: None,\n+        };\n+\n+        let build = Build::new(config);\n+        let builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+\n+        // Ensure we have really excluded tidy\n+        assert!(!builder.cache.contains::<test::Tidy>());\n+\n+        // Ensure other tests are not affected.\n+        assert!(builder.cache.contains::<test::RustdocUi>());\n+    }\n+\n+    #[test]\n+    fn doc_ci() {\n+        let mut config = configure(&[], &[]);\n+        config.compiler_docs = true;\n+        config.cmd = Subcommand::Doc { paths: Vec::new(), open: false };\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Doc), &[]);\n+        let a = TargetSelection::from_user(\"A\");\n+\n+        // error_index_generator uses stage 1 to share rustdoc artifacts with the\n+        // rustdoc tool.\n+        assert_eq!(\n+            first(builder.cache.all::<doc::ErrorIndex>()),\n+            &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<tool::ErrorIndex>()),\n+            &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n+        );\n+        // This is actually stage 1, but Rustdoc::run swaps out the compiler with\n+        // stage minus 1 if --stage is not 0. Very confusing!\n+        assert_eq!(\n+            first(builder.cache.all::<tool::Rustdoc>()),\n+            &[tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_docs() {\n+        // Behavior of `x.py test` doing various documentation tests.\n+        let mut config = configure(&[], &[]);\n+        config.cmd = Subcommand::Test {\n+            paths: vec![],\n+            test_args: vec![],\n+            rustc_args: vec![],\n+            fail_fast: true,\n+            doc_tests: DocTests::Yes,\n+            bless: false,\n+            compare_mode: None,\n+            rustfix_coverage: false,\n+            pass: None,\n+        };\n+        let build = Build::new(config);\n+        let mut builder = Builder::new(&build);\n+        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+        let a = TargetSelection::from_user(\"A\");\n+\n+        // error_index_generator uses stage 1 to share rustdoc artifacts with the\n+        // rustdoc tool.\n+        assert_eq!(\n+            first(builder.cache.all::<doc::ErrorIndex>()),\n+            &[doc::ErrorIndex { compiler: Compiler { host: a, stage: 1 }, target: a },]\n+        );\n+        assert_eq!(\n+            first(builder.cache.all::<tool::ErrorIndex>()),\n+            &[tool::ErrorIndex { compiler: Compiler { host: a, stage: 1 } }]\n+        );\n+        // Unfortunately rustdoc is built twice. Once from stage1 for compiletest\n+        // (and other things), and once from stage0 for std crates. Ideally it\n+        // would only be built once. If someone wants to fix this, it might be\n+        // worth investigating if it would be possible to test std from stage1.\n+        // Note that the stages here are +1 than what they actually are because\n+        // Rustdoc::run swaps out the compiler with stage minus 1 if --stage is\n+        // not 0.\n+        assert_eq!(\n+            first(builder.cache.all::<tool::Rustdoc>()),\n+            &[\n+                tool::Rustdoc { compiler: Compiler { host: a, stage: 1 } },\n+                tool::Rustdoc { compiler: Compiler { host: a, stage: 2 } },\n+            ]\n+        );\n+    }\n }"}, {"sha": "373e240cb8e3e456018e8eec30688443d2425d40", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -446,10 +446,10 @@ pub struct Rustc {\n impl Step for Rustc {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n+    const DEFAULT: bool = false;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"rustc-main\")\n+        run.path(\"src/rustc\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "d64ca95d24392ab1221c90d6974eb122bf42d955", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -734,7 +734,7 @@ impl Config {\n \n         let with_defaults = |debuginfo_level_specific: Option<u32>| {\n             debuginfo_level_specific.or(debuginfo_level).unwrap_or(if debug == Some(true) {\n-                2\n+                1\n             } else {\n                 0\n             })"}, {"sha": "a4a1d5193b9b9b3ff1e010e7c9a5020ef687aaae", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1016,7 +1016,17 @@ impl Step for Src {\n         let src_files = [\"Cargo.lock\"];\n         // This is the reduced set of paths which will become the rust-src component\n         // (essentially libstd and all of its path dependencies).\n-        copy_src_dirs(builder, &builder.src, &[\"library\"], &[], &dst_src);\n+        copy_src_dirs(\n+            builder,\n+            &builder.src,\n+            &[\"library\"],\n+            &[\n+                // not needed and contains symlinks which rustup currently\n+                // chokes on when unpacking.\n+                \"library/backtrace/crates\",\n+            ],\n+            &dst_src,\n+        );\n         for file in src_files.iter() {\n             builder.copy(&builder.src.join(file), &dst_src.join(file));\n         }"}, {"sha": "a1b5ca2ea2fa1f18c128645704f1dd329c0e6d79", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -460,7 +460,7 @@ impl Step for Std {\n         // open the corresponding rendered docs.\n         for path in builder.paths.iter().map(components_simplified) {\n             if path.get(0) == Some(&\"library\") {\n-                let requested_crate = &path[1][3..];\n+                let requested_crate = &path[1];\n                 if krates.contains(&requested_crate) {\n                     let index = out.join(requested_crate).join(\"index.html\");\n                     open(builder, &index);\n@@ -693,6 +693,7 @@ impl Step for UnstableBookGen {\n         builder.create_dir(&out);\n         builder.remove_dir(&out);\n         let mut cmd = builder.tool_cmd(Tool::UnstableBookGen);\n+        cmd.arg(builder.src.join(\"library\"));\n         cmd.arg(builder.src.join(\"src\"));\n         cmd.arg(out);\n "}, {"sha": "56e4f0467cc50967978d2752e7cf99374e460977", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -425,7 +425,7 @@ Arguments:\n     This subcommand accepts a number of paths to tools to build and run. For\n     example:\n \n-        ./x.py run src/tool/expand-yaml-anchors\n+        ./x.py run src/tools/expand-yaml-anchors\n \n     At least a tool needs to be called.\",\n                 );"}, {"sha": "1564cfb06199c7e77292e3b951c20441d4b20387", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,8 +9,8 @@ endif\n BOOTSTRAP := $(CFG_PYTHON) $(CFG_SRC_DIR)src/bootstrap/bootstrap.py\n \n all:\n-\t$(Q)$(BOOTSTRAP) build $(BOOTSTRAP_ARGS)\n-\t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) build --stage 2 $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) doc --stage 2 $(BOOTSTRAP_ARGS)\n \n help:\n \t$(Q)echo 'Welcome to the rustbuild build system!'\n@@ -31,17 +31,17 @@ rustc-stage2:\n \n docs: doc\n doc:\n-\t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) doc --stage 2 $(BOOTSTRAP_ARGS)\n nomicon:\n-\t$(Q)$(BOOTSTRAP) doc src/doc/nomicon $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) doc --stage 2 src/doc/nomicon $(BOOTSTRAP_ARGS)\n book:\n-\t$(Q)$(BOOTSTRAP) doc src/doc/book $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) doc --stage 2 src/doc/book $(BOOTSTRAP_ARGS)\n standalone-docs:\n-\t$(Q)$(BOOTSTRAP) doc src/doc $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) doc --stage 2 src/doc $(BOOTSTRAP_ARGS)\n check:\n-\t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) test --stage 2 $(BOOTSTRAP_ARGS)\n check-aux:\n-\t$(Q)$(BOOTSTRAP) test \\\n+\t$(Q)$(BOOTSTRAP) test --stage 2 \\\n \t\tsrc/tools/cargo \\\n \t\tsrc/tools/cargotest \\\n \t\t$(BOOTSTRAP_ARGS)\n@@ -51,37 +51,37 @@ dist:\n \t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n distcheck:\n \t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n-\t$(Q)$(BOOTSTRAP) test distcheck $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) test --stage 2 distcheck $(BOOTSTRAP_ARGS)\n install:\n \t$(Q)$(BOOTSTRAP) install $(BOOTSTRAP_ARGS)\n tidy:\n-\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS)\n+\t$(Q)$(BOOTSTRAP) test --stage 2 src/tools/tidy $(BOOTSTRAP_ARGS)\n prepare:\n-\t$(Q)$(BOOTSTRAP) build nonexistent/path/to/trigger/cargo/metadata\n+\t$(Q)$(BOOTSTRAP) build --stage 2 nonexistent/path/to/trigger/cargo/metadata\n \n check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu:\n-\t$(Q)$(BOOTSTRAP) test --target arm-linux-androideabi\n+\t$(Q)$(BOOTSTRAP) test --stage 2 --target arm-linux-androideabi\n check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n-\t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-musl\n+\t$(Q)$(BOOTSTRAP) test --stage 2 --target x86_64-unknown-linux-musl\n \n TESTS_IN_2 := \\\n \tsrc/test/ui \\\n \tsrc/test/compile-fail \\\n \tsrc/tools/linkchecker\n \n ci-subset-1:\n-\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2:%=--exclude %)\n+\t$(Q)$(BOOTSTRAP) test --stage 2 $(TESTS_IN_2:%=--exclude %)\n ci-subset-2:\n-\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2)\n+\t$(Q)$(BOOTSTRAP) test --stage 2 $(TESTS_IN_2)\n \n TESTS_IN_MINGW_2 := \\\n \tsrc/test/ui \\\n \tsrc/test/compile-fail\n \n ci-mingw-subset-1:\n-\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_MINGW_2:%=--exclude %)\n+\t$(Q)$(BOOTSTRAP) test --stage 2 $(TESTS_IN_MINGW_2:%=--exclude %)\n ci-mingw-subset-2:\n-\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_MINGW_2)\n+\t$(Q)$(BOOTSTRAP) test --stage 2 $(TESTS_IN_MINGW_2)\n \n \n .PHONY: dist"}, {"sha": "bb5b9296c0aa73e2c5e2b822abf5036ad95834df", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -106,19 +106,18 @@ impl Step for Linkcheck {\n     ///\n     /// This tool in `src/tools` will verify the validity of all our links in the\n     /// documentation to ensure we don't have a bunch of dead ones.\n-    fn run(self, _builder: &Builder<'_>) {\n-        // FIXME(mark-i-m): uncomment this after we fix the links...\n-        // let host = self.host;\n+    fn run(self, builder: &Builder<'_>) {\n+        let host = self.host;\n \n-        // builder.info(&format!(\"Linkcheck ({})\", host));\n+        builder.info(&format!(\"Linkcheck ({})\", host));\n \n-        // builder.default_doc(None);\n+        builder.default_doc(None);\n \n-        // let _time = util::timeit(&builder);\n-        // try_run(\n-        //     builder,\n-        //     builder.tool_cmd(Tool::Linkchecker).arg(builder.out.join(host.triple).join(\"doc\")),\n-        // );\n+        let _time = util::timeit(&builder);\n+        try_run(\n+            builder,\n+            builder.tool_cmd(Tool::Linkchecker).arg(builder.out.join(host.triple).join(\"doc\")),\n+        );\n     }\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -394,7 +393,7 @@ impl Step for Miri {\n             cargo.arg(\"--\").arg(\"miri\").arg(\"setup\");\n \n             // Tell `cargo miri setup` where to find the sources.\n-            cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"src\"));\n+            cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"library\"));\n             // Tell it where to find Miri.\n             cargo.env(\"MIRI\", &miri);\n             // Debug things.\n@@ -1159,13 +1158,19 @@ impl Step for Compiletest {\n             cmd.arg(\"--quiet\");\n         }\n \n+        let mut llvm_components_passed = false;\n+        let mut copts_passed = false;\n         if builder.config.llvm_enabled() {\n             let llvm_config = builder.ensure(native::Llvm { target: builder.config.build });\n             if !builder.config.dry_run {\n                 let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 // Remove trailing newline from llvm-config output.\n-                let llvm_version = llvm_version.trim_end();\n-                cmd.arg(\"--llvm-version\").arg(llvm_version);\n+                cmd.arg(\"--llvm-version\")\n+                    .arg(llvm_version.trim())\n+                    .arg(\"--llvm-components\")\n+                    .arg(llvm_components.trim());\n+                llvm_components_passed = true;\n             }\n             if !builder.is_rust_llvm(target) {\n                 cmd.arg(\"--system-llvm\");\n@@ -1183,15 +1188,13 @@ impl Step for Compiletest {\n             // Only pass correct values for these flags for the `run-make` suite as it\n             // requires that a C++ compiler was configured which isn't always the case.\n             if !builder.config.dry_run && suite == \"run-make-fulldeps\" {\n-                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n                 cmd.arg(\"--cc\")\n                     .arg(builder.cc(target))\n                     .arg(\"--cxx\")\n                     .arg(builder.cxx(target).unwrap())\n                     .arg(\"--cflags\")\n-                    .arg(builder.cflags(target, GitRepo::Rustc).join(\" \"))\n-                    .arg(\"--llvm-components\")\n-                    .arg(llvm_components.trim());\n+                    .arg(builder.cflags(target, GitRepo::Rustc).join(\" \"));\n+                copts_passed = true;\n                 if let Some(ar) = builder.ar(target) {\n                     cmd.arg(\"--ar\").arg(ar);\n                 }\n@@ -1221,15 +1224,11 @@ impl Step for Compiletest {\n             }\n         }\n \n-        if suite != \"run-make-fulldeps\" {\n-            cmd.arg(\"--cc\")\n-                .arg(\"\")\n-                .arg(\"--cxx\")\n-                .arg(\"\")\n-                .arg(\"--cflags\")\n-                .arg(\"\")\n-                .arg(\"--llvm-components\")\n-                .arg(\"\");\n+        if !llvm_components_passed {\n+            cmd.arg(\"--llvm-components\").arg(\"\");\n+        }\n+        if !copts_passed {\n+            cmd.arg(\"--cc\").arg(\"\").arg(\"--cxx\").arg(\"\").arg(\"--cflags\").arg(\"\");\n         }\n \n         if builder.remote_tested(target) {"}, {"sha": "2185b0d30dbde350c3ae25708d9388970b408768", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -36,7 +36,7 @@ jobs:\n       # Note that the compiler is compiled to target 10.8 here because the Xcode\n       # version that we're using, 8.2, cannot compile LLVM for OSX 10.7.\n       x86_64-apple:\n-        SCRIPT: ./x.py test\n+        SCRIPT: ./x.py --stage 2 test\n         INITIAL_RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n         MACOSX_DEPLOYMENT_TARGET: 10.8"}, {"sha": "b6cf60a5e15a7b11aa31b4a60fb241ab4d4df2f9", "filename": "src/ci/docker/host-aarch64/aarch64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-aarch64%2Faarch64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-aarch64%2Faarch64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-aarch64%2Faarch64-gnu%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -23,4 +23,4 @@ ENV RUST_CONFIGURE_ARGS \\\n  --enable-sanitizers \\\n  --enable-profiler \\\n  --enable-compiler-docs\n-ENV SCRIPT python3 ../x.py test\n+ENV SCRIPT python3 ../x.py --stage 2 test"}, {"sha": "add2647fa1e65c503abe0514981dd062d02d12de", "filename": "src/ci/docker/host-x86_64/arm-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Farm-android%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -31,7 +31,7 @@ ENV TARGETS=arm-linux-androideabi\n \n ENV RUST_CONFIGURE_ARGS --arm-linux-androideabi-ndk=/android/ndk/arm-14\n \n-ENV SCRIPT python3 ../x.py test --target $TARGETS\n+ENV SCRIPT python3 ../x.py --stage 2 test --target $TARGETS\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "1f3092c5513d956c21c9885a9d81c30dbbb30900", "filename": "src/ci/docker/host-x86_64/armhf-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Farmhf-gnu%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -78,6 +78,6 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --qemu-armhf-rootfs=/tmp/rootfs\n-ENV SCRIPT python3 ../x.py test --target arm-unknown-linux-gnueabihf\n+ENV SCRIPT python3 ../x.py --stage 2 test --target arm-unknown-linux-gnueabihf\n \n ENV NO_CHANGE_USER=1"}, {"sha": "a4d9f53ebabef1c3d32a4b07329f1de6e5abd9eb", "filename": "src/ci/docker/host-x86_64/disabled/asmjs/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fasmjs%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -33,7 +33,7 @@ ENV EMCC_CFLAGS=-O1\n # Emscripten installation is user-specific\n ENV NO_CHANGE_USER=1\n \n-ENV SCRIPT python3 ../x.py test --target $TARGETS\n+ENV SCRIPT python3 ../x.py --stage 2 test --target $TARGETS\n \n # This is almost identical to the wasm32-unknown-emscripten target, so\n # running with assertions again is not useful"}, {"sha": "f986c38ea02da913313c0760d701288aba98f81a", "filename": "src/ci/docker/host-x86_64/disabled/dist-armv7-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-armv7-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-armv7-android%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -33,7 +33,7 @@ ENV RUST_CONFIGURE_ARGS \\\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n ENV SCRIPT \\\n-  python3 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n+  python3 ../x.py --stage 2 build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/arm && \\\n     ln -s /android/ndk/arm-14 /android/ndk/arm && \\"}, {"sha": "4dfbc72560783f4d9a6229fd7f222b5cced9f934", "filename": "src/ci/docker/host-x86_64/disabled/dist-i686-android/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-i686-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-i686-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Fdist-i686-android%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -33,7 +33,7 @@ ENV RUST_CONFIGURE_ARGS \\\n # build to finish we use --warn-unresolved-symbols. Note that the missing\n # symbols does not affect std, only the compiler (llvm) and cargo (openssl).\n ENV SCRIPT \\\n-  python3 ../x.py build src/llvm --host $HOSTS --target $HOSTS && \\\n+  python3 ../x.py --stage 2 build src/llvm --host $HOSTS --target $HOSTS && \\\n   (export RUSTFLAGS=\"\\\"-C link-arg=-Wl,--warn-unresolved-symbols\\\"\"; \\\n     rm /android/ndk/x86 && \\\n     ln -s /android/ndk/x86-14 /android/ndk/x86 && \\"}, {"sha": "e3c35000eb818086cc67c4cd0e77dc83bbc46c91", "filename": "src/ci/docker/host-x86_64/disabled/riscv64gc-linux/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdisabled%2Friscv64gc-linux%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -97,6 +97,6 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --qemu-riscv64-rootfs=/tmp/rootfs\n-ENV SCRIPT python3 ../x.py test --target riscv64gc-unknown-linux-gnu\n+ENV SCRIPT python3 ../x.py --stage 2 test --target riscv64gc-unknown-linux-gnu\n \n ENV NO_CHANGE_USER=1"}, {"sha": "162d7a1345ce1cb64f9b192b292da68f8d76abaf", "filename": "src/ci/docker/host-x86_64/dist-i586-gnu-i586-i686-musl/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i586-gnu-i586-i686-musl%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -46,5 +46,5 @@ ENV CFLAGS_i586_unknown_linux_musl=-Wa,-mrelax-relocations=no\n ENV TARGETS=i586-unknown-linux-gnu,i686-unknown-linux-musl\n \n ENV SCRIPT \\\n-      python3 ../x.py test --target $TARGETS && \\\n+      python3 ../x.py --stage 2 test --target $TARGETS && \\\n       python3 ../x.py dist --target $TARGETS,i586-unknown-linux-musl"}, {"sha": "14af9b9efe815ff884f11c5c2dcd6f624c622213", "filename": "src/ci/docker/host-x86_64/dist-i686-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-i686-freebsd%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=i686-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV RUST_CONFIGURE_ARGS --enable-extended --enable-profiler --disable-docs\n ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "fdd777e824ba89c5433e50ea6ff4d85837d6de59", "filename": "src/ci/docker/host-x86_64/dist-various-1/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-1%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -192,7 +192,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --disable-docs\n \n ENV SCRIPT \\\n-      python3 ../x.py test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n+      python3 ../x.py --stage 2 test --target $RUN_MAKE_TARGETS src/test/run-make && \\\n       python3 ../x.py dist --target $TARGETS\n \n # sccache"}, {"sha": "c6db200f8660f36f5e3e36faf4e3692ab83ab551", "filename": "src/ci/docker/host-x86_64/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -4,15 +4,15 @@\n \n set -ex\n \n-# Originally from https://releases.llvm.org/9.0.0/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n-curl https://ci-mirrors.rust-lang.org/rustc/clang%2Bllvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n+# Originally from https://github.com/llvm/llvm-project/releases/download/llvmorg-10.0.0/clang+llvm-10.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz\n+curl https://ci-mirrors.rust-lang.org/rustc/clang%2Bllvm-10.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz | \\\n   tar xJf -\n-export PATH=`pwd`/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n+export PATH=`pwd`/clang+llvm-10.0.0-x86_64-linux-gnu-ubuntu-18.04/bin:$PATH\n \n-git clone https://github.com/CraneStation/wasi-libc\n+git clone https://github.com/WebAssembly/wasi-libc\n \n cd wasi-libc\n-git reset --hard 9efc2f428358564fe64c374d762d0bfce1d92507\n+git reset --hard 215adc8ac9f91eb055311acc72683fd2eb1ae15a\n make -j$(nproc) INSTALL_DIR=/wasm32-wasi install\n \n cd .."}, {"sha": "2372c0dad0abf626ac1e6d1f71882ee18e90d111", "filename": "src/ci/docker/host-x86_64/dist-x86_64-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-freebsd%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -29,5 +29,5 @@ ENV \\\n \n ENV HOSTS=x86_64-unknown-freebsd\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV RUST_CONFIGURE_ARGS --enable-extended --enable-profiler --disable-docs\n ENV SCRIPT python3 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "ab6515cd1fa955daf10a57117643ea9adf1eddfd", "filename": "src/ci/docker/host-x86_64/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-x86_64-musl%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -33,7 +33,6 @@ ENV HOSTS=x86_64-unknown-linux-musl\n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n       --enable-extended \\\n-      --disable-docs \\\n       --enable-lld \\\n       --set target.x86_64-unknown-linux-musl.crt-static=false \\\n       --build $HOSTS"}, {"sha": "6a596b3465f20da7e0b22843b63871fb89c1daf9", "filename": "src/ci/docker/host-x86_64/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu-nopt%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -20,7 +20,7 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n-ENV SCRIPT python3 ../x.py test\n+ENV SCRIPT python3 ../x.py --stage 2 test\n \n # FIXME(#59637) takes too long on CI right now\n ENV NO_LLVM_ASSERTIONS=1 NO_DEBUG_ASSERTIONS=1"}, {"sha": "9d319017d7967cbc0c9ccdc18846b561a333a74e", "filename": "src/ci/docker/host-x86_64/i686-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fi686-gnu%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -22,7 +22,7 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n # Exclude some tests that are unlikely to be platform specific, to speed up\n # this slow job.\n-ENV SCRIPT python3 ../x.py test \\\n+ENV SCRIPT python3 ../x.py --stage 2 test \\\n   --exclude src/bootstrap \\\n   --exclude src/test/rustdoc-js \\\n   --exclude src/tools/error_index_generator \\"}, {"sha": "b902eda87bc6ec9bd3c2d7b6b23a129be73f3b31", "filename": "src/ci/docker/host-x86_64/mingw-check/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fmingw-check%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -22,10 +22,10 @@ RUN sh /scripts/sccache.sh\n COPY host-x86_64/mingw-check/validate-toolstate.sh /scripts/\n \n ENV RUN_CHECK_WITH_PARALLEL_QUERIES 1\n-ENV SCRIPT python3 ../x.py test src/tools/expand-yaml-anchors && \\\n+ENV SCRIPT python3 ../x.py --stage 2 test src/tools/expand-yaml-anchors && \\\n            python3 ../x.py check --target=i686-pc-windows-gnu --host=i686-pc-windows-gnu && \\\n            python3 ../x.py build --stage 0 src/tools/build-manifest && \\\n            python3 ../x.py test --stage 0 src/tools/compiletest && \\\n-           python3 ../x.py test src/tools/tidy && \\\n+           python3 ../x.py test --stage 2 src/tools/tidy && \\\n            python3 ../x.py doc --stage 0 library/std && \\\n            /scripts/validate-toolstate.sh"}, {"sha": "c55a284e137b34454e4c0914b6ea103167216254", "filename": "src/ci/docker/host-x86_64/test-various/Dockerfile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Ftest-various%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -40,7 +40,7 @@ ENV RUST_CONFIGURE_ARGS \\\n ENV NO_DEBUG_ASSERTIONS=1\n \n ENV WASM_TARGETS=wasm32-unknown-unknown\n-ENV WASM_SCRIPT python3 /checkout/x.py test --target $WASM_TARGETS \\\n+ENV WASM_SCRIPT python3 /checkout/x.py --stage 2 test --target $WASM_TARGETS \\\n   src/test/run-make \\\n   src/test/ui \\\n   src/test/compile-fail \\\n@@ -49,13 +49,13 @@ ENV WASM_SCRIPT python3 /checkout/x.py test --target $WASM_TARGETS \\\n   library/core\n \n ENV NVPTX_TARGETS=nvptx64-nvidia-cuda\n-ENV NVPTX_SCRIPT python3 /checkout/x.py test --target $NVPTX_TARGETS \\\n+ENV NVPTX_SCRIPT python3 /checkout/x.py --stage 2 test --target $NVPTX_TARGETS \\\n   src/test/run-make \\\n   src/test/assembly\n \n ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n     CC_x86_64_unknown_linux_musl=x86_64-linux-musl-gcc \\\n     CXX_x86_64_unknown_linux_musl=x86_64-linux-musl-g++\n-ENV MUSL_SCRIPT python3 /checkout/x.py test --target $MUSL_TARGETS\n+ENV MUSL_SCRIPT python3 /checkout/x.py --stage 2 test --target $MUSL_TARGETS\n \n ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT && $MUSL_SCRIPT"}, {"sha": "e00177b4a67c9a979d104d956f98449f5bac7622", "filename": "src/ci/docker/host-x86_64/wasm32/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fwasm32%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fwasm32%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fwasm32%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -52,7 +52,7 @@ ENV NO_CHANGE_USER=1\n \n # FIXME: Re-enable these tests once https://github.com/rust-lang/cargo/pull/7476\n # is picked up by CI\n-ENV SCRIPT python3 ../x.py test --target $TARGETS \\\n+ENV SCRIPT python3 ../x.py test --stage 2 --target $TARGETS \\\n     --exclude library/core \\\n     --exclude library/alloc \\\n     --exclude library/proc_macro \\"}, {"sha": "c1cb20b631d319d20a4a35845860366ae577588a", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-debug%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -40,5 +40,5 @@ ENV RUST_CONFIGURE_ARGS \\\n       --set target.x86_64-unknown-linux-gnu.cxx=clang++\n \n ENV SCRIPT \\\n-  python3 ../x.py build && \\\n-  python3 ../x.py test src/test/run-make-fulldeps --test-args clang\n+  python3 ../x.py --stage 2 build && \\\n+  python3 ../x.py --stage 2 test src/test/run-make-fulldeps --test-args clang"}, {"sha": "68e89a7bade342b09d849945c053d00f44b95731", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-distcheck/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-distcheck%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -19,10 +19,10 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --set rust.ignore-git=false\n-ENV SCRIPT python3 ../x.py test distcheck\n+ENV SCRIPT python3 ../x.py --stage 2 test distcheck\n ENV DIST_SRC 1\n \n-# The purpose of this builder is to test that we can `./x.py test` successfully\n+# The purpose of this builder is to test that we can `./x.py --stage 2 test` successfully\n # from a tarball, not to test LLVM/rustc's own set of assertions. These cause a\n # significant hit to CI compile time (over a half hour as observed in #61185),\n # so disable assertions for this builder."}, {"sha": "8648e5ed7a4866e377d0fee584d6fdf189c80e01", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-full-bootstrap/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -21,7 +21,7 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-full-bootstrap\n-ENV SCRIPT python3 ../x.py build\n+ENV SCRIPT python3 ../x.py --stage 2 build\n \n # In general this just slows down the build and we're just a smoke test that\n # a full bootstrap works in general, so there's not much need to take this"}, {"sha": "5c971c73c97d3485ae5ce4811b603b26f5dfea87", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-llvm-8/Dockerfile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-8%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-8%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-llvm-8%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -30,7 +30,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-llvm-link-shared \\\n       --set rust.thin-lto-import-instr-limit=10\n \n-ENV SCRIPT python2.7 ../x.py test --exclude src/tools/tidy && \\\n+ENV SCRIPT python2.7 ../x.py --stage 2 test --exclude src/tools/tidy && \\\n            # Run the `mir-opt` tests again but this time for a 32-bit target.\n            # This enforces that tests using `// EMIT_MIR_FOR_EACH_BIT_WIDTH` have\n            # both 32-bit and 64-bit outputs updated by the PR author, before\n@@ -43,7 +43,7 @@ ENV SCRIPT python2.7 ../x.py test --exclude src/tools/tidy && \\\n            # This also requires `--pass=build` because we can't execute the tests\n            # on the `x86_64` host when they're built as `armv5te` binaries.\n            # (we're only interested in the MIR output, so this doesn't matter)\n-           python2.7 ../x.py test src/test/mir-opt --pass=build \\\n+           python2.7 ../x.py --stage 2 test src/test/mir-opt --pass=build \\\n                                   --target=armv5te-unknown-linux-gnueabi && \\\n            # Run the UI test suite again, but in `--pass=check` mode\n            #\n@@ -53,9 +53,9 @@ ENV SCRIPT python2.7 ../x.py test --exclude src/tools/tidy && \\\n            # FIXME: We ideally want to test this in 32-bit mode, but currently\n            # (due to the LLVM problems mentioned above) that isn't readily\n            # possible.\n-           python2.7 ../x.py test src/test/ui --pass=check && \\\n+           python2.7 ../x.py --stage 2 test src/test/ui --pass=check && \\\n            # Run tidy at the very end, after all the other tests.\n-           python2.7 ../x.py test src/tools/tidy\n+           python2.7 ../x.py --stage 2 test src/tools/tidy\n \n # The purpose of this container isn't to test with debug assertions and\n # this is run on all PRs, so let's get speedier builds by disabling these extra"}, {"sha": "fa769cac9c1da8ec7a8241049056dc1a193287fe", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-nopt%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -21,4 +21,4 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu \\\n   --disable-optimize-tests \\\n   --set rust.test-compare-mode\n-ENV SCRIPT python3 ../x.py test\n+ENV SCRIPT python3 ../x.py --stage 2 test"}, {"sha": "49a8e5e88a0390d412a115b731cb30dd9bd7d8f3", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -7,7 +7,7 @@ X_PY=\"$1\"\n # Try to test all the tools and store the build/test success in the TOOLSTATE_FILE\n \n set +e\n-python3 \"$X_PY\" test --no-fail-fast \\\n+python3 \"$X_PY\" test --stage 2 --no-fail-fast \\\n     src/doc/book \\\n     src/doc/nomicon \\\n     src/doc/reference \\\n@@ -22,5 +22,5 @@ set -e\n \n # debugging: print out the saved toolstates\n cat /tmp/toolstate/toolstates.json\n-python3 \"$X_PY\" test check-tools\n-python3 \"$X_PY\" test src/tools/clippy\n+python3 \"$X_PY\" test --stage 2 check-tools\n+python3 \"$X_PY\" test --stage 2 src/tools/clippy"}, {"sha": "f8bacf79ac0dccea249b20a2aeaa55ed14e38f9e", "filename": "src/ci/docker/host-x86_64/x86_64-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu%2FDockerfile?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -23,4 +23,4 @@ ENV RUST_CONFIGURE_ARGS \\\n  --enable-sanitizers \\\n  --enable-profiler \\\n  --enable-compiler-docs\n-ENV SCRIPT python3 ../x.py test\n+ENV SCRIPT python3 ../x.py --stage 2 test"}, {"sha": "8a6973bcdd6c91ce6048a98acc809349480b1730", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -84,6 +84,9 @@ x--expand-yaml-anchors--remove:\n     os: windows-latest-xl\n     <<: *base-job\n \n+  - &job-aarch64-linux\n+    os: [self-hosted, ARM64, linux]\n+\n   - &step\n     if: success() && !env.SKIP_JOB\n \n@@ -471,7 +474,7 @@ jobs:\n \n           - name: x86_64-msvc-cargo\n             env:\n-              SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n+              SCRIPT: python x.py --stage 2 test src/tools/cargotest src/tools/cargo\n               RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-lld\n               VCVARS_BAT: vcvars64.bat\n               # FIXME(#59637)\n@@ -586,6 +589,13 @@ jobs:\n     strategy:\n       matrix:\n         include:\n+          #############################\n+          #   Linux/Docker builders   #\n+          #############################\n+\n+          - name: aarch64-gnu\n+            <<: *job-aarch64-linux\n+\n           ####################\n           #  macOS Builders  #\n           ####################\n@@ -613,7 +623,7 @@ jobs:\n \n           - name: x86_64-apple\n             env:\n-              SCRIPT: ./x.py test\n+              SCRIPT: ./x.py --stage 2 test\n               RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n               RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n               MACOSX_DEPLOYMENT_TARGET: 10.8"}, {"sha": "28d8aa3b6e71a156ec9a58eeb91967d1cfa8eba5", "filename": "src/ci/scripts/symlink-build-dir.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fsymlink-build-dir.sh?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,7 +12,7 @@ source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n if isWindows && isAzurePipelines; then\n     cmd //c \"mkdir c:\\\\MORE_SPACE\"\n     cmd //c \"mklink /J build c:\\\\MORE_SPACE\"\n-elif isLinux && isGitHubActions; then\n+elif isLinux && isGitHubActions && ! isSelfHostedGitHubActions; then\n     sudo mkdir -p /mnt/more-space\n     sudo chown -R \"$(whoami):\" /mnt/more-space\n "}, {"sha": "8222758ed6dc4e5bf62eec89239bb0415fe657d1", "filename": "src/ci/shared.sh", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -38,6 +38,11 @@ function isGitHubActions {\n     [[ \"${GITHUB_ACTIONS-false}\" = \"true\" ]]\n }\n \n+\n+function isSelfHostedGitHubActions {\n+    [[ \"${RUST_GHA_SELF_HOSTED-false}\" = \"true\" ]]\n+}\n+\n function isMacOS {\n     [[ \"${OSTYPE}\" = \"darwin\"* ]]\n }"}, {"sha": "d1d6bc1c1fe69274be0e257e27ce8cc424065fe0", "filename": "src/doc/rustdoc/src/lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Flints.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ can use them like any other lints by doing this:\n \n Here is the list of the lints provided by `rustdoc`:\n \n-## intra_doc_link_resolution_failure\n+## broken_intra_doc_links\n \n This lint **warns by default** and is **nightly-only**. This lint detects when\n an intra-doc link fails to get resolved. For example:"}, {"sha": "38351131527620509fe45e6997489e54aa0406ab", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -35,7 +35,7 @@ of a library.\n Plugins can extend [Rust's lint\n infrastructure](../../reference/attributes/diagnostics.md#lint-check-attributes) with\n additional checks for code style, safety, etc. Now let's write a plugin\n-[`lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/ui-fulldeps/auxiliary/lint_plugin_test.rs)\n+[`lint-plugin-test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs)\n that warns about any item named `lintme`.\n \n ```rust,ignore\n@@ -45,42 +45,40 @@ that warns about any item named `lintme`.\n extern crate rustc_ast;\n \n // Load rustc as a plugin to get macros\n-#[macro_use]\n-extern crate rustc;\n extern crate rustc_driver;\n+#[macro_use]\n+extern crate rustc_lint;\n+#[macro_use]\n+extern crate rustc_session;\n \n-use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n-                  EarlyLintPassObject, LintArray};\n use rustc_driver::plugin::Registry;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintArray, LintContext, LintPass};\n use rustc_ast::ast;\n-\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n \n-struct Pass;\n-\n-impl LintPass for Pass {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(TEST_LINT)\n-    }\n-}\n+declare_lint_pass!(Pass => [TEST_LINT]);\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n-        if it.ident.as_str() == \"lintme\" {\n-            cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n+        if it.ident.name.as_str() == \"lintme\" {\n+            cx.lint(TEST_LINT, |lint| {\n+                lint.build(\"item is named 'lintme'\").set_span(it.span).emit()\n+            });\n         }\n     }\n }\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n-    reg.register_early_lint_pass(box Pass as EarlyLintPassObject);\n+    reg.lint_store.register_lints(&[&TEST_LINT]);\n+    reg.lint_store.register_early_pass(|| box Pass);\n }\n ```\n \n Then code like\n \n ```rust,ignore\n+#![feature(plugin)]\n #![plugin(lint_plugin_test)]\n \n fn lintme() { }\n@@ -107,7 +105,7 @@ The components of a lint plugin are:\n \n Lint passes are syntax traversals, but they run at a late stage of compilation\n where type information is available. `rustc`'s [built-in\n-lints](https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs)\n+lints](https://github.com/rust-lang/rust/blob/master/src/librustc_session/lint/builtin.rs)\n mostly use the same infrastructure as lint plugins, and provide examples of how\n to access type information.\n "}, {"sha": "218552a45972d860f022ce2d86b8421b40a646bc", "filename": "src/etc/test-float-parse/runtests.py", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Fetc%2Ftest-float-parse%2Fruntests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftest-float-parse%2Fruntests.py?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -193,11 +193,12 @@ def interact(proc, queue):\n \n def main():\n     global MAILBOX\n-    tests = [os.path.splitext(f)[0] for f in glob('*.rs')\n-                                    if not f.startswith('_')]\n-    listed = sys.argv[1:]\n-    if listed:\n-        tests = [test for test in tests if test in listed]\n+    all_tests = [os.path.splitext(f)[0] for f in glob('*.rs') if not f.startswith('_')]\n+    args = sys.argv[1:]\n+    if args:\n+        tests = [test for test in all_tests if test in args]\n+    else\n+        tests = all_tests\n     if not tests:\n         print(\"Error: No tests to run\")\n         sys.exit(1)"}, {"sha": "a36f49bd4146b60b82ddd07a1603eb7754f632c8", "filename": "src/librustc_ast/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_serialize = { path = \"../librustc_serialize\" }\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n scoped-tls = \"1.0\"\n rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "e1c94ddf782881d16571fa154727471f1f2159c3", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 61, "deletions": 56, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -673,62 +673,6 @@ impl Token {\n \n         Some(Token::new(kind, self.span.to(joint.span)))\n     }\n-\n-    // See comments in `Nonterminal::to_tokenstream` for why we care about\n-    // *probably* equal here rather than actual equality\n-    crate fn probably_equal_for_proc_macro(&self, other: &Token) -> bool {\n-        if mem::discriminant(&self.kind) != mem::discriminant(&other.kind) {\n-            return false;\n-        }\n-        match (&self.kind, &other.kind) {\n-            (&Eq, &Eq)\n-            | (&Lt, &Lt)\n-            | (&Le, &Le)\n-            | (&EqEq, &EqEq)\n-            | (&Ne, &Ne)\n-            | (&Ge, &Ge)\n-            | (&Gt, &Gt)\n-            | (&AndAnd, &AndAnd)\n-            | (&OrOr, &OrOr)\n-            | (&Not, &Not)\n-            | (&Tilde, &Tilde)\n-            | (&At, &At)\n-            | (&Dot, &Dot)\n-            | (&DotDot, &DotDot)\n-            | (&DotDotDot, &DotDotDot)\n-            | (&DotDotEq, &DotDotEq)\n-            | (&Comma, &Comma)\n-            | (&Semi, &Semi)\n-            | (&Colon, &Colon)\n-            | (&ModSep, &ModSep)\n-            | (&RArrow, &RArrow)\n-            | (&LArrow, &LArrow)\n-            | (&FatArrow, &FatArrow)\n-            | (&Pound, &Pound)\n-            | (&Dollar, &Dollar)\n-            | (&Question, &Question)\n-            | (&Whitespace, &Whitespace)\n-            | (&Comment, &Comment)\n-            | (&Eof, &Eof) => true,\n-\n-            (&BinOp(a), &BinOp(b)) | (&BinOpEq(a), &BinOpEq(b)) => a == b,\n-\n-            (&OpenDelim(a), &OpenDelim(b)) | (&CloseDelim(a), &CloseDelim(b)) => a == b,\n-\n-            (&DocComment(a), &DocComment(b)) | (&Shebang(a), &Shebang(b)) => a == b,\n-\n-            (&Literal(a), &Literal(b)) => a == b,\n-\n-            (&Lifetime(a), &Lifetime(b)) => a == b,\n-            (&Ident(a, b), &Ident(c, d)) => {\n-                b == d && (a == c || a == kw::DollarCrate || c == kw::DollarCrate)\n-            }\n-\n-            (&Interpolated(..), &Interpolated(..)) => false,\n-\n-            _ => panic!(\"forgot to add a token?\"),\n-        }\n-    }\n }\n \n impl PartialEq<TokenKind> for Token {\n@@ -760,6 +704,67 @@ pub enum Nonterminal {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Nonterminal, 40);\n \n+#[derive(Debug, Copy, Clone, PartialEq, RustcEncodable, RustcDecodable)]\n+pub enum NonterminalKind {\n+    Item,\n+    Block,\n+    Stmt,\n+    Pat,\n+    Expr,\n+    Ty,\n+    Ident,\n+    Lifetime,\n+    Literal,\n+    Meta,\n+    Path,\n+    Vis,\n+    TT,\n+}\n+\n+impl NonterminalKind {\n+    pub fn from_symbol(symbol: Symbol) -> Option<NonterminalKind> {\n+        Some(match symbol {\n+            sym::item => NonterminalKind::Item,\n+            sym::block => NonterminalKind::Block,\n+            sym::stmt => NonterminalKind::Stmt,\n+            sym::pat => NonterminalKind::Pat,\n+            sym::expr => NonterminalKind::Expr,\n+            sym::ty => NonterminalKind::Ty,\n+            sym::ident => NonterminalKind::Ident,\n+            sym::lifetime => NonterminalKind::Lifetime,\n+            sym::literal => NonterminalKind::Literal,\n+            sym::meta => NonterminalKind::Meta,\n+            sym::path => NonterminalKind::Path,\n+            sym::vis => NonterminalKind::Vis,\n+            sym::tt => NonterminalKind::TT,\n+            _ => return None,\n+        })\n+    }\n+    fn symbol(self) -> Symbol {\n+        match self {\n+            NonterminalKind::Item => sym::item,\n+            NonterminalKind::Block => sym::block,\n+            NonterminalKind::Stmt => sym::stmt,\n+            NonterminalKind::Pat => sym::pat,\n+            NonterminalKind::Expr => sym::expr,\n+            NonterminalKind::Ty => sym::ty,\n+            NonterminalKind::Ident => sym::ident,\n+            NonterminalKind::Lifetime => sym::lifetime,\n+            NonterminalKind::Literal => sym::literal,\n+            NonterminalKind::Meta => sym::meta,\n+            NonterminalKind::Path => sym::path,\n+            NonterminalKind::Vis => sym::vis,\n+            NonterminalKind::TT => sym::tt,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for NonterminalKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{}\", self.symbol())\n+    }\n+}\n+\n impl Nonterminal {\n     fn span(&self) -> Span {\n         match self {"}, {"sha": "9d0199078fa6a354eb4ee9f51305aa95fbb4e4fa", "filename": "src/librustc_ast/tokenstream.rs", "status": "modified", "additions": 0, "deletions": 125, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftokenstream.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -21,8 +21,6 @@ use rustc_macros::HashStable_Generic;\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n-use log::debug;\n-\n use std::{iter, mem};\n \n /// When the main rust parser encounters a syntax-extension invocation, it\n@@ -68,23 +66,6 @@ impl TokenTree {\n         }\n     }\n \n-    // See comments in `Nonterminal::to_tokenstream` for why we care about\n-    // *probably* equal here rather than actual equality\n-    //\n-    // This is otherwise the same as `eq_unspanned`, only recursing with a\n-    // different method.\n-    pub fn probably_equal_for_proc_macro(&self, other: &TokenTree) -> bool {\n-        match (self, other) {\n-            (TokenTree::Token(token), TokenTree::Token(token2)) => {\n-                token.probably_equal_for_proc_macro(token2)\n-            }\n-            (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n-                delim == delim2 && tts.probably_equal_for_proc_macro(&tts2)\n-            }\n-            _ => false,\n-        }\n-    }\n-\n     /// Retrieves the TokenTree's span.\n     pub fn span(&self) -> Span {\n         match self {\n@@ -307,112 +288,6 @@ impl TokenStream {\n         t1.next().is_none() && t2.next().is_none()\n     }\n \n-    // See comments in `Nonterminal::to_tokenstream` for why we care about\n-    // *probably* equal here rather than actual equality\n-    //\n-    // This is otherwise the same as `eq_unspanned`, only recursing with a\n-    // different method.\n-    pub fn probably_equal_for_proc_macro(&self, other: &TokenStream) -> bool {\n-        // When checking for `probably_eq`, we ignore certain tokens that aren't\n-        // preserved in the AST. Because they are not preserved, the pretty\n-        // printer arbitrarily adds or removes them when printing as token\n-        // streams, making a comparison between a token stream generated from an\n-        // AST and a token stream which was parsed into an AST more reliable.\n-        fn semantic_tree(tree: &TokenTree) -> bool {\n-            if let TokenTree::Token(token) = tree {\n-                if let\n-                    // The pretty printer tends to add trailing commas to\n-                    // everything, and in particular, after struct fields.\n-                    | token::Comma\n-                    // The pretty printer emits `NoDelim` as whitespace.\n-                    | token::OpenDelim(DelimToken::NoDelim)\n-                    | token::CloseDelim(DelimToken::NoDelim)\n-                    // The pretty printer collapses many semicolons into one.\n-                    | token::Semi\n-                    // The pretty printer collapses whitespace arbitrarily and can\n-                    // introduce whitespace from `NoDelim`.\n-                    | token::Whitespace\n-                    // The pretty printer can turn `$crate` into `::crate_name`\n-                    | token::ModSep = token.kind {\n-                    return false;\n-                }\n-            }\n-            true\n-        }\n-\n-        // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n-        //\n-        // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n-        // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n-        // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n-        // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n-        // when determining if two `TokenStream`s are 'probably equal'.\n-        //\n-        // Therefore, we use `break_two_token_op` to convert all tokens\n-        // to the 'unglued' form (if it exists). This ensures that two\n-        // `TokenStream`s which differ only in how their tokens are glued\n-        // will be considered 'probably equal', which allows us to keep spans.\n-        //\n-        // This is important when the original `TokenStream` contained\n-        // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n-        // will be omitted when we pretty-print, which can cause the original\n-        // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n-        // leading to some tokens being 'glued' together in one stream but not\n-        // the other. See #68489 for more details.\n-        fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n-            // In almost all cases, we should have either zero or one levels\n-            // of 'unglueing'. However, in some unusual cases, we may need\n-            // to iterate breaking tokens mutliple times. For example:\n-            // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n-            let mut token_trees: SmallVec<[_; 2]>;\n-            if let TokenTree::Token(token) = &tree {\n-                let mut out = SmallVec::<[_; 2]>::new();\n-                out.push(token.clone());\n-                // Iterate to fixpoint:\n-                // * We start off with 'out' containing our initial token, and `temp` empty\n-                // * If we are able to break any tokens in `out`, then `out` will have\n-                //   at least one more element than 'temp', so we will try to break tokens\n-                //   again.\n-                // * If we cannot break any tokens in 'out', we are done\n-                loop {\n-                    let mut temp = SmallVec::<[_; 2]>::new();\n-                    let mut changed = false;\n-\n-                    for token in out.into_iter() {\n-                        if let Some((first, second)) = token.kind.break_two_token_op() {\n-                            temp.push(Token::new(first, DUMMY_SP));\n-                            temp.push(Token::new(second, DUMMY_SP));\n-                            changed = true;\n-                        } else {\n-                            temp.push(token);\n-                        }\n-                    }\n-                    out = temp;\n-                    if !changed {\n-                        break;\n-                    }\n-                }\n-                token_trees = out.into_iter().map(TokenTree::Token).collect();\n-                if token_trees.len() != 1 {\n-                    debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n-                }\n-            } else {\n-                token_trees = SmallVec::new();\n-                token_trees.push(tree);\n-            }\n-            token_trees.into_iter()\n-        }\n-\n-        let mut t1 = self.trees().filter(semantic_tree).flat_map(break_tokens);\n-        let mut t2 = other.trees().filter(semantic_tree).flat_map(break_tokens);\n-        for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n-            if !t1.probably_equal_for_proc_macro(&t2) {\n-                return false;\n-            }\n-        }\n-        t1.next().is_none() && t2.next().is_none()\n-    }\n-\n     pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n         TokenStream(Lrc::new(\n             self.0"}, {"sha": "bf7e69a31abcba446d7238ff3e7c310ef7941332", "filename": "src/librustc_ast_lowering/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../librustc_arena\" }\n-log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+tracing = \"0.1\"\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "5414e5842904726f8d5a32746425d56236553789", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -17,9 +17,9 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n \n-use log::debug;\n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeSet;\n+use tracing::debug;\n \n pub(super) struct ItemLowerer<'a, 'lowering, 'hir> {\n     pub(super) lctx: &'a mut LoweringContext<'lowering, 'hir>,"}, {"sha": "9df7ad2a9acf47d22e2c72c948a6b0c4ce4254bd", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -64,10 +64,10 @@ use rustc_span::source_map::{respan, DesugaringKind, ExpnData, ExpnKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n \n-use log::{debug, trace};\n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeMap;\n use std::mem;\n+use tracing::{debug, trace};\n \n macro_rules! arena_vec {\n     ($this:expr; $($x:expr),*) => ({"}, {"sha": "171856e7e637181fa2878216b484213d2cfbd999", "filename": "src/librustc_ast_lowering/pat.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpat.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -112,7 +112,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 // Found a sub-tuple pattern `$binding_mode $ident @ ..`.\n                 // This is not allowed as a sub-tuple pattern\n                 PatKind::Ident(ref _bm, ident, Some(ref sub)) if sub.is_rest() => {\n-                    rest = Some((idx, pat.span));\n                     let sp = pat.span;\n                     self.diagnostic()\n                         .struct_span_err(\n@@ -128,7 +127,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             Applicability::MaybeIncorrect,\n                         )\n                         .emit();\n-                    break;\n                 }\n                 _ => {}\n             }"}, {"sha": "2541d6824fec4e66331ca93d7915dc347b3a59c3", "filename": "src/librustc_ast_lowering/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_lowering%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fpath.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,8 +12,8 @@ use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-use log::debug;\n use smallvec::smallvec;\n+use tracing::debug;\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     crate fn lower_qpath("}, {"sha": "6db9bce3164bb120579594334a151b12f55d220d", "filename": "src/librustc_ast_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n \n [dependencies]\n itertools = \"0.8\"\n-log = \"0.4\"\n+tracing = \"0.1\"\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "2fe208c3ce68caf5cb02d2f0aef4466496ec827f", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -10,7 +10,7 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n-use log::debug;\n+use tracing::debug;\n \n macro_rules! gate_feature_fn {\n     ($cx: expr, $has_feature: expr, $span: expr, $name: expr, $explain: expr) => {{"}, {"sha": "d26205c791dc0f67c70d366de2c43ee301de57c5", "filename": "src/librustc_ast_pretty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-log = \"0.4\"\n+tracing = \"0.1\"\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "ca7f127ced60d4c5111e24ee4ce8b3b2ea7f719b", "filename": "src/librustc_ast_pretty/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_pretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_pretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpp.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -132,10 +132,10 @@\n //! methods called `Printer::scan_*`, and the 'PRINT' process is the\n //! method called `Printer::print`.\n \n-use log::debug;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n use std::fmt;\n+use tracing::debug;\n \n /// How to break. Described in more detail in the module docs.\n #[derive(Clone, Copy, PartialEq)]"}, {"sha": "4b228629ad719e2e2bac4a58687b2a5a00398326", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -450,7 +450,9 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn print_comment(&mut self, cmnt: &comments::Comment) {\n         match cmnt.style {\n             comments::Mixed => {\n-                self.zerobreak();\n+                if !self.is_beginning_of_line() {\n+                    self.zerobreak();\n+                }\n                 if let Some((last, lines)) = cmnt.lines.split_last() {\n                     self.ibox(0);\n "}, {"sha": "c612781153e8fa5476e9f30eeee8fc944ba61b77", "filename": "src/librustc_builtin_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_builtin_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_builtin_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_parse_format = { path = \"../librustc_parse_format\" }\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "ec4dfabdcc2f04bd5d9676af0417e5ba9837089a", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -15,7 +15,7 @@ bitflags = \"1.0\"\n flate2 = \"1.0\"\n libc = \"0.2\"\n measureme = \"0.7.1\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc-demangle = \"0.1\"\n rustc_attr = { path = \"../librustc_attr\" }"}, {"sha": "afdc8dc618794ace87da73a39736676f0141b0a9", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -172,7 +172,12 @@ pub fn get_fn(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) -> &'ll Value\n             }\n         }\n \n-        if cx.use_dll_storage_attrs && tcx.is_dllimport_foreign_item(instance_def_id) {\n+        // MinGW: For backward compatibility we rely on the linker to decide whether it\n+        // should use dllimport for functions.\n+        if cx.use_dll_storage_attrs\n+            && tcx.is_dllimport_foreign_item(instance_def_id)\n+            && tcx.sess.target.target.target_env != \"gnu\"\n+        {\n             unsafe {\n                 llvm::LLVMSetDLLStorageClass(llfn, llvm::DLLStorageClass::DllImport);\n             }"}, {"sha": "1288870f55f1f40ccb3b7dd24a23581e6723fa84", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -287,7 +287,7 @@ impl CodegenCx<'ll, 'tcx> {\n             // argument validation.\n             debug_assert!(\n                 !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-                    && self.tcx.sess.target.target.options.is_like_msvc\n+                    && self.tcx.sess.target.target.options.is_like_windows\n                     && self.tcx.sess.opts.cg.prefer_dynamic)\n             );\n "}, {"sha": "26707fdf8395af9f59015b7a078a8a1389e2869e", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -217,7 +217,16 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         // attributes in LLVM IR as well as native dependencies (in C these\n         // correspond to `__declspec(dllimport)`).\n         //\n-        // Whenever a dynamic library is built by MSVC it must have its public\n+        // LD (BFD) in MinGW mode can often correctly guess `dllexport` but\n+        // relying on that can result in issues like #50176.\n+        // LLD won't support that and expects symbols with proper attributes.\n+        // Because of that we make MinGW target emit dllexport just like MSVC.\n+        // When it comes to dllimport we use it for constants but for functions\n+        // rely on the linker to do the right thing. Opposed to dllexport this\n+        // task is easy for them (both LD and LLD) and allows us to easily use\n+        // symbols from static libraries in shared libraries.\n+        //\n+        // Whenever a dynamic library is built on Windows it must have its public\n         // interface specified by functions tagged with `dllexport` or otherwise\n         // they're not available to be linked against. This poses a few problems\n         // for the compiler, some of which are somewhat fundamental, but we use\n@@ -254,8 +263,8 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         // this effect) by marking very little as `dllimport` and praying the\n         // linker will take care of everything. Fixing this problem will likely\n         // require adding a few attributes to Rust itself (feature gated at the\n-        // start) and then strongly recommending static linkage on MSVC!\n-        let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_msvc;\n+        // start) and then strongly recommending static linkage on Windows!\n+        let use_dll_storage_attrs = tcx.sess.target.target.options.is_like_windows;\n \n         let check_overflow = tcx.sess.overflow_checks();\n "}, {"sha": "4d9747a43f2e2b64e3c9681c50414a1490faf953", "filename": "src/librustc_codegen_llvm/coverageinfo/mapgen.rs", "status": "modified", "additions": 117, "deletions": 155, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmapgen.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,23 +1,15 @@\n-use crate::llvm;\n-\n use crate::common::CodegenCx;\n use crate::coverageinfo;\n+use crate::llvm;\n \n+use llvm::coverageinfo::CounterMappingRegion;\n use log::debug;\n-use rustc_codegen_ssa::coverageinfo::map::*;\n-use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, MiscMethods};\n+use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression, Region};\n+use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_llvm::RustString;\n-use rustc_middle::ty::Instance;\n-use rustc_middle::{bug, mir};\n \n-use std::collections::BTreeMap;\n use std::ffi::CString;\n-use std::path::PathBuf;\n-\n-// FIXME(richkadel): Complete all variations of generating and exporting the coverage map to LLVM.\n-// The current implementation is an initial foundation with basic capabilities (Counters, but not\n-// CounterExpressions, etc.).\n \n /// Generates and exports the Coverage Map.\n ///\n@@ -32,174 +24,123 @@ use std::path::PathBuf;\n /// undocumented details in Clang's implementation (that may or may not be important) were also\n /// replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n-    let mut coverage_writer = CoverageMappingWriter::new(cx);\n-\n     let function_coverage_map = cx.coverage_context().take_function_coverage_map();\n+    if function_coverage_map.is_empty() {\n+        // This module has no functions with coverage instrumentation\n+        return;\n+    }\n+\n+    let mut mapgen = CoverageMapGenerator::new();\n \n     // Encode coverage mappings and generate function records\n     let mut function_records = Vec::<&'ll llvm::Value>::new();\n     let coverage_mappings_buffer = llvm::build_byte_buffer(|coverage_mappings_buffer| {\n         for (instance, function_coverage) in function_coverage_map.into_iter() {\n-            if let Some(function_record) = coverage_writer.write_function_mappings_and_record(\n-                instance,\n-                function_coverage,\n-                coverage_mappings_buffer,\n-            ) {\n-                function_records.push(function_record);\n-            }\n+            debug!(\"Generate coverage map for: {:?}\", instance);\n+\n+            let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n+            let function_source_hash = function_coverage.source_hash();\n+            let (expressions, counter_regions) =\n+                function_coverage.get_expressions_and_counter_regions();\n+\n+            let old_len = coverage_mappings_buffer.len();\n+            mapgen.write_coverage_mappings(expressions, counter_regions, coverage_mappings_buffer);\n+            let mapping_data_size = coverage_mappings_buffer.len() - old_len;\n+            debug_assert!(\n+                mapping_data_size > 0,\n+                \"Every `FunctionCoverage` should have at least one counter\"\n+            );\n+\n+            let function_record = mapgen.make_function_record(\n+                cx,\n+                mangled_function_name,\n+                function_source_hash,\n+                mapping_data_size,\n+            );\n+            function_records.push(function_record);\n         }\n     });\n \n-    // Encode all filenames covered in this module, ordered by `file_id`\n+    // Encode all filenames referenced by counters/expressions in this module\n     let filenames_buffer = llvm::build_byte_buffer(|filenames_buffer| {\n-        coverageinfo::write_filenames_section_to_buffer(\n-            &coverage_writer.filenames,\n-            filenames_buffer,\n-        );\n+        coverageinfo::write_filenames_section_to_buffer(&mapgen.filenames, filenames_buffer);\n     });\n \n-    if coverage_mappings_buffer.len() > 0 {\n-        // Generate the LLVM IR representation of the coverage map and store it in a well-known\n-        // global constant.\n-        coverage_writer.write_coverage_map(\n-            function_records,\n-            filenames_buffer,\n-            coverage_mappings_buffer,\n-        );\n-    }\n+    // Generate the LLVM IR representation of the coverage map and store it in a well-known global\n+    mapgen.save_generated_coverage_map(\n+        cx,\n+        function_records,\n+        filenames_buffer,\n+        coverage_mappings_buffer,\n+    );\n }\n \n-struct CoverageMappingWriter<'a, 'll, 'tcx> {\n-    cx: &'a CodegenCx<'ll, 'tcx>,\n+struct CoverageMapGenerator {\n     filenames: Vec<CString>,\n     filename_to_index: FxHashMap<CString, u32>,\n }\n \n-impl<'a, 'll, 'tcx> CoverageMappingWriter<'a, 'll, 'tcx> {\n-    fn new(cx: &'a CodegenCx<'ll, 'tcx>) -> Self {\n-        Self { cx, filenames: Vec::new(), filename_to_index: FxHashMap::<CString, u32>::default() }\n+impl CoverageMapGenerator {\n+    fn new() -> Self {\n+        Self { filenames: Vec::new(), filename_to_index: FxHashMap::default() }\n     }\n \n-    /// For the given function, get the coverage region data, stream it to the given buffer, and\n-    /// then generate and return a new function record.\n-    fn write_function_mappings_and_record(\n+    /// Using the `expressions` and `counter_regions` collected for the current function, generate\n+    /// the `mapping_regions` and `virtual_file_mapping`, and capture any new filenames. Then use\n+    /// LLVM APIs to encode the `virtual_file_mapping`, `expressions`, and `mapping_regions` into\n+    /// the given `coverage_mappings` byte buffer, compliant with the LLVM Coverage Mapping format.\n+    fn write_coverage_mappings(\n         &mut self,\n-        instance: Instance<'tcx>,\n-        mut function_coverage: FunctionCoverage,\n+        expressions: Vec<CounterExpression>,\n+        counter_regions: impl Iterator<Item = (Counter, &'a Region)>,\n         coverage_mappings_buffer: &RustString,\n-    ) -> Option<&'ll llvm::Value> {\n-        let cx = self.cx;\n-        let coverageinfo: &mir::CoverageInfo = cx.tcx.coverageinfo(instance.def_id());\n-        debug!(\n-            \"Generate coverage map for: {:?}, num_counters: {}, num_expressions: {}\",\n-            instance, coverageinfo.num_counters, coverageinfo.num_expressions\n-        );\n-        debug_assert!(coverageinfo.num_counters > 0);\n-\n-        let regions_in_file_order = function_coverage.regions_in_file_order(cx.sess().source_map());\n-        if regions_in_file_order.len() == 0 {\n-            return None;\n+    ) {\n+        let mut counter_regions = counter_regions.collect::<Vec<_>>();\n+        if counter_regions.is_empty() {\n+            return;\n         }\n \n-        // Stream the coverage mapping regions for the function (`instance`) to the buffer, and\n-        // compute the data byte size used.\n-        let old_len = coverage_mappings_buffer.len();\n-        self.regions_to_mappings(regions_in_file_order, coverage_mappings_buffer);\n-        let mapping_data_size = coverage_mappings_buffer.len() - old_len;\n-        debug_assert!(mapping_data_size > 0);\n-\n-        let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n-        let name_ref = coverageinfo::compute_hash(&mangled_function_name);\n-        let function_source_hash = function_coverage.source_hash();\n-\n-        // Generate and return the function record\n-        let name_ref_val = cx.const_u64(name_ref);\n-        let mapping_data_size_val = cx.const_u32(mapping_data_size as u32);\n-        let func_hash_val = cx.const_u64(function_source_hash);\n-        Some(cx.const_struct(\n-            &[name_ref_val, mapping_data_size_val, func_hash_val],\n-            /*packed=*/ true,\n-        ))\n-    }\n-\n-    /// For each coverage region, extract its coverage data from the earlier coverage analysis.\n-    /// Use LLVM APIs to convert the data into buffered bytes compliant with the LLVM Coverage\n-    /// Mapping format.\n-    fn regions_to_mappings(\n-        &mut self,\n-        regions_in_file_order: BTreeMap<PathBuf, BTreeMap<CoverageLoc, (usize, CoverageKind)>>,\n-        coverage_mappings_buffer: &RustString,\n-    ) {\n         let mut virtual_file_mapping = Vec::new();\n-        let mut mapping_regions = coverageinfo::SmallVectorCounterMappingRegion::new();\n-        let mut expressions = coverageinfo::SmallVectorCounterExpression::new();\n-\n-        for (file_id, (file_path, file_coverage_regions)) in\n-            regions_in_file_order.into_iter().enumerate()\n-        {\n-            let file_id = file_id as u32;\n-            let filename = CString::new(file_path.to_string_lossy().to_string())\n-                .expect(\"null error converting filename to C string\");\n-            debug!(\"  file_id: {} = '{:?}'\", file_id, filename);\n-            let filenames_index = match self.filename_to_index.get(&filename) {\n-                Some(index) => *index,\n-                None => {\n-                    let index = self.filenames.len() as u32;\n-                    self.filenames.push(filename.clone());\n-                    self.filename_to_index.insert(filename, index);\n-                    index\n+        let mut mapping_regions = Vec::new();\n+        let mut current_file_path = None;\n+        let mut current_file_id = 0;\n+\n+        // Convert the list of (Counter, Region) pairs to an array of `CounterMappingRegion`, sorted\n+        // by filename and position. Capture any new files to compute the `CounterMappingRegion`s\n+        // `file_id` (indexing files referenced by the current function), and construct the\n+        // function-specific `virtual_file_mapping` from `file_id` to its index in the module's\n+        // `filenames` array.\n+        counter_regions.sort_unstable_by_key(|(_counter, region)| *region);\n+        for (counter, region) in counter_regions {\n+            let (file_path, start_line, start_col, end_line, end_col) = region.file_start_and_end();\n+            let same_file = current_file_path.as_ref().map_or(false, |p| p == file_path);\n+            if !same_file {\n+                if current_file_path.is_some() {\n+                    current_file_id += 1;\n                 }\n-            };\n-            virtual_file_mapping.push(filenames_index);\n-\n-            let mut mapping_indexes = vec![0 as u32; file_coverage_regions.len()];\n-            for (mapping_index, (region_id, _)) in file_coverage_regions.values().enumerate() {\n-                mapping_indexes[*region_id] = mapping_index as u32;\n-            }\n-\n-            for (region_loc, (region_id, region_kind)) in file_coverage_regions.into_iter() {\n-                let mapping_index = mapping_indexes[region_id];\n-                match region_kind {\n-                    CoverageKind::Counter => {\n-                        debug!(\n-                            \"  Counter {}, file_id: {}, region_loc: {}\",\n-                            mapping_index, file_id, region_loc\n-                        );\n-                        mapping_regions.push_from(\n-                            mapping_index,\n-                            file_id,\n-                            region_loc.start_line,\n-                            region_loc.start_col,\n-                            region_loc.end_line,\n-                            region_loc.end_col,\n-                        );\n-                    }\n-                    CoverageKind::CounterExpression(lhs, op, rhs) => {\n-                        debug!(\n-                            \"  CounterExpression {} = {} {:?} {}, file_id: {}, region_loc: {:?}\",\n-                            mapping_index, lhs, op, rhs, file_id, region_loc,\n-                        );\n-                        mapping_regions.push_from(\n-                            mapping_index,\n-                            file_id,\n-                            region_loc.start_line,\n-                            region_loc.start_col,\n-                            region_loc.end_line,\n-                            region_loc.end_col,\n-                        );\n-                        expressions.push_from(op, lhs, rhs);\n-                    }\n-                    CoverageKind::Unreachable => {\n-                        debug!(\n-                            \"  Unreachable region, file_id: {}, region_loc: {:?}\",\n-                            file_id, region_loc,\n-                        );\n-                        bug!(\"Unreachable region not expected and not yet handled!\")\n-                        // FIXME(richkadel): implement and call\n-                        //   mapping_regions.push_from(...) for unreachable regions\n+                current_file_path = Some(file_path.clone());\n+                let filename = CString::new(file_path.to_string_lossy().to_string())\n+                    .expect(\"null error converting filename to C string\");\n+                debug!(\"  file_id: {} = '{:?}'\", current_file_id, filename);\n+                let filenames_index = match self.filename_to_index.get(&filename) {\n+                    Some(index) => *index,\n+                    None => {\n+                        let index = self.filenames.len() as u32;\n+                        self.filenames.push(filename.clone());\n+                        self.filename_to_index.insert(filename.clone(), index);\n+                        index\n                     }\n-                }\n+                };\n+                virtual_file_mapping.push(filenames_index);\n             }\n+            mapping_regions.push(CounterMappingRegion::code_region(\n+                counter,\n+                current_file_id,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+            ));\n         }\n \n         // Encode and append the current function's coverage mapping data\n@@ -211,14 +152,35 @@ impl<'a, 'll, 'tcx> CoverageMappingWriter<'a, 'll, 'tcx> {\n         );\n     }\n \n-    fn write_coverage_map(\n+    /// Generate and return the function record `Value`\n+    fn make_function_record(\n+        &mut self,\n+        cx: &CodegenCx<'ll, 'tcx>,\n+        mangled_function_name: String,\n+        function_source_hash: u64,\n+        mapping_data_size: usize,\n+    ) -> &'ll llvm::Value {\n+        let name_ref = coverageinfo::compute_hash(&mangled_function_name);\n+        let name_ref_val = cx.const_u64(name_ref);\n+        let mapping_data_size_val = cx.const_u32(mapping_data_size as u32);\n+        let func_hash_val = cx.const_u64(function_source_hash);\n+        cx.const_struct(\n+            &[name_ref_val, mapping_data_size_val, func_hash_val],\n+            /*packed=*/ true,\n+        )\n+    }\n+\n+    /// Combine the filenames and coverage mappings buffers, construct coverage map header and the\n+    /// array of function records, and combine everything into the complete coverage map. Save the\n+    /// coverage map data into the LLVM IR as a static global using a specific, well-known section\n+    /// and name.\n+    fn save_generated_coverage_map(\n         self,\n+        cx: &CodegenCx<'ll, 'tcx>,\n         function_records: Vec<&'ll llvm::Value>,\n         filenames_buffer: Vec<u8>,\n         mut coverage_mappings_buffer: Vec<u8>,\n     ) {\n-        let cx = self.cx;\n-\n         // Concatenate the encoded filenames and encoded coverage mappings, and add additional zero\n         // bytes as-needed to ensure 8-byte alignment.\n         let mut coverage_size = coverage_mappings_buffer.len();"}, {"sha": "9d2090eae8f19669429e42c172942afa0d901973", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "modified", "additions": 31, "deletions": 123, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -4,8 +4,9 @@ use crate::builder::Builder;\n use crate::common::CodegenCx;\n \n use libc::c_uint;\n+use llvm::coverageinfo::CounterMappingRegion;\n use log::debug;\n-use rustc_codegen_ssa::coverageinfo::map::*;\n+use rustc_codegen_ssa::coverageinfo::map::{CounterExpression, ExprKind, FunctionCoverage};\n use rustc_codegen_ssa::traits::{\n     BaseTypeMethods, CoverageInfoBuilderMethods, CoverageInfoMethods, StaticMethods,\n };\n@@ -23,15 +24,15 @@ const COVMAP_VAR_ALIGN_BYTES: usize = 8;\n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'tcx> {\n     // Coverage region data for each instrumented function identified by DefId.\n-    pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage>>,\n+    pub(crate) function_coverage_map: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>>>,\n }\n \n impl<'tcx> CrateCoverageContext<'tcx> {\n     pub fn new() -> Self {\n         Self { function_coverage_map: Default::default() }\n     }\n \n-    pub fn take_function_coverage_map(&self) -> FxHashMap<Instance<'tcx>, FunctionCoverage> {\n+    pub fn take_function_coverage_map(&self) -> FxHashMap<Instance<'tcx>, FunctionCoverage<'tcx>> {\n         self.function_coverage_map.replace(FxHashMap::default())\n     }\n }\n@@ -47,44 +48,49 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         &mut self,\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n-        index: u32,\n+        id: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, index={}, byte range {}..{}\",\n-            instance, function_source_hash, index, start_byte_pos, end_byte_pos,\n+            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={}, \\\n+             byte range {}..{}\",\n+            instance, function_source_hash, id, start_byte_pos, end_byte_pos,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n-            .or_insert_with(|| {\n-                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n-            })\n-            .add_counter(function_source_hash, index, start_byte_pos, end_byte_pos);\n+            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+            .add_counter(function_source_hash, id, start_byte_pos, end_byte_pos);\n     }\n \n     fn add_counter_expression_region(\n         &mut self,\n         instance: Instance<'tcx>,\n-        index: u32,\n+        id_descending_from_max: u32,\n         lhs: u32,\n-        op: CounterOp,\n+        op: ExprKind,\n         rhs: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n         debug!(\n-            \"adding counter expression to coverage_regions: instance={:?}, index={}, {} {:?} {}, byte range {}..{}\",\n-            instance, index, lhs, op, rhs, start_byte_pos, end_byte_pos,\n+            \"adding counter expression to coverage_regions: instance={:?}, id={}, {} {:?} {}, \\\n+             byte range {}..{}\",\n+            instance, id_descending_from_max, lhs, op, rhs, start_byte_pos, end_byte_pos,\n         );\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n-            .or_insert_with(|| {\n-                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n-            })\n-            .add_counter_expression(index, lhs, op, rhs, start_byte_pos, end_byte_pos);\n+            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+            .add_counter_expression(\n+                id_descending_from_max,\n+                lhs,\n+                op,\n+                rhs,\n+                start_byte_pos,\n+                end_byte_pos,\n+            );\n     }\n \n     fn add_unreachable_region(\n@@ -100,108 +106,8 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n         coverage_regions\n             .entry(instance)\n-            .or_insert_with(|| {\n-                FunctionCoverage::with_coverageinfo(self.tcx.coverageinfo(instance.def_id()))\n-            })\n-            .add_unreachable(start_byte_pos, end_byte_pos);\n-    }\n-}\n-\n-/// This struct wraps an opaque reference to the C++ template instantiation of\n-/// `llvm::SmallVector<coverage::CounterExpression>`. Each `coverage::CounterExpression` object is\n-/// constructed from primative-typed arguments, and pushed to the `SmallVector`, in the C++\n-/// implementation of `LLVMRustCoverageSmallVectorCounterExpressionAdd()` (see\n-/// `src/rustllvm/CoverageMappingWrapper.cpp`).\n-pub struct SmallVectorCounterExpression<'a> {\n-    pub raw: &'a mut llvm::coverageinfo::SmallVectorCounterExpression<'a>,\n-}\n-\n-impl SmallVectorCounterExpression<'a> {\n-    pub fn new() -> Self {\n-        SmallVectorCounterExpression {\n-            raw: unsafe { llvm::LLVMRustCoverageSmallVectorCounterExpressionCreate() },\n-        }\n-    }\n-\n-    pub fn as_ptr(&self) -> *const llvm::coverageinfo::SmallVectorCounterExpression<'a> {\n-        self.raw\n-    }\n-\n-    pub fn push_from(\n-        &mut self,\n-        kind: rustc_codegen_ssa::coverageinfo::CounterOp,\n-        left_index: u32,\n-        right_index: u32,\n-    ) {\n-        unsafe {\n-            llvm::LLVMRustCoverageSmallVectorCounterExpressionAdd(\n-                &mut *(self.raw as *mut _),\n-                kind,\n-                left_index,\n-                right_index,\n-            )\n-        }\n-    }\n-}\n-\n-impl Drop for SmallVectorCounterExpression<'a> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMRustCoverageSmallVectorCounterExpressionDispose(&mut *(self.raw as *mut _));\n-        }\n-    }\n-}\n-\n-/// This struct wraps an opaque reference to the C++ template instantiation of\n-/// `llvm::SmallVector<coverage::CounterMappingRegion>`. Each `coverage::CounterMappingRegion`\n-/// object is constructed from primative-typed arguments, and pushed to the `SmallVector`, in the\n-/// C++ implementation of `LLVMRustCoverageSmallVectorCounterMappingRegionAdd()` (see\n-/// `src/rustllvm/CoverageMappingWrapper.cpp`).\n-pub struct SmallVectorCounterMappingRegion<'a> {\n-    pub raw: &'a mut llvm::coverageinfo::SmallVectorCounterMappingRegion<'a>,\n-}\n-\n-impl SmallVectorCounterMappingRegion<'a> {\n-    pub fn new() -> Self {\n-        SmallVectorCounterMappingRegion {\n-            raw: unsafe { llvm::LLVMRustCoverageSmallVectorCounterMappingRegionCreate() },\n-        }\n-    }\n-\n-    pub fn as_ptr(&self) -> *const llvm::coverageinfo::SmallVectorCounterMappingRegion<'a> {\n-        self.raw\n-    }\n-\n-    pub fn push_from(\n-        &mut self,\n-        index: u32,\n-        file_id: u32,\n-        line_start: u32,\n-        column_start: u32,\n-        line_end: u32,\n-        column_end: u32,\n-    ) {\n-        unsafe {\n-            llvm::LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n-                &mut *(self.raw as *mut _),\n-                index,\n-                file_id,\n-                line_start,\n-                column_start,\n-                line_end,\n-                column_end,\n-            )\n-        }\n-    }\n-}\n-\n-impl Drop for SmallVectorCounterMappingRegion<'a> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n-                &mut *(self.raw as *mut _),\n-            );\n-        }\n+            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+            .add_unreachable_region(start_byte_pos, end_byte_pos);\n     }\n }\n \n@@ -218,16 +124,18 @@ pub(crate) fn write_filenames_section_to_buffer(filenames: &Vec<CString>, buffer\n \n pub(crate) fn write_mapping_to_buffer(\n     virtual_file_mapping: Vec<u32>,\n-    expressions: SmallVectorCounterExpression<'_>,\n-    mapping_regions: SmallVectorCounterMappingRegion<'_>,\n+    expressions: Vec<CounterExpression>,\n+    mut mapping_regions: Vec<CounterMappingRegion>,\n     buffer: &RustString,\n ) {\n     unsafe {\n         llvm::LLVMRustCoverageWriteMappingToBuffer(\n             virtual_file_mapping.as_ptr(),\n             virtual_file_mapping.len() as c_uint,\n             expressions.as_ptr(),\n-            mapping_regions.as_ptr(),\n+            expressions.len() as c_uint,\n+            mapping_regions.as_mut_ptr(),\n+            mapping_regions.len() as c_uint,\n             buffer,\n         );\n     }"}, {"sha": "728af7b0a8cd177323e7def9bd8db33893379b75", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 59, "deletions": 54, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -13,7 +13,7 @@ use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n-use rustc_codegen_ssa::coverageinfo::CounterOp;\n+use rustc_codegen_ssa::coverageinfo::ExprKind;\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n@@ -90,64 +90,69 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         args: &Vec<Operand<'tcx>>,\n         caller_instance: ty::Instance<'tcx>,\n     ) -> bool {\n+        let mut is_codegen_intrinsic = true;\n+        // Set `is_codegen_intrinsic` to `false` to bypass `codegen_intrinsic_call()`.\n+\n         if self.tcx.sess.opts.debugging_opts.instrument_coverage {\n-            // Add the coverage information from the MIR to the Codegen context. Some coverage\n-            // intrinsics are used only to pass along the coverage information (returns `false`\n-            // for `is_codegen_intrinsic()`), but `count_code_region` is also converted into an\n-            // LLVM intrinsic to increment a coverage counter.\n-            match intrinsic {\n-                sym::count_code_region => {\n-                    use coverage::count_code_region_args::*;\n-                    self.add_counter_region(\n-                        caller_instance,\n-                        op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n-                        op_to_u32(&args[COUNTER_INDEX]),\n-                        op_to_u32(&args[START_BYTE_POS]),\n-                        op_to_u32(&args[END_BYTE_POS]),\n-                    );\n-                    return true; // Also inject the counter increment in the backend\n-                }\n-                sym::coverage_counter_add | sym::coverage_counter_subtract => {\n-                    use coverage::coverage_counter_expression_args::*;\n-                    self.add_counter_expression_region(\n-                        caller_instance,\n-                        op_to_u32(&args[COUNTER_EXPRESSION_INDEX]),\n-                        op_to_u32(&args[LEFT_INDEX]),\n-                        if intrinsic == sym::coverage_counter_add {\n-                            CounterOp::Add\n-                        } else {\n-                            CounterOp::Subtract\n-                        },\n-                        op_to_u32(&args[RIGHT_INDEX]),\n-                        op_to_u32(&args[START_BYTE_POS]),\n-                        op_to_u32(&args[END_BYTE_POS]),\n-                    );\n-                    return false; // Does not inject backend code\n+            // If the intrinsic is from the local MIR, add the coverage information to the Codegen\n+            // context, to be encoded into the local crate's coverage map.\n+            if caller_instance.def_id().is_local() {\n+                // FIXME(richkadel): Make sure to add coverage analysis tests on a crate with\n+                // external crate dependencies, where:\n+                //   1. Both binary and dependent crates are compiled with `-Zinstrument-coverage`\n+                //   2. Only binary is compiled with `-Zinstrument-coverage`\n+                //   3. Only dependent crates are compiled with `-Zinstrument-coverage`\n+                match intrinsic {\n+                    sym::count_code_region => {\n+                        use coverage::count_code_region_args::*;\n+                        self.add_counter_region(\n+                            caller_instance,\n+                            op_to_u64(&args[FUNCTION_SOURCE_HASH]),\n+                            op_to_u32(&args[COUNTER_ID]),\n+                            op_to_u32(&args[START_BYTE_POS]),\n+                            op_to_u32(&args[END_BYTE_POS]),\n+                        );\n+                    }\n+                    sym::coverage_counter_add | sym::coverage_counter_subtract => {\n+                        use coverage::coverage_counter_expression_args::*;\n+                        self.add_counter_expression_region(\n+                            caller_instance,\n+                            op_to_u32(&args[EXPRESSION_ID]),\n+                            op_to_u32(&args[LEFT_ID]),\n+                            if intrinsic == sym::coverage_counter_add {\n+                                ExprKind::Add\n+                            } else {\n+                                ExprKind::Subtract\n+                            },\n+                            op_to_u32(&args[RIGHT_ID]),\n+                            op_to_u32(&args[START_BYTE_POS]),\n+                            op_to_u32(&args[END_BYTE_POS]),\n+                        );\n+                    }\n+                    sym::coverage_unreachable => {\n+                        use coverage::coverage_unreachable_args::*;\n+                        self.add_unreachable_region(\n+                            caller_instance,\n+                            op_to_u32(&args[START_BYTE_POS]),\n+                            op_to_u32(&args[END_BYTE_POS]),\n+                        );\n+                    }\n+                    _ => {}\n                 }\n-                sym::coverage_unreachable => {\n-                    use coverage::coverage_unreachable_args::*;\n-                    self.add_unreachable_region(\n-                        caller_instance,\n-                        op_to_u32(&args[START_BYTE_POS]),\n-                        op_to_u32(&args[END_BYTE_POS]),\n-                    );\n-                    return false; // Does not inject backend code\n+            }\n+\n+            // Only the `count_code_region` coverage intrinsic is translated into an actual LLVM\n+            // intrinsic call (local or not); otherwise, set `is_codegen_intrinsic` to `false`.\n+            match intrinsic {\n+                sym::coverage_counter_add\n+                | sym::coverage_counter_subtract\n+                | sym::coverage_unreachable => {\n+                    is_codegen_intrinsic = false;\n                 }\n                 _ => {}\n             }\n-        } else {\n-            // NOT self.tcx.sess.opts.debugging_opts.instrument_coverage\n-            if intrinsic == sym::count_code_region {\n-                // An external crate may have been pre-compiled with coverage instrumentation, and\n-                // some references from the current crate to the external crate might carry along\n-                // the call terminators to coverage intrinsics, like `count_code_region` (for\n-                // example, when instantiating a generic function). If the current crate has\n-                // `instrument_coverage` disabled, the `count_code_region` call terminators should\n-                // be ignored.\n-                return false; // Do not inject coverage counters inlined from external crates\n-            }\n         }\n-        true // Unhandled intrinsics should be passed to `codegen_intrinsic_call()`\n+        is_codegen_intrinsic\n     }\n \n     fn codegen_intrinsic_call(\n@@ -219,7 +224,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 let num_counters = self.const_u32(coverageinfo.num_counters);\n                 use coverage::count_code_region_args::*;\n                 let hash = args[FUNCTION_SOURCE_HASH].immediate();\n-                let index = args[COUNTER_INDEX].immediate();\n+                let index = args[COUNTER_ID].immediate();\n                 debug!(\n                     \"translating Rust intrinsic `count_code_region()` to LLVM intrinsic: \\\n                     instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\","}, {"sha": "eb7dc827f9391b38fa15c332c9f79d805038879c", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 147, "deletions": 33, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,7 +1,7 @@\n #![allow(non_camel_case_types)]\n #![allow(non_upper_case_globals)]\n \n-use super::coverageinfo::{SmallVectorCounterExpression, SmallVectorCounterMappingRegion};\n+use rustc_codegen_ssa::coverageinfo::map as coverage_map;\n \n use super::debuginfo::{\n     DIArray, DIBasicType, DIBuilder, DICompositeType, DIDerivedType, DIDescriptor, DIEnumerator,\n@@ -653,13 +653,152 @@ pub type DiagnosticHandler = unsafe extern \"C\" fn(&DiagnosticInfo, *mut c_void);\n pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(&SMDiagnostic, *const c_void, c_uint);\n \n pub mod coverageinfo {\n-    use super::InvariantOpaque;\n+    use super::coverage_map;\n \n+    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L205-L221)\n+    #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n-    pub struct SmallVectorCounterExpression<'a>(InvariantOpaque<'a>);\n+    pub enum RegionKind {\n+        /// A CodeRegion associates some code with a counter\n+        CodeRegion = 0,\n+\n+        /// An ExpansionRegion represents a file expansion region that associates\n+        /// a source range with the expansion of a virtual source file, such as\n+        /// for a macro instantiation or #include file.\n+        ExpansionRegion = 1,\n+\n+        /// A SkippedRegion represents a source range with code that was skipped\n+        /// by a preprocessor or similar means.\n+        SkippedRegion = 2,\n+\n+        /// A GapRegion is like a CodeRegion, but its count is only set as the\n+        /// line execution count when its the only region in the line.\n+        GapRegion = 3,\n+    }\n \n+    /// This struct provides LLVM's representation of a \"CoverageMappingRegion\", encoded into the\n+    /// coverage map, in accordance with the\n+    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+    /// The struct composes fields representing the `Counter` type and value(s) (injected counter\n+    /// ID, or expression type and operands), the source file (an indirect index into a \"filenames\n+    /// array\", encoded separately), and source location (start and end positions of the represented\n+    /// code region).\n+    ///\n+    /// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L223-L226)\n+    /// Important: The Rust struct layout (order and types of fields) must match its C++\n+    /// counterpart.\n+    #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n-    pub struct SmallVectorCounterMappingRegion<'a>(InvariantOpaque<'a>);\n+    pub struct CounterMappingRegion {\n+        /// The counter type and type-dependent counter data, if any.\n+        counter: coverage_map::Counter,\n+\n+        /// An indirect reference to the source filename. In the LLVM Coverage Mapping Format, the\n+        /// file_id is an index into a function-specific `virtual_file_mapping` array of indexes\n+        /// that, in turn, are used to look up the filename for this region.\n+        file_id: u32,\n+\n+        /// If the `RegionKind` is an `ExpansionRegion`, the `expanded_file_id` can be used to find\n+        /// the mapping regions created as a result of macro expansion, by checking if their file id\n+        /// matches the expanded file id.\n+        expanded_file_id: u32,\n+\n+        /// 1-based starting line of the mapping region.\n+        start_line: u32,\n+\n+        /// 1-based starting column of the mapping region.\n+        start_col: u32,\n+\n+        /// 1-based ending line of the mapping region.\n+        end_line: u32,\n+\n+        /// 1-based ending column of the mapping region. If the high bit is set, the current\n+        /// mapping region is a gap area.\n+        end_col: u32,\n+\n+        kind: RegionKind,\n+    }\n+\n+    impl CounterMappingRegion {\n+        pub fn code_region(\n+            counter: coverage_map::Counter,\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter,\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::CodeRegion,\n+            }\n+        }\n+\n+        pub fn expansion_region(\n+            file_id: u32,\n+            expanded_file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter: coverage_map::Counter::zero(),\n+                file_id,\n+                expanded_file_id,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::ExpansionRegion,\n+            }\n+        }\n+\n+        pub fn skipped_region(\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter: coverage_map::Counter::zero(),\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col,\n+                kind: RegionKind::SkippedRegion,\n+            }\n+        }\n+\n+        pub fn gap_region(\n+            counter: coverage_map::Counter,\n+            file_id: u32,\n+            start_line: u32,\n+            start_col: u32,\n+            end_line: u32,\n+            end_col: u32,\n+        ) -> Self {\n+            Self {\n+                counter,\n+                file_id,\n+                expanded_file_id: 0,\n+                start_line,\n+                start_col,\n+                end_line,\n+                end_col: ((1 as u32) << 31) | end_col,\n+                kind: RegionKind::GapRegion,\n+            }\n+        }\n+    }\n }\n \n pub mod debuginfo {\n@@ -1645,33 +1784,6 @@ extern \"C\" {\n         ConstraintsLen: size_t,\n     ) -> bool;\n \n-    pub fn LLVMRustCoverageSmallVectorCounterExpressionCreate()\n-    -> &'a mut SmallVectorCounterExpression<'a>;\n-    pub fn LLVMRustCoverageSmallVectorCounterExpressionDispose(\n-        Container: &'a mut SmallVectorCounterExpression<'a>,\n-    );\n-    pub fn LLVMRustCoverageSmallVectorCounterExpressionAdd(\n-        Container: &mut SmallVectorCounterExpression<'a>,\n-        Kind: rustc_codegen_ssa::coverageinfo::CounterOp,\n-        LeftIndex: c_uint,\n-        RightIndex: c_uint,\n-    );\n-\n-    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionCreate()\n-    -> &'a mut SmallVectorCounterMappingRegion<'a>;\n-    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionDispose(\n-        Container: &'a mut SmallVectorCounterMappingRegion<'a>,\n-    );\n-    pub fn LLVMRustCoverageSmallVectorCounterMappingRegionAdd(\n-        Container: &mut SmallVectorCounterMappingRegion<'a>,\n-        Index: c_uint,\n-        FileID: c_uint,\n-        LineStart: c_uint,\n-        ColumnStart: c_uint,\n-        LineEnd: c_uint,\n-        ColumnEnd: c_uint,\n-    );\n-\n     #[allow(improper_ctypes)]\n     pub fn LLVMRustCoverageWriteFilenamesSectionToBuffer(\n         Filenames: *const *const c_char,\n@@ -1683,8 +1795,10 @@ extern \"C\" {\n     pub fn LLVMRustCoverageWriteMappingToBuffer(\n         VirtualFileMappingIDs: *const c_uint,\n         NumVirtualFileMappingIDs: c_uint,\n-        Expressions: *const SmallVectorCounterExpression<'_>,\n-        MappingRegions: *const SmallVectorCounterMappingRegion<'_>,\n+        Expressions: *const coverage_map::CounterExpression,\n+        NumExpressions: c_uint,\n+        MappingRegions: *mut coverageinfo::CounterMappingRegion,\n+        NumMappingRegions: c_uint,\n         BufferOut: &RustString,\n     );\n "}, {"sha": "8fa0de37648f3649ec68f15a2068804b2c1b52f6", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -14,7 +14,7 @@ bitflags = \"1.2.1\"\n cc = \"1.0.1\"\n num_cpus = \"1.0\"\n memmap = \"0.7\"\n-log = \"0.4.5\"\n+log = { package = \"tracing\", version = \"0.1\" }\n libc = \"0.2.50\"\n jobserver = \"0.1.11\"\n tempfile = \"3.1\""}, {"sha": "f9a782af24cda7c74b3cb725e69fecd296669db8", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -523,8 +523,9 @@ impl<'a> Linker for GccLinker<'a> {\n             return;\n         }\n \n+        let is_windows = self.sess.target.target.options.is_like_windows;\n         let mut arg = OsString::new();\n-        let path = tmpdir.join(\"list\");\n+        let path = tmpdir.join(if is_windows { \"list.def\" } else { \"list\" });\n \n         debug!(\"EXPORTED SYMBOLS:\");\n \n@@ -540,6 +541,21 @@ impl<'a> Linker for GccLinker<'a> {\n             if let Err(e) = res {\n                 self.sess.fatal(&format!(\"failed to write lib.def file: {}\", e));\n             }\n+        } else if is_windows {\n+            let res: io::Result<()> = try {\n+                let mut f = BufWriter::new(File::create(&path)?);\n+\n+                // .def file similar to MSVC one but without LIBRARY section\n+                // because LD doesn't like when it's empty\n+                writeln!(f, \"EXPORTS\")?;\n+                for symbol in self.info.exports[&crate_type].iter() {\n+                    debug!(\"  _{}\", symbol);\n+                    writeln!(f, \"  {}\", symbol)?;\n+                }\n+            };\n+            if let Err(e) = res {\n+                self.sess.fatal(&format!(\"failed to write list.def file: {}\", e));\n+            }\n         } else {\n             // Write an LD version script\n             let res: io::Result<()> = try {\n@@ -573,7 +589,10 @@ impl<'a> Linker for GccLinker<'a> {\n             if !self.is_ld {\n                 arg.push(\"-Wl,\")\n             }\n-            arg.push(\"--version-script=\");\n+            // Both LD and LLD accept export list in *.def file form, there are no flags required\n+            if !is_windows {\n+                arg.push(\"--version-script=\")\n+            }\n         }\n \n         arg.push(&path);"}, {"sha": "b0fae566a5aef39b1b77c167951fccd877db58f0", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1846,11 +1846,11 @@ fn msvc_imps_needed(tcx: TyCtxt<'_>) -> bool {\n     // something is wrong with commandline arg validation.\n     assert!(\n         !(tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-            && tcx.sess.target.target.options.is_like_msvc\n+            && tcx.sess.target.target.options.is_like_windows\n             && tcx.sess.opts.cg.prefer_dynamic)\n     );\n \n-    tcx.sess.target.target.options.is_like_msvc &&\n+    tcx.sess.target.target.options.is_like_windows &&\n         tcx.sess.crate_types().iter().any(|ct| *ct == CrateType::Rlib) &&\n     // ThinLTO can't handle this workaround in all cases, so we don't\n     // emit the `__imp_` symbols. Instead we make them unnecessary by disallowing"}, {"sha": "5b04f99499437fead897b7edfd29dd573bc52fd0", "filename": "src/librustc_codegen_ssa/coverageinfo/ffi.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fffi.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -0,0 +1,67 @@\n+use super::map::{CounterValueReference, MappedExpressionIndex};\n+\n+/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L91)\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+enum CounterKind {\n+    Zero = 0,\n+    CounterValueReference = 1,\n+    Expression = 2,\n+}\n+\n+/// A reference to an instance of an abstract \"counter\" that will yield a value in a coverage\n+/// report. Note that `id` has different interpretations, depending on the `kind`:\n+///   * For `CounterKind::Zero`, `id` is assumed to be `0`\n+///   * For `CounterKind::CounterValueReference`,  `id` matches the `counter_id` of the injected\n+///     instrumentation counter (the `index` argument to the LLVM intrinsic\n+///     `instrprof.increment()`)\n+///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of\n+///     counter expressions.\n+/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L98-L99)\n+/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct Counter {\n+    // Important: The layout (order and types of fields) must match its C++ counterpart.\n+    kind: CounterKind,\n+    id: u32,\n+}\n+\n+impl Counter {\n+    pub fn zero() -> Self {\n+        Self { kind: CounterKind::Zero, id: 0 }\n+    }\n+\n+    pub fn counter_value_reference(counter_id: CounterValueReference) -> Self {\n+        Self { kind: CounterKind::CounterValueReference, id: counter_id.into() }\n+    }\n+\n+    pub fn expression(mapped_expression_index: MappedExpressionIndex) -> Self {\n+        Self { kind: CounterKind::Expression, id: mapped_expression_index.into() }\n+    }\n+}\n+\n+/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146)\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub enum ExprKind {\n+    Subtract = 0,\n+    Add = 1,\n+}\n+\n+/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147-L148)\n+/// Important: The Rust struct layout (order and types of fields) must match its C++\n+/// counterpart.\n+#[derive(Copy, Clone, Debug)]\n+#[repr(C)]\n+pub struct CounterExpression {\n+    kind: ExprKind,\n+    lhs: Counter,\n+    rhs: Counter,\n+}\n+\n+impl CounterExpression {\n+    pub fn new(lhs: Counter, kind: ExprKind, rhs: Counter) -> Self {\n+        Self { kind, lhs, rhs }\n+    }\n+}"}, {"sha": "72138065a90ba965d1eb64419603216d02125fc0", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "modified", "additions": 285, "deletions": 210, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,289 +1,364 @@\n-use rustc_data_structures::sync::Lrc;\n-use rustc_middle::mir;\n-use rustc_span::source_map::{Pos, SourceFile, SourceMap};\n-use rustc_span::{BytePos, FileName, RealFileName};\n+pub use super::ffi::*;\n+\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::ty::Instance;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_span::source_map::{Pos, SourceMap};\n+use rustc_span::{BytePos, FileName, Loc, RealFileName};\n \n use std::cmp::{Ord, Ordering};\n-use std::collections::BTreeMap;\n use std::fmt;\n use std::path::PathBuf;\n \n-#[derive(Copy, Clone, Debug)]\n-#[repr(C)]\n-pub enum CounterOp {\n-    // Note the order (and therefore the default values) is important. With the attribute\n-    // `#[repr(C)]`, this enum matches the layout of the LLVM enum defined for the nested enum,\n-    // `llvm::coverage::CounterExpression::ExprKind`, as shown in the following source snippet:\n-    // https://github.com/rust-lang/llvm-project/blob/f208b70fbc4dee78067b3c5bd6cb92aa3ba58a1e/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146\n-    Subtract,\n-    Add,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum CoverageKind {\n-    Counter,\n-    CounterExpression(u32, CounterOp, u32),\n-    Unreachable,\n+rustc_index::newtype_index! {\n+    pub struct ExpressionOperandId {\n+        DEBUG_FORMAT = \"ExpressionOperandId({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n }\n \n-#[derive(Clone, Debug)]\n-pub struct CoverageRegion {\n-    pub kind: CoverageKind,\n-    pub start_byte_pos: u32,\n-    pub end_byte_pos: u32,\n+rustc_index::newtype_index! {\n+    pub struct CounterValueReference {\n+        DEBUG_FORMAT = \"CounterValueReference({})\",\n+        MAX = 0xFFFF_FFFF,\n+    }\n }\n \n-impl CoverageRegion {\n-    pub fn source_loc(&self, source_map: &SourceMap) -> Option<(Lrc<SourceFile>, CoverageLoc)> {\n-        let (start_file, start_line, start_col) =\n-            lookup_file_line_col(source_map, BytePos::from_u32(self.start_byte_pos));\n-        let (end_file, end_line, end_col) =\n-            lookup_file_line_col(source_map, BytePos::from_u32(self.end_byte_pos));\n-        let start_file_path = match &start_file.name {\n-            FileName::Real(RealFileName::Named(path)) => path,\n-            _ => {\n-                bug!(\"start_file_path should be a RealFileName, but it was: {:?}\", start_file.name)\n-            }\n-        };\n-        let end_file_path = match &end_file.name {\n-            FileName::Real(RealFileName::Named(path)) => path,\n-            _ => bug!(\"end_file_path should be a RealFileName, but it was: {:?}\", end_file.name),\n-        };\n-        if start_file_path == end_file_path {\n-            Some((start_file, CoverageLoc { start_line, start_col, end_line, end_col }))\n-        } else {\n-            None\n-            // FIXME(richkadel): There seems to be a problem computing the file location in\n-            // some cases. I need to investigate this more. When I generate and show coverage\n-            // for the example binary in the crates.io crate `json5format`, I had a couple of\n-            // notable problems:\n-            //\n-            //   1. I saw a lot of coverage spans in `llvm-cov show` highlighting regions in\n-            //      various comments (not corresponding to rustdoc code), indicating a possible\n-            //      problem with the byte_pos-to-source-map implementation.\n-            //\n-            //   2. And (perhaps not related) when I build the aforementioned example binary with:\n-            //      `RUST_FLAGS=\"-Zinstrument-coverage\" cargo build --example formatjson5`\n-            //      and then run that binary with\n-            //      `LLVM_PROFILE_FILE=\"formatjson5.profraw\" ./target/debug/examples/formatjson5 \\\n-            //      some.json5` for some reason the binary generates *TWO* `.profraw` files. One\n-            //      named `default.profraw` and the other named `formatjson5.profraw` (the expected\n-            //      name, in this case).\n-            //\n-            // If the byte range conversion is wrong, fix it. But if it\n-            // is right, then it is possible for the start and end to be in different files.\n-            // Can I do something other than ignore coverages that span multiple files?\n-            //\n-            // If I can resolve this, remove the \"Option<>\" result type wrapper\n-            // `regions_in_file_order()` accordingly.\n-        }\n+rustc_index::newtype_index! {\n+    pub struct InjectedExpressionIndex {\n+        DEBUG_FORMAT = \"InjectedExpressionIndex({})\",\n+        MAX = 0xFFFF_FFFF,\n     }\n }\n \n-impl Default for CoverageRegion {\n-    fn default() -> Self {\n-        Self {\n-            // The default kind (Unreachable) is a placeholder that will be overwritten before\n-            // backend codegen.\n-            kind: CoverageKind::Unreachable,\n-            start_byte_pos: 0,\n-            end_byte_pos: 0,\n-        }\n+rustc_index::newtype_index! {\n+    pub struct MappedExpressionIndex {\n+        DEBUG_FORMAT = \"MappedExpressionIndex({})\",\n+        MAX = 0xFFFF_FFFF,\n     }\n }\n \n-/// A source code region used with coverage information.\n-#[derive(Debug, Eq, PartialEq)]\n-pub struct CoverageLoc {\n-    /// The (1-based) line number of the region start.\n-    pub start_line: u32,\n-    /// The (1-based) column number of the region start.\n-    pub start_col: u32,\n-    /// The (1-based) line number of the region end.\n-    pub end_line: u32,\n-    /// The (1-based) column number of the region end.\n-    pub end_col: u32,\n+#[derive(Clone, Debug)]\n+pub struct Region {\n+    start: Loc,\n+    end: Loc,\n }\n \n-impl Ord for CoverageLoc {\n+impl Ord for Region {\n     fn cmp(&self, other: &Self) -> Ordering {\n-        (self.start_line, &self.start_col, &self.end_line, &self.end_col).cmp(&(\n-            other.start_line,\n-            &other.start_col,\n-            &other.end_line,\n-            &other.end_col,\n-        ))\n+        (&self.start.file.name, &self.start.line, &self.start.col, &self.end.line, &self.end.col)\n+            .cmp(&(\n+                &other.start.file.name,\n+                &other.start.line,\n+                &other.start.col,\n+                &other.end.line,\n+                &other.end.col,\n+            ))\n     }\n }\n \n-impl PartialOrd for CoverageLoc {\n+impl PartialOrd for Region {\n     fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n-impl fmt::Display for CoverageLoc {\n+impl PartialEq for Region {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.start.file.name == other.start.file.name\n+            && self.start.line == other.start.line\n+            && self.start.col == other.start.col\n+            && self.end.line == other.end.line\n+            && self.end.col == other.end.col\n+    }\n+}\n+\n+impl Eq for Region {}\n+\n+impl fmt::Display for Region {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Customize debug format, and repeat the file name, so generated location strings are\n-        // \"clickable\" in many IDEs.\n-        write!(f, \"{}:{} - {}:{}\", self.start_line, self.start_col, self.end_line, self.end_col)\n+        let (file_path, start_line, start_col, end_line, end_col) = self.file_start_and_end();\n+        write!(f, \"{:?}:{}:{} - {}:{}\", file_path, start_line, start_col, end_line, end_col)\n     }\n }\n \n-fn lookup_file_line_col(source_map: &SourceMap, byte_pos: BytePos) -> (Lrc<SourceFile>, u32, u32) {\n-    let found = source_map\n-        .lookup_line(byte_pos)\n-        .expect(\"should find coverage region byte position in source\");\n-    let file = found.sf;\n-    let line_pos = file.line_begin_pos(byte_pos);\n+impl Region {\n+    pub fn new(source_map: &SourceMap, start_byte_pos: u32, end_byte_pos: u32) -> Self {\n+        let start = source_map.lookup_char_pos(BytePos::from_u32(start_byte_pos));\n+        let end = source_map.lookup_char_pos(BytePos::from_u32(end_byte_pos));\n+        assert_eq!(\n+            start.file.name, end.file.name,\n+            \"Region start ({} -> {:?}) and end ({} -> {:?}) don't come from the same source file!\",\n+            start_byte_pos, start, end_byte_pos, end\n+        );\n+        Self { start, end }\n+    }\n \n-    // Use 1-based indexing.\n-    let line = (found.line + 1) as u32;\n-    let col = (byte_pos - line_pos).to_u32() + 1;\n+    pub fn file_start_and_end<'a>(&'a self) -> (&'a PathBuf, u32, u32, u32, u32) {\n+        let start = &self.start;\n+        let end = &self.end;\n+        match &start.file.name {\n+            FileName::Real(RealFileName::Named(path)) => (\n+                path,\n+                start.line as u32,\n+                start.col.to_u32() + 1,\n+                end.line as u32,\n+                end.col.to_u32() + 1,\n+            ),\n+            _ => {\n+                bug!(\"start.file.name should be a RealFileName, but it was: {:?}\", start.file.name)\n+            }\n+        }\n+    }\n+}\n \n-    (file, line, col)\n+#[derive(Clone, Debug)]\n+pub struct ExpressionRegion {\n+    lhs: ExpressionOperandId,\n+    op: ExprKind,\n+    rhs: ExpressionOperandId,\n+    region: Region,\n }\n \n+// FIXME(richkadel): There seems to be a problem computing the file location in\n+// some cases. I need to investigate this more. When I generate and show coverage\n+// for the example binary in the crates.io crate `json5format`, I had a couple of\n+// notable problems:\n+//\n+//   1. I saw a lot of coverage spans in `llvm-cov show` highlighting regions in\n+//      various comments (not corresponding to rustdoc code), indicating a possible\n+//      problem with the byte_pos-to-source-map implementation.\n+//\n+//   2. And (perhaps not related) when I build the aforementioned example binary with:\n+//      `RUST_FLAGS=\"-Zinstrument-coverage\" cargo build --example formatjson5`\n+//      and then run that binary with\n+//      `LLVM_PROFILE_FILE=\"formatjson5.profraw\" ./target/debug/examples/formatjson5 \\\n+//      some.json5` for some reason the binary generates *TWO* `.profraw` files. One\n+//      named `default.profraw` and the other named `formatjson5.profraw` (the expected\n+//      name, in this case).\n+//\n+//   3. I think that if I eliminate regions within a function, their region_ids,\n+//      referenced in expressions, will be wrong? I think the ids are implied by their\n+//      array position in the final coverage map output (IIRC).\n+//\n+//   4. I suspect a problem (if not the only problem) is the SourceMap is wrong for some\n+//      region start/end byte positions. Just like I couldn't get the function hash at\n+//      intrinsic codegen time for external crate functions, I think the SourceMap I\n+//      have here only applies to the local crate, and I know I have coverages that\n+//      reference external crates.\n+//\n+//          I still don't know if I fixed the hash problem correctly. If external crates\n+//          implement the function, can't I use the coverage counters already compiled\n+//          into those external crates? (Maybe not for generics and/or maybe not for\n+//          macros... not sure. But I need to understand this better.)\n+//\n+// If the byte range conversion is wrong, fix it. But if it\n+// is right, then it is possible for the start and end to be in different files.\n+// Can I do something other than ignore coverages that span multiple files?\n+//\n+// If I can resolve this, remove the \"Option<>\" result type wrapper\n+// `regions_in_file_order()` accordingly.\n+\n /// Collects all of the coverage regions associated with (a) injected counters, (b) counter\n /// expressions (additions or subtraction), and (c) unreachable regions (always counted as zero),\n-/// for a given Function. Counters and counter expressions are indexed because they can be operands\n-/// in an expression. This struct also stores the `function_source_hash`, computed during\n-/// instrumentation and forwarded with counters.\n+/// for a given Function. Counters and counter expressions have non-overlapping `id`s because they\n+/// can both be operands in an expression. This struct also stores the `function_source_hash`,\n+/// computed during instrumentation, and forwarded with counters.\n ///\n-/// Note, it's important to distinguish the `unreachable` region type from what LLVM's refers to as\n-/// a \"gap region\" (or \"gap area\"). A gap region is a code region within a counted region (either\n-/// counter or expression), but the line or lines in the gap region are not executable (such as\n-/// lines with only whitespace or comments). According to LLVM Code Coverage Mapping documentation,\n-/// \"A count for a gap area is only used as the line execution count if there are no other regions\n-/// on a line.\"\n-pub struct FunctionCoverage {\n+/// Note, it may be important to understand LLVM's definitions of `unreachable` regions versus \"gap\n+/// regions\" (or \"gap areas\"). A gap region is a code region within a counted region (either counter\n+/// or expression), but the line or lines in the gap region are not executable (such as lines with\n+/// only whitespace or comments). According to LLVM Code Coverage Mapping documentation, \"A count\n+/// for a gap area is only used as the line execution count if there are no other regions on a\n+/// line.\"\n+pub struct FunctionCoverage<'a> {\n+    source_map: &'a SourceMap,\n     source_hash: u64,\n-    counters: Vec<CoverageRegion>,\n-    expressions: Vec<CoverageRegion>,\n-    unreachable: Vec<CoverageRegion>,\n-    translated: bool,\n+    counters: IndexVec<CounterValueReference, Option<Region>>,\n+    expressions: IndexVec<InjectedExpressionIndex, Option<ExpressionRegion>>,\n+    unreachable_regions: Vec<Region>,\n }\n \n-impl FunctionCoverage {\n-    pub fn with_coverageinfo<'tcx>(coverageinfo: &'tcx mir::CoverageInfo) -> Self {\n+impl<'a> FunctionCoverage<'a> {\n+    pub fn new<'tcx: 'a>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) -> Self {\n+        let coverageinfo = tcx.coverageinfo(instance.def_id());\n         Self {\n+            source_map: tcx.sess.source_map(),\n             source_hash: 0, // will be set with the first `add_counter()`\n-            counters: vec![CoverageRegion::default(); coverageinfo.num_counters as usize],\n-            expressions: vec![CoverageRegion::default(); coverageinfo.num_expressions as usize],\n-            unreachable: Vec::new(),\n-            translated: false,\n+            counters: IndexVec::from_elem_n(None, coverageinfo.num_counters as usize),\n+            expressions: IndexVec::from_elem_n(None, coverageinfo.num_expressions as usize),\n+            unreachable_regions: Vec::new(),\n         }\n     }\n \n-    /// Adds a code region to be counted by an injected counter intrinsic. Return a counter ID\n-    /// for the call.\n+    /// Adds a code region to be counted by an injected counter intrinsic.\n+    /// The source_hash (computed during coverage instrumentation) should also be provided, and\n+    /// should be the same for all counters in a given function.\n     pub fn add_counter(\n         &mut self,\n         source_hash: u64,\n-        index: u32,\n+        id: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n-        self.source_hash = source_hash;\n-        self.counters[index as usize] =\n-            CoverageRegion { kind: CoverageKind::Counter, start_byte_pos, end_byte_pos };\n+        if self.source_hash == 0 {\n+            self.source_hash = source_hash;\n+        } else {\n+            debug_assert_eq!(source_hash, self.source_hash);\n+        }\n+        self.counters[CounterValueReference::from(id)]\n+            .replace(Region::new(self.source_map, start_byte_pos, end_byte_pos))\n+            .expect_none(\"add_counter called with duplicate `id`\");\n     }\n \n+    /// Both counters and \"counter expressions\" (or simply, \"expressions\") can be operands in other\n+    /// expressions. Expression IDs start from `u32::MAX` and go down, so the range of expression\n+    /// IDs will not overlap with the range of counter IDs. Counters and expressions can be added in\n+    /// any order, and expressions can still be assigned contiguous (though descending) IDs, without\n+    /// knowing what the last counter ID will be.\n+    ///\n+    /// When storing the expression data in the `expressions` vector in the `FunctionCoverage`\n+    /// struct, its vector index is computed, from the given expression ID, by subtracting from\n+    /// `u32::MAX`.\n+    ///\n+    /// Since the expression operands (`lhs` and `rhs`) can reference either counters or\n+    /// expressions, an operand that references an expression also uses its original ID, descending\n+    /// from `u32::MAX`. Theses operands are translated only during code generation, after all\n+    /// counters and expressions have been added.\n     pub fn add_counter_expression(\n         &mut self,\n-        translated_index: u32,\n+        id_descending_from_max: u32,\n         lhs: u32,\n-        op: CounterOp,\n+        op: ExprKind,\n         rhs: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,\n     ) {\n-        let index = u32::MAX - translated_index;\n-        // Counter expressions start with \"translated indexes\", descending from `u32::MAX`, so\n-        // the range of expression indexes is disjoint from the range of counter indexes. This way,\n-        // both counters and expressions can be operands in other expressions.\n-        //\n-        // Once all counters have been added, the final \"region index\" for an expression is\n-        // `counters.len() + expression_index` (where `expression_index` is its index in\n-        // `self.expressions`), and the expression operands (`lhs` and `rhs`) can be converted to\n-        // final \"region index\" references by the same conversion, after subtracting from\n-        // `u32::MAX`.\n-        self.expressions[index as usize] = CoverageRegion {\n-            kind: CoverageKind::CounterExpression(lhs, op, rhs),\n-            start_byte_pos,\n-            end_byte_pos,\n-        };\n+        let expression_id = ExpressionOperandId::from(id_descending_from_max);\n+        let lhs = ExpressionOperandId::from(lhs);\n+        let rhs = ExpressionOperandId::from(rhs);\n+\n+        let expression_index = self.expression_index(expression_id);\n+        self.expressions[expression_index]\n+            .replace(ExpressionRegion {\n+                lhs,\n+                op,\n+                rhs,\n+                region: Region::new(self.source_map, start_byte_pos, end_byte_pos),\n+            })\n+            .expect_none(\"add_counter_expression called with duplicate `id_descending_from_max`\");\n     }\n \n-    pub fn add_unreachable(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n-        self.unreachable.push(CoverageRegion {\n-            kind: CoverageKind::Unreachable,\n-            start_byte_pos,\n-            end_byte_pos,\n-        });\n+    /// Add a region that will be marked as \"unreachable\", with a constant \"zero counter\".\n+    pub fn add_unreachable_region(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n+        self.unreachable_regions.push(Region::new(self.source_map, start_byte_pos, end_byte_pos));\n     }\n \n+    /// Return the source hash, generated from the HIR node structure, and used to indicate whether\n+    /// or not the source code structure changed between different compilations.\n     pub fn source_hash(&self) -> u64 {\n         self.source_hash\n     }\n \n-    fn regions(&'a mut self) -> impl Iterator<Item = &'a CoverageRegion> {\n+    /// Generate an array of CounterExpressions, and an iterator over all `Counter`s and their\n+    /// associated `Regions` (from which the LLVM-specific `CoverageMapGenerator` will create\n+    /// `CounterMappingRegion`s.\n+    pub fn get_expressions_and_counter_regions(\n+        &'a self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a Region)>) {\n         assert!(self.source_hash != 0);\n-        self.ensure_expressions_translated();\n-        self.counters.iter().chain(self.expressions.iter().chain(self.unreachable.iter()))\n+\n+        let counter_regions = self.counter_regions();\n+        let (counter_expressions, expression_regions) = self.expressions_with_regions();\n+        let unreachable_regions = self.unreachable_regions();\n+\n+        let counter_regions =\n+            counter_regions.chain(expression_regions.into_iter().chain(unreachable_regions));\n+        (counter_expressions, counter_regions)\n     }\n \n-    pub fn regions_in_file_order(\n-        &'a mut self,\n-        source_map: &SourceMap,\n-    ) -> BTreeMap<PathBuf, BTreeMap<CoverageLoc, (usize, CoverageKind)>> {\n-        let mut regions_in_file_order = BTreeMap::new();\n-        for (region_id, region) in self.regions().enumerate() {\n-            if let Some((source_file, region_loc)) = region.source_loc(source_map) {\n-                // FIXME(richkadel): `region.source_loc()` sometimes fails with two different\n-                // filenames for the start and end byte position. This seems wrong, but for\n-                // now, if encountered, the region is skipped. If resolved, convert the result\n-                // to a non-option value so regions are never skipped.\n-                let real_file_path = match &(*source_file).name {\n-                    FileName::Real(RealFileName::Named(path)) => path.clone(),\n-                    _ => bug!(\"coverage mapping expected only real, named files\"),\n-                };\n-                let file_coverage_regions =\n-                    regions_in_file_order.entry(real_file_path).or_insert_with(|| BTreeMap::new());\n-                file_coverage_regions.insert(region_loc, (region_id, region.kind));\n-            }\n-        }\n-        regions_in_file_order\n+    fn counter_regions(&'a self) -> impl Iterator<Item = (Counter, &'a Region)> {\n+        self.counters.iter_enumerated().filter_map(|(index, entry)| {\n+            // Option::map() will return None to filter out missing counters. This may happen\n+            // if, for example, a MIR-instrumented counter is removed during an optimization.\n+            entry.as_ref().map(|region| {\n+                (Counter::counter_value_reference(index as CounterValueReference), region)\n+            })\n+        })\n     }\n \n-    /// A one-time translation of expression operands is needed, for any operands referencing\n-    /// other CounterExpressions. CounterExpression operands get an initial operand ID that is\n-    /// computed by the simple translation: `u32::max - expression_index` because, when created,\n-    /// the total number of Counters is not yet known. This function recomputes region indexes\n-    /// for expressions so they start with the next region index after the last counter index.\n-    fn ensure_expressions_translated(&mut self) {\n-        if !self.translated {\n-            self.translated = true;\n-            let start = self.counters.len() as u32;\n-            assert!(\n-                (start as u64 + self.expressions.len() as u64) < u32::MAX as u64,\n-                \"the number of counters and counter expressions in a single function exceeds {}\",\n-                u32::MAX\n-            );\n-            for region in self.expressions.iter_mut() {\n-                match region.kind {\n-                    CoverageKind::CounterExpression(lhs, op, rhs) => {\n-                        let lhs = to_region_index(start, lhs);\n-                        let rhs = to_region_index(start, rhs);\n-                        region.kind = CoverageKind::CounterExpression(lhs, op, rhs);\n-                    }\n-                    _ => bug!(\"expressions must only contain CounterExpression kinds\"),\n+    fn expressions_with_regions(\n+        &'a self,\n+    ) -> (Vec<CounterExpression>, impl Iterator<Item = (Counter, &'a Region)>) {\n+        let mut counter_expressions = Vec::with_capacity(self.expressions.len());\n+        let mut expression_regions = Vec::with_capacity(self.expressions.len());\n+        let mut new_indexes =\n+            IndexVec::from_elem_n(MappedExpressionIndex::from(u32::MAX), self.expressions.len());\n+        // Note, the initial value shouldn't matter since every index in use in `self.expressions`\n+        // will be set, and after that, `new_indexes` will only be accessed using those same\n+        // indexes.\n+\n+        // Note that an `ExpressionRegion`s at any given index can include other expressions as\n+        // operands, but expression operands can only come from the subset of expressions having\n+        // `expression_index`s lower than the referencing `ExpressionRegion`. Therefore, it is\n+        // reasonable to look up the new index of an expression operand while the `new_indexes`\n+        // vector is only complete up to the current `ExpressionIndex`.\n+        let id_to_counter =\n+            |new_indexes: &IndexVec<InjectedExpressionIndex, MappedExpressionIndex>,\n+             id: ExpressionOperandId| {\n+                if id.index() < self.counters.len() {\n+                    let index = CounterValueReference::from(id.index());\n+                    self.counters\n+                        .get(index)\n+                        .unwrap() // pre-validated\n+                        .as_ref()\n+                        .map(|_| Counter::counter_value_reference(index))\n+                } else {\n+                    let index = self.expression_index(id);\n+                    self.expressions\n+                        .get(index)\n+                        .expect(\"expression id is out of range\")\n+                        .as_ref()\n+                        .map(|_| Counter::expression(new_indexes[index]))\n                 }\n+            };\n+\n+        for (original_index, expression_region) in\n+            self.expressions.iter_enumerated().filter_map(|(original_index, entry)| {\n+                // Option::map() will return None to filter out missing expressions. This may happen\n+                // if, for example, a MIR-instrumented expression is removed during an optimization.\n+                entry.as_ref().map(|region| (original_index, region))\n+            })\n+        {\n+            let region = &expression_region.region;\n+            let ExpressionRegion { lhs, op, rhs, .. } = *expression_region;\n+\n+            if let Some(Some((lhs_counter, rhs_counter))) =\n+                id_to_counter(&new_indexes, lhs).map(|lhs_counter| {\n+                    id_to_counter(&new_indexes, rhs).map(|rhs_counter| (lhs_counter, rhs_counter))\n+                })\n+            {\n+                // Both operands exist. `Expression` operands exist in `self.expressions` and have\n+                // been assigned a `new_index`.\n+                let mapped_expression_index =\n+                    MappedExpressionIndex::from(counter_expressions.len());\n+                counter_expressions.push(CounterExpression::new(lhs_counter, op, rhs_counter));\n+                new_indexes[original_index] = mapped_expression_index;\n+                expression_regions.push((Counter::expression(mapped_expression_index), region));\n             }\n         }\n+        (counter_expressions, expression_regions.into_iter())\n+    }\n+\n+    fn unreachable_regions(&'a self) -> impl Iterator<Item = (Counter, &'a Region)> {\n+        self.unreachable_regions.iter().map(|region| (Counter::zero(), region))\n     }\n-}\n \n-fn to_region_index(start: u32, index: u32) -> u32 {\n-    if index < start { index } else { start + (u32::MAX - index) }\n+    fn expression_index(\n+        &self,\n+        id_descending_from_max: ExpressionOperandId,\n+    ) -> InjectedExpressionIndex {\n+        debug_assert!(id_descending_from_max.index() >= self.counters.len());\n+        InjectedExpressionIndex::from(u32::MAX - u32::from(id_descending_from_max))\n+    }\n }"}, {"sha": "1f0ffd289b13a7ca9a158ecb9d42634c8f1cce49", "filename": "src/librustc_codegen_ssa/coverageinfo/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,3 +1,4 @@\n+pub mod ffi;\n pub mod map;\n \n-pub use map::CounterOp;\n+pub use map::ExprKind;"}, {"sha": "85260d30a3d7c36292b30580c427e8d392df94ba", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,12 +1,15 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![feature(bool_to_option)]\n+#![feature(option_expect_none)]\n #![feature(box_patterns)]\n #![feature(try_blocks)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(or_patterns)]\n #![feature(trusted_len)]\n #![feature(associated_type_bounds)]\n+#![feature(const_fn)] // for rustc_index::newtype_index\n+#![feature(const_panic)] // for rustc_index::newtype_index\n #![recursion_limit = \"256\"]\n \n //! This crate contains codegen code that is used by all codegen backends (LLVM and others)."}, {"sha": "db1d86c974ea885477c19222b5f2ea2e5c8fd8f5", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,5 +1,5 @@\n use super::BackendTypes;\n-use crate::coverageinfo::CounterOp;\n+use crate::coverageinfo::ExprKind;\n use rustc_middle::ty::Instance;\n \n pub trait CoverageInfoMethods: BackendTypes {\n@@ -21,7 +21,7 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         instance: Instance<'tcx>,\n         index: u32,\n         lhs: u32,\n-        op: CounterOp,\n+        op: ExprKind,\n         rhs: u32,\n         start_byte_pos: u32,\n         end_byte_pos: u32,"}, {"sha": "811d1e49626c4879d3249d5f9ec109eb17f413bb", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n ena = \"0.14\"\n indexmap = \"1\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n jobserver_crate = { version = \"0.1.13\", package = \"jobserver\" }\n lazy_static = \"1\"\n once_cell = { version = \"1\", features = [\"parking_lot\"] }"}, {"sha": "6474a69b216a91e98e784614b766752b485211ad", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,8 +12,8 @@ crate-type = [\"dylib\"]\n [dependencies]\n lazy_static = \"1.0\"\n libc = \"0.2\"\n-log = \"0.4\"\n-env_logger = { version = \"0.7\", default-features = false }\n+log = { package = \"tracing\", version = \"0.1.18\", features = [\"release_max_level_info\"]  }\n+tracing-subscriber = { version = \"0.2.10\", default-features = false, features = [\"fmt\", \"env-filter\", \"smallvec\", \"parking_lot\", \"ansi\"] }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "7af640c109ed57dbfa134e42159a3fa0f1266d1f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1224,9 +1224,26 @@ pub fn install_ice_hook() {\n }\n \n /// This allows tools to enable rust logging without having to magically match rustc's\n-/// log crate version\n+/// log crate version.\n pub fn init_rustc_env_logger() {\n-    env_logger::init_from_env(\"RUSTC_LOG\");\n+    init_env_logger(\"RUSTC_LOG\")\n+}\n+\n+/// This allows tools to enable rust logging without having to magically match rustc's\n+/// log crate version. In contrast to `init_rustc_env_logger` it allows you to choose an env var\n+/// other than `RUSTC_LOG`.\n+pub fn init_env_logger(env: &str) {\n+    // Don't register a dispatcher if there's no filter to print anything\n+    match std::env::var(env) {\n+        Err(_) => return,\n+        Ok(s) if s.is_empty() => return,\n+        Ok(_) => {}\n+    }\n+    let builder = tracing_subscriber::FmtSubscriber::builder();\n+\n+    let builder = builder.with_env_filter(tracing_subscriber::EnvFilter::from_env(env));\n+\n+    builder.init()\n }\n \n pub fn main() -> ! {"}, {"sha": "40dfa484d3f9443760894bb2680994fddcfa0645", "filename": "src/librustc_error_codes/error_codes/E0720.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0720.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0720.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0720.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,11 +1,13 @@\n An `impl Trait` type expands to a recursive type.\n \n-An `impl Trait` type must be expandable to a concrete type that contains no\n-`impl Trait` types. For example the following example tries to create an\n-`impl Trait` type `T` that is equal to `[T, T]`:\n+Erroneous code example:\n \n ```compile_fail,E0720\n fn make_recursive_type() -> impl Sized {\n     [make_recursive_type(), make_recursive_type()]\n }\n ```\n+\n+An `impl Trait` type must be expandable to a concrete type that contains no\n+`impl Trait` types. For example the previous example tries to create an\n+`impl Trait` type `T` that is equal to `[T, T]`."}, {"sha": "f4968a4f00e38f4da4ea6376faeff7c039d5f63f", "filename": "src/librustc_error_codes/error_codes/E0728.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0728.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0728.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0728.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,6 +1,6 @@\n-[`await`] has been used outside [`async`] function or block.\n+[`await`] has been used outside [`async`] function or [`async`] block.\n \n-Erroneous code examples:\n+Erroneous code example:\n \n ```edition2018,compile_fail,E0728\n # use std::pin::Pin;\n@@ -33,7 +33,7 @@ fn foo() {\n \n [`await`] is used to suspend the current computation until the given\n future is ready to produce a value. So it is legal only within\n-an [`async`] context, like an `async fn` or an `async` block.\n+an [`async`] context, like an `async` function or an `async` block.\n \n ```edition2018\n # use std::pin::Pin;"}, {"sha": "016b3f38aa310598bba2365a47289709238af03a", "filename": "src/librustc_error_codes/error_codes/E0730.md", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0730.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,6 +1,6 @@\n An array without a fixed length was pattern-matched.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0730\n #![feature(const_generics)]\n@@ -14,14 +14,28 @@ fn is_123<const N: usize>(x: [u32; N]) -> bool {\n }\n ```\n \n-Ensure that the pattern is consistent with the size of the matched\n-array. Additional elements can be matched with `..`:\n+To fix this error, you have two solutions:\n+ 1. Use an array with a fixed length.\n+ 2. Use a slice.\n \n+Example with an array with a fixed length:\n+\n+```\n+fn is_123(x: [u32; 3]) -> bool { // We use an array with a fixed size\n+    match x {\n+        [1, 2, ..] => true, // ok!\n+        _ => false\n+    }\n+}\n ```\n-let r = &[1, 2, 3, 4];\n-match r {\n-    &[a, b, ..] => { // ok!\n-        println!(\"a={}, b={}\", a, b);\n+\n+Example with a slice:\n+\n+```\n+fn is_123(x: &[u32]) -> bool { // We use a slice\n+    match x {\n+        [1, 2, ..] => true, // ok!\n+        _ => false\n     }\n }\n ```"}, {"sha": "051b75148e5095df27ca39b1dd4f96b345e9b120", "filename": "src/librustc_error_codes/error_codes/E0733.md", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0733.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0733.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0733.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,4 +1,6 @@\n-Recursion in an `async fn` requires boxing. For example, this will not compile:\n+An [`async`] function used recursion without boxing.\n+\n+Erroneous code example:\n \n ```edition2018,compile_fail,E0733\n async fn foo(n: usize) {\n@@ -8,8 +10,8 @@ async fn foo(n: usize) {\n }\n ```\n \n-To achieve async recursion, the `async fn` needs to be desugared\n-such that the `Future` is explicit in the return type:\n+To perform async recursion, the `async fn` needs to be desugared such that the\n+`Future` is explicit in the return type:\n \n ```edition2018,compile_fail,E0720\n use std::future::Future;\n@@ -36,5 +38,7 @@ fn foo_recursive(n: usize) -> Pin<Box<dyn Future<Output = ()>>> {\n }\n ```\n \n-The `Box<...>` ensures that the result is of known size,\n-and the pin is required to keep it in the same place in memory.\n+The `Box<...>` ensures that the result is of known size, and the pin is\n+required to keep it in the same place in memory.\n+\n+[`async`]: https://doc.rust-lang.org/std/keyword.async.html"}, {"sha": "4b8e89a70604d0974f5630271e3632c709b3a066", "filename": "src/librustc_error_codes/error_codes/E0734.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0734.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0734.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0734.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,6 +1,6 @@\n A stability attribute has been used outside of the standard library.\n \n-Erroneous code examples:\n+Erroneous code example:\n \n ```compile_fail,E0734\n #[rustc_deprecated(since = \"b\", reason = \"text\")] // invalid"}, {"sha": "6240099a99f671b1e6934615e4a353908d2669f0", "filename": "src/librustc_error_codes/error_codes/E0740.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0740.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,4 +1,4 @@\n-A `union` cannot have fields with destructors.\n+A `union` was declared with fields with destructors.\n \n Erroneous code example:\n \n@@ -14,3 +14,5 @@ impl Drop for A {\n     fn drop(&mut self) { println!(\"A\"); }\n }\n ```\n+\n+A `union` cannot have fields with destructors."}, {"sha": "91379bfe05c65fe5122667d9b81b85a33d06473e", "filename": "src/librustc_error_codes/error_codes/E0741.md", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0741.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0741.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0741.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,5 +1,6 @@\n-Only structural-match types (that is, types that derive `PartialEq` and `Eq`)\n-may be used as the types of const generic parameters.\n+A non-structural-match type was used as the type of a const generic parameter.\n+\n+Erroneous code example:\n \n ```compile_fail,E0741\n #![feature(const_generics)]\n@@ -9,12 +10,15 @@ struct A;\n struct B<const X: A>; // error!\n ```\n \n-To fix this example, we derive `PartialEq` and `Eq`.\n+Only structural-match types (that is, types that derive `PartialEq` and `Eq`)\n+may be used as the types of const generic parameters.\n+\n+To fix the previous code example, we derive `PartialEq` and `Eq`:\n \n ```\n #![feature(const_generics)]\n \n-#[derive(PartialEq, Eq)]\n+#[derive(PartialEq, Eq)] // We derive both traits here.\n struct A;\n \n struct B<const X: A>; // ok!"}, {"sha": "ddd3136df0c39c67da43b73c5e02ad8782931123", "filename": "src/librustc_error_codes/error_codes/E0743.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0743.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0743.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0743.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -8,10 +8,9 @@ Erroneous code example:\n fn foo2(x: u8, y: &...) {} // error!\n ```\n \n-Only foreign functions can use the C-variadic type (`...`).\n-In such functions, `...` may only occur non-nested.\n-That is, `y: &'a ...` is not allowed.\n+Only foreign functions can use the C-variadic type (`...`). In such functions,\n+`...` may only occur non-nested. That is, `y: &'a ...` is not allowed.\n \n-A C-variadic type is used to give an undefined number\n-of parameters to a given function (like `printf` in C).\n-The equivalent in Rust would be to use macros directly.\n+A C-variadic type is used to give an undefined number of parameters to a given\n+function (like `printf` in C). The equivalent in Rust would be to use macros\n+directly (like `println!` for example)."}, {"sha": "14cff3613e02394acfe42a93b269013e6cf82f4b", "filename": "src/librustc_error_codes/error_codes/E0744.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0744.md?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,7 +1,6 @@\n-Control-flow expressions are not allowed inside a const context.\n+A control-flow expression was used inside a const context.\n \n-At the moment, `if` and `match`, as well as the looping constructs `for`,\n-`while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n+Erroneous code example:\n \n ```compile_fail,E0744\n const _: i32 = {\n@@ -13,6 +12,9 @@ const _: i32 = {\n };\n ```\n \n+At the moment, `if` and `match`, as well as the looping constructs `for`,\n+`while`, and `loop`, are forbidden inside a `const`, `static`, or `const fn`.\n+\n This will be allowed at some point in the future, but the implementation is not\n yet complete. See the tracking issue for [conditionals] or [loops] in a const\n context for the current status."}, {"sha": "d0f04c3fe7647187ade03a61f40bee27e06ec084", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "bdf039c36abf6c60e610a1f56db80cfeaac0b9f6", "filename": "src/librustc_expand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,7 +12,7 @@ doctest = false\n \n [dependencies]\n rustc_serialize = { path = \"../librustc_serialize\" }\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_ast_passes = { path = \"../librustc_ast_passes\" }"}, {"sha": "6f2daaa81c02f5a6b1bd9669539afbce2d7edb83", "filename": "src/librustc_expand/mbe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,7 +9,7 @@ crate mod macro_rules;\n crate mod quoted;\n crate mod transcribe;\n \n-use rustc_ast::token::{self, Token, TokenKind};\n+use rustc_ast::token::{self, NonterminalKind, Token, TokenKind};\n use rustc_ast::tokenstream::DelimSpan;\n \n use rustc_span::symbol::Ident;\n@@ -84,7 +84,7 @@ enum TokenTree {\n     /// e.g., `$var`\n     MetaVar(Span, Ident),\n     /// e.g., `$var:expr`. This is only used in the left hand side of MBE macros.\n-    MetaVarDecl(Span, Ident /* name to bind */, Ident /* kind of nonterminal */),\n+    MetaVarDecl(Span, Ident /* name to bind */, Option<NonterminalKind>),\n }\n \n impl TokenTree {"}, {"sha": "d2fe7fe10a8301b1cd24cdbe4d23a78b2690f04b", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 17, "deletions": 189, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -76,15 +76,11 @@ use TokenTreeOrTokenTreeSlice::*;\n \n use crate::mbe::{self, TokenTree};\n \n-use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DocComment, Nonterminal, Token};\n-use rustc_ast_pretty::pprust;\n-use rustc_parse::parser::{FollowedByType, Parser, PathStyle};\n+use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n-use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::symbol::MacroRulesNormalizedIdent;\n \n-use rustc_errors::PResult;\n-use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -382,7 +378,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n                     n_rec(sess, next_m, res.by_ref(), ret_val)?;\n                 }\n             }\n-            TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n+            TokenTree::MetaVarDecl(span, _, None) => {\n                 if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                     return Err((span, \"missing fragment specifier\".to_string()));\n                 }\n@@ -565,18 +561,18 @@ fn inner_parse_loop<'root, 'tt>(\n                 }\n \n                 // We need to match a metavar (but the identifier is invalid)... this is an error\n-                TokenTree::MetaVarDecl(span, _, id) if id.name == kw::Invalid => {\n+                TokenTree::MetaVarDecl(span, _, None) => {\n                     if sess.missing_fragment_specifiers.borrow_mut().remove(&span).is_some() {\n                         return Error(span, \"missing fragment specifier\".to_string());\n                     }\n                 }\n \n                 // We need to match a metavar with a valid ident... call out to the black-box\n                 // parser by adding an item to `bb_items`.\n-                TokenTree::MetaVarDecl(_, _, id) => {\n+                TokenTree::MetaVarDecl(_, _, Some(kind)) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n-                    if may_begin_with(token, id.name) {\n+                    if Parser::nonterminal_may_begin_with(kind, token) {\n                         bb_items.push(item);\n                     }\n                 }\n@@ -706,7 +702,7 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             let nts = bb_items\n                 .iter()\n                 .map(|item| match item.top_elts.get_tt(item.idx) {\n-                    TokenTree::MetaVarDecl(_, bind, name) => format!(\"{} ('{}')\", name, bind),\n+                    TokenTree::MetaVarDecl(_, bind, Some(kind)) => format!(\"{} ('{}')\", kind, bind),\n                     _ => panic!(),\n                 })\n                 .collect::<Vec<String>>()\n@@ -736,10 +732,17 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n             assert_eq!(bb_items.len(), 1);\n \n             let mut item = bb_items.pop().unwrap();\n-            if let TokenTree::MetaVarDecl(span, _, ident) = item.top_elts.get_tt(item.idx) {\n+            if let TokenTree::MetaVarDecl(span, _, Some(kind)) = item.top_elts.get_tt(item.idx) {\n                 let match_cur = item.match_cur;\n-                let nt = match parse_nt(parser.to_mut(), span, ident.name) {\n-                    Err(()) => return ErrorReported,\n+                let nt = match parser.to_mut().parse_nonterminal(kind) {\n+                    Err(mut err) => {\n+                        err.span_label(\n+                            span,\n+                            format!(\"while parsing argument for this `{}` macro fragment\", kind),\n+                        )\n+                        .emit();\n+                        return ErrorReported;\n+                    }\n                     Ok(nt) => nt,\n                 };\n                 item.push_match(match_cur, MatchedNonterminal(Lrc::new(nt)));\n@@ -754,178 +757,3 @@ pub(super) fn parse_tt(parser: &mut Cow<'_, Parser<'_>>, ms: &[TokenTree]) -> Na\n         assert!(!cur_items.is_empty());\n     }\n }\n-\n-/// The token is an identifier, but not `_`.\n-/// We prohibit passing `_` to macros expecting `ident` for now.\n-fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n-    token.ident().filter(|(ident, _)| ident.name != kw::Underscore)\n-}\n-\n-/// Checks whether a non-terminal may begin with a particular token.\n-///\n-/// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n-/// token. Be conservative (return true) if not sure.\n-fn may_begin_with(token: &Token, name: Symbol) -> bool {\n-    /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n-    fn may_be_ident(nt: &token::Nonterminal) -> bool {\n-        match *nt {\n-            token::NtItem(_) | token::NtBlock(_) | token::NtVis(_) | token::NtLifetime(_) => false,\n-            _ => true,\n-        }\n-    }\n-\n-    match name {\n-        sym::expr => {\n-            token.can_begin_expr()\n-            // This exception is here for backwards compatibility.\n-            && !token.is_keyword(kw::Let)\n-        }\n-        sym::ty => token.can_begin_type(),\n-        sym::ident => get_macro_ident(token).is_some(),\n-        sym::literal => token.can_begin_literal_maybe_minus(),\n-        sym::vis => match token.kind {\n-            // The follow-set of :vis + \"priv\" keyword + interpolated\n-            token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n-            _ => token.can_begin_type(),\n-        },\n-        sym::block => match token.kind {\n-            token::OpenDelim(token::Brace) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtItem(_)\n-                | token::NtPat(_)\n-                | token::NtTy(_)\n-                | token::NtIdent(..)\n-                | token::NtMeta(_)\n-                | token::NtPath(_)\n-                | token::NtVis(_) => false, // none of these may start with '{'.\n-                _ => true,\n-            },\n-            _ => false,\n-        },\n-        sym::path | sym::meta => match token.kind {\n-            token::ModSep | token::Ident(..) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtPath(_) | token::NtMeta(_) => true,\n-                _ => may_be_ident(&nt),\n-            },\n-            _ => false,\n-        },\n-        sym::pat => match token.kind {\n-            token::Ident(..) |               // box, ref, mut, and other identifiers (can stricten)\n-            token::OpenDelim(token::Paren) |    // tuple pattern\n-            token::OpenDelim(token::Bracket) |  // slice pattern\n-            token::BinOp(token::And) |          // reference\n-            token::BinOp(token::Minus) |        // negative literal\n-            token::AndAnd |                     // double reference\n-            token::Literal(..) |                // literal\n-            token::DotDot |                     // range pattern (future compat)\n-            token::DotDotDot |                  // range pattern (future compat)\n-            token::ModSep |                     // path\n-            token::Lt |                         // path (UFCS constant)\n-            token::BinOp(token::Shl) => true,   // path (double UFCS)\n-            token::Interpolated(ref nt) => may_be_ident(nt),\n-            _ => false,\n-        },\n-        sym::lifetime => match token.kind {\n-            token::Lifetime(_) => true,\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtLifetime(_) | token::NtTT(_) => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        },\n-        _ => match token.kind {\n-            token::CloseDelim(_) => false,\n-            _ => true,\n-        },\n-    }\n-}\n-\n-/// A call to the \"black-box\" parser to parse some Rust non-terminal.\n-///\n-/// # Parameters\n-///\n-/// - `p`: the \"black-box\" parser to use\n-/// - `sp`: the `Span` we want to parse\n-/// - `name`: the name of the metavar _matcher_ we want to match (e.g., `tt`, `ident`, `block`,\n-///   etc...)\n-///\n-/// # Returns\n-///\n-/// The parsed non-terminal.\n-fn parse_nt(p: &mut Parser<'_>, sp: Span, name: Symbol) -> Result<Nonterminal, ()> {\n-    // FIXME(Centril): Consider moving this to `parser.rs` to make\n-    // the visibilities of the methods used below `pub(super)` at most.\n-    if name == sym::tt {\n-        return Ok(token::NtTT(p.parse_token_tree()));\n-    }\n-    parse_nt_inner(p, sp, name).map_err(|mut err| {\n-        err.span_label(sp, format!(\"while parsing argument for this `{}` macro fragment\", name))\n-            .emit()\n-    })\n-}\n-\n-fn parse_nt_inner<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> PResult<'a, Nonterminal> {\n-    // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n-    // needs to have them force-captured here.\n-    // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n-    // which requires having captured tokens available. Since we cannot determine\n-    // in advance whether or not a proc-macro will be (transitively) invoked,\n-    // we always capture tokens for any `Nonterminal` which needs them.\n-    Ok(match name {\n-        sym::item => match p.collect_tokens(|this| this.parse_item())? {\n-            (Some(mut item), tokens) => {\n-                // If we captured tokens during parsing (due to outer attributes),\n-                // use those.\n-                if item.tokens.is_none() {\n-                    item.tokens = Some(tokens);\n-                }\n-                token::NtItem(item)\n-            }\n-            (None, _) => return Err(p.struct_span_err(p.token.span, \"expected an item keyword\")),\n-        },\n-        sym::block => token::NtBlock(p.parse_block()?),\n-        sym::stmt => match p.parse_stmt()? {\n-            Some(s) => token::NtStmt(s),\n-            None => return Err(p.struct_span_err(p.token.span, \"expected a statement\")),\n-        },\n-        sym::pat => token::NtPat(p.parse_pat(None)?),\n-        sym::expr => {\n-            let (mut expr, tokens) = p.collect_tokens(|this| this.parse_expr())?;\n-            // If we captured tokens during parsing (due to outer attributes),\n-            // use those.\n-            if expr.tokens.is_none() {\n-                expr.tokens = Some(tokens);\n-            }\n-            token::NtExpr(expr)\n-        }\n-        sym::literal => token::NtLiteral(p.parse_literal_maybe_minus()?),\n-        sym::ty => token::NtTy(p.parse_ty()?),\n-        // this could be handled like a token, since it is one\n-        sym::ident => {\n-            if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n-                p.bump();\n-                token::NtIdent(ident, is_raw)\n-            } else {\n-                let token_str = pprust::token_to_string(&p.token);\n-                let msg = &format!(\"expected ident, found {}\", &token_str);\n-                return Err(p.struct_span_err(p.token.span, msg));\n-            }\n-        }\n-        sym::path => token::NtPath(p.parse_path(PathStyle::Type)?),\n-        sym::meta => token::NtMeta(P(p.parse_attr_item()?)),\n-        sym::vis => token::NtVis(p.parse_visibility(FollowedByType::Yes)?),\n-        sym::lifetime => {\n-            if p.check_lifetime() {\n-                token::NtLifetime(p.expect_lifetime().ident)\n-            } else {\n-                let token_str = pprust::token_to_string(&p.token);\n-                let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n-                return Err(p.struct_span_err(p.token.span, msg));\n-            }\n-        }\n-        // this is not supposed to happen, since it has been checked\n-        // when compiling the macro.\n-        _ => p.span_bug(sp, \"invalid fragment specifier\"),\n-    })\n-}"}, {"sha": "74d4023b41075b52e4872b2518ac4f5be8c6c8ec", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 43, "deletions": 132, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,7 +9,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq};\n use crate::mbe::transcribe::transcribe;\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, NtTT, Token, TokenKind::*};\n+use rustc_ast::token::{self, NonterminalKind, NtTT, Token, TokenKind::*};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, TransparencyError};\n@@ -21,18 +21,14 @@ use rustc_parse::parser::Parser;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, MacroRulesNormalizedIdent};\n use rustc_span::Span;\n \n use log::debug;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry;\n use std::{mem, slice};\n \n-const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n-                                        `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n-                                        `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n-\n crate struct ParserAnyMacro<'a> {\n     parser: Parser<'a>,\n \n@@ -403,7 +399,7 @@ pub fn compile_declarative_macro(\n     let diag = &sess.span_diagnostic;\n     let lhs_nm = Ident::new(sym::lhs, def.span);\n     let rhs_nm = Ident::new(sym::rhs, def.span);\n-    let tt_spec = Ident::new(sym::tt, def.span);\n+    let tt_spec = Some(NonterminalKind::TT);\n \n     // Parse the macro_rules! invocation\n     let (macro_rules, body) = match &def.kind {\n@@ -571,7 +567,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n             TokenTree::Sequence(span, ref seq) => {\n                 if seq.separator.is_none()\n                     && seq.tts.iter().all(|seq_tt| match *seq_tt {\n-                        TokenTree::MetaVarDecl(_, _, id) => id.name == sym::vis,\n+                        TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Vis)) => true,\n                         TokenTree::Sequence(_, ref sub_seq) => {\n                             sub_seq.kleene.op == mbe::KleeneOp::ZeroOrMore\n                                 || sub_seq.kleene.op == mbe::KleeneOp::ZeroOrOne\n@@ -890,21 +886,7 @@ fn check_matcher_core(\n         // of NT tokens that might end the sequence `... token`.\n         match *token {\n             TokenTree::Token(..) | TokenTree::MetaVar(..) | TokenTree::MetaVarDecl(..) => {\n-                let can_be_followed_by_any;\n-                if let Err(bad_frag) = has_legal_fragment_specifier(sess, features, attrs, token) {\n-                    let msg = format!(\"invalid fragment specifier `{}`\", bad_frag);\n-                    sess.span_diagnostic\n-                        .struct_span_err(token.span(), &msg)\n-                        .help(VALID_FRAGMENT_NAMES_MSG)\n-                        .emit();\n-                    // (This eliminates false positives and duplicates\n-                    // from error messages.)\n-                    can_be_followed_by_any = true;\n-                } else {\n-                    can_be_followed_by_any = token_can_be_followed_by_any(token);\n-                }\n-\n-                if can_be_followed_by_any {\n+                if token_can_be_followed_by_any(token) {\n                     // don't need to track tokens that work with any,\n                     last.replace_with_irrelevant();\n                     // ... and don't need to check tokens that can be\n@@ -967,19 +949,10 @@ fn check_matcher_core(\n \n         // Now `last` holds the complete set of NT tokens that could\n         // end the sequence before SUFFIX. Check that every one works with `suffix`.\n-        'each_last: for token in &last.tokens {\n-            if let TokenTree::MetaVarDecl(_, name, frag_spec) = *token {\n+        for token in &last.tokens {\n+            if let TokenTree::MetaVarDecl(_, name, Some(kind)) = *token {\n                 for next_token in &suffix_first.tokens {\n-                    match is_in_follow(next_token, frag_spec.name) {\n-                        IsInFollow::Invalid(msg, help) => {\n-                            sess.span_diagnostic\n-                                .struct_span_err(next_token.span(), &msg)\n-                                .help(help)\n-                                .emit();\n-                            // don't bother reporting every source of\n-                            // conflict for a particular element of `last`.\n-                            continue 'each_last;\n-                        }\n+                    match is_in_follow(next_token, kind) {\n                         IsInFollow::Yes => {}\n                         IsInFollow::No(possible) => {\n                             let may_be = if last.tokens.len() == 1 && suffix_first.tokens.len() == 1\n@@ -996,22 +969,19 @@ fn check_matcher_core(\n                                     \"`${name}:{frag}` {may_be} followed by `{next}`, which \\\n                                      is not allowed for `{frag}` fragments\",\n                                     name = name,\n-                                    frag = frag_spec,\n+                                    frag = kind,\n                                     next = quoted_tt_to_string(next_token),\n                                     may_be = may_be\n                                 ),\n                             );\n-                            err.span_label(\n-                                sp,\n-                                format!(\"not allowed after `{}` fragments\", frag_spec),\n-                            );\n+                            err.span_label(sp, format!(\"not allowed after `{}` fragments\", kind));\n                             let msg = \"allowed there are: \";\n                             match possible {\n                                 &[] => {}\n                                 &[t] => {\n                                     err.note(&format!(\n                                         \"only {} is allowed after `{}` fragments\",\n-                                        t, frag_spec,\n+                                        t, kind,\n                                     ));\n                                 }\n                                 ts => {\n@@ -1038,8 +1008,8 @@ fn check_matcher_core(\n }\n \n fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n-    if let mbe::TokenTree::MetaVarDecl(_, _, frag_spec) = *tok {\n-        frag_can_be_followed_by_any(frag_spec.name)\n+    if let mbe::TokenTree::MetaVarDecl(_, _, Some(kind)) = *tok {\n+        frag_can_be_followed_by_any(kind)\n     } else {\n         // (Non NT's can always be followed by anything in matchers.)\n         true\n@@ -1054,26 +1024,23 @@ fn token_can_be_followed_by_any(tok: &mbe::TokenTree) -> bool {\n /// specifier which consumes at most one token tree can be followed by\n /// a fragment specifier (indeed, these fragments can be followed by\n /// ANYTHING without fear of future compatibility hazards).\n-fn frag_can_be_followed_by_any(frag: Symbol) -> bool {\n-    match frag {\n-        sym::item     | // always terminated by `}` or `;`\n-        sym::block    | // exactly one token tree\n-        sym::ident    | // exactly one token tree\n-        sym::literal  | // exactly one token tree\n-        sym::meta     | // exactly one token tree\n-        sym::lifetime | // exactly one token tree\n-        sym::tt =>   // exactly one token tree\n-            true,\n-\n-        _ =>\n-            false,\n+fn frag_can_be_followed_by_any(kind: NonterminalKind) -> bool {\n+    match kind {\n+        NonterminalKind::Item           // always terminated by `}` or `;`\n+        | NonterminalKind::Block        // exactly one token tree\n+        | NonterminalKind::Ident        // exactly one token tree\n+        | NonterminalKind::Literal      // exactly one token tree\n+        | NonterminalKind::Meta         // exactly one token tree\n+        | NonterminalKind::Lifetime     // exactly one token tree\n+        | NonterminalKind::TT => true,  // exactly one token tree\n+\n+        _ => false,\n     }\n }\n \n enum IsInFollow {\n     Yes,\n     No(&'static [&'static str]),\n-    Invalid(String, &'static str),\n }\n \n /// Returns `true` if `frag` can legally be followed by the token `tok`. For\n@@ -1084,26 +1051,26 @@ enum IsInFollow {\n /// break macros that were relying on that binary operator as a\n /// separator.\n // when changing this do not forget to update doc/book/macros.md!\n-fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n+fn is_in_follow(tok: &mbe::TokenTree, kind: NonterminalKind) -> IsInFollow {\n     use mbe::TokenTree;\n \n     if let TokenTree::Token(Token { kind: token::CloseDelim(_), .. }) = *tok {\n         // closing a token tree can never be matched by any fragment;\n         // iow, we always require that `(` and `)` match, etc.\n         IsInFollow::Yes\n     } else {\n-        match frag {\n-            sym::item => {\n+        match kind {\n+            NonterminalKind::Item => {\n                 // since items *must* be followed by either a `;` or a `}`, we can\n                 // accept anything after them\n                 IsInFollow::Yes\n             }\n-            sym::block => {\n+            NonterminalKind::Block => {\n                 // anything can follow block, the braces provide an easy boundary to\n                 // maintain\n                 IsInFollow::Yes\n             }\n-            sym::stmt | sym::expr => {\n+            NonterminalKind::Stmt | NonterminalKind::Expr => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`;`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1113,7 +1080,7 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::pat => {\n+            NonterminalKind::Pat => {\n                 const TOKENS: &[&str] = &[\"`=>`\", \"`,`\", \"`=`\", \"`|`\", \"`if`\", \"`in`\"];\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n@@ -1124,7 +1091,7 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::path | sym::ty => {\n+            NonterminalKind::Path | NonterminalKind::Ty => {\n                 const TOKENS: &[&str] = &[\n                     \"`{`\", \"`[`\", \"`=>`\", \"`,`\", \"`>`\", \"`=`\", \"`:`\", \"`;`\", \"`|`\", \"`as`\",\n                     \"`where`\",\n@@ -1146,26 +1113,24 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                         }\n                         _ => IsInFollow::No(TOKENS),\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::block => {\n-                        IsInFollow::Yes\n-                    }\n+                    TokenTree::MetaVarDecl(_, _, Some(NonterminalKind::Block)) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            sym::ident | sym::lifetime => {\n+            NonterminalKind::Ident | NonterminalKind::Lifetime => {\n                 // being a single token, idents and lifetimes are harmless\n                 IsInFollow::Yes\n             }\n-            sym::literal => {\n+            NonterminalKind::Literal => {\n                 // literals may be of a single token, or two tokens (negative numbers)\n                 IsInFollow::Yes\n             }\n-            sym::meta | sym::tt => {\n+            NonterminalKind::Meta | NonterminalKind::TT => {\n                 // being either a single token or a delimited sequence, tt is\n                 // harmless\n                 IsInFollow::Yes\n             }\n-            sym::vis => {\n+            NonterminalKind::Vis => {\n                 // Explicitly disallow `priv`, on the off chance it comes back.\n                 const TOKENS: &[&str] = &[\"`,`\", \"an ident\", \"a type\"];\n                 match tok {\n@@ -1180,78 +1145,24 @@ fn is_in_follow(tok: &mbe::TokenTree, frag: Symbol) -> IsInFollow {\n                             }\n                         }\n                     },\n-                    TokenTree::MetaVarDecl(_, _, frag)\n-                        if frag.name == sym::ident\n-                            || frag.name == sym::ty\n-                            || frag.name == sym::path =>\n-                    {\n-                        IsInFollow::Yes\n-                    }\n+                    TokenTree::MetaVarDecl(\n+                        _,\n+                        _,\n+                        Some(NonterminalKind::Ident | NonterminalKind::Ty | NonterminalKind::Path),\n+                    ) => IsInFollow::Yes,\n                     _ => IsInFollow::No(TOKENS),\n                 }\n             }\n-            kw::Invalid => IsInFollow::Yes,\n-            _ => IsInFollow::Invalid(\n-                format!(\"invalid fragment specifier `{}`\", frag),\n-                VALID_FRAGMENT_NAMES_MSG,\n-            ),\n         }\n     }\n }\n \n-fn has_legal_fragment_specifier(\n-    sess: &ParseSess,\n-    features: &Features,\n-    attrs: &[ast::Attribute],\n-    tok: &mbe::TokenTree,\n-) -> Result<(), String> {\n-    debug!(\"has_legal_fragment_specifier({:?})\", tok);\n-    if let mbe::TokenTree::MetaVarDecl(_, _, ref frag_spec) = *tok {\n-        let frag_span = tok.span();\n-        if !is_legal_fragment_specifier(sess, features, attrs, frag_spec.name, frag_span) {\n-            return Err(frag_spec.to_string());\n-        }\n-    }\n-    Ok(())\n-}\n-\n-fn is_legal_fragment_specifier(\n-    _sess: &ParseSess,\n-    _features: &Features,\n-    _attrs: &[ast::Attribute],\n-    frag_name: Symbol,\n-    _frag_span: Span,\n-) -> bool {\n-    /*\n-     * If new fragment specifiers are invented in nightly, `_sess`,\n-     * `_features`, `_attrs`, and `_frag_span` will be useful here\n-     * for checking against feature gates. See past versions of\n-     * this function.\n-     */\n-    match frag_name {\n-        sym::item\n-        | sym::block\n-        | sym::stmt\n-        | sym::expr\n-        | sym::pat\n-        | sym::lifetime\n-        | sym::path\n-        | sym::ty\n-        | sym::ident\n-        | sym::meta\n-        | sym::tt\n-        | sym::vis\n-        | sym::literal\n-        | kw::Invalid => true,\n-        _ => false,\n-    }\n-}\n-\n fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     match *tt {\n         mbe::TokenTree::Token(ref token) => pprust::token_to_string(&token),\n         mbe::TokenTree::MetaVar(_, name) => format!(\"${}\", name),\n-        mbe::TokenTree::MetaVarDecl(_, name, kind) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, Some(kind)) => format!(\"${}:{}\", name, kind),\n+        mbe::TokenTree::MetaVarDecl(_, name, None) => format!(\"${}:\", name),\n         _ => panic!(\n             \"unexpected mbe::TokenTree::{{Sequence or Delimited}} \\\n              in follow set checker\""}, {"sha": "774cc84afdeb11df0f8fb7c7c1b3d73d9dcaa057", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,6 +12,10 @@ use rustc_span::Span;\n \n use rustc_data_structures::sync::Lrc;\n \n+const VALID_FRAGMENT_NAMES_MSG: &str = \"valid fragment specifiers are \\\n+                                        `ident`, `block`, `stmt`, `expr`, `pat`, `ty`, `lifetime`, \\\n+                                        `literal`, `path`, `meta`, `tt`, `item` and `vis`\";\n+\n /// Takes a `tokenstream::TokenStream` and returns a `Vec<self::TokenTree>`. Specifically, this\n /// takes a generic `TokenStream`, such as is used in the rest of the compiler, and returns a\n /// collection of `TokenTree` for use in parsing a macro.\n@@ -55,9 +59,21 @@ pub(super) fn parse(\n                     Some(tokenstream::TokenTree::Token(Token { kind: token::Colon, span })) => {\n                         match trees.next() {\n                             Some(tokenstream::TokenTree::Token(token)) => match token.ident() {\n-                                Some((kind, _)) => {\n+                                Some((frag, _)) => {\n                                     let span = token.span.with_lo(start_sp.lo());\n-                                    result.push(TokenTree::MetaVarDecl(span, ident, kind));\n+                                    let kind = token::NonterminalKind::from_symbol(frag.name)\n+                                        .unwrap_or_else(|| {\n+                                            let msg = format!(\n+                                                \"invalid fragment specifier `{}`\",\n+                                                frag.name\n+                                            );\n+                                            sess.span_diagnostic\n+                                                .struct_span_err(span, &msg)\n+                                                .help(VALID_FRAGMENT_NAMES_MSG)\n+                                                .emit();\n+                                            token::NonterminalKind::Ident\n+                                        });\n+                                    result.push(TokenTree::MetaVarDecl(span, ident, Some(kind)));\n                                     continue;\n                                 }\n                                 _ => token.span,\n@@ -71,7 +87,7 @@ pub(super) fn parse(\n                     // Macros loaded from other crates have dummy node ids.\n                     sess.missing_fragment_specifiers.borrow_mut().insert(span, node_id);\n                 }\n-                result.push(TokenTree::MetaVarDecl(span, ident, Ident::invalid()));\n+                result.push(TokenTree::MetaVarDecl(span, ident, None));\n             }\n \n             // Not a metavar or no matchers allowed, so just return the tree"}, {"sha": "4a404e176e148de43a4c580a186901d794064a9b", "filename": "src/librustc_hir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -18,5 +18,5 @@ rustc_span = { path = \"../librustc_span\" }\n rustc_serialize = { path = \"../librustc_serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n lazy_static = \"1\"\n-log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+log = { package = \"tracing\", version = \"0.1\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "60a87078d63cfdad911cdced0cb076e3e8ed64f7", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_graphviz = { path = \"../librustc_graphviz\" }\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rand = \"0.7\"\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "9d56fa223a9cb83dbe558715efe5b7539c72dbf0", "filename": "src/librustc_infer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_graphviz = { path = \"../librustc_graphviz\" }\n-log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "133c4bf2db5f7a869c8ecd8a6db3654dcc67f9eb", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -166,15 +166,15 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n                 return self.unify_const_variable(!a_is_expected, vid, a);\n             }\n             (ty::ConstKind::Unevaluated(..), _) if self.tcx.lazy_normalization() => {\n-                // FIXME(#59490): Need to remove the leak check to accomodate\n+                // FIXME(#59490): Need to remove the leak check to accommodate\n                 // escaping bound variables here.\n                 if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n                     relation.const_equate_obligation(a, b);\n                 }\n                 return Ok(b);\n             }\n             (_, ty::ConstKind::Unevaluated(..)) if self.tcx.lazy_normalization() => {\n-                // FIXME(#59490): Need to remove the leak check to accomodate\n+                // FIXME(#59490): Need to remove the leak check to accommodate\n                 // escaping bound variables here.\n                 if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n                     relation.const_equate_obligation(a, b);"}, {"sha": "0125e0f48e8852944dc4e5ecdacbf3b42b75c023", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n         if let (Some(ident), true) = (override_error_code, fn_returns.is_empty()) {\n-            // Provide a more targetted error code and description.\n+            // Provide a more targeted error code and description.\n             err.code(rustc_errors::error_code!(E0772));\n             err.set_primary_message(&format!(\n                 \"{} has {} but calling `{}` introduces an implicit `'static` lifetime \\"}, {"sha": "5c7edc10dd5c79a596893fba36eee084ab462e32", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n libc = \"0.2\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "125a020de37b7bcc845a222faa66a72a87ed877e", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -2,7 +2,7 @@ use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n use crate::util;\n \n-use log::{info, log_enabled, warn};\n+use log::{info, warn};\n use once_cell::sync::Lazy;\n use rustc_ast::mut_visit::MutVisitor;\n use rustc_ast::{self, ast, visit};\n@@ -1015,21 +1015,15 @@ pub fn start_codegen<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     outputs: &OutputFilenames,\n ) -> Box<dyn Any> {\n-    if log_enabled!(::log::Level::Info) {\n-        println!(\"Pre-codegen\");\n-        tcx.print_debug_stats();\n-    }\n+    info!(\"Pre-codegen\\n{:?}\", tcx.debug_stats());\n \n     let (metadata, need_metadata_module) = encode_and_write_metadata(tcx, outputs);\n \n     let codegen = tcx.sess.time(\"codegen_crate\", move || {\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n     });\n \n-    if log_enabled!(::log::Level::Info) {\n-        println!(\"Post-codegen\");\n-        tcx.print_debug_stats();\n-    }\n+    info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n         if let Err(e) = mir::transform::dump_mir::emit_mir(tcx, outputs) {"}, {"sha": "3ba1566023d2842a376971a4bdd4fef03abbcbc9", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,7 +9,7 @@ name = \"rustc_lint\"\n path = \"lib.rs\"\n \n [dependencies]\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n unicode-security = \"0.0.5\"\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }"}, {"sha": "e32c8fbee6852275c9d7215faddd5200ca0c81a7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 83, "deletions": 22, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -20,7 +20,9 @@\n //! If you define a new `LateLintPass`, you will also need to add it to the\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n-use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use crate::{\n+    types::CItemKind, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n+};\n use rustc_ast::ast::{self, Expr};\n use rustc_ast::attr::{self, HasAttrs};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -36,14 +38,14 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{ForeignItemKind, GenericParamKind, PatKind};\n use rustc_hir::{HirId, HirIdSet, Node};\n use rustc_middle::lint::LintDiagnosticBuilder;\n-use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Span};\n-use rustc_target::abi::VariantIdx;\n+use rustc_target::abi::{LayoutOf, VariantIdx};\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n@@ -2144,7 +2146,13 @@ impl ClashingExternDeclarations {\n     /// Checks whether two types are structurally the same enough that the declarations shouldn't\n     /// clash. We need this so we don't emit a lint when two modules both declare an extern struct,\n     /// with the same members (as the declarations shouldn't clash).\n-    fn structurally_same_type<'tcx>(cx: &LateContext<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+    fn structurally_same_type<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        ckind: CItemKind,\n+    ) -> bool {\n+        debug!(\"structurally_same_type(cx, a = {:?}, b = {:?})\", a, b);\n         let tcx = cx.tcx;\n         if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n             // All nominally-same types are structurally same, too.\n@@ -2155,47 +2163,77 @@ impl ClashingExternDeclarations {\n             let a_kind = &a.kind;\n             let b_kind = &b.kind;\n \n+            let compare_layouts = |a, b| -> bool {\n+                let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n+                let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n+                debug!(\"{:?} == {:?} = {}\", a_layout, b_layout, a_layout == b_layout);\n+                a_layout == b_layout\n+            };\n+\n+            #[allow(rustc::usage_of_ty_tykind)]\n+            let is_primitive_or_pointer =\n+                |kind: &ty::TyKind<'_>| kind.is_primitive() || matches!(kind, RawPtr(..));\n+\n             match (a_kind, b_kind) {\n-                (Adt(..), Adt(..)) => {\n-                    // Adts are pretty straightforward: just compare the layouts.\n-                    use rustc_target::abi::LayoutOf;\n-                    let a_layout = cx.layout_of(a).unwrap().layout;\n-                    let b_layout = cx.layout_of(b).unwrap().layout;\n-                    a_layout == b_layout\n+                (Adt(_, a_substs), Adt(_, b_substs)) => {\n+                    let a = a.subst(cx.tcx, a_substs);\n+                    let b = b.subst(cx.tcx, b_substs);\n+                    debug!(\"Comparing {:?} and {:?}\", a, b);\n+\n+                    if let (Adt(a_def, ..), Adt(b_def, ..)) = (&a.kind, &b.kind) {\n+                        // Grab a flattened representation of all fields.\n+                        let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n+                        let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n+                        compare_layouts(a, b)\n+                            && a_fields.eq_by(\n+                                b_fields,\n+                                |&ty::FieldDef { did: a_did, .. },\n+                                 &ty::FieldDef { did: b_did, .. }| {\n+                                    Self::structurally_same_type(\n+                                        cx,\n+                                        tcx.type_of(a_did),\n+                                        tcx.type_of(b_did),\n+                                        ckind,\n+                                    )\n+                                },\n+                            )\n+                    } else {\n+                        unreachable!()\n+                    }\n                 }\n                 (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n                     // For arrays, we also check the constness of the type.\n                     a_const.val == b_const.val\n-                        && Self::structurally_same_type(cx, a_const.ty, b_const.ty)\n-                        && Self::structurally_same_type(cx, a_ty, b_ty)\n+                        && Self::structurally_same_type(cx, a_const.ty, b_const.ty, ckind)\n+                        && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n                 }\n-                (Slice(a_ty), Slice(b_ty)) => Self::structurally_same_type(cx, a_ty, b_ty),\n+                (Slice(a_ty), Slice(b_ty)) => Self::structurally_same_type(cx, a_ty, b_ty, ckind),\n                 (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n-                    a_tymut.mutbl == a_tymut.mutbl\n-                        && Self::structurally_same_type(cx, &a_tymut.ty, &b_tymut.ty)\n+                    a_tymut.mutbl == b_tymut.mutbl\n+                        && Self::structurally_same_type(cx, &a_tymut.ty, &b_tymut.ty, ckind)\n                 }\n                 (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n                     // For structural sameness, we don't need the region to be same.\n-                    a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty)\n+                    a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n                 }\n                 (FnDef(..), FnDef(..)) => {\n-                    // As we don't compare regions, skip_binder is fine.\n                     let a_poly_sig = a.fn_sig(tcx);\n                     let b_poly_sig = b.fn_sig(tcx);\n \n+                    // As we don't compare regions, skip_binder is fine.\n                     let a_sig = a_poly_sig.skip_binder();\n                     let b_sig = b_poly_sig.skip_binder();\n \n                     (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n                         == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n                         && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n-                            Self::structurally_same_type(cx, a, b)\n+                            Self::structurally_same_type(cx, a, b, ckind)\n                         })\n-                        && Self::structurally_same_type(cx, a_sig.output(), b_sig.output())\n+                        && Self::structurally_same_type(cx, a_sig.output(), b_sig.output(), ckind)\n                 }\n                 (Tuple(a_substs), Tuple(b_substs)) => {\n                     a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n-                        Self::structurally_same_type(cx, a_ty, b_ty)\n+                        Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n                     })\n                 }\n                 // For these, it's not quite as easy to define structural-sameness quite so easily.\n@@ -2208,9 +2246,27 @@ impl ClashingExternDeclarations {\n                 | (GeneratorWitness(..), GeneratorWitness(..))\n                 | (Projection(..), Projection(..))\n                 | (Opaque(..), Opaque(..)) => false,\n+\n                 // These definitely should have been caught above.\n                 (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n-                _ => false,\n+\n+                // An Adt and a primitive type. This can be FFI-safe is the ADT is an enum with a\n+                // non-null field.\n+                (Adt(..), other_kind) | (other_kind, Adt(..))\n+                    if is_primitive_or_pointer(other_kind) =>\n+                {\n+                    let (primitive, adt) =\n+                        if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n+                    if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n+                        ty == primitive\n+                    } else {\n+                        compare_layouts(a, b)\n+                    }\n+                }\n+                // Otherwise, just compare the layouts. This may fail to lint for some\n+                // incompatible types, but at the very least, will stop reads into\n+                // uninitialised memory.\n+                _ => compare_layouts(a, b),\n             }\n         }\n     }\n@@ -2231,7 +2287,12 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                     existing_hid, existing_decl_ty, this_fi.hir_id, this_decl_ty\n                 );\n                 // Check that the declarations match.\n-                if !Self::structurally_same_type(cx, existing_decl_ty, this_decl_ty) {\n+                if !Self::structurally_same_type(\n+                    cx,\n+                    existing_decl_ty,\n+                    this_decl_ty,\n+                    CItemKind::Declaration,\n+                ) {\n                     let orig_fi = tcx.hir().expect_foreign_item(existing_hid);\n                     let orig = Self::name_of_extern_decl(tcx, orig_fi);\n "}, {"sha": "31d30a264a59ed57c193ec36ffaa68f4332e63fe", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -573,7 +573,7 @@ pub trait LintContext: Sized {\n                     }\n                 }\n                 BuiltinLintDiagnostics::DeprecatedMacro(suggestion, span) => {\n-                    stability::deprecation_suggestion(&mut db, suggestion, span)\n+                    stability::deprecation_suggestion(&mut db, \"macro\", suggestion, span)\n                 }\n                 BuiltinLintDiagnostics::UnusedDocComment(span) => {\n                     db.span_label(span, \"rustdoc does not generate documentation for macro invocations\");"}, {"sha": "15a9affbff7e9b4393680b31fd8c9802dfa01610", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -61,8 +61,8 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n-    BARE_TRAIT_OBJECTS, ELIDED_LIFETIMES_IN_PATHS, EXPLICIT_OUTLIVES_REQUIREMENTS,\n-    INTRA_DOC_LINK_RESOLUTION_FAILURE, INVALID_CODEBLOCK_ATTRIBUTES, MISSING_DOC_CODE_EXAMPLES,\n+    BARE_TRAIT_OBJECTS, BROKEN_INTRA_DOC_LINKS, ELIDED_LIFETIMES_IN_PATHS,\n+    EXPLICIT_OUTLIVES_REQUIREMENTS, INVALID_CODEBLOCK_ATTRIBUTES, MISSING_DOC_CODE_EXAMPLES,\n     PRIVATE_DOC_TESTS,\n };\n use rustc_span::symbol::{Ident, Symbol};\n@@ -303,7 +303,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n \n     add_lint_group!(\n         \"rustdoc\",\n-        INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        BROKEN_INTRA_DOC_LINKS,\n         INVALID_CODEBLOCK_ATTRIBUTES,\n         MISSING_DOC_CODE_EXAMPLES,\n         PRIVATE_DOC_TESTS\n@@ -318,6 +318,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     store.register_renamed(\"async_idents\", \"keyword_idents\");\n     store.register_renamed(\"exceeding_bitshifts\", \"arithmetic_overflow\");\n     store.register_renamed(\"redundant_semicolon\", \"redundant_semicolons\");\n+    store.register_renamed(\"intra_doc_link_resolution_failure\", \"broken_intra_doc_links\");\n     store.register_removed(\"unknown_features\", \"replaced by an error\");\n     store.register_removed(\"unsigned_negation\", \"replaced by negate_unsigned feature gate\");\n     store.register_removed(\"negate_unsigned\", \"cast a signed value instead\");"}, {"sha": "de750010ed1e6e1af3a4557d615508191e424809", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 128, "deletions": 74, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -15,8 +15,9 @@ use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::abi::Abi;\n use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n-use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::abi::Abi as SpecAbi;\n \n use log::debug;\n use std::cmp;\n@@ -509,14 +510,15 @@ declare_lint! {\n \n declare_lint_pass!(ImproperCTypesDefinitions => [IMPROPER_CTYPES_DEFINITIONS]);\n \n-enum ImproperCTypesMode {\n-    Declarations,\n-    Definitions,\n+#[derive(Clone, Copy)]\n+crate enum CItemKind {\n+    Declaration,\n+    Definition,\n }\n \n struct ImproperCTypesVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    mode: ImproperCTypesMode,\n+    mode: CItemKind,\n }\n \n enum FfiResult<'tcx> {\n@@ -525,54 +527,94 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n-impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n-    /// Is type known to be non-null?\n-    fn ty_is_known_nonnull(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.kind {\n-            ty::FnPtr(_) => true,\n-            ty::Ref(..) => true,\n-            ty::Adt(def, _)\n-                if def.is_box() && matches!(self.mode, ImproperCTypesMode::Definitions) =>\n-            {\n-                true\n-            }\n-            ty::Adt(def, substs) if def.repr.transparent() && !def.is_union() => {\n-                let guaranteed_nonnull_optimization = self\n-                    .cx\n-                    .tcx\n-                    .get_attrs(def.did)\n-                    .iter()\n-                    .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed));\n-\n-                if guaranteed_nonnull_optimization {\n-                    return true;\n-                }\n+/// Is type known to be non-null?\n+fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKind) -> bool {\n+    let tcx = cx.tcx;\n+    match ty.kind {\n+        ty::FnPtr(_) => true,\n+        ty::Ref(..) => true,\n+        ty::Adt(def, _) if def.is_box() && matches!(mode, CItemKind::Definition) => true,\n+        ty::Adt(def, substs) if def.repr.transparent() && !def.is_union() => {\n+            let guaranteed_nonnull_optimization = tcx\n+                .get_attrs(def.did)\n+                .iter()\n+                .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed));\n \n-                for variant in &def.variants {\n-                    if let Some(field) = variant.transparent_newtype_field(self.cx.tcx) {\n-                        if self.ty_is_known_nonnull(field.ty(self.cx.tcx, substs)) {\n-                            return true;\n-                        }\n+            if guaranteed_nonnull_optimization {\n+                return true;\n+            }\n+            for variant in &def.variants {\n+                if let Some(field) = variant.transparent_newtype_field(tcx) {\n+                    if ty_is_known_nonnull(cx, field.ty(tcx, substs), mode) {\n+                        return true;\n                     }\n                 }\n-\n-                false\n             }\n-            _ => false,\n+\n+            false\n         }\n+        _ => false,\n     }\n+}\n+/// Given a non-null scalar (or transparent) type `ty`, return the nullable version of that type.\n+/// If the type passed in was not scalar, returns None.\n+fn get_nullable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+    let tcx = cx.tcx;\n+    Some(match ty.kind {\n+        ty::Adt(field_def, field_substs) => {\n+            let inner_field_ty = {\n+                let first_non_zst_ty =\n+                    field_def.variants.iter().filter_map(|v| v.transparent_newtype_field(tcx));\n+                debug_assert_eq!(\n+                    first_non_zst_ty.clone().count(),\n+                    1,\n+                    \"Wrong number of fields for transparent type\"\n+                );\n+                first_non_zst_ty\n+                    .last()\n+                    .expect(\"No non-zst fields in transparent type.\")\n+                    .ty(tcx, field_substs)\n+            };\n+            return get_nullable_type(cx, inner_field_ty);\n+        }\n+        ty::Int(ty) => tcx.mk_mach_int(ty),\n+        ty::Uint(ty) => tcx.mk_mach_uint(ty),\n+        ty::RawPtr(ty_mut) => tcx.mk_ptr(ty_mut),\n+        // As these types are always non-null, the nullable equivalent of\n+        // Option<T> of these types are their raw pointer counterparts.\n+        ty::Ref(_region, ty, mutbl) => tcx.mk_ptr(ty::TypeAndMut { ty, mutbl }),\n+        ty::FnPtr(..) => {\n+            // There is no nullable equivalent for Rust's function pointers -- you\n+            // must use an Option<fn(..) -> _> to represent it.\n+            ty\n+        }\n \n-    /// Check if this enum can be safely exported based on the \"nullable pointer optimization\".\n-    /// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n-    /// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n-    fn is_repr_nullable_ptr(\n-        &self,\n-        ty: Ty<'tcx>,\n-        ty_def: &'tcx ty::AdtDef,\n-        substs: SubstsRef<'tcx>,\n-    ) -> bool {\n+        // We should only ever reach this case if ty_is_known_nonnull is extended\n+        // to other types.\n+        ref unhandled => {\n+            debug!(\n+                \"get_nullable_type: Unhandled scalar kind: {:?} while checking {:?}\",\n+                unhandled, ty\n+            );\n+            return None;\n+        }\n+    })\n+}\n+\n+/// Check if this enum can be safely exported based on the \"nullable pointer optimization\". If it\n+/// can, return the the type that `ty` can be safely converted to, otherwise return `None`.\n+/// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n+/// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n+/// FIXME: This duplicates code in codegen.\n+crate fn repr_nullable_ptr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    ckind: CItemKind,\n+) -> Option<Ty<'tcx>> {\n+    debug!(\"is_repr_nullable_ptr(cx, ty = {:?})\", ty);\n+    if let ty::Adt(ty_def, substs) = ty.kind {\n         if ty_def.variants.len() != 2 {\n-            return false;\n+            return None;\n         }\n \n         let get_variant_fields = |index| &ty_def.variants[VariantIdx::new(index)].fields;\n@@ -582,30 +624,42 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         } else if variant_fields[1].is_empty() {\n             &variant_fields[0]\n         } else {\n-            return false;\n+            return None;\n         };\n \n         if fields.len() != 1 {\n-            return false;\n+            return None;\n         }\n \n-        let field_ty = fields[0].ty(self.cx.tcx, substs);\n-        if !self.ty_is_known_nonnull(field_ty) {\n-            return false;\n+        let field_ty = fields[0].ty(cx.tcx, substs);\n+        if !ty_is_known_nonnull(cx, field_ty, ckind) {\n+            return None;\n         }\n \n-        // At this point, the field's type is known to be nonnull and the parent enum is\n-        // Option-like. If the computed size for the field and the enum are different, the non-null\n-        // optimization isn't being applied (and we've got a problem somewhere).\n-        let compute_size_skeleton =\n-            |t| SizeSkeleton::compute(t, self.cx.tcx, self.cx.param_env).unwrap();\n+        // At this point, the field's type is known to be nonnull and the parent enum is Option-like.\n+        // If the computed size for the field and the enum are different, the nonnull optimization isn't\n+        // being applied (and we've got a problem somewhere).\n+        let compute_size_skeleton = |t| SizeSkeleton::compute(t, cx.tcx, cx.param_env).unwrap();\n         if !compute_size_skeleton(ty).same_size(compute_size_skeleton(field_ty)) {\n             bug!(\"improper_ctypes: Option nonnull optimization not applied?\");\n         }\n \n-        true\n+        // Return the nullable type this Option-like enum can be safely represented with.\n+        let field_ty_abi = &cx.layout_of(field_ty).unwrap().abi;\n+        if let Abi::Scalar(field_ty_scalar) = field_ty_abi {\n+            match (field_ty_scalar.valid_range.start(), field_ty_scalar.valid_range.end()) {\n+                (0, _) => unreachable!(\"Non-null optimisation extended to a non-zero value.\"),\n+                (1, _) => {\n+                    return Some(get_nullable_type(cx, field_ty).unwrap());\n+                }\n+                (start, end) => unreachable!(\"Unhandled start and end range: ({}, {})\", start, end),\n+            };\n+        }\n     }\n+    None\n+}\n \n+impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the type is array and emit an unsafe type lint.\n     fn check_for_array_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n         if let ty::Array(..) = ty.kind {\n@@ -686,7 +740,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_type_for_ffi(&self, cache: &mut FxHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult<'tcx> {\n         use FfiResult::*;\n \n-        let cx = self.cx.tcx;\n+        let tcx = self.cx.tcx;\n \n         // Protect against infinite recursion, for example\n         // `struct S(*mut S);`.\n@@ -697,9 +751,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.kind {\n-            ty::Adt(def, _)\n-                if def.is_box() && matches!(self.mode, ImproperCTypesMode::Definitions) =>\n-            {\n+            ty::Adt(def, _) if def.is_box() && matches!(self.mode, CItemKind::Definition) => {\n                 FfiSafe\n             }\n \n@@ -753,7 +805,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // discriminant.\n                         if !def.repr.c() && !def.repr.transparent() && def.repr.int.is_none() {\n                             // Special-case types like `Option<extern fn()>`.\n-                            if !self.is_repr_nullable_ptr(ty, def, substs) {\n+                            if repr_nullable_ptr(self.cx, ty, self.mode).is_none() {\n                                 return FfiUnsafe {\n                                     ty,\n                                     reason: \"enum has no representation hint\".into(),\n@@ -836,7 +888,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n                 if {\n-                    matches!(self.mode, ImproperCTypesMode::Definitions)\n+                    matches!(self.mode, CItemKind::Definition)\n                         && ty.is_sized(self.cx.tcx.at(DUMMY_SP), self.cx.param_env)\n                 } =>\n             {\n@@ -862,7 +914,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     };\n                 }\n \n-                let sig = cx.erase_late_bound_regions(&sig);\n+                let sig = tcx.erase_late_bound_regions(&sig);\n                 if !sig.output().is_unit() {\n                     let r = self.check_type_for_ffi(cache, sig.output());\n                     match r {\n@@ -894,9 +946,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Projection(..)\n-                if matches!(self.mode, ImproperCTypesMode::Definitions) =>\n-            {\n+            ty::Param(..) | ty::Projection(..) if matches!(self.mode, CItemKind::Definition) => {\n                 FfiSafe\n             }\n \n@@ -921,14 +971,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         help: Option<&str>,\n     ) {\n         let lint = match self.mode {\n-            ImproperCTypesMode::Declarations => IMPROPER_CTYPES,\n-            ImproperCTypesMode::Definitions => IMPROPER_CTYPES_DEFINITIONS,\n+            CItemKind::Declaration => IMPROPER_CTYPES,\n+            CItemKind::Definition => IMPROPER_CTYPES_DEFINITIONS,\n         };\n \n         self.cx.struct_span_lint(lint, sp, |lint| {\n             let item_description = match self.mode {\n-                ImproperCTypesMode::Declarations => \"block\",\n-                ImproperCTypesMode::Definitions => \"fn\",\n+                CItemKind::Declaration => \"block\",\n+                CItemKind::Definition => \"fn\",\n             };\n             let mut diag = lint.build(&format!(\n                 \"`extern` {} uses type `{}`, which is not FFI-safe\",\n@@ -1052,8 +1102,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         self.check_type_for_ffi_and_report_errors(span, ty, true, false);\n     }\n \n-    fn is_internal_abi(&self, abi: Abi) -> bool {\n-        if let Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic = abi {\n+    fn is_internal_abi(&self, abi: SpecAbi) -> bool {\n+        if let SpecAbi::Rust\n+        | SpecAbi::RustCall\n+        | SpecAbi::RustIntrinsic\n+        | SpecAbi::PlatformIntrinsic = abi\n+        {\n             true\n         } else {\n             false\n@@ -1063,7 +1117,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDeclarations {\n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, it: &hir::ForeignItem<'_>) {\n-        let mut vis = ImproperCTypesVisitor { cx, mode: ImproperCTypesMode::Declarations };\n+        let mut vis = ImproperCTypesVisitor { cx, mode: CItemKind::Declaration };\n         let abi = cx.tcx.hir().get_foreign_abi(it.hir_id);\n \n         if !vis.is_internal_abi(abi) {\n@@ -1098,7 +1152,7 @@ impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDefinitions {\n             _ => return,\n         };\n \n-        let mut vis = ImproperCTypesVisitor { cx, mode: ImproperCTypesMode::Definitions };\n+        let mut vis = ImproperCTypesVisitor { cx, mode: CItemKind::Definition };\n         if !vis.is_internal_abi(abi) {\n             vis.check_foreign_fn(hir_id, decl);\n         }"}, {"sha": "a33f920603592691d95881aa371ebc80b2d565f7", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -203,6 +203,28 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     // Otherwise, we don't lint, to avoid false positives.\n                     _ => false,\n                 },\n+                ty::Closure(..) => {\n+                    cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n+                        let mut err = lint.build(&format!(\n+                            \"unused {}closure{}{} that must be used\",\n+                            descr_pre, plural_suffix, descr_post,\n+                        ));\n+                        err.note(\"closures are lazy and do nothing unless called\");\n+                        err.emit();\n+                    });\n+                    true\n+                }\n+                ty::Generator(..) => {\n+                    cx.struct_span_lint(UNUSED_MUST_USE, span, |lint| {\n+                        let mut err = lint.build(&format!(\n+                            \"unused {}generator{}{} that must be used\",\n+                            descr_pre, plural_suffix, descr_post,\n+                        ));\n+                        err.note(\"generators are lazy and do nothing unless resumed\");\n+                        err.emit();\n+                    });\n+                    true\n+                }\n                 _ => false,\n             }\n         }\n@@ -400,7 +422,7 @@ trait UnusedDelimLint {\n         lhs_needs_parens\n             || (followed_by_block\n                 && match inner.kind {\n-                    ExprKind::Ret(_) | ExprKind::Break(..) => true,\n+                    ExprKind::Ret(_) | ExprKind::Break(..) | ExprKind::Yield(..) => true,\n                     _ => parser::contains_exterior_struct_lit(&inner),\n                 })\n     }"}, {"sha": "2c0e2aa39fd595dcedf398ae40acb5803591258f", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,7 +12,7 @@ doctest = false\n [dependencies]\n flate2 = \"1.0\"\n libc = \"0.2\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n memmap = \"0.7\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_middle = { path = \"../librustc_middle\" }"}, {"sha": "9bc6c054e4d018840cc20987e946dfeb6cbf0561", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -13,7 +13,7 @@ use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def_id::{CrateNum, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::Definitions;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::middle::cstore::{CrateSource, DepKind, ExternCrate};\n+use rustc_middle::middle::cstore::{CrateDepKind, CrateSource, ExternCrate};\n use rustc_middle::middle::cstore::{ExternCrateSource, MetadataLoaderDyn};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{self, CrateType, ExternLocation};\n@@ -26,7 +26,7 @@ use rustc_span::symbol::{sym, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n \n-use log::{debug, info, log_enabled};\n+use log::{debug, info};\n use proc_macro::bridge::client::ProcMacro;\n use std::path::Path;\n use std::{cmp, env, fs};\n@@ -82,24 +82,36 @@ impl std::ops::Deref for CrateMetadataRef<'_> {\n     }\n }\n \n-fn dump_crates(cstore: &CStore) {\n-    info!(\"resolved crates:\");\n-    cstore.iter_crate_data(|cnum, data| {\n-        info!(\"  name: {}\", data.name());\n-        info!(\"  cnum: {}\", cnum);\n-        info!(\"  hash: {}\", data.hash());\n-        info!(\"  reqd: {:?}\", data.dep_kind());\n-        let CrateSource { dylib, rlib, rmeta } = data.source();\n-        if let Some(dylib) = dylib {\n-            info!(\"  dylib: {}\", dylib.0.display());\n-        }\n-        if let Some(rlib) = rlib {\n-            info!(\"   rlib: {}\", rlib.0.display());\n-        }\n-        if let Some(rmeta) = rmeta {\n-            info!(\"   rmeta: {}\", rmeta.0.display());\n-        }\n-    });\n+struct CrateDump<'a>(&'a CStore);\n+\n+impl<'a> std::fmt::Debug for CrateDump<'a> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        writeln!(fmt, \"resolved crates:\")?;\n+        // `iter_crate_data` does not allow returning values. Thus we use a mutable variable here\n+        // that aggregates the value (and any errors that could happen).\n+        let mut res = Ok(());\n+        self.0.iter_crate_data(|cnum, data| {\n+            res = res.and(\n+                try {\n+                    writeln!(fmt, \"  name: {}\", data.name())?;\n+                    writeln!(fmt, \"  cnum: {}\", cnum)?;\n+                    writeln!(fmt, \"  hash: {}\", data.hash())?;\n+                    writeln!(fmt, \"  reqd: {:?}\", data.dep_kind())?;\n+                    let CrateSource { dylib, rlib, rmeta } = data.source();\n+                    if let Some(dylib) = dylib {\n+                        writeln!(fmt, \"  dylib: {}\", dylib.0.display())?;\n+                    }\n+                    if let Some(rlib) = rlib {\n+                        writeln!(fmt, \"   rlib: {}\", rlib.0.display())?;\n+                    }\n+                    if let Some(rmeta) = rmeta {\n+                        writeln!(fmt, \"   rmeta: {}\", rmeta.0.display())?;\n+                    }\n+                },\n+            );\n+        });\n+        res\n+    }\n }\n \n impl CStore {\n@@ -236,9 +248,9 @@ impl<'a> CrateLoader<'a> {\n                 // Only use `--extern crate_name=path` here, not `--extern crate_name`.\n                 if let Some(mut files) = entry.files() {\n                     if files.any(|l| {\n-                        let l = fs::canonicalize(l).ok();\n-                        source.dylib.as_ref().map(|p| &p.0) == l.as_ref()\n-                            || source.rlib.as_ref().map(|p| &p.0) == l.as_ref()\n+                        let l = fs::canonicalize(l).unwrap_or(l.clone().into());\n+                        source.dylib.as_ref().map(|p| &p.0) == Some(&l)\n+                            || source.rlib.as_ref().map(|p| &p.0) == Some(&l)\n                     }) {\n                         ret = Some(cnum);\n                     }\n@@ -294,7 +306,7 @@ impl<'a> CrateLoader<'a> {\n         host_lib: Option<Library>,\n         root: Option<&CratePaths>,\n         lib: Library,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n         name: Symbol,\n     ) -> Result<CrateNum, CrateError> {\n         let _prof_timer = self.sess.prof.generic_activity(\"metadata_register_crate\");\n@@ -425,7 +437,7 @@ impl<'a> CrateLoader<'a> {\n         &'b mut self,\n         name: Symbol,\n         span: Span,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> CrateNum {\n         if dep.is_none() {\n@@ -438,7 +450,7 @@ impl<'a> CrateLoader<'a> {\n     fn maybe_resolve_crate<'b>(\n         &'b mut self,\n         name: Symbol,\n-        mut dep_kind: DepKind,\n+        mut dep_kind: CrateDepKind,\n         dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> Result<CrateNum, CrateError> {\n         info!(\"resolving crate `{}`\", name);\n@@ -475,7 +487,7 @@ impl<'a> CrateLoader<'a> {\n             match self.load(&mut locator)? {\n                 Some(res) => (res, None),\n                 None => {\n-                    dep_kind = DepKind::MacrosOnly;\n+                    dep_kind = CrateDepKind::MacrosOnly;\n                     match self.load_proc_macro(&mut locator, path_kind)? {\n                         Some(res) => res,\n                         None => return Err(locator.into_error()),\n@@ -488,7 +500,7 @@ impl<'a> CrateLoader<'a> {\n             (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n                 if data.is_proc_macro_crate() {\n-                    dep_kind = DepKind::MacrosOnly;\n+                    dep_kind = CrateDepKind::MacrosOnly;\n                 }\n                 data.update_dep_kind(|data_dep_kind| cmp::max(data_dep_kind, dep_kind));\n                 Ok(cnum)\n@@ -548,7 +560,7 @@ impl<'a> CrateLoader<'a> {\n         crate_root: &CrateRoot<'_>,\n         metadata: &MetadataBlob,\n         krate: CrateNum,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n     ) -> Result<CrateNumMap, CrateError> {\n         debug!(\"resolving deps of external crate\");\n         if crate_root.is_proc_macro_crate() {\n@@ -567,7 +579,7 @@ impl<'a> CrateLoader<'a> {\n                 dep.name, dep.hash, dep.extra_filename\n             );\n             let dep_kind = match dep_kind {\n-                DepKind::MacrosOnly => DepKind::MacrosOnly,\n+                CrateDepKind::MacrosOnly => CrateDepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n             let cnum = self.maybe_resolve_crate(dep.name, dep_kind, Some((root, &dep)))?;\n@@ -634,7 +646,7 @@ impl<'a> CrateLoader<'a> {\n                 self.inject_dependency_if(cnum, \"a panic runtime\", &|data| {\n                     data.needs_panic_runtime()\n                 });\n-                runtime_found = runtime_found || data.dep_kind() == DepKind::Explicit;\n+                runtime_found = runtime_found || data.dep_kind() == CrateDepKind::Explicit;\n             }\n         });\n \n@@ -663,7 +675,7 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+        let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit, None);\n         let data = self.cstore.get_crate_data(cnum);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n@@ -693,7 +705,7 @@ impl<'a> CrateLoader<'a> {\n             info!(\"loading profiler\");\n \n             let name = sym::profiler_builtins;\n-            let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n+            let cnum = self.resolve_crate(name, DUMMY_SP, CrateDepKind::Implicit, None);\n             let data = self.cstore.get_crate_data(cnum);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n@@ -864,9 +876,7 @@ impl<'a> CrateLoader<'a> {\n         self.inject_allocator_crate(krate);\n         self.inject_panic_runtime(krate);\n \n-        if log_enabled!(log::Level::Info) {\n-            dump_crates(&self.cstore);\n-        }\n+        info!(\"{:?}\", CrateDump(&self.cstore));\n \n         self.report_unused_deps(krate);\n     }\n@@ -891,9 +901,9 @@ impl<'a> CrateLoader<'a> {\n                     None => item.ident.name,\n                 };\n                 let dep_kind = if attr::contains_name(&item.attrs, sym::no_link) {\n-                    DepKind::MacrosOnly\n+                    CrateDepKind::MacrosOnly\n                 } else {\n-                    DepKind::Explicit\n+                    CrateDepKind::Explicit\n                 };\n \n                 let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n@@ -915,7 +925,7 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn process_path_extern(&mut self, name: Symbol, span: Span) -> CrateNum {\n-        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None);\n+        let cnum = self.resolve_crate(name, span, CrateDepKind::Explicit, None);\n \n         self.update_extern_crate(\n             cnum,\n@@ -932,6 +942,6 @@ impl<'a> CrateLoader<'a> {\n     }\n \n     pub fn maybe_process_path_extern(&mut self, name: Symbol) -> Option<CrateNum> {\n-        self.maybe_resolve_crate(name, DepKind::Explicit, None).ok()\n+        self.maybe_resolve_crate(name, CrateDepKind::Explicit, None).ok()\n     }\n }"}, {"sha": "bb5ae4d0557c9866a221ae6d7053b519c2397f9b", "filename": "src/librustc_metadata/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -56,7 +56,7 @@ use crate::creader::CStore;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::LinkagePreference::{self, RequireDynamic, RequireStatic};\n-use rustc_middle::middle::cstore::{self, DepKind};\n+use rustc_middle::middle::cstore::{self, CrateDepKind};\n use rustc_middle::middle::dependency_format::{Dependencies, DependencyList, Linkage};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::CrateType;\n@@ -188,7 +188,7 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         let src = tcx.used_crate_source(cnum);\n         if src.dylib.is_none()\n             && !formats.contains_key(&cnum)\n-            && tcx.dep_kind(cnum) == DepKind::Explicit\n+            && tcx.dep_kind(cnum) == CrateDepKind::Explicit\n         {\n             assert!(src.rlib.is_some() || src.rmeta.is_some());\n             log::info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n@@ -284,7 +284,7 @@ fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n     let last_crate = tcx.crates().len();\n     let mut ret = (1..last_crate + 1)\n         .map(|cnum| {\n-            if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n+            if tcx.dep_kind(CrateNum::new(cnum)) == CrateDepKind::Explicit {\n                 Linkage::Static\n             } else {\n                 Linkage::NotLinked"}, {"sha": "059ae340bcfe968821f5f36d99a46165a365a837", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,6 +9,7 @@\n #![feature(proc_macro_internals)]\n #![feature(min_specialization)]\n #![feature(stmt_expr_attributes)]\n+#![feature(try_blocks)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "8828b318d1ea6bb6d5fcac44707ee06f4b044391", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -426,20 +426,17 @@ impl<'a> CrateLocator<'a> {\n             info!(\"lib candidate: {}\", spf.path.display());\n \n             let (rlibs, rmetas, dylibs) = candidates.entry(hash.to_string()).or_default();\n-            fs::canonicalize(&spf.path)\n-                .map(|p| {\n-                    if seen_paths.contains(&p) {\n-                        return FileDoesntMatch;\n-                    };\n-                    seen_paths.insert(p.clone());\n-                    match found_kind {\n-                        CrateFlavor::Rlib => rlibs.insert(p, kind),\n-                        CrateFlavor::Rmeta => rmetas.insert(p, kind),\n-                        CrateFlavor::Dylib => dylibs.insert(p, kind),\n-                    };\n-                    FileMatches\n-                })\n-                .unwrap_or(FileDoesntMatch)\n+            let path = fs::canonicalize(&spf.path).unwrap_or_else(|_| spf.path.clone());\n+            if seen_paths.contains(&path) {\n+                return FileDoesntMatch;\n+            };\n+            seen_paths.insert(path.clone());\n+            match found_kind {\n+                CrateFlavor::Rlib => rlibs.insert(path, kind),\n+                CrateFlavor::Rmeta => rmetas.insert(path, kind),\n+                CrateFlavor::Dylib => dylibs.insert(path, kind),\n+            };\n+            FileMatches\n         });\n         self.rejected_via_kind.extend(staticlibs);\n \n@@ -688,12 +685,13 @@ impl<'a> CrateLocator<'a> {\n                     && file.ends_with(&self.target.options.dll_suffix)\n             {\n                 // Make sure there's at most one rlib and at most one dylib.\n+                let loc = fs::canonicalize(&loc).unwrap_or_else(|_| loc.clone());\n                 if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rlib\") {\n-                    rlibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                    rlibs.insert(loc, PathKind::ExternFlag);\n                 } else if loc.file_name().unwrap().to_str().unwrap().ends_with(\".rmeta\") {\n-                    rmetas.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                    rmetas.insert(loc, PathKind::ExternFlag);\n                 } else {\n-                    dylibs.insert(fs::canonicalize(&loc).unwrap(), PathKind::ExternFlag);\n+                    dylibs.insert(loc, PathKind::ExternFlag);\n                 }\n             } else {\n                 self.rejected_via_filename"}, {"sha": "3c045df45da161a35daf4ee15a2e80b022b220b6", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -100,7 +100,7 @@ crate struct CrateMetadata {\n     /// Same ID set as `cnum_map` plus maybe some injected crates like panic runtime.\n     dependencies: Lock<Vec<CrateNum>>,\n     /// How to link (or not link) this crate to the currently compiled crate.\n-    dep_kind: Lock<DepKind>,\n+    dep_kind: Lock<CrateDepKind>,\n     /// Filesystem location of this crate.\n     source: CrateSource,\n     /// Whether or not this crate should be consider a private dependency\n@@ -780,7 +780,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n     fn get_variant(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n         kind: &EntryKind,\n         index: DefIndex,\n         parent_did: DefId,\n@@ -805,7 +804,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         let ctor_did = data.ctor.map(|index| self.local_def_id(index));\n \n         ty::VariantDef::new(\n-            tcx,\n             self.item_ident(index, sess),\n             variant_did,\n             ctor_did,\n@@ -826,6 +824,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             adt_kind,\n             parent_did,\n             false,\n+            data.is_non_exhaustive,\n         )\n     }\n \n@@ -847,10 +846,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or(Lazy::empty())\n                 .decode(self)\n-                .map(|index| self.get_variant(tcx, &self.kind(index), index, did, tcx.sess))\n+                .map(|index| self.get_variant(&self.kind(index), index, did, tcx.sess))\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(tcx, &kind, item_id, did, tcx.sess)).collect()\n+            std::iter::once(self.get_variant(&kind, item_id, did, tcx.sess)).collect()\n         };\n \n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n@@ -1670,7 +1669,7 @@ impl CrateMetadata {\n         raw_proc_macros: Option<&'static [ProcMacro]>,\n         cnum: CrateNum,\n         cnum_map: CrateNumMap,\n-        dep_kind: DepKind,\n+        dep_kind: CrateDepKind,\n         source: CrateSource,\n         private_dep: bool,\n         host_hash: Option<Svh>,\n@@ -1728,11 +1727,11 @@ impl CrateMetadata {\n         &self.source\n     }\n \n-    crate fn dep_kind(&self) -> DepKind {\n+    crate fn dep_kind(&self) -> CrateDepKind {\n         *self.dep_kind.lock()\n     }\n \n-    crate fn update_dep_kind(&self, f: impl FnOnce(DepKind) -> DepKind) {\n+    crate fn update_dep_kind(&self, f: impl FnOnce(CrateDepKind) -> CrateDepKind) {\n         self.dep_kind.with_lock(|dep_kind| *dep_kind = f(*dep_kind))\n     }\n "}, {"sha": "352b8bff7e2fb80df0428685f901b70a5f850154", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -267,7 +267,7 @@ impl<'a, 'tcx> SpecializedEncoder<Span> for EncodeContext<'a, 'tcx> {\n         // real code should never need to care about this.\n         //\n         // 2. Using `Span::def_site` or `Span::mixed_site` will not\n-        // include any hygiene information associated with the defintion\n+        // include any hygiene information associated with the definition\n         // site. This means that a proc-macro cannot emit a `$crate`\n         // identifier which resolves to one of its dependencies,\n         // which also should never come up in practice.\n@@ -738,6 +738,7 @@ impl EncodeContext<'a, 'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: variant.ctor_def_id.map(|did| did.index),\n+            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n         let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local());\n@@ -782,6 +783,7 @@ impl EncodeContext<'a, 'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n+            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n@@ -886,6 +888,7 @@ impl EncodeContext<'a, 'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n+            is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n         let struct_id = tcx.hir().as_local_hir_id(adt_def.did.expect_local());\n@@ -1235,6 +1238,7 @@ impl EncodeContext<'a, 'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n+                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Union(..) => {\n@@ -1245,6 +1249,7 @@ impl EncodeContext<'a, 'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n+                    is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Impl { defaultness, .. } => {"}, {"sha": "12d2f50363c1a85e343e7fbccfd6e196c65b0d1d", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ use rustc_hir::def_id::{DefId, DefIndex};\n use rustc_hir::lang_items;\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_middle::hir::exports::Export;\n-use rustc_middle::middle::cstore::{DepKind, ForeignModule, LinkagePreference, NativeLib};\n+use rustc_middle::middle::cstore::{CrateDepKind, ForeignModule, LinkagePreference, NativeLib};\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, ReprOptions, Ty};\n@@ -226,7 +226,7 @@ crate struct CrateDep {\n     pub name: Symbol,\n     pub hash: Svh,\n     pub host_hash: Option<Svh>,\n-    pub kind: DepKind,\n+    pub kind: CrateDepKind,\n     pub extra_filename: String,\n }\n \n@@ -346,6 +346,7 @@ struct VariantData {\n     discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n     ctor: Option<DefIndex>,\n+    is_non_exhaustive: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}, {"sha": "678fcfe65394b969a943dff049be2a963f72e17a", "filename": "src/librustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -13,7 +13,7 @@ doctest = false\n rustc_arena = { path = \"../librustc_arena\" }\n bitflags = \"1.2.1\"\n scoped-tls = \"1.0\"\n-log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc-rayon-core = \"0.3.0\"\n polonius-engine = \"0.12.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }"}, {"sha": "0a34c06adf063bae570f3c72b4b1c98d2bd15ddd", "filename": "src/librustc_middle/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fcstore.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -40,7 +40,7 @@ impl CrateSource {\n \n #[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n #[derive(HashStable)]\n-pub enum DepKind {\n+pub enum CrateDepKind {\n     /// A dependency that is only used for its macros.\n     MacrosOnly,\n     /// A dependency that is always injected into the dependency list and so\n@@ -51,11 +51,11 @@ pub enum DepKind {\n     Explicit,\n }\n \n-impl DepKind {\n+impl CrateDepKind {\n     pub fn macros_only(self) -> bool {\n         match self {\n-            DepKind::MacrosOnly => true,\n-            DepKind::Implicit | DepKind::Explicit => false,\n+            CrateDepKind::MacrosOnly => true,\n+            CrateDepKind::Implicit | CrateDepKind::Explicit => false,\n         }\n     }\n }"}, {"sha": "b913d7dd4ad0b62ba9a3c7c7583c9b4b48c72b0a", "filename": "src/librustc_middle/middle/stability.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmiddle%2Fstability.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -166,29 +166,31 @@ pub fn deprecation_in_effect(is_since_rustc_version: bool, since: Option<&str>)\n \n pub fn deprecation_suggestion(\n     diag: &mut DiagnosticBuilder<'_>,\n+    kind: &str,\n     suggestion: Option<Symbol>,\n     span: Span,\n ) {\n     if let Some(suggestion) = suggestion {\n         diag.span_suggestion(\n             span,\n-            \"replace the use of the deprecated item\",\n+            &format!(\"replace the use of the deprecated {}\", kind),\n             suggestion.to_string(),\n             Applicability::MachineApplicable,\n         );\n     }\n }\n \n-pub fn deprecation_message(depr: &Deprecation, path: &str) -> (String, &'static Lint) {\n+pub fn deprecation_message(depr: &Deprecation, kind: &str, path: &str) -> (String, &'static Lint) {\n     let (message, lint) = if deprecation_in_effect(\n         depr.is_since_rustc_version,\n         depr.since.map(Symbol::as_str).as_deref(),\n     ) {\n-        (format!(\"use of deprecated item '{}'\", path), DEPRECATED)\n+        (format!(\"use of deprecated {} `{}`\", kind, path), DEPRECATED)\n     } else {\n         (\n             format!(\n-                \"use of item '{}' that will be deprecated in future version {}\",\n+                \"use of {} `{}` that will be deprecated in future version {}\",\n+                kind,\n                 path,\n                 depr.since.unwrap()\n             ),\n@@ -224,6 +226,7 @@ fn late_report_deprecation(\n     lint: &'static Lint,\n     span: Span,\n     hir_id: HirId,\n+    def_id: DefId,\n ) {\n     if span.in_derive_expansion() {\n         return;\n@@ -232,7 +235,8 @@ fn late_report_deprecation(\n     tcx.struct_span_lint_hir(lint, hir_id, span, |lint| {\n         let mut diag = lint.build(message);\n         if let hir::Node::Expr(_) = tcx.hir().get(hir_id) {\n-            deprecation_suggestion(&mut diag, suggestion, span);\n+            let kind = tcx.def_kind(def_id).descr(def_id);\n+            deprecation_suggestion(&mut diag, kind, suggestion, span);\n         }\n         diag.emit()\n     });\n@@ -304,15 +308,17 @@ impl<'tcx> TyCtxt<'tcx> {\n                 // #[rustc_deprecated] however wants to emit down the whole\n                 // hierarchy.\n                 if !skip || depr_entry.attr.is_since_rustc_version {\n-                    let (message, lint) =\n-                        deprecation_message(&depr_entry.attr, &self.def_path_str(def_id));\n+                    let path = &self.def_path_str(def_id);\n+                    let kind = self.def_kind(def_id).descr(def_id);\n+                    let (message, lint) = deprecation_message(&depr_entry.attr, kind, path);\n                     late_report_deprecation(\n                         self,\n                         &message,\n                         depr_entry.attr.suggestion,\n                         lint,\n                         span,\n                         id,\n+                        def_id,\n                     );\n                 }\n             };"}, {"sha": "82365ef6a73de8ebb2e5f05ad0af9d2717b3a328", "filename": "src/librustc_middle/mir/coverage/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -3,17 +3,17 @@\n /// Positional arguments to `libcore::count_code_region()`\n pub mod count_code_region_args {\n     pub const FUNCTION_SOURCE_HASH: usize = 0;\n-    pub const COUNTER_INDEX: usize = 1;\n+    pub const COUNTER_ID: usize = 1;\n     pub const START_BYTE_POS: usize = 2;\n     pub const END_BYTE_POS: usize = 3;\n }\n \n /// Positional arguments to `libcore::coverage_counter_add()` and\n /// `libcore::coverage_counter_subtract()`\n pub mod coverage_counter_expression_args {\n-    pub const COUNTER_EXPRESSION_INDEX: usize = 0;\n-    pub const LEFT_INDEX: usize = 1;\n-    pub const RIGHT_INDEX: usize = 2;\n+    pub const EXPRESSION_ID: usize = 0;\n+    pub const LEFT_ID: usize = 1;\n+    pub const RIGHT_ID: usize = 2;\n     pub const START_BYTE_POS: usize = 3;\n     pub const END_BYTE_POS: usize = 4;\n }"}, {"sha": "442e7f6b0f45e46e5930bcc9519c2e297553d666", "filename": "src/librustc_middle/mir/interpret/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fqueries.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -18,7 +18,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let substs = InternalSubsts::identity_for_item(self, def_id);\n         let instance = ty::Instance::new(def_id, substs);\n         let cid = GlobalId { instance, promoted: None };\n-        let param_env = self.param_env(def_id).with_reveal_all();\n+        let param_env = self.param_env(def_id).with_reveal_all_normalized(self);\n         self.const_eval_global_id(param_env, cid, None)\n     }\n "}, {"sha": "2c76f0b5ad0222bf6cc2cb3c598a36d13c9491b3", "filename": "src/librustc_middle/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fvalue.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -78,7 +78,7 @@ impl<'tcx> ConstValue<'tcx> {\n         param_env: ParamEnv<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> Option<u128> {\n-        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        let size = tcx.layout_of(param_env.with_reveal_all_normalized(tcx).and(ty)).ok()?.size;\n         self.try_to_bits(size)\n     }\n "}, {"sha": "862c046358b8418f539c12c44158ae46127fab79", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -864,11 +864,17 @@ rustc_queries! {\n         /// type-checking etc, and it does not normalize specializable\n         /// associated types. This is almost always what you want,\n         /// unless you are doing MIR optimizations, in which case you\n-        /// might want to use `reveal_all()` method to change modes.\n         query param_env(def_id: DefId) -> ty::ParamEnv<'tcx> {\n             desc { |tcx| \"computing normalized predicates of `{}`\", tcx.def_path_str(def_id) }\n         }\n \n+        /// Like `param_env`, but returns the `ParamEnv in `Reveal::All` mode.\n+        /// Prefer this over `tcx.param_env(def_id).with_reveal_all_normalized(tcx)`,\n+        /// as this method is more efficient.\n+        query param_env_reveal_all_normalized(def_id: DefId) -> ty::ParamEnv<'tcx> {\n+            desc { |tcx| \"computing revealed normalized predicates of `{}`\", tcx.def_path_str(def_id) }\n+        }\n+\n         /// Trait selection queries. These are best used by invoking `ty.is_copy_modulo_regions()`,\n         /// `ty.is_copy()`, etc, since that will prune the environment where possible.\n         query is_copy_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n@@ -1180,7 +1186,7 @@ rustc_queries! {\n     }\n \n     Other {\n-        query dep_kind(_: CrateNum) -> DepKind {\n+        query dep_kind(_: CrateNum) -> CrateDepKind {\n             eval_always\n             desc { \"fetching what a dependency looks like\" }\n         }\n@@ -1527,5 +1533,9 @@ rustc_queries! {\n                 ty::Instance::new(key.value.0.to_def_id(), key.value.2),\n             }\n         }\n+\n+        query normalize_opaque_types(key: &'tcx ty::List<ty::Predicate<'tcx>>) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n+            desc { \"normalizing opaque types in {:?}\", key }\n+        }\n     }\n }"}, {"sha": "c0b5693dc594e0586498b13fa5e1a1eb4d2700cd", "filename": "src/librustc_middle/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -158,7 +158,7 @@ impl<'tcx> Const<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> Option<u128> {\n         assert_eq!(self.ty, ty);\n-        let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        let size = tcx.layout_of(param_env.with_reveal_all_normalized(tcx).and(ty)).ok()?.size;\n         // if `ty` does not depend on generic parameters, use an empty param_env\n         self.val.eval(tcx, param_env).try_to_bits(size)\n     }"}, {"sha": "e8a1e714a8f43885a9a5c65d39525fe3722930e5", "filename": "src/librustc_middle/ty/consts/kind.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts%2Fkind.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -96,12 +96,16 @@ impl<'tcx> ConstKind<'tcx> {\n         if let ConstKind::Unevaluated(def, substs, promoted) = self {\n             use crate::mir::interpret::ErrorHandled;\n \n-            let param_env_and_substs = param_env.with_reveal_all().and(substs);\n-\n             // HACK(eddyb) this erases lifetimes even though `const_eval_resolve`\n             // also does later, but we want to do it before checking for\n             // inference variables.\n-            let param_env_and_substs = tcx.erase_regions(&param_env_and_substs);\n+            // Note that we erase regions *before* calling `with_reveal_all_normalized`,\n+            // so that we don't try to invoke this query with\n+            // any region variables.\n+            let param_env_and_substs = tcx\n+                .erase_regions(&param_env)\n+                .with_reveal_all_normalized(tcx)\n+                .and(tcx.erase_regions(&substs));\n \n             // HACK(eddyb) when the query key would contain inference variables,\n             // attempt using identity substs and `ParamEnv` instead, that will succeed"}, {"sha": "775d755444d7d3a23ee63104e28a66c73cb08db4", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -352,7 +352,7 @@ pub struct TypeckResults<'tcx> {\n     pat_binding_modes: ItemLocalMap<BindingMode>,\n \n     /// Stores the types which were implicitly dereferenced in pattern binding modes\n-    /// for later usage in HAIR lowering. For example,\n+    /// for later usage in THIR lowering. For example,\n     ///\n     /// ```\n     /// match &&Some(5i32) {\n@@ -1831,7 +1831,7 @@ pub mod tls {\n }\n \n macro_rules! sty_debug_print {\n-    ($ctxt: expr, $($variant: ident),*) => {{\n+    ($fmt: expr, $ctxt: expr, $($variant: ident),*) => {{\n         // Curious inner module to allow variant names to be used as\n         // variable names.\n         #[allow(non_snake_case)]\n@@ -1848,7 +1848,7 @@ macro_rules! sty_debug_print {\n                 all_infer: usize,\n             }\n \n-            pub fn go(tcx: TyCtxt<'_>) {\n+            pub fn go(fmt: &mut std::fmt::Formatter<'_>, tcx: TyCtxt<'_>) -> std::fmt::Result {\n                 let mut total = DebugStat {\n                     total: 0,\n                     lt_infer: 0,\n@@ -1878,18 +1878,18 @@ macro_rules! sty_debug_print {\n                     if ct { total.ct_infer += 1; variant.ct_infer += 1 }\n                     if lt && ty && ct { total.all_infer += 1; variant.all_infer += 1 }\n                 }\n-                println!(\"Ty interner             total           ty lt ct all\");\n-                $(println!(\"    {:18}: {uses:6} {usespc:4.1}%, \\\n+                writeln!(fmt, \"Ty interner             total           ty lt ct all\")?;\n+                $(writeln!(fmt, \"    {:18}: {uses:6} {usespc:4.1}%, \\\n                             {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n                     stringify!($variant),\n                     uses = $variant.total,\n                     usespc = $variant.total as f64 * 100.0 / total.total as f64,\n                     ty = $variant.ty_infer as f64 * 100.0  / total.total as f64,\n                     lt = $variant.lt_infer as f64 * 100.0  / total.total as f64,\n                     ct = $variant.ct_infer as f64 * 100.0  / total.total as f64,\n-                    all = $variant.all_infer as f64 * 100.0  / total.total as f64);\n+                    all = $variant.all_infer as f64 * 100.0  / total.total as f64)?;\n                 )*\n-                println!(\"                  total {uses:6}        \\\n+                writeln!(fmt, \"                  total {uses:6}        \\\n                           {ty:4.1}% {lt:5.1}% {ct:4.1}% {all:4.1}%\",\n                     uses = total.total,\n                     ty = total.ty_infer as f64 * 100.0  / total.total as f64,\n@@ -1899,41 +1899,56 @@ macro_rules! sty_debug_print {\n             }\n         }\n \n-        inner::go($ctxt)\n+        inner::go($fmt, $ctxt)\n     }}\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn print_debug_stats(self) {\n-        sty_debug_print!(\n-            self,\n-            Adt,\n-            Array,\n-            Slice,\n-            RawPtr,\n-            Ref,\n-            FnDef,\n-            FnPtr,\n-            Placeholder,\n-            Generator,\n-            GeneratorWitness,\n-            Dynamic,\n-            Closure,\n-            Tuple,\n-            Bound,\n-            Param,\n-            Infer,\n-            Projection,\n-            Opaque,\n-            Foreign\n-        );\n-\n-        println!(\"InternalSubsts interner: #{}\", self.interners.substs.len());\n-        println!(\"Region interner: #{}\", self.interners.region.len());\n-        println!(\"Stability interner: #{}\", self.stability_interner.len());\n-        println!(\"Const Stability interner: #{}\", self.const_stability_interner.len());\n-        println!(\"Allocation interner: #{}\", self.allocation_interner.len());\n-        println!(\"Layout interner: #{}\", self.layout_interner.len());\n+    pub fn debug_stats(self) -> impl std::fmt::Debug + 'tcx {\n+        struct DebugStats<'tcx>(TyCtxt<'tcx>);\n+\n+        impl std::fmt::Debug for DebugStats<'tcx> {\n+            fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                sty_debug_print!(\n+                    fmt,\n+                    self.0,\n+                    Adt,\n+                    Array,\n+                    Slice,\n+                    RawPtr,\n+                    Ref,\n+                    FnDef,\n+                    FnPtr,\n+                    Placeholder,\n+                    Generator,\n+                    GeneratorWitness,\n+                    Dynamic,\n+                    Closure,\n+                    Tuple,\n+                    Bound,\n+                    Param,\n+                    Infer,\n+                    Projection,\n+                    Opaque,\n+                    Foreign\n+                )?;\n+\n+                writeln!(fmt, \"InternalSubsts interner: #{}\", self.0.interners.substs.len())?;\n+                writeln!(fmt, \"Region interner: #{}\", self.0.interners.region.len())?;\n+                writeln!(fmt, \"Stability interner: #{}\", self.0.stability_interner.len())?;\n+                writeln!(\n+                    fmt,\n+                    \"Const Stability interner: #{}\",\n+                    self.0.const_stability_interner.len()\n+                )?;\n+                writeln!(fmt, \"Allocation interner: #{}\", self.0.allocation_interner.len())?;\n+                writeln!(fmt, \"Layout interner: #{}\", self.0.layout_interner.len())?;\n+\n+                Ok(())\n+            }\n+        }\n+\n+        DebugStats(self)\n     }\n }\n "}, {"sha": "143d3c4e1e92bcb2b8c438257d2868272c70c640", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1903,7 +1903,7 @@ impl<'tcx> LayoutOf for LayoutCx<'tcx, TyCtxt<'tcx>> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        let param_env = self.param_env.with_reveal_all();\n+        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n         let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n         let layout = self.tcx.layout_raw(param_env.and(ty))?;\n         let layout = TyAndLayout { ty, layout };\n@@ -1927,7 +1927,7 @@ impl LayoutOf for LayoutCx<'tcx, ty::query::TyCtxtAt<'tcx>> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyAndLayout {\n-        let param_env = self.param_env.with_reveal_all();\n+        let param_env = self.param_env.with_reveal_all_normalized(*self.tcx);\n         let ty = self.tcx.normalize_erasing_regions(param_env, ty);\n         let layout = self.tcx.layout_raw(param_env.and(ty))?;\n         let layout = TyAndLayout { ty, layout };"}, {"sha": "bd45f866abc8bbbdacd7f717ea086bcf2b391d0d", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,5 +1,5 @@\n // ignore-tidy-filelength\n-pub use self::fold::{TypeFoldable, TypeVisitor};\n+pub use self::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n pub use self::AssocItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n@@ -1874,9 +1874,15 @@ impl<'tcx> ParamEnv<'tcx> {\n     /// the desired behavior during codegen and certain other special\n     /// contexts; normally though we want to use `Reveal::UserFacing`,\n     /// which is the default.\n-    pub fn with_reveal_all(mut self) -> Self {\n-        self.packed_data |= 1;\n-        self\n+    /// All opaque types in the caller_bounds of the `ParamEnv`\n+    /// will be normalized to their underlying types.\n+    /// See PR #65989 and issue #65918 for more details\n+    pub fn with_reveal_all_normalized(self, tcx: TyCtxt<'tcx>) -> Self {\n+        if self.packed_data & 1 == 1 {\n+            return self;\n+        }\n+\n+        ParamEnv::new(tcx.normalize_opaque_types(self.caller_bounds()), Reveal::All, self.def_id)\n     }\n \n     /// Returns this same environment but with no caller bounds.\n@@ -2046,7 +2052,6 @@ impl<'tcx> VariantDef {\n     /// If someone speeds up attribute loading to not be a performance concern, they can\n     /// remove this hack and use the constructor `DefId` everywhere.\n     pub fn new(\n-        tcx: TyCtxt<'tcx>,\n         ident: Ident,\n         variant_did: Option<DefId>,\n         ctor_def_id: Option<DefId>,\n@@ -2056,6 +2061,7 @@ impl<'tcx> VariantDef {\n         adt_kind: AdtKind,\n         parent_did: DefId,\n         recovered: bool,\n+        is_field_list_non_exhaustive: bool,\n     ) -> Self {\n         debug!(\n             \"VariantDef::new(ident = {:?}, variant_did = {:?}, ctor_def_id = {:?}, discr = {:?},\n@@ -2064,14 +2070,8 @@ impl<'tcx> VariantDef {\n         );\n \n         let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n-        if adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, sym::non_exhaustive) {\n-            debug!(\"found non-exhaustive field list for {:?}\", parent_did);\n-            flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n-        } else if let Some(variant_did) = variant_did {\n-            if tcx.has_attr(variant_did, sym::non_exhaustive) {\n-                debug!(\"found non-exhaustive field list for {:?}\", variant_did);\n-                flags = flags | VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n-            }\n+        if is_field_list_non_exhaustive {\n+            flags |= VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE;\n         }\n \n         VariantDef {\n@@ -3122,6 +3122,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n     layout::provide(providers);\n+    util::provide(providers);\n     super::util::bug::provide(providers);\n     *providers = ty::query::Providers {\n         trait_impls_of: trait_def::trait_impls_of_provider,"}, {"sha": "3f7a20bba2b9add597b91cf99d5dfea170c82f3e", "filename": "src/librustc_middle/ty/query/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -270,6 +270,17 @@ impl<'tcx> Key for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for &'tcx ty::List<ty::Predicate<'tcx>> {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        LOCAL_CRATE\n+    }\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for ty::ParamEnv<'tcx> {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "b39c0b5190a6d951c59cae210ccbd49dcee06544", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,10 +1,10 @@\n-use crate::dep_graph::{self, DepNode, DepNodeParams};\n+use crate::dep_graph::{self, DepKind, DepNode, DepNodeParams};\n use crate::hir::exports::Export;\n use crate::hir::map;\n use crate::infer::canonical::{self, Canonical};\n use crate::lint::LintLevelMap;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n-use crate::middle::cstore::{CrateSource, DepKind};\n+use crate::middle::cstore::{CrateDepKind, CrateSource};\n use crate::middle::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n use crate::middle::lib_features::LibFeatures;\n@@ -161,7 +161,7 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     // hit the cache instead of having to go through `force_from_dep_node`.\n     // This assertion makes sure, we actually keep applying the solution above.\n     debug_assert!(\n-        dep_node.kind != crate::dep_graph::DepKind::codegen_unit,\n+        dep_node.kind != DepKind::codegen_unit,\n         \"calling force_from_dep_node() on DepKind::codegen_unit\"\n     );\n \n@@ -172,14 +172,14 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already.\n-        crate::dep_graph::DepKind::CrateMetadata |\n+        DepKind::CrateMetadata |\n \n         // These are anonymous nodes.\n-        crate::dep_graph::DepKind::TraitSelect |\n+        DepKind::TraitSelect |\n \n         // We don't have enough information to reconstruct the query key of\n         // these.\n-        crate::dep_graph::DepKind::CompileCodegenUnit => {\n+        DepKind::CompileCodegenUnit => {\n             bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n         }\n     );"}, {"sha": "310ab4f7235ebf8e57fc4d5b8603619b62e6c81a", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -202,6 +202,16 @@ pub enum TyKind<'tcx> {\n     Error(DelaySpanBugEmitted),\n }\n \n+impl TyKind<'tcx> {\n+    #[inline]\n+    pub fn is_primitive(&self) -> bool {\n+        match self {\n+            Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n /// except through `tcx.err*()`.\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n@@ -1766,10 +1776,7 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_primitive(&self) -> bool {\n-        match self.kind {\n-            Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n-            _ => false,\n-        }\n+        self.kind.is_primitive()\n     }\n \n     #[inline]"}, {"sha": "07221082048fbc3603a8995e98d7f670e3e374e1", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 90, "deletions": 66, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -3,11 +3,12 @@\n use crate::ich::NodeIdHashingMode;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir::interpret::{sign_extend, truncate};\n+use crate::ty::fold::TypeFolder;\n use crate::ty::layout::IntegerExt;\n use crate::ty::query::TyCtxtAt;\n use crate::ty::subst::{GenericArgKind, InternalSubsts, Subst, SubstsRef};\n use crate::ty::TyKind::*;\n-use crate::ty::{self, DefIdTree, GenericParamDefKind, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, DefIdTree, GenericParamDefKind, List, Ty, TyCtxt, TypeFoldable};\n use rustc_apfloat::Float as _;\n use rustc_ast::ast;\n use rustc_attr::{self as attr, SignedInt, UnsignedInt};\n@@ -557,82 +558,84 @@ impl<'tcx> TyCtxt<'tcx> {\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> Result<Ty<'tcx>, Ty<'tcx>> {\n-        use crate::ty::fold::TypeFolder;\n-\n-        struct OpaqueTypeExpander<'tcx> {\n-            // Contains the DefIds of the opaque types that are currently being\n-            // expanded. When we expand an opaque type we insert the DefId of\n-            // that type, and when we finish expanding that type we remove the\n-            // its DefId.\n-            seen_opaque_tys: FxHashSet<DefId>,\n-            // Cache of all expansions we've seen so far. This is a critical\n-            // optimization for some large types produced by async fn trees.\n-            expanded_cache: FxHashMap<(DefId, SubstsRef<'tcx>), Ty<'tcx>>,\n-            primary_def_id: DefId,\n-            found_recursion: bool,\n-            tcx: TyCtxt<'tcx>,\n-        }\n-\n-        impl<'tcx> OpaqueTypeExpander<'tcx> {\n-            fn expand_opaque_ty(\n-                &mut self,\n-                def_id: DefId,\n-                substs: SubstsRef<'tcx>,\n-            ) -> Option<Ty<'tcx>> {\n-                if self.found_recursion {\n-                    return None;\n-                }\n-                let substs = substs.fold_with(self);\n-                if self.seen_opaque_tys.insert(def_id) {\n-                    let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n-                        Some(expanded_ty) => expanded_ty,\n-                        None => {\n-                            let generic_ty = self.tcx.type_of(def_id);\n-                            let concrete_ty = generic_ty.subst(self.tcx, substs);\n-                            let expanded_ty = self.fold_ty(concrete_ty);\n-                            self.expanded_cache.insert((def_id, substs), expanded_ty);\n-                            expanded_ty\n-                        }\n-                    };\n-                    self.seen_opaque_tys.remove(&def_id);\n-                    Some(expanded_ty)\n-                } else {\n-                    // If another opaque type that we contain is recursive, then it\n-                    // will report the error, so we don't have to.\n-                    self.found_recursion = def_id == self.primary_def_id;\n-                    None\n-                }\n-            }\n-        }\n-\n-        impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n-            fn tcx(&self) -> TyCtxt<'tcx> {\n-                self.tcx\n-            }\n-\n-            fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::Opaque(def_id, substs) = t.kind {\n-                    self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n-                } else if t.has_opaque_types() {\n-                    t.super_fold_with(self)\n-                } else {\n-                    t\n-                }\n-            }\n-        }\n-\n         let mut visitor = OpaqueTypeExpander {\n             seen_opaque_tys: FxHashSet::default(),\n             expanded_cache: FxHashMap::default(),\n-            primary_def_id: def_id,\n+            primary_def_id: Some(def_id),\n             found_recursion: false,\n+            check_recursion: true,\n             tcx: self,\n         };\n+\n         let expanded_type = visitor.expand_opaque_ty(def_id, substs).unwrap();\n         if visitor.found_recursion { Err(expanded_type) } else { Ok(expanded_type) }\n     }\n }\n \n+struct OpaqueTypeExpander<'tcx> {\n+    // Contains the DefIds of the opaque types that are currently being\n+    // expanded. When we expand an opaque type we insert the DefId of\n+    // that type, and when we finish expanding that type we remove the\n+    // its DefId.\n+    seen_opaque_tys: FxHashSet<DefId>,\n+    // Cache of all expansions we've seen so far. This is a critical\n+    // optimization for some large types produced by async fn trees.\n+    expanded_cache: FxHashMap<(DefId, SubstsRef<'tcx>), Ty<'tcx>>,\n+    primary_def_id: Option<DefId>,\n+    found_recursion: bool,\n+    /// Whether or not to check for recursive opaque types.\n+    /// This is `true` when we're explicitly checking for opaque type\n+    /// recursion, and 'false' otherwise to avoid unnecessary work.\n+    check_recursion: bool,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> OpaqueTypeExpander<'tcx> {\n+    fn expand_opaque_ty(&mut self, def_id: DefId, substs: SubstsRef<'tcx>) -> Option<Ty<'tcx>> {\n+        if self.found_recursion {\n+            return None;\n+        }\n+        let substs = substs.fold_with(self);\n+        if !self.check_recursion || self.seen_opaque_tys.insert(def_id) {\n+            let expanded_ty = match self.expanded_cache.get(&(def_id, substs)) {\n+                Some(expanded_ty) => expanded_ty,\n+                None => {\n+                    let generic_ty = self.tcx.type_of(def_id);\n+                    let concrete_ty = generic_ty.subst(self.tcx, substs);\n+                    let expanded_ty = self.fold_ty(concrete_ty);\n+                    self.expanded_cache.insert((def_id, substs), expanded_ty);\n+                    expanded_ty\n+                }\n+            };\n+            if self.check_recursion {\n+                self.seen_opaque_tys.remove(&def_id);\n+            }\n+            Some(expanded_ty)\n+        } else {\n+            // If another opaque type that we contain is recursive, then it\n+            // will report the error, so we don't have to.\n+            self.found_recursion = def_id == *self.primary_def_id.as_ref().unwrap();\n+            None\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for OpaqueTypeExpander<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if let ty::Opaque(def_id, substs) = t.kind {\n+            self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n+        } else if t.has_opaque_types() {\n+            t.super_fold_with(self)\n+        } else {\n+            t\n+        }\n+    }\n+}\n+\n impl<'tcx> ty::TyS<'tcx> {\n     /// Returns the maximum value for the given numeric type (including `char`s)\n     /// or returns `None` if the type is not numeric.\n@@ -1142,3 +1145,24 @@ pub fn needs_drop_components(\n \n #[derive(Copy, Clone, Debug, HashStable, RustcEncodable, RustcDecodable)]\n pub struct AlwaysRequiresDrop;\n+\n+/// Normalizes all opaque types in the given value, replacing them\n+/// with their underlying types.\n+pub fn normalize_opaque_types(\n+    tcx: TyCtxt<'tcx>,\n+    val: &'tcx List<ty::Predicate<'tcx>>,\n+) -> &'tcx List<ty::Predicate<'tcx>> {\n+    let mut visitor = OpaqueTypeExpander {\n+        seen_opaque_tys: FxHashSet::default(),\n+        expanded_cache: FxHashMap::default(),\n+        primary_def_id: None,\n+        found_recursion: false,\n+        check_recursion: false,\n+        tcx,\n+    };\n+    val.fold_with(&mut visitor)\n+}\n+\n+pub fn provide(providers: &mut ty::query::Providers) {\n+    *providers = ty::query::Providers { normalize_opaque_types, ..*providers }\n+}"}, {"sha": "f05c47e0ed62655656c4f330ca095cbc49e9d793", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -13,7 +13,7 @@ doctest = false\n either = \"1.5.0\"\n rustc_graphviz = { path = \"../librustc_graphviz\" }\n itertools = \"0.8\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n log_settings = \"0.1.1\"\n polonius-engine = \"0.12.0\"\n rustc_middle = { path = \"../librustc_middle\" }"}, {"sha": "0dac8b64910114fb58ddebb45323fc301061eda4", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n         self.copy_op(place.into(), dest)?;\n \n         self.return_to_block(ret.map(|r| r.1))?;\n-        self.dump_place(*dest);\n+        trace!(\"{:?}\", self.dump_place(*dest));\n         Ok(true)\n     }\n "}, {"sha": "78f149f6451e6f1b2b27d46d780977aff4c31e38", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -8,11 +8,14 @@ use rustc_middle::mir::interpret::{InterpResult, PointerArithmetic, Scalar};\n use rustc_middle::mir::CastKind;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::layout::{IntegerExt, TyAndLayout};\n-use rustc_middle::ty::{self, Ty, TypeAndMut, TypeFoldable};\n+use rustc_middle::ty::{self, Ty, TypeAndMut};\n use rustc_span::symbol::sym;\n use rustc_target::abi::{Integer, LayoutOf, Variants};\n \n-use super::{truncate, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy, PlaceTy};\n+use super::{\n+    truncate, util::ensure_monomorphic_enough, FnVal, ImmTy, Immediate, InterpCx, Machine, OpTy,\n+    PlaceTy,\n+};\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn cast(\n@@ -47,9 +50,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 match src.layout.ty.kind {\n                     ty::FnDef(def_id, substs) => {\n                         // All reifications must be monomorphic, bail out otherwise.\n-                        if src.layout.ty.needs_subst() {\n-                            throw_inval!(TooGeneric);\n-                        }\n+                        ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n \n                         if self.tcx.has_attr(def_id, sym::rustc_args_required_const) {\n                             span_bug!(\n@@ -89,9 +90,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 match src.layout.ty.kind {\n                     ty::Closure(def_id, substs) => {\n                         // All reifications must be monomorphic, bail out otherwise.\n-                        if src.layout.ty.needs_subst() {\n-                            throw_inval!(TooGeneric);\n-                        }\n+                        ensure_monomorphic_enough(*self.tcx, src.layout.ty)?;\n \n                         let instance = ty::Instance::resolve_closure(\n                             *self.tcx,"}, {"sha": "1e9be097815080b2bcce1f38ca566453e95a55bc", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,5 +1,4 @@\n use std::cell::Cell;\n-use std::fmt::Write;\n use std::mem;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -719,6 +718,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         );\n \n+        if unwinding && self.frame_idx() == 0 {\n+            throw_ub_format!(\"unwinding past the topmost frame of the stack\");\n+        }\n+\n         ::log_settings::settings().indentation -= 1;\n         let frame =\n             self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n@@ -728,7 +731,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if let Some(return_place) = frame.return_place {\n                 let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n                 self.copy_op_transmute(op, return_place)?;\n-                self.dump_place(*return_place);\n+                trace!(\"{:?}\", self.dump_place(*return_place));\n             } else {\n                 throw_ub!(Unreachable);\n             }\n@@ -819,13 +822,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx> {\n         // FIXME: should we tell the user that there was a local which was never written to?\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n-            trace!(\"deallocating local\");\n             // All locals have a backing allocation, even if the allocation is empty\n             // due to the local having ZST type.\n             let ptr = ptr.assert_ptr();\n-            if log_enabled!(::log::Level::Trace) {\n-                self.memory.dump_alloc(ptr.alloc_id);\n-            }\n+            trace!(\"deallocating local: {:?}\", self.memory.dump_alloc(ptr.alloc_id));\n             self.memory.deallocate_local(ptr)?;\n         };\n         Ok(())\n@@ -881,47 +881,77 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.raw_const_to_mplace(val)\n     }\n \n-    pub fn dump_place(&self, place: Place<M::PointerTag>) {\n-        // Debug output\n-        if !log_enabled!(::log::Level::Trace) {\n-            return;\n+    #[must_use]\n+    pub fn dump_place(&'a self, place: Place<M::PointerTag>) -> PlacePrinter<'a, 'mir, 'tcx, M> {\n+        PlacePrinter { ecx: self, place }\n+    }\n+\n+    #[must_use]\n+    pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n+        let mut frames = Vec::new();\n+        for frame in self.stack().iter().rev() {\n+            let source_info = frame.current_source_info();\n+            let lint_root = source_info.and_then(|source_info| {\n+                match &frame.body.source_scopes[source_info.scope].local_data {\n+                    mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n+                    mir::ClearCrossCrate::Clear => None,\n+                }\n+            });\n+            let span = source_info.map_or(DUMMY_SP, |source_info| source_info.span);\n+\n+            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n         }\n-        match place {\n+        trace!(\"generate stacktrace: {:#?}\", frames);\n+        frames\n+    }\n+}\n+\n+#[doc(hidden)]\n+/// Helper struct for the `dump_place` function.\n+pub struct PlacePrinter<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n+    ecx: &'a InterpCx<'mir, 'tcx, M>,\n+    place: Place<M::PointerTag>,\n+}\n+\n+impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n+    for PlacePrinter<'a, 'mir, 'tcx, M>\n+{\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self.place {\n             Place::Local { frame, local } => {\n                 let mut allocs = Vec::new();\n-                let mut msg = format!(\"{:?}\", local);\n-                if frame != self.frame_idx() {\n-                    write!(msg, \" ({} frames up)\", self.frame_idx() - frame).unwrap();\n+                write!(fmt, \"{:?}\", local)?;\n+                if frame != self.ecx.frame_idx() {\n+                    write!(fmt, \" ({} frames up)\", self.ecx.frame_idx() - frame)?;\n                 }\n-                write!(msg, \":\").unwrap();\n+                write!(fmt, \":\")?;\n \n-                match self.stack()[frame].locals[local].value {\n-                    LocalValue::Dead => write!(msg, \" is dead\").unwrap(),\n-                    LocalValue::Uninitialized => write!(msg, \" is uninitialized\").unwrap(),\n+                match self.ecx.stack()[frame].locals[local].value {\n+                    LocalValue::Dead => write!(fmt, \" is dead\")?,\n+                    LocalValue::Uninitialized => write!(fmt, \" is uninitialized\")?,\n                     LocalValue::Live(Operand::Indirect(mplace)) => match mplace.ptr {\n                         Scalar::Ptr(ptr) => {\n                             write!(\n-                                msg,\n+                                fmt,\n                                 \" by align({}){} ref:\",\n                                 mplace.align.bytes(),\n                                 match mplace.meta {\n                                     MemPlaceMeta::Meta(meta) => format!(\" meta({:?})\", meta),\n                                     MemPlaceMeta::Poison | MemPlaceMeta::None => String::new(),\n                                 }\n-                            )\n-                            .unwrap();\n+                            )?;\n                             allocs.push(ptr.alloc_id);\n                         }\n-                        ptr => write!(msg, \" by integral ref: {:?}\", ptr).unwrap(),\n+                        ptr => write!(fmt, \" by integral ref: {:?}\", ptr)?,\n                     },\n                     LocalValue::Live(Operand::Immediate(Immediate::Scalar(val))) => {\n-                        write!(msg, \" {:?}\", val).unwrap();\n+                        write!(fmt, \" {:?}\", val)?;\n                         if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n                     LocalValue::Live(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n-                        write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n+                        write!(fmt, \" ({:?}, {:?})\", val1, val2)?;\n                         if let ScalarMaybeUninit::Scalar(Scalar::Ptr(ptr)) = val1 {\n                             allocs.push(ptr.alloc_id);\n                         }\n@@ -931,36 +961,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     }\n                 }\n \n-                trace!(\"{}\", msg);\n-                self.memory.dump_allocs(allocs);\n+                write!(fmt, \": {:?}\", self.ecx.memory.dump_allocs(allocs))\n             }\n             Place::Ptr(mplace) => match mplace.ptr {\n-                Scalar::Ptr(ptr) => {\n-                    trace!(\"by align({}) ref:\", mplace.align.bytes());\n-                    self.memory.dump_alloc(ptr.alloc_id);\n-                }\n-                ptr => trace!(\" integral by ref: {:?}\", ptr),\n+                Scalar::Ptr(ptr) => write!(\n+                    fmt,\n+                    \"by align({}) ref: {:?}\",\n+                    mplace.align.bytes(),\n+                    self.ecx.memory.dump_alloc(ptr.alloc_id)\n+                ),\n+                ptr => write!(fmt, \" integral by ref: {:?}\", ptr),\n             },\n         }\n     }\n-\n-    pub fn generate_stacktrace(&self) -> Vec<FrameInfo<'tcx>> {\n-        let mut frames = Vec::new();\n-        for frame in self.stack().iter().rev() {\n-            let source_info = frame.current_source_info();\n-            let lint_root = source_info.and_then(|source_info| {\n-                match &frame.body.source_scopes[source_info.scope].local_data {\n-                    mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n-                    mir::ClearCrossCrate::Clear => None,\n-                }\n-            });\n-            let span = source_info.map_or(DUMMY_SP, |source_info| source_info.span);\n-\n-            frames.push(FrameInfo { span, instance: frame.instance, lint_root });\n-        }\n-        trace!(\"generate stacktrace: {:#?}\", frames);\n-        frames\n-    }\n }\n \n impl<'ctx, 'mir, 'tcx, Tag, Extra> HashStable<StableHashingContext<'ctx>>"}, {"sha": "b45045716d18c209b32ad2b9ef4245d71d86279b", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,11 +12,13 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{Ty, TyCtxt, TypeFoldable};\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{Abi, LayoutOf as _, Primitive, Size};\n \n-use super::{CheckInAllocMsg, ImmTy, InterpCx, Machine, OpTy, PlaceTy};\n+use super::{\n+    util::ensure_monomorphic_enough, CheckInAllocMsg, ImmTy, InterpCx, Machine, OpTy, PlaceTy,\n+};\n \n mod caller_location;\n mod type_name;\n@@ -54,9 +56,7 @@ crate fn eval_nullary_intrinsic<'tcx>(\n     let name = tcx.item_name(def_id);\n     Ok(match name {\n         sym::type_name => {\n-            if tp_ty.needs_subst() {\n-                throw_inval!(TooGeneric);\n-            }\n+            ensure_monomorphic_enough(tcx, tp_ty)?;\n             let alloc = type_name::alloc_type_name(tcx, tp_ty);\n             ConstValue::Slice { data: alloc, start: 0, end: alloc.len() }\n         }\n@@ -72,9 +72,7 @@ crate fn eval_nullary_intrinsic<'tcx>(\n             ConstValue::from_machine_usize(n, &tcx)\n         }\n         sym::type_id => {\n-            if tp_ty.needs_subst() {\n-                throw_inval!(TooGeneric);\n-            }\n+            ensure_monomorphic_enough(tcx, tp_ty)?;\n             ConstValue::from_u64(tcx.type_id_hash(tp_ty))\n         }\n         sym::variant_count => {\n@@ -120,6 +118,21 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.write_scalar(location.ptr, dest)?;\n             }\n \n+            sym::min_align_of_val | sym::size_of_val => {\n+                let place = self.deref_operand(args[0])?;\n+                let (size, align) = self\n+                    .size_and_align_of(place.meta, place.layout)?\n+                    .ok_or_else(|| err_unsup_format!(\"`extern type` does not have known layout\"))?;\n+\n+                let result = match intrinsic_name {\n+                    sym::min_align_of_val => align.bytes(),\n+                    sym::size_of_val => size.bytes(),\n+                    _ => bug!(),\n+                };\n+\n+                self.write_scalar(Scalar::from_machine_usize(result, self), dest)?;\n+            }\n+\n             sym::min_align_of\n             | sym::pref_align_of\n             | sym::needs_drop\n@@ -430,7 +443,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => return Ok(false),\n         }\n \n-        self.dump_place(*dest);\n+        trace!(\"{:?}\", self.dump_place(*dest));\n         self.go_to_block(ret);\n         Ok(true)\n     }"}, {"sha": "a9e6e324eb23a7a26b126741aec7db673f7c6bd0", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 85, "deletions": 61, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -667,69 +667,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    /// Print an allocation and all allocations it points to, recursively.\n-    /// This prints directly to stderr, ignoring RUSTC_LOG! It is up to the caller to\n-    /// control for this.\n-    pub fn dump_alloc(&self, id: AllocId) {\n-        self.dump_allocs(vec![id]);\n+    /// Create a lazy debug printer that prints the given allocation and all allocations it points\n+    /// to, recursively.\n+    #[must_use]\n+    pub fn dump_alloc<'a>(&'a self, id: AllocId) -> DumpAllocs<'a, 'mir, 'tcx, M> {\n+        self.dump_allocs(vec![id])\n     }\n \n-    /// Print a list of allocations and all allocations they point to, recursively.\n-    /// This prints directly to stderr, ignoring RUSTC_LOG! It is up to the caller to\n-    /// control for this.\n-    pub fn dump_allocs(&self, mut allocs: Vec<AllocId>) {\n-        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n-        fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n-            tcx: TyCtxt<'tcx>,\n-            allocs_to_print: &mut VecDeque<AllocId>,\n-            alloc: &Allocation<Tag, Extra>,\n-        ) {\n-            for &(_, target_id) in alloc.relocations().values() {\n-                allocs_to_print.push_back(target_id);\n-            }\n-            pretty::write_allocation(tcx, alloc, &mut std::io::stderr()).unwrap();\n-        }\n-\n+    /// Create a lazy debug printer for a list of allocations and all allocations they point to,\n+    /// recursively.\n+    #[must_use]\n+    pub fn dump_allocs<'a>(&'a self, mut allocs: Vec<AllocId>) -> DumpAllocs<'a, 'mir, 'tcx, M> {\n         allocs.sort();\n         allocs.dedup();\n-        let mut allocs_to_print = VecDeque::from(allocs);\n-        // `allocs_printed` contains all allocations that we have already printed.\n-        let mut allocs_printed = FxHashSet::default();\n-\n-        while let Some(id) = allocs_to_print.pop_front() {\n-            if !allocs_printed.insert(id) {\n-                // Already printed, so skip this.\n-                continue;\n-            }\n-\n-            eprint!(\"{}\", id);\n-            match self.alloc_map.get(id) {\n-                Some(&(kind, ref alloc)) => {\n-                    // normal alloc\n-                    eprint!(\" ({}, \", kind);\n-                    write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n-                }\n-                None => {\n-                    // global alloc\n-                    match self.tcx.get_global_alloc(id) {\n-                        Some(GlobalAlloc::Memory(alloc)) => {\n-                            eprint!(\" (unchanged global, \");\n-                            write_allocation_track_relocs(self.tcx, &mut allocs_to_print, alloc);\n-                        }\n-                        Some(GlobalAlloc::Function(func)) => {\n-                            eprint!(\" (fn: {})\", func);\n-                        }\n-                        Some(GlobalAlloc::Static(did)) => {\n-                            eprint!(\" (static: {})\", self.tcx.def_path_str(did));\n-                        }\n-                        None => {\n-                            eprint!(\" (deallocated)\");\n-                        }\n-                    }\n-                }\n-            }\n-            eprintln!();\n-        }\n+        DumpAllocs { mem: self, allocs }\n     }\n \n     /// Print leaked memory. Allocations reachable from `static_roots` or a `Global` allocation\n@@ -760,8 +711,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         });\n         let n = leaks.len();\n         if n > 0 {\n-            eprintln!(\"The following memory was leaked:\");\n-            self.dump_allocs(leaks);\n+            eprintln!(\"The following memory was leaked: {:?}\", self.dump_allocs(leaks));\n         }\n         n\n     }\n@@ -772,6 +722,80 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n }\n \n+#[doc(hidden)]\n+/// There's no way to use this directly, it's just a helper struct for the `dump_alloc(s)` methods.\n+pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n+    mem: &'a Memory<'mir, 'tcx, M>,\n+    allocs: Vec<AllocId>,\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a, 'mir, 'tcx, M> {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        // Cannot be a closure because it is generic in `Tag`, `Extra`.\n+        fn write_allocation_track_relocs<'tcx, Tag: Copy + fmt::Debug, Extra>(\n+            fmt: &mut std::fmt::Formatter<'_>,\n+            tcx: TyCtxt<'tcx>,\n+            allocs_to_print: &mut VecDeque<AllocId>,\n+            alloc: &Allocation<Tag, Extra>,\n+        ) -> std::fmt::Result {\n+            for &(_, target_id) in alloc.relocations().values() {\n+                allocs_to_print.push_back(target_id);\n+            }\n+            write!(fmt, \"{}\", pretty::display_allocation(tcx, alloc))\n+        }\n+\n+        let mut allocs_to_print: VecDeque<_> = self.allocs.iter().copied().collect();\n+        // `allocs_printed` contains all allocations that we have already printed.\n+        let mut allocs_printed = FxHashSet::default();\n+\n+        while let Some(id) = allocs_to_print.pop_front() {\n+            if !allocs_printed.insert(id) {\n+                // Already printed, so skip this.\n+                continue;\n+            }\n+\n+            write!(fmt, \"{}\", id)?;\n+            match self.mem.alloc_map.get(id) {\n+                Some(&(kind, ref alloc)) => {\n+                    // normal alloc\n+                    write!(fmt, \" ({}, \", kind)?;\n+                    write_allocation_track_relocs(\n+                        &mut *fmt,\n+                        self.mem.tcx,\n+                        &mut allocs_to_print,\n+                        alloc,\n+                    )?;\n+                }\n+                None => {\n+                    // global alloc\n+                    match self.mem.tcx.get_global_alloc(id) {\n+                        Some(GlobalAlloc::Memory(alloc)) => {\n+                            write!(fmt, \" (unchanged global, \")?;\n+                            write_allocation_track_relocs(\n+                                &mut *fmt,\n+                                self.mem.tcx,\n+                                &mut allocs_to_print,\n+                                alloc,\n+                            )?;\n+                        }\n+                        Some(GlobalAlloc::Function(func)) => {\n+                            write!(fmt, \" (fn: {})\", func)?;\n+                        }\n+                        Some(GlobalAlloc::Static(did)) => {\n+                            write!(fmt, \" (static: {})\", self.mem.tcx.def_path_str(did))?;\n+                        }\n+                        None => {\n+                            write!(fmt, \" (deallocated)\")?;\n+                        }\n+                    }\n+                }\n+            }\n+            writeln!(fmt)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n /// Reading and writing.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Reads the given number of bytes from memory. Returns them as a slice."}, {"sha": "ebb061f48518b07d5f3b1a91aad87df33d020ddf", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,6 +12,7 @@ mod place;\n mod step;\n mod terminator;\n mod traits;\n+mod util;\n mod validity;\n mod visitor;\n "}, {"sha": "15e341d9c4c01380cd6a1d6844327e630c939afb", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -648,7 +648,7 @@ where\n             place_ty = self.place_projection(place_ty, &elem)?\n         }\n \n-        self.dump_place(place_ty.place);\n+        trace!(\"{:?}\", self.dump_place(place_ty.place));\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n             *self.tcx,"}, {"sha": "fcd26c86c473d62b3ebf0e04ae276f96ac50e9c5", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -271,7 +271,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         }\n \n-        self.dump_place(*dest);\n+        trace!(\"{:?}\", self.dump_place(*dest));\n \n         Ok(())\n     }"}, {"sha": "77f4593fa162ce4a3aada3418621734cf55b77f7", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,9 +1,10 @@\n use std::convert::TryFrom;\n \n use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n-use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, Instance, Ty};\n use rustc_target::abi::{Align, LayoutOf, Size};\n \n+use super::util::ensure_monomorphic_enough;\n use super::{FnVal, InterpCx, Machine, MemoryKind};\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -23,9 +24,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n \n         // All vtables must be monomorphic, bail out otherwise.\n-        if ty.needs_subst() || poly_trait_ref.needs_subst() {\n-            throw_inval!(TooGeneric);\n-        }\n+        ensure_monomorphic_enough(*self.tcx, ty)?;\n+        ensure_monomorphic_enough(*self.tcx, poly_trait_ref)?;\n \n         if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n             // This means we guarantee that there are no duplicate vtables, we will"}, {"sha": "c0eac8a9305ee7a9a62432100af36da7f046653e", "filename": "src/librustc_mir/interpret/util.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Futil.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -0,0 +1,73 @@\n+use rustc_middle::mir::interpret::InterpResult;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n+use std::convert::TryInto;\n+\n+/// Returns `true` if a used generic parameter requires substitution.\n+crate fn ensure_monomorphic_enough<'tcx, T>(tcx: TyCtxt<'tcx>, ty: T) -> InterpResult<'tcx>\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    debug!(\"ensure_monomorphic_enough: ty={:?}\", ty);\n+    if !ty.needs_subst() {\n+        return Ok(());\n+    }\n+\n+    struct UsedParamsNeedSubstVisitor<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+    };\n+\n+    impl<'tcx> TypeVisitor<'tcx> for UsedParamsNeedSubstVisitor<'tcx> {\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+            if !c.needs_subst() {\n+                return false;\n+            }\n+\n+            match c.val {\n+                ty::ConstKind::Param(..) => true,\n+                _ => c.super_visit_with(self),\n+            }\n+        }\n+\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+            if !ty.needs_subst() {\n+                return false;\n+            }\n+\n+            match ty.kind {\n+                ty::Param(_) => true,\n+                ty::Closure(def_id, substs)\n+                | ty::Generator(def_id, substs, ..)\n+                | ty::FnDef(def_id, substs) => {\n+                    let unused_params = self.tcx.unused_generic_params(def_id);\n+                    for (index, subst) in substs.into_iter().enumerate() {\n+                        let index = index\n+                            .try_into()\n+                            .expect(\"more generic parameters than can fit into a `u32`\");\n+                        let is_used =\n+                            unused_params.contains(index).map(|unused| !unused).unwrap_or(true);\n+                        // Only recurse when generic parameters in fns, closures and generators\n+                        // are used and require substitution.\n+                        if is_used && subst.needs_subst() {\n+                            // Just in case there are closures or generators within this subst,\n+                            // recurse.\n+                            if subst.super_visit_with(self) {\n+                                // Only return when we find a parameter so the remaining substs\n+                                // are not skipped.\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                    false\n+                }\n+                _ => ty.super_visit_with(self),\n+            }\n+        }\n+    }\n+\n+    let mut vis = UsedParamsNeedSubstVisitor { tcx };\n+    if ty.visit_with(&mut vis) {\n+        throw_inval!(TooGeneric);\n+    } else {\n+        Ok(())\n+    }\n+}"}, {"sha": "6a7653b60752db1164fa40bd6f78ee33c692e501", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -193,7 +193,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n             );\n         }\n         let patch = {\n-            let param_env = tcx.param_env(def_id).with_reveal_all();\n+            let param_env = tcx.param_env_reveal_all_normalized(def_id);\n             let mut elaborator =\n                 DropShimElaborator { body: &body, patch: MirPatch::new(&body), tcx, param_env };\n             let dropee = tcx.mk_place_deref(dropee_ptr);"}, {"sha": "8e2fd709d66f0102a0b0af4c8b6712776fdfde57", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -328,7 +328,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     ) -> ConstPropagator<'mir, 'tcx> {\n         let def_id = source.def_id();\n         let substs = &InternalSubsts::identity_for_item(tcx, def_id);\n-        let param_env = tcx.param_env(def_id).with_reveal_all();\n+        let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n         let span = tcx.def_span(def_id);\n         let can_const_prop = CanConstProp::check(body);"}, {"sha": "ad49090bfc50c1dbc3b5f6e0d67294adad7d988e", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -25,7 +25,7 @@ impl<'tcx> MirPass<'tcx> for ElaborateDrops {\n         debug!(\"elaborate_drops({:?} @ {:?})\", src, body.span);\n \n         let def_id = src.def_id();\n-        let param_env = tcx.param_env(src.def_id()).with_reveal_all();\n+        let param_env = tcx.param_env_reveal_all_normalized(src.def_id());\n         let move_data = match MoveData::gather_moves(body, tcx, param_env) {\n             Ok(move_data) => move_data,\n             Err((move_data, _)) => {"}, {"sha": "92ea162e419dbb6941ffe68dc8439bac96acd8ce", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -72,7 +72,7 @@ impl Inliner<'tcx> {\n \n         let mut callsites = VecDeque::new();\n \n-        let param_env = self.tcx.param_env(self.source.def_id()).with_reveal_all();\n+        let param_env = self.tcx.param_env_reveal_all_normalized(self.source.def_id());\n \n         // Only do inlining into fn bodies.\n         let id = self.tcx.hir().as_local_hir_id(self.source.def_id().expect_local());"}, {"sha": "fe63a67fdbb34cd1041ce89ce95584d5a37a9c2f", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 111, "deletions": 85, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -7,10 +7,9 @@ use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::interpret::Scalar;\n-use rustc_middle::mir::CoverageInfo;\n use rustc_middle::mir::{\n-    self, traversal, BasicBlock, BasicBlockData, Operand, Place, SourceInfo, StatementKind,\n-    Terminator, TerminatorKind, START_BLOCK,\n+    self, traversal, BasicBlock, BasicBlockData, CoverageInfo, Operand, Place, SourceInfo,\n+    SourceScope, StatementKind, Terminator, TerminatorKind,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n@@ -41,14 +40,14 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> Coverage\n         tcx.require_lang_item(lang_items::CoverageCounterSubtractFnLangItem, None);\n \n     // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n-    // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n+    // counters, with each counter having a counter ID from `0..num_counters-1`. MIR optimization\n     // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n-    // not work; but computing the num_counters by adding `1` to the highest index (for a given\n+    // work; but computing the num_counters by adding `1` to the highest counter_id (for a given\n     // instrumented function) is valid.\n     //\n     // `num_expressions` is the number of counter expressions added to the MIR body. Both\n     // `num_counters` and `num_expressions` are used to initialize new vectors, during backend\n-    // code generate, to lookup counters and expressions by their simple u32 indexes.\n+    // code generate, to lookup counters and expressions by simple u32 indexes.\n     let mut num_counters: u32 = 0;\n     let mut num_expressions: u32 = 0;\n     for terminator in\n@@ -57,27 +56,26 @@ fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> Coverage\n         if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } = &terminator.kind {\n             match func.literal.ty.kind {\n                 FnDef(id, _) if id == count_code_region_fn => {\n-                    let index_arg =\n-                        args.get(count_code_region_args::COUNTER_INDEX).expect(\"arg found\");\n-                    let counter_index = mir::Operand::scalar_from_const(index_arg)\n+                    let counter_id_arg =\n+                        args.get(count_code_region_args::COUNTER_ID).expect(\"arg found\");\n+                    let counter_id = mir::Operand::scalar_from_const(counter_id_arg)\n                         .to_u32()\n-                        .expect(\"index arg is u32\");\n-                    num_counters = std::cmp::max(num_counters, counter_index + 1);\n+                        .expect(\"counter_id arg is u32\");\n+                    num_counters = std::cmp::max(num_counters, counter_id + 1);\n                 }\n                 FnDef(id, _)\n                     if id == coverage_counter_add_fn || id == coverage_counter_subtract_fn =>\n                 {\n-                    let index_arg = args\n-                        .get(coverage_counter_expression_args::COUNTER_EXPRESSION_INDEX)\n+                    let expression_id_arg = args\n+                        .get(coverage_counter_expression_args::EXPRESSION_ID)\n                         .expect(\"arg found\");\n-                    let translated_index = mir::Operand::scalar_from_const(index_arg)\n+                    let id_descending_from_max = mir::Operand::scalar_from_const(expression_id_arg)\n                         .to_u32()\n-                        .expect(\"index arg is u32\");\n-                    // Counter expressions start with \"translated indexes\", descending from\n-                    // `u32::MAX`, so the range of expression indexes is disjoint from the range of\n-                    // counter indexes. This way, both counters and expressions can be operands in\n-                    // other expressions.\n-                    let expression_index = u32::MAX - translated_index;\n+                        .expect(\"expression_id arg is u32\");\n+                    // Counter expressions are initially assigned IDs descending from `u32::MAX`, so\n+                    // the range of expression IDs is disjoint from the range of counter IDs. This\n+                    // way, both counters and expressions can be operands in other expressions.\n+                    let expression_index = u32::MAX - id_descending_from_max;\n                     num_expressions = std::cmp::max(num_expressions, expression_index + 1);\n                 }\n                 _ => {}\n@@ -97,12 +95,10 @@ fn call_terminators(data: &'tcx BasicBlockData<'tcx>) -> Option<&'tcx Terminator\n \n impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, src: MirSource<'tcx>, mir_body: &mut mir::Body<'tcx>) {\n-        if tcx.sess.opts.debugging_opts.instrument_coverage {\n-            // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n-            // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n-            if src.promoted.is_none() {\n-                Instrumentor::new(tcx, src, mir_body).inject_counters();\n-            }\n+        // If the InstrumentCoverage pass is called on promoted MIRs, skip them.\n+        // See: https://github.com/rust-lang/rust/pull/73011#discussion_r438317601\n+        if src.promoted.is_none() {\n+            Instrumentor::new(tcx, src, mir_body).inject_counters();\n         }\n     }\n }\n@@ -113,6 +109,12 @@ enum Op {\n     Subtract,\n }\n \n+struct InjectedCall<'tcx> {\n+    func: Operand<'tcx>,\n+    args: Vec<Operand<'tcx>>,\n+    inject_at: Span,\n+}\n+\n struct Instrumentor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     mir_def_id: DefId,\n@@ -147,11 +149,8 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     }\n \n     /// Expression IDs start from u32::MAX and go down because a CounterExpression can reference\n-    /// (add or subtract counts) of both Counter regions and CounterExpression regions. The indexes\n-    /// of each type of region must be contiguous, but also must be unique across both sets.\n-    /// The expression IDs are eventually translated into region indexes (starting after the last\n-    /// counter index, for the given function), during backend code generation, by the helper method\n-    /// `rustc_codegen_ssa::coverageinfo::map::FunctionCoverage::translate_expressions()`.\n+    /// (add or subtract counts) of both Counter regions and CounterExpression regions. The counter\n+    /// expression operand IDs must be unique across both types.\n     fn next_expression(&mut self) -> u32 {\n         assert!(self.num_counters < u32::MAX - self.num_expressions);\n         let next = u32::MAX - self.num_expressions;\n@@ -171,17 +170,25 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n     }\n \n     fn inject_counters(&mut self) {\n+        let mir_body = &self.mir_body;\n         let body_span = self.hir_body.value.span;\n-        debug!(\n-            \"instrumenting {:?}, span: {}\",\n-            self.mir_def_id,\n-            self.tcx.sess.source_map().span_to_string(body_span)\n-        );\n+        debug!(\"instrumenting {:?}, span: {:?}\", self.mir_def_id, body_span);\n \n         // FIXME(richkadel): As a first step, counters are only injected at the top of each\n         // function. The complete solution will inject counters at each conditional code branch.\n-        let next_block = START_BLOCK;\n-        self.inject_counter(body_span, next_block);\n+        let _ignore = mir_body;\n+        let id = self.next_counter();\n+        let function_source_hash = self.function_source_hash();\n+        let code_region = body_span;\n+        let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n+        let is_cleanup = false;\n+        let next_block = rustc_middle::mir::START_BLOCK;\n+        self.inject_call(\n+            self.make_counter(id, function_source_hash, code_region),\n+            scope,\n+            is_cleanup,\n+            next_block,\n+        );\n \n         // FIXME(richkadel): The next step to implement source based coverage analysis will be\n         // instrumenting branches within functions, and some regions will be counted by \"counter\n@@ -190,57 +197,68 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let fake_use = false;\n         if fake_use {\n             let add = false;\n-            if add {\n-                self.inject_counter_expression(body_span, next_block, 1, Op::Add, 2);\n-            } else {\n-                self.inject_counter_expression(body_span, next_block, 1, Op::Subtract, 2);\n-            }\n+            let lhs = 1;\n+            let op = if add { Op::Add } else { Op::Subtract };\n+            let rhs = 2;\n+\n+            let code_region = body_span;\n+            let scope = rustc_middle::mir::OUTERMOST_SOURCE_SCOPE;\n+            let is_cleanup = false;\n+            let next_block = rustc_middle::mir::START_BLOCK;\n+\n+            let id = self.next_expression();\n+            self.inject_call(\n+                self.make_expression(id, code_region, lhs, op, rhs),\n+                scope,\n+                is_cleanup,\n+                next_block,\n+            );\n         }\n     }\n \n-    fn inject_counter(&mut self, code_region: Span, next_block: BasicBlock) -> u32 {\n-        let counter_id = self.next_counter();\n-        let function_source_hash = self.function_source_hash();\n-        let injection_point = code_region.shrink_to_lo();\n+    fn make_counter(\n+        &self,\n+        id: u32,\n+        function_source_hash: u64,\n+        code_region: Span,\n+    ) -> InjectedCall<'tcx> {\n+        let inject_at = code_region.shrink_to_lo();\n \n-        let count_code_region_fn = function_handle(\n+        let func = function_handle(\n             self.tcx,\n             self.tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n-            injection_point,\n+            inject_at,\n         );\n \n         let mut args = Vec::new();\n \n         use count_code_region_args::*;\n         debug_assert_eq!(FUNCTION_SOURCE_HASH, args.len());\n-        args.push(self.const_u64(function_source_hash, injection_point));\n+        args.push(self.const_u64(function_source_hash, inject_at));\n \n-        debug_assert_eq!(COUNTER_INDEX, args.len());\n-        args.push(self.const_u32(counter_id, injection_point));\n+        debug_assert_eq!(COUNTER_ID, args.len());\n+        args.push(self.const_u32(id, inject_at));\n \n         debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n \n         debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n-\n-        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n+        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n \n-        counter_id\n+        InjectedCall { func, args, inject_at }\n     }\n \n-    fn inject_counter_expression(\n-        &mut self,\n+    fn make_expression(\n+        &self,\n+        id: u32,\n         code_region: Span,\n-        next_block: BasicBlock,\n         lhs: u32,\n         op: Op,\n         rhs: u32,\n-    ) -> u32 {\n-        let expression_id = self.next_expression();\n-        let injection_point = code_region.shrink_to_lo();\n+    ) -> InjectedCall<'tcx> {\n+        let inject_at = code_region.shrink_to_lo();\n \n-        let count_code_region_fn = function_handle(\n+        let func = function_handle(\n             self.tcx,\n             self.tcx.require_lang_item(\n                 match op {\n@@ -249,43 +267,51 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 },\n                 None,\n             ),\n-            injection_point,\n+            inject_at,\n         );\n \n         let mut args = Vec::new();\n \n         use coverage_counter_expression_args::*;\n-        debug_assert_eq!(COUNTER_EXPRESSION_INDEX, args.len());\n-        args.push(self.const_u32(expression_id, injection_point));\n+        debug_assert_eq!(EXPRESSION_ID, args.len());\n+        args.push(self.const_u32(id, inject_at));\n \n-        debug_assert_eq!(LEFT_INDEX, args.len());\n-        args.push(self.const_u32(lhs, injection_point));\n+        debug_assert_eq!(LEFT_ID, args.len());\n+        args.push(self.const_u32(lhs, inject_at));\n \n-        debug_assert_eq!(RIGHT_INDEX, args.len());\n-        args.push(self.const_u32(rhs, injection_point));\n+        debug_assert_eq!(RIGHT_ID, args.len());\n+        args.push(self.const_u32(rhs, inject_at));\n \n         debug_assert_eq!(START_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+        args.push(self.const_u32(code_region.lo().to_u32(), inject_at));\n \n         debug_assert_eq!(END_BYTE_POS, args.len());\n-        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n+        args.push(self.const_u32(code_region.hi().to_u32(), inject_at));\n \n-        self.inject_call(count_code_region_fn, args, injection_point, next_block);\n-\n-        expression_id\n+        InjectedCall { func, args, inject_at }\n     }\n \n     fn inject_call(\n         &mut self,\n-        func: Operand<'tcx>,\n-        args: Vec<Operand<'tcx>>,\n-        fn_span: Span,\n+        call: InjectedCall<'tcx>,\n+        scope: SourceScope,\n+        is_cleanup: bool,\n         next_block: BasicBlock,\n     ) {\n+        let InjectedCall { func, args, inject_at } = call;\n+        debug!(\n+            \"  injecting {}call to {:?}({:?}) at: {:?}, scope: {:?}\",\n+            if is_cleanup { \"cleanup \" } else { \"\" },\n+            func,\n+            args,\n+            inject_at,\n+            scope,\n+        );\n+\n         let mut patch = MirPatch::new(self.mir_body);\n \n-        let temp = patch.new_temp(self.tcx.mk_unit(), fn_span);\n-        let new_block = patch.new_block(placeholder_block(fn_span));\n+        let temp = patch.new_temp(self.tcx.mk_unit(), inject_at);\n+        let new_block = patch.new_block(placeholder_block(inject_at, scope, is_cleanup));\n         patch.patch_terminator(\n             new_block,\n             TerminatorKind::Call {\n@@ -295,7 +321,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n                 destination: Some((Place::from(temp), new_block)),\n                 cleanup: None,\n                 from_hir_call: false,\n-                fn_span,\n+                fn_span: inject_at,\n             },\n         );\n \n@@ -325,15 +351,15 @@ fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Ope\n     Operand::function_handle(tcx, fn_def_id, substs, span)\n }\n \n-fn placeholder_block(span: Span) -> BasicBlockData<'tcx> {\n+fn placeholder_block(span: Span, scope: SourceScope, is_cleanup: bool) -> BasicBlockData<'tcx> {\n     BasicBlockData {\n         statements: vec![],\n         terminator: Some(Terminator {\n-            source_info: SourceInfo::outermost(span),\n+            source_info: SourceInfo { span, scope },\n             // this gets overwritten by the counter Call\n             kind: TerminatorKind::Unreachable,\n         }),\n-        is_cleanup: false,\n+        is_cleanup,\n     }\n }\n "}, {"sha": "26b4a6968971d9efc5eb5604f3fd93513203842a", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -332,21 +332,25 @@ fn mir_validated(\n     body.required_consts = required_consts;\n \n     let promote_pass = promote_consts::PromoteTemps::default();\n+    let promote: &[&dyn MirPass<'tcx>] = &[\n+        // What we need to run borrowck etc.\n+        &promote_pass,\n+        &simplify::SimplifyCfg::new(\"qualify-consts\"),\n+    ];\n+\n+    let opt_coverage: &[&dyn MirPass<'tcx>] = if tcx.sess.opts.debugging_opts.instrument_coverage {\n+        &[&instrument_coverage::InstrumentCoverage]\n+    } else {\n+        &[]\n+    };\n+\n     run_passes(\n         tcx,\n         &mut body,\n         InstanceDef::Item(def.to_global()),\n         None,\n         MirPhase::Validated,\n-        &[&[\n-            // What we need to run borrowck etc.\n-            &promote_pass,\n-            &simplify::SimplifyCfg::new(\"qualify-consts\"),\n-            // If the `instrument-coverage` option is enabled, analyze the CFG, identify each\n-            // conditional branch, construct a coverage map to be passed to LLVM, and inject counters\n-            // where needed.\n-            &instrument_coverage::InstrumentCoverage,\n-        ]],\n+        &[promote, opt_coverage],\n     );\n \n     let promoted = promote_pass.promoted_fragments.into_inner();"}, {"sha": "f1a7338d11fd966180551bf5078984e23c5aae18", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -502,9 +502,47 @@ impl<'tcx> Validator<'_, 'tcx> {\n     fn validate_place(&self, place: PlaceRef<'tcx>) -> Result<(), Unpromotable> {\n         match place {\n             PlaceRef { local, projection: [] } => self.validate_local(local),\n-            PlaceRef { local: _, projection: [proj_base @ .., elem] } => {\n+            PlaceRef { local, projection: [proj_base @ .., elem] } => {\n                 match *elem {\n-                    ProjectionElem::Deref | ProjectionElem::Downcast(..) => {\n+                    ProjectionElem::Deref => {\n+                        let mut not_promotable = true;\n+                        // This is a special treatment for cases like *&STATIC where STATIC is a\n+                        // global static variable.\n+                        // This pattern is generated only when global static variables are directly\n+                        // accessed and is qualified for promotion safely.\n+                        if let TempState::Defined { location, .. } = self.temps[local] {\n+                            let def_stmt =\n+                                self.body[location.block].statements.get(location.statement_index);\n+                            if let Some(Statement {\n+                                kind:\n+                                    StatementKind::Assign(box (_, Rvalue::Use(Operand::Constant(c)))),\n+                                ..\n+                            }) = def_stmt\n+                            {\n+                                if let Some(did) = c.check_static_ptr(self.tcx) {\n+                                    if let Some(hir::ConstContext::Static(..)) = self.const_kind {\n+                                        // The `is_empty` predicate is introduced to exclude the case\n+                                        // where the projection operations are [ .field, * ].\n+                                        // The reason is because promotion will be illegal if field\n+                                        // accesses precede the dereferencing.\n+                                        // Discussion can be found at\n+                                        // https://github.com/rust-lang/rust/pull/74945#discussion_r463063247\n+                                        // There may be opportunity for generalization, but this needs to be\n+                                        // accounted for.\n+                                        if proj_base.is_empty()\n+                                            && !self.tcx.is_thread_local_static(did)\n+                                        {\n+                                            not_promotable = false;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        if not_promotable {\n+                            return Err(Unpromotable);\n+                        }\n+                    }\n+                    ProjectionElem::Downcast(..) => {\n                         return Err(Unpromotable);\n                     }\n "}, {"sha": "9288d6e16f5e079e8937a78c521102d1944bb91e", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -33,6 +33,7 @@ use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::TyCtxt;\n+use smallvec::SmallVec;\n use std::borrow::Cow;\n \n pub struct SimplifyCfg {\n@@ -172,9 +173,12 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n         }\n     }\n \n-    // Collapse a goto chain starting from `start`\n-    fn collapse_goto_chain(&mut self, start: &mut BasicBlock, changed: &mut bool) {\n-        let mut terminator = match self.basic_blocks[*start] {\n+    /// This function will return `None` if\n+    /// * the block has statements\n+    /// * the block has a terminator other than `goto`\n+    /// * the block has no terminator (meaning some other part of the current optimization stole it)\n+    fn take_terminator_if_simple_goto(&mut self, bb: BasicBlock) -> Option<Terminator<'tcx>> {\n+        match self.basic_blocks[bb] {\n             BasicBlockData {\n                 ref statements,\n                 terminator:\n@@ -183,32 +187,45 @@ impl<'a, 'tcx> CfgSimplifier<'a, 'tcx> {\n             } if statements.is_empty() => terminator.take(),\n             // if `terminator` is None, this means we are in a loop. In that\n             // case, let all the loop collapse to its entry.\n-            _ => return,\n-        };\n-\n-        let target = match terminator {\n-            Some(Terminator { kind: TerminatorKind::Goto { ref mut target }, .. }) => {\n-                self.collapse_goto_chain(target, changed);\n-                *target\n-            }\n-            _ => unreachable!(),\n-        };\n-        self.basic_blocks[*start].terminator = terminator;\n-\n-        debug!(\"collapsing goto chain from {:?} to {:?}\", *start, target);\n-\n-        *changed |= *start != target;\n+            _ => None,\n+        }\n+    }\n \n-        if self.pred_count[*start] == 1 {\n-            // This is the last reference to *start, so the pred-count to\n-            // to target is moved into the current block.\n-            self.pred_count[*start] = 0;\n-        } else {\n-            self.pred_count[target] += 1;\n-            self.pred_count[*start] -= 1;\n+    /// Collapse a goto chain starting from `start`\n+    fn collapse_goto_chain(&mut self, start: &mut BasicBlock, changed: &mut bool) {\n+        // Using `SmallVec` here, because in some logs on libcore oli-obk saw many single-element\n+        // goto chains. We should probably benchmark different sizes.\n+        let mut terminators: SmallVec<[_; 1]> = Default::default();\n+        let mut current = *start;\n+        while let Some(terminator) = self.take_terminator_if_simple_goto(current) {\n+            let target = match terminator {\n+                Terminator { kind: TerminatorKind::Goto { target }, .. } => target,\n+                _ => unreachable!(),\n+            };\n+            terminators.push((current, terminator));\n+            current = target;\n         }\n+        let last = current;\n+        *start = last;\n+        while let Some((current, mut terminator)) = terminators.pop() {\n+            let target = match terminator {\n+                Terminator { kind: TerminatorKind::Goto { ref mut target }, .. } => target,\n+                _ => unreachable!(),\n+            };\n+            *target = last;\n+            debug!(\"collapsing goto chain from {:?} to {:?}\", current, target);\n \n-        *start = target;\n+            if self.pred_count[current] == 1 {\n+                // This is the last reference to current, so the pred-count to\n+                // to target is moved into the current block.\n+                self.pred_count[current] = 0;\n+            } else {\n+                self.pred_count[*target] += 1;\n+                self.pred_count[current] -= 1;\n+            }\n+            *changed = true;\n+            self.basic_blocks[current].terminator = Some(terminator);\n+        }\n     }\n \n     // merge a block with 1 `goto` predecessor to its parent"}, {"sha": "b8a74f09409ca9822470012995b55b06c2f28e58", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -189,7 +189,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // Normalize projections and things like that.\n         // FIXME: We need to reveal_all, as some optimizations change types in ways\n         // that require unfolding opaque types.\n-        let param_env = self.param_env.with_reveal_all();\n+        let param_env = self.param_env.with_reveal_all_normalized(self.tcx);\n         let src = self.tcx.normalize_erasing_regions(param_env, src);\n         let dest = self.tcx.normalize_erasing_regions(param_env, dest);\n "}, {"sha": "25657ba98b8936342d94f98f791fc5879adac221", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -177,6 +177,7 @@ fn dump_path(\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n \n+    let crate_name = tcx.crate_name(source.def_id().krate);\n     let item_name = tcx.def_path(source.def_id()).to_filename_friendly_no_crate();\n     // All drop shims have the same DefId, so we have to add the type\n     // to get unique file names.\n@@ -196,8 +197,15 @@ fn dump_path(\n     };\n \n     let file_name = format!(\n-        \"rustc.{}{}{}{}.{}.{}.{}\",\n-        item_name, shim_disambiguator, promotion_id, pass_num, pass_name, disambiguator, extension,\n+        \"{}.{}{}{}{}.{}.{}.{}\",\n+        crate_name,\n+        item_name,\n+        shim_disambiguator,\n+        promotion_id,\n+        pass_num,\n+        pass_name,\n+        disambiguator,\n+        extension,\n     );\n \n     file_path.push(&file_name);\n@@ -588,7 +596,7 @@ pub fn write_allocations<'tcx>(\n                         todo.push(id);\n                     }\n                 }\n-                write_allocation(tcx, alloc, w)\n+                write!(w, \"{}\", display_allocation(tcx, alloc))\n             };\n         write!(w, \"\\n{}\", id)?;\n         match tcx.get_global_alloc(id) {\n@@ -640,24 +648,36 @@ pub fn write_allocations<'tcx>(\n /// After the hex dump, an ascii dump follows, replacing all unprintable characters (control\n /// characters or characters whose value is larger than 127) with a `.`\n /// This also prints relocations adequately.\n-pub fn write_allocation<Tag: Copy + Debug, Extra>(\n+pub fn display_allocation<Tag: Copy + Debug, Extra>(\n     tcx: TyCtxt<'tcx>,\n-    alloc: &Allocation<Tag, Extra>,\n-    w: &mut dyn Write,\n-) -> io::Result<()> {\n-    write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n-    if alloc.size == Size::ZERO {\n-        // We are done.\n-        return write!(w, \" {{}}\");\n+    alloc: &'a Allocation<Tag, Extra>,\n+) -> RenderAllocation<'a, 'tcx, Tag, Extra> {\n+    RenderAllocation { tcx, alloc }\n+}\n+\n+#[doc(hidden)]\n+pub struct RenderAllocation<'a, 'tcx, Tag, Extra> {\n+    tcx: TyCtxt<'tcx>,\n+    alloc: &'a Allocation<Tag, Extra>,\n+}\n+\n+impl<Tag: Copy + Debug, Extra> std::fmt::Display for RenderAllocation<'a, 'tcx, Tag, Extra> {\n+    fn fmt(&self, w: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        let RenderAllocation { tcx, alloc } = *self;\n+        write!(w, \"size: {}, align: {})\", alloc.size.bytes(), alloc.align.bytes())?;\n+        if alloc.size == Size::ZERO {\n+            // We are done.\n+            return write!(w, \" {{}}\");\n+        }\n+        // Write allocation bytes.\n+        writeln!(w, \" {{\")?;\n+        write_allocation_bytes(tcx, alloc, w, \"    \")?;\n+        write!(w, \"}}\")?;\n+        Ok(())\n     }\n-    // Write allocation bytes.\n-    writeln!(w, \" {{\")?;\n-    write_allocation_bytes(tcx, alloc, w, \"    \")?;\n-    write!(w, \"}}\")?;\n-    Ok(())\n }\n \n-fn write_allocation_endline(w: &mut dyn Write, ascii: &str) -> io::Result<()> {\n+fn write_allocation_endline(w: &mut dyn std::fmt::Write, ascii: &str) -> std::fmt::Result {\n     for _ in 0..(BYTES_PER_LINE - ascii.chars().count()) {\n         write!(w, \"   \")?;\n     }\n@@ -669,12 +689,12 @@ const BYTES_PER_LINE: usize = 16;\n \n /// Prints the line start address and returns the new line start address.\n fn write_allocation_newline(\n-    w: &mut dyn Write,\n+    w: &mut dyn std::fmt::Write,\n     mut line_start: Size,\n     ascii: &str,\n     pos_width: usize,\n     prefix: &str,\n-) -> io::Result<Size> {\n+) -> Result<Size, std::fmt::Error> {\n     write_allocation_endline(w, ascii)?;\n     line_start += Size::from_bytes(BYTES_PER_LINE);\n     write!(w, \"{}0x{:02$x} \u2502 \", prefix, line_start.bytes(), pos_width)?;\n@@ -687,9 +707,9 @@ fn write_allocation_newline(\n fn write_allocation_bytes<Tag: Copy + Debug, Extra>(\n     tcx: TyCtxt<'tcx>,\n     alloc: &Allocation<Tag, Extra>,\n-    w: &mut dyn Write,\n+    w: &mut dyn std::fmt::Write,\n     prefix: &str,\n-) -> io::Result<()> {\n+) -> std::fmt::Result {\n     let num_lines = alloc.size.bytes_usize().saturating_sub(BYTES_PER_LINE);\n     // Number of chars needed to represent all line numbers.\n     let pos_width = format!(\"{:x}\", alloc.size.bytes()).len();"}, {"sha": "96059fa43e52124f3f2e1d3959e595ea1e16962a", "filename": "src/librustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../librustc_arena\" }\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_attr = { path = \"../librustc_attr\" }"}, {"sha": "d1cbf209b06cebc4035cb783f8a3de4ccf29cfe3", "filename": "src/librustc_mir_build/build/block.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,7 +1,7 @@\n use crate::build::matches::ArmHasGuard;\n use crate::build::ForGuard::OutsideGuard;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_hir as hir;\n use rustc_middle::mir::*;\n use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n@@ -176,7 +176,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let tail_result_is_ignored =\n                 destination_ty.is_unit() || this.block_context.currently_ignores_tail_results();\n             let span = match expr {\n-                ExprRef::Hair(expr) => expr.span,\n+                ExprRef::Thir(expr) => expr.span,\n                 ExprRef::Mirror(ref expr) => expr.span,\n             };\n             this.block_context.push(BlockFrame::TailExpr { tail_result_is_ignored, span });\n@@ -235,11 +235,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .push_unsafe_count\n                     .checked_sub(1)\n                     .unwrap_or_else(|| span_bug!(span, \"unsafe count underflow\"));\n-                if self.push_unsafe_count == 0 {\n-                    Some(self.unpushed_unsafe)\n-                } else {\n-                    None\n-                }\n+                if self.push_unsafe_count == 0 { Some(self.unpushed_unsafe) } else { None }\n             }\n         };\n "}, {"sha": "982aefcf6045c2c914d7b2b693a960e9a6d40b10", "filename": "src/librustc_mir_build/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_constant.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,7 +1,7 @@\n //! See docs in build/expr/mod.rs\n \n use crate::build::Builder;\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty::CanonicalUserTypeAnnotation;\n "}, {"sha": "aac93f313f4e151af252829735b540f4db754ff3", "filename": "src/librustc_mir_build/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_operand.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -2,7 +2,7 @@\n \n use crate::build::expr::category::Category;\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n "}, {"sha": "1e3e104c2bad64d72f959539bd07efbc3efd3850", "filename": "src/librustc_mir_build/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_place.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -3,7 +3,7 @@\n use crate::build::expr::category::Category;\n use crate::build::ForGuard::{OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;"}, {"sha": "9c5fddc6b77c097ed6a479a0026b8361f8131c3f", "filename": "src/librustc_mir_build/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -4,7 +4,7 @@ use rustc_index::vec::Idx;\n \n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::*;"}, {"sha": "a9cc0cc2f24757e365f9657c551fcc4571a7eee9", "filename": "src/librustc_mir_build/build/expr/as_temp.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fas_temp.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -2,7 +2,7 @@\n \n use crate::build::scope::DropKind;\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir as hir;\n use rustc_middle::middle::region;\n@@ -67,12 +67,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ExprKind::StaticRef { def_id, .. } => {\n                     assert!(!this.hir.tcx().is_thread_local_static(def_id));\n                     local_decl.internal = true;\n-                    local_decl.local_info = Some(box LocalInfo::StaticRef { def_id, is_thread_local: false });\n+                    local_decl.local_info =\n+                        Some(box LocalInfo::StaticRef { def_id, is_thread_local: false });\n                 }\n                 ExprKind::ThreadLocalRef(def_id) => {\n                     assert!(this.hir.tcx().is_thread_local_static(def_id));\n                     local_decl.internal = true;\n-                    local_decl.local_info = Some(box LocalInfo::StaticRef { def_id, is_thread_local: true });\n+                    local_decl.local_info =\n+                        Some(box LocalInfo::StaticRef { def_id, is_thread_local: true });\n                 }\n                 _ => {}\n             }"}, {"sha": "9cabd186d8460cff88350229693e23f81ba76e9b", "filename": "src/librustc_mir_build/build/expr/category.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fcategory.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,4 +1,4 @@\n-use crate::hair::*;\n+use crate::thir::*;\n \n #[derive(Debug, PartialEq)]\n crate enum Category {"}, {"sha": "c3f54b39a3f38e6b7f895ae12d58a59e9def9523", "filename": "src/librustc_mir_build/build/expr/into.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Finto.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -2,7 +2,7 @@\n \n use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_ast::ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -320,23 +320,23 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 block.unit()\n             }\n             ExprKind::InlineAsm { template, operands, options, line_spans } => {\n-                use crate::hair;\n+                use crate::thir;\n                 use rustc_middle::mir;\n                 let operands = operands\n                     .into_iter()\n                     .map(|op| match op {\n-                        hair::InlineAsmOperand::In { reg, expr } => mir::InlineAsmOperand::In {\n+                        thir::InlineAsmOperand::In { reg, expr } => mir::InlineAsmOperand::In {\n                             reg,\n                             value: unpack!(block = this.as_local_operand(block, expr)),\n                         },\n-                        hair::InlineAsmOperand::Out { reg, late, expr } => {\n+                        thir::InlineAsmOperand::Out { reg, late, expr } => {\n                             mir::InlineAsmOperand::Out {\n                                 reg,\n                                 late,\n                                 place: expr.map(|expr| unpack!(block = this.as_place(block, expr))),\n                             }\n                         }\n-                        hair::InlineAsmOperand::InOut { reg, late, expr } => {\n+                        thir::InlineAsmOperand::InOut { reg, late, expr } => {\n                             let place = unpack!(block = this.as_place(block, expr));\n                             mir::InlineAsmOperand::InOut {\n                                 reg,\n@@ -346,7 +346,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 out_place: Some(place),\n                             }\n                         }\n-                        hair::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n+                        thir::InlineAsmOperand::SplitInOut { reg, late, in_expr, out_expr } => {\n                             mir::InlineAsmOperand::InOut {\n                                 reg,\n                                 late,\n@@ -356,13 +356,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                 }),\n                             }\n                         }\n-                        hair::InlineAsmOperand::Const { expr } => mir::InlineAsmOperand::Const {\n+                        thir::InlineAsmOperand::Const { expr } => mir::InlineAsmOperand::Const {\n                             value: unpack!(block = this.as_local_operand(block, expr)),\n                         },\n-                        hair::InlineAsmOperand::SymFn { expr } => {\n+                        thir::InlineAsmOperand::SymFn { expr } => {\n                             mir::InlineAsmOperand::SymFn { value: box this.as_constant(expr) }\n                         }\n-                        hair::InlineAsmOperand::SymStatic { def_id } => {\n+                        thir::InlineAsmOperand::SymStatic { def_id } => {\n                             mir::InlineAsmOperand::SymStatic { def_id }\n                         }\n                     })"}, {"sha": "f117689d940fd7a210183b1d0a526c8032912d46", "filename": "src/librustc_mir_build/build/expr/stmt.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fexpr%2Fstmt.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,11 +1,11 @@\n use crate::build::scope::BreakableTarget;\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    /// Builds a block of MIR statements to evaluate the HAIR `expr`.\n+    /// Builds a block of MIR statements to evaluate the THIR `expr`.\n     /// If the original expression was an AST statement,\n     /// (e.g., `some().code(&here());`) then `opt_stmt_span` is the\n     /// span of that statement (including its semicolon, if any).\n@@ -150,8 +150,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                                     break;\n                                 }\n                             }\n-                            this.block_context\n-                                .push(BlockFrame::TailExpr { tail_result_is_ignored: true, span: expr.span });\n+                            this.block_context.push(BlockFrame::TailExpr {\n+                                tail_result_is_ignored: true,\n+                                span: expr.span,\n+                            });\n                             return Some(expr.span);\n                         }\n                     }"}, {"sha": "7264e495b84fd0dc6026c67f156f4cb25c40a428", "filename": "src/librustc_mir_build/build/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Finto.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -5,7 +5,7 @@\n //! latter `EvalInto` trait.\n \n use crate::build::{BlockAnd, Builder};\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_middle::mir::*;\n \n pub(in crate::build) trait EvalInto<'tcx> {"}, {"sha": "77c0fe8dda5346dd0bbf5010dfcc37e84b7c87b0", "filename": "src/librustc_mir_build/build/matches/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,15 +9,18 @@ use crate::build::scope::DropKind;\n use crate::build::ForGuard::{self, OutsideGuard, RefWithinGuard};\n use crate::build::{BlockAnd, BlockAndExtension, Builder};\n use crate::build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n-use crate::hair::{self, *};\n-use rustc_data_structures::{fx::{FxHashMap, FxHashSet}, stack::ensure_sufficient_stack};\n+use crate::thir::{self, *};\n+use rustc_data_structures::{\n+    fx::{FxHashMap, FxHashSet},\n+    stack::ensure_sufficient_stack,\n+};\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, CanonicalUserTypeAnnotation, Ty};\n-use rustc_span::Span;\n use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n use smallvec::{smallvec, SmallVec};\n \n@@ -395,7 +398,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         ..\n                     },\n                 ascription:\n-                    hair::pattern::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n+                    thir::pattern::Ascription { user_ty: pat_ascription_ty, variance: _, user_ty_span },\n             } => {\n                 let place =\n                     self.storage_live_binding(block, var, irrefutable_pat.span, OutsideGuard, true);\n@@ -631,7 +634,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n             PatKind::AscribeUserType {\n                 ref subpattern,\n-                ascription: hair::pattern::Ascription { ref user_ty, user_ty_span, variance: _ },\n+                ascription: thir::pattern::Ascription { ref user_ty, user_ty_span, variance: _ },\n             } => {\n                 // This corresponds to something like\n                 //\n@@ -1982,16 +1985,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             source_info,\n             internal: false,\n             is_block_tail: None,\n-            local_info: Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(VarBindingForm {\n-                binding_mode,\n-                // hypothetically, `visit_primary_bindings` could try to unzip\n-                // an outermost hir::Ty as we descend, matching up\n-                // idents in pat; but complex w/ unclear UI payoff.\n-                // Instead, just abandon providing diagnostic info.\n-                opt_ty_info: None,\n-                opt_match_place,\n-                pat_span,\n-            })))),\n+            local_info: Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                VarBindingForm {\n+                    binding_mode,\n+                    // hypothetically, `visit_primary_bindings` could try to unzip\n+                    // an outermost hir::Ty as we descend, matching up\n+                    // idents in pat; but complex w/ unclear UI payoff.\n+                    // Instead, just abandon providing diagnostic info.\n+                    opt_ty_info: None,\n+                    opt_match_place,\n+                    pat_span,\n+                },\n+            )))),\n         };\n         let for_arm_body = self.local_decls.push(local);\n         self.var_debug_info.push(VarDebugInfo {\n@@ -2009,7 +2014,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 source_info,\n                 internal: false,\n                 is_block_tail: None,\n-                local_info: Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::RefForGuard))),\n+                local_info: Some(box LocalInfo::User(ClearCrossCrate::Set(\n+                    BindingForm::RefForGuard,\n+                ))),\n             });\n             self.var_debug_info.push(VarDebugInfo {\n                 name,"}, {"sha": "e584aeb922672f4f6bac94396bd1b3afc902a1db", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -14,7 +14,7 @@\n \n use crate::build::matches::{Ascription, Binding, Candidate, MatchPair};\n use crate::build::Builder;\n-use crate::hair::{self, *};\n+use crate::thir::{self, *};\n use rustc_attr::{SignedInt, UnsignedInt};\n use rustc_hir::RangeEnd;\n use rustc_middle::mir::interpret::truncate;\n@@ -108,7 +108,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match *match_pair.pattern.kind {\n             PatKind::AscribeUserType {\n                 ref subpattern,\n-                ascription: hair::pattern::Ascription { variance, user_ty, user_ty_span },\n+                ascription: thir::pattern::Ascription { variance, user_ty, user_ty_span },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n                 // value being matched, taking the variance field into account."}, {"sha": "158ad78a1bf36c4fc629465c3c9bc61f66c1fe2c", "filename": "src/librustc_mir_build/build/matches/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Ftest.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -7,8 +7,8 @@\n \n use crate::build::matches::{Candidate, MatchPair, Test, TestKind};\n use crate::build::Builder;\n-use crate::hair::pattern::compare_const_vals;\n-use crate::hair::*;\n+use crate::thir::pattern::compare_const_vals;\n+use crate::thir::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::RangeEnd;\n use rustc_index::bit_set::BitSet;\n@@ -443,7 +443,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 destination: Some((eq_result, eq_block)),\n                 cleanup: Some(cleanup),\n                 from_hir_call: false,\n-                fn_span: source_info.span\n+                fn_span: source_info.span,\n             },\n         );\n "}, {"sha": "605396c5eb639f722003f4e5b12528e7bde7bd16", "filename": "src/librustc_mir_build/build/matches/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Futil.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,6 +1,6 @@\n use crate::build::matches::MatchPair;\n use crate::build::Builder;\n-use crate::hair::*;\n+use crate::thir::*;\n use rustc_middle::mir::*;\n use rustc_middle::ty;\n use smallvec::SmallVec;"}, {"sha": "3c4587119cd55453070a8989e4efe61a3e577413", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,7 +1,7 @@\n use crate::build;\n use crate::build::scope::DropKind;\n-use crate::hair::cx::Cx;\n-use crate::hair::{BindingMode, LintLevel, PatKind};\n+use crate::thir::cx::Cx;\n+use crate::thir::{BindingMode, LintLevel, PatKind};\n use rustc_attr::{self as attr, UnwindAttr};\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -10,6 +10,7 @@ use rustc_hir::lang_items;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::middle::region;\n use rustc_middle::mir::*;\n use rustc_middle::ty::subst::Subst;\n@@ -293,7 +294,7 @@ struct Builder<'a, 'tcx> {\n     /// see the `scope` module for more details.\n     scopes: scope::Scopes<'tcx>,\n \n-    /// The block-context: each time we build the code within an hair::Block,\n+    /// The block-context: each time we build the code within an thir::Block,\n     /// we push a frame here tracking whether we are building a statement or\n     /// if we are pushing the tail expression of the block. This is used to\n     /// embed information in generated temps about whether they were created\n@@ -797,12 +798,22 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         argument_scope: region::Scope,\n         ast_body: &'tcx hir::Expr<'tcx>,\n     ) -> BlockAnd<()> {\n+        let tcx = self.hir.tcx();\n+        let attrs = tcx.codegen_fn_attrs(fn_def_id);\n+        let naked = attrs.flags.contains(CodegenFnAttrFlags::NAKED);\n+\n         // Allocate locals for the function arguments\n         for &ArgInfo(ty, _, arg_opt, _) in arguments.iter() {\n             let source_info =\n                 SourceInfo::outermost(arg_opt.map_or(self.fn_span, |arg| arg.pat.span));\n             let arg_local = self.local_decls.push(LocalDecl::with_source_info(ty, source_info));\n \n+            // Emit function argument debuginfo only for non-naked functions.\n+            // See: https://github.com/rust-lang/rust/issues/42779\n+            if naked {\n+                continue;\n+            }\n+\n             // If this is a simple binding pattern, give debuginfo a nice name.\n             if let Some(arg) = arg_opt {\n                 if let Some(ident) = arg.pat.simple_ident() {\n@@ -815,7 +826,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n         }\n \n-        let tcx = self.hir.tcx();\n         let tcx_hir = tcx.hir();\n         let hir_typeck_results = self.hir.typeck_results();\n "}, {"sha": "2a03bb78c6b1ac31a37e74b51dd8fdc7d05b7548", "filename": "src/librustc_mir_build/build/scope.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fscope.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,6 +1,6 @@\n /*!\n Managing the scope stack. The scopes are tied to lexical scopes, so as\n-we descend the HAIR, we push a scope on the stack, build its\n+we descend the THIR, we push a scope on the stack, build its\n contents, and then pop it off. Every scope is named by a\n `region::Scope`.\n \n@@ -83,12 +83,12 @@ should go to.\n */\n \n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder, CFG};\n-use crate::hair::{Expr, ExprRef, LintLevel};\n-use rustc_middle::middle::region;\n-use rustc_middle::mir::*;\n+use crate::thir::{Expr, ExprRef, LintLevel};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::GeneratorKind;\n+use rustc_middle::middle::region;\n+use rustc_middle::mir::*;\n use rustc_span::{Span, DUMMY_SP};\n use std::collections::hash_map::Entry;\n use std::mem;"}, {"sha": "30545558933f7d8ace5109ec80906bd2cc187dae", "filename": "src/librustc_mir_build/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -17,13 +17,13 @@ extern crate log;\n extern crate rustc_middle;\n \n mod build;\n-mod hair;\n mod lints;\n+mod thir;\n \n use rustc_middle::ty::query::Providers;\n \n pub fn provide(providers: &mut Providers) {\n-    providers.check_match = hair::pattern::check_match;\n-    providers.lit_to_const = hair::constant::lit_to_const;\n+    providers.check_match = thir::pattern::check_match;\n+    providers.lit_to_const = thir::constant::lit_to_const;\n     providers.mir_built = build::mir_built;\n }"}, {"sha": "e5af0b5bd6bed5b852bcea166d86f8d28187c0fc", "filename": "src/librustc_mir_build/thir/constant.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fconstant.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "previous_filename": "src/librustc_mir_build/hair/constant.rs"}, {"sha": "980888df7fee41242285ca1224f14dcfa26d814b", "filename": "src/librustc_mir_build/thir/cx/block.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fblock.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,6 +1,6 @@\n-use crate::hair::cx::to_ref::ToRef;\n-use crate::hair::cx::Cx;\n-use crate::hair::{self, *};\n+use crate::thir::cx::to_ref::ToRef;\n+use crate::thir::cx::Cx;\n+use crate::thir::{self, *};\n \n use rustc_hir as hir;\n use rustc_middle::middle::region;\n@@ -71,7 +71,7 @@ fn mirror_stmts<'a, 'tcx>(\n                             ty: pattern.ty,\n                             span: pattern.span,\n                             kind: Box::new(PatKind::AscribeUserType {\n-                                ascription: hair::pattern::Ascription {\n+                                ascription: thir::pattern::Ascription {\n                                     user_ty: PatTyProj::from_user_type(user_ty),\n                                     user_ty_span: ty.span,\n                                     variance: ty::Variance::Covariant,", "previous_filename": "src/librustc_mir_build/hair/cx/block.rs"}, {"sha": "ea41a66b3e43d873d032821e6111a750fa55e4d7", "filename": "src/librustc_mir_build/thir/cx/expr.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fexpr.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,8 +1,8 @@\n-use crate::hair::cx::block;\n-use crate::hair::cx::to_ref::ToRef;\n-use crate::hair::cx::Cx;\n-use crate::hair::util::UserAnnotatedTyHelpers;\n-use crate::hair::*;\n+use crate::thir::cx::block;\n+use crate::thir::cx::to_ref::ToRef;\n+use crate::thir::cx::Cx;\n+use crate::thir::util::UserAnnotatedTyHelpers;\n+use crate::thir::*;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_index::vec::Idx;\n@@ -1020,7 +1020,7 @@ fn overloaded_place<'a, 'tcx>(\n     // line up (this is because `*x` and `x[y]` represent places):\n \n     let recv_ty = match args[0] {\n-        ExprRef::Hair(e) => cx.typeck_results().expr_ty_adjusted(e),\n+        ExprRef::Thir(e) => cx.typeck_results().expr_ty_adjusted(e),\n         ExprRef::Mirror(ref e) => e.ty,\n     };\n ", "previous_filename": "src/librustc_mir_build/hair/cx/expr.rs"}, {"sha": "21736df7b0710fbb3f0c60f42a829a766d009652", "filename": "src/librustc_mir_build/thir/cx/mod.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,9 +1,9 @@\n //! This module contains the functionality to convert from the wacky tcx data\n-//! structures into the HAIR. The `builder` is generally ignorant of the tcx,\n+//! structures into the THIR. The `builder` is generally ignorant of the tcx,\n //! etc., and instead goes through the `Cx` for most of its work.\n \n-use crate::hair::util::UserAnnotatedTyHelpers;\n-use crate::hair::*;\n+use crate::thir::util::UserAnnotatedTyHelpers;\n+use crate::thir::*;\n \n use rustc_ast::ast;\n use rustc_ast::attr;", "previous_filename": "src/librustc_mir_build/hair/cx/mod.rs"}, {"sha": "53a988ebb79e2aec4fc453028b0513a7352845e2", "filename": "src/librustc_mir_build/thir/cx/to_ref.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fto_ref.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,4 +1,4 @@\n-use crate::hair::*;\n+use crate::thir::*;\n \n use rustc_hir as hir;\n \n@@ -11,15 +11,15 @@ impl<'tcx> ToRef for &'tcx hir::Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n-        ExprRef::Hair(self)\n+        ExprRef::Thir(self)\n     }\n }\n \n impl<'tcx> ToRef for &'tcx &'tcx hir::Expr<'tcx> {\n     type Output = ExprRef<'tcx>;\n \n     fn to_ref(self) -> ExprRef<'tcx> {\n-        ExprRef::Hair(&**self)\n+        ExprRef::Thir(&**self)\n     }\n }\n ", "previous_filename": "src/librustc_mir_build/hair/cx/to_ref.rs"}, {"sha": "b6ce7e0b41e5418451058227c50a9f6ceb1c868a", "filename": "src/librustc_mir_build/thir/mod.rs", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,5 +1,5 @@\n-//! The MIR is built from some high-level abstract IR\n-//! (HAIR). This section defines the HAIR along with a trait for\n+//! The MIR is built from some typed high-level IR\n+//! (THIR). This section defines the THIR along with a trait for\n //! accessing it. The intention is to allow MIR construction to be\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n@@ -99,18 +99,18 @@ crate enum StmtKind<'tcx> {\n #[cfg(target_arch = \"x86_64\")]\n rustc_data_structures::static_assert_size!(Expr<'_>, 168);\n \n-/// The Hair trait implementor lowers their expressions (`&'tcx H::Expr`)\n+/// The Thir trait implementor lowers their expressions (`&'tcx H::Expr`)\n /// into instances of this `Expr` enum. This lowering can be done\n /// basically as lazily or as eagerly as desired: every recursive\n /// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n /// may in turn be another instance of this enum (boxed), or else an\n /// unlowered `&'tcx H::Expr`. Note that instances of `Expr` are very\n-/// short-lived. They are created by `Hair::to_expr`, analyzed and\n+/// short-lived. They are created by `Thir::to_expr`, analyzed and\n /// converted into MIR, and then discarded.\n ///\n /// If you compare `Expr` to the full compiler AST, you will see it is\n /// a good bit simpler. In fact, a number of the more straight-forward\n-/// MIR simplifications are already done in the impl of `Hair`. For\n+/// MIR simplifications are already done in the impl of `Thir`. For\n /// example, method calls and overloaded operators are absent: they are\n /// expected to be converted into `Expr::Call` instances.\n #[derive(Clone, Debug)]\n@@ -302,7 +302,7 @@ crate enum ExprKind<'tcx> {\n \n #[derive(Clone, Debug)]\n crate enum ExprRef<'tcx> {\n-    Hair(&'tcx hir::Expr<'tcx>),\n+    Thir(&'tcx hir::Expr<'tcx>),\n     Mirror(Box<Expr<'tcx>>),\n }\n \n@@ -342,7 +342,7 @@ crate enum LogicalOp {\n impl<'tcx> ExprRef<'tcx> {\n     crate fn span(&self) -> Span {\n         match self {\n-            ExprRef::Hair(expr) => expr.span,\n+            ExprRef::Thir(expr) => expr.span,\n             ExprRef::Mirror(expr) => expr.span,\n         }\n     }\n@@ -385,7 +385,7 @@ crate enum InlineAsmOperand<'tcx> {\n // The Mirror trait\n \n /// \"Mirroring\" is the process of converting from a HIR type into one\n-/// of the HAIR types defined in this file. This is basically a \"on\n+/// of the THIR types defined in this file. This is basically a \"on\n /// the fly\" desugaring step that hides a lot of the messiness in the\n /// tcx. For example, the mirror of a `&'tcx hir::Expr` is an\n /// `Expr<'tcx>`.\n@@ -394,7 +394,7 @@ crate enum InlineAsmOperand<'tcx> {\n /// + e2`, the references to the inner expressions `e1` and `e2` are\n /// `ExprRef<'tcx>` instances, and they may or may not be eagerly\n /// mirrored. This allows a single AST node from the compiler to\n-/// expand into one or more Hair nodes, which lets the Hair nodes be\n+/// expand into one or more Thir nodes, which lets the Thir nodes be\n /// simpler.\n crate trait Mirror<'tcx> {\n     type Output;\n@@ -415,7 +415,7 @@ impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n \n     fn make_mirror(self, hir: &mut Cx<'_, 'tcx>) -> Expr<'tcx> {\n         match self {\n-            ExprRef::Hair(h) => h.make_mirror(hir),\n+            ExprRef::Thir(h) => h.make_mirror(hir),\n             ExprRef::Mirror(m) => *m,\n         }\n     }", "previous_filename": "src/librustc_mir_build/hair/mod.rs"}, {"sha": "3202f7d1b1b88a036598e159d7c37c7a5c88c40c", "filename": "src/librustc_mir_build/thir/pattern/_match.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2F_match.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "previous_filename": "src/librustc_mir_build/hair/pattern/_match.rs"}, {"sha": "744f319205f94a18bf18eaec1699344d9d346c72", "filename": "src/librustc_mir_build/thir/pattern/check_match.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fcheck_match.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "previous_filename": "src/librustc_mir_build/hair/pattern/check_match.rs"}, {"sha": "6dd7e0871b45ef8bb9b319dd805fa873d3fdb951", "filename": "src/librustc_mir_build/thir/pattern/const_to_pat.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "previous_filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs"}, {"sha": "daff10eb194f83fa15c6003f8f34094ef4533f61", "filename": "src/librustc_mir_build/thir/pattern/mod.rs", "status": "renamed", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -6,7 +6,7 @@ mod const_to_pat;\n \n pub(crate) use self::check_match::check_match;\n \n-use crate::hair::util::UserAnnotatedTyHelpers;\n+use crate::thir::util::UserAnnotatedTyHelpers;\n \n use rustc_ast::ast;\n use rustc_errors::struct_span_err;\n@@ -16,7 +16,7 @@ use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::RangeEnd;\n use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{get_slice_bytes, sign_extend, ConstValue};\n-use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n+use rustc_middle::mir::interpret::{ErrorHandled, LitToConstError, LitToConstInput};\n use rustc_middle::mir::UserTypeProjection;\n use rustc_middle::mir::{BorrowKind, Field, Mutability};\n use rustc_middle::ty::subst::{GenericArg, SubstsRef};\n@@ -133,7 +133,7 @@ crate enum PatKind<'tcx> {\n         var: hir::HirId,\n         ty: Ty<'tcx>,\n         subpattern: Option<Pat<'tcx>>,\n-        /// Is this the leftmost occurance of the binding, i.e., is `var` the\n+        /// Is this the leftmost occurrence of the binding, i.e., is `var` the\n         /// `HirId` of this pattern?\n         is_primary: bool,\n     },\n@@ -402,7 +402,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         //\n         // `vec![&&Option<i32>, &Option<i32>]`.\n         //\n-        // Applying the adjustments, we want to instead output `&&Some(n)` (as a HAIR pattern). So\n+        // Applying the adjustments, we want to instead output `&&Some(n)` (as a THIR pattern). So\n         // we wrap the unadjusted pattern in `PatKind::Deref` repeatedly, consuming the\n         // adjustments in *reverse order* (last-in-first-out, so that the last `Deref` inserted\n         // gets the least-dereferenced type).\n@@ -776,7 +776,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n \n         // Use `Reveal::All` here because patterns are always monomorphic even if their function\n         // isn't.\n-        let param_env_reveal_all = self.param_env.with_reveal_all();\n+        let param_env_reveal_all = self.param_env.with_reveal_all_normalized(self.tcx);\n         let substs = self.typeck_results.node_substs(id);\n         let instance = match ty::Instance::resolve(self.tcx, param_env_reveal_all, def_id, substs) {\n             Ok(Some(i)) => i,\n@@ -834,6 +834,12 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                     pattern\n                 }\n             }\n+            Err(ErrorHandled::TooGeneric) => {\n+                // While `Reported | Linted` cases will have diagnostics emitted already\n+                // it is not true for TooGeneric case, so we need to give user more information.\n+                self.tcx.sess.span_err(span, \"constant pattern depends on a generic parameter\");\n+                pat_from_kind(PatKind::Wild)\n+            }\n             Err(_) => {\n                 self.tcx.sess.span_err(span, \"could not evaluate constant pattern\");\n                 pat_from_kind(PatKind::Wild)", "previous_filename": "src/librustc_mir_build/hair/pattern/mod.rs"}, {"sha": "7de60ddda41a3fcbdba2b65c3006bf27d88838b5", "filename": "src/librustc_mir_build/thir/util.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_mir_build%2Fthir%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Futil.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "previous_filename": "src/librustc_mir_build/hair/util.rs"}, {"sha": "25144bd610d3e11b3cce06a00cc1ec6b4565bc22", "filename": "src/librustc_parse/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n bitflags = \"1.0\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_feature = { path = \"../librustc_feature\" }\n@@ -21,3 +21,4 @@ rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_ast = { path = \"../librustc_ast\" }\n unicode-normalization = \"0.1.11\"\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "3319ca44da467caa38ad8226e918fc5d4a767ed1", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 185, "deletions": 3, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -7,14 +7,16 @@\n #![feature(or_patterns)]\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, Nonterminal};\n+use rustc_ast::token::{self, DelimToken, Nonterminal, Token};\n use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n use rustc_session::parse::ParseSess;\n-use rustc_span::{FileName, SourceFile, Span};\n+use rustc_span::{symbol::kw, FileName, SourceFile, Span, DUMMY_SP};\n \n+use smallvec::SmallVec;\n+use std::mem;\n use std::path::Path;\n use std::str;\n \n@@ -306,7 +308,7 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     // modifications, including adding/removing typically non-semantic\n     // tokens such as extra braces and commas, don't happen.\n     if let Some(tokens) = tokens {\n-        if tokens.probably_equal_for_proc_macro(&tokens_for_real) {\n+        if tokenstream_probably_equal_for_proc_macro(&tokens, &tokens_for_real) {\n             return tokens;\n         }\n         info!(\n@@ -319,6 +321,186 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     tokens_for_real\n }\n \n+// See comments in `Nonterminal::to_tokenstream` for why we care about\n+// *probably* equal here rather than actual equality\n+//\n+// This is otherwise the same as `eq_unspanned`, only recursing with a\n+// different method.\n+pub fn tokenstream_probably_equal_for_proc_macro(first: &TokenStream, other: &TokenStream) -> bool {\n+    // When checking for `probably_eq`, we ignore certain tokens that aren't\n+    // preserved in the AST. Because they are not preserved, the pretty\n+    // printer arbitrarily adds or removes them when printing as token\n+    // streams, making a comparison between a token stream generated from an\n+    // AST and a token stream which was parsed into an AST more reliable.\n+    fn semantic_tree(tree: &TokenTree) -> bool {\n+        if let TokenTree::Token(token) = tree {\n+            if let\n+                // The pretty printer tends to add trailing commas to\n+                // everything, and in particular, after struct fields.\n+                | token::Comma\n+                // The pretty printer emits `NoDelim` as whitespace.\n+                | token::OpenDelim(DelimToken::NoDelim)\n+                | token::CloseDelim(DelimToken::NoDelim)\n+                // The pretty printer collapses many semicolons into one.\n+                | token::Semi\n+                // The pretty printer collapses whitespace arbitrarily and can\n+                // introduce whitespace from `NoDelim`.\n+                | token::Whitespace\n+                // The pretty printer can turn `$crate` into `::crate_name`\n+                | token::ModSep = token.kind {\n+                return false;\n+            }\n+        }\n+        true\n+    }\n+\n+    // When comparing two `TokenStream`s, we ignore the `IsJoint` information.\n+    //\n+    // However, `rustc_parse::lexer::tokentrees::TokenStreamBuilder` will\n+    // use `Token.glue` on adjacent tokens with the proper `IsJoint`.\n+    // Since we are ignoreing `IsJoint`, a 'glued' token (e.g. `BinOp(Shr)`)\n+    // and its 'split'/'unglued' compoenents (e.g. `Gt, Gt`) are equivalent\n+    // when determining if two `TokenStream`s are 'probably equal'.\n+    //\n+    // Therefore, we use `break_two_token_op` to convert all tokens\n+    // to the 'unglued' form (if it exists). This ensures that two\n+    // `TokenStream`s which differ only in how their tokens are glued\n+    // will be considered 'probably equal', which allows us to keep spans.\n+    //\n+    // This is important when the original `TokenStream` contained\n+    // extra spaces (e.g. `f :: < Vec < _ > > ( ) ;'). These extra spaces\n+    // will be omitted when we pretty-print, which can cause the original\n+    // and reparsed `TokenStream`s to differ in the assignment of `IsJoint`,\n+    // leading to some tokens being 'glued' together in one stream but not\n+    // the other. See #68489 for more details.\n+    fn break_tokens(tree: TokenTree) -> impl Iterator<Item = TokenTree> {\n+        // In almost all cases, we should have either zero or one levels\n+        // of 'unglueing'. However, in some unusual cases, we may need\n+        // to iterate breaking tokens mutliple times. For example:\n+        // '[BinOpEq(Shr)] => [Gt, Ge] -> [Gt, Gt, Eq]'\n+        let mut token_trees: SmallVec<[_; 2]>;\n+        if let TokenTree::Token(token) = &tree {\n+            let mut out = SmallVec::<[_; 2]>::new();\n+            out.push(token.clone());\n+            // Iterate to fixpoint:\n+            // * We start off with 'out' containing our initial token, and `temp` empty\n+            // * If we are able to break any tokens in `out`, then `out` will have\n+            //   at least one more element than 'temp', so we will try to break tokens\n+            //   again.\n+            // * If we cannot break any tokens in 'out', we are done\n+            loop {\n+                let mut temp = SmallVec::<[_; 2]>::new();\n+                let mut changed = false;\n+\n+                for token in out.into_iter() {\n+                    if let Some((first, second)) = token.kind.break_two_token_op() {\n+                        temp.push(Token::new(first, DUMMY_SP));\n+                        temp.push(Token::new(second, DUMMY_SP));\n+                        changed = true;\n+                    } else {\n+                        temp.push(token);\n+                    }\n+                }\n+                out = temp;\n+                if !changed {\n+                    break;\n+                }\n+            }\n+            token_trees = out.into_iter().map(TokenTree::Token).collect();\n+            if token_trees.len() != 1 {\n+                debug!(\"break_tokens: broke {:?} to {:?}\", tree, token_trees);\n+            }\n+        } else {\n+            token_trees = SmallVec::new();\n+            token_trees.push(tree);\n+        }\n+        token_trees.into_iter()\n+    }\n+\n+    let mut t1 = first.trees().filter(semantic_tree).flat_map(break_tokens);\n+    let mut t2 = other.trees().filter(semantic_tree).flat_map(break_tokens);\n+    for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n+        if !tokentree_probably_equal_for_proc_macro(&t1, &t2) {\n+            return false;\n+        }\n+    }\n+    t1.next().is_none() && t2.next().is_none()\n+}\n+\n+// See comments in `Nonterminal::to_tokenstream` for why we care about\n+// *probably* equal here rather than actual equality\n+//\n+// This is otherwise the same as `eq_unspanned`, only recursing with a\n+// different method.\n+fn tokentree_probably_equal_for_proc_macro(first: &TokenTree, other: &TokenTree) -> bool {\n+    match (first, other) {\n+        (TokenTree::Token(token), TokenTree::Token(token2)) => {\n+            token_probably_equal_for_proc_macro(token, token2)\n+        }\n+        (TokenTree::Delimited(_, delim, tts), TokenTree::Delimited(_, delim2, tts2)) => {\n+            delim == delim2 && tokenstream_probably_equal_for_proc_macro(&tts, &tts2)\n+        }\n+        _ => false,\n+    }\n+}\n+\n+// See comments in `Nonterminal::to_tokenstream` for why we care about\n+// *probably* equal here rather than actual equality\n+fn token_probably_equal_for_proc_macro(first: &Token, other: &Token) -> bool {\n+    if mem::discriminant(&first.kind) != mem::discriminant(&other.kind) {\n+        return false;\n+    }\n+    use rustc_ast::token::TokenKind::*;\n+    match (&first.kind, &other.kind) {\n+        (&Eq, &Eq)\n+        | (&Lt, &Lt)\n+        | (&Le, &Le)\n+        | (&EqEq, &EqEq)\n+        | (&Ne, &Ne)\n+        | (&Ge, &Ge)\n+        | (&Gt, &Gt)\n+        | (&AndAnd, &AndAnd)\n+        | (&OrOr, &OrOr)\n+        | (&Not, &Not)\n+        | (&Tilde, &Tilde)\n+        | (&At, &At)\n+        | (&Dot, &Dot)\n+        | (&DotDot, &DotDot)\n+        | (&DotDotDot, &DotDotDot)\n+        | (&DotDotEq, &DotDotEq)\n+        | (&Comma, &Comma)\n+        | (&Semi, &Semi)\n+        | (&Colon, &Colon)\n+        | (&ModSep, &ModSep)\n+        | (&RArrow, &RArrow)\n+        | (&LArrow, &LArrow)\n+        | (&FatArrow, &FatArrow)\n+        | (&Pound, &Pound)\n+        | (&Dollar, &Dollar)\n+        | (&Question, &Question)\n+        | (&Whitespace, &Whitespace)\n+        | (&Comment, &Comment)\n+        | (&Eof, &Eof) => true,\n+\n+        (&BinOp(a), &BinOp(b)) | (&BinOpEq(a), &BinOpEq(b)) => a == b,\n+\n+        (&OpenDelim(a), &OpenDelim(b)) | (&CloseDelim(a), &CloseDelim(b)) => a == b,\n+\n+        (&DocComment(a), &DocComment(b)) | (&Shebang(a), &Shebang(b)) => a == b,\n+\n+        (&Literal(a), &Literal(b)) => a == b,\n+\n+        (&Lifetime(a), &Lifetime(b)) => a == b,\n+        (&Ident(a, b), &Ident(c, d)) => {\n+            b == d && (a == c || a == kw::DollarCrate || c == kw::DollarCrate)\n+        }\n+\n+        (&Interpolated(..), &Interpolated(..)) => false,\n+\n+        _ => panic!(\"forgot to add a token?\"),\n+    }\n+}\n+\n fn prepend_attrs(\n     sess: &ParseSess,\n     attrs: &[ast::Attribute],"}, {"sha": "5e9411327cabdd6d7dc3ea71cac17274008019c4", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -333,6 +333,7 @@ impl<'a> Parser<'a> {\n                         Applicability::MachineApplicable\n                     },\n                 );\n+                self.sess.type_ascription_path_suggestions.borrow_mut().insert(sp);\n             } else if op_pos.line != next_pos.line && maybe_expected_semicolon {\n                 err.span_suggestion(\n                     sp,"}, {"sha": "3aec300d86d4f5dcb6bb6cf386fb3b8c9d1d64e4", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1450,7 +1450,7 @@ impl<'a> Parser<'a> {\n \n     /// Matches `'-' lit | lit` (cf. `ast_validation::AstValidator::check_expr_within_pat`).\n     /// Keep this in sync with `Token::can_begin_literal_maybe_minus`.\n-    pub fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n+    pub(super) fn parse_literal_maybe_minus(&mut self) -> PResult<'a, P<Expr>> {\n         maybe_whole_expr!(self);\n \n         let lo = self.token.span;"}, {"sha": "2509a9792215d553379da4acdf0ce201045c94e1", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,16 +1,17 @@\n pub mod attr;\n+mod diagnostics;\n mod expr;\n+mod generics;\n mod item;\n+mod nonterminal;\n mod pat;\n mod path;\n-mod ty;\n-pub use path::PathStyle;\n-mod diagnostics;\n-mod generics;\n mod stmt;\n-use diagnostics::Error;\n+mod ty;\n \n use crate::lexer::UnmatchedBrace;\n+use diagnostics::Error;\n+pub use path::PathStyle;\n \n use log::debug;\n use rustc_ast::ast::DUMMY_NODE_ID;\n@@ -958,7 +959,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a single token tree from the input.\n-    pub fn parse_token_tree(&mut self) -> TokenTree {\n+    pub(crate) fn parse_token_tree(&mut self) -> TokenTree {\n         match self.token.kind {\n             token::OpenDelim(..) => {\n                 let frame = mem::replace(\n@@ -1017,7 +1018,7 @@ impl<'a> Parser<'a> {\n     /// If the following element can't be a tuple (i.e., it's a function definition), then\n     /// it's not a tuple struct field), and the contents within the parentheses isn't valid,\n     /// so emit a proper diagnostic.\n-    pub fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {\n+    pub(crate) fn parse_visibility(&mut self, fbt: FollowedByType) -> PResult<'a, Visibility> {\n         maybe_whole!(self, NtVis, |x| x);\n \n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));"}, {"sha": "12139771bbfdaa172c9d4cc9f0d7026fd59ab8a1", "filename": "src/librustc_parse/parser/nonterminal.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fnonterminal.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -0,0 +1,163 @@\n+use rustc_ast::ptr::P;\n+use rustc_ast::token::{self, Nonterminal, NonterminalKind, Token};\n+use rustc_ast_pretty::pprust;\n+use rustc_errors::PResult;\n+use rustc_span::symbol::{kw, Ident};\n+\n+use crate::parser::{FollowedByType, Parser, PathStyle};\n+\n+impl<'a> Parser<'a> {\n+    /// Checks whether a non-terminal may begin with a particular token.\n+    ///\n+    /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n+    /// token. Be conservative (return true) if not sure.\n+    pub fn nonterminal_may_begin_with(kind: NonterminalKind, token: &Token) -> bool {\n+        /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n+        fn may_be_ident(nt: &token::Nonterminal) -> bool {\n+            match *nt {\n+                token::NtItem(_) | token::NtBlock(_) | token::NtVis(_) | token::NtLifetime(_) => {\n+                    false\n+                }\n+                _ => true,\n+            }\n+        }\n+\n+        match kind {\n+            NonterminalKind::Expr => {\n+                token.can_begin_expr()\n+                // This exception is here for backwards compatibility.\n+                && !token.is_keyword(kw::Let)\n+            }\n+            NonterminalKind::Ty => token.can_begin_type(),\n+            NonterminalKind::Ident => get_macro_ident(token).is_some(),\n+            NonterminalKind::Literal => token.can_begin_literal_maybe_minus(),\n+            NonterminalKind::Vis => match token.kind {\n+                // The follow-set of :vis + \"priv\" keyword + interpolated\n+                token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n+                _ => token.can_begin_type(),\n+            },\n+            NonterminalKind::Block => match token.kind {\n+                token::OpenDelim(token::Brace) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtItem(_)\n+                    | token::NtPat(_)\n+                    | token::NtTy(_)\n+                    | token::NtIdent(..)\n+                    | token::NtMeta(_)\n+                    | token::NtPath(_)\n+                    | token::NtVis(_) => false, // none of these may start with '{'.\n+                    _ => true,\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::Path | NonterminalKind::Meta => match token.kind {\n+                token::ModSep | token::Ident(..) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtPath(_) | token::NtMeta(_) => true,\n+                    _ => may_be_ident(&nt),\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::Pat => match token.kind {\n+                token::Ident(..) |                  // box, ref, mut, and other identifiers (can stricten)\n+                token::OpenDelim(token::Paren) |    // tuple pattern\n+                token::OpenDelim(token::Bracket) |  // slice pattern\n+                token::BinOp(token::And) |          // reference\n+                token::BinOp(token::Minus) |        // negative literal\n+                token::AndAnd |                     // double reference\n+                token::Literal(..) |                // literal\n+                token::DotDot |                     // range pattern (future compat)\n+                token::DotDotDot |                  // range pattern (future compat)\n+                token::ModSep |                     // path\n+                token::Lt |                         // path (UFCS constant)\n+                token::BinOp(token::Shl) => true,   // path (double UFCS)\n+                token::Interpolated(ref nt) => may_be_ident(nt),\n+                _ => false,\n+            },\n+            NonterminalKind::Lifetime => match token.kind {\n+                token::Lifetime(_) => true,\n+                token::Interpolated(ref nt) => match **nt {\n+                    token::NtLifetime(_) | token::NtTT(_) => true,\n+                    _ => false,\n+                },\n+                _ => false,\n+            },\n+            NonterminalKind::TT | NonterminalKind::Item | NonterminalKind::Stmt => match token.kind\n+            {\n+                token::CloseDelim(_) => false,\n+                _ => true,\n+            },\n+        }\n+    }\n+\n+    pub fn parse_nonterminal(&mut self, kind: NonterminalKind) -> PResult<'a, Nonterminal> {\n+        // Any `Nonterminal` which stores its tokens (currently `NtItem` and `NtExpr`)\n+        // needs to have them force-captured here.\n+        // A `macro_rules!` invocation may pass a captured item/expr to a proc-macro,\n+        // which requires having captured tokens available. Since we cannot determine\n+        // in advance whether or not a proc-macro will be (transitively) invoked,\n+        // we always capture tokens for any `Nonterminal` which needs them.\n+        Ok(match kind {\n+            NonterminalKind::Item => match self.collect_tokens(|this| this.parse_item())? {\n+                (Some(mut item), tokens) => {\n+                    // If we captured tokens during parsing (due to outer attributes),\n+                    // use those.\n+                    if item.tokens.is_none() {\n+                        item.tokens = Some(tokens);\n+                    }\n+                    token::NtItem(item)\n+                }\n+                (None, _) => {\n+                    return Err(self.struct_span_err(self.token.span, \"expected an item keyword\"));\n+                }\n+            },\n+            NonterminalKind::Block => token::NtBlock(self.parse_block()?),\n+            NonterminalKind::Stmt => match self.parse_stmt()? {\n+                Some(s) => token::NtStmt(s),\n+                None => return Err(self.struct_span_err(self.token.span, \"expected a statement\")),\n+            },\n+            NonterminalKind::Pat => token::NtPat(self.parse_pat(None)?),\n+            NonterminalKind::Expr => {\n+                let (mut expr, tokens) = self.collect_tokens(|this| this.parse_expr())?;\n+                // If we captured tokens during parsing (due to outer attributes),\n+                // use those.\n+                if expr.tokens.is_none() {\n+                    expr.tokens = Some(tokens);\n+                }\n+                token::NtExpr(expr)\n+            }\n+            NonterminalKind::Literal => token::NtLiteral(self.parse_literal_maybe_minus()?),\n+            NonterminalKind::Ty => token::NtTy(self.parse_ty()?),\n+            // this could be handled like a token, since it is one\n+            NonterminalKind::Ident => {\n+                if let Some((ident, is_raw)) = get_macro_ident(&self.token) {\n+                    self.bump();\n+                    token::NtIdent(ident, is_raw)\n+                } else {\n+                    let token_str = pprust::token_to_string(&self.token);\n+                    let msg = &format!(\"expected ident, found {}\", &token_str);\n+                    return Err(self.struct_span_err(self.token.span, msg));\n+                }\n+            }\n+            NonterminalKind::Path => token::NtPath(self.parse_path(PathStyle::Type)?),\n+            NonterminalKind::Meta => token::NtMeta(P(self.parse_attr_item()?)),\n+            NonterminalKind::TT => token::NtTT(self.parse_token_tree()),\n+            NonterminalKind::Vis => token::NtVis(self.parse_visibility(FollowedByType::Yes)?),\n+            NonterminalKind::Lifetime => {\n+                if self.check_lifetime() {\n+                    token::NtLifetime(self.expect_lifetime().ident)\n+                } else {\n+                    let token_str = pprust::token_to_string(&self.token);\n+                    let msg = &format!(\"expected a lifetime, found `{}`\", &token_str);\n+                    return Err(self.struct_span_err(self.token.span, msg));\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+/// The token is an identifier, but not `_`.\n+/// We prohibit passing `_` to macros expecting `ident` for now.\n+fn get_macro_ident(token: &Token) -> Option<(Ident, bool)> {\n+    token.ident().filter(|(ident, _)| ident.name != kw::Underscore)\n+}"}, {"sha": "d4e44c54b127405fdcdc4c11fe474dda129938f5", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -125,7 +125,7 @@ impl<'a> Parser<'a> {\n     /// `a::b::C::<D>` (with disambiguator)\n     /// `Fn(Args)` (without disambiguator)\n     /// `Fn::(Args)` (with disambiguator)\n-    pub fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n+    pub(super) fn parse_path(&mut self, style: PathStyle) -> PResult<'a, Path> {\n         maybe_whole!(self, NtPath, |path| {\n             if style == PathStyle::Mod && path.segments.iter().any(|segment| segment.args.is_some())\n             {"}, {"sha": "5c3a5e9987324c93f4c56aab60dbd88bc4797d86", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -21,7 +21,7 @@ use std::mem;\n impl<'a> Parser<'a> {\n     /// Parses a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n-    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+    pub(super) fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n         Ok(self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n@@ -247,7 +247,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block. No inner attributes are allowed.\n-    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n+    pub(super) fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n         let (attrs, block) = self.parse_inner_attrs_and_block()?;\n         if let [.., last] = &*attrs {\n             self.error_on_forbidden_inner_attr(last.span, DEFAULT_INNER_ATTR_FORBIDDEN);"}, {"sha": "cd66b917f232a016e9912d81c1e329dd3d784828", "filename": "src/librustc_parse/parser/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_parse%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fty.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -610,13 +610,13 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn check_lifetime(&mut self) -> bool {\n+    pub(super) fn check_lifetime(&mut self) -> bool {\n         self.expected_tokens.push(TokenType::Lifetime);\n         self.token.is_lifetime()\n     }\n \n     /// Parses a single lifetime `'a` or panics.\n-    pub fn expect_lifetime(&mut self) -> Lifetime {\n+    pub(super) fn expect_lifetime(&mut self) -> Lifetime {\n         if let Some(ident) = self.token.lifetime() {\n             self.bump();\n             Lifetime { ident, id: ast::DUMMY_NODE_ID }"}, {"sha": "d9fa435e3ad680e002780a08b968c5cdb39e9adb", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,7 +9,7 @@ name = \"rustc_passes\"\n path = \"lib.rs\"\n \n [dependencies]\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "55a6d3f76457e3567aab727b1e32ef2a96f296f5", "filename": "src/librustc_passes/layout_test.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_passes%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_passes%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flayout_test.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -82,8 +82,10 @@ impl LayoutTest<'tcx> {\n                         }\n \n                         sym::debug => {\n-                            let normalized_ty =\n-                                self.tcx.normalize_erasing_regions(param_env.with_reveal_all(), ty);\n+                            let normalized_ty = self.tcx.normalize_erasing_regions(\n+                                param_env.with_reveal_all_normalized(self.tcx),\n+                                ty,\n+                            );\n                             self.tcx.sess.span_err(\n                                 item.span,\n                                 &format!(\"layout_of({:?}) = {:#?}\", normalized_ty, *ty_layout),"}, {"sha": "6f543e71b428137a0f1455bfcc9e6e55f31dff96", "filename": "src/librustc_privacy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -17,4 +17,4 @@ rustc_typeck = { path = \"../librustc_typeck\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }"}, {"sha": "fc00050f405182d1eddb93558a470572ed294e4b", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -637,7 +637,7 @@ impl EmbargoVisitor<'tcx> {\n         &mut self,\n         segments: &[hir::PathSegment<'_>],\n     ) {\n-        if let Some([module, segment]) = segments.rchunks_exact(2).next() {\n+        if let [.., module, segment] = segments {\n             if let Some(item) = module\n                 .res\n                 .and_then(|res| res.mod_def_id())"}, {"sha": "64af9c5f1a15244a1c9b74704e552973a5f0235a", "filename": "src/librustc_query_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../librustc_arena\" }\n-log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc-rayon-core = \"0.3.0\"\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "1cb49132ead9cf7f103ed057b25792d0abbdc789", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,7 +12,7 @@ doctest = false\n \n [dependencies]\n bitflags = \"1.2.1\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_arena = { path = \"../librustc_arena\" }\n rustc_middle = { path = \"../librustc_middle\" }"}, {"sha": "44ff4209095418473d9f4a4d749cb9c7f3be9242", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1510,30 +1510,18 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         pat_src: PatternSource,\n         bindings: &mut SmallVec<[(PatBoundCtx, FxHashSet<Ident>); 1]>,\n     ) {\n-        let is_tuple_struct_pat = matches!(pat.kind, PatKind::TupleStruct(_, _));\n-\n         // Visit all direct subpatterns of this pattern.\n         pat.walk(&mut |pat| {\n             debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.kind);\n             match pat.kind {\n                 PatKind::Ident(bmode, ident, ref sub) => {\n-                    if is_tuple_struct_pat && sub.as_ref().filter(|p| p.is_rest()).is_some() {\n-                        // In tuple struct patterns ignore the invalid `ident @ ...`.\n-                        // It will be handled as an error by the AST lowering.\n-                        self.r\n-                            .session\n-                            .delay_span_bug(ident.span, \"ident in tuple pattern is invalid\");\n-                    } else {\n-                        // First try to resolve the identifier as some existing entity,\n-                        // then fall back to a fresh binding.\n-                        let has_sub = sub.is_some();\n-                        let res = self\n-                            .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n-                            .unwrap_or_else(|| {\n-                                self.fresh_binding(ident, pat.id, pat_src, bindings)\n-                            });\n-                        self.r.record_partial_res(pat.id, PartialRes::new(res));\n-                    }\n+                    // First try to resolve the identifier as some existing entity,\n+                    // then fall back to a fresh binding.\n+                    let has_sub = sub.is_some();\n+                    let res = self\n+                        .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n+                        .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n+                    self.r.record_partial_res(pat.id, PartialRes::new(res));\n                 }\n                 PatKind::TupleStruct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct(pat.span));\n@@ -2241,8 +2229,15 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     self.resolve_expr(argument, None);\n                 }\n             }\n-            ExprKind::Type(ref type_expr, _) => {\n-                self.diagnostic_metadata.current_type_ascription.push(type_expr.span);\n+            ExprKind::Type(ref type_expr, ref ty) => {\n+                // `ParseSess::type_ascription_path_suggestions` keeps spans of colon tokens in\n+                // type ascription. Here we are trying to retrieve the span of the colon token as\n+                // well, but only if it's written without spaces `expr:Ty` and therefore confusable\n+                // with `expr::Ty`, only in this case it will match the span from\n+                // `type_ascription_path_suggestions`.\n+                self.diagnostic_metadata\n+                    .current_type_ascription\n+                    .push(type_expr.span.between(ty.span));\n                 visit::walk_expr(self, expr);\n                 self.diagnostic_metadata.current_type_ascription.pop();\n             }"}, {"sha": "ec6dbb070dfa8cdd1ae10fadfa884924a8b83ba6", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "modified", "additions": 117, "deletions": 78, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::PrimTy;\n use rustc_session::config::nightly_options;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::Span;\n+use rustc_span::{BytePos, Span};\n \n use log::debug;\n \n@@ -223,13 +223,31 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n         if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n             let enum_candidates =\n                 self.r.lookup_import_candidates(ident, ns, &self.parent_scope, is_enum_variant);\n-            let mut enum_candidates = enum_candidates\n-                .iter()\n-                .map(|suggestion| import_candidate_to_enum_paths(&suggestion))\n-                .collect::<Vec<_>>();\n-            enum_candidates.sort();\n \n             if !enum_candidates.is_empty() {\n+                if let (PathSource::Type, Some(span)) =\n+                    (source, self.diagnostic_metadata.current_type_ascription.last())\n+                {\n+                    if self\n+                        .r\n+                        .session\n+                        .parse_sess\n+                        .type_ascription_path_suggestions\n+                        .borrow()\n+                        .contains(span)\n+                    {\n+                        // Already reported this issue on the lhs of the type ascription.\n+                        err.delay_as_bug();\n+                        return (err, candidates);\n+                    }\n+                }\n+\n+                let mut enum_candidates = enum_candidates\n+                    .iter()\n+                    .map(|suggestion| import_candidate_to_enum_paths(&suggestion))\n+                    .collect::<Vec<_>>();\n+                enum_candidates.sort();\n+\n                 // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n                 // (that it's a variant) for E0573 \"expected type, found variant\".\n                 let preamble = if res.is_none() {\n@@ -484,10 +502,21 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n             match source {\n                 PathSource::Expr(Some(\n                     parent @ Expr { kind: ExprKind::Field(..) | ExprKind::MethodCall(..), .. },\n-                )) => {\n-                    path_sep(err, &parent);\n-                }\n-                PathSource::Expr(None) if followed_by_brace => {\n+                )) if path_sep(err, &parent) => {}\n+                PathSource::Expr(\n+                    None\n+                    | Some(Expr {\n+                        kind:\n+                            ExprKind::Path(..)\n+                            | ExprKind::Binary(..)\n+                            | ExprKind::Unary(..)\n+                            | ExprKind::If(..)\n+                            | ExprKind::While(..)\n+                            | ExprKind::ForLoop(..)\n+                            | ExprKind::Match(..),\n+                        ..\n+                    }),\n+                ) if followed_by_brace => {\n                     if let Some(sp) = closing_brace {\n                         err.multipart_suggestion(\n                             \"surround the struct literal with parentheses\",\n@@ -508,11 +537,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                         );\n                     }\n                 }\n-                PathSource::Expr(\n-                    None | Some(Expr { kind: ExprKind::Call(..) | ExprKind::Path(..), .. }),\n-                )\n-                | PathSource::TupleStruct(_)\n-                | PathSource::Pat => {\n+                PathSource::Expr(_) | PathSource::TupleStruct(_) | PathSource::Pat => {\n                     let span = match &source {\n                         PathSource::Expr(Some(Expr {\n                             span, kind: ExprKind::Call(_, _), ..\n@@ -593,6 +618,24 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                 Res::Def(DefKind::Enum, def_id),\n                 PathSource::TupleStruct(_) | PathSource::Expr(..),\n             ) => {\n+                if self\n+                    .diagnostic_metadata\n+                    .current_type_ascription\n+                    .last()\n+                    .map(|sp| {\n+                        self.r\n+                            .session\n+                            .parse_sess\n+                            .type_ascription_path_suggestions\n+                            .borrow()\n+                            .contains(&sp)\n+                    })\n+                    .unwrap_or(false)\n+                {\n+                    err.delay_as_bug();\n+                    // We already suggested changing `:` into `::` during parsing.\n+                    return false;\n+                }\n                 if let Some(variants) = self.collect_enum_variants(def_id) {\n                     if !variants.is_empty() {\n                         let msg = if variants.len() == 1 {\n@@ -609,7 +652,7 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n                         );\n                     }\n                 } else {\n-                    err.note(\"did you mean to use one of the enum's variants?\");\n+                    err.note(\"you might have meant to use one of the enum's variants\");\n                 }\n             }\n             (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n@@ -829,77 +872,73 @@ impl<'a> LateResolutionVisitor<'a, '_, '_> {\n     fn type_ascription_suggestion(&self, err: &mut DiagnosticBuilder<'_>, base_span: Span) {\n         let sm = self.r.session.source_map();\n         let base_snippet = sm.span_to_snippet(base_span);\n-        if let Some(sp) = self.diagnostic_metadata.current_type_ascription.last() {\n-            let mut sp = *sp;\n-            loop {\n-                // Try to find the `:`; bail on first non-':' / non-whitespace.\n-                sp = sm.next_point(sp);\n-                if let Ok(snippet) = sm.span_to_snippet(sp.to(sm.next_point(sp))) {\n-                    let line_sp = sm.lookup_char_pos(sp.hi()).line;\n-                    let line_base_sp = sm.lookup_char_pos(base_span.lo()).line;\n-                    if snippet == \":\" {\n-                        let mut show_label = true;\n-                        if line_sp != line_base_sp {\n-                            err.span_suggestion_short(\n-                                sp,\n-                                \"did you mean to use `;` here instead?\",\n-                                \";\".to_string(),\n+        if let Some(&sp) = self.diagnostic_metadata.current_type_ascription.last() {\n+            if let Ok(snippet) = sm.span_to_snippet(sp) {\n+                let len = snippet.trim_end().len() as u32;\n+                if snippet.trim() == \":\" {\n+                    let colon_sp =\n+                        sp.with_lo(sp.lo() + BytePos(len - 1)).with_hi(sp.lo() + BytePos(len));\n+                    let mut show_label = true;\n+                    if sm.is_multiline(sp) {\n+                        err.span_suggestion_short(\n+                            colon_sp,\n+                            \"maybe you meant to write `;` here\",\n+                            \";\".to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        let after_colon_sp =\n+                            self.get_colon_suggestion_span(colon_sp.shrink_to_hi());\n+                        if snippet.len() == 1 {\n+                            // `foo:bar`\n+                            err.span_suggestion(\n+                                colon_sp,\n+                                \"maybe you meant to write a path separator here\",\n+                                \"::\".to_string(),\n                                 Applicability::MaybeIncorrect,\n                             );\n-                        } else {\n-                            let colon_sp = self.get_colon_suggestion_span(sp);\n-                            let after_colon_sp =\n-                                self.get_colon_suggestion_span(colon_sp.shrink_to_hi());\n-                            if !sm\n-                                .span_to_snippet(after_colon_sp)\n-                                .map(|s| s == \" \")\n-                                .unwrap_or(false)\n+                            show_label = false;\n+                            if !self\n+                                .r\n+                                .session\n+                                .parse_sess\n+                                .type_ascription_path_suggestions\n+                                .borrow_mut()\n+                                .insert(colon_sp)\n                             {\n-                                err.span_suggestion(\n-                                    colon_sp,\n-                                    \"maybe you meant to write a path separator here\",\n-                                    \"::\".to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                show_label = false;\n+                                err.delay_as_bug();\n                             }\n-                            if let Ok(base_snippet) = base_snippet {\n-                                let mut sp = after_colon_sp;\n-                                for _ in 0..100 {\n-                                    // Try to find an assignment\n-                                    sp = sm.next_point(sp);\n-                                    let snippet = sm.span_to_snippet(sp.to(sm.next_point(sp)));\n-                                    match snippet {\n-                                        Ok(ref x) if x.as_str() == \"=\" => {\n-                                            err.span_suggestion(\n-                                                base_span,\n-                                                \"maybe you meant to write an assignment here\",\n-                                                format!(\"let {}\", base_snippet),\n-                                                Applicability::MaybeIncorrect,\n-                                            );\n-                                            show_label = false;\n-                                            break;\n-                                        }\n-                                        Ok(ref x) if x.as_str() == \"\\n\" => break,\n-                                        Err(_) => break,\n-                                        Ok(_) => {}\n+                        }\n+                        if let Ok(base_snippet) = base_snippet {\n+                            let mut sp = after_colon_sp;\n+                            for _ in 0..100 {\n+                                // Try to find an assignment\n+                                sp = sm.next_point(sp);\n+                                let snippet = sm.span_to_snippet(sp.to(sm.next_point(sp)));\n+                                match snippet {\n+                                    Ok(ref x) if x.as_str() == \"=\" => {\n+                                        err.span_suggestion(\n+                                            base_span,\n+                                            \"maybe you meant to write an assignment here\",\n+                                            format!(\"let {}\", base_snippet),\n+                                            Applicability::MaybeIncorrect,\n+                                        );\n+                                        show_label = false;\n+                                        break;\n                                     }\n+                                    Ok(ref x) if x.as_str() == \"\\n\" => break,\n+                                    Err(_) => break,\n+                                    Ok(_) => {}\n                                 }\n                             }\n                         }\n-                        if show_label {\n-                            err.span_label(\n-                                base_span,\n-                                \"expecting a type here because of type ascription\",\n-                            );\n-                        }\n-                        break;\n-                    } else if !snippet.trim().is_empty() {\n-                        debug!(\"tried to find type ascription `:` token, couldn't find it\");\n-                        break;\n                     }\n-                } else {\n-                    break;\n+                    if show_label {\n+                        err.span_label(\n+                            base_span,\n+                            \"expecting a type here because of type ascription\",\n+                        );\n+                    }\n                 }\n             }\n         }"}, {"sha": "ccc7e16ae4cf667059a7e3c192d059311ce06de7", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1020,7 +1020,7 @@ impl<'a> Resolver<'a> {\n         }\n         if let Some(depr) = &ext.deprecation {\n             let path = pprust::path_to_string(&path);\n-            let (message, lint) = stability::deprecation_message(depr, &path);\n+            let (message, lint) = stability::deprecation_message(depr, \"macro\", &path);\n             stability::early_report_deprecation(\n                 &mut self.lint_buffer,\n                 &message,"}, {"sha": "7a5ae0ace3ae67e4f4500054d22c1f3a6dc0ac81", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,7 +9,7 @@ name = \"rustc_save_analysis\"\n path = \"lib.rs\"\n \n [dependencies]\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }"}, {"sha": "35c227df8500a98832284eae2e53009f0b704ab9", "filename": "src/librustc_session/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ path = \"lib.rs\"\n [dependencies]\n bitflags = \"1.2.1\"\n getopts = \"0.2\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "9fcdd46539c46f15aee8c50306f9f58af128ea18", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1717,7 +1717,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         }\n \n         // `-Z instrument-coverage` implies:\n-        //   * `-Z symbol-mangling-version=v0` - to ensure consistent and reversable name mangling.\n+        //   * `-Z symbol-mangling-version=v0` - to ensure consistent and reversible name mangling.\n         //     Note, LLVM coverage tools can analyze coverage over multiple runs, including some\n         //     changes to source code; so mangled names must be consistent across compilations.\n         //   * `-C link-dead-code` - so unexecuted code is still counted as zero, rather than be"}, {"sha": "504490d938cfa576d77287643df8fe06111a7ffb", "filename": "src/librustc_session/filesearch.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Ffilesearch.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -117,28 +117,22 @@ pub fn make_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n \n pub fn get_or_default_sysroot() -> PathBuf {\n     // Follow symlinks.  If the resolved path is relative, make it absolute.\n-    fn canonicalize(path: Option<PathBuf>) -> Option<PathBuf> {\n-        path.and_then(|path| {\n-            match fs::canonicalize(&path) {\n-                // See comments on this target function, but the gist is that\n-                // gcc chokes on verbatim paths which fs::canonicalize generates\n-                // so we try to avoid those kinds of paths.\n-                Ok(canon) => Some(fix_windows_verbatim_for_gcc(&canon)),\n-                Err(e) => panic!(\"failed to get realpath: {}\", e),\n-            }\n-        })\n+    fn canonicalize(path: PathBuf) -> PathBuf {\n+        let path = fs::canonicalize(&path).unwrap_or(path);\n+        // See comments on this target function, but the gist is that\n+        // gcc chokes on verbatim paths which fs::canonicalize generates\n+        // so we try to avoid those kinds of paths.\n+        fix_windows_verbatim_for_gcc(&path)\n     }\n \n     match env::current_exe() {\n-        Ok(exe) => match canonicalize(Some(exe)) {\n-            Some(mut p) => {\n-                p.pop();\n-                p.pop();\n-                p\n-            }\n-            None => panic!(\"can't determine value for sysroot\"),\n-        },\n-        Err(ref e) => panic!(format!(\"failed to get current_exe: {}\", e)),\n+        Ok(exe) => {\n+            let mut p = canonicalize(exe);\n+            p.pop();\n+            p.pop();\n+            p\n+        }\n+        Err(e) => panic!(\"failed to get current_exe: {}\", e),\n     }\n }\n "}, {"sha": "144a06a4916bd3a64073fb9a8e3caa6acf0dd9b9", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -398,7 +398,7 @@ declare_lint! {\n }\n \n declare_lint! {\n-    pub INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+    pub BROKEN_INTRA_DOC_LINKS,\n     Warn,\n     \"failures in resolving intra-doc link targets\"\n }\n@@ -601,7 +601,7 @@ declare_lint_pass! {\n         ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n         UNSTABLE_NAME_COLLISIONS,\n         IRREFUTABLE_LET_PATTERNS,\n-        INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        BROKEN_INTRA_DOC_LINKS,\n         INVALID_CODEBLOCK_ATTRIBUTES,\n         MISSING_CRATE_LEVEL_DOCS,\n         MISSING_DOC_CODE_EXAMPLES,"}, {"sha": "80164840334a23ba3de4724190d8439ccd0b922e", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -883,7 +883,7 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"instrument the generated code to support LLVM source-based code coverage \\\n         reports (note, the compiler build config must include `profiler = true`, \\\n         and is mutually exclusive with `-C profile-generate`/`-C profile-use`); \\\n-        implies `-C link-dead-code` (unless explicitly disabled)` and\n+        implies `-C link-dead-code` (unless explicitly disabled)` and \\\n         `-Z symbol-mangling-version=v0`; and disables/overrides some optimization \\\n         options (default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],"}, {"sha": "9cdb7e966fef860d41608cca0e6a46e594cda302", "filename": "src/librustc_session/parse.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fparse.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -63,7 +63,7 @@ impl GatedSpans {\n \n #[derive(Default)]\n pub struct SymbolGallery {\n-    /// All symbols occurred and their first occurrance span.\n+    /// All symbols occurred and their first occurrence span.\n     pub symbols: Lock<BTreeMap<Symbol, Span>>,\n }\n \n@@ -138,6 +138,8 @@ pub struct ParseSess {\n     pub reached_eof: Lock<bool>,\n     /// Environment variables accessed during the build and their values when they exist.\n     pub env_depinfo: Lock<FxHashSet<(Symbol, Option<Symbol>)>>,\n+    /// All the type ascriptions expressions that have had a suggestion for likely path typo.\n+    pub type_ascription_path_suggestions: Lock<FxHashSet<Span>>,\n }\n \n impl ParseSess {\n@@ -164,6 +166,7 @@ impl ParseSess {\n             symbol_gallery: SymbolGallery::default(),\n             reached_eof: Lock::new(false),\n             env_depinfo: Default::default(),\n+            type_ascription_path_suggestions: Default::default(),\n         }\n     }\n "}, {"sha": "e9077f40859097309703b30c8659d3ee8b8aef29", "filename": "src/librustc_session/session.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_session%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fsession.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1294,19 +1294,19 @@ pub fn build_session(\n // commandline argument, you can do so here.\n fn validate_commandline_args_with_session_available(sess: &Session) {\n     // Since we don't know if code in an rlib will be linked to statically or\n-    // dynamically downstream, rustc generates `__imp_` symbols that help the\n-    // MSVC linker deal with this lack of knowledge (#27438). Unfortunately,\n+    // dynamically downstream, rustc generates `__imp_` symbols that help linkers\n+    // on Windows deal with this lack of knowledge (#27438). Unfortunately,\n     // these manually generated symbols confuse LLD when it tries to merge\n-    // bitcode during ThinLTO. Therefore we disallow dynamic linking on MSVC\n+    // bitcode during ThinLTO. Therefore we disallow dynamic linking on Windows\n     // when compiling for LLD ThinLTO. This way we can validly just not generate\n     // the `dllimport` attributes and `__imp_` symbols in that case.\n     if sess.opts.cg.linker_plugin_lto.enabled()\n         && sess.opts.cg.prefer_dynamic\n-        && sess.target.target.options.is_like_msvc\n+        && sess.target.target.options.is_like_windows\n     {\n         sess.err(\n             \"Linker plugin based LTO is not supported together with \\\n-                  `-C prefer-dynamic` when targeting MSVC\",\n+                  `-C prefer-dynamic` when targeting Windows-like targets\",\n         );\n     }\n "}, {"sha": "2db417ce0e12953ed44fb532cc71bde91fcc6507", "filename": "src/librustc_span/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_span%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_span%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -18,6 +18,6 @@ rustc_arena = { path = \"../librustc_arena\" }\n scoped-tls = \"1.0\"\n unicode-width = \"0.1.4\"\n cfg-if = \"0.1.2\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n sha-1 = \"0.8\"\n md-5 = \"0.8\""}, {"sha": "a03ac4e1fdba1638c7f5adff9bcb76f2094db332", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -891,7 +891,7 @@ impl UseSpecializedDecodable for ExpnId {}\n \n #[derive(Default)]\n pub struct HygieneEncodeContext {\n-    /// All `SyntaxContexts` for which we have writen `SyntaxContextData` into crate metadata.\n+    /// All `SyntaxContexts` for which we have written `SyntaxContextData` into crate metadata.\n     /// This is `None` after we finish encoding `SyntaxContexts`, to ensure\n     /// that we don't accidentally try to encode any more `SyntaxContexts`\n     serialized_ctxts: Lock<FxHashSet<SyntaxContext>>,\n@@ -961,7 +961,7 @@ pub struct HygieneDecodeContext {\n     // Maps serialized `SyntaxContext` ids to a `SyntaxContext` in the current\n     // global `HygieneData`. When we deserialize a `SyntaxContext`, we need to create\n     // a new id in the global `HygieneData`. This map tracks the ID we end up picking,\n-    // so that multiple occurences of the same serialized id are decoded to the same\n+    // so that multiple occurrences of the same serialized id are decoded to the same\n     // `SyntaxContext`\n     remapped_ctxts: Lock<Vec<Option<SyntaxContext>>>,\n     // The same as `remapepd_ctxts`, but for `ExpnId`s"}, {"sha": "98776a0478237495e80c53b76f93c7225ee39d8a", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1043,6 +1043,7 @@ symbols! {\n         stop_after_dataflow,\n         str,\n         str_alloc,\n+        string_type,\n         stringify,\n         struct_field_attributes,\n         struct_inherit,"}, {"sha": "757d86bd95afdbdf3b5b0c3c7803c1aca91c14d8", "filename": "src/librustc_symbol_mangling/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_symbol_mangling%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_symbol_mangling%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n punycode = \"0.4.0\"\n rustc-demangle = \"0.1.16\"\n "}, {"sha": "56ee492de87abf790b15a780904192e824bafddc", "filename": "src/librustc_symbol_mangling/v0.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_symbol_mangling%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_symbol_mangling%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Fv0.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -271,7 +271,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         let key = self.tcx.def_key(impl_def_id);\n         let parent_def_id = DefId { index: key.parent.unwrap(), ..impl_def_id };\n \n-        let mut param_env = self.tcx.param_env(impl_def_id).with_reveal_all();\n+        let mut param_env = self.tcx.param_env_reveal_all_normalized(impl_def_id);\n         if !substs.is_empty() {\n             param_env = param_env.subst(self.tcx, substs);\n         }\n@@ -636,9 +636,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n                 }\n                 GenericArgKind::Const(c) => {\n                     self.push(\"K\");\n-                    // FIXME(const_generics) implement `ty::print::Print` on `ty::Const`.\n-                    // self = c.print(self)?;\n-                    self = self.print_const(c)?;\n+                    self = c.print(self)?;\n                 }\n             }\n         }"}, {"sha": "21796e8498568436fa5bab7129cfdfd547c8f146", "filename": "src/librustc_target/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_target%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_target%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -10,7 +10,7 @@ path = \"lib.rs\"\n \n [dependencies]\n bitflags = \"1.2.1\"\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../librustc_serialize\" }"}, {"sha": "a8c78f057fc8a1333ad9f8aa08c5a9b8a425a529", "filename": "src/librustc_target/spec/thumbv4t_none_eabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_target%2Fspec%2Fthumbv4t_none_eabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_target%2Fspec%2Fthumbv4t_none_eabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fthumbv4t_none_eabi.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -29,7 +29,7 @@ pub fn target() -> TargetResult {\n          * native integers are 32-bit\n          * All other elements are default\n          */\n-        data_layout: \"e-S64-p:32:32-i64:64-m:e-n32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64\".to_string(),\n         linker_flavor: LinkerFlavor::Ld,\n         options: TargetOptions {\n             linker: Some(\"arm-none-eabi-ld\".to_string()),"}, {"sha": "c43fe3f2c0c89db989228afd0516ab6ed882f105", "filename": "src/librustc_trait_selection/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_trait_selection%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_trait_selection%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,7 +11,7 @@ doctest = false\n \n [dependencies]\n rustc_parse_format = { path = \"../librustc_parse_format\" }\n-log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "05a0c52badb7adb0d17576caa282f9f70cf5d7a5", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -802,6 +802,38 @@ impl AutoTraitFinder<'tcx> {\n                         _ => {}\n                     };\n                 }\n+                ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                    let evaluate = |c: &'tcx ty::Const<'tcx>| {\n+                        if let ty::ConstKind::Unevaluated(def, substs, promoted) = c.val {\n+                            match select.infcx().const_eval_resolve(\n+                                obligation.param_env,\n+                                def,\n+                                substs,\n+                                promoted,\n+                                Some(obligation.cause.span),\n+                            ) {\n+                                Ok(val) => Ok(ty::Const::from_value(select.tcx(), val, c.ty)),\n+                                Err(err) => Err(err),\n+                            }\n+                        } else {\n+                            Ok(c)\n+                        }\n+                    };\n+\n+                    match (evaluate(c1), evaluate(c2)) {\n+                        (Ok(c1), Ok(c2)) => {\n+                            match select\n+                                .infcx()\n+                                .at(&obligation.cause, obligation.param_env)\n+                                .eq(c1, c2)\n+                            {\n+                                Ok(_) => (),\n+                                Err(_) => return false,\n+                            }\n+                        }\n+                        _ => return false,\n+                    }\n+                }\n                 _ => panic!(\"Unexpected predicate {:?} {:?}\", ty, predicate),\n             };\n         }"}, {"sha": "f8487982e3d49e0057d0263e7e6c41d7ccc36cf8", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,7 +9,7 @@ name = \"rustc_traits\"\n path = \"lib.rs\"\n \n [dependencies]\n-log = { version = \"0.4\" }\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }"}, {"sha": "6cdb3530002783ce4e61c47673d174ecd8853d6d", "filename": "src/librustc_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -9,7 +9,7 @@ name = \"rustc_ty\"\n path = \"lib.rs\"\n \n [dependencies]\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "1e0c4055af3c5a476a1dec21b5e9bf042e18ff62", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -137,7 +137,7 @@ fn resolve_associated_item<'tcx>(\n                 });\n \n             let substs = tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = param_env.with_reveal_all();\n+                let param_env = param_env.with_reveal_all_normalized(tcx);\n                 let substs = rcvr_substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(\n                     &infcx,"}, {"sha": "dfb28b473ff267c240981ae9f3bf78a58c4dcc33", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -276,6 +276,10 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n     traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n }\n \n+fn param_env_reveal_all_normalized(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n+    tcx.param_env(def_id).with_reveal_all_normalized(tcx)\n+}\n+\n fn crate_disambiguator(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateDisambiguator {\n     assert_eq!(crate_num, LOCAL_CRATE);\n     tcx.sess.local_crate_disambiguator()\n@@ -502,6 +506,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         adt_sized_constraint,\n         def_span,\n         param_env,\n+        param_env_reveal_all_normalized,\n         trait_of_item,\n         crate_disambiguator,\n         original_crate_name,"}, {"sha": "963deda162d62e61e3b3a35e9c1480f80a47f531", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,7 +12,7 @@ doctest = false\n \n [dependencies]\n rustc_arena = { path = \"../librustc_arena\" }\n-log = \"0.4\"\n+log = { package = \"tracing\", version = \"0.1\" }\n rustc_middle = { path = \"../librustc_middle\" }\n rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "db8cdfc5b20d65ea7160c9b6f3bcc3637d38762f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -456,7 +456,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         //\n         // Both of these trigger a special `CoerceUnsized`-related error (E0376)\n         //\n-        // We can take advantage of this fact to avoid performing unecessary work.\n+        // We can take advantage of this fact to avoid performing unnecessary work.\n         // If either `source` or `target` is a type variable, then any applicable impl\n         // would need to be generic over the self-type (`impl<T> CoerceUnsized<SomeType> for T`)\n         // or generic over the `CoerceUnsized` type parameter (`impl<T> CoerceUnsized<T> for"}, {"sha": "e69102d1995d3f05d4d85d58600ae15f39ee3218", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -678,6 +678,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .collect::<Vec<(usize, String)>>();\n                     for ((span, empty_where), obligations) in type_params.into_iter() {\n                         restrict_type_params = true;\n+                        // #74886: Sort here so that the output is always the same.\n+                        let mut obligations = obligations.into_iter().collect::<Vec<_>>();\n+                        obligations.sort();\n                         err.span_suggestion_verbose(\n                             span,\n                             &format!(\n@@ -688,7 +691,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             format!(\n                                 \"{} {}\",\n                                 if empty_where { \" where\" } else { \",\" },\n-                                obligations.into_iter().collect::<Vec<_>>().join(\", \")\n+                                obligations.join(\", \")\n                             ),\n                             Applicability::MaybeIncorrect,\n                         );"}, {"sha": "fd516c88ec61aac2896f340e66d4baee1236c065", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -562,7 +562,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                    on the left and may require reallocation. This \\\n                    requires ownership of the string on the left\";\n \n-        let is_std_string = |ty| &format!(\"{:?}\", ty) == \"std::string::String\";\n+        let string_type = self.tcx.get_diagnostic_item(sym::string_type);\n+        let is_std_string = |ty: Ty<'tcx>| match ty.ty_adt_def() {\n+            Some(ty_def) => Some(ty_def.did) == string_type,\n+            None => false,\n+        };\n \n         match (&lhs_ty.kind, &rhs_ty.kind) {\n             (&Ref(_, l_ty, _), &Ref(_, r_ty, _)) // &str or &String + &str, &String or &&str"}, {"sha": "9c7ea34bf51b6b89c545223c5338f92b19e9e964", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -345,7 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             debug!(\"inspecting {:?}\", expected);\n \n             debug!(\"current discriminant is Ref, inserting implicit deref\");\n-            // Preserve the reference type. We'll need it later during HAIR lowering.\n+            // Preserve the reference type. We'll need it later during THIR lowering.\n             pat_adjustments.push(expected);\n \n             expected = inner_ty;"}, {"sha": "8715dacb324b0974768401026899425226cbfe4e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -858,7 +858,6 @@ fn convert_variant(\n         _ => false,\n     };\n     ty::VariantDef::new(\n-        tcx,\n         ident,\n         variant_did.map(LocalDefId::to_def_id),\n         ctor_did.map(LocalDefId::to_def_id),\n@@ -868,6 +867,10 @@ fn convert_variant(\n         adt_kind,\n         parent_did.to_def_id(),\n         recovered,\n+        adt_kind == AdtKind::Struct && tcx.has_attr(parent_did.to_def_id(), sym::non_exhaustive)\n+            || variant_did.map_or(false, |variant_did| {\n+                tcx.has_attr(variant_did.to_def_id(), sym::non_exhaustive)\n+            }),\n     )\n }\n "}, {"sha": "b810c9824ce66eb5379362cbd49857f29b7037ca", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -161,6 +161,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_sig(current_item, tcx.fn_sig(def_id), self.covariant);\n             }\n \n+            ty::Error(_) => {}\n             _ => {\n                 span_bug!(\n                     tcx.def_span(def_id),"}, {"sha": "9c44d27447db8614445e2073acb3a640db25f426", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -430,14 +430,14 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     }\n \n     // Converts the calculated ParamEnv and lifetime information to a clean::Generics, suitable for\n-    // display on the docs page. Cleaning the Predicates produces sub-optimal WherePredicate's,\n+    // display on the docs page. Cleaning the Predicates produces sub-optimal `WherePredicate`s,\n     // so we fix them up:\n     //\n     // * Multiple bounds for the same type are coalesced into one: e.g., 'T: Copy', 'T: Debug'\n     // becomes 'T: Copy + Debug'\n     // * Fn bounds are handled specially - instead of leaving it as 'T: Fn(), <T as Fn::Output> =\n     // K', we use the dedicated syntax 'T: Fn() -> K'\n-    // * We explcitly add a '?Sized' bound if we didn't find any 'Sized' predicates for a type\n+    // * We explicitly add a '?Sized' bound if we didn't find any 'Sized' predicates for a type\n     fn param_env_to_generics(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -480,6 +480,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 .clean(self.cx)\n                 .params;\n \n+        debug!(\n+            \"param_env_to_generics({:?}): generic_params={:?}\",\n+            param_env_def_id, generic_params\n+        );\n+\n         let mut has_sized = FxHashSet::default();\n         let mut ty_to_bounds: FxHashMap<_, FxHashSet<_>> = Default::default();\n         let mut lifetime_to_bounds: FxHashMap<_, FxHashSet<_>> = Default::default();\n@@ -588,7 +593,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                         .args;\n \n                                     match args {\n-                                        // Convert somethiung like '<T as Iterator::Item> = u8'\n+                                        // Convert something like '<T as Iterator::Item> = u8'\n                                         // to 'T: Iterator<Item=u8>'\n                                         GenericArgs::AngleBracketed {\n                                             ref mut bindings, ..\n@@ -712,7 +717,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n     // since FxHasher has different behavior for 32-bit and 64-bit platforms.\n     //\n     // Obviously, it's extremely undesirable for documentation rendering\n-    // to be depndent on the platform it's run on. Apart from being confusing\n+    // to be dependent on the platform it's run on. Apart from being confusing\n     // to end users, it makes writing tests much more difficult, as predicates\n     // can appear in any order in the final result.\n     //"}, {"sha": "5b048372624a4a9ff399d552cac939cc5350804f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -716,11 +716,11 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n         // Bounds in the type_params and lifetimes fields are repeated in the\n         // predicates field (see rustc_typeck::collect::ty_generics), so remove\n         // them.\n-        let stripped_typarams = gens\n+        let stripped_params = gens\n             .params\n             .iter()\n             .filter_map(|param| match param.kind {\n-                ty::GenericParamDefKind::Lifetime => None,\n+                ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n                 ty::GenericParamDefKind::Type { synthetic, .. } => {\n                     if param.name == kw::SelfUpper {\n                         assert_eq!(param.index, 0);\n@@ -732,7 +732,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                     }\n                     Some(param.clean(cx))\n                 }\n-                ty::GenericParamDefKind::Const { .. } => None,\n+                ty::GenericParamDefKind::Const { .. } => Some(param.clean(cx)),\n             })\n             .collect::<Vec<GenericParamDef>>();\n \n@@ -844,8 +844,10 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n \n         // Run through the type parameters again and insert a ?Sized\n         // unbound for any we didn't find to be Sized.\n-        for tp in &stripped_typarams {\n-            if !sized_params.contains(&tp.name) {\n+        for tp in &stripped_params {\n+            if matches!(tp.kind, types::GenericParamDefKind::Type { .. })\n+                && !sized_params.contains(&tp.name)\n+            {\n                 where_predicates.push(WP::BoundPredicate {\n                     ty: Type::Generic(tp.name.clone()),\n                     bounds: vec![GenericBound::maybe_sized(cx)],\n@@ -858,16 +860,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n         // and instead see `where T: Foo + Bar + Sized + 'a`\n \n         Generics {\n-            params: gens\n-                .params\n-                .iter()\n-                .flat_map(|param| match param.kind {\n-                    ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n-                    ty::GenericParamDefKind::Type { .. } => None,\n-                    ty::GenericParamDefKind::Const { .. } => Some(param.clean(cx)),\n-                })\n-                .chain(simplify::ty_params(stripped_typarams).into_iter())\n-                .collect(),\n+            params: stripped_params,\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n         }\n     }"}, {"sha": "990189f6ea04dd54da709737eaa198fdab113635", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -12,7 +12,6 @@\n //! bounds by special casing scenarios such as these. Fun!\n \n use std::collections::BTreeMap;\n-use std::mem;\n \n use rustc_hir::def_id::DefId;\n use rustc_middle::ty;\n@@ -118,18 +117,6 @@ pub fn merge_bounds(\n     })\n }\n \n-pub fn ty_params(mut params: Vec<clean::GenericParamDef>) -> Vec<clean::GenericParamDef> {\n-    for param in &mut params {\n-        match param.kind {\n-            clean::GenericParamDefKind::Type { ref mut bounds, .. } => {\n-                *bounds = mem::take(bounds);\n-            }\n-            _ => panic!(\"expected only type parameters\"),\n-        }\n-    }\n-    params\n-}\n-\n fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId) -> bool {\n     if child == trait_ {\n         return true;"}, {"sha": "89549eae2cb0e7bfdb6a18eb84efb8cffeae155a", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -32,8 +32,9 @@ use crate::clean::inline;\n use crate::clean::types::Type::{QPath, ResolvedPath};\n use crate::core::DocContext;\n use crate::doctree;\n-use crate::html::item_type::ItemType;\n-use crate::html::render::{cache, ExternalLocation};\n+use crate::formats::cache::cache;\n+use crate::formats::item_type::ItemType;\n+use crate::html::render::cache::ExternalLocation;\n \n use self::FnRetTy::*;\n use self::ItemEnum::*;\n@@ -1172,7 +1173,7 @@ impl GetDefId for Type {\n     fn def_id(&self) -> Option<DefId> {\n         match *self {\n             ResolvedPath { did, .. } => Some(did),\n-            Primitive(p) => crate::html::render::cache().primitive_locations.get(&p).cloned(),\n+            Primitive(p) => cache().primitive_locations.get(&p).cloned(),\n             BorrowedRef { type_: box Generic(..), .. } => {\n                 Primitive(PrimitiveType::Reference).def_id()\n             }"}, {"sha": "4f751decc8090a2bbeb16ca3f05a67b6112871dc", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -4,6 +4,9 @@ use std::ffi::OsStr;\n use std::fmt;\n use std::path::PathBuf;\n \n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::middle::privacy::AccessLevels;\n use rustc_session::config::{self, parse_crate_types_from_list, parse_externs, CrateType};\n use rustc_session::config::{\n     build_codegen_options, build_debugging_options, get_cmd_lint_options, host_triple,\n@@ -249,6 +252,20 @@ pub struct RenderOptions {\n     pub document_hidden: bool,\n }\n \n+/// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n+/// Later on moved into `CACHE_KEY`.\n+#[derive(Default, Clone)]\n+pub struct RenderInfo {\n+    pub inlined: FxHashSet<DefId>,\n+    pub external_paths: crate::core::ExternalPaths,\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+    pub access_levels: AccessLevels<DefId>,\n+    pub deref_trait_did: Option<DefId>,\n+    pub deref_mut_trait_did: Option<DefId>,\n+    pub owned_box_did: Option<DefId>,\n+    pub output_format: Option<OutputFormat>,\n+}\n+\n impl Options {\n     /// Parses the given command-line for options. If an error message or other early-return has\n     /// been printed, returns `Err` with the exit code.\n@@ -491,7 +508,7 @@ impl Options {\n         let output_format = match matches.opt_str(\"output-format\") {\n             Some(s) => match OutputFormat::try_from(s.as_str()) {\n                 Ok(o) => {\n-                    if o.is_json() && !show_coverage {\n+                    if o.is_json() && !(show_coverage || nightly_options::is_nightly_build()) {\n                         diag.struct_err(\"json output format isn't supported for doc generation\")\n                             .emit();\n                         return Err(1);\n@@ -609,7 +626,9 @@ fn check_deprecated_options(matches: &getopts::Matches, diag: &rustc_errors::Han\n \n     for flag in deprecated_flags.iter() {\n         if matches.opt_present(flag) {\n-            if *flag == \"output-format\" && matches.opt_present(\"show-coverage\") {\n+            if *flag == \"output-format\"\n+                && (matches.opt_present(\"show-coverage\") || nightly_options::is_nightly_build())\n+            {\n                 continue;\n             }\n             let mut err ="}, {"sha": "cbd0ca0de64146ea9c1b4b72fee0b79e711f252b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -32,8 +32,8 @@ use std::rc::Rc;\n \n use crate::clean;\n use crate::clean::{AttributesExt, MAX_DEF_ID};\n+use crate::config::RenderInfo;\n use crate::config::{Options as RustdocOptions, RenderOptions};\n-use crate::html::render::RenderInfo;\n use crate::passes::{self, Condition::*, ConditionalPass};\n \n pub use rustc_session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n@@ -44,9 +44,9 @@ pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n pub struct DocContext<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n     pub resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    /// Later on moved into `html::render::CACHE_KEY`\n+    /// Later on moved into `CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n-    /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n+    /// Later on moved through `clean::Crate` into `CACHE_KEY`\n     pub external_traits: Rc<RefCell<FxHashMap<DefId, clean::Trait>>>,\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n@@ -315,7 +315,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let cpath = Some(input.clone());\n     let input = Input::File(input);\n \n-    let intra_link_resolution_failure_name = lint::builtin::INTRA_DOC_LINK_RESOLUTION_FAILURE.name;\n+    let intra_link_resolution_failure_name = lint::builtin::BROKEN_INTRA_DOC_LINKS.name;\n     let missing_docs = rustc_lint::builtin::MISSING_DOCS.name;\n     let missing_doc_example = rustc_lint::builtin::MISSING_DOC_CODE_EXAMPLES.name;\n     let private_doc_tests = rustc_lint::builtin::PRIVATE_DOC_TESTS.name;"}, {"sha": "4ce6bcbe2749e0e7e4bb7a18954c0dce1ad809a6", "filename": "src/librustdoc/docfs.rs", "status": "modified", "additions": 16, "deletions": 45, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fdocfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fdocfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdocfs.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -13,8 +13,7 @@ use std::fs;\n use std::io;\n use std::path::Path;\n use std::string::ToString;\n-use std::sync::mpsc::{channel, Receiver, Sender};\n-use std::sync::Arc;\n+use std::sync::mpsc::Sender;\n \n macro_rules! try_err {\n     ($e:expr, $file:expr) => {\n@@ -31,47 +30,24 @@ pub trait PathError {\n         S: ToString + Sized;\n }\n \n-pub struct ErrorStorage {\n-    sender: Option<Sender<Option<String>>>,\n-    receiver: Receiver<Option<String>>,\n-}\n-\n-impl ErrorStorage {\n-    pub fn new() -> ErrorStorage {\n-        let (sender, receiver) = channel();\n-        ErrorStorage { sender: Some(sender), receiver }\n-    }\n-\n-    /// Prints all stored errors. Returns the number of printed errors.\n-    pub fn write_errors(&mut self, diag: &rustc_errors::Handler) -> usize {\n-        let mut printed = 0;\n-        // In order to drop the sender part of the channel.\n-        self.sender = None;\n-\n-        for msg in self.receiver.iter() {\n-            if let Some(ref error) = msg {\n-                diag.struct_err(&error).emit();\n-                printed += 1;\n-            }\n-        }\n-        printed\n-    }\n-}\n-\n pub struct DocFS {\n     sync_only: bool,\n-    errors: Arc<ErrorStorage>,\n+    errors: Option<Sender<String>>,\n }\n \n impl DocFS {\n-    pub fn new(errors: &Arc<ErrorStorage>) -> DocFS {\n-        DocFS { sync_only: false, errors: Arc::clone(errors) }\n+    pub fn new(errors: Sender<String>) -> DocFS {\n+        DocFS { sync_only: false, errors: Some(errors) }\n     }\n \n     pub fn set_sync_only(&mut self, sync_only: bool) {\n         self.sync_only = sync_only;\n     }\n \n+    pub fn close(&mut self) {\n+        self.errors = None;\n+    }\n+\n     pub fn create_dir_all<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n         // For now, dir creation isn't a huge time consideration, do it\n         // synchronously, which avoids needing ordering between write() actions\n@@ -88,20 +64,15 @@ impl DocFS {\n         if !self.sync_only && cfg!(windows) {\n             // A possible future enhancement after more detailed profiling would\n             // be to create the file sync so errors are reported eagerly.\n-            let contents = contents.as_ref().to_vec();\n             let path = path.as_ref().to_path_buf();\n-            let sender = self.errors.sender.clone().unwrap();\n-            rayon::spawn(move || match fs::write(&path, &contents) {\n-                Ok(_) => {\n-                    sender.send(None).unwrap_or_else(|_| {\n-                        panic!(\"failed to send error on \\\"{}\\\"\", path.display())\n-                    });\n-                }\n-                Err(e) => {\n-                    sender.send(Some(format!(\"\\\"{}\\\": {}\", path.display(), e))).unwrap_or_else(\n-                        |_| panic!(\"failed to send non-error on \\\"{}\\\"\", path.display()),\n-                    );\n-                }\n+            let contents = contents.as_ref().to_vec();\n+            let sender = self.errors.clone().expect(\"can't write after closing\");\n+            rayon::spawn(move || {\n+                fs::write(&path, contents).unwrap_or_else(|e| {\n+                    sender\n+                        .send(format!(\"\\\"{}\\\": {}\", path.display(), e))\n+                        .expect(&format!(\"failed to send error on \\\"{}\\\"\", path.display()));\n+                });\n             });\n             Ok(())\n         } else {"}, {"sha": "77063ab4639a121dccb44de7342941eee56e8766", "filename": "src/librustdoc/error.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ferror.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -0,0 +1,56 @@\n+use std::error;\n+use std::fmt::{self, Formatter};\n+use std::path::{Path, PathBuf};\n+\n+use crate::docfs::PathError;\n+\n+#[derive(Debug)]\n+pub struct Error {\n+    pub file: PathBuf,\n+    pub error: String,\n+}\n+\n+impl error::Error for Error {}\n+\n+impl std::fmt::Display for Error {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n+        let file = self.file.display().to_string();\n+        if file.is_empty() {\n+            write!(f, \"{}\", self.error)\n+        } else {\n+            write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n+        }\n+    }\n+}\n+\n+impl PathError for Error {\n+    fn new<S, P: AsRef<Path>>(e: S, path: P) -> Error\n+    where\n+        S: ToString + Sized,\n+    {\n+        Error { file: path.as_ref().to_path_buf(), error: e.to_string() }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! try_none {\n+    ($e:expr, $file:expr) => {{\n+        use std::io;\n+        match $e {\n+            Some(e) => e,\n+            None => {\n+                return Err(Error::new(io::Error::new(io::ErrorKind::Other, \"not found\"), $file));\n+            }\n+        }\n+    }};\n+}\n+\n+#[macro_export]\n+macro_rules! try_err {\n+    ($e:expr, $file:expr) => {{\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(Error::new(e, $file)),\n+        }\n+    }};\n+}"}, {"sha": "99b31473f87a371651bbe87295d607f1eebf349b", "filename": "src/librustdoc/formats/cache.rs", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -0,0 +1,488 @@\n+use std::cell::RefCell;\n+use std::collections::BTreeMap;\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::sync::Arc;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n+use rustc_middle::middle::privacy::AccessLevels;\n+use rustc_span::source_map::FileName;\n+\n+use crate::clean::{self, GetDefId};\n+use crate::config::RenderInfo;\n+use crate::fold::DocFolder;\n+use crate::formats::item_type::ItemType;\n+use crate::formats::Impl;\n+use crate::html::render::cache::{extern_location, get_index_search_type, ExternalLocation};\n+use crate::html::render::IndexItem;\n+use crate::html::render::{plain_summary_line, shorten};\n+\n+thread_local!(crate static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n+\n+/// This cache is used to store information about the `clean::Crate` being\n+/// rendered in order to provide more useful documentation. This contains\n+/// information like all implementors of a trait, all traits a type implements,\n+/// documentation for all known traits, etc.\n+///\n+/// This structure purposefully does not implement `Clone` because it's intended\n+/// to be a fairly large and expensive structure to clone. Instead this adheres\n+/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n+/// rendering threads.\n+#[derive(Default)]\n+pub struct Cache {\n+    /// Maps a type ID to all known implementations for that type. This is only\n+    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n+    /// out extra documentation on the page of an enum/struct.\n+    ///\n+    /// The values of the map are a list of implementations and documentation\n+    /// found on that implementation.\n+    pub impls: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n+    /// and \"short type description\" of that node. This is used when generating\n+    /// URLs when a type is being linked to. External paths are not located in\n+    /// this map because the `External` type itself has all the information\n+    /// necessary.\n+    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Similar to `paths`, but only holds external paths. This is only used for\n+    /// generating explicit hyperlinks to other crates.\n+    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n+\n+    /// Maps local `DefId`s of exported types to fully qualified paths.\n+    /// Unlike 'paths', this mapping ignores any renames that occur\n+    /// due to 'use' statements.\n+    ///\n+    /// This map is used when writing out the special 'implementors'\n+    /// javascript file. By using the exact path that the type\n+    /// is declared with, we ensure that each path will be identical\n+    /// to the path used if the corresponding type is inlined. By\n+    /// doing this, we can detect duplicate impls on a trait page, and only display\n+    /// the impl for the inlined type.\n+    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n+\n+    /// This map contains information about all known traits of this crate.\n+    /// Implementations of a crate should inherit the documentation of the\n+    /// parent trait if no extra documentation is specified, and default methods\n+    /// should show up in documentation about trait implementations.\n+    pub traits: FxHashMap<DefId, clean::Trait>,\n+\n+    /// When rendering traits, it's often useful to be able to list all\n+    /// implementors of the trait, and this mapping is exactly, that: a mapping\n+    /// of trait ids to the list of known implementors of the trait\n+    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n+\n+    /// Cache of where external crate documentation can be found.\n+    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n+\n+    /// Cache of where documentation for primitives can be found.\n+    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n+\n+    // Note that external items for which `doc(hidden)` applies to are shown as\n+    // non-reachable while local items aren't. This is because we're reusing\n+    // the access levels from the privacy check pass.\n+    pub access_levels: AccessLevels<DefId>,\n+\n+    /// The version of the crate being documented, if given from the `--crate-version` flag.\n+    pub crate_version: Option<String>,\n+\n+    /// Whether to document private items.\n+    /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n+    pub document_private: bool,\n+\n+    // Private fields only used when initially crawling a crate to build a cache\n+    stack: Vec<String>,\n+    parent_stack: Vec<DefId>,\n+    parent_is_trait_impl: bool,\n+    stripped_mod: bool,\n+    masked_crates: FxHashSet<CrateNum>,\n+\n+    pub search_index: Vec<IndexItem>,\n+    pub deref_trait_did: Option<DefId>,\n+    pub deref_mut_trait_did: Option<DefId>,\n+    pub owned_box_did: Option<DefId>,\n+\n+    // In rare case where a structure is defined in one module but implemented\n+    // in another, if the implementing module is parsed before defining module,\n+    // then the fully qualified name of the structure isn't presented in `paths`\n+    // yet when its implementation methods are being indexed. Caches such methods\n+    // and their parent id here and indexes them at the end of crate parsing.\n+    pub orphan_impl_items: Vec<(DefId, clean::Item)>,\n+\n+    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n+    // even though the trait itself is not exported. This can happen if a trait\n+    // was defined in function/expression scope, since the impl will be picked\n+    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n+    // crawl. In order to prevent crashes when looking for spotlight traits or\n+    // when gathering trait documentation on a type, hold impls here while\n+    // folding and add them to the cache later on if we find the trait.\n+    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n+\n+    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n+    /// we need the alias element to have an array of items.\n+    pub aliases: BTreeMap<String, Vec<usize>>,\n+}\n+\n+impl Cache {\n+    pub fn from_krate(\n+        render_info: RenderInfo,\n+        document_private: bool,\n+        extern_html_root_urls: &BTreeMap<String, String>,\n+        dst: &Path,\n+        mut krate: clean::Crate,\n+    ) -> (clean::Crate, Cache) {\n+        // Crawl the crate to build various caches used for the output\n+        let RenderInfo {\n+            inlined: _,\n+            external_paths,\n+            exact_paths,\n+            access_levels,\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+            ..\n+        } = render_info;\n+\n+        let external_paths =\n+            external_paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from(t)))).collect();\n+\n+        let mut cache = Cache {\n+            external_paths,\n+            exact_paths,\n+            parent_is_trait_impl: false,\n+            stripped_mod: false,\n+            access_levels,\n+            crate_version: krate.version.take(),\n+            document_private,\n+            traits: krate.external_traits.replace(Default::default()),\n+            deref_trait_did,\n+            deref_mut_trait_did,\n+            owned_box_did,\n+            masked_crates: mem::take(&mut krate.masked_crates),\n+            ..Cache::default()\n+        };\n+\n+        // Cache where all our extern crates are located\n+        // FIXME: this part is specific to HTML so it'd be nice to remove it from the common code\n+        for &(n, ref e) in &krate.externs {\n+            let src_root = match e.src {\n+                FileName::Real(ref p) => match p.local_path().parent() {\n+                    Some(p) => p.to_path_buf(),\n+                    None => PathBuf::new(),\n+                },\n+                _ => PathBuf::new(),\n+            };\n+            let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n+            cache\n+                .extern_locations\n+                .insert(n, (e.name.clone(), src_root, extern_location(e, extern_url, &dst)));\n+\n+            let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n+            cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n+        }\n+\n+        // Cache where all known primitives have their documentation located.\n+        //\n+        // Favor linking to as local extern as possible, so iterate all crates in\n+        // reverse topological order.\n+        for &(_, ref e) in krate.externs.iter().rev() {\n+            for &(def_id, prim, _) in &e.primitives {\n+                cache.primitive_locations.insert(prim, def_id);\n+            }\n+        }\n+        for &(def_id, prim, _) in &krate.primitives {\n+            cache.primitive_locations.insert(prim, def_id);\n+        }\n+\n+        cache.stack.push(krate.name.clone());\n+        krate = cache.fold_crate(krate);\n+\n+        for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n+            if cache.traits.contains_key(&trait_did) {\n+                for did in dids {\n+                    cache.impls.entry(did).or_default().push(impl_.clone());\n+                }\n+            }\n+        }\n+\n+        (krate, cache)\n+    }\n+}\n+\n+impl DocFolder for Cache {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        if item.def_id.is_local() {\n+            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n+        }\n+\n+        // If this is a stripped module,\n+        // we don't want it or its children in the search index.\n+        let orig_stripped_mod = match item.inner {\n+            clean::StrippedItem(box clean::ModuleItem(..)) => {\n+                mem::replace(&mut self.stripped_mod, true)\n+            }\n+            _ => self.stripped_mod,\n+        };\n+\n+        // If the impl is from a masked crate or references something from a\n+        // masked crate then remove it completely.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if self.masked_crates.contains(&item.def_id.krate)\n+                || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n+                || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n+            {\n+                return None;\n+            }\n+        }\n+\n+        // Propagate a trait method's documentation to all implementors of the\n+        // trait.\n+        if let clean::TraitItem(ref t) = item.inner {\n+            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+        }\n+\n+        // Collect all the implementors of traits.\n+        if let clean::ImplItem(ref i) = item.inner {\n+            if let Some(did) = i.trait_.def_id() {\n+                if i.blanket_impl.is_none() {\n+                    self.implementors\n+                        .entry(did)\n+                        .or_default()\n+                        .push(Impl { impl_item: item.clone() });\n+                }\n+            }\n+        }\n+\n+        // Index this method for searching later on.\n+        if let Some(ref s) = item.name {\n+            let (parent, is_inherent_impl_item) = match item.inner {\n+                clean::StrippedItem(..) => ((None, None), false),\n+                clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n+                    if self.parent_is_trait_impl =>\n+                {\n+                    // skip associated items in trait impls\n+                    ((None, None), false)\n+                }\n+                clean::AssocTypeItem(..)\n+                | clean::TyMethodItem(..)\n+                | clean::StructFieldItem(..)\n+                | clean::VariantItem(..) => (\n+                    (\n+                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n+                        Some(&self.stack[..self.stack.len() - 1]),\n+                    ),\n+                    false,\n+                ),\n+                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n+                    if self.parent_stack.is_empty() {\n+                        ((None, None), false)\n+                    } else {\n+                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n+                        let did = *last;\n+                        let path = match self.paths.get(&did) {\n+                            // The current stack not necessarily has correlation\n+                            // for where the type was defined. On the other\n+                            // hand, `paths` always has the right\n+                            // information if present.\n+                            Some(&(\n+                                ref fqp,\n+                                ItemType::Trait\n+                                | ItemType::Struct\n+                                | ItemType::Union\n+                                | ItemType::Enum,\n+                            )) => Some(&fqp[..fqp.len() - 1]),\n+                            Some(..) => Some(&*self.stack),\n+                            None => None,\n+                        };\n+                        ((Some(*last), path), true)\n+                    }\n+                }\n+                _ => ((None, Some(&*self.stack)), false),\n+            };\n+\n+            match parent {\n+                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n+                    debug_assert!(!item.is_stripped());\n+\n+                    // A crate has a module at its root, containing all items,\n+                    // which should not be indexed. The crate-item itself is\n+                    // inserted later on when serializing the search-index.\n+                    if item.def_id.index != CRATE_DEF_INDEX {\n+                        self.search_index.push(IndexItem {\n+                            ty: item.type_(),\n+                            name: s.to_string(),\n+                            path: path.join(\"::\"),\n+                            desc: shorten(plain_summary_line(item.doc_value())),\n+                            parent,\n+                            parent_idx: None,\n+                            search_type: get_index_search_type(&item),\n+                        });\n+\n+                        for alias in item.attrs.get_doc_aliases() {\n+                            self.aliases\n+                                .entry(alias.to_lowercase())\n+                                .or_insert(Vec::new())\n+                                .push(self.search_index.len() - 1);\n+                        }\n+                    }\n+                }\n+                (Some(parent), None) if is_inherent_impl_item => {\n+                    // We have a parent, but we don't know where they're\n+                    // defined yet. Wait for later to index this item.\n+                    self.orphan_impl_items.push((parent, item.clone()));\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        // Keep track of the fully qualified path for this item.\n+        let pushed = match item.name {\n+            Some(ref n) if !n.is_empty() => {\n+                self.stack.push(n.to_string());\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        match item.inner {\n+            clean::StructItem(..)\n+            | clean::EnumItem(..)\n+            | clean::TypedefItem(..)\n+            | clean::TraitItem(..)\n+            | clean::FunctionItem(..)\n+            | clean::ModuleItem(..)\n+            | clean::ForeignFunctionItem(..)\n+            | clean::ForeignStaticItem(..)\n+            | clean::ConstantItem(..)\n+            | clean::StaticItem(..)\n+            | clean::UnionItem(..)\n+            | clean::ForeignTypeItem\n+            | clean::MacroItem(..)\n+            | clean::ProcMacroItem(..)\n+            | clean::VariantItem(..)\n+                if !self.stripped_mod =>\n+            {\n+                // Re-exported items mean that the same id can show up twice\n+                // in the rustdoc ast that we're looking at. We know,\n+                // however, that a re-exported item doesn't show up in the\n+                // `public_items` map, so we can skip inserting into the\n+                // paths map if there was already an entry present and we're\n+                // not a public item.\n+                if !self.paths.contains_key(&item.def_id)\n+                    || self.access_levels.is_public(item.def_id)\n+                {\n+                    self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+                }\n+            }\n+            clean::PrimitiveItem(..) => {\n+                self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n+            }\n+\n+            _ => {}\n+        }\n+\n+        // Maintain the parent stack\n+        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n+        let parent_pushed = match item.inner {\n+            clean::TraitItem(..)\n+            | clean::EnumItem(..)\n+            | clean::ForeignTypeItem\n+            | clean::StructItem(..)\n+            | clean::UnionItem(..)\n+            | clean::VariantItem(..) => {\n+                self.parent_stack.push(item.def_id);\n+                self.parent_is_trait_impl = false;\n+                true\n+            }\n+            clean::ImplItem(ref i) => {\n+                self.parent_is_trait_impl = i.trait_.is_some();\n+                match i.for_ {\n+                    clean::ResolvedPath { did, .. } => {\n+                        self.parent_stack.push(did);\n+                        true\n+                    }\n+                    ref t => {\n+                        let prim_did = t\n+                            .primitive_type()\n+                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n+                        match prim_did {\n+                            Some(did) => {\n+                                self.parent_stack.push(did);\n+                                true\n+                            }\n+                            None => false,\n+                        }\n+                    }\n+                }\n+            }\n+            _ => false,\n+        };\n+\n+        // Once we've recursively found all the generics, hoard off all the\n+        // implementations elsewhere.\n+        let ret = self.fold_item_recur(item).and_then(|item| {\n+            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n+                // Figure out the id of this impl. This may map to a\n+                // primitive rather than always to a struct/enum.\n+                // Note: matching twice to restrict the lifetime of the `i` borrow.\n+                let mut dids = FxHashSet::default();\n+                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n+                    match i.for_ {\n+                        clean::ResolvedPath { did, .. }\n+                        | clean::BorrowedRef {\n+                            type_: box clean::ResolvedPath { did, .. }, ..\n+                        } => {\n+                            dids.insert(did);\n+                        }\n+                        ref t => {\n+                            let did = t\n+                                .primitive_type()\n+                                .and_then(|t| self.primitive_locations.get(&t).cloned());\n+\n+                            if let Some(did) = did {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+\n+                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n+                        for bound in generics {\n+                            if let Some(did) = bound.def_id() {\n+                                dids.insert(did);\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    unreachable!()\n+                };\n+                let impl_item = Impl { impl_item: item };\n+                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n+                    for did in dids {\n+                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    }\n+                } else {\n+                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n+                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n+                }\n+                None\n+            } else {\n+                Some(item)\n+            }\n+        });\n+\n+        if pushed {\n+            self.stack.pop().expect(\"stack already empty\");\n+        }\n+        if parent_pushed {\n+            self.parent_stack.pop().expect(\"parent stack already empty\");\n+        }\n+        self.stripped_mod = orig_stripped_mod;\n+        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n+        ret\n+    }\n+}\n+\n+crate fn cache() -> Arc<Cache> {\n+    CACHE_KEY.with(|c| c.borrow().clone())\n+}"}, {"sha": "696bdae94fc88b89170999b60258b2d196781c04", "filename": "src/librustdoc/formats/item_type.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fformats%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fitem_type.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -13,7 +13,7 @@ use crate::clean;\n /// The search index uses item types encoded as smaller numbers which equal to\n /// discriminants. JavaScript then is used to decode them into the original value.\n /// Consequently, every change to this type should be synchronized to\n-/// the `itemTypes` mapping table in `static/main.js`.\n+/// the `itemTypes` mapping table in `html/static/main.js`.\n ///\n /// In addition, code in `html::render` uses this enum to generate CSS classes, page prefixes, and\n /// module headings. If you are adding to this enum and want to ensure that the sidebar also prints", "previous_filename": "src/librustdoc/html/item_type.rs"}, {"sha": "dcb0184c58cd20c95918f6c215e7a4edda050787", "filename": "src/librustdoc/formats/mod.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -0,0 +1,44 @@\n+pub mod cache;\n+pub mod item_type;\n+pub mod renderer;\n+\n+pub use renderer::{run_format, FormatRenderer};\n+\n+use rustc_span::def_id::DefId;\n+\n+use crate::clean;\n+use crate::clean::types::GetDefId;\n+\n+/// Specifies whether rendering directly implemented trait items or ones from a certain Deref\n+/// impl.\n+pub enum AssocItemRender<'a> {\n+    All,\n+    DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type, deref_mut_: bool },\n+}\n+\n+/// For different handling of associated items from the Deref target of a type rather than the type\n+/// itself.\n+#[derive(Copy, Clone, PartialEq)]\n+pub enum RenderMode {\n+    Normal,\n+    ForDeref { mut_: bool },\n+}\n+\n+/// Metadata about implementations for a type or trait.\n+#[derive(Clone, Debug)]\n+pub struct Impl {\n+    pub impl_item: clean::Item,\n+}\n+\n+impl Impl {\n+    pub fn inner_impl(&self) -> &clean::Impl {\n+        match self.impl_item.inner {\n+            clean::ImplItem(ref impl_) => impl_,\n+            _ => panic!(\"non-impl item found in impl\"),\n+        }\n+    }\n+\n+    pub fn trait_did(&self) -> Option<DefId> {\n+        self.inner_impl().trait_.def_id()\n+    }\n+}"}, {"sha": "90ace4d44c47dc93e1539dbf1da183df6f641d4b", "filename": "src/librustdoc/formats/renderer.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fformats%2Frenderer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Frenderer.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -0,0 +1,106 @@\n+use std::sync::Arc;\n+\n+use rustc_span::edition::Edition;\n+\n+use crate::clean;\n+use crate::config::{RenderInfo, RenderOptions};\n+use crate::error::Error;\n+use crate::formats::cache::{Cache, CACHE_KEY};\n+\n+/// Allows for different backends to rustdoc to be used with the `run_format()` function. Each\n+/// backend renderer has hooks for initialization, documenting an item, entering and exiting a\n+/// module, and cleanup/finalizing output.\n+pub trait FormatRenderer: Clone {\n+    /// Sets up any state required for the renderer. When this is called the cache has already been\n+    /// populated.\n+    fn init(\n+        krate: clean::Crate,\n+        options: RenderOptions,\n+        render_info: RenderInfo,\n+        edition: Edition,\n+        cache: &mut Cache,\n+    ) -> Result<(Self, clean::Crate), Error>;\n+\n+    /// Renders a single non-module item. This means no recursive sub-item rendering is required.\n+    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error>;\n+\n+    /// Renders a module (should not handle recursing into children).\n+    fn mod_item_in(\n+        &mut self,\n+        item: &clean::Item,\n+        item_name: &str,\n+        cache: &Cache,\n+    ) -> Result<(), Error>;\n+\n+    /// Runs after recursively rendering all sub-items of a module.\n+    fn mod_item_out(&mut self, item_name: &str) -> Result<(), Error>;\n+\n+    /// Post processing hook for cleanup and dumping output to files.\n+    fn after_krate(&mut self, krate: &clean::Crate, cache: &Cache) -> Result<(), Error>;\n+\n+    /// Called after everything else to write out errors.\n+    fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error>;\n+}\n+\n+/// Main method for rendering a crate.\n+pub fn run_format<T: FormatRenderer>(\n+    krate: clean::Crate,\n+    options: RenderOptions,\n+    render_info: RenderInfo,\n+    diag: &rustc_errors::Handler,\n+    edition: Edition,\n+) -> Result<(), Error> {\n+    let (krate, mut cache) = Cache::from_krate(\n+        render_info.clone(),\n+        options.document_private,\n+        &options.extern_html_root_urls,\n+        &options.output,\n+        krate,\n+    );\n+\n+    let (mut format_renderer, mut krate) =\n+        T::init(krate, options, render_info, edition, &mut cache)?;\n+\n+    let cache = Arc::new(cache);\n+    // Freeze the cache now that the index has been built. Put an Arc into TLS for future\n+    // parallelization opportunities\n+    CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n+\n+    let mut item = match krate.module.take() {\n+        Some(i) => i,\n+        None => return Ok(()),\n+    };\n+\n+    item.name = Some(krate.name.clone());\n+\n+    // Render the crate documentation\n+    let mut work = vec![(format_renderer.clone(), item)];\n+\n+    while let Some((mut cx, item)) = work.pop() {\n+        if item.is_mod() {\n+            // modules are special because they add a namespace. We also need to\n+            // recurse into the items of the module as well.\n+            let name = item.name.as_ref().unwrap().to_string();\n+            if name.is_empty() {\n+                panic!(\"Unexpected module with empty name\");\n+            }\n+\n+            cx.mod_item_in(&item, &name, &cache)?;\n+            let module = match item.inner {\n+                clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n+                _ => unreachable!(),\n+            };\n+            for it in module.items {\n+                debug!(\"Adding {:?} to worklist\", it.name);\n+                work.push((cx.clone(), it));\n+            }\n+\n+            cx.mod_item_out(&name)?;\n+        } else if item.name.is_some() {\n+            cx.item(item, &cache)?;\n+        }\n+    }\n+\n+    format_renderer.after_krate(&krate, &cache)?;\n+    format_renderer.after_run(diag)\n+}"}, {"sha": "699f8c36cba6a43cbdd9a2a198fdf899275713dd", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -11,13 +11,15 @@ use std::fmt;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_span::def_id::DefId;\n use rustc_target::spec::abi::Abi;\n \n use crate::clean::{self, PrimitiveType};\n+use crate::formats::cache::cache;\n+use crate::formats::item_type::ItemType;\n use crate::html::escape::Escape;\n-use crate::html::item_type::ItemType;\n-use crate::html::render::{self, cache, CURRENT_DEPTH};\n+use crate::html::render::cache::ExternalLocation;\n+use crate::html::render::CURRENT_DEPTH;\n \n pub trait Print {\n     fn print(self, buffer: &mut Buffer);\n@@ -493,9 +495,9 @@ pub fn href(did: DefId) -> Option<(String, ItemType, Vec<String>)> {\n                 fqp,\n                 shortty,\n                 match cache.extern_locations[&did.krate] {\n-                    (.., render::Remote(ref s)) => s.to_string(),\n-                    (.., render::Local) => \"../\".repeat(depth),\n-                    (.., render::Unknown) => return None,\n+                    (.., ExternalLocation::Remote(ref s)) => s.to_string(),\n+                    (.., ExternalLocation::Local) => \"../\".repeat(depth),\n+                    (.., ExternalLocation::Unknown) => return None,\n                 },\n             )\n         }\n@@ -574,12 +576,12 @@ fn primitive_link(\n             }\n             Some(&def_id) => {\n                 let loc = match m.extern_locations[&def_id.krate] {\n-                    (ref cname, _, render::Remote(ref s)) => Some((cname, s.to_string())),\n-                    (ref cname, _, render::Local) => {\n+                    (ref cname, _, ExternalLocation::Remote(ref s)) => Some((cname, s.to_string())),\n+                    (ref cname, _, ExternalLocation::Local) => {\n                         let len = CURRENT_DEPTH.with(|s| s.get());\n                         Some((cname, \"../\".repeat(len)))\n                     }\n-                    (.., render::Unknown) => None,\n+                    (.., ExternalLocation::Unknown) => None,\n                 };\n                 if let Some((cname, root)) = loc {\n                     write!("}, {"sha": "367538d440ea113c839e3de90f6c195c616b56a0", "filename": "src/librustdoc/html/mod.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -0,0 +1,9 @@\n+crate mod escape;\n+crate mod format;\n+crate mod highlight;\n+crate mod layout;\n+pub mod markdown;\n+pub mod render;\n+crate mod sources;\n+crate mod static_files;\n+crate mod toc;"}, {"sha": "378efa1a1bed7c0aaad67a5a2aab26a8af8ed225", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 12, "deletions": 488, "changes": 500, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,18 +1,16 @@\n-use crate::clean::{self, AttributesExt, GetDefId};\n-use crate::fold::DocFolder;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n-use rustc_middle::middle::privacy::AccessLevels;\n-use rustc_span::source_map::FileName;\n-use rustc_span::symbol::sym;\n use std::collections::BTreeMap;\n-use std::mem;\n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n \n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_span::symbol::sym;\n use serde::Serialize;\n \n-use super::{plain_summary_line, shorten, Impl, IndexItem, IndexItemFunctionType, ItemType};\n-use super::{Generic, RenderInfo, RenderType, TypeWithKind};\n+use crate::clean::types::GetDefId;\n+use crate::clean::{self, AttributesExt};\n+use crate::formats::cache::Cache;\n+use crate::formats::item_type::ItemType;\n+use crate::html::render::{plain_summary_line, shorten};\n+use crate::html::render::{Generic, IndexItem, IndexItemFunctionType, RenderType, TypeWithKind};\n \n /// Indicates where an external crate can be found.\n pub enum ExternalLocation {\n@@ -24,483 +22,9 @@ pub enum ExternalLocation {\n     Unknown,\n }\n \n-/// This cache is used to store information about the `clean::Crate` being\n-/// rendered in order to provide more useful documentation. This contains\n-/// information like all implementors of a trait, all traits a type implements,\n-/// documentation for all known traits, etc.\n-///\n-/// This structure purposefully does not implement `Clone` because it's intended\n-/// to be a fairly large and expensive structure to clone. Instead this adheres\n-/// to `Send` so it may be stored in a `Arc` instance and shared among the various\n-/// rendering threads.\n-#[derive(Default)]\n-crate struct Cache {\n-    /// Maps a type ID to all known implementations for that type. This is only\n-    /// recognized for intra-crate `ResolvedPath` types, and is used to print\n-    /// out extra documentation on the page of an enum/struct.\n-    ///\n-    /// The values of the map are a list of implementations and documentation\n-    /// found on that implementation.\n-    pub impls: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Maintains a mapping of local crate `DefId`s to the fully qualified name\n-    /// and \"short type description\" of that node. This is used when generating\n-    /// URLs when a type is being linked to. External paths are not located in\n-    /// this map because the `External` type itself has all the information\n-    /// necessary.\n-    pub paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Similar to `paths`, but only holds external paths. This is only used for\n-    /// generating explicit hyperlinks to other crates.\n-    pub external_paths: FxHashMap<DefId, (Vec<String>, ItemType)>,\n-\n-    /// Maps local `DefId`s of exported types to fully qualified paths.\n-    /// Unlike 'paths', this mapping ignores any renames that occur\n-    /// due to 'use' statements.\n-    ///\n-    /// This map is used when writing out the special 'implementors'\n-    /// javascript file. By using the exact path that the type\n-    /// is declared with, we ensure that each path will be identical\n-    /// to the path used if the corresponding type is inlined. By\n-    /// doing this, we can detect duplicate impls on a trait page, and only display\n-    /// the impl for the inlined type.\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-\n-    /// This map contains information about all known traits of this crate.\n-    /// Implementations of a crate should inherit the documentation of the\n-    /// parent trait if no extra documentation is specified, and default methods\n-    /// should show up in documentation about trait implementations.\n-    pub traits: FxHashMap<DefId, clean::Trait>,\n-\n-    /// When rendering traits, it's often useful to be able to list all\n-    /// implementors of the trait, and this mapping is exactly, that: a mapping\n-    /// of trait ids to the list of known implementors of the trait\n-    pub implementors: FxHashMap<DefId, Vec<Impl>>,\n-\n-    /// Cache of where external crate documentation can be found.\n-    pub extern_locations: FxHashMap<CrateNum, (String, PathBuf, ExternalLocation)>,\n-\n-    /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: FxHashMap<clean::PrimitiveType, DefId>,\n-\n-    // Note that external items for which `doc(hidden)` applies to are shown as\n-    // non-reachable while local items aren't. This is because we're reusing\n-    // the access levels from the privacy check pass.\n-    pub access_levels: AccessLevels<DefId>,\n-\n-    /// The version of the crate being documented, if given from the `--crate-version` flag.\n-    pub crate_version: Option<String>,\n-\n-    /// Whether to document private items.\n-    /// This is stored in `Cache` so it doesn't need to be passed through all rustdoc functions.\n-    pub document_private: bool,\n-\n-    // Private fields only used when initially crawling a crate to build a cache\n-    stack: Vec<String>,\n-    parent_stack: Vec<DefId>,\n-    parent_is_trait_impl: bool,\n-    search_index: Vec<IndexItem>,\n-    stripped_mod: bool,\n-    pub deref_trait_did: Option<DefId>,\n-    pub deref_mut_trait_did: Option<DefId>,\n-    pub owned_box_did: Option<DefId>,\n-    masked_crates: FxHashSet<CrateNum>,\n-\n-    // In rare case where a structure is defined in one module but implemented\n-    // in another, if the implementing module is parsed before defining module,\n-    // then the fully qualified name of the structure isn't presented in `paths`\n-    // yet when its implementation methods are being indexed. Caches such methods\n-    // and their parent id here and indexes them at the end of crate parsing.\n-    orphan_impl_items: Vec<(DefId, clean::Item)>,\n-\n-    // Similarly to `orphan_impl_items`, sometimes trait impls are picked up\n-    // even though the trait itself is not exported. This can happen if a trait\n-    // was defined in function/expression scope, since the impl will be picked\n-    // up by `collect-trait-impls` but the trait won't be scraped out in the HIR\n-    // crawl. In order to prevent crashes when looking for spotlight traits or\n-    // when gathering trait documentation on a type, hold impls here while\n-    // folding and add them to the cache later on if we find the trait.\n-    orphan_trait_impls: Vec<(DefId, FxHashSet<DefId>, Impl)>,\n-\n-    /// Aliases added through `#[doc(alias = \"...\")]`. Since a few items can have the same alias,\n-    /// we need the alias element to have an array of items.\n-    pub(super) aliases: BTreeMap<String, Vec<usize>>,\n-}\n-\n-impl Cache {\n-    pub fn from_krate(\n-        renderinfo: RenderInfo,\n-        document_private: bool,\n-        extern_html_root_urls: &BTreeMap<String, String>,\n-        dst: &Path,\n-        mut krate: clean::Crate,\n-    ) -> (clean::Crate, String, Cache) {\n-        // Crawl the crate to build various caches used for the output\n-        let RenderInfo {\n-            inlined: _,\n-            external_paths,\n-            exact_paths,\n-            access_levels,\n-            deref_trait_did,\n-            deref_mut_trait_did,\n-            owned_box_did,\n-            ..\n-        } = renderinfo;\n-\n-        let external_paths =\n-            external_paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from(t)))).collect();\n-\n-        let mut cache = Cache {\n-            impls: Default::default(),\n-            external_paths,\n-            exact_paths,\n-            paths: Default::default(),\n-            implementors: Default::default(),\n-            stack: Vec::new(),\n-            parent_stack: Vec::new(),\n-            search_index: Vec::new(),\n-            parent_is_trait_impl: false,\n-            extern_locations: Default::default(),\n-            primitive_locations: Default::default(),\n-            stripped_mod: false,\n-            access_levels,\n-            crate_version: krate.version.take(),\n-            document_private,\n-            orphan_impl_items: Vec::new(),\n-            orphan_trait_impls: Vec::new(),\n-            traits: krate.external_traits.replace(Default::default()),\n-            deref_trait_did,\n-            deref_mut_trait_did,\n-            owned_box_did,\n-            masked_crates: mem::take(&mut krate.masked_crates),\n-            aliases: Default::default(),\n-        };\n-\n-        // Cache where all our extern crates are located\n-        for &(n, ref e) in &krate.externs {\n-            let src_root = match e.src {\n-                FileName::Real(ref p) => match p.local_path().parent() {\n-                    Some(p) => p.to_path_buf(),\n-                    None => PathBuf::new(),\n-                },\n-                _ => PathBuf::new(),\n-            };\n-            let extern_url = extern_html_root_urls.get(&e.name).map(|u| &**u);\n-            cache\n-                .extern_locations\n-                .insert(n, (e.name.clone(), src_root, extern_location(e, extern_url, &dst)));\n-\n-            let did = DefId { krate: n, index: CRATE_DEF_INDEX };\n-            cache.external_paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n-        }\n-\n-        // Cache where all known primitives have their documentation located.\n-        //\n-        // Favor linking to as local extern as possible, so iterate all crates in\n-        // reverse topological order.\n-        for &(_, ref e) in krate.externs.iter().rev() {\n-            for &(def_id, prim, _) in &e.primitives {\n-                cache.primitive_locations.insert(prim, def_id);\n-            }\n-        }\n-        for &(def_id, prim, _) in &krate.primitives {\n-            cache.primitive_locations.insert(prim, def_id);\n-        }\n-\n-        cache.stack.push(krate.name.clone());\n-        krate = cache.fold_crate(krate);\n-\n-        for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n-            if cache.traits.contains_key(&trait_did) {\n-                for did in dids {\n-                    cache.impls.entry(did).or_insert(vec![]).push(impl_.clone());\n-                }\n-            }\n-        }\n-\n-        // Build our search index\n-        let index = build_index(&krate, &mut cache);\n-\n-        (krate, index, cache)\n-    }\n-}\n-\n-impl DocFolder for Cache {\n-    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n-        if item.def_id.is_local() {\n-            debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n-        }\n-\n-        // If this is a stripped module,\n-        // we don't want it or its children in the search index.\n-        let orig_stripped_mod = match item.inner {\n-            clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                mem::replace(&mut self.stripped_mod, true)\n-            }\n-            _ => self.stripped_mod,\n-        };\n-\n-        // If the impl is from a masked crate or references something from a\n-        // masked crate then remove it completely.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if self.masked_crates.contains(&item.def_id.krate)\n-                || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n-                || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n-            {\n-                return None;\n-            }\n-        }\n-\n-        // Propagate a trait method's documentation to all implementors of the\n-        // trait.\n-        if let clean::TraitItem(ref t) = item.inner {\n-            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n-        }\n-\n-        // Collect all the implementors of traits.\n-        if let clean::ImplItem(ref i) = item.inner {\n-            if let Some(did) = i.trait_.def_id() {\n-                if i.blanket_impl.is_none() {\n-                    self.implementors\n-                        .entry(did)\n-                        .or_default()\n-                        .push(Impl { impl_item: item.clone() });\n-                }\n-            }\n-        }\n-\n-        // Index this method for searching later on.\n-        if let Some(ref s) = item.name {\n-            let (parent, is_inherent_impl_item) = match item.inner {\n-                clean::StrippedItem(..) => ((None, None), false),\n-                clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n-                    if self.parent_is_trait_impl =>\n-                {\n-                    // skip associated items in trait impls\n-                    ((None, None), false)\n-                }\n-                clean::AssocTypeItem(..)\n-                | clean::TyMethodItem(..)\n-                | clean::StructFieldItem(..)\n-                | clean::VariantItem(..) => (\n-                    (\n-                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n-                        Some(&self.stack[..self.stack.len() - 1]),\n-                    ),\n-                    false,\n-                ),\n-                clean::MethodItem(..) | clean::AssocConstItem(..) => {\n-                    if self.parent_stack.is_empty() {\n-                        ((None, None), false)\n-                    } else {\n-                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n-                        let did = *last;\n-                        let path = match self.paths.get(&did) {\n-                            // The current stack not necessarily has correlation\n-                            // for where the type was defined. On the other\n-                            // hand, `paths` always has the right\n-                            // information if present.\n-                            Some(&(\n-                                ref fqp,\n-                                ItemType::Trait\n-                                | ItemType::Struct\n-                                | ItemType::Union\n-                                | ItemType::Enum,\n-                            )) => Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(&*self.stack),\n-                            None => None,\n-                        };\n-                        ((Some(*last), path), true)\n-                    }\n-                }\n-                _ => ((None, Some(&*self.stack)), false),\n-            };\n-\n-            match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n-                    debug_assert!(!item.is_stripped());\n-\n-                    // A crate has a module at its root, containing all items,\n-                    // which should not be indexed. The crate-item itself is\n-                    // inserted later on when serializing the search-index.\n-                    if item.def_id.index != CRATE_DEF_INDEX {\n-                        self.search_index.push(IndexItem {\n-                            ty: item.type_(),\n-                            name: s.to_string(),\n-                            path: path.join(\"::\"),\n-                            desc: shorten(plain_summary_line(item.doc_value())),\n-                            parent,\n-                            parent_idx: None,\n-                            search_type: get_index_search_type(&item),\n-                        });\n-\n-                        for alias in item.attrs.get_doc_aliases() {\n-                            self.aliases\n-                                .entry(alias.to_lowercase())\n-                                .or_insert(Vec::new())\n-                                .push(self.search_index.len() - 1);\n-                        }\n-                    }\n-                }\n-                (Some(parent), None) if is_inherent_impl_item => {\n-                    // We have a parent, but we don't know where they're\n-                    // defined yet. Wait for later to index this item.\n-                    self.orphan_impl_items.push((parent, item.clone()));\n-                }\n-                _ => {}\n-            }\n-        }\n-\n-        // Keep track of the fully qualified path for this item.\n-        let pushed = match item.name {\n-            Some(ref n) if !n.is_empty() => {\n-                self.stack.push(n.to_string());\n-                true\n-            }\n-            _ => false,\n-        };\n-\n-        match item.inner {\n-            clean::StructItem(..)\n-            | clean::EnumItem(..)\n-            | clean::TypedefItem(..)\n-            | clean::TraitItem(..)\n-            | clean::FunctionItem(..)\n-            | clean::ModuleItem(..)\n-            | clean::ForeignFunctionItem(..)\n-            | clean::ForeignStaticItem(..)\n-            | clean::ConstantItem(..)\n-            | clean::StaticItem(..)\n-            | clean::UnionItem(..)\n-            | clean::ForeignTypeItem\n-            | clean::MacroItem(..)\n-            | clean::ProcMacroItem(..)\n-            | clean::VariantItem(..)\n-                if !self.stripped_mod =>\n-            {\n-                // Re-exported items mean that the same id can show up twice\n-                // in the rustdoc ast that we're looking at. We know,\n-                // however, that a re-exported item doesn't show up in the\n-                // `public_items` map, so we can skip inserting into the\n-                // paths map if there was already an entry present and we're\n-                // not a public item.\n-                if !self.paths.contains_key(&item.def_id)\n-                    || self.access_levels.is_public(item.def_id)\n-                {\n-                    self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n-                }\n-            }\n-            clean::PrimitiveItem(..) => {\n-                self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n-            }\n-\n-            _ => {}\n-        }\n-\n-        // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n-        let parent_pushed = match item.inner {\n-            clean::TraitItem(..)\n-            | clean::EnumItem(..)\n-            | clean::ForeignTypeItem\n-            | clean::StructItem(..)\n-            | clean::UnionItem(..)\n-            | clean::VariantItem(..) => {\n-                self.parent_stack.push(item.def_id);\n-                self.parent_is_trait_impl = false;\n-                true\n-            }\n-            clean::ImplItem(ref i) => {\n-                self.parent_is_trait_impl = i.trait_.is_some();\n-                match i.for_ {\n-                    clean::ResolvedPath { did, .. } => {\n-                        self.parent_stack.push(did);\n-                        true\n-                    }\n-                    ref t => {\n-                        let prim_did = t\n-                            .primitive_type()\n-                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n-                        match prim_did {\n-                            Some(did) => {\n-                                self.parent_stack.push(did);\n-                                true\n-                            }\n-                            None => false,\n-                        }\n-                    }\n-                }\n-            }\n-            _ => false,\n-        };\n-\n-        // Once we've recursively found all the generics, hoard off all the\n-        // implementations elsewhere.\n-        let ret = self.fold_item_recur(item).and_then(|item| {\n-            if let clean::Item { inner: clean::ImplItem(_), .. } = item {\n-                // Figure out the id of this impl. This may map to a\n-                // primitive rather than always to a struct/enum.\n-                // Note: matching twice to restrict the lifetime of the `i` borrow.\n-                let mut dids = FxHashSet::default();\n-                if let clean::Item { inner: clean::ImplItem(ref i), .. } = item {\n-                    match i.for_ {\n-                        clean::ResolvedPath { did, .. }\n-                        | clean::BorrowedRef {\n-                            type_: box clean::ResolvedPath { did, .. }, ..\n-                        } => {\n-                            dids.insert(did);\n-                        }\n-                        ref t => {\n-                            let did = t\n-                                .primitive_type()\n-                                .and_then(|t| self.primitive_locations.get(&t).cloned());\n-\n-                            if let Some(did) = did {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-\n-                    if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n-                        for bound in generics {\n-                            if let Some(did) = bound.def_id() {\n-                                dids.insert(did);\n-                            }\n-                        }\n-                    }\n-                } else {\n-                    unreachable!()\n-                };\n-                let impl_item = Impl { impl_item: item };\n-                if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n-                    for did in dids {\n-                        self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n-                    }\n-                } else {\n-                    let trait_did = impl_item.trait_did().expect(\"no trait did\");\n-                    self.orphan_trait_impls.push((trait_did, dids, impl_item));\n-                }\n-                None\n-            } else {\n-                Some(item)\n-            }\n-        });\n-\n-        if pushed {\n-            self.stack.pop().expect(\"stack already empty\");\n-        }\n-        if parent_pushed {\n-            self.parent_stack.pop().expect(\"parent stack already empty\");\n-        }\n-        self.stripped_mod = orig_stripped_mod;\n-        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n-        ret\n-    }\n-}\n-\n /// Attempts to find where an external crate is located, given that we're\n /// rendering in to the specified source destination.\n-fn extern_location(\n+pub fn extern_location(\n     e: &clean::ExternalCrate,\n     extern_url: Option<&str>,\n     dst: &Path,\n@@ -538,7 +62,7 @@ fn extern_location(\n }\n \n /// Builds the search index from the collected metadata\n-fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n+pub fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     let mut defid_to_pathid = FxHashMap::default();\n     let mut crate_items = Vec::with_capacity(cache.search_index.len());\n     let mut crate_paths = vec![];\n@@ -640,7 +164,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     )\n }\n \n-fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n+crate fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n     let (all_types, ret_types) = match item.inner {\n         clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n         clean::MethodItem(ref m) => (&m.all_types, &m.ret_types),"}, {"sha": "5fb2d9f6f917c929746c3f1c1a1bea65b866db82", "filename": "src/librustdoc/html/render/mod.rs", "status": "renamed", "additions": 418, "deletions": 505, "changes": 923, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -25,21 +25,26 @@\n //! These threads are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n+pub mod cache;\n+\n+#[cfg(test)]\n+mod tests;\n+\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n use std::collections::{BTreeMap, VecDeque};\n use std::default::Default;\n-use std::error;\n use std::ffi::OsStr;\n-use std::fmt::{self, Formatter, Write};\n+use std::fmt::{self, Write};\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Component, Path, PathBuf};\n use std::rc::Rc;\n use std::str;\n use std::string::ToString;\n+use std::sync::mpsc::{channel, Receiver};\n use std::sync::Arc;\n \n use itertools::Itertools;\n@@ -50,7 +55,6 @@ use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::Mutability;\n-use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::middle::stability;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n@@ -60,26 +64,23 @@ use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n use crate::clean::{self, AttributesExt, Deprecation, GetDefId, SelfTy, TypeKind};\n-use crate::config::{OutputFormat, RenderOptions};\n-use crate::docfs::{DocFS, ErrorStorage, PathError};\n+use crate::config::RenderInfo;\n+use crate::config::RenderOptions;\n+use crate::docfs::{DocFS, PathError};\n use crate::doctree;\n+use crate::error::Error;\n+use crate::formats::cache::{cache, Cache};\n+use crate::formats::item_type::ItemType;\n+use crate::formats::{AssocItemRender, FormatRenderer, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::fmt_impl_for_trait_page;\n use crate::html::format::Function;\n use crate::html::format::{href, print_default_space, print_generic_bounds, WhereClause};\n use crate::html::format::{print_abi_with_space, Buffer, PrintWithSpace};\n-use crate::html::item_type::ItemType;\n use crate::html::markdown::{self, ErrorCodes, IdMap, Markdown, MarkdownHtml, MarkdownSummaryLine};\n use crate::html::sources;\n use crate::html::{highlight, layout, static_files};\n-\n-#[cfg(test)]\n-mod tests;\n-\n-mod cache;\n-\n-use cache::Cache;\n-crate use cache::ExternalLocation::{self, *};\n+use cache::{build_index, ExternalLocation};\n \n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n@@ -90,55 +91,6 @@ crate fn ensure_trailing_slash(v: &str) -> impl fmt::Display + '_ {\n     })\n }\n \n-#[derive(Debug)]\n-pub struct Error {\n-    pub file: PathBuf,\n-    pub error: String,\n-}\n-\n-impl error::Error for Error {}\n-\n-impl std::fmt::Display for Error {\n-    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        let file = self.file.display().to_string();\n-        if file.is_empty() {\n-            write!(f, \"{}\", self.error)\n-        } else {\n-            write!(f, \"\\\"{}\\\": {}\", self.file.display(), self.error)\n-        }\n-    }\n-}\n-\n-impl PathError for Error {\n-    fn new<S, P: AsRef<Path>>(e: S, path: P) -> Error\n-    where\n-        S: ToString + Sized,\n-    {\n-        Error { file: path.as_ref().to_path_buf(), error: e.to_string() }\n-    }\n-}\n-\n-macro_rules! try_none {\n-    ($e:expr, $file:expr) => {{\n-        use std::io;\n-        match $e {\n-            Some(e) => e,\n-            None => {\n-                return Err(Error::new(io::Error::new(io::ErrorKind::Other, \"not found\"), $file));\n-            }\n-        }\n-    }};\n-}\n-\n-macro_rules! try_err {\n-    ($e:expr, $file:expr) => {{\n-        match $e {\n-            Ok(e) => e,\n-            Err(e) => return Err(Error::new(e, $file)),\n-        }\n-    }};\n-}\n-\n /// Major driving force in all rustdoc rendering. This contains information\n /// about where in the tree-like hierarchy rendering is occurring and controls\n /// how the current page is being rendered.\n@@ -147,7 +99,7 @@ macro_rules! try_err {\n /// easily cloned because it is cloned per work-job (about once per item in the\n /// rustdoc tree).\n #[derive(Clone)]\n-struct Context {\n+crate struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     pub current: Vec<String>,\n@@ -161,7 +113,10 @@ struct Context {\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n-    pub cache: Arc<Cache>,\n+    all: Rc<RefCell<AllTypes>>,\n+    /// Storage for the errors produced while generating documentation so they\n+    /// can be printed together at the end.\n+    pub errors: Rc<Receiver<String>>,\n }\n \n crate struct SharedContext {\n@@ -241,53 +196,20 @@ impl SharedContext {\n     }\n }\n \n-/// Metadata about implementations for a type or trait.\n-#[derive(Clone, Debug)]\n-pub struct Impl {\n-    pub impl_item: clean::Item,\n-}\n-\n-impl Impl {\n-    fn inner_impl(&self) -> &clean::Impl {\n-        match self.impl_item.inner {\n-            clean::ImplItem(ref impl_) => impl_,\n-            _ => panic!(\"non-impl item found in impl\"),\n-        }\n-    }\n-\n-    fn trait_did(&self) -> Option<DefId> {\n-        self.inner_impl().trait_.def_id()\n-    }\n-}\n-\n-/// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n-/// Later on moved into `CACHE_KEY`.\n-#[derive(Default)]\n-pub struct RenderInfo {\n-    pub inlined: FxHashSet<DefId>,\n-    pub external_paths: crate::core::ExternalPaths,\n-    pub exact_paths: FxHashMap<DefId, Vec<String>>,\n-    pub access_levels: AccessLevels<DefId>,\n-    pub deref_trait_did: Option<DefId>,\n-    pub deref_mut_trait_did: Option<DefId>,\n-    pub owned_box_did: Option<DefId>,\n-    pub output_format: Option<OutputFormat>,\n-}\n-\n // Helper structs for rendering items/sidebars and carrying along contextual\n // information\n \n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n #[derive(Debug)]\n-struct IndexItem {\n-    ty: ItemType,\n-    name: String,\n-    path: String,\n-    desc: String,\n-    parent: Option<DefId>,\n-    parent_idx: Option<usize>,\n-    search_type: Option<IndexItemFunctionType>,\n+pub struct IndexItem {\n+    pub ty: ItemType,\n+    pub name: String,\n+    pub path: String,\n+    pub desc: String,\n+    pub parent: Option<DefId>,\n+    pub parent_idx: Option<usize>,\n+    pub search_type: Option<IndexItemFunctionType>,\n }\n \n impl Serialize for IndexItem {\n@@ -309,7 +231,7 @@ impl Serialize for IndexItem {\n \n /// A type used for the search index.\n #[derive(Debug)]\n-struct RenderType {\n+crate struct RenderType {\n     ty: Option<DefId>,\n     idx: Option<usize>,\n     name: Option<String>,\n@@ -340,7 +262,7 @@ impl Serialize for RenderType {\n \n /// A type used for the search index.\n #[derive(Debug)]\n-struct Generic {\n+crate struct Generic {\n     name: String,\n     defid: Option<DefId>,\n     idx: Option<usize>,\n@@ -361,7 +283,7 @@ impl Serialize for Generic {\n \n /// Full type of functions/methods in the search index.\n #[derive(Debug)]\n-struct IndexItemFunctionType {\n+pub struct IndexItemFunctionType {\n     inputs: Vec<TypeWithKind>,\n     output: Option<Vec<TypeWithKind>>,\n }\n@@ -394,7 +316,7 @@ impl Serialize for IndexItemFunctionType {\n }\n \n #[derive(Debug)]\n-pub struct TypeWithKind {\n+crate struct TypeWithKind {\n     ty: RenderType,\n     kind: TypeKind,\n }\n@@ -426,7 +348,6 @@ pub struct StylePath {\n     pub disabled: bool,\n }\n \n-thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n \n pub fn initial_ids() -> Vec<String> {\n@@ -454,147 +375,301 @@ pub fn initial_ids() -> Vec<String> {\n }\n \n /// Generates the documentation for `crate` into the directory `dst`\n-pub fn run(\n-    mut krate: clean::Crate,\n-    options: RenderOptions,\n-    renderinfo: RenderInfo,\n-    diag: &rustc_errors::Handler,\n-    edition: Edition,\n-) -> Result<(), Error> {\n-    // need to save a copy of the options for rendering the index page\n-    let md_opts = options.clone();\n-    let RenderOptions {\n-        output,\n-        external_html,\n-        id_map,\n-        playground_url,\n-        sort_modules_alphabetically,\n-        themes: style_files,\n-        extension_css,\n-        extern_html_root_urls,\n-        resource_suffix,\n-        static_root_path,\n-        generate_search_filter,\n-        document_private,\n-        ..\n-    } = options;\n-\n-    let src_root = match krate.src {\n-        FileName::Real(ref p) => match p.local_path().parent() {\n-            Some(p) => p.to_path_buf(),\n-            None => PathBuf::new(),\n-        },\n-        _ => PathBuf::new(),\n-    };\n-    let mut errors = Arc::new(ErrorStorage::new());\n-    // If user passed in `--playground-url` arg, we fill in crate name here\n-    let mut playground = None;\n-    if let Some(url) = playground_url {\n-        playground = Some(markdown::Playground { crate_name: Some(krate.name.clone()), url });\n-    }\n-    let mut layout = layout::Layout {\n-        logo: String::new(),\n-        favicon: String::new(),\n-        external_html,\n-        krate: krate.name.clone(),\n-        css_file_extension: extension_css,\n-        generate_search_filter,\n-    };\n-    let mut issue_tracker_base_url = None;\n-    let mut include_sources = true;\n-\n-    // Crawl the crate attributes looking for attributes which control how we're\n-    // going to emit HTML\n-    if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n-        for attr in attrs.lists(sym::doc) {\n-            match (attr.name_or_empty(), attr.value_str()) {\n-                (sym::html_favicon_url, Some(s)) => {\n-                    layout.favicon = s.to_string();\n-                }\n-                (sym::html_logo_url, Some(s)) => {\n-                    layout.logo = s.to_string();\n-                }\n-                (sym::html_playground_url, Some(s)) => {\n-                    playground = Some(markdown::Playground {\n-                        crate_name: Some(krate.name.clone()),\n-                        url: s.to_string(),\n-                    });\n-                }\n-                (sym::issue_tracker_base_url, Some(s)) => {\n-                    issue_tracker_base_url = Some(s.to_string());\n-                }\n-                (sym::html_no_source, None) if attr.is_word() => {\n-                    include_sources = false;\n+impl FormatRenderer for Context {\n+    fn init(\n+        mut krate: clean::Crate,\n+        options: RenderOptions,\n+        _render_info: RenderInfo,\n+        edition: Edition,\n+        cache: &mut Cache,\n+    ) -> Result<(Context, clean::Crate), Error> {\n+        // need to save a copy of the options for rendering the index page\n+        let md_opts = options.clone();\n+        let RenderOptions {\n+            output,\n+            external_html,\n+            id_map,\n+            playground_url,\n+            sort_modules_alphabetically,\n+            themes: style_files,\n+            extension_css,\n+            resource_suffix,\n+            static_root_path,\n+            generate_search_filter,\n+            ..\n+        } = options;\n+\n+        let src_root = match krate.src {\n+            FileName::Real(ref p) => match p.local_path().parent() {\n+                Some(p) => p.to_path_buf(),\n+                None => PathBuf::new(),\n+            },\n+            _ => PathBuf::new(),\n+        };\n+        // If user passed in `--playground-url` arg, we fill in crate name here\n+        let mut playground = None;\n+        if let Some(url) = playground_url {\n+            playground = Some(markdown::Playground { crate_name: Some(krate.name.clone()), url });\n+        }\n+        let mut layout = layout::Layout {\n+            logo: String::new(),\n+            favicon: String::new(),\n+            external_html,\n+            krate: krate.name.clone(),\n+            css_file_extension: extension_css,\n+            generate_search_filter,\n+        };\n+        let mut issue_tracker_base_url = None;\n+        let mut include_sources = true;\n+\n+        // Crawl the crate attributes looking for attributes which control how we're\n+        // going to emit HTML\n+        if let Some(attrs) = krate.module.as_ref().map(|m| &m.attrs) {\n+            for attr in attrs.lists(sym::doc) {\n+                match (attr.name_or_empty(), attr.value_str()) {\n+                    (sym::html_favicon_url, Some(s)) => {\n+                        layout.favicon = s.to_string();\n+                    }\n+                    (sym::html_logo_url, Some(s)) => {\n+                        layout.logo = s.to_string();\n+                    }\n+                    (sym::html_playground_url, Some(s)) => {\n+                        playground = Some(markdown::Playground {\n+                            crate_name: Some(krate.name.clone()),\n+                            url: s.to_string(),\n+                        });\n+                    }\n+                    (sym::issue_tracker_base_url, Some(s)) => {\n+                        issue_tracker_base_url = Some(s.to_string());\n+                    }\n+                    (sym::html_no_source, None) if attr.is_word() => {\n+                        include_sources = false;\n+                    }\n+                    _ => {}\n                 }\n-                _ => {}\n             }\n         }\n+        let (sender, receiver) = channel();\n+        let mut scx = SharedContext {\n+            collapsed: krate.collapsed,\n+            src_root,\n+            include_sources,\n+            local_sources: Default::default(),\n+            issue_tracker_base_url,\n+            layout,\n+            created_dirs: Default::default(),\n+            sort_modules_alphabetically,\n+            style_files,\n+            resource_suffix,\n+            static_root_path,\n+            fs: DocFS::new(sender),\n+            edition,\n+            codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+            playground,\n+        };\n+\n+        // Add the default themes to the `Vec` of stylepaths\n+        //\n+        // Note that these must be added before `sources::render` is called\n+        // so that the resulting source pages are styled\n+        //\n+        // `light.css` is not disabled because it is the stylesheet that stays loaded\n+        // by the browser as the theme stylesheet. The theme system (hackily) works by\n+        // changing the href to this stylesheet. All other themes are disabled to\n+        // prevent rule conflicts\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n+        scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n+\n+        let dst = output;\n+        scx.ensure_dir(&dst)?;\n+        krate = sources::render(&dst, &mut scx, krate)?;\n+\n+        // Build our search index\n+        let index = build_index(&krate, cache);\n+\n+        let cache = Arc::new(cache);\n+        let mut cx = Context {\n+            current: Vec::new(),\n+            dst,\n+            render_redirect_pages: false,\n+            id_map: Rc::new(RefCell::new(id_map)),\n+            shared: Arc::new(scx),\n+            all: Rc::new(RefCell::new(AllTypes::new())),\n+            errors: Rc::new(receiver),\n+        };\n+\n+        CURRENT_DEPTH.with(|s| s.set(0));\n+\n+        // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n+        write_shared(&cx, &krate, index, &md_opts, &cache)?;\n+        Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n+        Ok((cx, krate))\n     }\n-    let mut scx = SharedContext {\n-        collapsed: krate.collapsed,\n-        src_root,\n-        include_sources,\n-        local_sources: Default::default(),\n-        issue_tracker_base_url,\n-        layout,\n-        created_dirs: Default::default(),\n-        sort_modules_alphabetically,\n-        style_files,\n-        resource_suffix,\n-        static_root_path,\n-        fs: DocFS::new(&errors),\n-        edition,\n-        codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n-        playground,\n-    };\n \n-    // Add the default themes to the `Vec` of stylepaths\n-    //\n-    // Note that these must be added before `sources::render` is called\n-    // so that the resulting source pages are styled\n-    //\n-    // `light.css` is not disabled because it is the stylesheet that stays loaded\n-    // by the browser as the theme stylesheet. The theme system (hackily) works by\n-    // changing the href to this stylesheet. All other themes are disabled to\n-    // prevent rule conflicts\n-    scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n-    scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n-    scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n-\n-    let dst = output;\n-    scx.ensure_dir(&dst)?;\n-    krate = sources::render(&dst, &mut scx, krate)?;\n-    let (new_crate, index, cache) =\n-        Cache::from_krate(renderinfo, document_private, &extern_html_root_urls, &dst, krate);\n-    krate = new_crate;\n-    let cache = Arc::new(cache);\n-    let mut cx = Context {\n-        current: Vec::new(),\n-        dst,\n-        render_redirect_pages: false,\n-        id_map: Rc::new(RefCell::new(id_map)),\n-        shared: Arc::new(scx),\n-        cache: cache.clone(),\n-    };\n+    fn after_run(&mut self, diag: &rustc_errors::Handler) -> Result<(), Error> {\n+        Arc::get_mut(&mut self.shared).unwrap().fs.close();\n+        let nb_errors = self.errors.iter().map(|err| diag.struct_err(&err).emit()).count();\n+        if nb_errors > 0 {\n+            Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n+    fn after_krate(&mut self, krate: &clean::Crate, cache: &Cache) -> Result<(), Error> {\n+        let final_file = self.dst.join(&krate.name).join(\"all.html\");\n+        let settings_file = self.dst.join(\"settings.html\");\n+        let crate_name = krate.name.clone();\n \n-    // Freeze the cache now that the index has been built. Put an Arc into TLS\n-    // for future parallelization opportunities\n-    CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n-    CURRENT_DEPTH.with(|s| s.set(0));\n+        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n+        if !root_path.ends_with('/') {\n+            root_path.push('/');\n+        }\n+        let mut page = layout::Page {\n+            title: \"List of all items in this crate\",\n+            css_class: \"mod\",\n+            root_path: \"../\",\n+            static_root_path: self.shared.static_root_path.as_deref(),\n+            description: \"List of all items in this crate\",\n+            keywords: BASIC_KEYWORDS,\n+            resource_suffix: &self.shared.resource_suffix,\n+            extra_scripts: &[],\n+            static_extra_scripts: &[],\n+        };\n+        let sidebar = if let Some(ref version) = cache.crate_version {\n+            format!(\n+                \"<p class='location'>Crate {}</p>\\\n+                     <div class='block version'>\\\n+                         <p>Version {}</p>\\\n+                     </div>\\\n+                     <a id='all-types' href='index.html'><p>Back to index</p></a>\",\n+                crate_name,\n+                Escape(version),\n+            )\n+        } else {\n+            String::new()\n+        };\n+        let all = self.all.replace(AllTypes::new());\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            |buf: &mut Buffer| all.print(buf),\n+            &self.shared.style_files,\n+        );\n+        self.shared.fs.write(&final_file, v.as_bytes())?;\n \n-    // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n-    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-    write_shared(&cx, &krate, index, &md_opts)?;\n-    Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n+        // Generating settings page.\n+        page.title = \"Rustdoc settings\";\n+        page.description = \"Settings of Rustdoc\";\n+        page.root_path = \"./\";\n \n-    // And finally render the whole crate's documentation\n-    let ret = cx.krate(krate);\n-    let nb_errors = Arc::get_mut(&mut errors).map_or_else(|| 0, |errors| errors.write_errors(diag));\n-    if ret.is_err() {\n-        ret\n-    } else if nb_errors > 0 {\n-        Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n-    } else {\n+        let mut style_files = self.shared.style_files.clone();\n+        let sidebar = \"<p class='location'>Settings</p><div class='sidebar-elems'></div>\";\n+        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n+        let v = layout::render(\n+            &self.shared.layout,\n+            &page,\n+            sidebar,\n+            settings(\n+                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n+                &self.shared.resource_suffix,\n+            ),\n+            &style_files,\n+        );\n+        self.shared.fs.write(&settings_file, v.as_bytes())?;\n+        Ok(())\n+    }\n+\n+    fn mod_item_in(\n+        &mut self,\n+        item: &clean::Item,\n+        item_name: &str,\n+        cache: &Cache,\n+    ) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+        let scx = &self.shared;\n+        self.dst.push(item_name);\n+        self.current.push(item_name.to_owned());\n+\n+        info!(\"Recursing into {}\", self.dst.display());\n+\n+        let buf = self.render_item(item, false, cache);\n+        // buf will be empty if the module is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(\"index.html\");\n+            scx.fs.write(&joint_dst, buf.as_bytes())?;\n+        }\n+\n+        // Render sidebar-items.js used throughout this module.\n+        if !self.render_redirect_pages {\n+            let module = match item.inner {\n+                clean::StrippedItem(box clean::ModuleItem(ref m)) | clean::ModuleItem(ref m) => m,\n+                _ => unreachable!(),\n+            };\n+            let items = self.build_sidebar_items(module);\n+            let js_dst = self.dst.join(\"sidebar-items.js\");\n+            let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n+            scx.fs.write(&js_dst, &v)?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn mod_item_out(&mut self, _item_name: &str) -> Result<(), Error> {\n+        info!(\"Recursed; leaving {}\", self.dst.display());\n+\n+        // Go back to where we were at\n+        self.dst.pop();\n+        self.current.pop();\n+        Ok(())\n+    }\n+\n+    fn item(&mut self, item: clean::Item, cache: &Cache) -> Result<(), Error> {\n+        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n+        // if they contain impls for public types. These modules can also\n+        // contain items such as publicly re-exported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally\n+        // (a flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = item.is_stripped();\n+        }\n+\n+        let buf = self.render_item(&item, true, cache);\n+        // buf will be empty if the item is stripped and there is no redirect for it\n+        if !buf.is_empty() {\n+            let name = item.name.as_ref().unwrap();\n+            let item_type = item.type_();\n+            let file_name = &item_path(item_type, name);\n+            self.shared.ensure_dir(&self.dst)?;\n+            let joint_dst = self.dst.join(file_name);\n+            self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n+\n+            if !self.render_redirect_pages {\n+                self.all.borrow_mut().append(full_path(self, &item), &item_type);\n+            }\n+            // If the item is a macro, redirect from the old macro URL (with !)\n+            // to the new one (without).\n+            if item_type == ItemType::Macro {\n+                let redir_name = format!(\"{}.{}!.html\", item_type, name);\n+                let redir_dst = self.dst.join(redir_name);\n+                let v = layout::redirect(file_name);\n+                self.shared.fs.write(&redir_dst, v.as_bytes())?;\n+            }\n+        }\n         Ok(())\n     }\n }\n@@ -604,6 +679,7 @@ fn write_shared(\n     krate: &clean::Crate,\n     search_index: String,\n     options: &RenderOptions,\n+    cache: &Cache,\n ) -> Result<(), Error> {\n     // Write out the shared files. Note that these are shared among all rustdoc\n     // docs placed in the output directory, so this needs to be a synchronized\n@@ -1001,17 +1077,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    for (&did, imps) in &cx.cache.implementors {\n+    for (&did, imps) in &cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n         // indexed, so we just skip this step in that case.\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n+        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n             Some(p) => p,\n-            None => match cx.cache.external_paths.get(&did) {\n+            None => match cache.external_paths.get(&did) {\n                 Some(p) => p,\n                 None => continue,\n             },\n@@ -1049,7 +1125,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // Only create a js file if we have impls to add to it. If the trait is\n         // documented locally though we always create the file to avoid dead\n         // links.\n-        if implementors.is_empty() && !cx.cache.paths.contains_key(&did) {\n+        if implementors.is_empty() && !cache.paths.contains_key(&did) {\n             continue;\n         }\n \n@@ -1354,93 +1430,7 @@ impl Context {\n         \"../\".repeat(self.current.len())\n     }\n \n-    /// Main method for rendering a crate.\n-    ///\n-    /// This currently isn't parallelized, but it'd be pretty easy to add\n-    /// parallelization to this function.\n-    fn krate(self, mut krate: clean::Crate) -> Result<(), Error> {\n-        let mut item = match krate.module.take() {\n-            Some(i) => i,\n-            None => return Ok(()),\n-        };\n-        let final_file = self.dst.join(&krate.name).join(\"all.html\");\n-        let settings_file = self.dst.join(\"settings.html\");\n-\n-        let crate_name = krate.name.clone();\n-        item.name = Some(krate.name);\n-\n-        let mut all = AllTypes::new();\n-\n-        {\n-            // Render the crate documentation\n-            let mut work = vec![(self.clone(), item)];\n-\n-            while let Some((mut cx, item)) = work.pop() {\n-                cx.item(item, &mut all, |cx, item| work.push((cx.clone(), item)))?\n-            }\n-        }\n-\n-        let mut root_path = self.dst.to_str().expect(\"invalid path\").to_owned();\n-        if !root_path.ends_with('/') {\n-            root_path.push('/');\n-        }\n-        let mut page = layout::Page {\n-            title: \"List of all items in this crate\",\n-            css_class: \"mod\",\n-            root_path: \"../\",\n-            static_root_path: self.shared.static_root_path.as_deref(),\n-            description: \"List of all items in this crate\",\n-            keywords: BASIC_KEYWORDS,\n-            resource_suffix: &self.shared.resource_suffix,\n-            extra_scripts: &[],\n-            static_extra_scripts: &[],\n-        };\n-        let sidebar = if let Some(ref version) = self.cache.crate_version {\n-            format!(\n-                \"<p class='location'>Crate {}</p>\\\n-                     <div class='block version'>\\\n-                         <p>Version {}</p>\\\n-                     </div>\\\n-                     <a id='all-types' href='index.html'><p>Back to index</p></a>\",\n-                crate_name,\n-                Escape(version),\n-            )\n-        } else {\n-            String::new()\n-        };\n-        let v = layout::render(\n-            &self.shared.layout,\n-            &page,\n-            sidebar,\n-            |buf: &mut Buffer| all.print(buf),\n-            &self.shared.style_files,\n-        );\n-        self.shared.fs.write(&final_file, v.as_bytes())?;\n-\n-        // Generating settings page.\n-        page.title = \"Rustdoc settings\";\n-        page.description = \"Settings of Rustdoc\";\n-        page.root_path = \"./\";\n-\n-        let mut style_files = self.shared.style_files.clone();\n-        let sidebar = \"<p class='location'>Settings</p><div class='sidebar-elems'></div>\";\n-        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n-        let v = layout::render(\n-            &self.shared.layout,\n-            &page,\n-            sidebar,\n-            settings(\n-                self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n-                &self.shared.resource_suffix,\n-            ),\n-            &style_files,\n-        );\n-        self.shared.fs.write(&settings_file, v.as_bytes())?;\n-\n-        Ok(())\n-    }\n-\n-    fn render_item(&self, it: &clean::Item, pushname: bool) -> String {\n+    fn render_item(&self, it: &clean::Item, pushname: bool, cache: &Cache) -> String {\n         // A little unfortunate that this is done like this, but it sure\n         // does make formatting *a lot* nicer.\n         CURRENT_DEPTH.with(|slot| {\n@@ -1493,13 +1483,13 @@ impl Context {\n             layout::render(\n                 &self.shared.layout,\n                 &page,\n-                |buf: &mut _| print_sidebar(self, it, buf),\n-                |buf: &mut _| print_item(self, it, buf),\n+                |buf: &mut _| print_sidebar(self, it, buf, cache),\n+                |buf: &mut _| print_item(self, it, buf, cache),\n                 &self.shared.style_files,\n             )\n         } else {\n             let mut url = self.root_path();\n-            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n+            if let Some(&(ref names, ty)) = cache.paths.get(&it.def_id) {\n                 for name in &names[..names.len() - 1] {\n                     url.push_str(name);\n                     url.push_str(\"/\");\n@@ -1512,97 +1502,6 @@ impl Context {\n         }\n     }\n \n-    /// Non-parallelized version of rendering an item. This will take the input\n-    /// item, render its contents, and then invoke the specified closure with\n-    /// all sub-items which need to be rendered.\n-    ///\n-    /// The rendering driver uses this closure to queue up more work.\n-    fn item<F>(&mut self, item: clean::Item, all: &mut AllTypes, mut f: F) -> Result<(), Error>\n-    where\n-        F: FnMut(&mut Context, clean::Item),\n-    {\n-        // Stripped modules survive the rustdoc passes (i.e., `strip-private`)\n-        // if they contain impls for public types. These modules can also\n-        // contain items such as publicly re-exported structures.\n-        //\n-        // External crates will provide links to these structures, so\n-        // these modules are recursed into, but not rendered normally\n-        // (a flag on the context).\n-        if !self.render_redirect_pages {\n-            self.render_redirect_pages = item.is_stripped();\n-        }\n-\n-        if item.is_mod() {\n-            // modules are special because they add a namespace. We also need to\n-            // recurse into the items of the module as well.\n-            let name = item.name.as_ref().unwrap().to_string();\n-            let scx = &self.shared;\n-            if name.is_empty() {\n-                panic!(\"Unexpected empty destination: {:?}\", self.current);\n-            }\n-            let prev = self.dst.clone();\n-            self.dst.push(&name);\n-            self.current.push(name);\n-\n-            info!(\"Recursing into {}\", self.dst.display());\n-\n-            let buf = self.render_item(&item, false);\n-            // buf will be empty if the module is stripped and there is no redirect for it\n-            if !buf.is_empty() {\n-                self.shared.ensure_dir(&self.dst)?;\n-                let joint_dst = self.dst.join(\"index.html\");\n-                scx.fs.write(&joint_dst, buf.as_bytes())?;\n-            }\n-\n-            let m = match item.inner {\n-                clean::StrippedItem(box clean::ModuleItem(m)) | clean::ModuleItem(m) => m,\n-                _ => unreachable!(),\n-            };\n-\n-            // Render sidebar-items.js used throughout this module.\n-            if !self.render_redirect_pages {\n-                let items = self.build_sidebar_items(&m);\n-                let js_dst = self.dst.join(\"sidebar-items.js\");\n-                let v = format!(\"initSidebarItems({});\", serde_json::to_string(&items).unwrap());\n-                scx.fs.write(&js_dst, &v)?;\n-            }\n-\n-            for item in m.items {\n-                f(self, item);\n-            }\n-\n-            info!(\"Recursed; leaving {}\", self.dst.display());\n-\n-            // Go back to where we were at\n-            self.dst = prev;\n-            self.current.pop().unwrap();\n-        } else if item.name.is_some() {\n-            let buf = self.render_item(&item, true);\n-            // buf will be empty if the item is stripped and there is no redirect for it\n-            if !buf.is_empty() {\n-                let name = item.name.as_ref().unwrap();\n-                let item_type = item.type_();\n-                let file_name = &item_path(item_type, name);\n-                self.shared.ensure_dir(&self.dst)?;\n-                let joint_dst = self.dst.join(file_name);\n-                self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n-\n-                if !self.render_redirect_pages {\n-                    all.append(full_path(self, &item), &item_type);\n-                }\n-                // If the item is a macro, redirect from the old macro URL (with !)\n-                // to the new one (without).\n-                if item_type == ItemType::Macro {\n-                    let redir_name = format!(\"{}.{}!.html\", item_type, name);\n-                    let redir_dst = self.dst.join(redir_name);\n-                    let v = layout::redirect(file_name);\n-                    self.shared.fs.write(&redir_dst, v.as_bytes())?;\n-                }\n-            }\n-        }\n-        Ok(())\n-    }\n-\n     fn build_sidebar_items(&self, m: &clean::Module) -> BTreeMap<String, Vec<NameDoc>> {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map: BTreeMap<_, Vec<_>> = BTreeMap::new();\n@@ -1629,9 +1528,7 @@ impl Context {\n         }\n         map\n     }\n-}\n \n-impl Context {\n     /// Generates a url appropriate for an `href` attribute back to the source of\n     /// this item.\n     ///\n@@ -1641,7 +1538,7 @@ impl Context {\n     /// If `None` is returned, then a source link couldn't be generated. This\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n-    fn src_href(&self, item: &clean::Item) -> Option<String> {\n+    fn src_href(&self, item: &clean::Item, cache: &Cache) -> Option<String> {\n         let mut root = self.root_path();\n \n         let mut path = String::new();\n@@ -1660,13 +1557,13 @@ impl Context {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *self.cache.extern_locations.get(&item.source.cnum)? {\n-                (ref name, ref src, Local) => (name, src),\n-                (ref name, ref src, Remote(ref s)) => {\n+            let (krate, src_root) = match *cache.extern_locations.get(&item.source.cnum)? {\n+                (ref name, ref src, ExternalLocation::Local) => (name, src),\n+                (ref name, ref src, ExternalLocation::Remote(ref s)) => {\n                     root = s.to_string();\n                     (name, src)\n                 }\n-                (_, _, Unknown) => return None,\n+                (_, _, ExternalLocation::Unknown) => return None,\n             };\n \n             sources::clean_path(&src_root, file, false, |component| {\n@@ -1703,7 +1600,7 @@ where\n     write!(w, \"</div>\")\n }\n \n-fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n+fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer, cache: &Cache) {\n     debug_assert!(!item.is_stripped());\n     // Write the breadcrumb trail header for the top\n     write!(buf, \"<h1 class='fqn'><span class='out-of-band'>\");\n@@ -1731,7 +1628,7 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n     // this page, and this link will be auto-clicked. The `id` attribute is\n     // used to find the link to auto-click.\n     if cx.shared.include_sources && !item.is_primitive() {\n-        if let Some(l) = cx.src_href(item) {\n+        if let Some(l) = cx.src_href(item, cache) {\n             write!(buf, \"<a class='srclink' href='{}' title='{}'>[src]</a>\", l, \"goto source code\");\n         }\n     }\n@@ -1792,20 +1689,20 @@ fn print_item(cx: &Context, item: &clean::Item, buf: &mut Buffer) {\n         clean::FunctionItem(ref f) | clean::ForeignFunctionItem(ref f) => {\n             item_function(buf, cx, item, f)\n         }\n-        clean::TraitItem(ref t) => item_trait(buf, cx, item, t),\n-        clean::StructItem(ref s) => item_struct(buf, cx, item, s),\n-        clean::UnionItem(ref s) => item_union(buf, cx, item, s),\n-        clean::EnumItem(ref e) => item_enum(buf, cx, item, e),\n-        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t),\n+        clean::TraitItem(ref t) => item_trait(buf, cx, item, t, cache),\n+        clean::StructItem(ref s) => item_struct(buf, cx, item, s, cache),\n+        clean::UnionItem(ref s) => item_union(buf, cx, item, s, cache),\n+        clean::EnumItem(ref e) => item_enum(buf, cx, item, e, cache),\n+        clean::TypedefItem(ref t, _) => item_typedef(buf, cx, item, t, cache),\n         clean::MacroItem(ref m) => item_macro(buf, cx, item, m),\n         clean::ProcMacroItem(ref m) => item_proc_macro(buf, cx, item, m),\n-        clean::PrimitiveItem(_) => item_primitive(buf, cx, item),\n+        clean::PrimitiveItem(_) => item_primitive(buf, cx, item, cache),\n         clean::StaticItem(ref i) | clean::ForeignStaticItem(ref i) => item_static(buf, cx, item, i),\n         clean::ConstantItem(ref c) => item_constant(buf, cx, item, c),\n-        clean::ForeignTypeItem => item_foreign_type(buf, cx, item),\n+        clean::ForeignTypeItem => item_foreign_type(buf, cx, item, cache),\n         clean::KeywordItem(_) => item_keyword(buf, cx, item),\n-        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e),\n-        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta),\n+        clean::OpaqueTyItem(ref e, _) => item_opaque_ty(buf, cx, item, e, cache),\n+        clean::TraitAliasItem(ref ta) => item_trait_alias(buf, cx, item, ta, cache),\n         _ => {\n             // We don't generate pages for any other type.\n             unreachable!();\n@@ -1828,7 +1725,7 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n }\n \n #[inline]\n-fn plain_summary_line(s: Option<&str>) -> String {\n+crate fn plain_summary_line(s: Option<&str>) -> String {\n     let s = s.unwrap_or(\"\");\n     // This essentially gets the first paragraph of text in one line.\n     let mut line = s\n@@ -1845,7 +1742,7 @@ fn plain_summary_line(s: Option<&str>) -> String {\n     markdown::plain_summary_line(&line[..])\n }\n \n-fn shorten(s: String) -> String {\n+crate fn shorten(s: String) -> String {\n     if s.chars().count() > 60 {\n         let mut len = 0;\n         let mut ret = s\n@@ -2415,6 +2312,7 @@ fn render_implementor(\n     w: &mut Buffer,\n     implementor_dups: &FxHashMap<&str, (DefId, bool)>,\n     aliases: &[String],\n+    cache: &Cache,\n ) {\n     // If there's already another implementor that has the same abbridged name, use the\n     // full path, for example in `std::iter::ExactSizeIterator`\n@@ -2438,10 +2336,17 @@ fn render_implementor(\n         false,\n         false,\n         aliases,\n+        cache,\n     );\n }\n \n-fn render_impls(cx: &Context, w: &mut Buffer, traits: &[&&Impl], containing_item: &clean::Item) {\n+fn render_impls(\n+    cx: &Context,\n+    w: &mut Buffer,\n+    traits: &[&&Impl],\n+    containing_item: &clean::Item,\n+    cache: &Cache,\n+) {\n     let mut impls = traits\n         .iter()\n         .map(|i| {\n@@ -2460,6 +2365,7 @@ fn render_impls(cx: &Context, w: &mut Buffer, traits: &[&&Impl], containing_item\n                 false,\n                 true,\n                 &[],\n+                cache,\n             );\n             buffer.into_inner()\n         })\n@@ -2492,7 +2398,7 @@ fn compare_impl<'a, 'b>(lhs: &'a &&Impl, rhs: &'b &&Impl) -> Ordering {\n     name_key(&lhs).cmp(&name_key(&rhs))\n }\n \n-fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait) {\n+fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait, cache: &Cache) {\n     let bounds = bounds(&t.bounds, false);\n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2652,9 +2558,9 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache);\n \n-    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<&str, (DefId, bool)> = FxHashMap::default();\n@@ -2676,7 +2582,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n         }\n \n         let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n-            i.inner_impl().for_.def_id().map_or(true, |d| cx.cache.paths.contains_key(&d))\n+            i.inner_impl().for_.def_id().map_or(true, |d| cache.paths.contains_key(&d))\n         });\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -2705,6 +2611,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n                     true,\n                     false,\n                     &[],\n+                    cache,\n                 );\n             }\n             write_loading_content(w, \"\");\n@@ -2717,7 +2624,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n             \"<div class='item-list' id='implementors-list'>\",\n         );\n         for implementor in concrete {\n-            render_implementor(cx, implementor, w, &implementor_dups, &[]);\n+            render_implementor(cx, implementor, w, &implementor_dups, &[], cache);\n         }\n         write_loading_content(w, \"</div>\");\n \n@@ -2735,6 +2642,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n                     w,\n                     &implementor_dups,\n                     &collect_paths_for_type(implementor.inner_impl().for_.clone()),\n+                    cache,\n                 );\n             }\n             write_loading_content(w, \"</div>\");\n@@ -2770,7 +2678,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n         path = if it.def_id.is_local() {\n             cx.current.join(\"/\")\n         } else {\n-            let (ref path, _) = cx.cache.external_paths[&it.def_id];\n+            let (ref path, _) = cache.external_paths[&it.def_id];\n             path[..path.len() - 1].join(\"/\")\n         },\n         ty = it.type_(),\n@@ -2779,7 +2687,7 @@ fn item_trait(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Trait)\n }\n \n fn naive_assoc_href(it: &clean::Item, link: AssocItemLink<'_>) -> String {\n-    use crate::html::item_type::ItemType::*;\n+    use crate::formats::item_type::ItemType::*;\n \n     let name = it.name.as_ref().unwrap();\n     let ty = match it.type_() {\n@@ -2945,7 +2853,7 @@ fn render_assoc_item(\n     }\n }\n \n-fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct) {\n+fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust struct'>\");\n         render_attributes(w, it, true);\n@@ -2992,10 +2900,10 @@ fn item_struct(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Struct\n             }\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union) {\n+fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust union'>\");\n         render_attributes(w, it, true);\n@@ -3038,10 +2946,10 @@ fn item_union(w: &mut Buffer, cx: &Context, it: &clean::Item, s: &clean::Union)\n             document(w, cx, field);\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n+fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum, cache: &Cache) {\n     wrap_into_docblock(w, |w| {\n         write!(w, \"<pre class='rust enum'>\");\n         render_attributes(w, it, true);\n@@ -3166,7 +3074,7 @@ fn item_enum(w: &mut Buffer, cx: &Context, it: &clean::Item, e: &clean::Enum) {\n             render_stability_since(w, variant, it);\n         }\n     }\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n const ALLOWED_ATTRIBUTES: &[Symbol] = &[\n@@ -3348,26 +3256,15 @@ impl<'a> AssocItemLink<'a> {\n     }\n }\n \n-enum AssocItemRender<'a> {\n-    All,\n-    DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type, deref_mut_: bool },\n-}\n-\n-#[derive(Copy, Clone, PartialEq)]\n-enum RenderMode {\n-    Normal,\n-    ForDeref { mut_: bool },\n-}\n-\n fn render_assoc_items(\n     w: &mut Buffer,\n     cx: &Context,\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n+    cache: &Cache,\n ) {\n-    let c = &cx.cache;\n-    let v = match c.impls.get(&it) {\n+    let v = match cache.impls.get(&it) {\n         Some(v) => v,\n         None => return,\n     };\n@@ -3413,6 +3310,7 @@ fn render_assoc_items(\n                 false,\n                 true,\n                 &[],\n+                cache,\n             );\n         }\n     }\n@@ -3421,11 +3319,11 @@ fn render_assoc_items(\n     }\n     if !traits.is_empty() {\n         let deref_impl =\n-            traits.iter().find(|t| t.inner_impl().trait_.def_id() == c.deref_trait_did);\n+            traits.iter().find(|t| t.inner_impl().trait_.def_id() == cache.deref_trait_did);\n         if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n-                traits.iter().any(|t| t.inner_impl().trait_.def_id() == c.deref_mut_trait_did);\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n+                traits.iter().any(|t| t.inner_impl().trait_.def_id() == cache.deref_mut_trait_did);\n+            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, cache);\n         }\n \n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -3434,7 +3332,7 @@ fn render_assoc_items(\n             concrete.into_iter().partition(|t| t.inner_impl().blanket_impl.is_some());\n \n         let mut impls = Buffer::empty_from(&w);\n-        render_impls(cx, &mut impls, &concrete, containing_item);\n+        render_impls(cx, &mut impls, &concrete, containing_item, cache);\n         let impls = impls.into_inner();\n         if !impls.is_empty() {\n             write!(\n@@ -3459,7 +3357,7 @@ fn render_assoc_items(\n                 <div id='synthetic-implementations-list'>\\\n             \"\n             );\n-            render_impls(cx, w, &synthetic, containing_item);\n+            render_impls(cx, w, &synthetic, containing_item, cache);\n             write!(w, \"</div>\");\n         }\n \n@@ -3474,7 +3372,7 @@ fn render_assoc_items(\n                 <div id='blanket-implementations-list'>\\\n             \"\n             );\n-            render_impls(cx, w, &blanket_impl, containing_item);\n+            render_impls(cx, w, &blanket_impl, containing_item, cache);\n             write!(w, \"</div>\");\n         }\n     }\n@@ -3486,6 +3384,7 @@ fn render_deref_methods(\n     impl_: &Impl,\n     container_item: &clean::Item,\n     deref_mut: bool,\n+    cache: &Cache,\n ) {\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n     let (target, real_target) = impl_\n@@ -3503,11 +3402,11 @@ fn render_deref_methods(\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n     if let Some(did) = target.def_id() {\n-        render_assoc_items(w, cx, container_item, did, what);\n+        render_assoc_items(w, cx, container_item, did, what, cache);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n-                render_assoc_items(w, cx, container_item, did, what);\n+            if let Some(&did) = cache.primitive_locations.get(&prim) {\n+                render_assoc_items(w, cx, container_item, did, what, cache);\n             }\n         }\n     }\n@@ -3609,6 +3508,7 @@ fn render_impl(\n     // This argument is used to reference same type with different paths to avoid duplication\n     // in documentation pages for trait with automatic implementations like \"Send\" and \"Sync\".\n     aliases: &[String],\n+    cache: &Cache,\n ) {\n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n@@ -3651,7 +3551,7 @@ fn render_impl(\n         write!(w, \"<a href='#{}' class='anchor'></a>\", id);\n         let since = i.impl_item.stability.as_ref().map(|s| &s.since[..]);\n         render_stability_since_raw(w, since, outer_version);\n-        if let Some(l) = cx.src_href(&i.impl_item) {\n+        if let Some(l) = cx.src_href(&i.impl_item, cache) {\n             write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\", l, \"goto source code\");\n         }\n         write!(w, \"</h3>\");\n@@ -3683,6 +3583,7 @@ fn render_impl(\n         outer_version: Option<&str>,\n         trait_: Option<&clean::Trait>,\n         show_def_docs: bool,\n+        cache: &Cache,\n     ) {\n         let item_type = item.type_();\n         let name = item.name.as_ref().unwrap();\n@@ -3711,7 +3612,7 @@ fn render_impl(\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl);\n                     write!(w, \"</code>\");\n                     render_stability_since_raw(w, item.stable_since(), outer_version);\n-                    if let Some(l) = cx.src_href(item) {\n+                    if let Some(l) = cx.src_href(item, cache) {\n                         write!(\n                             w,\n                             \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n@@ -3733,7 +3634,7 @@ fn render_impl(\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id), \"\");\n                 write!(w, \"</code>\");\n                 render_stability_since_raw(w, item.stable_since(), outer_version);\n-                if let Some(l) = cx.src_href(item) {\n+                if let Some(l) = cx.src_href(item, cache) {\n                     write!(\n                         w,\n                         \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n@@ -3784,7 +3685,7 @@ fn render_impl(\n         }\n     }\n \n-    let traits = &cx.cache.traits;\n+    let traits = &cache.traits;\n     let trait_ = i.trait_did().map(|did| &traits[&did]);\n \n     write!(w, \"<div class='impl-items'>\");\n@@ -3799,6 +3700,7 @@ fn render_impl(\n             outer_version,\n             trait_,\n             show_def_docs,\n+            cache,\n         );\n     }\n \n@@ -3810,6 +3712,7 @@ fn render_impl(\n         render_mode: RenderMode,\n         outer_version: Option<&str>,\n         show_def_docs: bool,\n+        cache: &Cache,\n     ) {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n@@ -3829,6 +3732,7 @@ fn render_impl(\n                 outer_version,\n                 None,\n                 show_def_docs,\n+                cache,\n             );\n         }\n     }\n@@ -3847,13 +3751,20 @@ fn render_impl(\n                 render_mode,\n                 outer_version,\n                 show_def_docs,\n+                cache,\n             );\n         }\n     }\n     write!(w, \"</div>\");\n }\n \n-fn item_opaque_ty(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::OpaqueTy) {\n+fn item_opaque_ty(\n+    w: &mut Buffer,\n+    cx: &Context,\n+    it: &clean::Item,\n+    t: &clean::OpaqueTy,\n+    cache: &Cache,\n+) {\n     write!(w, \"<pre class='rust opaque'>\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3871,10 +3782,16 @@ fn item_opaque_ty(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Opa\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::TraitAlias) {\n+fn item_trait_alias(\n+    w: &mut Buffer,\n+    cx: &Context,\n+    it: &clean::Item,\n+    t: &clean::TraitAlias,\n+    cache: &Cache,\n+) {\n     write!(w, \"<pre class='rust trait-alias'>\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3892,10 +3809,10 @@ fn item_trait_alias(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::T\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typedef) {\n+fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typedef, cache: &Cache) {\n     write!(w, \"<pre class='rust typedef'>\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3913,10 +3830,10 @@ fn item_typedef(w: &mut Buffer, cx: &Context, it: &clean::Item, t: &clean::Typed\n     // won't be visible anywhere in the docs. It would be nice to also show\n     // associated items from the aliased type (see discussion in #32077), but\n     // we need #14072 to make sense of the generics.\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n+fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cache) {\n     writeln!(w, \"<pre class='rust foreigntype'>extern {{\");\n     render_attributes(w, it, false);\n     write!(\n@@ -3928,10 +3845,10 @@ fn item_foreign_type(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n \n     document(w, cx, it);\n \n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n-fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n+fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer, cache: &Cache) {\n     let parentlen = cx.current.len() - if it.is_mod() { 1 } else { 0 };\n \n     if it.is_struct()\n@@ -3966,7 +3883,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n     }\n \n     if it.is_crate() {\n-        if let Some(ref version) = cx.cache.crate_version {\n+        if let Some(ref version) = cache.crate_version {\n             write!(\n                 buffer,\n                 \"<div class='block version'>\\\n@@ -4603,9 +4520,9 @@ fn item_proc_macro(w: &mut Buffer, cx: &Context, it: &clean::Item, m: &clean::Pr\n     document(w, cx, it)\n }\n \n-fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n+fn item_primitive(w: &mut Buffer, cx: &Context, it: &clean::Item, cache: &Cache) {\n     document(w, cx, it);\n-    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All)\n+    render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All, cache)\n }\n \n fn item_keyword(w: &mut Buffer, cx: &Context, it: &clean::Item) {\n@@ -4670,7 +4587,3 @@ fn collect_paths_for_type(first_ty: clean::Type) -> Vec<String> {\n     }\n     out\n }\n-\n-crate fn cache() -> Arc<Cache> {\n-    CACHE_KEY.with(|c| c.borrow().clone())\n-}", "previous_filename": "src/librustdoc/html/render.rs"}, {"sha": "aaa73b100c2433b15918b871091e4e645c7a0698", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -1,10 +1,11 @@\n use crate::clean;\n use crate::docfs::PathError;\n+use crate::error::Error;\n use crate::fold::DocFolder;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n-use crate::html::render::{Error, SharedContext, BASIC_KEYWORDS};\n+use crate::html::render::{SharedContext, BASIC_KEYWORDS};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_span::source_map::FileName;\n use std::ffi::OsStr;"}, {"sha": "f4710f6ae873aef882d6387c255e0553ca75f5e8", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/24ddf76ed7bc453826e6e843cd0ca289e02185f1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=24ddf76ed7bc453826e6e843cd0ca289e02185f1", "patch": "@@ -197,9 +197,8 @@ pre {\n \tcolor: #a37acc;\n }\n \n-pre.rust .comment, pre.rust .doccomment {\n-\tcolor: #788797;\n-}\n+pre.rust .comment { color: #788797; }\n+pre.rust .doccomment { color: #a1ac88; }\n \n nav:not(.sidebar) {\n \tborder-bottom-color: #424c57;"}]}