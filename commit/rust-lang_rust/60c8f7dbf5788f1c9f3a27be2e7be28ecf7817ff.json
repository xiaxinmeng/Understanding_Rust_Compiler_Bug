{"sha": "60c8f7dbf5788f1c9f3a27be2e7be28ecf7817ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwYzhmN2RiZjU3ODhmMWM5ZjNhMjdiZTJlN2JlMjhlY2Y3ODE3ZmY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-23T21:20:17Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-04-29T18:34:13Z"}, "message": "Revert #27493", "tree": {"sha": "72c3d600fc371d757a161d1738f94ba31f149cb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72c3d600fc371d757a161d1738f94ba31f149cb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/60c8f7dbf5788f1c9f3a27be2e7be28ecf7817ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/60c8f7dbf5788f1c9f3a27be2e7be28ecf7817ff", "html_url": "https://github.com/rust-lang/rust/commit/60c8f7dbf5788f1c9f3a27be2e7be28ecf7817ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/60c8f7dbf5788f1c9f3a27be2e7be28ecf7817ff/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3", "html_url": "https://github.com/rust-lang/rust/commit/8b1dcf40f2a2e9e13fc9cb9fe2200841c6fa40f3"}], "stats": {"total": 83, "additions": 16, "deletions": 67}, "files": [{"sha": "bca7a6a89e9e910a247e75dfd1de13514e35796e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 67, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/60c8f7dbf5788f1c9f3a27be2e7be28ecf7817ff/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/60c8f7dbf5788f1c9f3a27be2e7be28ecf7817ff/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=60c8f7dbf5788f1c9f3a27be2e7be28ecf7817ff", "patch": "@@ -97,17 +97,6 @@ mod check_unused;\n mod build_reduced_graph;\n mod resolve_imports;\n \n-// Perform the callback, not walking deeper if the return is true\n-macro_rules! execute_callback {\n-    ($node: expr, $walker: expr) => (\n-        if let Some(ref callback) = $walker.callback {\n-            if callback($node, &mut $walker.resolved) {\n-                return;\n-            }\n-        }\n-    )\n-}\n-\n enum SuggestionType {\n     Macro(String),\n     Function(token::InternedString),\n@@ -559,22 +548,18 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n         self.visit_item(self.ast_map.expect_item(item.id))\n     }\n     fn visit_item(&mut self, item: &Item) {\n-        execute_callback!(hir_map::Node::NodeItem(item), self);\n         self.resolve_item(item);\n     }\n     fn visit_arm(&mut self, arm: &Arm) {\n         self.resolve_arm(arm);\n     }\n     fn visit_block(&mut self, block: &Block) {\n-        execute_callback!(hir_map::Node::NodeBlock(block), self);\n         self.resolve_block(block);\n     }\n     fn visit_expr(&mut self, expr: &Expr) {\n-        execute_callback!(hir_map::Node::NodeExpr(expr), self);\n         self.resolve_expr(expr);\n     }\n     fn visit_local(&mut self, local: &Local) {\n-        execute_callback!(hir_map::Node::NodeLocal(&local.pat), self);\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &Ty) {\n@@ -597,7 +582,6 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                      variant: &hir::Variant,\n                      generics: &Generics,\n                      item_id: ast::NodeId) {\n-        execute_callback!(hir_map::Node::NodeVariant(variant), self);\n         if let Some(ref dis_expr) = variant.node.disr_expr {\n             // resolve the discriminator expr as a constant\n             self.with_constant_rib(|this| {\n@@ -613,7 +597,6 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                                 variant.span);\n     }\n     fn visit_foreign_item(&mut self, foreign_item: &hir::ForeignItem) {\n-        execute_callback!(hir_map::Node::NodeForeignItem(foreign_item), self);\n         let type_parameters = match foreign_item.node {\n             ForeignItemFn(_, ref generics) => {\n                 HasTypeParameters(generics, FnSpace, ItemRibKind)\n@@ -1080,11 +1063,6 @@ pub struct Resolver<'a, 'tcx: 'a> {\n     used_imports: HashSet<(NodeId, Namespace)>,\n     used_crates: HashSet<CrateNum>,\n \n-    // Callback function for intercepting walks\n-    callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>,\n-    // The intention is that the callback modifies this flag.\n-    // Once set, the resolver falls out of the walk, preserving the ribs.\n-    resolved: bool,\n     privacy_errors: Vec<PrivacyError<'a>>,\n \n     arenas: &'a ResolverArenas<'a>,\n@@ -1186,8 +1164,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n-            callback: None,\n-            resolved: false,\n             privacy_errors: Vec::new(),\n \n             arenas: arenas,\n@@ -1758,13 +1734,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         f(self);\n \n-        match type_parameters {\n-            HasTypeParameters(..) => {\n-                if !self.resolved {\n-                    self.type_ribs.pop();\n-                }\n-            }\n-            NoTypeParameters => {}\n+        if let HasTypeParameters(..) = type_parameters {\n+            self.type_ribs.pop();\n         }\n     }\n \n@@ -1773,9 +1744,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     {\n         self.label_ribs.push(Rib::new(NormalRibKind));\n         f(self);\n-        if !self.resolved {\n-            self.label_ribs.pop();\n-        }\n+        self.label_ribs.pop();\n     }\n \n     fn with_constant_rib<F>(&mut self, f: F)\n@@ -1784,10 +1753,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self.value_ribs.push(Rib::new(ConstantItemRibKind));\n         self.type_ribs.push(Rib::new(ConstantItemRibKind));\n         f(self);\n-        if !self.resolved {\n-            self.type_ribs.pop();\n-            self.value_ribs.pop();\n-        }\n+        self.type_ribs.pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_function(&mut self, rib_kind: RibKind<'a>, declaration: &FnDecl, block: &Block) {\n@@ -1813,10 +1780,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         debug!(\"(resolving function) leaving function\");\n \n-        if !self.resolved {\n-            self.label_ribs.pop();\n-            self.value_ribs.pop();\n-        }\n+        self.label_ribs.pop();\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_trait_reference(&mut self,\n@@ -1950,9 +1915,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         self_type_rib.bindings.insert(keywords::SelfType.name(), self_def);\n         self.type_ribs.push(self_type_rib);\n         f(self);\n-        if !self.resolved {\n-            self.type_ribs.pop();\n-        }\n+        self.type_ribs.pop();\n     }\n \n     fn resolve_implementation(&mut self,\n@@ -2117,9 +2080,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         walk_list!(self, visit_expr, &arm.guard);\n         self.visit_expr(&arm.body);\n \n-        if !self.resolved {\n-            self.value_ribs.pop();\n-        }\n+        self.value_ribs.pop();\n     }\n \n     fn resolve_block(&mut self, block: &Block) {\n@@ -2141,12 +2102,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         intravisit::walk_block(self, block);\n \n         // Move back up.\n-        if !self.resolved {\n-            self.current_module = orig_module;\n-            self.value_ribs.pop();\n-            if let Some(_) = anonymous_module {\n-                self.type_ribs.pop();\n-            }\n+        self.current_module = orig_module;\n+        self.value_ribs.pop();\n+        if let Some(_) = anonymous_module {\n+            self.type_ribs.pop();\n         }\n         debug!(\"(resolving block) leaving block\");\n     }\n@@ -3588,7 +3547,7 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n \n     let krate = ast_map.krate();\n     let arenas = Resolver::arenas();\n-    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, &arenas, None);\n+    let mut resolver = create_resolver(session, ast_map, krate, make_glob_map, &arenas);\n \n     resolver.resolve_crate(krate);\n \n@@ -3608,25 +3567,15 @@ pub fn resolve_crate<'a, 'tcx>(session: &'a Session,\n     }\n }\n \n-/// Builds a name resolution walker to be used within this module,\n-/// or used externally, with an optional callback function.\n-///\n-/// The callback takes a &mut bool which allows callbacks to end a\n-/// walk when set to true, passing through the rest of the walk, while\n-/// preserving the ribs + current module. This allows resolve_path\n-/// calls to be made with the correct scope info. The node in the\n-/// callback corresponds to the current node in the walk.\n+/// Builds a name resolution walker.\n fn create_resolver<'a, 'tcx>(session: &'a Session,\n                              ast_map: &'a hir_map::Map<'tcx>,\n                              krate: &'a Crate,\n                              make_glob_map: MakeGlobMap,\n-                             arenas: &'a ResolverArenas<'a>,\n-                             callback: Option<Box<Fn(hir_map::Node, &mut bool) -> bool>>)\n+                             arenas: &'a ResolverArenas<'a>)\n                              -> Resolver<'a, 'tcx> {\n     let mut resolver = Resolver::new(session, ast_map, make_glob_map, arenas);\n \n-    resolver.callback = callback;\n-\n     resolver.build_reduced_graph(krate);\n \n     resolve_imports::resolve_imports(&mut resolver);"}]}