{"sha": "d10d0b3e9eb5c72b651c52b6fd38f1db20589b47", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMGQwYjNlOWViNWM3MmI2NTFjNTJiNmZkMzhmMWRiMjA1ODliNDc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-04-21T19:16:55Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-07-19T21:15:11Z"}, "message": "proc_macro: don't try to reflect literals in quasi-quoting.", "tree": {"sha": "cb9b76a6066c61357c28a202589134775373a3d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb9b76a6066c61357c28a202589134775373a3d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47", "html_url": "https://github.com/rust-lang/rust/commit/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0adb05d340a69f416b98a7daa663188a3a5be0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0adb05d340a69f416b98a7daa663188a3a5be0f", "html_url": "https://github.com/rust-lang/rust/commit/c0adb05d340a69f416b98a7daa663188a3a5be0f"}], "stats": {"total": 111, "additions": 16, "deletions": 95}, "files": [{"sha": "ea4ca03a0a1f624f3e728a109f645c9cdd70fa81", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=d10d0b3e9eb5c72b651c52b6fd38f1db20589b47", "patch": "@@ -1364,7 +1364,7 @@ impl TokenTree {\n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]\n pub mod __internal {\n-    pub use quote::{LiteralKind, SpannedSymbol, Quoter, unquote};\n+    pub use quote::{Quoter, unquote};\n \n     use std::cell::Cell;\n     use std::ptr;"}, {"sha": "8ae1d7b8525cf210333b7368f5ff77d5b5736474", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 15, "deletions": 94, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d10d0b3e9eb5c72b651c52b6fd38f1db20589b47/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=d10d0b3e9eb5c72b651c52b6fd38f1db20589b47", "patch": "@@ -17,8 +17,6 @@\n use {Delimiter, Literal, Spacing, Span, Ident, Punct, Group, TokenStream, TokenTree};\n \n use syntax::ext::base::{ExtCtxt, ProcMacro};\n-use syntax::parse::token;\n-use syntax::symbol::Symbol;\n use syntax::tokenstream;\n \n /// This is the actual quote!() proc macro\n@@ -42,6 +40,7 @@ macro_rules! quote_tok {\n     (,) => { tt2ts!(Punct::new(',', Spacing::Alone)) };\n     (.) => { tt2ts!(Punct::new('.', Spacing::Alone)) };\n     (:) => { tt2ts!(Punct::new(':', Spacing::Alone)) };\n+    (;) => { tt2ts!(Punct::new(';', Spacing::Alone)) };\n     (|) => { tt2ts!(Punct::new('|', Spacing::Alone)) };\n     (::) => {\n         [\n@@ -61,6 +60,7 @@ macro_rules! quote_tok {\n     (_) => { tt2ts!(Punct::new('_', Spacing::Alone)) };\n     (0) => { tt2ts!(Literal::i8_unsuffixed(0)) };\n     (&) => { tt2ts!(Punct::new('&', Spacing::Alone)) };\n+    (=) => { tt2ts!(Punct::new('=', Spacing::Alone)) };\n     ($i:ident) => { tt2ts!(Ident::new(stringify!($i), Span::def_site())) };\n }\n \n@@ -92,15 +92,6 @@ impl ProcMacro for Quoter {\n     }\n }\n \n-impl<T: Quote> Quote for Option<T> {\n-    fn quote(self) -> TokenStream {\n-        match self {\n-            Some(t) => quote!(Some((quote t))),\n-            None => quote!(None),\n-        }\n-    }\n-}\n-\n impl Quote for TokenStream {\n     fn quote(self) -> TokenStream {\n         if self.is_empty() {\n@@ -194,93 +185,23 @@ impl Quote for Span {\n     }\n }\n \n-macro_rules! literals {\n-    ($($i:ident),*; $($raw:ident),*) => {\n-        pub struct SpannedSymbol {\n-            sym: Symbol,\n-            span: Span,\n-        }\n-\n-        impl SpannedSymbol {\n-            pub fn new(string: &str, span: Span) -> SpannedSymbol {\n-                SpannedSymbol { sym: Symbol::intern(string), span }\n-            }\n-        }\n-\n-        impl Quote for SpannedSymbol {\n-            fn quote(self) -> TokenStream {\n-                quote!(::__internal::SpannedSymbol::new((quote self.sym.as_str()),\n-                                                        (quote self.span)))\n-            }\n-        }\n-\n-        pub enum LiteralKind {\n-            $($i,)*\n-            $($raw(u16),)*\n-        }\n-\n-        impl LiteralKind {\n-            pub fn with_contents_and_suffix(self, contents: SpannedSymbol,\n-                                            suffix: Option<SpannedSymbol>) -> Literal {\n-                let sym = contents.sym;\n-                let suffix = suffix.map(|t| t.sym);\n-                match self {\n-                    $(LiteralKind::$i => {\n-                        Literal {\n-                            lit: token::Lit::$i(sym),\n-                            suffix,\n-                            span: contents.span,\n-                        }\n-                    })*\n-                    $(LiteralKind::$raw(n) => {\n-                        Literal {\n-                            lit: token::Lit::$raw(sym, n),\n-                            suffix,\n-                            span: contents.span,\n-                        }\n-                    })*\n-                }\n-            }\n-        }\n-\n-        impl Literal {\n-            fn kind_contents_and_suffix(self) -> (LiteralKind, SpannedSymbol, Option<SpannedSymbol>)\n-            {\n-                let (kind, contents) = match self.lit {\n-                    $(token::Lit::$i(contents) => (LiteralKind::$i, contents),)*\n-                    $(token::Lit::$raw(contents, n) => (LiteralKind::$raw(n), contents),)*\n-                };\n-                let suffix = self.suffix.map(|sym| SpannedSymbol::new(&sym.as_str(), self.span()));\n-                (kind, SpannedSymbol::new(&contents.as_str(), self.span()), suffix)\n-            }\n-        }\n-\n-        impl Quote for LiteralKind {\n-            fn quote(self) -> TokenStream {\n-                match self {\n-                    $(LiteralKind::$i => quote! {\n-                        ::__internal::LiteralKind::$i\n-                    },)*\n-                    $(LiteralKind::$raw(n) => quote! {\n-                        ::__internal::LiteralKind::$raw((quote n))\n-                    },)*\n-                }\n-            }\n-        }\n-\n-        impl Quote for Literal {\n-            fn quote(self) -> TokenStream {\n-                let (kind, contents, suffix) = self.kind_contents_and_suffix();\n-                quote! {\n-                    (quote kind).with_contents_and_suffix((quote contents), (quote suffix))\n-                }\n+impl Quote for Literal {\n+    fn quote(self) -> TokenStream {\n+        quote! {{\n+            let mut iter = (quote self.to_string())\n+                .parse::<::TokenStream>()\n+                .unwrap()\n+                .into_iter();\n+            if let (Some(::TokenTree::Literal(mut lit)), None) = (iter.next(), iter.next()) {\n+                lit.set_span((quote self.span));\n+                lit\n+            } else {\n+                unreachable!()\n             }\n-        }\n+        }}\n     }\n }\n \n-literals!(Byte, Char, Float, Str_, Integer, ByteStr; StrRaw, ByteStrRaw);\n-\n impl Quote for Delimiter {\n     fn quote(self) -> TokenStream {\n         macro_rules! gen_match {"}]}