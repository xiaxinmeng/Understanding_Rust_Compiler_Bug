{"sha": "37768cba92f58c99cc320a02d67165d41d8642f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NzY4Y2JhOTJmNThjOTljYzMyMGEwMmQ2NzE2NWQ0MWQ4NjQyZjY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-16T22:47:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-17T21:37:23Z"}, "message": "rustc: Don't rebuild call or bind expressions during typechecking", "tree": {"sha": "6bfba6ea6f023def3a0fff3f88c7c31a39bf85fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bfba6ea6f023def3a0fff3f88c7c31a39bf85fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37768cba92f58c99cc320a02d67165d41d8642f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37768cba92f58c99cc320a02d67165d41d8642f6", "html_url": "https://github.com/rust-lang/rust/commit/37768cba92f58c99cc320a02d67165d41d8642f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37768cba92f58c99cc320a02d67165d41d8642f6/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f300de2963a35047fbd317002efea9b017cbb916", "url": "https://api.github.com/repos/rust-lang/rust/commits/f300de2963a35047fbd317002efea9b017cbb916", "html_url": "https://github.com/rust-lang/rust/commit/f300de2963a35047fbd317002efea9b017cbb916"}], "stats": {"total": 44, "additions": 14, "deletions": 30}, "files": [{"sha": "0d0a8c532661b91489f5361ee4f5254b3a33ceee", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/37768cba92f58c99cc320a02d67165d41d8642f6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37768cba92f58c99cc320a02d67165d41d8642f6/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=37768cba92f58c99cc320a02d67165d41d8642f6", "patch": "@@ -1789,29 +1789,22 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n     // A generic function to factor out common logic from call and bind\n     // expressions.\n     fn check_call_or_bind(&@fn_ctxt fcx, &@ast::expr f,\n-                          &vec[option::t[@ast::expr]] args)\n-            -> tup(@ast::expr, vec[option::t[@ast::expr]]) {\n+                          &vec[option::t[@ast::expr]] args) {\n \n         // Check the function.\n-        auto f_0 = check_expr(fcx, f);\n+        check_expr(fcx, f);\n \n         // Check the arguments and generate the argument signature.\n         let vec[option::t[@ast::expr]] args_0 = [];\n         let vec[arg] arg_tys_0 = [];\n         for (option::t[@ast::expr] a_opt in args) {\n             alt (a_opt) {\n                 case (some[@ast::expr](?a)) {\n-                    auto a_0 = check_expr(fcx, a);\n-                    args_0 += [some[@ast::expr](a_0)];\n-\n-                    auto arg_ty = rec(mode=mo_either,\n-                                      ty=expr_ty(fcx.ccx.tcx,\n-                                                 fcx.ccx.node_types, a_0));\n-                    vec::push[arg](arg_tys_0, arg_ty);\n+                    check_expr(fcx, a);\n+                    auto typ = expr_ty(fcx.ccx.tcx, fcx.ccx.node_types, a);\n+                    vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n                 }\n                 case (none[@ast::expr]) {\n-                    args_0 += [none[@ast::expr]];\n-\n                     auto typ = next_ty_var(fcx.ccx);\n                     vec::push[arg](arg_tys_0, rec(mode=mo_either, ty=typ));\n                 }\n@@ -1821,7 +1814,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         auto rt_0 = next_ty_var(fcx.ccx);\n         auto t_0;\n         alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                         f_0))) {\n+                                         f))) {\n             case (ty::ty_fn(?proto, _, _))   {\n                 t_0 = ty::mk_fn(fcx.ccx.tcx, proto, arg_tys_0, rt_0);\n             }\n@@ -1833,19 +1826,17 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n                 \"check_call_or_bind(): fn expr doesn't have fn type,\"\n                 + \" instead having: \" +\n                 ty_to_str(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx,\n-                                              fcx.ccx.node_types, f_0)));\n+                                               fcx.ccx.node_types, f)));\n                 fail;\n             }\n         }\n \n         // Unify the callee and arguments.\n         auto tpt_0 = ty::expr_ty_params_and_ty(fcx.ccx.tcx,\n-                                               fcx.ccx.node_types, f_0);\n+                                               fcx.ccx.node_types, f);\n         auto tpt_1 = Demand::full(fcx, f.span, tpt_0._1, t_0, tpt_0._0,\n                                  NO_AUTODEREF);\n-        replace_expr_type(fcx.ccx.node_types, f_0, tpt_1);\n-\n-        ret tup(f_0, args_0);\n+        replace_expr_type(fcx.ccx.node_types, f, tpt_1);\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1878,15 +1869,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n         }\n \n         // Call the generic checker.\n-        auto result = check_call_or_bind(fcx, f, args_opt_0);\n-\n-        // Pull out the arguments.\n-        let vec[@ast::expr] args_1 = [];\n-        for (option::t[@ast::expr] arg in result._1) {\n-            args_1 += [option::get[@ast::expr](arg)];\n-        }\n+        check_call_or_bind(fcx, f, args_opt_0);\n \n-        ret tup(result._0, args_1);\n+        ret tup(f, args);\n     }\n \n     alt (expr.node) {\n@@ -2400,14 +2385,14 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n \n         case (ast::expr_bind(?f, ?args, ?a)) {\n             // Call the generic checker.\n-            auto result = check_call_or_bind(fcx, f, args);\n+            check_call_or_bind(fcx, f, args);\n \n             // Pull the argument and return types out.\n             auto proto_1;\n             let vec[ty::arg] arg_tys_1 = [];\n             auto rt_1;\n             alt (struct(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, fcx.ccx.node_types,\n-                                             result._0))) {\n+                                             f))) {\n                 case (ty::ty_fn(?proto, ?arg_tys, ?rt)) {\n                     proto_1 = proto;\n                     rt_1 = rt;\n@@ -2435,8 +2420,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) -> @ast::expr {\n             auto ann = triv_ann(a.id, t_1);\n             write_type_only(fcx.ccx.node_types, a.id, t_1);\n             ret @fold::respan[ast::expr_](expr.span,\n-                                          ast::expr_bind(result._0, result._1,\n-                                                         ann));\n+                                          ast::expr_bind(f, args, ann));\n         }\n \n         case (ast::expr_call(?f, ?args, ?a)) {"}]}