{"sha": "45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MjMyZGZhNjg5YmFmYWRmOThiOTJlZjMwZmQzMmVhOWE1ZTllN2E=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T15:13:21Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-12-21T15:13:21Z"}, "message": "organize completion tests better", "tree": {"sha": "4652bd1f393540f2f5abdaaab367cfb0b46a10d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4652bd1f393540f2f5abdaaab367cfb0b46a10d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "html_url": "https://github.com/rust-lang/rust/commit/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4ef07b2355df891d4f9b7641f0246ebe5bd6a6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4ef07b2355df891d4f9b7641f0246ebe5bd6a6b", "html_url": "https://github.com/rust-lang/rust/commit/d4ef07b2355df891d4f9b7641f0246ebe5bd6a6b"}], "stats": {"total": 881, "additions": 488, "deletions": 393}, "files": [{"sha": "a11e98ac0be8ebdb07c42b91ebabce54ca2f8e1f", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 34, "deletions": 309, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "patch": "@@ -16,7 +16,7 @@ use hir::source_binder;\n use crate::{\n     db,\n     Cancelable, FilePosition,\n-    completion::completion_item::Completions,\n+    completion::completion_item::{Completions, CompletionKind},\n };\n \n pub use crate::completion::completion_item::{CompletionItem, InsertText};\n@@ -81,7 +81,12 @@ fn param_completions(acc: &mut Completions, ctx: SyntaxNodeRef) {\n                 Some((label, lookup))\n             }\n         })\n-        .for_each(|(label, lookup)| CompletionItem::new(label).lookup_by(lookup).add_to(acc));\n+        .for_each(|(label, lookup)| {\n+            CompletionItem::new(label)\n+                .lookup_by(lookup)\n+                .kind(CompletionKind::Magic)\n+                .add_to(acc)\n+        });\n \n     fn process<'a, N: ast::FnDefOwner<'a>>(\n         node: N,\n@@ -105,341 +110,61 @@ fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use test_utils::assert_eq_dbg;\n-\n-    use crate::mock_analysis::single_file_with_position;\n+fn check_completion(code: &str, expected_completions: &str, kind: CompletionKind) {\n+    use crate::mock_analysis::{single_file_with_position, analysis_and_position};\n+    let (analysis, position) = if code.contains(\"//-\") {\n+        analysis_and_position(code)\n+    } else {\n+        single_file_with_position(code)\n+    };\n+    let completions = completions(&analysis.imp.db, position).unwrap().unwrap();\n+    completions.assert_match(expected_completions, kind);\n+}\n \n+#[cfg(test)]\n+mod tests {\n     use super::*;\n \n-    fn is_snippet(completion_item: &CompletionItem) -> bool {\n-        match completion_item.insert_text() {\n-            InsertText::Snippet { .. } => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn check_scope_completion(code: &str, expected_completions: &str) {\n-        let (analysis, position) = single_file_with_position(code);\n-        let completions = completions(&analysis.imp.db, position)\n-            .unwrap()\n-            .unwrap()\n-            .into_iter()\n-            .filter(|c| !is_snippet(c))\n-            .collect::<Vec<_>>();\n-        assert_eq_dbg(expected_completions, &completions);\n-    }\n-\n-    fn check_snippet_completion(code: &str, expected_completions: &str) {\n-        let (analysis, position) = single_file_with_position(code);\n-        let completions = completions(&analysis.imp.db, position)\n-            .unwrap()\n-            .unwrap()\n-            .into_iter()\n-            .filter(is_snippet)\n-            .collect::<Vec<_>>();\n-        assert_eq_dbg(expected_completions, &completions);\n-    }\n-\n-    #[test]\n-    fn test_completion_let_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux(x: i32) {\n-                let y = 92;\n-                1 + <|>;\n-                let z = ();\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"y\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_if_let_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux() {\n-                if let Some(x) = foo() {\n-                    let y = 92;\n-                };\n-                if let Some(a) = bar() {\n-                    let b = 62;\n-                    1 + <|>\n-                }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"b\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"a\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_for_scope() {\n-        check_scope_completion(\n-            r\"\n-            fn quux() {\n-                for x in &[1, 2, 3] {\n-                    <|>\n-                }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            enum Baz {}\n-            fn quux() {\n-                <|>\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"quux\", lookup: None, snippet: None },\n-                CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-                CompletionItem { label: \"Baz\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_no_self_use() {\n-        check_scope_completion(\n-            r\"\n-            use foo<|>;\n-            \",\n-            r#\"[]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_self_path() {\n-        check_scope_completion(\n-            r\"\n-            use self::m::<|>;\n-\n-            mod m {\n-                struct Bar;\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_completion_mod_scope_nested() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            mod m {\n-                struct Bar;\n-                fn quux() { <|> }\n-            }\n-            \",\n-            r#\"[CompletionItem { label: \"quux\", lookup: None, snippet: None },\n-                CompletionItem { label: \"Bar\", lookup: None, snippet: None }]\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn test_complete_type() {\n-        check_scope_completion(\n-            r\"\n-            struct Foo;\n-            fn x() -> <|>\n-        \",\n-            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-               CompletionItem { label: \"x\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_shadowing() {\n-        check_scope_completion(\n-            r\"\n-            fn foo() -> {\n-                let bar = 92;\n-                {\n-                    let bar = 62;\n-                    <|>\n-                }\n-            }\n-        \",\n-            r#\"[CompletionItem { label: \"bar\", lookup: None, snippet: None },\n-               CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_complete_self() {\n-        check_scope_completion(\n-            r\"\n-            impl S { fn foo(&self) { <|> } }\n-        \",\n-            r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None }]\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn test_completion_kewords() {\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                <|>\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_else() {\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                if true {\n-                    ()\n-                } <|>\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"else\", lookup: None, snippet: Some(\"else {$0}\") },\n-                   CompletionItem { label: \"else if\", lookup: None, snippet: Some(\"else if $0 {}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_return_value() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                <|>\n-                92\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0;\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-        check_snippet_completion(r\"\n-            fn quux() {\n-                <|>\n-                92\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return;\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_completion_return_no_stmt() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                match () {\n-                    () => <|>\n-                }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_continue_break_completion() {\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                loop { <|> }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"continue\", lookup: None, snippet: Some(\"continue\") },\n-                   CompletionItem { label: \"break\", lookup: None, snippet: Some(\"break\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n-        check_snippet_completion(r\"\n-            fn quux() -> i32 {\n-                loop { || { <|> } }\n-            }\n-            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n-                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n-                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n-                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n-                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n-                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n-                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    fn check_magic_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Magic);\n     }\n \n     #[test]\n     fn test_param_completion_last_param() {\n-        check_scope_completion(r\"\n+        check_magic_completion(\n+            r\"\n             fn foo(file_id: FileId) {}\n             fn bar(file_id: FileId) {}\n             fn baz(file<|>) {}\n-        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n     }\n \n     #[test]\n     fn test_param_completion_nth_param() {\n-        check_scope_completion(r\"\n+        check_magic_completion(\n+            r\"\n             fn foo(file_id: FileId) {}\n             fn bar(file_id: FileId) {}\n             fn baz(file<|>, x: i32) {}\n-        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+            \",\n+            r#\"file_id \"file_id: FileId\"\"#,\n+        );\n     }\n \n     #[test]\n     fn test_param_completion_trait_param() {\n-        check_scope_completion(r\"\n+        check_magic_completion(\n+            r\"\n             pub(crate) trait SourceRoot {\n                 pub fn contains(&self, file_id: FileId) -> bool;\n                 pub fn module_map(&self) -> &ModuleMap;\n                 pub fn lines(&self, file_id: FileId) -> &LineIndex;\n                 pub fn syntax(&self, file<|>)\n             }\n-        \", r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None },\n-               CompletionItem { label: \"SourceRoot\", lookup: None, snippet: None },\n-               CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n-    }\n-\n-    #[test]\n-    fn test_item_snippets() {\n-        // check_snippet_completion(r\"\n-        //     <|>\n-        //     \",\n-        //     r##\"[CompletionItem { label: \"Test function\", lookup: None, snippet: Some(\"#[test]\\nfn test_${1:feature}() {\\n$0\\n}\"##,\n-        // );\n-        check_snippet_completion(r\"\n-            #[cfg(test)]\n-            mod tests {\n-                <|>\n-            }\n             \",\n-            r##\"[CompletionItem { label: \"Test function\", lookup: Some(\"tfn\"), snippet: Some(\"#[test]\\nfn ${1:feature}() {\\n    $0\\n}\") },\n-                 CompletionItem { label: \"pub(crate)\", lookup: None, snippet: Some(\"pub(crate) $0\") }]\"##,\n+            r#\"file_id \"file_id: FileId\"\"#,\n         );\n     }\n }"}, {"sha": "d5d751759858d4d6b72c07ba88af40ddc50ab7b0", "filename": "crates/ra_analysis/src/completion/completion_item.rs", "status": "modified", "additions": 76, "deletions": 4, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "patch": "@@ -6,20 +6,35 @@ pub struct CompletionItem {\n     label: String,\n     lookup: Option<String>,\n     snippet: Option<String>,\n+    /// Used only internally in test, to check only specific kind of completion.\n+    kind: CompletionKind,\n }\n \n pub enum InsertText {\n     PlainText { text: String },\n     Snippet { text: String },\n }\n \n+#[derive(Debug, PartialEq, Eq)]\n+pub(crate) enum CompletionKind {\n+    /// Parser-based keyword completion.\n+    Keyword,\n+    /// Your usual \"complete all valid identifiers\".\n+    Reference,\n+    /// \"Secret sauce\" completions.\n+    Magic,\n+    Snippet,\n+    Unspecified,\n+}\n+\n impl CompletionItem {\n     pub(crate) fn new(label: impl Into<String>) -> Builder {\n         let label = label.into();\n         Builder {\n             label,\n             lookup: None,\n             snippet: None,\n+            kind: CompletionKind::Unspecified,\n         }\n     }\n     /// What user sees in pop-up in the UI.\n@@ -50,28 +65,34 @@ pub(crate) struct Builder {\n     label: String,\n     lookup: Option<String>,\n     snippet: Option<String>,\n+    kind: CompletionKind,\n }\n \n impl Builder {\n-    pub fn add_to(self, acc: &mut Completions) {\n+    pub(crate) fn add_to(self, acc: &mut Completions) {\n         acc.add(self.build())\n     }\n \n-    pub fn build(self) -> CompletionItem {\n+    pub(crate) fn build(self) -> CompletionItem {\n         CompletionItem {\n             label: self.label,\n             lookup: self.lookup,\n             snippet: self.snippet,\n+            kind: self.kind,\n         }\n     }\n-    pub fn lookup_by(mut self, lookup: impl Into<String>) -> Builder {\n+    pub(crate) fn lookup_by(mut self, lookup: impl Into<String>) -> Builder {\n         self.lookup = Some(lookup.into());\n         self\n     }\n-    pub fn snippet(mut self, snippet: impl Into<String>) -> Builder {\n+    pub(crate) fn snippet(mut self, snippet: impl Into<String>) -> Builder {\n         self.snippet = Some(snippet.into());\n         self\n     }\n+    pub(crate) fn kind(mut self, kind: CompletionKind) -> Builder {\n+        self.kind = kind;\n+        self\n+    }\n }\n \n impl Into<CompletionItem> for Builder {\n@@ -97,6 +118,57 @@ impl Completions {\n     {\n         items.into_iter().for_each(|item| self.add(item.into()))\n     }\n+\n+    #[cfg(test)]\n+    pub(crate) fn assert_match(&self, expected: &str, kind: CompletionKind) {\n+        let expected = normalize(expected);\n+        let actual = self.debug_render(kind);\n+        test_utils::assert_eq_text!(expected.as_str(), actual.as_str(),);\n+\n+        /// Normalize the textual representation of `Completions`:\n+        /// replace `;` with newlines, normalize whitespace\n+        fn normalize(expected: &str) -> String {\n+            use ra_syntax::{tokenize, TextUnit, TextRange, SyntaxKind::SEMI};\n+            let mut res = String::new();\n+            for line in expected.trim().lines() {\n+                let line = line.trim();\n+                let mut start_offset: TextUnit = 0.into();\n+                // Yep, we use rust tokenize in completion tests :-)\n+                for token in tokenize(line) {\n+                    let range = TextRange::offset_len(start_offset, token.len);\n+                    start_offset += token.len;\n+                    if token.kind == SEMI {\n+                        res.push('\\n');\n+                    } else {\n+                        res.push_str(&line[range]);\n+                    }\n+                }\n+\n+                res.push('\\n');\n+            }\n+            res\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    fn debug_render(&self, kind: CompletionKind) -> String {\n+        let mut res = String::new();\n+        for c in self.buf.iter() {\n+            if c.kind == kind {\n+                if let Some(lookup) = &c.lookup {\n+                    res.push_str(lookup);\n+                    res.push_str(&format!(\" {:?}\", c.label));\n+                } else {\n+                    res.push_str(&c.label);\n+                }\n+                if let Some(snippet) = &c.snippet {\n+                    res.push_str(&format!(\" {:?}\", snippet));\n+                }\n+                res.push('\\n');\n+            }\n+        }\n+        res\n+    }\n }\n \n impl Into<Vec<CompletionItem>> for Completions {"}, {"sha": "c2a650b6d38daa032618edc030b3de962bdb2c82", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 368, "deletions": 8, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "patch": "@@ -13,7 +13,7 @@ use hir::{\n \n use crate::{\n     db::RootDatabase,\n-    completion::{CompletionItem, Completions},\n+    completion::{CompletionItem, Completions, CompletionKind::*},\n     Cancelable\n };\n \n@@ -51,7 +51,11 @@ pub(super) fn completions(\n                         }\n                     }\n                 })\n-                .for_each(|(name, _res)| CompletionItem::new(name.to_string()).add_to(acc));\n+                .for_each(|(name, _res)| {\n+                    CompletionItem::new(name.to_string())\n+                        .kind(Reference)\n+                        .add_to(acc)\n+                });\n         }\n         NameRefKind::Path(path) => complete_path(acc, db, module, path)?,\n         NameRefKind::BareIdentInMod => {\n@@ -123,9 +127,13 @@ fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Completions)\n         .scope_chain(name_ref.syntax())\n         .flat_map(|scope| scopes.entries(scope).iter())\n         .filter(|entry| shadowed.insert(entry.name()))\n-        .for_each(|entry| CompletionItem::new(entry.name().to_string()).add_to(acc));\n+        .for_each(|entry| {\n+            CompletionItem::new(entry.name().to_string())\n+                .kind(Reference)\n+                .add_to(acc)\n+        });\n     if scopes.self_param.is_some() {\n-        CompletionItem::new(\"self\").add_to(acc);\n+        CompletionItem::new(\"self\").kind(Reference).add_to(acc);\n     }\n }\n \n@@ -148,9 +156,11 @@ fn complete_path(\n         _ => return Ok(()),\n     };\n     let module_scope = target_module.scope(db)?;\n-    module_scope\n-        .entries()\n-        .for_each(|(name, _res)| CompletionItem::new(name.to_string()).add_to(acc));\n+    module_scope.entries().for_each(|(name, _res)| {\n+        CompletionItem::new(name.to_string())\n+            .kind(Reference)\n+            .add_to(acc)\n+    });\n     Ok(())\n }\n \n@@ -164,9 +174,11 @@ fn ${1:feature}() {\n     $0\n }\",\n         )\n+        .kind(Snippet)\n         .add_to(acc);\n     CompletionItem::new(\"pub(crate)\")\n         .snippet(\"pub(crate) $0\")\n+        .kind(Snippet)\n         .add_to(acc);\n }\n \n@@ -249,14 +261,362 @@ fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<Complet\n }\n \n fn keyword(kw: &str, snippet: &str) -> CompletionItem {\n-    CompletionItem::new(kw).snippet(snippet).build()\n+    CompletionItem::new(kw)\n+        .kind(Keyword)\n+        .snippet(snippet)\n+        .build()\n }\n \n fn complete_expr_snippets(acc: &mut Completions) {\n     CompletionItem::new(\"pd\")\n         .snippet(\"eprintln!(\\\"$0 = {:?}\\\", $0);\")\n+        .kind(Snippet)\n         .add_to(acc);\n     CompletionItem::new(\"ppd\")\n         .snippet(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\")\n+        .kind(Snippet)\n         .add_to(acc);\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::{CompletionKind, check_completion};\n+\n+    fn check_reference_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Reference);\n+    }\n+\n+    fn check_keyword_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Keyword);\n+    }\n+\n+    fn check_snippet_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Snippet);\n+    }\n+\n+    #[test]\n+    fn test_completion_let_scope() {\n+        check_reference_completion(\n+            r\"\n+            fn quux(x: i32) {\n+                let y = 92;\n+                1 + <|>;\n+                let z = ();\n+            }\n+            \",\n+            \"y;x;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_if_let_scope() {\n+        check_reference_completion(\n+            r\"\n+            fn quux() {\n+                if let Some(x) = foo() {\n+                    let y = 92;\n+                };\n+                if let Some(a) = bar() {\n+                    let b = 62;\n+                    1 + <|>\n+                }\n+            }\n+            \",\n+            \"b;a;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_for_scope() {\n+        check_reference_completion(\n+            r\"\n+            fn quux() {\n+                for x in &[1, 2, 3] {\n+                    <|>\n+                }\n+            }\n+            \",\n+            \"x;quux\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            enum Baz {}\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            \"quux;Foo;Baz\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope_no_self_use() {\n+        check_reference_completion(\n+            r\"\n+            use foo<|>;\n+            \",\n+            \"\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_self_path() {\n+        check_reference_completion(\n+            r\"\n+            use self::m::<|>;\n+\n+            mod m {\n+                struct Bar;\n+            }\n+            \",\n+            \"Bar\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope_nested() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            mod m {\n+                struct Bar;\n+                fn quux() { <|> }\n+            }\n+            \",\n+            \"quux;Bar\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_complete_type() {\n+        check_reference_completion(\n+            r\"\n+            struct Foo;\n+            fn x() -> <|>\n+            \",\n+            \"Foo;x\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_shadowing() {\n+        check_reference_completion(\n+            r\"\n+            fn foo() -> {\n+                let bar = 92;\n+                {\n+                    let bar = 62;\n+                    <|>\n+                }\n+            }\n+            \",\n+            \"bar;foo\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_self() {\n+        check_reference_completion(r\"impl S { fn foo(&self) { <|> } }\", \"self\")\n+    }\n+\n+    #[test]\n+    fn test_complete_crate_path() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            struct Spam;\n+            //- /foo.rs\n+            use crate::Sp<|>\n+            \",\n+            \"Spam;foo\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_complete_crate_path_with_braces() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            struct Spam;\n+            //- /foo.rs\n+            use crate::{Sp<|>};\n+            \",\n+            \"Spam;foo\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_complete_crate_path_in_nested_tree() {\n+        check_reference_completion(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+            pub mod bar {\n+                pub mod baz {\n+                    pub struct Spam;\n+                }\n+            }\n+            //- /foo.rs\n+            use crate::{bar::{baz::Sp<|>}};\n+            \",\n+            \"Spam\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_kewords() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_else() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                if true {\n+                    ()\n+                } <|>\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            else \"else {$0}\"\n+            else if \"else if $0 {}\"\n+            return \"return\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_return_value() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                <|>\n+                92\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0;\"\n+            \"#,\n+        );\n+        check_keyword_completion(\n+            r\"\n+            fn quux() {\n+                <|>\n+                92\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return;\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_return_no_stmt() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                match () {\n+                    () => <|>\n+                }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_continue_break_completion() {\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                loop { <|> }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            continue \"continue\"\n+            break \"break\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+        check_keyword_completion(\n+            r\"\n+            fn quux() -> i32 {\n+                loop { || { <|> } }\n+            }\n+            \",\n+            r#\"\n+            if \"if $0 {}\"\n+            match \"match $0 {}\"\n+            while \"while $0 {}\"\n+            loop \"loop {$0}\"\n+            return \"return $0\"\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_item_snippets() {\n+        // check_snippet_completion(r\"\n+        //     <|>\n+        //     \",\n+        //     r##\"[CompletionItem { label: \"Test function\", lookup: None, snippet: Some(\"#[test]\\nfn test_${1:feature}() {\\n$0\\n}\"##,\n+        // );\n+        check_snippet_completion(\n+            r\"\n+            #[cfg(test)]\n+            mod tests {\n+                <|>\n+            }\n+            \",\n+            r##\"\n+            tfn \"Test function\" \"#[test]\\nfn ${1:feature}() {\\n    $0\\n}\"\n+            pub(crate) \"pub(crate) $0\"\n+        \"##,\n+        );\n+    }\n+\n+}"}, {"sha": "938ca797a2d5980cdd530d46c043b2cf8b552deb", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "patch": "@@ -452,63 +452,3 @@ fn test_find_all_refs_for_fn_param() {\n     let refs = get_all_refs(code);\n     assert_eq!(refs.len(), 2);\n }\n-\n-#[test]\n-fn test_complete_crate_path() {\n-    let (analysis, position) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        struct Spam;\n-        //- /foo.rs\n-        use crate::Sp<|>\n-    \",\n-    );\n-    let completions = analysis.completions(position).unwrap().unwrap();\n-    assert_eq_dbg(\n-        r#\"[CompletionItem { label: \"Spam\", lookup: None, snippet: None },\n-            CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n-        &completions,\n-    );\n-}\n-\n-#[test]\n-fn test_complete_crate_path_with_braces() {\n-    let (analysis, position) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        struct Spam;\n-        //- /foo.rs\n-        use crate::{Sp<|>};\n-    \",\n-    );\n-    let completions = analysis.completions(position).unwrap().unwrap();\n-    assert_eq_dbg(\n-        r#\"[CompletionItem { label: \"Spam\", lookup: None, snippet: None },\n-            CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n-        &completions,\n-    );\n-}\n-\n-#[test]\n-fn test_complete_crate_path_in_nested_tree() {\n-    let (analysis, position) = analysis_and_position(\n-        \"\n-        //- /lib.rs\n-        mod foo;\n-        pub mod bar {\n-            pub mod baz {\n-                pub struct Spam;\n-            }\n-        }\n-        //- /foo.rs\n-        use crate::{bar::{baz::Sp<|>}};\n-    \",\n-    );\n-    let completions = analysis.completions(position).unwrap().unwrap();\n-    assert_eq_dbg(\n-        r#\"[CompletionItem { label: \"Spam\", lookup: None, snippet: None }]\"#,\n-        &completions,\n-    );\n-}"}, {"sha": "beb936c616d3a5d7cf0cb9517a514caf5bade9e5", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45232dfa689bafadf98b92ef30fd32ea9a5e9e7a/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=45232dfa689bafadf98b92ef30fd32ea9a5e9e7a", "patch": "@@ -10,22 +10,20 @@ pub const CURSOR_MARKER: &str = \"<|>\";\n \n #[macro_export]\n macro_rules! assert_eq_text {\n-    ($expected:expr, $actual:expr) => {{\n-        let expected = $expected;\n-        let actual = $actual;\n-        if expected != actual {\n-            let changeset = $crate::__Changeset::new(actual, expected, \"\\n\");\n-            println!(\"Expected:\\n{}\\n\\nActual:\\n{}\\nDiff:{}\\n\", expected, actual, changeset);\n-            panic!(\"text differs\");\n-        }\n-    }};\n+    ($expected:expr, $actual:expr) => {\n+        assert_eq_text!($expected, $actual,)\n+    };\n     ($expected:expr, $actual:expr, $($tt:tt)*) => {{\n         let expected = $expected;\n         let actual = $actual;\n         if expected != actual {\n-            let changeset = $crate::__Changeset::new(actual, expected, \"\\n\");\n-            println!(\"Expected:\\n{}\\n\\nActual:\\n{}\\n\\nDiff:\\n{}\\n\", expected, actual, changeset);\n-            println!($($tt)*);\n+            if expected.trim() == actual.trim() {\n+                eprintln!(\"Expected:\\n{:?}\\n\\nActual:\\n{:?}\\n\\nWhitespace difference\\n\", expected, actual);\n+            } else {\n+                let changeset = $crate::__Changeset::new(actual, expected, \"\\n\");\n+                eprintln!(\"Expected:\\n{}\\n\\nActual:\\n{}\\n\\nDiff:\\n{}\\n\", expected, actual, changeset);\n+            }\n+            eprintln!($($tt)*);\n             panic!(\"text differs\");\n         }\n     }};"}]}