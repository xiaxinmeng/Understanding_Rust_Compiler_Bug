{"sha": "95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1YjRhNGYwZWVlOTM1ZjllMGM4MGIwY2VlZjM0ODY2YmNiNzJjYTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-16T07:44:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-16T07:44:35Z"}, "message": "Auto merge of #77666 - fusion-engineering-forks:vxworks-cleanup, r=dtolnay\n\nVxworks / Unix deduplication\n\n`sys/vxworks` was almost entirely an (outdated) copy of `sys/unix`. I went through every file to check the differences and tried to figure out if they were simply outdated or intentional differences between `unix` and `vxworks`. Most of them did not have any `vxworks`-specific changes, so are deleted. I've added some minor `cfg(target_os = \"vxworks\")`-specific things to `sys/unix` to allow for deduplication.\n\nBefore this change, the vxworks target didn't compile because its outdated process implementation did not match the expected interface anymore. This also fixes that: `std` compiles again for `x86_64-wrs-vxworks`.\n\nIt's probably good to merge `sys/vxworks` entirely into `sys/unix`, but it might be better to to that in a follow-up PR.\n\n`@rustbot` modify labels: +T-libs +C-cleanup", "tree": {"sha": "e404cae93e41a1068f17a2c7294691822b8fd4a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e404cae93e41a1068f17a2c7294691822b8fd4a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "html_url": "https://github.com/rust-lang/rust/commit/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e6f69afc9b0943003ce51a53d1f59611e6601a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6f69afc9b0943003ce51a53d1f59611e6601a3", "html_url": "https://github.com/rust-lang/rust/commit/8e6f69afc9b0943003ce51a53d1f59611e6601a3"}, {"sha": "0f0257be101281d65462bd5bfe92325f636e1950", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f0257be101281d65462bd5bfe92325f636e1950", "html_url": "https://github.com/rust-lang/rust/commit/0f0257be101281d65462bd5bfe92325f636e1950"}], "stats": {"total": 4702, "additions": 226, "deletions": 4476}, "files": [{"sha": "77e6238ca1f528dd11420ae35724608ce9e4cbdf", "filename": "library/std/src/os/vxworks/fs.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -26,10 +26,16 @@ pub trait MetadataExt {\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_atime(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_mtime(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_ctime(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_blksize(&self) -> u64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_blocks(&self) -> u64;\n@@ -66,12 +72,21 @@ impl MetadataExt for Metadata {\n     fn st_atime(&self) -> i64 {\n         self.as_inner().as_inner().st_atime as i64\n     }\n+    fn st_atime_nsec(&self) -> i64 {\n+        0\n+    }\n     fn st_mtime(&self) -> i64 {\n         self.as_inner().as_inner().st_mtime as i64\n     }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        0\n+    }\n     fn st_ctime(&self) -> i64 {\n         self.as_inner().as_inner().st_ctime as i64\n     }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        0\n+    }\n     fn st_blksize(&self) -> u64 {\n         self.as_inner().as_inner().st_blksize as u64\n     }"}, {"sha": "cb41ddfe2a9bf4d916441ec8632da981d3b933bf", "filename": "library/std/src/os/vxworks/raw.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Fraw.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -5,3 +5,6 @@ use crate::os::raw::c_ulong;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = c_ulong;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub use libc::{blkcnt_t, blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t, time_t};"}, {"sha": "69676472493909b72be73204bc05a7262e595815", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -70,7 +70,8 @@ impl DoubleEndedIterator for Args {\n     target_os = \"haiku\",\n     target_os = \"l4re\",\n     target_os = \"fuchsia\",\n-    target_os = \"redox\"\n+    target_os = \"redox\",\n+    target_os = \"vxworks\"\n ))]\n mod imp {\n     use super::Args;"}, {"sha": "66bbc1c585413906067b8372804ffd948f978829", "filename": "library/std/src/sys/unix/ext/fs.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -650,6 +650,9 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn blocks(&self) -> u64;\n+    #[cfg(target_os = \"vxworks\")]\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn attrib(&self) -> u8;\n }\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n@@ -702,6 +705,10 @@ impl MetadataExt for fs::Metadata {\n     fn blocks(&self) -> u64 {\n         self.st_blocks()\n     }\n+    #[cfg(target_os = \"vxworks\")]\n+    fn attrib(&self) -> u8 {\n+        self.st_attrib()\n+    }\n }\n \n /// Unix-specific extensions for [`fs::FileType`]."}, {"sha": "3615a8a5ee8b0432be4e369993d1cd360cb57a00", "filename": "library/std/src/sys/unix/ext/process.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -16,12 +16,20 @@ pub trait CommandExt {\n     /// `setuid` call in the child process. Failure in the `setuid`\n     /// call will cause the spawn to fail.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn uid(&mut self, id: u32) -> &mut process::Command;\n+    fn uid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command;\n \n     /// Similar to `uid`, but sets the group ID of the child process. This has\n     /// the same semantics as the `uid` field.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn gid(&mut self, id: u32) -> &mut process::Command;\n+    fn gid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command;\n \n     /// Schedules a closure to be run just before the `exec` function is\n     /// invoked.\n@@ -115,12 +123,20 @@ pub trait CommandExt {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CommandExt for process::Command {\n-    fn uid(&mut self, id: u32) -> &mut process::Command {\n+    fn uid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command {\n         self.as_inner_mut().uid(id);\n         self\n     }\n \n-    fn gid(&mut self, id: u32) -> &mut process::Command {\n+    fn gid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command {\n         self.as_inner_mut().gid(id);\n         self\n     }"}, {"sha": "d3a279a23553ee551d7812a86094cad051c441e1", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -200,7 +200,8 @@ impl FileDesc {\n         target_os = \"l4re\",\n         target_os = \"linux\",\n         target_os = \"haiku\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     )))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n@@ -217,7 +218,8 @@ impl FileDesc {\n         target_os = \"l4re\",\n         target_os = \"linux\",\n         target_os = \"haiku\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {"}, {"sha": "819e8ef18415b3d1fb1aa6934f165153b468dae9", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -297,20 +297,38 @@ impl FileAttr {\n \n #[cfg(not(target_os = \"netbsd\"))]\n impl FileAttr {\n+    #[cfg(not(target_os = \"vxworks\"))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_mtime as libc::time_t,\n             tv_nsec: self.stat.st_mtime_nsec as _,\n         }))\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_mtime as libc::time_t,\n+            tv_nsec: 0,\n+        }))\n+    }\n+\n+    #[cfg(not(target_os = \"vxworks\"))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_atime as libc::time_t,\n             tv_nsec: self.stat.st_atime_nsec as _,\n         }))\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_atime as libc::time_t,\n+            tv_nsec: 0,\n+        }))\n+    }\n+\n     #[cfg(any(\n         target_os = \"freebsd\",\n         target_os = \"openbsd\",\n@@ -535,12 +553,22 @@ impl DirEntry {\n         lstat(&self.path())\n     }\n \n-    #[cfg(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"haiku\"))]\n+    #[cfg(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n+    ))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         lstat(&self.path()).map(|m| m.file_type())\n     }\n \n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"haiku\")))]\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n+    )))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         match self.entry.d_type {\n             libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n@@ -565,7 +593,8 @@ impl DirEntry {\n         target_os = \"haiku\",\n         target_os = \"l4re\",\n         target_os = \"fuchsia\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n@@ -603,7 +632,8 @@ impl DirEntry {\n         target_os = \"linux\",\n         target_os = \"emscripten\",\n         target_os = \"l4re\",\n-        target_os = \"haiku\"\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n     ))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes() }\n@@ -901,13 +931,25 @@ impl fmt::Debug for File {\n             Some(PathBuf::from(OsString::from_vec(buf)))\n         }\n \n-        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n+        #[cfg(target_os = \"vxworks\")]\n+        fn get_path(fd: c_int) -> Option<PathBuf> {\n+            let mut buf = vec![0; libc::PATH_MAX as usize];\n+            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n+            if n == -1 {\n+                return None;\n+            }\n+            let l = buf.iter().position(|&c| c == 0).unwrap();\n+            buf.truncate(l as usize);\n+            Some(PathBuf::from(OsString::from_vec(buf)))\n+        }\n+\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n         fn get_path(_fd: c_int) -> Option<PathBuf> {\n             // FIXME(#24570): implement this for other Unix platforms\n             None\n         }\n \n-        #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+        #[cfg(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\"))]\n         fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n             let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n             if mode == -1 {\n@@ -921,7 +963,7 @@ impl fmt::Debug for File {\n             }\n         }\n \n-        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n         fn get_mode(_fd: c_int) -> Option<(bool, bool)> {\n             // FIXME(#24570): implement this for other Unix platforms\n             None"}, {"sha": "74c7db27226ef8a43b6e9f9177daf9914297ba7f", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -77,6 +77,7 @@ impl Socket {\n         }\n     }\n \n+    #[cfg(not(target_os = \"vxworks\"))]\n     pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> {\n         unsafe {\n             let mut fds = [0, 0];\n@@ -98,6 +99,11 @@ impl Socket {\n         }\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {\n+        unimplemented!()\n+    }\n+\n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n         self.set_nonblocking(true)?;\n         let r = unsafe {\n@@ -366,7 +372,7 @@ impl IntoInner<c_int> for Socket {\n // res_init unconditionally, we call it only when we detect we're linking\n // against glibc version < 2.26. (That is, when we both know its needed and\n // believe it's thread-safe).\n-#[cfg(target_env = \"gnu\")]\n+#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\n fn on_resolver_failure() {\n     use crate::sys;\n \n@@ -378,5 +384,5 @@ fn on_resolver_failure() {\n     }\n }\n \n-#[cfg(not(target_env = \"gnu\"))]\n+#[cfg(any(not(target_env = \"gnu\"), target_os = \"vxworks\"))]\n fn on_resolver_failure() {}"}, {"sha": "d5e14bec7657298e2d4ced4951a300c5fa81ab51", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -37,7 +37,7 @@ cfg_if::cfg_if! {\n }\n \n extern \"C\" {\n-    #[cfg(not(target_os = \"dragonfly\"))]\n+    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\n     #[cfg_attr(\n         any(\n             target_os = \"linux\",\n@@ -67,18 +67,28 @@ extern \"C\" {\n }\n \n /// Returns the platform-specific value of errno\n-#[cfg(not(target_os = \"dragonfly\"))]\n+#[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\n pub fn errno() -> i32 {\n     unsafe { (*errno_location()) as i32 }\n }\n \n /// Sets the platform-specific value of errno\n-#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\")))] // needed for readdir and syscall!\n+#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\"), not(target_os = \"vxworks\")))] // needed for readdir and syscall!\n #[allow(dead_code)] // but not all target cfgs actually end up using it\n pub fn set_errno(e: i32) {\n     unsafe { *errno_location() = e as c_int }\n }\n \n+#[cfg(target_os = \"vxworks\")]\n+pub fn errno() -> i32 {\n+    unsafe { libc::errnoGet() }\n+}\n+\n+#[cfg(target_os = \"vxworks\")]\n+pub fn set_errno(e: i32) {\n+    unsafe { libc::errnoSet(e as c_int) };\n+}\n+\n #[cfg(target_os = \"dragonfly\")]\n pub fn errno() -> i32 {\n     extern \"C\" {\n@@ -439,6 +449,19 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     Err(io::Error::new(ErrorKind::Other, \"Not yet implemented!\"))\n }\n \n+#[cfg(target_os = \"vxworks\")]\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    #[cfg(test)]\n+    use realstd::env;\n+\n+    #[cfg(not(test))]\n+    use crate::env;\n+\n+    let exe_path = env::args().next().unwrap();\n+    let path = path::Path::new(&exe_path);\n+    path.canonicalize()\n+}\n+\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n@@ -568,7 +591,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"android\",\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     unsafe fn fallback() -> Option<OsString> {\n         None\n@@ -577,7 +601,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"android\",\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     )))]\n     unsafe fn fallback() -> Option<OsString> {\n         let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {"}, {"sha": "4b29b7020eb8547e30ab1d55b91f84d177ed235e", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -24,6 +24,8 @@ cfg_if::cfg_if! {\n         // fuchsia doesn't have /dev/null\n     } else if #[cfg(target_os = \"redox\")] {\n         const DEV_NULL: &str = \"null:\\0\";\n+    } else if #[cfg(target_os = \"vxworks\")] {\n+        const DEV_NULL: &str = \"/null\\0\";\n     } else {\n         const DEV_NULL: &str = \"/dev/null\\0\";\n     }\n@@ -48,7 +50,7 @@ cfg_if::cfg_if! {\n             raw[bit / 8] |= 1 << (bit % 8);\n             return 0;\n         }\n-    } else {\n+    } else if #[cfg(not(target_os = \"vxworks\"))] {\n         pub use libc::{sigemptyset, sigaddset};\n     }\n }"}, {"sha": "b5be92e3eae006ebb4faf8370e6128cfcd14bb04", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -6,6 +6,10 @@ use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n \n+#[cfg(target_os = \"vxworks\")]\n+use libc::RTP_ID as pid_t;\n+\n+#[cfg(not(target_os = \"vxworks\"))]\n use libc::{c_int, gid_t, pid_t, uid_t};\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "d84742053524eb95950a1727b60dcf94b9c79c23", "filename": "library/std/src/sys/unix/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstack_overflow.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -219,7 +219,7 @@ mod imp {\n     target_os = \"solaris\",\n     target_os = \"illumos\",\n     all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-    target_os = \"openbsd\"\n+    target_os = \"openbsd\",\n )))]\n mod imp {\n     pub unsafe fn init() {}"}, {"sha": "fdf114d6df6fec17fd354e14acee433c9b152c77", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -6,10 +6,12 @@ use crate::ptr;\n use crate::sys::{os, stack_overflow};\n use crate::time::Duration;\n \n-#[cfg(not(target_os = \"l4re\"))]\n+#[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\")))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n #[cfg(target_os = \"l4re\")]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n+#[cfg(target_os = \"vxworks\")]\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 256 * 1024;\n \n pub struct Thread {\n     id: libc::pthread_t,\n@@ -152,10 +154,11 @@ impl Thread {\n         target_os = \"haiku\",\n         target_os = \"l4re\",\n         target_os = \"emscripten\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     pub fn set_name(_name: &CStr) {\n-        // Newlib, Haiku, and Emscripten have no way to set a thread name.\n+        // Newlib, Haiku, Emscripten, and VxWorks have no way to set a thread name.\n     }\n     #[cfg(target_os = \"fuchsia\")]\n     pub fn set_name(_name: &CStr) {"}, {"sha": "97a191d7232e08837fcbac10e3862232784aa53c", "filename": "library/std/src/sys/vxworks/alloc.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Falloc.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,49 +0,0 @@\n-use crate::alloc::{GlobalAlloc, Layout, System};\n-use crate::ptr;\n-use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n-\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-unsafe impl GlobalAlloc for System {\n-    #[inline]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            libc::malloc(layout.size()) as *mut u8\n-        } else {\n-            aligned_malloc(&layout)\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            libc::calloc(layout.size(), 1) as *mut u8\n-        } else {\n-            let ptr = self.alloc(layout.clone());\n-            if !ptr.is_null() {\n-                ptr::write_bytes(ptr, 0, layout.size());\n-            }\n-            ptr\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n-        libc::free(ptr as *mut libc::c_void)\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n-        } else {\n-            realloc_fallback(self, ptr, layout, new_size)\n-        }\n-    }\n-}\n-\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    let mut out = ptr::null_mut();\n-    let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n-    if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n-}"}, {"sha": "30cf7a707c7af9e08d53ec1e6719d98f837ab357", "filename": "library/std/src/sys/vxworks/args.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,95 +0,0 @@\n-#![allow(dead_code)] // runtime init functions not used during testing\n-use crate::ffi::OsString;\n-use crate::marker::PhantomData;\n-use crate::vec;\n-\n-/// One-time global initialization.\n-pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-    imp::init(argc, argv)\n-}\n-\n-/// One-time global cleanup.\n-pub unsafe fn cleanup() {\n-    imp::cleanup()\n-}\n-\n-/// Returns the command line arguments\n-pub fn args() -> Args {\n-    imp::args()\n-}\n-\n-pub struct Args {\n-    iter: vec::IntoIter<OsString>,\n-    _dont_send_or_sync_me: PhantomData<*mut ()>,\n-}\n-\n-impl Args {\n-    pub fn inner_debug(&self) -> &[OsString] {\n-        self.iter.as_slice()\n-    }\n-}\n-\n-impl Iterator for Args {\n-    type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> {\n-        self.iter.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-}\n-\n-impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> {\n-        self.iter.next_back()\n-    }\n-}\n-\n-mod imp {\n-    use super::Args;\n-    use crate::ffi::{CStr, OsString};\n-    use crate::marker::PhantomData;\n-    use crate::ptr;\n-\n-    use crate::sys_common::mutex::StaticMutex;\n-\n-    static mut ARGC: isize = 0;\n-    static mut ARGV: *const *const u8 = ptr::null();\n-    static LOCK: StaticMutex = StaticMutex::new();\n-\n-    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-        let _guard = LOCK.lock();\n-        ARGC = argc;\n-        ARGV = argv;\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        let _guard = LOCK.lock();\n-        ARGC = 0;\n-        ARGV = ptr::null();\n-    }\n-\n-    pub fn args() -> Args {\n-        Args { iter: clone().into_iter(), _dont_send_or_sync_me: PhantomData }\n-    }\n-\n-    fn clone() -> Vec<OsString> {\n-        unsafe {\n-            let _guard = LOCK.lock();\n-            let ret = (0..ARGC)\n-                .map(|i| {\n-                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n-                    use crate::sys::vxworks::ext::ffi::OsStringExt;\n-                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n-                })\n-                .collect();\n-            return ret;\n-        }\n-    }\n-}"}, {"sha": "f327b69fc754109060b23b56f44d3ffb832b1fb9", "filename": "library/std/src/sys/vxworks/cmath.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcmath.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,32 +0,0 @@\n-#![cfg(not(test))]\n-\n-use libc::{c_double, c_float};\n-\n-extern \"C\" {\n-    pub fn acos(n: c_double) -> c_double;\n-    pub fn acosf(n: c_float) -> c_float;\n-    pub fn asin(n: c_double) -> c_double;\n-    pub fn asinf(n: c_float) -> c_float;\n-    pub fn atan(n: c_double) -> c_double;\n-    pub fn atan2(a: c_double, b: c_double) -> c_double;\n-    pub fn atan2f(a: c_float, b: c_float) -> c_float;\n-    pub fn atanf(n: c_float) -> c_float;\n-    pub fn cbrt(n: c_double) -> c_double;\n-    pub fn cbrtf(n: c_float) -> c_float;\n-    pub fn cosh(n: c_double) -> c_double;\n-    pub fn coshf(n: c_float) -> c_float;\n-    pub fn expm1(n: c_double) -> c_double;\n-    pub fn expm1f(n: c_float) -> c_float;\n-    pub fn fdim(a: c_double, b: c_double) -> c_double;\n-    pub fn fdimf(a: c_float, b: c_float) -> c_float;\n-    pub fn hypot(x: c_double, y: c_double) -> c_double;\n-    pub fn hypotf(x: c_float, y: c_float) -> c_float;\n-    pub fn log1p(n: c_double) -> c_double;\n-    pub fn log1pf(n: c_float) -> c_float;\n-    pub fn sinh(n: c_double) -> c_double;\n-    pub fn sinhf(n: c_float) -> c_float;\n-    pub fn tan(n: c_double) -> c_double;\n-    pub fn tanf(n: c_float) -> c_float;\n-    pub fn tanh(n: c_double) -> c_double;\n-    pub fn tanhf(n: c_float) -> c_float;\n-}"}, {"sha": "b4724be7c7c3b38b31e65fba624978384e98e0d5", "filename": "library/std/src/sys/vxworks/condvar.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcondvar.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,91 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::sys::mutex::{self, Mutex};\n-use crate::time::Duration;\n-\n-pub struct Condvar {\n-    inner: UnsafeCell<libc::pthread_cond_t>,\n-}\n-\n-pub type MovableCondvar = Box<Condvar>;\n-\n-unsafe impl Send for Condvar {}\n-unsafe impl Sync for Condvar {}\n-\n-const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n-\n-fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n-    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n-}\n-\n-impl Condvar {\n-    pub const fn new() -> Condvar {\n-        // Might be moved and address is changing it is better to avoid\n-        // initialization of potentially opaque OS data before it landed\n-        Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n-    }\n-\n-    pub unsafe fn init(&mut self) {\n-        use crate::mem::MaybeUninit;\n-        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n-        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n-        assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn notify_one(&self) {\n-        let r = libc::pthread_cond_signal(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        let r = libc::pthread_cond_broadcast(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let r = libc::pthread_cond_wait(self.inner.get(), mutex::raw(mutex));\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    // This implementation is used on systems that support pthread_condattr_setclock\n-    // where we configure condition variable to use monotonic clock (instead of\n-    // default system clock). This approach avoids all problems that result\n-    // from changes made to the system time.\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        use crate::mem;\n-\n-        let mut now: libc::timespec = mem::zeroed();\n-        let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n-        assert_eq!(r, 0);\n-\n-        // Nanosecond calculations can't overflow because both values are below 1e9.\n-        let nsec = dur.subsec_nanos() + now.tv_nsec as u32;\n-\n-        let sec = saturating_cast_to_time_t(dur.as_secs())\n-            .checked_add((nsec / 1_000_000_000) as libc::time_t)\n-            .and_then(|s| s.checked_add(now.tv_sec));\n-        let nsec = nsec % 1_000_000_000;\n-\n-        let timeout =\n-            sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n-\n-        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n-        assert!(r == libc::ETIMEDOUT || r == 0);\n-        r == 0\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        let r = libc::pthread_cond_destroy(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-}"}, {"sha": "76b34a6b5d84aa64a0a9a429e56218fc59931752", "filename": "library/std/src/sys/vxworks/ext/ffi.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fffi.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,38 +0,0 @@\n-//! Unix-specific extension to the primitives in the `std::ffi` module\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! use std::ffi::OsString;\n-//! use std::os::unix::ffi::OsStringExt;\n-//!\n-//! let bytes = b\"foo\".to_vec();\n-//!\n-//! // OsStringExt::from_vec\n-//! let os_string = OsString::from_vec(bytes);\n-//! assert_eq!(os_string.to_str(), Some(\"foo\"));\n-//!\n-//! // OsStringExt::into_vec\n-//! let bytes = os_string.into_vec();\n-//! assert_eq!(bytes, b\"foo\");\n-//! ```\n-//!\n-//! ```\n-//! use std::ffi::OsStr;\n-//! use std::os::unix::ffi::OsStrExt;\n-//!\n-//! let bytes = b\"foo\";\n-//!\n-//! // OsStrExt::from_bytes\n-//! let os_str = OsStr::from_bytes(bytes);\n-//! assert_eq!(os_str.to_str(), Some(\"foo\"));\n-//!\n-//! // OsStrExt::as_bytes\n-//! let bytes = os_str.as_bytes();\n-//! assert_eq!(bytes, b\"foo\");\n-//! ```\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use crate::sys_common::os_str_bytes::*;"}, {"sha": "68dc21b806c0fd70cb0be6555939bf9dc8b3a3bb", "filename": "library/std/src/sys/vxworks/ext/fs.rs", "status": "removed", "additions": 0, "deletions": 817, "changes": 817, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Ffs.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,817 +0,0 @@\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::fs::{self, Permissions};\n-use crate::io;\n-use crate::path::Path;\n-use crate::sys;\n-use crate::sys::platform::fs::MetadataExt as UnixMetadataExt;\n-use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n-\n-/// Unix-specific extensions to [`fs::File`].\n-#[stable(feature = \"file_offset\", since = \"1.15.0\")]\n-pub trait FileExt {\n-    /// Reads a number of bytes starting from a given offset.\n-    ///\n-    /// Returns the number of bytes read.\n-    ///\n-    /// The offset is relative to the start of the file and thus independent\n-    /// from the current cursor.\n-    ///\n-    /// The current file cursor is not affected by this function.\n-    ///\n-    /// Note that similar to [`File::read`], it is not an error to return with a\n-    /// short read.\n-    ///\n-    /// [`File::read`]: fs::File::read\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::fs::File;\n-    /// use std::os::unix::prelude::FileExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut buf = [0u8; 8];\n-    ///     let file = File::open(\"foo.txt\")?;\n-    ///\n-    ///     // We now read 8 bytes from the offset 10.\n-    ///     let num_bytes_read = file.read_at(&mut buf, 10)?;\n-    ///     println!(\"read {} bytes: {:?}\", num_bytes_read, buf);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n-    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize>;\n-\n-    /// Reads the exact number of byte required to fill `buf` from the given offset.\n-    ///\n-    /// The offset is relative to the start of the file and thus independent\n-    /// from the current cursor.\n-    ///\n-    /// The current file cursor is not affected by this function.\n-    ///\n-    /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n-    ///\n-    /// [`Read::read_exact`]: io::Read::read_exact\n-    /// [`read_at`]: FileExt::read_at\n-    ///\n-    /// # Errors\n-    ///\n-    /// If this function encounters an error of the kind\n-    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n-    /// will continue.\n-    ///\n-    /// If this function encounters an \"end of file\" before completely filling\n-    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n-    /// The contents of `buf` are unspecified in this case.\n-    ///\n-    /// If any other read error is encountered then this function immediately\n-    /// returns. The contents of `buf` are unspecified in this case.\n-    ///\n-    /// If this function returns an error, it is unspecified how many bytes it\n-    /// has read, but it will never read more than would be necessary to\n-    /// completely fill the buffer.\n-    ///\n-    /// [`ErrorKind::Interrupted`]: io::ErrorKind::Interrupted\n-    /// [`ErrorKind::UnexpectedEof`]: io::ErrorKind::UnexpectedEof\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(rw_exact_all_at)]\n-    /// use std::io;\n-    /// use std::fs::File;\n-    /// use std::os::unix::prelude::FileExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut buf = [0u8; 8];\n-    ///     let file = File::open(\"foo.txt\")?;\n-    ///\n-    ///     // We now read exactly 8 bytes from the offset 10.\n-    ///     file.read_exact_at(&mut buf, 10)?;\n-    ///     println!(\"read {} bytes: {:?}\", buf.len(), buf);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n-    fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n-        while !buf.is_empty() {\n-            match self.read_at(buf, offset) {\n-                Ok(0) => break,\n-                Ok(n) => {\n-                    let tmp = buf;\n-                    buf = &mut tmp[n..];\n-                    offset += n as u64;\n-                }\n-                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        if !buf.is_empty() {\n-            Err(io::Error::new(io::ErrorKind::UnexpectedEof, \"failed to fill whole buffer\"))\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    /// Writes a number of bytes starting from a given offset.\n-    ///\n-    /// Returns the number of bytes written.\n-    ///\n-    /// The offset is relative to the start of the file and thus independent\n-    /// from the current cursor.\n-    ///\n-    /// The current file cursor is not affected by this function.\n-    ///\n-    /// When writing beyond the end of the file, the file is appropriately\n-    /// extended and the intermediate bytes are initialized with the value 0.\n-    ///\n-    /// Note that similar to [`File::write`], it is not an error to return a\n-    /// short write.\n-    ///\n-    /// [`File::write`]: fs::File::write\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::io;\n-    /// use std::os::unix::prelude::FileExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let file = File::open(\"foo.txt\")?;\n-    ///\n-    ///     // We now write at the offset 10.\n-    ///     file.write_at(b\"sushi\", 10)?;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_offset\", since = \"1.15.0\")]\n-    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize>;\n-\n-    /// Attempts to write an entire buffer starting from a given offset.\n-    ///\n-    /// The offset is relative to the start of the file and thus independent\n-    /// from the current cursor.\n-    ///\n-    /// The current file cursor is not affected by this function.\n-    ///\n-    /// This method will continuously call [`write_at`] until there is no more data\n-    /// to be written or an error of non-[`ErrorKind::Interrupted`] kind is\n-    /// returned. This method will not return until the entire buffer has been\n-    /// successfully written or such an error occurs. The first error that is\n-    /// not of [`ErrorKind::Interrupted`] kind generated from this method will be\n-    /// returned.\n-    ///\n-    /// # Errors\n-    ///\n-    /// This function will return the first error of\n-    /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n-    ///\n-    /// [`ErrorKind::Interrupted`]: io::ErrorKind::Interrupted\n-    /// [`write_at`]: FileExt::write_at\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(rw_exact_all_at)]\n-    /// use std::fs::File;\n-    /// use std::io;\n-    /// use std::os::unix::prelude::FileExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let file = File::open(\"foo.txt\")?;\n-    ///\n-    ///     // We now write at the offset 10.\n-    ///     file.write_all_at(b\"sushi\", 10)?;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n-    fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n-        while !buf.is_empty() {\n-            match self.write_at(buf, offset) {\n-                Ok(0) => {\n-                    return Err(io::Error::new(\n-                        io::ErrorKind::WriteZero,\n-                        \"failed to write whole buffer\",\n-                    ));\n-                }\n-                Ok(n) => {\n-                    buf = &buf[n..];\n-                    offset += n as u64\n-                }\n-                Err(ref e) if e.kind() == io::ErrorKind::Interrupted => {}\n-                Err(e) => return Err(e),\n-            }\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"file_offset\", since = \"1.15.0\")]\n-impl FileExt for fs::File {\n-    fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        self.as_inner().read_at(buf, offset)\n-    }\n-    fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        self.as_inner().write_at(buf, offset)\n-    }\n-}\n-\n-/// Unix-specific extensions to [`fs::Permissions`].\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-pub trait PermissionsExt {\n-    /// Returns the underlying raw `st_mode` bits that contain the standard\n-    /// Unix permissions for this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::os::unix::fs::PermissionsExt;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::create(\"foo.txt\")?;\n-    ///     let metadata = f.metadata()?;\n-    ///     let permissions = metadata.permissions();\n-    ///\n-    ///     println!(\"permissions: {}\", permissions.mode());\n-    ///     Ok(()) }\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn mode(&self) -> u32;\n-\n-    /// Sets the underlying raw bits for this set of permissions.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::File;\n-    /// use std::os::unix::fs::PermissionsExt;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f = File::create(\"foo.txt\")?;\n-    ///     let metadata = f.metadata()?;\n-    ///     let mut permissions = metadata.permissions();\n-    ///\n-    ///     permissions.set_mode(0o644); // Read/write for owner and read for others.\n-    ///     assert_eq!(permissions.mode(), 0o644);\n-    ///     Ok(()) }\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn set_mode(&mut self, mode: u32);\n-\n-    /// Creates a new instance of `Permissions` from the given set of Unix\n-    /// permission bits.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::fs::Permissions;\n-    /// use std::os::unix::fs::PermissionsExt;\n-    ///\n-    /// // Read/write for owner and read for others.\n-    /// let permissions = Permissions::from_mode(0o644);\n-    /// assert_eq!(permissions.mode(), 0o644);\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn from_mode(mode: u32) -> Self;\n-}\n-\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-impl PermissionsExt for Permissions {\n-    fn mode(&self) -> u32 {\n-        self.as_inner().mode()\n-    }\n-\n-    fn set_mode(&mut self, mode: u32) {\n-        *self = Permissions::from_inner(FromInner::from_inner(mode));\n-    }\n-\n-    fn from_mode(mode: u32) -> Permissions {\n-        Permissions::from_inner(FromInner::from_inner(mode))\n-    }\n-}\n-\n-/// Unix-specific extensions to [`fs::OpenOptions`].\n-#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-pub trait OpenOptionsExt {\n-    /// Sets the mode bits that a new file will be created with.\n-    ///\n-    /// If a new file is created as part of an `OpenOptions::open` call then this\n-    /// specified `mode` will be used as the permission bits for the new file.\n-    /// If no `mode` is set, the default of `0o666` will be used.\n-    /// The operating system masks out bits with the system's `umask`, to produce\n-    /// the final permissions.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::OpenOptions;\n-    /// use std::os::unix::fs::OpenOptionsExt;\n-    ///\n-    /// # fn main() {\n-    /// let mut options = OpenOptions::new();\n-    /// options.mode(0o644); // Give read/write for owner and read for others.\n-    /// let file = options.open(\"foo.txt\");\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-    fn mode(&mut self, mode: u32) -> &mut Self;\n-\n-    /// Pass custom flags to the `flags` argument of `open`.\n-    ///\n-    /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n-    /// ensure they do not interfere with the access mode set by Rusts options.\n-    ///\n-    /// Custom flags can only set flags, not remove flags set by Rusts options.\n-    /// This options overwrites any previously set custom flags.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// # #![feature(libc)]\n-    /// extern crate libc;\n-    /// use std::fs::OpenOptions;\n-    /// use std::os::unix::fs::OpenOptionsExt;\n-    ///\n-    /// # fn main() {\n-    /// let mut options = OpenOptions::new();\n-    /// options.write(true);\n-    /// if cfg!(unix) {\n-    ///     options.custom_flags(libc::O_NOFOLLOW);\n-    /// }\n-    /// let file = options.open(\"foo.txt\");\n-    /// # }\n-    /// ```\n-    #[stable(feature = \"open_options_ext\", since = \"1.10.0\")]\n-    fn custom_flags(&mut self, flags: i32) -> &mut Self;\n-}\n-\n-/*#[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n-impl OpenOptionsExt for OpenOptions {\n-    fn mode(&mut self, mode: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().mode(mode); self\n-    }\n-\n-    fn custom_flags(&mut self, flags: i32) -> &mut OpenOptions {\n-        self.as_inner_mut().custom_flags(flags); self\n-    }\n-}\n-*/\n-\n-/// Unix-specific extensions to [`fs::Metadata`].\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-pub trait MetadataExt {\n-    /// Returns the ID of the device containing the file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let dev_id = meta.dev();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn dev(&self) -> u64;\n-    /// Returns the inode number.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let inode = meta.ino();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn ino(&self) -> u64;\n-    /// Returns the rights applied to this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let mode = meta.mode();\n-    ///     let user_has_write_access      = mode & 0o200;\n-    ///     let user_has_read_write_access = mode & 0o600;\n-    ///     let group_has_read_access      = mode & 0o040;\n-    ///     let others_have_exec_access    = mode & 0o001;\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn mode(&self) -> u32;\n-    /// Returns the number of hard links pointing to this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let nb_hard_links = meta.nlink();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn nlink(&self) -> u64;\n-    /// Returns the user ID of the owner of this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let user_id = meta.uid();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn uid(&self) -> u32;\n-    /// Returns the group ID of the owner of this file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let group_id = meta.gid();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn gid(&self) -> u32;\n-    /// Returns the device ID of this file (if it is a special one).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let device_id = meta.rdev();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn rdev(&self) -> u64;\n-    /// Returns the total size of this file in bytes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let file_size = meta.size();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn size(&self) -> u64;\n-    /// Returns the time of the last access to the file.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let last_access_time = meta.atime();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn atime(&self) -> i64;\n-    /// Returns the time of the last access to the file in nanoseconds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let nano_last_access_time = meta.atime_nsec();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn mtime(&self) -> i64;\n-    /// Returns the time of the last modification of the file in nanoseconds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let nano_last_modification_time = meta.mtime_nsec();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn ctime(&self) -> i64;\n-    /// Returns the time of the last status change of the file in nanoseconds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let nano_last_status_change_time = meta.ctime_nsec();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn blksize(&self) -> u64;\n-    /// Returns the number of blocks allocated to the file, in 512-byte units.\n-    ///\n-    /// Please note that this may be smaller than `st_size / 512` when the file has holes.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::MetadataExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"some_file\")?;\n-    ///     let blocks = meta.blocks();\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn blocks(&self) -> u64;\n-    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-    fn attrib(&self) -> u8;\n-}\n-\n-#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n-impl MetadataExt for fs::Metadata {\n-    fn dev(&self) -> u64 {\n-        self.st_dev()\n-    }\n-    fn ino(&self) -> u64 {\n-        self.st_ino()\n-    }\n-    fn mode(&self) -> u32 {\n-        self.st_mode()\n-    }\n-    fn nlink(&self) -> u64 {\n-        self.st_nlink()\n-    }\n-    fn uid(&self) -> u32 {\n-        self.st_uid()\n-    }\n-    fn gid(&self) -> u32 {\n-        self.st_gid()\n-    }\n-    fn rdev(&self) -> u64 {\n-        self.st_rdev()\n-    }\n-    fn size(&self) -> u64 {\n-        self.st_size()\n-    }\n-    fn atime(&self) -> i64 {\n-        self.st_atime()\n-    }\n-    fn mtime(&self) -> i64 {\n-        self.st_mtime()\n-    }\n-    fn ctime(&self) -> i64 {\n-        self.st_ctime()\n-    }\n-    fn blksize(&self) -> u64 {\n-        self.st_blksize()\n-    }\n-    fn blocks(&self) -> u64 {\n-        self.st_blocks()\n-    }\n-    fn attrib(&self) -> u8 {\n-        self.st_attrib()\n-    }\n-}\n-\n-/// Unix-specific extensions for [`fs::FileType`].\n-///\n-/// Adds support for special Unix file types such as block/character devices,\n-/// pipes, and sockets.\n-#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-pub trait FileTypeExt {\n-    /// Returns whether this file type is a block device.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::FileTypeExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"block_device_file\")?;\n-    ///     let file_type = meta.file_type();\n-    ///     assert!(file_type.is_block_device());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_block_device(&self) -> bool;\n-    /// Returns whether this file type is a char device.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::FileTypeExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"char_device_file\")?;\n-    ///     let file_type = meta.file_type();\n-    ///     assert!(file_type.is_char_device());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_char_device(&self) -> bool;\n-    /// Returns whether this file type is a fifo.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::FileTypeExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"fifo_file\")?;\n-    ///     let file_type = meta.file_type();\n-    ///     assert!(file_type.is_fifo());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_fifo(&self) -> bool;\n-    /// Returns whether this file type is a socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs;\n-    /// use std::os::unix::fs::FileTypeExt;\n-    /// use std::io;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let meta = fs::metadata(\"unix.socket\")?;\n-    ///     let file_type = meta.file_type();\n-    ///     assert!(file_type.is_socket());\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-    fn is_socket(&self) -> bool;\n-}\n-\n-#[stable(feature = \"file_type_ext\", since = \"1.5.0\")]\n-impl FileTypeExt for fs::FileType {\n-    fn is_block_device(&self) -> bool {\n-        self.as_inner().is(libc::S_IFBLK)\n-    }\n-    fn is_char_device(&self) -> bool {\n-        self.as_inner().is(libc::S_IFCHR)\n-    }\n-    fn is_fifo(&self) -> bool {\n-        self.as_inner().is(libc::S_IFIFO)\n-    }\n-    fn is_socket(&self) -> bool {\n-        self.as_inner().is(libc::S_IFSOCK)\n-    }\n-}\n-\n-/// Unix-specific extension methods for [`fs::DirEntry`].\n-#[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n-pub trait DirEntryExt {\n-    /// Returns the underlying `d_ino` field in the contained `dirent`\n-    /// structure.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::fs;\n-    /// use std::os::unix::fs::DirEntryExt;\n-    ///\n-    /// if let Ok(entries) = fs::read_dir(\".\") {\n-    ///     for entry in entries {\n-    ///         if let Ok(entry) = entry {\n-    ///             // Here, `entry` is a `DirEntry`.\n-    ///             println!(\"{:?}: {}\", entry.file_name(), entry.ino());\n-    ///         }\n-    ///     }\n-    /// }\n-    /// ```\n-    #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n-    fn ino(&self) -> u64;\n-}\n-\n-#[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n-impl DirEntryExt for fs::DirEntry {\n-    fn ino(&self) -> u64 {\n-        self.as_inner().ino()\n-    }\n-}\n-\n-/// Creates a new symbolic link on the filesystem.\n-///\n-/// The `dst` path will be a symbolic link pointing to the `src` path.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::fs;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     fs::symlink(\"a.txt\", \"b.txt\")?;\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"symlink\", since = \"1.1.0\")]\n-pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()> {\n-    sys::fs::symlink(src.as_ref(), dst.as_ref())\n-}\n-\n-/// Unix-specific extensions to [`fs::DirBuilder`].\n-#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-pub trait DirBuilderExt {\n-    /// Sets the mode to create new directories with. This option defaults to\n-    /// 0o777.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::fs::DirBuilder;\n-    /// use std::os::unix::fs::DirBuilderExt;\n-    ///\n-    /// let mut builder = DirBuilder::new();\n-    /// builder.mode(0o755);\n-    /// ```\n-    #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-    fn mode(&mut self, mode: u32) -> &mut Self;\n-}\n-\n-#[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n-impl DirBuilderExt for fs::DirBuilder {\n-    fn mode(&mut self, mode: u32) -> &mut fs::DirBuilder {\n-        self.as_inner_mut().set_mode(mode);\n-        self\n-    }\n-}"}, {"sha": "8b5a2d12af74f74a29b880766aea4ca21d1f7e74", "filename": "library/std/src/sys/vxworks/ext/io.rs", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fio.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,208 +0,0 @@\n-//! Unix-specific extensions to general I/O primitives\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::fs;\n-use crate::io;\n-use crate::net;\n-use crate::os::raw;\n-use crate::sys;\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n-\n-/// Raw file descriptors.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub type RawFd = raw::c_int;\n-\n-/// A trait to extract the raw unix file descriptor from an underlying\n-/// object.\n-///\n-/// This is only available on unix platforms and must be imported in order\n-/// to call the method. Windows platforms have a corresponding `AsRawHandle`\n-/// and `AsRawSocket` set of traits.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait AsRawFd {\n-    /// Extracts the raw file descriptor.\n-    ///\n-    /// This method does **not** pass ownership of the raw file descriptor\n-    /// to the caller. The descriptor is only guaranteed to be valid while\n-    /// the original object has not yet been destroyed.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn as_raw_fd(&self) -> RawFd;\n-}\n-\n-/// A trait to express the ability to construct an object from a raw file\n-/// descriptor.\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-pub trait FromRawFd {\n-    /// Constructs a new instance of `Self` from the given raw file\n-    /// descriptor.\n-    ///\n-    /// This function **consumes ownership** of the specified file\n-    /// descriptor. The returned object will take responsibility for closing\n-    /// it when the object goes out of scope.\n-    ///\n-    /// This function is also unsafe as the primitives currently returned\n-    /// have the contract that they are the sole owner of the file\n-    /// descriptor they are wrapping. Usage of this function could\n-    /// accidentally allow violating this contract which can cause memory\n-    /// unsafety in code that relies on it being true.\n-    #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n-}\n-\n-/// A trait to express the ability to consume an object and acquire ownership of\n-/// its raw file descriptor.\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-pub trait IntoRawFd {\n-    /// Consumes this object, returning the raw underlying file descriptor.\n-    ///\n-    /// This function **transfers ownership** of the underlying file descriptor\n-    /// to the caller. Callers are then the unique owners of the file descriptor\n-    /// and must close the descriptor once it's no longer needed.\n-    #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-    fn into_raw_fd(self) -> RawFd;\n-}\n-\n-#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n-impl AsRawFd for RawFd {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self\n-    }\n-}\n-#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n-impl IntoRawFd for RawFd {\n-    fn into_raw_fd(self) -> RawFd {\n-        self\n-    }\n-}\n-#[stable(feature = \"raw_fd_reflexive_traits\", since = \"1.48.0\")]\n-impl FromRawFd for RawFd {\n-    unsafe fn from_raw_fd(fd: RawFd) -> RawFd {\n-        fd\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for fs::File {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for fs::File {\n-    unsafe fn from_raw_fd(fd: RawFd) -> fs::File {\n-        fs::File::from_inner(sys::fs::File::from_inner(fd))\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for fs::File {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n-impl AsRawFd for io::Stdin {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDIN_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n-impl AsRawFd for io::Stdout {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDOUT_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n-impl AsRawFd for io::Stderr {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDERR_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n-impl<'a> AsRawFd for io::StdinLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDIN_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n-impl<'a> AsRawFd for io::StdoutLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDOUT_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"asraw_stdio_locks\", since = \"1.35.0\")]\n-impl<'a> AsRawFd for io::StderrLock<'a> {\n-    fn as_raw_fd(&self) -> RawFd {\n-        libc::STDERR_FILENO\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::UdpSocket {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::UdpSocket {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}"}, {"sha": "8fa9bd9d1e27f0da8911671268c44e6d08cd2099", "filename": "library/std/src/sys/vxworks/ext/mod.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fmod.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,24 +0,0 @@\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-#![allow(missing_docs)]\n-\n-pub mod ffi;\n-pub mod fs;\n-pub mod io;\n-pub mod process;\n-pub mod raw;\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub mod prelude {\n-    #[doc(no_inline)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::ffi::{OsStrExt, OsStringExt};\n-    #[doc(no_inline)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::fs::{FileTypeExt, MetadataExt, OpenOptionsExt, PermissionsExt};\n-    #[doc(no_inline)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n-    #[doc(no_inline)]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub use super::process::ExitStatusExt;\n-}"}, {"sha": "3ffa5be1b3bf1c64eafd74e09694cb4723822ae5", "filename": "library/std/src/sys/vxworks/ext/process.rs", "status": "removed", "additions": 0, "deletions": 229, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fprocess.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,229 +0,0 @@\n-//! Unix-specific extensions to primitives in the `std::process` module.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::ffi::OsStr;\n-use crate::io;\n-use crate::process;\n-use crate::sys;\n-use crate::sys::vxworks::ext::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n-use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n-\n-/// Unix-specific extensions to the [`process::Command`] builder.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait CommandExt {\n-    /// Sets the child process's user ID. This translates to a\n-    /// `setuid` call in the child process. Failure in the `setuid`\n-    /// call will cause the spawn to fail.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn uid(&mut self, id: u16) -> &mut process::Command;\n-\n-    /// Similar to `uid`, but sets the group ID of the child process. This has\n-    /// the same semantics as the `uid` field.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn gid(&mut self, id: u16) -> &mut process::Command;\n-\n-    /// Schedules a closure to be run just before the `exec` function is\n-    /// invoked.\n-    ///\n-    /// The closure is allowed to return an I/O error whose OS error code will\n-    /// be communicated back to the parent and returned as an error from when\n-    /// the spawn was requested.\n-    ///\n-    /// Multiple closures can be registered and they will be called in order of\n-    /// their registration. If a closure returns `Err` then no further closures\n-    /// will be called and the spawn operation will immediately return with a\n-    /// failure.\n-    ///\n-    /// # Notes and Safety\n-    ///\n-    /// This closure will be run in the context of the child process after a\n-    /// `fork`. This primarily means that any modifications made to memory on\n-    /// behalf of this closure will **not** be visible to the parent process.\n-    /// This is often a very constrained environment where normal operations\n-    /// like `malloc` or acquiring a mutex are not guaranteed to work (due to\n-    /// other threads perhaps still running when the `fork` was run).\n-    ///\n-    /// This also means that all resources such as file descriptors and\n-    /// memory-mapped regions got duplicated. It is your responsibility to make\n-    /// sure that the closure does not violate library invariants by making\n-    /// invalid use of these duplicates.\n-    ///\n-    /// When this closure is run, aspects such as the stdio file descriptors and\n-    /// working directory have successfully been changed, so output to these\n-    /// locations may not appear where intended.\n-    #[stable(feature = \"process_pre_exec\", since = \"1.34.0\")]\n-    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-    where\n-        F: FnMut() -> io::Result<()> + Send + Sync + 'static;\n-\n-    /// Schedules a closure to be run just before the `exec` function is\n-    /// invoked.\n-    ///\n-    /// This method is stable and usable, but it should be unsafe. To fix\n-    /// that, it got deprecated in favor of the unsafe [`pre_exec`].\n-    ///\n-    /// [`pre_exec`]: CommandExt::pre_exec\n-    #[stable(feature = \"process_exec\", since = \"1.15.0\")]\n-    #[rustc_deprecated(since = \"1.37.0\", reason = \"should be unsafe, use `pre_exec` instead\")]\n-    fn before_exec<F>(&mut self, f: F) -> &mut process::Command\n-    where\n-        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n-    {\n-        unsafe { self.pre_exec(f) }\n-    }\n-\n-    /// Performs all the required setup by this `Command`, followed by calling\n-    /// the `execvp` syscall.\n-    ///\n-    /// On success this function will not return, and otherwise it will return\n-    /// an error indicating why the exec (or another part of the setup of the\n-    /// `Command`) failed.\n-    ///\n-    /// `exec` not returning has the same implications as calling\n-    /// [`process::exit`] \u2013 no destructors on the current stack or any other\n-    /// thread\u2019s stack will be run. Therefore, it is recommended to only call\n-    /// `exec` at a point where it is fine to not run any destructors. Note,\n-    /// that the `execvp` syscall independently guarantees that all memory is\n-    /// freed and all file descriptors with the `CLOEXEC` option (set by default\n-    /// on all file descriptors opened by the standard library) are closed.\n-    ///\n-    /// This function, unlike `spawn`, will **not** `fork` the process to create\n-    /// a new child. Like spawn, however, the default behavior for the stdio\n-    /// descriptors will be to inherited from the current process.\n-    ///\n-    ///\n-    /// # Notes\n-    ///\n-    /// The process may be in a \"broken state\" if this function returns in\n-    /// error. For example the working directory, environment variables, signal\n-    /// handling settings, various user/group information, or aspects of stdio\n-    /// file descriptors may have changed. If a \"transactional spawn\" is\n-    /// required to gracefully handle errors it is recommended to use the\n-    /// cross-platform `spawn` instead.\n-    #[stable(feature = \"process_exec2\", since = \"1.9.0\")]\n-    fn exec(&mut self) -> io::Error;\n-\n-    /// Set executable argument\n-    ///\n-    /// Set the first process argument, `argv[0]`, to something other than the\n-    /// default executable path.\n-    #[stable(feature = \"process_set_argv0\", since = \"1.45.0\")]\n-    fn arg0<S>(&mut self, arg: S) -> &mut process::Command\n-    where\n-        S: AsRef<OsStr>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl CommandExt for process::Command {\n-    fn uid(&mut self, id: u16) -> &mut process::Command {\n-        self.as_inner_mut().uid(id);\n-        self\n-    }\n-\n-    fn gid(&mut self, id: u16) -> &mut process::Command {\n-        self.as_inner_mut().gid(id);\n-        self\n-    }\n-\n-    unsafe fn pre_exec<F>(&mut self, f: F) -> &mut process::Command\n-    where\n-        F: FnMut() -> io::Result<()> + Send + Sync + 'static,\n-    {\n-        self.as_inner_mut().pre_exec(Box::new(f));\n-        self\n-    }\n-\n-    fn exec(&mut self) -> io::Error {\n-        self.as_inner_mut().exec(sys::process::Stdio::Inherit)\n-    }\n-\n-    fn arg0<S>(&mut self, arg: S) -> &mut process::Command\n-    where\n-        S: AsRef<OsStr>,\n-    {\n-        self.as_inner_mut().set_arg_0(arg.as_ref());\n-        self\n-    }\n-}\n-\n-/// Unix-specific extensions to [`process::ExitStatus`].\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait ExitStatusExt {\n-    /// Creates a new `ExitStatus` from the raw underlying `i32` return value of\n-    /// a process.\n-    #[stable(feature = \"exit_status_from\", since = \"1.12.0\")]\n-    fn from_raw(raw: i32) -> Self;\n-\n-    /// If the process was terminated by a signal, returns that signal.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn signal(&self) -> Option<i32>;\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ExitStatusExt for process::ExitStatus {\n-    fn from_raw(raw: i32) -> Self {\n-        process::ExitStatus::from_inner(From::from(raw))\n-    }\n-\n-    fn signal(&self) -> Option<i32> {\n-        self.as_inner().signal()\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl FromRawFd for process::Stdio {\n-    unsafe fn from_raw_fd(fd: RawFd) -> process::Stdio {\n-        let fd = sys::fd::FileDesc::new(fd);\n-        let io = sys::process::Stdio::Fd(fd);\n-        process::Stdio::from_inner(io)\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl AsRawFd for process::ChildStdin {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl AsRawFd for process::ChildStdout {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"process_extensions\", since = \"1.2.0\")]\n-impl AsRawFd for process::ChildStderr {\n-    fn as_raw_fd(&self) -> RawFd {\n-        self.as_inner().fd().raw()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for process::ChildStdin {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for process::ChildStdout {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for process::ChildStderr {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_fd().into_raw()\n-    }\n-}\n-\n-/// Returns the OS-assigned process identifier associated with this process's parent.\n-#[stable(feature = \"unix_ppid\", since = \"1.27.0\")]\n-pub fn parent_id() -> u32 {\n-    crate::sys::os::getppid()\n-}"}, {"sha": "1f134f4e2d1bddd7bc427099fbf562b158a0717a", "filename": "library/std/src/sys/vxworks/ext/raw.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fraw.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,5 +0,0 @@\n-#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n-\n-#[doc(inline)]\n-#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n-pub use crate::sys::platform::raw::pthread_t;"}, {"sha": "d58468ad539ff92ca0a9d4d96fd260c01d7329b2", "filename": "library/std/src/sys/vxworks/fd.rs", "status": "removed", "additions": 0, "deletions": 201, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffd.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,201 +0,0 @@\n-#![unstable(reason = \"not public\", issue = \"none\", feature = \"fd\")]\n-\n-use crate::cmp;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut, Read};\n-use crate::mem;\n-use crate::sys::cvt;\n-use crate::sys_common::AsInner;\n-\n-use libc::{self, c_int, c_void, ssize_t};\n-\n-#[derive(Debug)]\n-pub struct FileDesc {\n-    fd: c_int,\n-}\n-\n-// The maximum read limit on most POSIX-like systems is `SSIZE_MAX`,\n-// with the man page quoting that if the count of bytes to read is\n-// greater than `SSIZE_MAX` the result is \"unspecified\".\n-const READ_LIMIT: usize = ssize_t::MAX as usize;\n-\n-impl FileDesc {\n-    pub fn new(fd: c_int) -> FileDesc {\n-        FileDesc { fd: fd }\n-    }\n-\n-    pub fn raw(&self) -> c_int {\n-        self.fd\n-    }\n-\n-    /// Extracts the actual file descriptor without closing it.\n-    pub fn into_raw(self) -> c_int {\n-        let fd = self.fd;\n-        mem::forget(self);\n-        fd\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::read(self.fd, buf.as_mut_ptr() as *mut c_void, cmp::min(buf.len(), READ_LIMIT))\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::readv(\n-                self.fd,\n-                bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n-            )\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        true\n-    }\n-\n-    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let mut me = self;\n-        (&mut me).read_to_end(buf)\n-    }\n-\n-    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        unsafe fn cvt_pread(\n-            fd: c_int,\n-            buf: *mut c_void,\n-            count: usize,\n-            offset: i64,\n-        ) -> io::Result<isize> {\n-            use libc::pread;\n-            cvt(pread(fd, buf, count, offset))\n-        }\n-\n-        unsafe {\n-            cvt_pread(\n-                self.fd,\n-                buf.as_mut_ptr() as *mut c_void,\n-                cmp::min(buf.len(), READ_LIMIT),\n-                offset as i64,\n-            )\n-            .map(|n| n as usize)\n-        }\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::write(self.fd, buf.as_ptr() as *const c_void, cmp::min(buf.len(), READ_LIMIT))\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::writev(\n-                self.fd,\n-                bufs.as_ptr() as *const libc::iovec,\n-                cmp::min(bufs.len(), c_int::MAX as usize) as c_int,\n-            )\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        true\n-    }\n-\n-    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        unsafe fn cvt_pwrite(\n-            fd: c_int,\n-            buf: *const c_void,\n-            count: usize,\n-            offset: i64,\n-        ) -> io::Result<isize> {\n-            use libc::pwrite;\n-            cvt(pwrite(fd, buf, count, offset))\n-        }\n-\n-        unsafe {\n-            cvt_pwrite(\n-                self.fd,\n-                buf.as_ptr() as *const c_void,\n-                cmp::min(buf.len(), READ_LIMIT),\n-                offset as i64,\n-            )\n-            .map(|n| n as usize)\n-        }\n-    }\n-\n-    pub fn get_cloexec(&self) -> io::Result<bool> {\n-        unsafe { Ok((cvt(libc::fcntl(self.fd, libc::F_GETFD))? & libc::FD_CLOEXEC) != 0) }\n-    }\n-\n-    pub fn set_cloexec(&self) -> io::Result<()> {\n-        unsafe {\n-            let previous = cvt(libc::fcntl(self.fd, libc::F_GETFD))?;\n-            let new = previous | libc::FD_CLOEXEC;\n-            if new != previous {\n-                cvt(libc::fcntl(self.fd, libc::F_SETFD, new))?;\n-            }\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        unsafe {\n-            let v = nonblocking as c_int;\n-            cvt(libc::ioctl(self.fd, libc::FIONBIO, &v))?;\n-            Ok(())\n-        }\n-    }\n-\n-    // refer to pxPipeDrv library documentation.\n-    // VxWorks uses fcntl to set O_NONBLOCK to the pipes\n-    pub fn set_nonblocking_pipe(&self, nonblocking: bool) -> io::Result<()> {\n-        unsafe {\n-            let mut flags = cvt(libc::fcntl(self.fd, libc::F_GETFL, 0))?;\n-            flags = if nonblocking { flags | libc::O_NONBLOCK } else { flags & !libc::O_NONBLOCK };\n-            cvt(libc::fcntl(self.fd, libc::F_SETFL, flags))?;\n-            Ok(())\n-        }\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<FileDesc> {\n-        let fd = self.raw();\n-        match cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD_CLOEXEC, 0) }) {\n-            Ok(newfd) => Ok(FileDesc::new(newfd)),\n-            Err(e) => return Err(e),\n-        }\n-    }\n-}\n-\n-impl<'a> Read for &'a FileDesc {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        (**self).read(buf)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-impl AsInner<c_int> for FileDesc {\n-    fn as_inner(&self) -> &c_int {\n-        &self.fd\n-    }\n-}\n-\n-impl Drop for FileDesc {\n-    fn drop(&mut self) {\n-        // Note that errors are ignored when closing a file descriptor. The\n-        // reason for this is that if an error occurs we don't actually know if\n-        // the file descriptor was closed or not, and if we retried (for\n-        // something like EINTR), we might close another valid file descriptor\n-        // (opened after we closed ours.\n-        let _ = unsafe { libc::close(self.fd) };\n-    }\n-}"}, {"sha": "cb761af1a25c2d4ea123d3c2f73b35b4d1637927", "filename": "library/std/src/sys/vxworks/fs.rs", "status": "removed", "additions": 0, "deletions": 624, "changes": 624, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ffs.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,624 +0,0 @@\n-// copies from linuxx\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n-use crate::fmt;\n-use crate::io::{self, Error, ErrorKind, IoSlice, IoSliceMut, SeekFrom};\n-use crate::mem;\n-use crate::path::{Path, PathBuf};\n-use crate::ptr;\n-use crate::sync::Arc;\n-use crate::sys::fd::FileDesc;\n-use crate::sys::time::SystemTime;\n-use crate::sys::vxworks::ext::ffi::OsStrExt;\n-use crate::sys::vxworks::ext::ffi::OsStringExt;\n-use crate::sys::{cvt, cvt_r};\n-use crate::sys_common::{AsInner, FromInner};\n-use libc::{self, c_int, mode_t, off_t, stat64};\n-use libc::{dirent, ftruncate, lseek, open, readdir_r as readdir64_r};\n-pub struct File(FileDesc);\n-\n-#[derive(Clone)]\n-pub struct FileAttr {\n-    stat: stat64,\n-}\n-\n-// all DirEntry's will have a reference to this struct\n-struct InnerReadDir {\n-    dirp: Dir,\n-    root: PathBuf,\n-}\n-\n-pub struct ReadDir {\n-    inner: Arc<InnerReadDir>,\n-    end_of_stream: bool,\n-}\n-\n-struct Dir(*mut libc::DIR);\n-\n-unsafe impl Send for Dir {}\n-unsafe impl Sync for Dir {}\n-\n-pub struct DirEntry {\n-    entry: dirent,\n-    dir: Arc<InnerReadDir>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct OpenOptions {\n-    // generic\n-    read: bool,\n-    write: bool,\n-    append: bool,\n-    truncate: bool,\n-    create: bool,\n-    create_new: bool,\n-    // system-specific\n-    custom_flags: i32,\n-    mode: mode_t,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct FilePermissions {\n-    mode: mode_t,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n-pub struct FileType {\n-    mode: mode_t,\n-}\n-\n-#[derive(Debug)]\n-pub struct DirBuilder {\n-    mode: mode_t,\n-}\n-\n-impl FileAttr {\n-    pub fn size(&self) -> u64 {\n-        self.stat.st_size as u64\n-    }\n-    pub fn perm(&self) -> FilePermissions {\n-        FilePermissions { mode: (self.stat.st_mode as mode_t) }\n-    }\n-\n-    pub fn file_type(&self) -> FileType {\n-        FileType { mode: self.stat.st_mode as mode_t }\n-    }\n-\n-    pub fn modified(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_mtime as libc::time_t,\n-            tv_nsec: 0, // hack 2.0;\n-        }))\n-    }\n-\n-    pub fn accessed(&self) -> io::Result<SystemTime> {\n-        Ok(SystemTime::from(libc::timespec {\n-            tv_sec: self.stat.st_atime as libc::time_t,\n-            tv_nsec: 0, // hack - a proper fix would be better\n-        }))\n-    }\n-\n-    pub fn created(&self) -> io::Result<SystemTime> {\n-        Err(io::Error::new(\n-            io::ErrorKind::Other,\n-            \"creation time is not available on this platform currently\",\n-        ))\n-    }\n-}\n-\n-impl AsInner<stat64> for FileAttr {\n-    fn as_inner(&self) -> &stat64 {\n-        &self.stat\n-    }\n-}\n-\n-impl FilePermissions {\n-    pub fn readonly(&self) -> bool {\n-        // check if any class (owner, group, others) has write permission\n-        self.mode & 0o222 == 0\n-    }\n-\n-    pub fn set_readonly(&mut self, readonly: bool) {\n-        if readonly {\n-            // remove write permission for all classes; equivalent to `chmod a-w <file>`\n-            self.mode &= !0o222;\n-        } else {\n-            // add write permission for all classes; equivalent to `chmod a+w <file>`\n-            self.mode |= 0o222;\n-        }\n-    }\n-    pub fn mode(&self) -> u32 {\n-        self.mode as u32\n-    }\n-}\n-\n-impl FileType {\n-    pub fn is_dir(&self) -> bool {\n-        self.is(libc::S_IFDIR)\n-    }\n-    pub fn is_file(&self) -> bool {\n-        self.is(libc::S_IFREG)\n-    }\n-    pub fn is_symlink(&self) -> bool {\n-        self.is(libc::S_IFLNK)\n-    }\n-\n-    pub fn is(&self, mode: mode_t) -> bool {\n-        self.mode & libc::S_IFMT == mode\n-    }\n-}\n-\n-impl FromInner<u32> for FilePermissions {\n-    fn from_inner(mode: u32) -> FilePermissions {\n-        FilePermissions { mode: mode as mode_t }\n-    }\n-}\n-\n-impl fmt::Debug for ReadDir {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // This will only be called from std::fs::ReadDir, which will add a \"ReadDir()\" frame.\n-        // Thus the result will be e g 'ReadDir(\"/home\")'\n-        fmt::Debug::fmt(&*self.inner.root, f)\n-    }\n-}\n-\n-impl Iterator for ReadDir {\n-    type Item = io::Result<DirEntry>;\n-    fn next(&mut self) -> Option<io::Result<DirEntry>> {\n-        if self.end_of_stream {\n-            return None;\n-        }\n-\n-        unsafe {\n-            let mut ret = DirEntry { entry: mem::zeroed(), dir: Arc::clone(&self.inner) };\n-            let mut entry_ptr = ptr::null_mut();\n-            loop {\n-                if readdir64_r(self.inner.dirp.0, &mut ret.entry, &mut entry_ptr) != 0 {\n-                    if entry_ptr.is_null() {\n-                        // We encountered an error (which will be returned in this iteration), but\n-                        // we also reached the end of the directory stream. The `end_of_stream`\n-                        // flag is enabled to make sure that we return `None` in the next iteration\n-                        // (instead of looping forever)\n-                        self.end_of_stream = true;\n-                    }\n-                    return Some(Err(Error::last_os_error()));\n-                }\n-                if entry_ptr.is_null() {\n-                    return None;\n-                }\n-                if ret.name_bytes() != b\".\" && ret.name_bytes() != b\"..\" {\n-                    return Some(Ok(ret));\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for Dir {\n-    fn drop(&mut self) {\n-        let r = unsafe { libc::closedir(self.0) };\n-        debug_assert_eq!(r, 0);\n-    }\n-}\n-\n-impl DirEntry {\n-    pub fn path(&self) -> PathBuf {\n-        use crate::sys::vxworks::ext::ffi::OsStrExt;\n-        self.dir.root.join(OsStr::from_bytes(self.name_bytes()))\n-    }\n-\n-    pub fn file_name(&self) -> OsString {\n-        OsStr::from_bytes(self.name_bytes()).to_os_string()\n-    }\n-\n-    pub fn metadata(&self) -> io::Result<FileAttr> {\n-        lstat(&self.path())\n-    }\n-\n-    pub fn file_type(&self) -> io::Result<FileType> {\n-        lstat(&self.path()).map(|m| m.file_type())\n-    }\n-\n-    pub fn ino(&self) -> u64 {\n-        self.entry.d_ino as u64\n-    }\n-\n-    fn name_bytes(&self) -> &[u8] {\n-        unsafe {\n-            //&*self.name\n-            CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes()\n-        }\n-    }\n-}\n-\n-impl OpenOptions {\n-    pub fn new() -> OpenOptions {\n-        OpenOptions {\n-            // generic\n-            read: false,\n-            write: false,\n-            append: false,\n-            truncate: false,\n-            create: false,\n-            create_new: false,\n-            // system-specific\n-            custom_flags: 0,\n-            mode: 0o666,\n-        }\n-    }\n-\n-    pub fn read(&mut self, read: bool) {\n-        self.read = read;\n-    }\n-    pub fn write(&mut self, write: bool) {\n-        self.write = write;\n-    }\n-    pub fn append(&mut self, append: bool) {\n-        self.append = append;\n-    }\n-    pub fn truncate(&mut self, truncate: bool) {\n-        self.truncate = truncate;\n-    }\n-    pub fn create(&mut self, create: bool) {\n-        self.create = create;\n-    }\n-    pub fn create_new(&mut self, create_new: bool) {\n-        self.create_new = create_new;\n-    }\n-    pub fn mode(&mut self, mode: u32) {\n-        self.mode = mode as mode_t;\n-    }\n-\n-    fn get_access_mode(&self) -> io::Result<c_int> {\n-        match (self.read, self.write, self.append) {\n-            (true, false, false) => Ok(libc::O_RDONLY),\n-            (false, true, false) => Ok(libc::O_WRONLY),\n-            (true, true, false) => Ok(libc::O_RDWR),\n-            (false, _, true) => Ok(libc::O_WRONLY | libc::O_APPEND),\n-            (true, _, true) => Ok(libc::O_RDWR | libc::O_APPEND),\n-            (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n-        }\n-    }\n-\n-    fn get_creation_mode(&self) -> io::Result<c_int> {\n-        match (self.write, self.append) {\n-            (true, false) => {}\n-            (false, false) => {\n-                if self.truncate || self.create || self.create_new {\n-                    return Err(Error::from_raw_os_error(libc::EINVAL));\n-                }\n-            }\n-            (_, true) => {\n-                if self.truncate && !self.create_new {\n-                    return Err(Error::from_raw_os_error(libc::EINVAL));\n-                }\n-            }\n-        }\n-\n-        Ok(match (self.create, self.truncate, self.create_new) {\n-            (false, false, false) => 0,\n-            (true, false, false) => libc::O_CREAT,\n-            (false, true, false) => libc::O_TRUNC,\n-            (true, true, false) => libc::O_CREAT | libc::O_TRUNC,\n-            (_, _, true) => libc::O_CREAT | libc::O_EXCL,\n-        })\n-    }\n-}\n-\n-impl File {\n-    pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let path = cstr(path)?;\n-        File::open_c(&path, opts)\n-    }\n-\n-    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n-        let flags = libc::O_CLOEXEC\n-            | opts.get_access_mode()?\n-            | opts.get_creation_mode()?\n-            | (opts.custom_flags as c_int & !libc::O_ACCMODE);\n-        let fd = cvt_r(|| unsafe { open(path.as_ptr(), flags, opts.mode as c_int) })?;\n-        Ok(File(FileDesc::new(fd)))\n-    }\n-\n-    pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut stat: stat64 = unsafe { mem::zeroed() };\n-        cvt(unsafe { ::libc::fstat(self.0.raw(), &mut stat) })?;\n-        Ok(FileAttr { stat: stat })\n-    }\n-\n-    pub fn fsync(&self) -> io::Result<()> {\n-        cvt_r(|| unsafe { libc::fsync(self.0.raw()) })?;\n-        Ok(())\n-    }\n-\n-    pub fn datasync(&self) -> io::Result<()> {\n-        cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n-        return Ok(());\n-        unsafe fn os_datasync(fd: c_int) -> c_int {\n-            libc::fsync(fd)\n-        } //not supported\n-    }\n-\n-    pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        return cvt_r(|| unsafe { ftruncate(self.0.raw(), size as off_t) }).map(drop);\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        self.0.is_read_vectored()\n-    }\n-\n-    pub fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n-        self.0.read_at(buf, offset)\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        self.0.is_write_vectored()\n-    }\n-\n-    pub fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n-        self.0.write_at(buf, offset)\n-    }\n-\n-    pub fn flush(&self) -> io::Result<()> {\n-        Ok(())\n-    }\n-\n-    pub fn seek(&self, pos: SeekFrom) -> io::Result<u64> {\n-        let (whence, pos) = match pos {\n-            // Casting to `i64` is fine, too large values will end up as\n-            // negative which will cause an error in `\"lseek64\"`.\n-            SeekFrom::Start(off) => (libc::SEEK_SET, off as i64),\n-            SeekFrom::End(off) => (libc::SEEK_END, off),\n-            SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n-        };\n-        let n = cvt(unsafe { lseek(self.0.raw(), pos, whence) })?;\n-        Ok(n as u64)\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<File> {\n-        self.0.duplicate().map(File)\n-    }\n-\n-    pub fn fd(&self) -> &FileDesc {\n-        &self.0\n-    }\n-\n-    pub fn into_fd(self) -> FileDesc {\n-        self.0\n-    }\n-\n-    pub fn set_permissions(&self, perm: FilePermissions) -> io::Result<()> {\n-        cvt_r(|| unsafe { libc::fchmod(self.0.raw(), perm.mode) })?;\n-        Ok(())\n-    }\n-\n-    pub fn diverge(&self) -> ! {\n-        panic!()\n-    }\n-}\n-\n-impl DirBuilder {\n-    pub fn new() -> DirBuilder {\n-        DirBuilder { mode: 0o777 }\n-    }\n-\n-    pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let p = cstr(p)?;\n-        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;\n-        Ok(())\n-    }\n-\n-    pub fn set_mode(&mut self, mode: u32) {\n-        self.mode = mode as mode_t;\n-    }\n-}\n-\n-fn cstr(path: &Path) -> io::Result<CString> {\n-    use crate::sys::vxworks::ext::ffi::OsStrExt;\n-    Ok(CString::new(path.as_os_str().as_bytes())?)\n-}\n-\n-impl FromInner<c_int> for File {\n-    fn from_inner(fd: c_int) -> File {\n-        File(FileDesc::new(fd))\n-    }\n-}\n-\n-impl fmt::Debug for File {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fn get_path(fd: c_int) -> Option<PathBuf> {\n-            let mut buf = vec![0; libc::PATH_MAX as usize];\n-            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n-            if n == -1 {\n-                return None;\n-            }\n-            let l = buf.iter().position(|&c| c == 0).unwrap();\n-            buf.truncate(l as usize);\n-            Some(PathBuf::from(OsString::from_vec(buf)))\n-        }\n-        fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n-            let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n-            if mode == -1 {\n-                return None;\n-            }\n-            match mode & libc::O_ACCMODE {\n-                libc::O_RDONLY => Some((true, false)),\n-                libc::O_RDWR => Some((true, true)),\n-                libc::O_WRONLY => Some((false, true)),\n-                _ => None,\n-            }\n-        }\n-\n-        let fd = self.0.raw();\n-        let mut b = f.debug_struct(\"File\");\n-        b.field(\"fd\", &fd);\n-        if let Some(path) = get_path(fd) {\n-            b.field(\"path\", &path);\n-        }\n-        if let Some((read, write)) = get_mode(fd) {\n-            b.field(\"read\", &read).field(\"write\", &write);\n-        }\n-        b.finish()\n-    }\n-}\n-\n-pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n-    let root = p.to_path_buf();\n-    let p = cstr(p)?;\n-    unsafe {\n-        let ptr = libc::opendir(p.as_ptr());\n-        if ptr.is_null() {\n-            Err(Error::last_os_error())\n-        } else {\n-            let inner = InnerReadDir { dirp: Dir(ptr), root };\n-            Ok(ReadDir { inner: Arc::new(inner), end_of_stream: false })\n-        }\n-    }\n-}\n-\n-pub fn unlink(p: &Path) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt(unsafe { libc::unlink(p.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let old = cstr(old)?;\n-    let new = cstr(new)?;\n-    cvt(unsafe { libc::rename(old.as_ptr(), new.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt_r(|| unsafe { libc::chmod(p.as_ptr(), perm.mode) })?;\n-    Ok(())\n-}\n-\n-pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt(unsafe { libc::rmdir(p.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn remove_dir_all(path: &Path) -> io::Result<()> {\n-    let filetype = lstat(path)?.file_type();\n-    if filetype.is_symlink() { unlink(path) } else { remove_dir_all_recursive(path) }\n-}\n-\n-fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n-    for child in readdir(path)? {\n-        let child = child?;\n-        if child.file_type()?.is_dir() {\n-            remove_dir_all_recursive(&child.path())?;\n-        } else {\n-            unlink(&child.path())?;\n-        }\n-    }\n-    rmdir(path)\n-}\n-\n-pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n-    let c_path = cstr(p)?;\n-    let p = c_path.as_ptr();\n-\n-    let mut buf = Vec::with_capacity(256);\n-\n-    loop {\n-        let buf_read =\n-            cvt(unsafe { libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity()) })? as usize;\n-\n-        unsafe {\n-            buf.set_len(buf_read);\n-        }\n-\n-        if buf_read != buf.capacity() {\n-            buf.shrink_to_fit();\n-\n-            return Ok(PathBuf::from(OsString::from_vec(buf)));\n-        }\n-\n-        // Trigger the internal buffer resizing logic of `Vec` by requiring\n-        // more space than the current capacity. The length is guaranteed to be\n-        // the same as the capacity due to the if statement above.\n-        buf.reserve(1);\n-    }\n-}\n-\n-pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = cstr(src)?;\n-    let dst = cstr(dst)?;\n-    cvt(unsafe { libc::symlink(src.as_ptr(), dst.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n-    let src = cstr(src)?;\n-    let dst = cstr(dst)?;\n-    cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n-    Ok(())\n-}\n-\n-pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p)?;\n-    let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe { libc::stat(p.as_ptr(), &mut stat as *mut _ as *mut _) })?;\n-    Ok(FileAttr { stat })\n-}\n-\n-pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p)?;\n-    let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe { ::libc::lstat(p.as_ptr(), &mut stat as *mut _ as *mut _) })?;\n-    Ok(FileAttr { stat })\n-}\n-\n-pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n-    use crate::sys::vxworks::ext::ffi::OsStrExt;\n-    let path = CString::new(p.as_os_str().as_bytes())?;\n-    let buf;\n-    unsafe {\n-        let r = libc::realpath(path.as_ptr(), ptr::null_mut());\n-        if r.is_null() {\n-            return Err(io::Error::last_os_error());\n-        }\n-        buf = CStr::from_ptr(r).to_bytes().to_vec();\n-        libc::free(r as *mut _);\n-    }\n-    Ok(PathBuf::from(OsString::from_vec(buf)))\n-}\n-\n-pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n-    use crate::fs::File;\n-    if !from.is_file() {\n-        return Err(Error::new(\n-            ErrorKind::InvalidInput,\n-            \"the source path is not an existing regular file\",\n-        ));\n-    }\n-\n-    let mut reader = File::open(from)?;\n-    let mut writer = File::create(to)?;\n-    let perm = reader.metadata()?.permissions();\n-\n-    let ret = io::copy(&mut reader, &mut writer)?;\n-    writer.set_permissions(perm)?;\n-    Ok(ret)\n-}"}, {"sha": "0f68ebf8da9cc43577482eb6f62dad433e701007", "filename": "library/std/src/sys/vxworks/io.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fio.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,75 +0,0 @@\n-use crate::marker::PhantomData;\n-use crate::slice;\n-\n-use libc::{c_void, iovec};\n-\n-#[derive(Copy, Clone)]\n-#[repr(transparent)]\n-pub struct IoSlice<'a> {\n-    vec: iovec,\n-    _p: PhantomData<&'a [u8]>,\n-}\n-\n-impl<'a> IoSlice<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a [u8]) -> IoSlice<'a> {\n-        IoSlice {\n-            vec: iovec { iov_base: buf.as_ptr() as *mut u8 as *mut c_void, iov_len: buf.len() },\n-            _p: PhantomData,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        if self.vec.iov_len < n {\n-            panic!(\"advancing IoSlice beyond its length\");\n-        }\n-\n-        unsafe {\n-            self.vec.iov_len -= n;\n-            self.vec.iov_base = self.vec.iov_base.add(n);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n-    }\n-}\n-\n-pub struct IoSliceMut<'a> {\n-    vec: iovec,\n-    _p: PhantomData<&'a mut [u8]>,\n-}\n-\n-impl<'a> IoSliceMut<'a> {\n-    #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> IoSliceMut<'a> {\n-        IoSliceMut {\n-            vec: iovec { iov_base: buf.as_mut_ptr() as *mut c_void, iov_len: buf.len() },\n-            _p: PhantomData,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn advance(&mut self, n: usize) {\n-        if self.vec.iov_len < n {\n-            panic!(\"advancing IoSliceMut beyond its length\");\n-        }\n-\n-        unsafe {\n-            self.vec.iov_len -= n;\n-            self.vec.iov_base = self.vec.iov_base.add(n);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn as_slice(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n-    }\n-\n-    #[inline]\n-    pub fn as_mut_slice(&mut self) -> &mut [u8] {\n-        unsafe { slice::from_raw_parts_mut(self.vec.iov_base as *mut u8, self.vec.iov_len) }\n-    }\n-}"}, {"sha": "928100c92ffadf57c3f018c628509bb073ccb786", "filename": "library/std/src/sys/vxworks/memchr.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmemchr.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,21 +0,0 @@\n-// Original implementation taken from rust-memchr.\n-// Copyright 2015 Andrew Gallant, bluss and Nicolas Koch\n-\n-pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-    let p = unsafe {\n-        libc::memchr(\n-            haystack.as_ptr() as *const libc::c_void,\n-            needle as libc::c_int,\n-            haystack.len(),\n-        )\n-    };\n-    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n-}\n-\n-pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n-    fn memrchr_specific(needle: u8, haystack: &[u8]) -> Option<usize> {\n-        core::slice::memchr::memrchr(needle, haystack)\n-    }\n-\n-    memrchr_specific(needle, haystack)\n-}"}, {"sha": "c20edaa1a4778a3761129eae4b1f79f9b7db8e25", "filename": "library/std/src/sys/vxworks/mod.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmod.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -7,29 +7,53 @@ pub use self::rand::hashmap_random_keys;\n pub use crate::os::vxworks as platform;\n pub use libc::strlen;\n \n+#[macro_use]\n+#[path = \"../unix/weak.rs\"]\n+pub mod weak;\n+\n+#[path = \"../unix/alloc.rs\"]\n pub mod alloc;\n+#[path = \"../unix/args.rs\"]\n pub mod args;\n+#[path = \"../unix/cmath.rs\"]\n pub mod cmath;\n+#[path = \"../unix/condvar.rs\"]\n pub mod condvar;\n pub mod env;\n+#[path = \"../unix/ext/mod.rs\"]\n pub mod ext;\n+#[path = \"../unix/fd.rs\"]\n pub mod fd;\n+#[path = \"../unix/fs.rs\"]\n pub mod fs;\n+#[path = \"../unix/io.rs\"]\n pub mod io;\n+#[path = \"../unix/memchr.rs\"]\n pub mod memchr;\n+#[path = \"../unix/mutex.rs\"]\n pub mod mutex;\n+#[path = \"../unix/net.rs\"]\n pub mod net;\n+#[path = \"../unix/os.rs\"]\n pub mod os;\n+#[path = \"../unix/path.rs\"]\n pub mod path;\n+#[path = \"../unix/pipe.rs\"]\n pub mod pipe;\n pub mod process;\n pub mod rand;\n+#[path = \"../unix/rwlock.rs\"]\n pub mod rwlock;\n+#[path = \"../unix/stack_overflow.rs\"]\n pub mod stack_overflow;\n+#[path = \"../unix/stdio.rs\"]\n pub mod stdio;\n+#[path = \"../unix/thread.rs\"]\n pub mod thread;\n pub mod thread_local_dtor;\n+#[path = \"../unix/thread_local_key.rs\"]\n pub mod thread_local_key;\n+#[path = \"../unix/time.rs\"]\n pub mod time;\n \n pub use crate::sys_common::os_str_bytes as os_str;"}, {"sha": "dd7582c21a72725ae20e6b7c42f8ffbac3ca3377", "filename": "library/std/src/sys/vxworks/mutex.rs", "status": "removed", "additions": 0, "deletions": 133, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmutex.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,133 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::mem::MaybeUninit;\n-\n-pub struct Mutex {\n-    inner: UnsafeCell<libc::pthread_mutex_t>,\n-}\n-\n-pub type MovableMutex = Box<Mutex>;\n-\n-#[inline]\n-pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n-    m.inner.get()\n-}\n-\n-unsafe impl Send for Mutex {}\n-unsafe impl Sync for Mutex {}\n-\n-#[allow(dead_code)] // sys isn't exported yet\n-impl Mutex {\n-    pub const fn new() -> Mutex {\n-        // Might be moved to a different address, so it is better to avoid\n-        // initialization of potentially opaque OS data before it landed.\n-        // Be very careful using this newly constructed `Mutex`, reentrant\n-        // locking is undefined behavior until `init` is called!\n-        Mutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n-    }\n-    #[inline]\n-    pub unsafe fn init(&mut self) {\n-        // Issue #33770\n-        //\n-        // A pthread mutex initialized with PTHREAD_MUTEX_INITIALIZER will have\n-        // a type of PTHREAD_MUTEX_DEFAULT, which has undefined behavior if you\n-        // try to re-lock it from the same thread when you already hold a lock.\n-        //\n-        // In practice, glibc takes advantage of this undefined behavior to\n-        // implement hardware lock elision, which uses hardware transactional\n-        // memory to avoid acquiring the lock. While a transaction is in\n-        // progress, the lock appears to be unlocked. This isn't a problem for\n-        // other threads since the transactional memory will abort if a conflict\n-        // is detected, however no abort is generated if re-locking from the\n-        // same thread.\n-        //\n-        // Since locking the same mutex twice will result in two aliasing &mut\n-        // references, we instead create the mutex with type\n-        // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n-        // re-lock it from the same thread, thus avoiding undefined behavior.\n-        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n-        let r = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n-        debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL);\n-        debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n-        debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n-        debug_assert_eq!(r, 0);\n-    }\n-    #[inline]\n-    pub unsafe fn lock(&self) {\n-        let r = libc::pthread_mutex_lock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-    #[inline]\n-    pub unsafe fn unlock(&self) {\n-        let r = libc::pthread_mutex_unlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        libc::pthread_mutex_trylock(self.inner.get()) == 0\n-    }\n-    #[inline]\n-    #[cfg(not(target_os = \"dragonfly\"))]\n-    pub unsafe fn destroy(&self) {\n-        let r = libc::pthread_mutex_destroy(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-    #[inline]\n-    #[cfg(target_os = \"dragonfly\")]\n-    pub unsafe fn destroy(&self) {\n-        let r = libc::pthread_mutex_destroy(self.inner.get());\n-        // On DragonFly pthread_mutex_destroy() returns EINVAL if called on a\n-        // mutex that was just initialized with libc::PTHREAD_MUTEX_INITIALIZER.\n-        // Once it is used (locked/unlocked) or pthread_mutex_init() is called,\n-        // this behaviour no longer occurs.\n-        debug_assert!(r == 0 || r == libc::EINVAL);\n-    }\n-}\n-\n-pub struct ReentrantMutex {\n-    inner: UnsafeCell<libc::pthread_mutex_t>,\n-}\n-\n-unsafe impl Send for ReentrantMutex {}\n-unsafe impl Sync for ReentrantMutex {}\n-\n-impl ReentrantMutex {\n-    pub const unsafe fn uninitialized() -> ReentrantMutex {\n-        ReentrantMutex { inner: UnsafeCell::new(libc::PTHREAD_MUTEX_INITIALIZER) }\n-    }\n-\n-    pub unsafe fn init(&self) {\n-        let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n-        let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n-        debug_assert_eq!(result, 0);\n-        let result =\n-            libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE);\n-        debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n-        debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n-        debug_assert_eq!(result, 0);\n-    }\n-\n-    pub unsafe fn lock(&self) {\n-        let result = libc::pthread_mutex_lock(self.inner.get());\n-        debug_assert_eq!(result, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        libc::pthread_mutex_trylock(self.inner.get()) == 0\n-    }\n-\n-    pub unsafe fn unlock(&self) {\n-        let result = libc::pthread_mutex_unlock(self.inner.get());\n-        debug_assert_eq!(result, 0);\n-    }\n-\n-    pub unsafe fn destroy(&self) {\n-        let result = libc::pthread_mutex_destroy(self.inner.get());\n-        debug_assert_eq!(result, 0);\n-    }\n-}"}, {"sha": "7613fbec46f397c454bab142949fdc58159486c8", "filename": "library/std/src/sys/vxworks/net.rs", "status": "removed", "additions": 0, "deletions": 335, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,335 +0,0 @@\n-#[cfg(all(test, taget_env = \"gnu\"))]\n-mod tests;\n-\n-use crate::cmp;\n-use crate::ffi::CStr;\n-use crate::io;\n-use crate::io::{IoSlice, IoSliceMut};\n-use crate::mem;\n-use crate::net::{Shutdown, SocketAddr};\n-use crate::str;\n-use crate::sys::fd::FileDesc;\n-use crate::sys_common::net::{getsockopt, setsockopt, sockaddr_to_addr};\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n-use crate::time::{Duration, Instant};\n-use libc::{self, c_int, c_void, size_t, sockaddr, socklen_t, EAI_SYSTEM, MSG_PEEK};\n-\n-pub use crate::sys::{cvt, cvt_r};\n-\n-#[allow(unused_extern_crates)]\n-pub extern crate libc as netc;\n-\n-pub type wrlen_t = size_t;\n-\n-pub struct Socket(FileDesc);\n-\n-pub fn init() {}\n-\n-pub fn cvt_gai(err: c_int) -> io::Result<()> {\n-    if err == 0 {\n-        return Ok(());\n-    }\n-\n-    // We may need to trigger a glibc workaround. See on_resolver_failure() for details.\n-    on_resolver_failure();\n-\n-    if err == EAI_SYSTEM {\n-        return Err(io::Error::last_os_error());\n-    }\n-\n-    let detail = unsafe {\n-        str::from_utf8(CStr::from_ptr(libc::gai_strerror(err)).to_bytes()).unwrap().to_owned()\n-    };\n-    Err(io::Error::new(\n-        io::ErrorKind::Other,\n-        &format!(\"failed to lookup address information: {}\", detail)[..],\n-    ))\n-}\n-\n-impl Socket {\n-    pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n-        let fam = match *addr {\n-            SocketAddr::V4(..) => libc::AF_INET,\n-            SocketAddr::V6(..) => libc::AF_INET6,\n-        };\n-        Socket::new_raw(fam, ty)\n-    }\n-\n-    pub fn new_raw(fam: c_int, ty: c_int) -> io::Result<Socket> {\n-        unsafe {\n-            let fd = cvt(libc::socket(fam, ty, 0))?;\n-            let fd = FileDesc::new(fd);\n-            fd.set_cloexec()?;\n-            let socket = Socket(fd);\n-            Ok(socket)\n-        }\n-    }\n-\n-    pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {\n-        unimplemented!();\n-    }\n-\n-    pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n-        self.set_nonblocking(true)?;\n-        let r = unsafe {\n-            let (addrp, len) = addr.into_inner();\n-            cvt(libc::connect(self.0.raw(), addrp, len))\n-        };\n-        self.set_nonblocking(false)?;\n-\n-        match r {\n-            Ok(_) => return Ok(()),\n-            // there's no ErrorKind for EINPROGRESS :(\n-            Err(ref e) if e.raw_os_error() == Some(libc::EINPROGRESS) => {}\n-            Err(e) => return Err(e),\n-        }\n-\n-        let mut pollfd = libc::pollfd { fd: self.0.raw(), events: libc::POLLOUT, revents: 0 };\n-\n-        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"cannot set a 0 duration timeout\",\n-            ));\n-        }\n-\n-        let start = Instant::now();\n-\n-        loop {\n-            let elapsed = start.elapsed();\n-            if elapsed >= timeout {\n-                return Err(io::Error::new(io::ErrorKind::TimedOut, \"connection timed out\"));\n-            }\n-\n-            let timeout = timeout - elapsed;\n-            let mut timeout = timeout\n-                .as_secs()\n-                .saturating_mul(1_000)\n-                .saturating_add(timeout.subsec_nanos() as u64 / 1_000_000);\n-            if timeout == 0 {\n-                timeout = 1;\n-            }\n-\n-            let timeout = cmp::min(timeout, c_int::MAX as u64) as c_int;\n-\n-            match unsafe { libc::poll(&mut pollfd, 1, timeout) } {\n-                -1 => {\n-                    let err = io::Error::last_os_error();\n-                    if err.kind() != io::ErrorKind::Interrupted {\n-                        return Err(err);\n-                    }\n-                }\n-                0 => {}\n-                _ => {\n-                    // linux returns POLLOUT|POLLERR|POLLHUP for refused connections (!), so look\n-                    // for POLLHUP rather than read readiness\n-                    if pollfd.revents & libc::POLLHUP != 0 {\n-                        let e = self.take_error()?.unwrap_or_else(|| {\n-                            io::Error::new(io::ErrorKind::Other, \"no error set after POLLHUP\")\n-                        });\n-                        return Err(e);\n-                    }\n-\n-                    return Ok(());\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t) -> io::Result<Socket> {\n-        let fd = cvt_r(|| unsafe { libc::accept(self.0.raw(), storage, len) })?;\n-        let fd = FileDesc::new(fd);\n-        fd.set_cloexec()?;\n-        Ok(Socket(fd))\n-    }\n-\n-    pub fn duplicate(&self) -> io::Result<Socket> {\n-        self.0.duplicate().map(Socket)\n-    }\n-\n-    fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::recv(self.0.raw(), buf.as_mut_ptr() as *mut c_void, buf.len(), flags)\n-        })?;\n-        Ok(ret as usize)\n-    }\n-\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, 0)\n-    }\n-\n-    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.recv_with_flags(buf, MSG_PEEK)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        self.0.is_read_vectored()\n-    }\n-\n-    fn recv_from_with_flags(\n-        &self,\n-        buf: &mut [u8],\n-        flags: c_int,\n-    ) -> io::Result<(usize, SocketAddr)> {\n-        let mut storage: libc::sockaddr_storage = unsafe { mem::zeroed() };\n-        let mut addrlen = mem::size_of_val(&storage) as libc::socklen_t;\n-\n-        let n = cvt(unsafe {\n-            libc::recvfrom(\n-                self.0.raw(),\n-                buf.as_mut_ptr() as *mut c_void,\n-                buf.len(),\n-                flags,\n-                &mut storage as *mut _ as *mut _,\n-                &mut addrlen,\n-            )\n-        })?;\n-        Ok((n as usize, sockaddr_to_addr(&storage, addrlen as usize)?))\n-    }\n-\n-    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        self.recv_from_with_flags(buf, 0)\n-    }\n-\n-    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        self.recv_from_with_flags(buf, MSG_PEEK)\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        self.0.is_write_vectored()\n-    }\n-\n-    pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n-        let timeout = match dur {\n-            Some(dur) => {\n-                if dur.as_secs() == 0 && dur.subsec_nanos() == 0 {\n-                    return Err(io::Error::new(\n-                        io::ErrorKind::InvalidInput,\n-                        \"cannot set a 0 duration timeout\",\n-                    ));\n-                }\n-\n-                let secs = if dur.as_secs() > libc::time_t::MAX as u64 {\n-                    libc::time_t::MAX\n-                } else {\n-                    dur.as_secs() as libc::time_t\n-                };\n-                let mut timeout = libc::timeval {\n-                    tv_sec: secs,\n-                    tv_usec: (dur.subsec_nanos() / 1000) as libc::suseconds_t,\n-                };\n-                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n-                    timeout.tv_usec = 1;\n-                }\n-                timeout\n-            }\n-            None => libc::timeval { tv_sec: 0, tv_usec: 0 },\n-        };\n-        setsockopt(self, libc::SOL_SOCKET, kind, timeout)\n-    }\n-\n-    pub fn timeout(&self, kind: libc::c_int) -> io::Result<Option<Duration>> {\n-        let raw: libc::timeval = getsockopt(self, libc::SOL_SOCKET, kind)?;\n-        if raw.tv_sec == 0 && raw.tv_usec == 0 {\n-            Ok(None)\n-        } else {\n-            let sec = raw.tv_sec as u64;\n-            let nsec = (raw.tv_usec as u32) * 1000;\n-            Ok(Some(Duration::new(sec, nsec)))\n-        }\n-    }\n-\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        let how = match how {\n-            Shutdown::Write => libc::SHUT_WR,\n-            Shutdown::Read => libc::SHUT_RD,\n-            Shutdown::Both => libc::SHUT_RDWR,\n-        };\n-        cvt(unsafe { libc::shutdown(self.0.raw(), how) })?;\n-        Ok(())\n-    }\n-\n-    pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {\n-        setsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY, nodelay as c_int)\n-    }\n-\n-    pub fn nodelay(&self) -> io::Result<bool> {\n-        let raw: c_int = getsockopt(self, libc::IPPROTO_TCP, libc::TCP_NODELAY)?;\n-        Ok(raw != 0)\n-    }\n-\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        let mut nonblocking = nonblocking as libc::c_int;\n-        cvt(unsafe { libc::ioctl(*self.as_inner(), libc::FIONBIO, &mut nonblocking) }).map(drop)\n-    }\n-\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        let raw: c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_ERROR)?;\n-        if raw == 0 { Ok(None) } else { Ok(Some(io::Error::from_raw_os_error(raw as i32))) }\n-    }\n-}\n-\n-impl AsInner<c_int> for Socket {\n-    fn as_inner(&self) -> &c_int {\n-        self.0.as_inner()\n-    }\n-}\n-\n-impl FromInner<c_int> for Socket {\n-    fn from_inner(fd: c_int) -> Socket {\n-        Socket(FileDesc::new(fd))\n-    }\n-}\n-\n-impl IntoInner<c_int> for Socket {\n-    fn into_inner(self) -> c_int {\n-        self.0.into_raw()\n-    }\n-}\n-\n-// In versions of glibc prior to 2.26, there's a bug where the DNS resolver\n-// will cache the contents of /etc/resolv.conf, so changes to that file on disk\n-// can be ignored by a long-running program. That can break DNS lookups on e.g.\n-// laptops where the network comes and goes. See\n-// https://sourceware.org/bugzilla/show_bug.cgi?id=984. Note however that some\n-// distros including Debian have patched glibc to fix this for a long time.\n-//\n-// A workaround for this bug is to call the res_init libc function, to clear\n-// the cached configs. Unfortunately, while we believe glibc's implementation\n-// of res_init is thread-safe, we know that other implementations are not\n-// (https://github.com/rust-lang/rust/issues/43592). Code here in libstd could\n-// try to synchronize its res_init calls with a Mutex, but that wouldn't\n-// protect programs that call into libc in other ways. So instead of calling\n-// res_init unconditionally, we call it only when we detect we're linking\n-// against glibc version < 2.26. (That is, when we both know its needed and\n-// believe it's thread-safe).\n-#[cfg(target_env = \"gnu\")]\n-fn on_resolver_failure() {\n-    /*\n-    use crate::sys;\n-\n-    // If the version fails to parse, we treat it the same as \"not glibc\".\n-    if let Some(version) = sys::os::glibc_version() {\n-        if version < (2, 26) {\n-            unsafe { libc::res_init() };\n-        }\n-    }\n-    */\n-}\n-\n-#[cfg(not(target_env = \"gnu\"))]\n-fn on_resolver_failure() {}"}, {"sha": "e7c6e348f8e5a44f8cdab12430ad3814ed164313", "filename": "library/std/src/sys/vxworks/net/tests.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fnet%2Ftests.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,23 +0,0 @@\n-use super::*;\n-\n-#[test]\n-fn test_res_init() {\n-    // This mostly just tests that the weak linkage doesn't panic wildly...\n-    res_init_if_glibc_before_2_26().unwrap();\n-}\n-\n-#[test]\n-fn test_parse_glibc_version() {\n-    let cases = [\n-        (\"0.0\", Some((0, 0))),\n-        (\"01.+2\", Some((1, 2))),\n-        (\"3.4.5.six\", Some((3, 4))),\n-        (\"1\", None),\n-        (\"1.-2\", None),\n-        (\"1.foo\", None),\n-        (\"foo.1\", None),\n-    ];\n-    for &(version_str, parsed) in cases.iter() {\n-        assert_eq!(parsed, parse_glibc_version(version_str));\n-    }\n-}"}, {"sha": "6eaec6f1e50df3054c6edf27313940285f6e9eca", "filename": "library/std/src/sys/vxworks/os.rs", "status": "removed", "additions": 0, "deletions": 315, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fos.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,315 +0,0 @@\n-use crate::error::Error as StdError;\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n-use crate::fmt;\n-use crate::io;\n-use crate::iter;\n-use crate::marker::PhantomData;\n-use crate::mem;\n-use crate::memchr;\n-use crate::path::{self, Path, PathBuf};\n-use crate::slice;\n-use crate::str;\n-use crate::sys::cvt;\n-use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n-use libc::{self, c_char /*,c_void */, c_int};\n-/*use sys::fd; this one is probably important */\n-use crate::vec;\n-\n-const TMPBUF_SZ: usize = 128;\n-\n-// This is a terrible fix\n-use crate::sys::os_str::Buf;\n-use crate::sys_common::{AsInner, FromInner, IntoInner};\n-\n-pub trait OsStringExt {\n-    fn from_vec(vec: Vec<u8>) -> Self;\n-    fn into_vec(self) -> Vec<u8>;\n-}\n-\n-impl OsStringExt for OsString {\n-    fn from_vec(vec: Vec<u8>) -> OsString {\n-        FromInner::from_inner(Buf { inner: vec })\n-    }\n-    fn into_vec(self) -> Vec<u8> {\n-        self.into_inner().inner\n-    }\n-}\n-\n-pub trait OsStrExt {\n-    fn from_bytes(slice: &[u8]) -> &Self;\n-    fn as_bytes(&self) -> &[u8];\n-}\n-\n-impl OsStrExt for OsStr {\n-    fn from_bytes(slice: &[u8]) -> &OsStr {\n-        unsafe { mem::transmute(slice) }\n-    }\n-    fn as_bytes(&self) -> &[u8] {\n-        &self.as_inner().inner\n-    }\n-}\n-\n-pub fn errno() -> i32 {\n-    unsafe { libc::errnoGet() }\n-}\n-\n-pub fn set_errno(e: i32) {\n-    unsafe {\n-        libc::errnoSet(e as c_int);\n-    }\n-}\n-\n-/// Gets a detailed string description for the given error number.\n-pub fn error_string(errno: i32) -> String {\n-    let mut buf = [0 as c_char; TMPBUF_SZ];\n-    extern \"C\" {\n-        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t) -> c_int;\n-    }\n-\n-    let p = buf.as_mut_ptr();\n-    unsafe {\n-        if strerror_r(errno as c_int, p, buf.len()) < 0 {\n-            panic!(\"strerror_r failure\");\n-        }\n-        let p = p as *const _;\n-        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n-    }\n-}\n-\n-pub fn getcwd() -> io::Result<PathBuf> {\n-    let mut buf = Vec::with_capacity(512);\n-    loop {\n-        unsafe {\n-            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n-            if !libc::getcwd(ptr, buf.capacity() as libc::size_t).is_null() {\n-                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n-                buf.set_len(len);\n-                buf.shrink_to_fit();\n-                return Ok(PathBuf::from(OsString::from_vec(buf)));\n-            } else {\n-                let error = io::Error::last_os_error();\n-                if error.raw_os_error() != Some(libc::ERANGE) {\n-                    return Err(error);\n-                }\n-            }\n-            // Trigger the internal buffer resizing logic of `Vec` by requiring\n-            // more space than the current capacity.\n-            let cap = buf.capacity();\n-            buf.set_len(cap);\n-            buf.reserve(1);\n-        }\n-    }\n-}\n-\n-pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    let p: &OsStr = p.as_ref();\n-    let p = CString::new(p.as_bytes())?;\n-    unsafe {\n-        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n-            true => Ok(()),\n-            false => Err(io::Error::last_os_error()),\n-        }\n-    }\n-}\n-\n-pub struct SplitPaths<'a> {\n-    iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>, fn(&'a [u8]) -> PathBuf>,\n-}\n-\n-pub fn split_paths(unparsed: &OsStr) -> SplitPaths<'_> {\n-    fn bytes_to_path(b: &[u8]) -> PathBuf {\n-        PathBuf::from(<OsStr as OsStrExt>::from_bytes(b))\n-    }\n-    fn is_colon(b: &u8) -> bool {\n-        *b == b':'\n-    }\n-    let unparsed = unparsed.as_bytes();\n-    SplitPaths {\n-        iter: unparsed\n-            .split(is_colon as fn(&u8) -> bool)\n-            .map(bytes_to_path as fn(&[u8]) -> PathBuf),\n-    }\n-}\n-\n-impl<'a> Iterator for SplitPaths<'a> {\n-    type Item = PathBuf;\n-    fn next(&mut self) -> Option<PathBuf> {\n-        self.iter.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct JoinPathsError;\n-\n-pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n-where\n-    I: Iterator<Item = T>,\n-    T: AsRef<OsStr>,\n-{\n-    let mut joined = Vec::new();\n-    let sep = b':';\n-\n-    for (i, path) in paths.enumerate() {\n-        let path = path.as_ref().as_bytes();\n-        if i > 0 {\n-            joined.push(sep)\n-        }\n-        if path.contains(&sep) {\n-            return Err(JoinPathsError);\n-        }\n-        joined.extend_from_slice(path);\n-    }\n-    Ok(OsStringExt::from_vec(joined))\n-}\n-\n-impl fmt::Display for JoinPathsError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        \"path segment contains separator `:`\".fmt(f)\n-    }\n-}\n-\n-impl StdError for JoinPathsError {\n-    #[allow(deprecated)]\n-    fn description(&self) -> &str {\n-        \"failed to join paths\"\n-    }\n-}\n-\n-pub fn current_exe() -> io::Result<PathBuf> {\n-    #[cfg(test)]\n-    use realstd::env;\n-\n-    #[cfg(not(test))]\n-    use crate::env;\n-\n-    let exe_path = env::args().next().unwrap();\n-    let path = Path::new(&exe_path);\n-    path.canonicalize()\n-}\n-\n-pub struct Env {\n-    iter: vec::IntoIter<(OsString, OsString)>,\n-    _dont_send_or_sync_me: PhantomData<*mut ()>,\n-}\n-\n-impl Iterator for Env {\n-    type Item = (OsString, OsString);\n-    fn next(&mut self) -> Option<(OsString, OsString)> {\n-        self.iter.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-pub unsafe fn environ() -> *mut *const *const c_char {\n-    extern \"C\" {\n-        static mut environ: *const *const c_char;\n-    }\n-    &mut environ\n-}\n-\n-pub unsafe fn env_lock() -> StaticMutexGuard {\n-    // It is UB to attempt to acquire this mutex reentrantly!\n-    static ENV_LOCK: StaticMutex = StaticMutex::new();\n-    ENV_LOCK.lock()\n-}\n-\n-/// Returns a vector of (variable, value) byte-vector pairs for all the\n-/// environment variables of the current process.\n-pub fn env() -> Env {\n-    unsafe {\n-        let _guard = env_lock();\n-        let mut environ = *environ();\n-        if environ.is_null() {\n-            panic!(\"os::env() failure getting env string from OS: {}\", io::Error::last_os_error());\n-        }\n-        let mut result = Vec::new();\n-        while !(*environ).is_null() {\n-            if let Some(key_value) = parse(CStr::from_ptr(*environ).to_bytes()) {\n-                result.push(key_value);\n-            }\n-            environ = environ.add(1);\n-        }\n-        return Env { iter: result.into_iter(), _dont_send_or_sync_me: PhantomData };\n-    }\n-\n-    fn parse(input: &[u8]) -> Option<(OsString, OsString)> {\n-        // Strategy (copied from glibc): Variable name and value are separated\n-        // by an ASCII equals sign '='. Since a variable name must not be\n-        // empty, allow variable names starting with an equals sign. Skip all\n-        // malformed lines.\n-        if input.is_empty() {\n-            return None;\n-        }\n-        let pos = memchr::memchr(b'=', &input[1..]).map(|p| p + 1);\n-        pos.map(|p| {\n-            (\n-                OsStringExt::from_vec(input[..p].to_vec()),\n-                OsStringExt::from_vec(input[p + 1..].to_vec()),\n-            )\n-        })\n-    }\n-}\n-\n-pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n-    // environment variables with a nul byte can't be set, so their value is\n-    // always None as well\n-    let k = CString::new(k.as_bytes())?;\n-    unsafe {\n-        let _guard = env_lock();\n-        let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n-        let ret = if s.is_null() {\n-            None\n-        } else {\n-            Some(OsStringExt::from_vec(CStr::from_ptr(s).to_bytes().to_vec()))\n-        };\n-        Ok(ret)\n-    }\n-}\n-\n-pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n-    let k = CString::new(k.as_bytes())?;\n-    let v = CString::new(v.as_bytes())?;\n-\n-    unsafe {\n-        let _guard = env_lock();\n-        cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n-    }\n-}\n-\n-pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n-    let nbuf = CString::new(n.as_bytes())?;\n-\n-    unsafe {\n-        let _guard = env_lock();\n-        cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n-    }\n-}\n-\n-pub fn page_size() -> usize {\n-    unsafe { libc::sysconf(libc::_SC_PAGESIZE) as usize }\n-}\n-\n-pub fn temp_dir() -> PathBuf {\n-    crate::env::var_os(\"TMPDIR\").map(PathBuf::from).unwrap_or_else(|| PathBuf::from(\"/tmp\"))\n-}\n-\n-pub fn home_dir() -> Option<PathBuf> {\n-    crate::env::var_os(\"HOME\").or_else(|| None).map(PathBuf::from)\n-}\n-\n-pub fn exit(code: i32) -> ! {\n-    unsafe { libc::exit(code as c_int) }\n-}\n-\n-pub fn getpid() -> u32 {\n-    unsafe { libc::getpid() as u32 }\n-}\n-\n-pub fn getppid() -> u32 {\n-    unsafe { libc::getppid() as u32 }\n-}"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "library/std/src/sys/vxworks/path.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpath.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,19 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::path::Prefix;\n-\n-#[inline]\n-pub fn is_sep_byte(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-#[inline]\n-pub fn is_verbatim_sep(b: u8) -> bool {\n-    b == b'/'\n-}\n-\n-pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n-    None\n-}\n-\n-pub const MAIN_SEP_STR: &str = \"/\";\n-pub const MAIN_SEP: char = '/';"}, {"sha": "a18376212af51a32e8044194fa39892aced42b1d", "filename": "library/std/src/sys/vxworks/pipe.rs", "status": "removed", "additions": 0, "deletions": 107, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fpipe.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,107 +0,0 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::mem;\n-use crate::sync::atomic::AtomicBool;\n-use crate::sys::fd::FileDesc;\n-use crate::sys::{cvt, cvt_r};\n-use libc::{self /*, c_int apparently not used? */};\n-\n-pub struct AnonPipe(FileDesc);\n-\n-pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n-    static INVALID: AtomicBool = AtomicBool::new(false);\n-\n-    let mut fds = [0; 2];\n-    cvt(unsafe { libc::pipe(fds.as_mut_ptr()) })?;\n-\n-    let fd0 = FileDesc::new(fds[0]);\n-    let fd1 = FileDesc::new(fds[1]);\n-    fd0.set_cloexec()?;\n-    fd1.set_cloexec()?;\n-    Ok((AnonPipe(fd0), AnonPipe(fd1)))\n-}\n-\n-impl AnonPipe {\n-    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_read_vectored(&self) -> bool {\n-        self.0.is_read_vectored()\n-    }\n-\n-    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    pub fn is_write_vectored(&self) -> bool {\n-        self.0.is_write_vectored()\n-    }\n-\n-    pub fn fd(&self) -> &FileDesc {\n-        &self.0\n-    }\n-    pub fn into_fd(self) -> FileDesc {\n-        self.0\n-    }\n-    pub fn diverge(&self) -> ! {\n-        panic!()\n-    }\n-}\n-\n-pub fn read2(p1: AnonPipe, v1: &mut Vec<u8>, p2: AnonPipe, v2: &mut Vec<u8>) -> io::Result<()> {\n-    // Set both pipes into nonblocking mode as we're gonna be reading from both\n-    // in the `select` loop below, and we wouldn't want one to block the other!\n-    let p1 = p1.into_fd();\n-    let p2 = p2.into_fd();\n-    p1.set_nonblocking_pipe(true)?;\n-    p2.set_nonblocking_pipe(true)?;\n-\n-    let mut fds: [libc::pollfd; 2] = unsafe { mem::zeroed() };\n-    fds[0].fd = p1.raw();\n-    fds[0].events = libc::POLLIN;\n-    fds[1].fd = p2.raw();\n-    fds[1].events = libc::POLLIN;\n-    loop {\n-        // wait for either pipe to become readable using `poll`\n-        cvt_r(|| unsafe { libc::poll(fds.as_mut_ptr(), 2, -1) })?;\n-\n-        if fds[0].revents != 0 && read(&p1, v1)? {\n-            p2.set_nonblocking_pipe(false)?;\n-            return p2.read_to_end(v2).map(drop);\n-        }\n-        if fds[1].revents != 0 && read(&p2, v2)? {\n-            p1.set_nonblocking_pipe(false)?;\n-            return p1.read_to_end(v1).map(drop);\n-        }\n-    }\n-\n-    // Read as much as we can from each pipe, ignoring EWOULDBLOCK or\n-    // EAGAIN. If we hit EOF, then this will happen because the underlying\n-    // reader will return Ok(0), in which case we'll see `Ok` ourselves. In\n-    // this case we flip the other fd back into blocking mode and read\n-    // whatever's leftover on that file descriptor.\n-    fn read(fd: &FileDesc, dst: &mut Vec<u8>) -> Result<bool, io::Error> {\n-        match fd.read_to_end(dst) {\n-            Ok(_) => Ok(true),\n-            Err(e) => {\n-                if e.raw_os_error() == Some(libc::EWOULDBLOCK)\n-                    || e.raw_os_error() == Some(libc::EAGAIN)\n-                {\n-                    Ok(false)\n-                } else {\n-                    Err(e)\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "dc6130eaa24a8ad5b3dabae4191089544990cf14", "filename": "library/std/src/sys/vxworks/process/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fmod.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -1,7 +1,9 @@\n-pub use self::process_common::{Command, ExitCode, ExitStatus, Stdio, StdioPipes};\n-pub use self::process_inner::Process;\n+pub use self::process_common::{Command, CommandArgs, ExitCode, Stdio, StdioPipes};\n+pub use self::process_inner::{ExitStatus, Process};\n pub use crate::ffi::OsString as EnvKey;\n+pub use crate::sys_common::process::CommandEnvs;\n \n+#[path = \"../../unix/process/process_common.rs\"]\n mod process_common;\n #[path = \"process_vxworks.rs\"]\n mod process_inner;"}, {"sha": "6473a0c3cec41aa764d824f02a81f1765773b781", "filename": "library/std/src/sys/vxworks/process/process_common.rs", "status": "removed", "additions": 0, "deletions": 399, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_common.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,399 +0,0 @@\n-use crate::os::unix::prelude::*;\n-\n-use crate::collections::BTreeMap;\n-use crate::ffi::{CStr, CString, OsStr, OsString};\n-use crate::fmt;\n-use crate::io;\n-use crate::ptr;\n-use crate::sys::fd::FileDesc;\n-use crate::sys::fs::{File, OpenOptions};\n-use crate::sys::pipe::{self, AnonPipe};\n-use crate::sys_common::process::CommandEnv;\n-\n-use libc::{c_char, c_int, gid_t, uid_t, EXIT_FAILURE, EXIT_SUCCESS};\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    // Currently we try hard to ensure that the call to `.exec()` doesn't\n-    // actually allocate any memory. While many platforms try to ensure that\n-    // memory allocation works after a fork in a multithreaded process, it's\n-    // been observed to be buggy and somewhat unreliable, so we do our best to\n-    // just not do it at all!\n-    //\n-    // Along those lines, the `argv` and `envp` raw pointers here are exactly\n-    // what's gonna get passed to `execvp`. The `argv` array starts with the\n-    // `program` and ends with a NULL, and the `envp` pointer, if present, is\n-    // also null-terminated.\n-    //\n-    // Right now we don't support removing arguments, so there's no much fancy\n-    // support there, but we support adding and removing environment variables,\n-    // so a side table is used to track where in the `envp` array each key is\n-    // located. Whenever we add a key we update it in place if it's already\n-    // present, and whenever we remove a key we update the locations of all\n-    // other keys.\n-    program: CString,\n-    args: Vec<CString>,\n-    argv: Argv,\n-    env: CommandEnv,\n-\n-    cwd: Option<CString>,\n-    uid: Option<uid_t>,\n-    gid: Option<gid_t>,\n-    saw_nul: bool,\n-    closures: Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>>,\n-    stdin: Option<Stdio>,\n-    stdout: Option<Stdio>,\n-    stderr: Option<Stdio>,\n-}\n-\n-// Create a new type for `Argv`, so that we can make it `Send` and `Sync`\n-struct Argv(Vec<*const c_char>);\n-\n-// It is safe to make `Argv` `Send` and `Sync`, because it contains\n-// pointers to memory owned by `Command.args`\n-unsafe impl Send for Argv {}\n-unsafe impl Sync for Argv {}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-// passed to do_exec() with configuration of what the child stdio should look\n-// like\n-pub struct ChildPipes {\n-    pub stdin: ChildStdio,\n-    pub stdout: ChildStdio,\n-    pub stderr: ChildStdio,\n-}\n-\n-pub enum ChildStdio {\n-    Inherit,\n-    Explicit(c_int),\n-    Owned(FileDesc),\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-    Fd(FileDesc),\n-}\n-\n-impl Command {\n-    pub fn new(program: &OsStr) -> Command {\n-        let mut saw_nul = false;\n-        let program = os2c(program, &mut saw_nul);\n-        Command {\n-            argv: Argv(vec![program.as_ptr(), ptr::null()]),\n-            args: vec![program.clone()],\n-            program,\n-            env: Default::default(),\n-            cwd: None,\n-            uid: None,\n-            gid: None,\n-            saw_nul,\n-            closures: Vec::new(),\n-            stdin: None,\n-            stdout: None,\n-            stderr: None,\n-        }\n-    }\n-\n-    pub fn set_arg_0(&mut self, arg: &OsStr) {\n-        // Set a new arg0\n-        let arg = os2c(arg, &mut self.saw_nul);\n-        debug_assert!(self.argv.0.len() > 1);\n-        self.argv.0[0] = arg.as_ptr();\n-        self.args[0] = arg;\n-    }\n-\n-    pub fn arg(&mut self, arg: &OsStr) {\n-        // Overwrite the trailing NULL pointer in `argv` and then add a new null\n-        // pointer.\n-        let arg = os2c(arg, &mut self.saw_nul);\n-        self.argv.0[self.args.len()] = arg.as_ptr();\n-        self.argv.0.push(ptr::null());\n-\n-        // Also make sure we keep track of the owned value to schedule a\n-        // destructor for this memory.\n-        self.args.push(arg);\n-    }\n-\n-    pub fn cwd(&mut self, dir: &OsStr) {\n-        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n-    }\n-    pub fn uid(&mut self, id: uid_t) {\n-        self.uid = Some(id);\n-    }\n-    pub fn gid(&mut self, id: gid_t) {\n-        self.gid = Some(id);\n-    }\n-\n-    pub fn saw_nul(&self) -> bool {\n-        self.saw_nul\n-    }\n-    pub fn get_argv(&self) -> &Vec<*const c_char> {\n-        &self.argv.0\n-    }\n-\n-    pub fn get_program(&self) -> &CStr {\n-        &*self.program\n-    }\n-\n-    #[allow(dead_code)]\n-    pub fn get_cwd(&self) -> &Option<CString> {\n-        &self.cwd\n-    }\n-    #[allow(dead_code)]\n-    pub fn get_uid(&self) -> Option<uid_t> {\n-        self.uid\n-    }\n-    #[allow(dead_code)]\n-    pub fn get_gid(&self) -> Option<gid_t> {\n-        self.gid\n-    }\n-\n-    pub fn get_closures(&mut self) -> &mut Vec<Box<dyn FnMut() -> io::Result<()> + Send + Sync>> {\n-        &mut self.closures\n-    }\n-\n-    pub unsafe fn pre_exec(&mut self, _f: Box<dyn FnMut() -> io::Result<()> + Send + Sync>) {\n-        // Fork() is not supported in vxWorks so no way to run the closure in the new procecss.\n-        unimplemented!();\n-    }\n-\n-    pub fn stdin(&mut self, stdin: Stdio) {\n-        self.stdin = Some(stdin);\n-    }\n-\n-    pub fn stdout(&mut self, stdout: Stdio) {\n-        self.stdout = Some(stdout);\n-    }\n-\n-    pub fn stderr(&mut self, stderr: Stdio) {\n-        self.stderr = Some(stderr);\n-    }\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv {\n-        &mut self.env\n-    }\n-\n-    pub fn capture_env(&mut self) -> Option<CStringArray> {\n-        let maybe_env = self.env.capture_if_changed();\n-        maybe_env.map(|env| construct_envp(env, &mut self.saw_nul))\n-    }\n-    #[allow(dead_code)]\n-    pub fn env_saw_path(&self) -> bool {\n-        self.env.have_changed_path()\n-    }\n-\n-    pub fn setup_io(\n-        &self,\n-        default: Stdio,\n-        needs_stdin: bool,\n-    ) -> io::Result<(StdioPipes, ChildPipes)> {\n-        let null = Stdio::Null;\n-        let default_stdin = if needs_stdin { &default } else { &null };\n-        let stdin = self.stdin.as_ref().unwrap_or(default_stdin);\n-        let stdout = self.stdout.as_ref().unwrap_or(&default);\n-        let stderr = self.stderr.as_ref().unwrap_or(&default);\n-        let (their_stdin, our_stdin) = stdin.to_child_stdio(true)?;\n-        let (their_stdout, our_stdout) = stdout.to_child_stdio(false)?;\n-        let (their_stderr, our_stderr) = stderr.to_child_stdio(false)?;\n-        let ours = StdioPipes { stdin: our_stdin, stdout: our_stdout, stderr: our_stderr };\n-        let theirs = ChildPipes { stdin: their_stdin, stdout: their_stdout, stderr: their_stderr };\n-        Ok((ours, theirs))\n-    }\n-}\n-\n-fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n-    CString::new(s.as_bytes()).unwrap_or_else(|_e| {\n-        *saw_nul = true;\n-        CString::new(\"<string-with-nul>\").unwrap()\n-    })\n-}\n-\n-// Helper type to manage ownership of the strings within a C-style array.\n-pub struct CStringArray {\n-    items: Vec<CString>,\n-    ptrs: Vec<*const c_char>,\n-}\n-\n-impl CStringArray {\n-    pub fn with_capacity(capacity: usize) -> Self {\n-        let mut result = CStringArray {\n-            items: Vec::with_capacity(capacity),\n-            ptrs: Vec::with_capacity(capacity + 1),\n-        };\n-        result.ptrs.push(ptr::null());\n-        result\n-    }\n-    pub fn push(&mut self, item: CString) {\n-        let l = self.ptrs.len();\n-        self.ptrs[l - 1] = item.as_ptr();\n-        self.ptrs.push(ptr::null());\n-        self.items.push(item);\n-    }\n-    pub fn as_ptr(&self) -> *const *const c_char {\n-        self.ptrs.as_ptr()\n-    }\n-}\n-\n-fn construct_envp(env: BTreeMap<OsString, OsString>, saw_nul: &mut bool) -> CStringArray {\n-    let mut result = CStringArray::with_capacity(env.len());\n-    for (k, v) in env {\n-        let mut k: OsString = k.into();\n-\n-        // Reserve additional space for '=' and null terminator\n-        k.reserve_exact(v.len() + 2);\n-        k.push(\"=\");\n-        k.push(&v);\n-\n-        // Add the new entry into the array\n-        if let Ok(item) = CString::new(k.into_vec()) {\n-            result.push(item);\n-        } else {\n-            *saw_nul = true;\n-        }\n-    }\n-\n-    result\n-}\n-\n-impl Stdio {\n-    pub fn to_child_stdio(&self, readable: bool) -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n-        match *self {\n-            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n-\n-            // Make sure that the source descriptors are not an stdio\n-            // descriptor, otherwise the order which we set the child's\n-            // descriptors may blow away a descriptor which we are hoping to\n-            // save. For example, suppose we want the child's stderr to be the\n-            // parent's stdout, and the child's stdout to be the parent's\n-            // stderr. No matter which we dup first, the second will get\n-            // overwritten prematurely.\n-            Stdio::Fd(ref fd) => {\n-                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n-                    Ok((ChildStdio::Owned(fd.duplicate()?), None))\n-                } else {\n-                    Ok((ChildStdio::Explicit(fd.raw()), None))\n-                }\n-            }\n-\n-            Stdio::MakePipe => {\n-                let (reader, writer) = pipe::anon_pipe()?;\n-                let (ours, theirs) = if readable { (writer, reader) } else { (reader, writer) };\n-                Ok((ChildStdio::Owned(theirs.into_fd()), Some(ours)))\n-            }\n-\n-            Stdio::Null => {\n-                let mut opts = OpenOptions::new();\n-                opts.read(readable);\n-                opts.write(!readable);\n-                let path = unsafe { CStr::from_ptr(\"/null\\0\".as_ptr() as *const _) };\n-                let fd = File::open_c(&path, &opts)?;\n-                Ok((ChildStdio::Owned(fd.into_fd()), None))\n-            }\n-        }\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        Stdio::Fd(pipe.into_fd())\n-    }\n-}\n-\n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        Stdio::Fd(file.into_fd())\n-    }\n-}\n-\n-impl ChildStdio {\n-    pub fn fd(&self) -> Option<c_int> {\n-        match *self {\n-            ChildStdio::Inherit => None,\n-            ChildStdio::Explicit(fd) => Some(fd),\n-            ChildStdio::Owned(ref fd) => Some(fd.raw()),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if self.program != self.args[0] {\n-            write!(f, \"[{:?}] \", self.program)?;\n-        }\n-        write!(f, \"{:?}\", self.args[0])?;\n-\n-        for arg in &self.args[1..] {\n-            write!(f, \" {:?}\", arg)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-/// Unix exit statuses\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitStatus(c_int);\n-\n-impl ExitStatus {\n-    pub fn new(status: c_int) -> ExitStatus {\n-        ExitStatus(status)\n-    }\n-\n-    fn exited(&self) -> bool {\n-        libc::WIFEXITED(self.0)\n-    }\n-\n-    pub fn success(&self) -> bool {\n-        self.code() == Some(0)\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        if self.exited() { Some(libc::WEXITSTATUS(self.0)) } else { None }\n-    }\n-\n-    pub fn signal(&self) -> Option<i32> {\n-        if !self.exited() { Some(libc::WTERMSIG(self.0)) } else { None }\n-    }\n-}\n-\n-/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\n-impl From<c_int> for ExitStatus {\n-    fn from(a: c_int) -> ExitStatus {\n-        ExitStatus(a)\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if let Some(code) = self.code() {\n-            write!(f, \"exit code: {}\", code)\n-        } else {\n-            let signal = self.signal().unwrap();\n-            write!(f, \"signal: {}\", signal)\n-        }\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(u8);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(EXIT_SUCCESS as _);\n-    pub const FAILURE: ExitCode = ExitCode(EXIT_FAILURE as _);\n-\n-    #[inline]\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}"}, {"sha": "69adbcdddc971eb5582b14ae09ab4825dff7a9f0", "filename": "library/std/src/sys/vxworks/process/process_vxworks.rs", "status": "modified", "additions": 46, "deletions": 1, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fprocess%2Fprocess_vxworks.rs?ref=95b4a4f0eee935f9e0c80b0ceef34866bcb72ca3", "patch": "@@ -1,3 +1,4 @@\n+use crate::fmt;\n use crate::io::{self, Error, ErrorKind};\n use crate::sys;\n use crate::sys::cvt;\n@@ -67,7 +68,7 @@ impl Command {\n             let _lock = sys::os::env_lock();\n \n             let ret = libc::rtpSpawn(\n-                self.get_program().as_ptr(),\n+                self.get_program_cstr().as_ptr(),\n                 self.get_argv().as_ptr() as *mut *const c_char, // argv\n                 c_envp as *mut *const c_char,\n                 100 as c_int, // initial priority\n@@ -167,3 +168,47 @@ impl Process {\n         }\n     }\n }\n+\n+/// Unix exit statuses\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(c_int);\n+\n+impl ExitStatus {\n+    pub fn new(status: c_int) -> ExitStatus {\n+        ExitStatus(status)\n+    }\n+\n+    fn exited(&self) -> bool {\n+        libc::WIFEXITED(self.0)\n+    }\n+\n+    pub fn success(&self) -> bool {\n+        self.code() == Some(0)\n+    }\n+\n+    pub fn code(&self) -> Option<i32> {\n+        if self.exited() { Some(libc::WEXITSTATUS(self.0)) } else { None }\n+    }\n+\n+    pub fn signal(&self) -> Option<i32> {\n+        if !self.exited() { Some(libc::WTERMSIG(self.0)) } else { None }\n+    }\n+}\n+\n+/// Converts a raw `c_int` to a type-safe `ExitStatus` by wrapping it without copying.\n+impl From<c_int> for ExitStatus {\n+    fn from(a: c_int) -> ExitStatus {\n+        ExitStatus(a)\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if let Some(code) = self.code() {\n+            write!(f, \"exit code: {}\", code)\n+        } else {\n+            let signal = self.signal().unwrap();\n+            write!(f, \"signal: {}\", signal)\n+        }\n+    }\n+}"}, {"sha": "c90304c2b4a6a2d90dede9cd798a4b6d4063a8aa", "filename": "library/std/src/sys/vxworks/rwlock.rs", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Frwlock.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,114 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-\n-pub struct RWLock {\n-    inner: UnsafeCell<libc::pthread_rwlock_t>,\n-    write_locked: UnsafeCell<bool>,\n-    num_readers: AtomicUsize,\n-}\n-\n-unsafe impl Send for RWLock {}\n-unsafe impl Sync for RWLock {}\n-\n-impl RWLock {\n-    pub const fn new() -> RWLock {\n-        RWLock {\n-            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n-            write_locked: UnsafeCell::new(false),\n-            num_readers: AtomicUsize::new(0),\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read(&self) {\n-        let r = libc::pthread_rwlock_rdlock(self.inner.get());\n-        if r == libc::EAGAIN {\n-            panic!(\"rwlock maximum reader count exceeded\");\n-        } else if r == libc::EDEADLK || (r == 0 && *self.write_locked.get()) {\n-            if r == 0 {\n-                self.raw_unlock();\n-            }\n-            panic!(\"rwlock read lock would result in deadlock\");\n-        } else {\n-            debug_assert_eq!(r, 0);\n-            self.num_readers.fetch_add(1, Ordering::Relaxed);\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n-        if r == 0 {\n-            if *self.write_locked.get() {\n-                self.raw_unlock();\n-                false\n-            } else {\n-                self.num_readers.fetch_add(1, Ordering::Relaxed);\n-                true\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write(&self) {\n-        let r = libc::pthread_rwlock_wrlock(self.inner.get());\n-        // See comments above for why we check for EDEADLK and write_locked. We\n-        // also need to check that num_readers is 0.\n-        if r == libc::EDEADLK\n-            || *self.write_locked.get()\n-            || self.num_readers.load(Ordering::Relaxed) != 0\n-        {\n-            if r == 0 {\n-                self.raw_unlock();\n-            }\n-            panic!(\"rwlock write lock would result in deadlock\");\n-        } else {\n-            debug_assert_eq!(r, 0);\n-        }\n-        *self.write_locked.get() = true;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n-        if r == 0 {\n-            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n-                self.raw_unlock();\n-                false\n-            } else {\n-                *self.write_locked.get() = true;\n-                true\n-            }\n-        } else {\n-            false\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn raw_unlock(&self) {\n-        let r = libc::pthread_rwlock_unlock(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read_unlock(&self) {\n-        debug_assert!(!*self.write_locked.get());\n-        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n-        self.raw_unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write_unlock(&self) {\n-        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n-        debug_assert!(*self.write_locked.get());\n-        *self.write_locked.get() = false;\n-        self.raw_unlock();\n-    }\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        let r = libc::pthread_rwlock_destroy(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-}"}, {"sha": "7b58c83193bf3579d484798a21d6c125a378d6d9", "filename": "library/std/src/sys/vxworks/stack_overflow.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fstack_overflow.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,38 +0,0 @@\n-#![cfg_attr(test, allow(dead_code))]\n-\n-use self::imp::{drop_handler, make_handler};\n-\n-pub use self::imp::cleanup;\n-pub use self::imp::init;\n-\n-pub struct Handler {\n-    _data: *mut libc::c_void,\n-}\n-\n-impl Handler {\n-    pub unsafe fn new() -> Handler {\n-        make_handler()\n-    }\n-}\n-\n-impl Drop for Handler {\n-    fn drop(&mut self) {\n-        unsafe {\n-            drop_handler(self);\n-        }\n-    }\n-}\n-\n-mod imp {\n-    use crate::ptr;\n-\n-    pub unsafe fn init() {}\n-\n-    pub unsafe fn cleanup() {}\n-\n-    pub unsafe fn make_handler() -> super::Handler {\n-        super::Handler { _data: ptr::null_mut() }\n-    }\n-\n-    pub unsafe fn drop_handler(_handler: &mut super::Handler) {}\n-}"}, {"sha": "92e9f205b4e6e2edaf2c7ac85c31f6bed2e00f88", "filename": "library/std/src/sys/vxworks/stdio.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fstdio.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,69 +0,0 @@\n-use crate::io;\n-use crate::sys::fd::FileDesc;\n-\n-pub struct Stdin(());\n-pub struct Stdout(());\n-pub struct Stderr(());\n-\n-impl Stdin {\n-    pub const fn new() -> Stdin {\n-        Stdin(())\n-    }\n-}\n-\n-impl io::Read for Stdin {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        let fd = FileDesc::new(libc::STDIN_FILENO);\n-        let ret = fd.read(buf);\n-        fd.into_raw(); // do not close this FD\n-        ret\n-    }\n-}\n-\n-impl Stdout {\n-    pub const fn new() -> Stdout {\n-        Stdout(())\n-    }\n-}\n-\n-impl io::Write for Stdout {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        let fd = FileDesc::new(libc::STDOUT_FILENO);\n-        let ret = fd.write(buf);\n-        fd.into_raw(); // do not close this FD\n-        ret\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-impl Stderr {\n-    pub const fn new() -> Stderr {\n-        Stderr(())\n-    }\n-}\n-\n-impl io::Write for Stderr {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        let fd = FileDesc::new(libc::STDERR_FILENO);\n-        let ret = fd.write(buf);\n-        fd.into_raw(); // do not close this FD\n-        ret\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-pub fn is_ebadf(err: &io::Error) -> bool {\n-    err.raw_os_error() == Some(libc::EBADF as i32)\n-}\n-\n-pub const STDIN_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n-\n-pub fn panic_output() -> Option<impl io::Write> {\n-    Some(Stderr::new())\n-}"}, {"sha": "24a2e0f965d28f1caa255b2cb902b91b80255454", "filename": "library/std/src/sys/vxworks/thread.rs", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fthread.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,155 +0,0 @@\n-use crate::cmp;\n-use crate::ffi::CStr;\n-use crate::io;\n-use crate::mem;\n-use crate::ptr;\n-use crate::sys::{os, stack_overflow};\n-use crate::time::Duration;\n-\n-pub const DEFAULT_MIN_STACK_SIZE: usize = 0x40000; // 256K\n-\n-pub struct Thread {\n-    id: libc::pthread_t,\n-}\n-\n-// Some platforms may have pthread_t as a pointer in which case we still want\n-// a thread to be Send/Sync\n-unsafe impl Send for Thread {}\n-unsafe impl Sync for Thread {}\n-\n-// The pthread_attr_setstacksize symbol doesn't exist in the emscripten libc,\n-// so we have to not link to it to satisfy emcc's ERROR_ON_UNDEFINED_SYMBOLS.\n-unsafe fn pthread_attr_setstacksize(\n-    attr: *mut libc::pthread_attr_t,\n-    stack_size: libc::size_t,\n-) -> libc::c_int {\n-    libc::pthread_attr_setstacksize(attr, stack_size)\n-}\n-\n-impl Thread {\n-    // unsafe: see thread::Builder::spawn_unchecked for safety requirements\n-    pub unsafe fn new(stack: usize, p: Box<dyn FnOnce()>) -> io::Result<Thread> {\n-        let p = Box::into_raw(box p);\n-        let mut native: libc::pthread_t = mem::zeroed();\n-        let mut attr: libc::pthread_attr_t = mem::zeroed();\n-        assert_eq!(libc::pthread_attr_init(&mut attr), 0);\n-\n-        let stack_size = cmp::max(stack, min_stack_size(&attr));\n-\n-        match pthread_attr_setstacksize(&mut attr, stack_size) {\n-            0 => {}\n-            n => {\n-                assert_eq!(n, libc::EINVAL);\n-                // EINVAL means |stack_size| is either too small or not a\n-                // multiple of the system page size.  Because it's definitely\n-                // >= PTHREAD_STACK_MIN, it must be an alignment issue.\n-                // Round up to the nearest page and try again.\n-                let page_size = os::page_size();\n-                let stack_size =\n-                    (stack_size + page_size - 1) & (-(page_size as isize - 1) as usize - 1);\n-                assert_eq!(libc::pthread_attr_setstacksize(&mut attr, stack_size), 0);\n-            }\n-        };\n-\n-        let ret = libc::pthread_create(&mut native, &attr, thread_start, p as *mut _);\n-        // Note: if the thread creation fails and this assert fails, then p will\n-        // be leaked. However, an alternative design could cause double-free\n-        // which is clearly worse.\n-        assert_eq!(libc::pthread_attr_destroy(&mut attr), 0);\n-\n-        return if ret != 0 {\n-            // The thread failed to start and as a result p was not consumed. Therefore, it is\n-            // safe to reconstruct the box so that it gets deallocated.\n-            drop(Box::from_raw(p));\n-            Err(io::Error::from_raw_os_error(ret))\n-        } else {\n-            Ok(Thread { id: native })\n-        };\n-\n-        extern \"C\" fn thread_start(main: *mut libc::c_void) -> *mut libc::c_void {\n-            unsafe {\n-                // Next, set up our stack overflow handler which may get triggered if we run\n-                // out of stack.\n-                let _handler = stack_overflow::Handler::new();\n-                // Finally, let's run some code.\n-                Box::from_raw(main as *mut Box<dyn FnOnce()>)();\n-            }\n-            ptr::null_mut()\n-        }\n-    }\n-\n-    pub fn yield_now() {\n-        let ret = unsafe { libc::sched_yield() };\n-        debug_assert_eq!(ret, 0);\n-    }\n-\n-    pub fn set_name(_name: &CStr) {\n-        // VxWorks does not provide a way to set the task name except at creation time\n-    }\n-\n-    pub fn sleep(dur: Duration) {\n-        let mut secs = dur.as_secs();\n-        let mut nsecs = dur.subsec_nanos() as _;\n-\n-        // If we're awoken with a signal then the return value will be -1 and\n-        // nanosleep will fill in `ts` with the remaining time.\n-        unsafe {\n-            while secs > 0 || nsecs > 0 {\n-                let mut ts = libc::timespec {\n-                    tv_sec: cmp::min(libc::time_t::MAX as u64, secs) as libc::time_t,\n-                    tv_nsec: nsecs,\n-                };\n-                secs -= ts.tv_sec as u64;\n-                if libc::nanosleep(&ts, &mut ts) == -1 {\n-                    assert_eq!(os::errno(), libc::EINTR);\n-                    secs += ts.tv_sec as u64;\n-                    nsecs = ts.tv_nsec;\n-                } else {\n-                    nsecs = 0;\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn join(self) {\n-        unsafe {\n-            let ret = libc::pthread_join(self.id, ptr::null_mut());\n-            mem::forget(self);\n-            assert!(ret == 0, \"failed to join thread: {}\", io::Error::from_raw_os_error(ret));\n-        }\n-    }\n-\n-    pub fn id(&self) -> libc::pthread_t {\n-        self.id\n-    }\n-\n-    pub fn into_id(self) -> libc::pthread_t {\n-        let id = self.id;\n-        mem::forget(self);\n-        id\n-    }\n-}\n-\n-impl Drop for Thread {\n-    fn drop(&mut self) {\n-        let ret = unsafe { libc::pthread_detach(self.id) };\n-        debug_assert_eq!(ret, 0);\n-    }\n-}\n-\n-#[cfg_attr(test, allow(dead_code))]\n-pub mod guard {\n-    use crate::ops::Range;\n-    pub type Guard = Range<usize>;\n-    pub unsafe fn current() -> Option<Guard> {\n-        None\n-    }\n-    pub unsafe fn init() -> Option<Guard> {\n-        None\n-    }\n-    pub unsafe fn deinit() {}\n-}\n-\n-fn min_stack_size(_: *const libc::pthread_attr_t) -> usize {\n-    libc::PTHREAD_STACK_MIN\n-}"}, {"sha": "2c5b94b1e61e5710717363d92396c6b5e1027305", "filename": "library/std/src/sys/vxworks/thread_local_key.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fthread_local_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fthread_local_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fthread_local_key.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,34 +0,0 @@\n-#![allow(dead_code)] // not used on all platforms\n-\n-use crate::mem;\n-\n-pub type Key = libc::pthread_key_t;\n-\n-#[inline]\n-pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n-    let mut key = 0;\n-    assert_eq!(libc::pthread_key_create(&mut key, mem::transmute(dtor)), 0);\n-    key\n-}\n-\n-#[inline]\n-pub unsafe fn set(key: Key, value: *mut u8) {\n-    let r = libc::pthread_setspecific(key, value as *mut _);\n-    debug_assert_eq!(r, 0);\n-}\n-\n-#[inline]\n-pub unsafe fn get(key: Key) -> *mut u8 {\n-    libc::pthread_getspecific(key) as *mut u8\n-}\n-\n-#[inline]\n-pub unsafe fn destroy(key: Key) {\n-    let r = libc::pthread_key_delete(key);\n-    debug_assert_eq!(r, 0);\n-}\n-\n-#[inline]\n-pub fn requires_synchronized_create() -> bool {\n-    false\n-}"}, {"sha": "8f46f4d284f0bf71ad499c3457da75c9faac5a55", "filename": "library/std/src/sys/vxworks/time.rs", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e6f69afc9b0943003ce51a53d1f59611e6601a3/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Ftime.rs?ref=8e6f69afc9b0943003ce51a53d1f59611e6601a3", "patch": "@@ -1,197 +0,0 @@\n-use crate::cmp::Ordering;\n-use crate::time::Duration;\n-use core::hash::{Hash, Hasher};\n-\n-pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n-use crate::convert::TryInto;\n-\n-const NSEC_PER_SEC: u64 = 1_000_000_000;\n-\n-#[derive(Copy, Clone)]\n-struct Timespec {\n-    t: libc::timespec,\n-}\n-\n-impl Timespec {\n-    const fn zero() -> Timespec {\n-        Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } }\n-    }\n-    fn sub_timespec(&self, other: &Timespec) -> Result<Duration, Duration> {\n-        if self >= other {\n-            Ok(if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::new(\n-                    (self.t.tv_sec - other.t.tv_sec) as u64,\n-                    (self.t.tv_nsec - other.t.tv_nsec) as u32,\n-                )\n-            } else {\n-                Duration::new(\n-                    (self.t.tv_sec - 1 - other.t.tv_sec) as u64,\n-                    self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) - other.t.tv_nsec as u32,\n-                )\n-            })\n-        } else {\n-            match other.sub_timespec(self) {\n-                Ok(d) => Err(d),\n-                Err(d) => Ok(d),\n-            }\n-        }\n-    }\n-\n-    fn checked_add_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_add(secs))?;\n-\n-        // Nano calculations can't overflow because nanos are <1B which fit\n-        // in a u32.\n-        let mut nsec = other.subsec_nanos() + self.t.tv_nsec as u32;\n-        if nsec >= NSEC_PER_SEC as u32 {\n-            nsec -= NSEC_PER_SEC as u32;\n-            secs = secs.checked_add(1)?;\n-        }\n-        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n-    }\n-\n-    fn checked_sub_duration(&self, other: &Duration) -> Option<Timespec> {\n-        let mut secs = other\n-            .as_secs()\n-            .try_into() // <- target type would be `libc::time_t`\n-            .ok()\n-            .and_then(|secs| self.t.tv_sec.checked_sub(secs))?;\n-\n-        // Similar to above, nanos can't overflow.\n-        let mut nsec = self.t.tv_nsec as i32 - other.subsec_nanos() as i32;\n-        if nsec < 0 {\n-            nsec += NSEC_PER_SEC as i32;\n-            secs = secs.checked_sub(1)?;\n-        }\n-        Some(Timespec { t: libc::timespec { tv_sec: secs, tv_nsec: nsec as _ } })\n-    }\n-}\n-\n-impl PartialEq for Timespec {\n-    fn eq(&self, other: &Timespec) -> bool {\n-        self.t.tv_sec == other.t.tv_sec && self.t.tv_nsec == other.t.tv_nsec\n-    }\n-}\n-\n-impl Eq for Timespec {}\n-\n-impl PartialOrd for Timespec {\n-    fn partial_cmp(&self, other: &Timespec) -> Option<Ordering> {\n-        Some(self.cmp(other))\n-    }\n-}\n-\n-impl Ord for Timespec {\n-    fn cmp(&self, other: &Timespec) -> Ordering {\n-        let me = (self.t.tv_sec, self.t.tv_nsec);\n-        let other = (other.t.tv_sec, other.t.tv_nsec);\n-        me.cmp(&other)\n-    }\n-}\n-\n-impl Hash for Timespec {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        self.t.tv_sec.hash(state);\n-        self.t.tv_nsec.hash(state);\n-    }\n-}\n-mod inner {\n-    use crate::fmt;\n-    use crate::sys::cvt;\n-    use crate::time::Duration;\n-\n-    use super::Timespec;\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub struct Instant {\n-        t: Timespec,\n-    }\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-    pub struct SystemTime {\n-        t: Timespec,\n-    }\n-\n-    pub const UNIX_EPOCH: SystemTime =\n-        SystemTime { t: Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } } };\n-\n-    impl Instant {\n-        pub fn now() -> Instant {\n-            Instant { t: now(libc::CLOCK_MONOTONIC) }\n-        }\n-\n-        pub const fn zero() -> Instant {\n-            Instant { t: Timespec::zero() }\n-        }\n-\n-        pub fn actually_monotonic() -> bool {\n-            true\n-        }\n-\n-        pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n-            self.t.sub_timespec(&other.t).ok()\n-        }\n-\n-        pub fn checked_add_duration(&self, other: &Duration) -> Option<Instant> {\n-            Some(Instant { t: self.t.checked_add_duration(other)? })\n-        }\n-\n-        pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n-            Some(Instant { t: self.t.checked_sub_duration(other)? })\n-        }\n-    }\n-\n-    impl fmt::Debug for Instant {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"Instant\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-                .finish()\n-        }\n-    }\n-\n-    impl SystemTime {\n-        pub fn now() -> SystemTime {\n-            SystemTime { t: now(libc::CLOCK_REALTIME) }\n-        }\n-\n-        pub fn sub_time(&self, other: &SystemTime) -> Result<Duration, Duration> {\n-            self.t.sub_timespec(&other.t)\n-        }\n-\n-        pub fn checked_add_duration(&self, other: &Duration) -> Option<SystemTime> {\n-            Some(SystemTime { t: self.t.checked_add_duration(other)? })\n-        }\n-\n-        pub fn checked_sub_duration(&self, other: &Duration) -> Option<SystemTime> {\n-            Some(SystemTime { t: self.t.checked_sub_duration(other)? })\n-        }\n-    }\n-\n-    impl From<libc::timespec> for SystemTime {\n-        fn from(t: libc::timespec) -> SystemTime {\n-            SystemTime { t: Timespec { t: t } }\n-        }\n-    }\n-\n-    impl fmt::Debug for SystemTime {\n-        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            f.debug_struct(\"SystemTime\")\n-                .field(\"tv_sec\", &self.t.t.tv_sec)\n-                .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-                .finish()\n-        }\n-    }\n-\n-    pub type clock_t = libc::c_int;\n-\n-    fn now(clock: clock_t) -> Timespec {\n-        let mut t = Timespec { t: libc::timespec { tv_sec: 0, tv_nsec: 0 } };\n-        cvt(unsafe { libc::clock_gettime(clock, &mut t.t) }).unwrap();\n-        t\n-    }\n-}"}]}