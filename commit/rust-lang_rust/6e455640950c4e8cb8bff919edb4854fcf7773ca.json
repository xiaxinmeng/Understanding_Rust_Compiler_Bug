{"sha": "6e455640950c4e8cb8bff919edb4854fcf7773ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNDU1NjQwOTUwYzRlOGNiOGJmZjkxOWVkYjQ4NTRmY2Y3NzczY2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-23T06:14:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-23T06:14:11Z"}, "message": "Auto merge of #31457 - lambda:rtabort-use-libc-abort, r=alexcrichton\n\nUse libc::abort, not intrinsics::abort, in rtabort!\n\nintrinsics::abort compiles down to an illegal instruction, which on\nUnix-like platforms causes the process to be killed with SIGILL.  A more\nappropriate way to kill the process would be SIGABRT; this indicates\nbetter that the runtime has explicitly aborted, rather than some kind of\ncompiler bug or architecture mismatch that SIGILL might indicate.\n\nFor rtassert!, replace this with libc::abort.  libc::abort raises\nSIGABRT, but is defined to do so in such a way that it will terminate\nthe process even if SIGABRT is currently masked or caught by a signal\nhandler that returns.\n\nOn non-Unix platforms, retain the existing behavior.  On Windows we\nprefer to avoid depending on the C runtime, and we need a fallback for\nany other platforms that may be defined.  An alternative on Windows\nwould be to call TerminateProcess, but this seems less essential than\nswitching to using SIGABRT on Unix-like platforms, where it is common\nfor the process-killing signal to be printed out or logged.\n\nThis is a [breaking-change] for any code that depends on the exact\nsignal raised to abort a process via rtabort!\n\ncc #31273\ncc #31333", "tree": {"sha": "72c06cdbaf5c6dc34fc76b0c82c9e8d76a22ec4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72c06cdbaf5c6dc34fc76b0c82c9e8d76a22ec4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e455640950c4e8cb8bff919edb4854fcf7773ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e455640950c4e8cb8bff919edb4854fcf7773ca", "html_url": "https://github.com/rust-lang/rust/commit/6e455640950c4e8cb8bff919edb4854fcf7773ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e455640950c4e8cb8bff919edb4854fcf7773ca/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e24d621fcacf59fa8ecc1c1af1c4adeded4bddee", "url": "https://api.github.com/repos/rust-lang/rust/commits/e24d621fcacf59fa8ecc1c1af1c4adeded4bddee", "html_url": "https://github.com/rust-lang/rust/commit/e24d621fcacf59fa8ecc1c1af1c4adeded4bddee"}, {"sha": "cfc386583291c8868d093d07431a57a20e69c944", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfc386583291c8868d093d07431a57a20e69c944", "html_url": "https://github.com/rust-lang/rust/commit/cfc386583291c8868d093d07431a57a20e69c944"}], "stats": {"total": 29, "additions": 25, "deletions": 4}, "files": [{"sha": "1df511a8818c414849262f14df1926e7e1818741", "filename": "src/libstd/sys/common/util.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e455640950c4e8cb8bff919edb4854fcf7773ca/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e455640950c4e8cb8bff919edb4854fcf7773ca/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Futil.rs?ref=6e455640950c4e8cb8bff919edb4854fcf7773ca", "patch": "@@ -10,7 +10,6 @@\n \n use env;\n use fmt;\n-use intrinsics;\n use io::prelude::*;\n use sync::atomic::{self, Ordering};\n use sys::stdio::Stderr;\n@@ -34,9 +33,32 @@ pub fn dumb_print(args: fmt::Arguments) {\n     let _ = Stderr::new().map(|mut stderr| stderr.write_fmt(args));\n }\n \n+// On Unix-like platforms, libc::abort will unregister signal handlers\n+// including the SIGABRT handler, preventing the abort from being blocked, and\n+// fclose streams, with the side effect of flushing them so libc bufferred\n+// output will be printed.  Additionally the shell will generally print a more\n+// understandable error message like \"Abort trap\" rather than \"Illegal\n+// instruction\" that intrinsics::abort would cause, as intrinsics::abort is\n+// implemented as an illegal instruction.\n+#[cfg(unix)]\n+unsafe fn abort_internal() -> ! {\n+    use libc;\n+    libc::abort()\n+}\n+\n+// On Windows, we want to avoid using libc, and there isn't a direct\n+// equivalent of libc::abort.  The __failfast intrinsic may be a reasonable\n+// substitute, but desireability of using it over the abort instrinsic is\n+// debateable; see https://github.com/rust-lang/rust/pull/31519 for details.\n+#[cfg(not(unix))]\n+unsafe fn abort_internal() -> ! {\n+    use intrinsics;\n+    intrinsics::abort()\n+}\n+\n pub fn abort(args: fmt::Arguments) -> ! {\n     dumb_print(format_args!(\"fatal runtime error: {}\\n\", args));\n-    unsafe { intrinsics::abort(); }\n+    unsafe { abort_internal(); }\n }\n \n #[allow(dead_code)] // stack overflow detection not enabled on all platforms"}, {"sha": "a7748b6d6a2a48569e9a8431faf284c3454e1309", "filename": "src/test/run-pass/out-of-stack.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6e455640950c4e8cb8bff919edb4854fcf7773ca/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e455640950c4e8cb8bff919edb4854fcf7773ca/src%2Ftest%2Frun-pass%2Fout-of-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fout-of-stack.rs?ref=6e455640950c4e8cb8bff919edb4854fcf7773ca", "patch": "@@ -47,8 +47,7 @@ fn check_status(status: std::process::ExitStatus)\n     use std::os::unix::process::ExitStatusExt;\n \n     assert!(!status.success());\n-    assert!(status.signal() != Some(libc::SIGSEGV)\n-            && status.signal() != Some(libc::SIGBUS));\n+    assert_eq!(status.signal(), Some(libc::SIGABRT));\n }\n \n #[cfg(not(unix))]"}]}