{"sha": "2638bec66cb05ff51a0804181a47546a0f55afbf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MzhiZWM2NmNiMDVmZjUxYTA4MDQxODFhNDc1NDZhMGY1NWFmYmY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-04T11:07:44Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-04T11:22:06Z"}, "message": "Merge refs_to_def and process_def", "tree": {"sha": "e34d34c0bba8ccc8f9e70ff3b8d6d9d3cb1a7e41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e34d34c0bba8ccc8f9e70ff3b8d6d9d3cb1a7e41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2638bec66cb05ff51a0804181a47546a0f55afbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2638bec66cb05ff51a0804181a47546a0f55afbf", "html_url": "https://github.com/rust-lang/rust/commit/2638bec66cb05ff51a0804181a47546a0f55afbf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2638bec66cb05ff51a0804181a47546a0f55afbf/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1874b6738ab4b849e5cbcb37fe2019192f950e5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1874b6738ab4b849e5cbcb37fe2019192f950e5e", "html_url": "https://github.com/rust-lang/rust/commit/1874b6738ab4b849e5cbcb37fe2019192f950e5e"}], "stats": {"total": 49, "additions": 20, "deletions": 29}, "files": [{"sha": "ee065b6f917c22936ff657cfbc9c87a8aae5828e", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2638bec66cb05ff51a0804181a47546a0f55afbf/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2638bec66cb05ff51a0804181a47546a0f55afbf/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=2638bec66cb05ff51a0804181a47546a0f55afbf", "patch": "@@ -127,6 +127,8 @@ pub(crate) fn find_refs_to_def(\n     def: &Definition,\n     search_scope: Option<SearchScope>,\n ) -> Vec<Reference> {\n+    let _p = profile(\"find_refs_to_def\");\n+\n     let search_scope = {\n         let base = SearchScope::for_def(&def, db);\n         match search_scope {\n@@ -140,38 +142,10 @@ pub(crate) fn find_refs_to_def(\n         Some(it) => it.to_string(),\n     };\n \n-    process_definition(db, def, name, search_scope)\n-}\n-\n-fn find_name(\n-    sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    position: FilePosition,\n-    opt_name: Option<ast::Name>,\n-) -> Option<RangeInfo<Definition>> {\n-    if let Some(name) = opt_name {\n-        let def = classify_name(sema, &name)?.definition();\n-        let range = name.syntax().text_range();\n-        return Some(RangeInfo::new(range, def));\n-    }\n-    let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n-    let def = classify_name_ref(sema, &name_ref)?.definition();\n-    let range = name_ref.syntax().text_range();\n-    Some(RangeInfo::new(range, def))\n-}\n-\n-fn process_definition(\n-    db: &RootDatabase,\n-    def: &Definition,\n-    name: String,\n-    scope: SearchScope,\n-) -> Vec<Reference> {\n-    let _p = profile(\"process_definition\");\n-\n     let pat = name.as_str();\n     let mut refs = vec![];\n \n-    for (file_id, search_range) in scope {\n+    for (file_id, search_range) in search_scope {\n         let text = db.file_text(file_id);\n         let search_range =\n             search_range.unwrap_or(TextRange::offset_len(0.into(), TextUnit::of_str(&text)));\n@@ -226,6 +200,23 @@ fn process_definition(\n     refs\n }\n \n+fn find_name(\n+    sema: &Semantics<RootDatabase>,\n+    syntax: &SyntaxNode,\n+    position: FilePosition,\n+    opt_name: Option<ast::Name>,\n+) -> Option<RangeInfo<Definition>> {\n+    if let Some(name) = opt_name {\n+        let def = classify_name(sema, &name)?.definition();\n+        let range = name.syntax().text_range();\n+        return Some(RangeInfo::new(range, def));\n+    }\n+    let name_ref = find_node_at_offset::<ast::NameRef>(&syntax, position.offset)?;\n+    let def = classify_name_ref(sema, &name_ref)?.definition();\n+    let range = name_ref.syntax().text_range();\n+    Some(RangeInfo::new(range, def))\n+}\n+\n fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Option<ReferenceAccess> {\n     match def {\n         Definition::Local(_) | Definition::StructField(_) => {}"}]}