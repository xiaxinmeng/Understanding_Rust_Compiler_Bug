{"sha": "7ed71c20e385d193c3bde4bb54c4ae6969ac9615", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZDcxYzIwZTM4NWQxOTNjM2JkZTRiYjU0YzRhZTY5NjlhYzk2MTU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-05T11:13:22Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-05T11:13:22Z"}, "message": "Rollup merge of #32714 - nrc:json-err-end-span, r=sfackler\n\nJSON errors: give better spans for SpanEnd errors", "tree": {"sha": "8dc929a7c4cdd8d70a4ceb013233897a8fbba03c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dc929a7c4cdd8d70a4ceb013233897a8fbba03c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ed71c20e385d193c3bde4bb54c4ae6969ac9615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed71c20e385d193c3bde4bb54c4ae6969ac9615", "html_url": "https://github.com/rust-lang/rust/commit/7ed71c20e385d193c3bde4bb54c4ae6969ac9615", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ed71c20e385d193c3bde4bb54c4ae6969ac9615/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "084d9fa94345c72e450184a0a6e4b46ba95285cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/084d9fa94345c72e450184a0a6e4b46ba95285cd", "html_url": "https://github.com/rust-lang/rust/commit/084d9fa94345c72e450184a0a6e4b46ba95285cd"}, {"sha": "8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2", "html_url": "https://github.com/rust-lang/rust/commit/8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2"}], "stats": {"total": 75, "additions": 60, "deletions": 15}, "files": [{"sha": "f369582bc5c30f674c5a8fe78462ab9345a520d0", "filename": "src/libsyntax/errors/json.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7ed71c20e385d193c3bde4bb54c4ae6969ac9615/src%2Flibsyntax%2Ferrors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed71c20e385d193c3bde4bb54c4ae6969ac9615/src%2Flibsyntax%2Ferrors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fjson.rs?ref=7ed71c20e385d193c3bde4bb54c4ae6969ac9615", "patch": "@@ -20,7 +20,7 @@\n // FIXME spec the JSON output properly.\n \n \n-use codemap::{Span, MultiSpan, CodeMap};\n+use codemap::{self, Span, MultiSpan, CodeMap};\n use diagnostics::registry::Registry;\n use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion};\n use errors::emitter::Emitter;\n@@ -197,8 +197,8 @@ impl DiagnosticSpan {\n \n     fn from_render_span(rsp: &RenderSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n         match *rsp {\n-            // FIXME(#30701) handle Suggestion properly\n             RenderSpan::FullSpan(ref msp) |\n+            // FIXME(#30701) handle Suggestion properly\n             RenderSpan::Suggestion(CodeSuggestion { ref msp, .. }) => {\n                 DiagnosticSpan::from_multispan(msp, je)\n             }\n@@ -207,13 +207,13 @@ impl DiagnosticSpan {\n                     let end = je.cm.lookup_char_pos(span.hi);\n                     DiagnosticSpan {\n                         file_name: end.file.name.clone(),\n-                        byte_start: span.lo.0,\n+                        byte_start: span.hi.0,\n                         byte_end: span.hi.0,\n-                        line_start: 0,\n+                        line_start: end.line,\n                         line_end: end.line,\n-                        column_start: 0,\n+                        column_start: end.col.0 + 1,\n                         column_end: end.col.0 + 1,\n-                        text: DiagnosticSpanLine::from_span(span, je),\n+                        text: DiagnosticSpanLine::from_span_end(span, je),\n                     }\n                 }).collect()\n             }\n@@ -237,25 +237,70 @@ impl DiagnosticSpan {\n     }\n }\n \n-impl DiagnosticSpanLine {\n-    fn from_span(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n-        let lines = match je.cm.span_to_lines(*span) {\n+macro_rules! get_lines_for_span {\n+    ($span: ident, $je: ident) => {\n+        match $je.cm.span_to_lines(*$span) {\n             Ok(lines) => lines,\n             Err(_) => {\n                 debug!(\"unprintable span\");\n                 return Vec::new();\n             }\n-        };\n+        }\n+    }\n+}\n+\n+impl DiagnosticSpanLine {\n+    fn line_from_filemap(fm: &codemap::FileMap,\n+                         index: usize,\n+                         h_start: usize,\n+                         h_end: usize)\n+                         -> DiagnosticSpanLine {\n+        DiagnosticSpanLine {\n+            text: fm.get_line(index).unwrap().to_owned(),\n+            highlight_start: h_start,\n+            highlight_end: h_end,\n+        }\n+    }\n+\n+    /// Create a list of DiagnosticSpanLines from span - each line with any part\n+    /// of `span` gets a DiagnosticSpanLine, with the highlight indicating the\n+    /// `span` within the line.\n+    fn from_span(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        let lines = get_lines_for_span!(span, je);\n \n         let mut result = Vec::new();\n         let fm = &*lines.file;\n \n         for line in &lines.lines {\n-            result.push(DiagnosticSpanLine {\n-                text: fm.get_line(line.line_index).unwrap().to_owned(),\n-                highlight_start: line.start_col.0 + 1,\n-                highlight_end: line.end_col.0 + 1,\n-            });\n+            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n+                                                              line.line_index,\n+                                                              line.start_col.0 + 1,\n+                                                              line.end_col.0 + 1));\n+        }\n+\n+        result\n+    }\n+\n+    /// Create a list of DiagnosticSpanLines from span - the result covers all\n+    /// of `span`, but the highlight is zero-length and at the end of `span`.\n+    fn from_span_end(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        let lines = get_lines_for_span!(span, je);\n+\n+        let mut result = Vec::new();\n+        let fm = &*lines.file;\n+\n+        for (i, line) in lines.lines.iter().enumerate() {\n+            // Invariant - CodeMap::span_to_lines will not return extra context\n+            // lines - the last line returned is the last line of `span`.\n+            let highlight = if i == lines.lines.len() - 1 {\n+                (line.end_col.0 + 1, line.end_col.0 + 1)\n+            } else {\n+                (0, 0)\n+            };\n+            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n+                                                              line.line_index,\n+                                                              highlight.0,\n+                                                              highlight.1));\n         }\n \n         result"}]}