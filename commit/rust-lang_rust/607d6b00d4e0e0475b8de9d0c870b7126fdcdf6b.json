{"sha": "607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwN2Q2YjAwZDRlMGUwNDc1YjhkZTlkMGM4NzBiNzEyNmZkY2RmNmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-15T20:15:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-15T20:15:23Z"}, "message": "Auto merge of #86321 - JohnTitor:rollup-q61c8q4, r=JohnTitor\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #80269 (Explain non-dropped sender recv in docs)\n - #82179 (Add functions `Duration::try_from_secs_{f32, f64}`)\n - #85608 (Stabilize `ops::ControlFlow` (just the type))\n - #85792 (Refactor windows sockets impl methods)\n - #86220 (Improve maybe_uninit_extra docs)\n - #86277 (Remove must_use from ALLOWED_ATTRIBUTES)\n - #86285 (:arrow_up: rust-analyzer)\n - #86294 (Stabilize {std, core}::prelude::rust_*.)\n - #86306 (Add mailmap entries for myself)\n - #86314 (Remove trailing triple backticks in `mut_keyword` docs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e32f610c6985de82f3f7076e4239c9b2f55e353d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e32f610c6985de82f3f7076e4239c9b2f55e353d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "html_url": "https://github.com/rust-lang/rust/commit/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "246571a846e29691bd535d531365acd318857207", "url": "https://api.github.com/repos/rust-lang/rust/commits/246571a846e29691bd535d531365acd318857207", "html_url": "https://github.com/rust-lang/rust/commit/246571a846e29691bd535d531365acd318857207"}, {"sha": "74cc63a7a5ded7c4c0e12cd5e4dc4838be914b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/74cc63a7a5ded7c4c0e12cd5e4dc4838be914b78", "html_url": "https://github.com/rust-lang/rust/commit/74cc63a7a5ded7c4c0e12cd5e4dc4838be914b78"}], "stats": {"total": 762, "additions": 501, "deletions": 261}, "files": [{"sha": "8cb74824d939a0f50f143ecd270dd6838ab2e638", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -166,6 +166,8 @@ lcnr <bastian_kauschke@hotmail.de>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n Lennart Kudling <github@kudling.de>\n+L\u00e9o Lanteri Thauvin <leseulartichaut@gmail.com>\n+L\u00e9o Lanteri Thauvin <leseulartichaut@gmail.com> <38361244+LeSeulArtichaut@users.noreply.github.com>\n L\u00e9o Testard <leo.testard@gmail.com>\n Lindsey Kuper <lindsey@composition.al> <lindsey@rockstargirl.org>\n Lindsey Kuper <lindsey@composition.al> <lkuper@mozilla.com>"}, {"sha": "9592c1d2fabff80cf37f5564f3d6180b2e501ecd", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -331,7 +331,7 @@ pub fn lower_crate<'a, 'hir>(\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n         in_scope_lifetimes: Vec::new(),\n-        allow_try_trait: Some([sym::control_flow_enum, sym::try_trait_v2][..].into()),\n+        allow_try_trait: Some([sym::try_trait_v2][..].into()),\n         allow_gen_future: Some([sym::gen_future][..].into()),\n     }\n     .lower_crate(krate)"}, {"sha": "00f0fe4a2889413dddd5fc6933cb17637378e658", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -11,7 +11,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(box_patterns)]\n #![feature(bool_to_option)]\n-#![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(format_args_capture)]\n #![feature(iter_zip)]"}, {"sha": "a96d37c652d12a94c14376256f1be5e2c5dd22dc", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -416,7 +416,6 @@ symbols! {\n         constructor,\n         contents,\n         context,\n-        control_flow_enum,\n         convert,\n         copy,\n         copy_closures,"}, {"sha": "d0b05beb4e63c86ee9ea23d25931a4a5c715acfc", "filename": "compiler/rustc_traits/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/compiler%2Frustc_traits%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Flib.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -4,7 +4,6 @@\n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n-#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "78d317096b4f6ee85df8490c138faa16c8711fa9", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -1959,6 +1959,31 @@ pub trait Iterator {\n     /// assert_eq!(it.len(), 2);\n     /// assert_eq!(it.next(), Some(&40));\n     /// ```\n+    ///\n+    /// While you cannot `break` from a closure, the [`crate::ops::ControlFlow`]\n+    /// type allows a similar idea:\n+    ///\n+    /// ```\n+    /// use std::ops::ControlFlow;\n+    ///\n+    /// let triangular = (1..30).try_fold(0_i8, |prev, x| {\n+    ///     if let Some(next) = prev.checked_add(x) {\n+    ///         ControlFlow::Continue(next)\n+    ///     } else {\n+    ///         ControlFlow::Break(prev)\n+    ///     }\n+    /// });\n+    /// assert_eq!(triangular, ControlFlow::Break(120));\n+    ///\n+    /// let triangular = (1..30).try_fold(0_u64, |prev, x| {\n+    ///     if let Some(next) = prev.checked_add(x) {\n+    ///         ControlFlow::Continue(next)\n+    ///     } else {\n+    ///         ControlFlow::Break(prev)\n+    ///     }\n+    /// });\n+    /// assert_eq!(triangular, ControlFlow::Continue(435));\n+    /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n     fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n@@ -2001,6 +2026,22 @@ pub trait Iterator {\n     /// // It short-circuited, so the remaining items are still in the iterator:\n     /// assert_eq!(it.next(), Some(\"stale_bread.json\"));\n     /// ```\n+    ///\n+    /// The [`crate::ops::ControlFlow`] type can be used with this method for the\n+    /// situations in which you'd use `break` and `continue` in a normal loop:\n+    ///\n+    /// ```\n+    /// use std::ops::ControlFlow;\n+    ///\n+    /// let r = (2..100).try_for_each(|x| {\n+    ///     if 323 % x == 0 {\n+    ///         return ControlFlow::Break(x)\n+    ///     }\n+    ///\n+    ///     ControlFlow::Continue(())\n+    /// });\n+    /// assert_eq!(r, ControlFlow::Break(17));\n+    /// ```\n     #[inline]\n     #[stable(feature = \"iterator_try_fold\", since = \"1.27.0\")]\n     fn try_for_each<F, R>(&mut self, f: F) -> R"}, {"sha": "de3367e5e5297b4c3be10f207d19dde5cc8eb577", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 67, "deletions": 13, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -402,10 +402,60 @@ impl<T> MaybeUninit<T> {\n         u\n     }\n \n-    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n-    /// without dropping it, so be careful not to use this twice unless you want to\n-    /// skip running the destructor. For your convenience, this also returns a mutable\n-    /// reference to the (now safely initialized) contents of `self`.\n+    /// Sets the value of the `MaybeUninit<T>`.\n+    ///\n+    /// This overwrites any previous value without dropping it, so be careful\n+    /// not to use this twice unless you want to skip running the destructor.\n+    /// For your convenience, this also returns a mutable reference to the\n+    /// (now safely initialized) contents of `self`.\n+    ///\n+    /// As the content is stored inside a `MaybeUninit`, the destructor is not\n+    /// ran for the inner data if the MaybeUninit leaves scope without a call to\n+    /// [`assume_init`], [`assume_init_drop`], or similar. Code that receives\n+    /// the mutable reference returned by this function needs to keep this in\n+    /// mind. The safety model of Rust regards leaks as safe, but they are\n+    /// usually still undesirable. This being said, the mutable reference\n+    /// behaves like any other mutable reference would, so assigning a new value\n+    /// to it will drop the old content.\n+    ///\n+    /// [`assume_init`]: Self::assume_init\n+    /// [`assume_init_drop`]: Self::assume_init_drop\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u8>>::uninit();\n+    ///\n+    /// {\n+    ///     let hello = x.write((&b\"Hello, world!\").to_vec());\n+    ///     // Setting hello does not leak prior allocations, but drops them\n+    ///     *hello = (&b\"Hello\").to_vec();\n+    ///     hello[0] = 'h' as u8;\n+    /// }\n+    /// // x is initialized now:\n+    /// let s = unsafe { x.assume_init() };\n+    /// assert_eq!(b\"hello\", s.as_slice());\n+    /// ```\n+    ///\n+    /// This usage of the method causes a leak:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<String>::uninit();\n+    ///\n+    /// x.write(\"Hello\".to_string());\n+    /// // This leaks the contained string:\n+    /// x.write(\"hello\".to_string());\n+    /// // x is initialized now:\n+    /// let s = unsafe { x.assume_init() };\n+    /// ```\n     #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[rustc_const_unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n@@ -564,9 +614,11 @@ impl<T> MaybeUninit<T> {\n     /// behavior. The [type-level documentation][inv] contains more information about\n     /// this initialization invariant.\n     ///\n-    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n-    /// multiple copies of the data (by calling `assume_init_read` multiple times, or first\n-    /// calling `assume_init_read` and then [`assume_init`]), it is your responsibility\n+    /// Moreover, similar to the [`ptr::read`] function, this function creates a\n+    /// bitwise copy of the contents, regardless whether the contained type\n+    /// implements the [`Copy`] trait or not. When using multiple copies of the\n+    /// data (by calling `assume_init_read` multiple times, or first calling\n+    /// `assume_init_read` and then [`assume_init`]), it is your responsibility\n     /// to ensure that that data may indeed be duplicated.\n     ///\n     /// [inv]: #initialization-invariant\n@@ -622,7 +674,8 @@ impl<T> MaybeUninit<T> {\n \n     /// Drops the contained value in place.\n     ///\n-    /// If you have ownership of the `MaybeUninit`, you can use [`assume_init`] instead.\n+    /// If you have ownership of the `MaybeUninit`, you can also use\n+    /// [`assume_init`] as an alternative.\n     ///\n     /// # Safety\n     ///\n@@ -632,11 +685,12 @@ impl<T> MaybeUninit<T> {\n     ///\n     /// On top of that, all additional invariants of the type `T` must be\n     /// satisfied, as the `Drop` implementation of `T` (or its members) may\n-    /// rely on this. For example, a `1`-initialized [`Vec<T>`] is considered\n-    /// initialized (under the current implementation; this does not constitute\n-    /// a stable guarantee) because the only requirement the compiler knows\n-    /// about it is that the data pointer must be non-null. Dropping such a\n-    /// `Vec<T>` however will cause undefined behaviour.\n+    /// rely on this. For example, setting a [`Vec<T>`] to an invalid but\n+    /// non-null address makes it initialized (under the current implementation;\n+    /// this does not constitute a stable guarantee), because the only\n+    /// requirement the compiler knows about it is that the data pointer must be\n+    /// non-null. Dropping such a `Vec<T>` however will cause undefined\n+    /// behaviour.\n     ///\n     /// [`assume_init`]: MaybeUninit::assume_init\n     /// [`Vec<T>`]: ../../std/vec/struct.Vec.html"}, {"sha": "c26b5c677105b54389c2b20513e0641f2631b496", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -11,7 +11,6 @@ use crate::{convert, ops};\n ///\n /// Early-exiting from [`Iterator::try_for_each`]:\n /// ```\n-/// #![feature(control_flow_enum)]\n /// use std::ops::ControlFlow;\n ///\n /// let r = (2..100).try_for_each(|x| {\n@@ -26,7 +25,6 @@ use crate::{convert, ops};\n ///\n /// A basic tree traversal:\n /// ```no_run\n-/// #![feature(control_flow_enum)]\n /// use std::ops::ControlFlow;\n ///\n /// pub struct TreeNode<T> {\n@@ -48,13 +46,15 @@ use crate::{convert, ops};\n ///     }\n /// }\n /// ```\n-#[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+#[stable(feature = \"control_flow_enum_type\", since = \"1.55.0\")]\n #[derive(Debug, Clone, Copy, PartialEq)]\n pub enum ControlFlow<B, C = ()> {\n     /// Move on to the next phase of the operation as normal.\n+    #[stable(feature = \"control_flow_enum_type\", since = \"1.55.0\")]\n     #[cfg_attr(not(bootstrap), lang = \"Continue\")]\n     Continue(C),\n     /// Exit the operation without running subsequent phases.\n+    #[stable(feature = \"control_flow_enum_type\", since = \"1.55.0\")]\n     #[cfg_attr(not(bootstrap), lang = \"Break\")]\n     Break(B),\n     // Yes, the order of the variants doesn't match the type parameters."}, {"sha": "0eec52a8701c7dbaa4cf4cd118f75cd724d1b1af", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -55,7 +55,6 @@ use crate::ops::ControlFlow;\n /// into the return type using [`Try::from_output`]:\n /// ```\n /// # #![feature(try_trait_v2)]\n-/// # #![feature(control_flow_enum)]\n /// # use std::ops::{ControlFlow, Try};\n /// fn simple_try_fold_2<A, T, R: Try<Output = A>>(\n ///     iter: impl Iterator<Item = T>,\n@@ -79,7 +78,6 @@ use crate::ops::ControlFlow;\n /// recreated from their corresponding residual, so we'll just call it:\n /// ```\n /// # #![feature(try_trait_v2)]\n-/// # #![feature(control_flow_enum)]\n /// # use std::ops::{ControlFlow, Try};\n /// pub fn simple_try_fold_3<A, T, R: Try<Output = A>>(\n ///     iter: impl Iterator<Item = T>,\n@@ -170,7 +168,6 @@ pub trait Try: FromResidual {\n     ///\n     /// ```\n     /// #![feature(try_trait_v2)]\n-    /// #![feature(control_flow_enum)]\n     /// use std::ops::Try;\n     ///\n     /// assert_eq!(<Result<_, String> as Try>::from_output(3), Ok(3));\n@@ -202,7 +199,6 @@ pub trait Try: FromResidual {\n     ///\n     /// ```\n     /// #![feature(try_trait_v2)]\n-    /// #![feature(control_flow_enum)]\n     /// use std::ops::{ControlFlow, Try};\n     ///\n     /// assert_eq!(Ok::<_, String>(3).branch(), ControlFlow::Continue(3));\n@@ -329,7 +325,6 @@ pub trait FromResidual<R = <Self as Try>::Residual> {\n     ///\n     /// ```\n     /// #![feature(try_trait_v2)]\n-    /// #![feature(control_flow_enum)]\n     /// use std::ops::{ControlFlow, FromResidual};\n     ///\n     /// assert_eq!(Result::<String, i64>::from_residual(Err(3_u8)), Err(3));"}, {"sha": "ccd36a428e29679bc766ff5008bc8c8d6d32919e", "filename": "library/core/src/prelude/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprelude%2Fmod.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -11,37 +11,37 @@ pub mod v1;\n /// The 2015 version of the core prelude.\n ///\n /// See the [module-level documentation](self) for more.\n-#[unstable(feature = \"prelude_2015\", issue = \"85684\")]\n+#[stable(feature = \"prelude_2015\", since = \"1.55.0\")]\n pub mod rust_2015 {\n-    #[unstable(feature = \"prelude_2015\", issue = \"85684\")]\n+    #[stable(feature = \"prelude_2015\", since = \"1.55.0\")]\n     #[doc(no_inline)]\n     pub use super::v1::*;\n }\n \n /// The 2018 version of the core prelude.\n ///\n /// See the [module-level documentation](self) for more.\n-#[unstable(feature = \"prelude_2018\", issue = \"85684\")]\n+#[stable(feature = \"prelude_2018\", since = \"1.55.0\")]\n pub mod rust_2018 {\n-    #[unstable(feature = \"prelude_2018\", issue = \"85684\")]\n+    #[stable(feature = \"prelude_2018\", since = \"1.55.0\")]\n     #[doc(no_inline)]\n     pub use super::v1::*;\n }\n \n /// The 2021 version of the core prelude.\n ///\n /// See the [module-level documentation](self) for more.\n-#[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n+#[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\n pub mod rust_2021 {\n-    #[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n+    #[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\n     #[doc(no_inline)]\n     pub use super::v1::*;\n \n-    #[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n+    #[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\n     #[doc(no_inline)]\n     pub use crate::iter::FromIterator;\n \n-    #[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n+    #[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\n     #[doc(no_inline)]\n     pub use crate::convert::{TryFrom, TryInto};\n }"}, {"sha": "92a4e6039189442190d56247bb0b6dcda7876ef7", "filename": "library/core/src/time.rs", "status": "modified", "additions": 128, "deletions": 24, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -687,21 +687,47 @@ impl Duration {\n     #[inline]\n     #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n     pub const fn from_secs_f64(secs: f64) -> Duration {\n+        match Duration::try_from_secs_f64(secs) {\n+            Ok(v) => v,\n+            Err(e) => crate::panicking::panic(e.description()),\n+        }\n+    }\n+\n+    /// The checked version of [`from_secs_f64`].\n+    ///\n+    /// [`from_secs_f64`]: Duration::from_secs_f64\n+    ///\n+    /// This constructor will return an `Err` if `secs` is not finite, negative or overflows `Duration`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_checked_float)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::try_from_secs_f64(2.7);\n+    /// assert_eq!(dur, Ok(Duration::new(2, 700_000_000)));\n+    ///\n+    /// let negative = Duration::try_from_secs_f64(-5.0);\n+    /// assert!(negative.is_err());\n+    /// ```\n+    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n+    #[inline]\n+    pub const fn try_from_secs_f64(secs: f64) -> Result<Duration, FromSecsError> {\n         const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f64;\n         let nanos = secs * (NANOS_PER_SEC as f64);\n         if !nanos.is_finite() {\n-            panic!(\"got non-finite value when converting float to duration\");\n-        }\n-        if nanos >= MAX_NANOS_F64 {\n-            panic!(\"overflow when converting float to duration\");\n-        }\n-        if nanos < 0.0 {\n-            panic!(\"underflow when converting float to duration\");\n-        }\n-        let nanos = nanos as u128;\n-        Duration {\n-            secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n-            nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n+            Err(FromSecsError { kind: FromSecsErrorKind::NonFinite })\n+        } else if nanos >= MAX_NANOS_F64 {\n+            Err(FromSecsError { kind: FromSecsErrorKind::Overflow })\n+        } else if nanos < 0.0 {\n+            Err(FromSecsError { kind: FromSecsErrorKind::Underflow })\n+        } else {\n+            let nanos = nanos as u128;\n+            Ok(Duration {\n+                secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n+                nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n+            })\n         }\n     }\n \n@@ -722,21 +748,47 @@ impl Duration {\n     #[inline]\n     #[rustc_const_unstable(feature = \"duration_consts_2\", issue = \"72440\")]\n     pub const fn from_secs_f32(secs: f32) -> Duration {\n+        match Duration::try_from_secs_f32(secs) {\n+            Ok(v) => v,\n+            Err(e) => crate::panicking::panic(e.description()),\n+        }\n+    }\n+\n+    /// The checked version of [`from_secs_f32`].\n+    ///\n+    /// [`from_secs_f32`]: Duration::from_secs_f32\n+    ///\n+    /// This constructor will return an `Err` if `secs` is not finite, negative or overflows `Duration`.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_checked_float)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// let dur = Duration::try_from_secs_f32(2.7);\n+    /// assert_eq!(dur, Ok(Duration::new(2, 700_000_000)));\n+    ///\n+    /// let negative = Duration::try_from_secs_f32(-5.0);\n+    /// assert!(negative.is_err());\n+    /// ```\n+    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n+    #[inline]\n+    pub const fn try_from_secs_f32(secs: f32) -> Result<Duration, FromSecsError> {\n         const MAX_NANOS_F32: f32 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f32;\n         let nanos = secs * (NANOS_PER_SEC as f32);\n         if !nanos.is_finite() {\n-            panic!(\"got non-finite value when converting float to duration\");\n-        }\n-        if nanos >= MAX_NANOS_F32 {\n-            panic!(\"overflow when converting float to duration\");\n-        }\n-        if nanos < 0.0 {\n-            panic!(\"underflow when converting float to duration\");\n-        }\n-        let nanos = nanos as u128;\n-        Duration {\n-            secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n-            nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n+            Err(FromSecsError { kind: FromSecsErrorKind::NonFinite })\n+        } else if nanos >= MAX_NANOS_F32 {\n+            Err(FromSecsError { kind: FromSecsErrorKind::Overflow })\n+        } else if nanos < 0.0 {\n+            Err(FromSecsError { kind: FromSecsErrorKind::Underflow })\n+        } else {\n+            let nanos = nanos as u128;\n+            Ok(Duration {\n+                secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n+                nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n+            })\n         }\n     }\n \n@@ -1099,3 +1151,55 @@ impl fmt::Debug for Duration {\n         }\n     }\n }\n+\n+/// An error which can be returned when converting a floating-point value of seconds\n+/// into a [`Duration`].\n+///\n+/// This error is used as the error type for [`Duration::try_from_secs_f32`] and\n+/// [`Duration::try_from_secs_f64`].\n+///\n+/// # Example\n+///\n+/// ```\n+/// #![feature(duration_checked_float)]\n+///\n+/// use std::time::Duration;\n+///\n+/// if let Err(e) = Duration::try_from_secs_f32(-1.0) {\n+///     println!(\"Failed conversion to Duration: {}\", e);\n+/// }\n+/// ```\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+#[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n+pub struct FromSecsError {\n+    kind: FromSecsErrorKind,\n+}\n+\n+impl FromSecsError {\n+    const fn description(&self) -> &'static str {\n+        match self.kind {\n+            FromSecsErrorKind::NonFinite => {\n+                \"got non-finite value when converting float to duration\"\n+            }\n+            FromSecsErrorKind::Overflow => \"overflow when converting float to duration\",\n+            FromSecsErrorKind::Underflow => \"underflow when converting float to duration\",\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n+impl fmt::Display for FromSecsError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self.description(), f)\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+enum FromSecsErrorKind {\n+    // Value is not a finite value (either infinity or NaN).\n+    NonFinite,\n+    // Value is too large to store in a `Duration`.\n+    Overflow,\n+    // Value is less than `0.0`.\n+    Underflow,\n+}"}, {"sha": "65fca67b4f290760deea01fc84cdbfc7becd3e10", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -15,7 +15,6 @@\n #![feature(const_ptr_read)]\n #![feature(const_ptr_write)]\n #![feature(const_ptr_offset)]\n-#![feature(control_flow_enum)]\n #![feature(core_intrinsics)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]"}, {"sha": "ec9f012295000902e044f21c4ef7900d52adf4e0", "filename": "library/std/src/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -597,6 +597,9 @@ impl Error for char::ParseCharError {\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue = \"48043\")]\n impl Error for alloc::collections::TryReserveError {}\n \n+#[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n+impl Error for core::time::FromSecsError {}\n+\n // Copied from `any.rs`.\n impl dyn Error + 'static {\n     /// Returns `true` if the boxed type is the same as `T`"}, {"sha": "c2d21ad23ac192a08d5778205e0d3da676bc5c99", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -1092,8 +1092,7 @@ mod move_keyword {}\n /// Mutable raw pointers work much like mutable references, with the added\n /// possibility of not pointing to a valid object. The syntax is `*mut Type`.\n ///\n-/// More information on mutable references and pointers can be found in```\n-/// [Reference].\n+/// More information on mutable references and pointers can be found in the [Reference].\n ///\n /// [Reference]: ../reference/types/pointer.html#mutable-references-mut\n mod mut_keyword {}"}, {"sha": "6b2f49cfe48c9543a78c5a907dcbd4e3b9493095", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -261,6 +261,7 @@\n #![feature(doc_masked)]\n #![feature(doc_notable_trait)]\n #![feature(dropck_eyepatch)]\n+#![feature(duration_checked_float)]\n #![feature(duration_constants)]\n #![feature(edition_panic)]\n #![feature(exact_size_is_empty)]\n@@ -301,7 +302,6 @@\n #![feature(panic_internals)]\n #![feature(panic_unwind)]\n #![feature(pin_static_ref)]\n-#![feature(prelude_2021)]\n #![feature(prelude_import)]\n #![feature(ptr_internals)]\n #![feature(raw)]"}, {"sha": "d4bf6aeefee57279bdf2375969bab5efd6949bdf", "filename": "library/std/src/prelude/mod.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprelude%2Fmod.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -25,8 +25,10 @@\n //!\n //! # Prelude contents\n //!\n-//! The current version of the prelude (version 1) lives in\n-//! [`std::prelude::v1`], and re-exports the following:\n+//! The first version of the prelude is used in Rust 2015 and Rust 2018,\n+//! and lives in [`std::prelude::v1`].\n+//! [`std::prelude::rust_2015`] and [`std::prelude::rust_2018`] re-export this prelude.\n+//! It re-exports the following:\n //!\n //! * <code>[std::marker]::{[Copy], [Send], [Sized], [Sync], [Unpin]}</code>,\n //!   marker traits that indicate fundamental properties of types.\n@@ -58,6 +60,12 @@\n //! * <code>[std::string]::{[String], [ToString]}</code>, heap-allocated strings.\n //! * <code>[std::vec]::[Vec]</code>, a growable, heap-allocated vector.\n //!\n+//! The prelude used in Rust 2021, [`std::prelude::rust_2021`], includes all of the above,\n+//! and in addition re-exports:\n+//!\n+//! * <code>[std::convert]::{[TryFrom], [TryInto]}</code>,\n+//! * <code>[std::iter]::[FromIterator]</code>.\n+//!\n //! [mem::drop]: crate::mem::drop\n //! [std::borrow]: crate::borrow\n //! [std::boxed]: crate::boxed\n@@ -71,10 +79,16 @@\n //! [std::ops]: crate::ops\n //! [std::option]: crate::option\n //! [`std::prelude::v1`]: v1\n+//! [`std::prelude::rust_2015`]: rust_2015\n+//! [`std::prelude::rust_2018`]: rust_2018\n+//! [`std::prelude::rust_2021`]: rust_2021\n //! [std::result]: crate::result\n //! [std::slice]: crate::slice\n //! [std::string]: crate::string\n //! [std::vec]: mod@crate::vec\n+//! [TryFrom]: crate::convert::TryFrom\n+//! [TryInto]: crate::convert::TryInto\n+//! [FromIterator]: crate::iter::FromIterator\n //! [`to_owned`]: crate::borrow::ToOwned::to_owned\n //! [book-closures]: ../../book/ch13-01-closures.html\n //! [book-dtor]: ../../book/ch15-03-drop.html\n@@ -88,33 +102,33 @@ pub mod v1;\n /// The 2015 version of the prelude of The Rust Standard Library.\n ///\n /// See the [module-level documentation](self) for more.\n-#[unstable(feature = \"prelude_2015\", issue = \"85684\")]\n+#[stable(feature = \"prelude_2015\", since = \"1.55.0\")]\n pub mod rust_2015 {\n-    #[unstable(feature = \"prelude_2015\", issue = \"85684\")]\n+    #[stable(feature = \"prelude_2015\", since = \"1.55.0\")]\n     #[doc(no_inline)]\n     pub use super::v1::*;\n }\n \n /// The 2018 version of the prelude of The Rust Standard Library.\n ///\n /// See the [module-level documentation](self) for more.\n-#[unstable(feature = \"prelude_2018\", issue = \"85684\")]\n+#[stable(feature = \"prelude_2018\", since = \"1.55.0\")]\n pub mod rust_2018 {\n-    #[unstable(feature = \"prelude_2018\", issue = \"85684\")]\n+    #[stable(feature = \"prelude_2018\", since = \"1.55.0\")]\n     #[doc(no_inline)]\n     pub use super::v1::*;\n }\n \n /// The 2021 version of the prelude of The Rust Standard Library.\n ///\n /// See the [module-level documentation](self) for more.\n-#[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n+#[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\n pub mod rust_2021 {\n-    #[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n+    #[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\n     #[doc(no_inline)]\n     pub use super::v1::*;\n \n-    #[unstable(feature = \"prelude_2021\", issue = \"85684\")]\n+    #[stable(feature = \"prelude_2021\", since = \"1.55.0\")]\n     #[doc(no_inline)]\n     pub use core::prelude::rust_2021::*;\n }"}, {"sha": "b4f4456537b9693f41b56df9208e5588ce4f88ab", "filename": "library/std/src/sync/mpsc/mod.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fmpsc%2Fmod.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -105,6 +105,35 @@\n //! });\n //! rx.recv().unwrap();\n //! ```\n+//!\n+//! Unbounded receive loop:\n+//!\n+//! ```\n+//! use std::sync::mpsc::sync_channel;\n+//! use std::thread;\n+//!\n+//! let (tx, rx) = sync_channel(3);\n+//!\n+//! for _ in 0..3 {\n+//!     // It would be the same without thread and clone here\n+//!     // since there will still be one `tx` left.\n+//!     let tx = tx.clone();\n+//!     // cloned tx dropped within thread\n+//!     thread::spawn(move || tx.send(\"ok\").unwrap());\n+//! }\n+//!\n+//! // Drop the last sender to stop `rx` waiting for message.\n+//! // The program will not complete if we comment this out.\n+//! // **All** `tx` needs to be dropped for `rx` to have `Err`.\n+//! drop(tx);\n+//!\n+//! // Unbounded receiver waiting for all senders to complete.\n+//! while let Ok(msg) = rx.recv() {\n+//!     println!(\"{}\", msg);\n+//! }\n+//!\n+//! println!(\"completed\");\n+//! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -437,6 +466,9 @@ pub struct IntoIter<T> {\n ///\n /// Messages can be sent through this channel with [`send`].\n ///\n+/// Note: all senders (the original and the clones) need to be dropped for the receiver\n+/// to stop blocking to receive messages with [`Receiver::recv`].\n+///\n /// [`send`]: Sender::send\n ///\n /// # Examples\n@@ -643,7 +675,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// the same order as it was sent, and no [`send`] will block the calling thread\n /// (this channel has an \"infinite buffer\", unlike [`sync_channel`], which will\n /// block after its buffer limit is reached). [`recv`] will block until a message\n-/// is available.\n+/// is available while there is at least one [`Sender`] alive (including clones).\n ///\n /// The [`Sender`] can be cloned to [`send`] to the same channel multiple times, but\n /// only one [`Receiver`] is supported.\n@@ -806,6 +838,11 @@ impl<T> Sender<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Sender<T> {\n+    /// Clone a sender to send to other threads.\n+    ///\n+    /// Note, be aware of the lifetime of the sender because all senders\n+    /// (including the original) need to be dropped in order for\n+    /// [`Receiver::recv`] to stop blocking.\n     fn clone(&self) -> Sender<T> {\n         let packet = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n@@ -1064,9 +1101,10 @@ impl<T> Receiver<T> {\n     /// corresponding channel has hung up.\n     ///\n     /// This function will always block the current thread if there is no data\n-    /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n-    /// receiver will wake up and return that message.\n+    /// available and it's possible for more data to be sent (at least one sender\n+    /// still exists). Once a message is sent to the corresponding [`Sender`]\n+    /// (or [`SyncSender`]), this receiver will wake up and return that\n+    /// message.\n     ///\n     /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n     /// this call is blocking, this call will wake up and return [`Err`] to\n@@ -1146,9 +1184,10 @@ impl<T> Receiver<T> {\n     /// corresponding channel has hung up, or if it waits more than `timeout`.\n     ///\n     /// This function will always block the current thread if there is no data\n-    /// available and it's possible for more data to be sent. Once a message is\n-    /// sent to the corresponding [`Sender`] (or [`SyncSender`]), then this\n-    /// receiver will wake up and return that message.\n+    /// available and it's possible for more data to be sent (at least one sender\n+    /// still exists). Once a message is sent to the corresponding [`Sender`]\n+    /// (or [`SyncSender`]), this receiver will wake up and return that\n+    /// message.\n     ///\n     /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n     /// this call is blocking, this call will wake up and return [`Err`] to"}, {"sha": "b64870401f1fdbe808b97ed2a58fa1a7b6d6e41d", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -234,6 +234,7 @@ pub const SD_RECEIVE: c_int = 0;\n pub const SD_SEND: c_int = 1;\n pub const SOCK_DGRAM: c_int = 2;\n pub const SOCK_STREAM: c_int = 1;\n+pub const SOCKET_ERROR: c_int = -1;\n pub const SOL_SOCKET: c_int = 0xffff;\n pub const SO_RCVTIMEO: c_int = 0x1006;\n pub const SO_SNDTIMEO: c_int = 0x1005;"}, {"sha": "9cea5c5e63a2df56ec4caed7be741e70c785570f", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 172, "deletions": 133, "changes": 305, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -12,7 +12,7 @@ use crate::sys_common::net;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n-use libc::{c_int, c_long, c_ulong, c_void};\n+use libc::{c_int, c_long, c_ulong};\n \n pub type wrlen_t = i32;\n \n@@ -93,153 +93,177 @@ where\n \n impl Socket {\n     pub fn new(addr: &SocketAddr, ty: c_int) -> io::Result<Socket> {\n-        let fam = match *addr {\n+        let family = match *addr {\n             SocketAddr::V4(..) => c::AF_INET,\n             SocketAddr::V6(..) => c::AF_INET6,\n         };\n         let socket = unsafe {\n-            match c::WSASocketW(\n-                fam,\n+            c::WSASocketW(\n+                family,\n                 ty,\n                 0,\n                 ptr::null_mut(),\n                 0,\n                 c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n-            ) {\n-                c::INVALID_SOCKET => match c::WSAGetLastError() {\n-                    c::WSAEPROTOTYPE | c::WSAEINVAL => {\n-                        match c::WSASocketW(fam, ty, 0, ptr::null_mut(), 0, c::WSA_FLAG_OVERLAPPED)\n-                        {\n-                            c::INVALID_SOCKET => Err(last_error()),\n-                            n => {\n-                                let s = Socket(n);\n-                                s.set_no_inherit()?;\n-                                Ok(s)\n-                            }\n-                        }\n-                    }\n-                    n => Err(io::Error::from_raw_os_error(n)),\n-                },\n-                n => Ok(Socket(n)),\n+            )\n+        };\n+\n+        if socket != c::INVALID_SOCKET {\n+            Ok(Self(socket))\n+        } else {\n+            let error = unsafe { c::WSAGetLastError() };\n+\n+            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n+                return Err(io::Error::from_raw_os_error(error));\n+            }\n+\n+            let socket =\n+                unsafe { c::WSASocketW(family, ty, 0, ptr::null_mut(), 0, c::WSA_FLAG_OVERLAPPED) };\n+\n+            if socket == c::INVALID_SOCKET {\n+                return Err(last_error());\n             }\n-        }?;\n-        Ok(socket)\n+\n+            let socket = Self(socket);\n+            socket.set_no_inherit()?;\n+            Ok(socket)\n+        }\n     }\n \n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n         self.set_nonblocking(true)?;\n-        let r = unsafe {\n+        let result = {\n             let (addrp, len) = addr.into_inner();\n-            cvt(c::connect(self.0, addrp, len))\n+            let result = unsafe { c::connect(self.0, addrp, len) };\n+            cvt(result).map(drop)\n         };\n         self.set_nonblocking(false)?;\n \n-        match r {\n-            Ok(_) => return Ok(()),\n-            Err(ref e) if e.kind() == io::ErrorKind::WouldBlock => {}\n-            Err(e) => return Err(e),\n-        }\n-\n-        if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n-            return Err(io::Error::new_const(\n-                io::ErrorKind::InvalidInput,\n-                &\"cannot set a 0 duration timeout\",\n-            ));\n-        }\n-\n-        let mut timeout = c::timeval {\n-            tv_sec: timeout.as_secs() as c_long,\n-            tv_usec: (timeout.subsec_nanos() / 1000) as c_long,\n-        };\n-        if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n-            timeout.tv_usec = 1;\n-        }\n+        match result {\n+            Err(ref error) if error.kind() == io::ErrorKind::WouldBlock => {\n+                if timeout.as_secs() == 0 && timeout.subsec_nanos() == 0 {\n+                    return Err(io::Error::new_const(\n+                        io::ErrorKind::InvalidInput,\n+                        &\"cannot set a 0 duration timeout\",\n+                    ));\n+                }\n \n-        let fds = unsafe {\n-            let mut fds = mem::zeroed::<c::fd_set>();\n-            fds.fd_count = 1;\n-            fds.fd_array[0] = self.0;\n-            fds\n-        };\n+                let mut timeout = c::timeval {\n+                    tv_sec: timeout.as_secs() as c_long,\n+                    tv_usec: (timeout.subsec_nanos() / 1000) as c_long,\n+                };\n \n-        let mut writefds = fds;\n-        let mut errorfds = fds;\n+                if timeout.tv_sec == 0 && timeout.tv_usec == 0 {\n+                    timeout.tv_usec = 1;\n+                }\n \n-        let n =\n-            unsafe { cvt(c::select(1, ptr::null_mut(), &mut writefds, &mut errorfds, &timeout))? };\n+                let fds = {\n+                    let mut fds = unsafe { mem::zeroed::<c::fd_set>() };\n+                    fds.fd_count = 1;\n+                    fds.fd_array[0] = self.0;\n+                    fds\n+                };\n+\n+                let mut writefds = fds;\n+                let mut errorfds = fds;\n+\n+                let count = {\n+                    let result = unsafe {\n+                        c::select(1, ptr::null_mut(), &mut writefds, &mut errorfds, &timeout)\n+                    };\n+                    cvt(result)?\n+                };\n+\n+                match count {\n+                    0 => {\n+                        Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\"))\n+                    }\n+                    _ => {\n+                        if writefds.fd_count != 1 {\n+                            if let Some(e) = self.take_error()? {\n+                                return Err(e);\n+                            }\n+                        }\n \n-        match n {\n-            0 => Err(io::Error::new_const(io::ErrorKind::TimedOut, &\"connection timed out\")),\n-            _ => {\n-                if writefds.fd_count != 1 {\n-                    if let Some(e) = self.take_error()? {\n-                        return Err(e);\n+                        Ok(())\n                     }\n                 }\n-                Ok(())\n             }\n+            _ => result,\n         }\n     }\n \n     pub fn accept(&self, storage: *mut c::SOCKADDR, len: *mut c_int) -> io::Result<Socket> {\n-        let socket = unsafe {\n-            match c::accept(self.0, storage, len) {\n-                c::INVALID_SOCKET => Err(last_error()),\n-                n => Ok(Socket(n)),\n-            }\n-        }?;\n-        Ok(socket)\n+        let socket = unsafe { c::accept(self.0, storage, len) };\n+\n+        match socket {\n+            c::INVALID_SOCKET => Err(last_error()),\n+            _ => Ok(Self(socket)),\n+        }\n     }\n \n     pub fn duplicate(&self) -> io::Result<Socket> {\n+        let mut info = unsafe { mem::zeroed::<c::WSAPROTOCOL_INFO>() };\n+        let result = unsafe { c::WSADuplicateSocketW(self.0, c::GetCurrentProcessId(), &mut info) };\n+        cvt(result)?;\n         let socket = unsafe {\n-            let mut info: c::WSAPROTOCOL_INFO = mem::zeroed();\n-            cvt(c::WSADuplicateSocketW(self.0, c::GetCurrentProcessId(), &mut info))?;\n-\n-            match c::WSASocketW(\n+            c::WSASocketW(\n                 info.iAddressFamily,\n                 info.iSocketType,\n                 info.iProtocol,\n                 &mut info,\n                 0,\n                 c::WSA_FLAG_OVERLAPPED | c::WSA_FLAG_NO_HANDLE_INHERIT,\n-            ) {\n-                c::INVALID_SOCKET => match c::WSAGetLastError() {\n-                    c::WSAEPROTOTYPE | c::WSAEINVAL => {\n-                        match c::WSASocketW(\n-                            info.iAddressFamily,\n-                            info.iSocketType,\n-                            info.iProtocol,\n-                            &mut info,\n-                            0,\n-                            c::WSA_FLAG_OVERLAPPED,\n-                        ) {\n-                            c::INVALID_SOCKET => Err(last_error()),\n-                            n => {\n-                                let s = Socket(n);\n-                                s.set_no_inherit()?;\n-                                Ok(s)\n-                            }\n-                        }\n-                    }\n-                    n => Err(io::Error::from_raw_os_error(n)),\n-                },\n-                n => Ok(Socket(n)),\n+            )\n+        };\n+\n+        if socket != c::INVALID_SOCKET {\n+            Ok(Self(socket))\n+        } else {\n+            let error = unsafe { c::WSAGetLastError() };\n+\n+            if error != c::WSAEPROTOTYPE && error != c::WSAEINVAL {\n+                return Err(io::Error::from_raw_os_error(error));\n+            }\n+\n+            let socket = unsafe {\n+                c::WSASocketW(\n+                    info.iAddressFamily,\n+                    info.iSocketType,\n+                    info.iProtocol,\n+                    &mut info,\n+                    0,\n+                    c::WSA_FLAG_OVERLAPPED,\n+                )\n+            };\n+\n+            if socket == c::INVALID_SOCKET {\n+                return Err(last_error());\n             }\n-        }?;\n-        Ok(socket)\n+\n+            let socket = Self(socket);\n+            socket.set_no_inherit()?;\n+            Ok(socket)\n+        }\n     }\n \n     fn recv_with_flags(&self, buf: &mut [u8], flags: c_int) -> io::Result<usize> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        let len = cmp::min(buf.len(), i32::MAX as usize) as i32;\n-        unsafe {\n-            match c::recv(self.0, buf.as_mut_ptr() as *mut c_void, len, flags) {\n-                -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n-                -1 => Err(last_error()),\n-                n => Ok(n as usize),\n+        let length = cmp::min(buf.len(), i32::MAX as usize) as i32;\n+        let result = unsafe { c::recv(self.0, buf.as_mut_ptr() as *mut _, length, flags) };\n+\n+        match result {\n+            c::SOCKET_ERROR => {\n+                let error = unsafe { c::WSAGetLastError() };\n+\n+                if error == c::WSAESHUTDOWN {\n+                    Ok(0)\n+                } else {\n+                    Err(io::Error::from_raw_os_error(error))\n+                }\n             }\n+            _ => Ok(result as usize),\n         }\n     }\n \n@@ -250,23 +274,31 @@ impl Socket {\n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        let len = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n+        let length = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n         let mut nread = 0;\n         let mut flags = 0;\n-        unsafe {\n-            let ret = c::WSARecv(\n+        let result = unsafe {\n+            c::WSARecv(\n                 self.0,\n                 bufs.as_mut_ptr() as *mut c::WSABUF,\n-                len,\n+                length,\n                 &mut nread,\n                 &mut flags,\n                 ptr::null_mut(),\n                 ptr::null_mut(),\n-            );\n-            match ret {\n-                0 => Ok(nread as usize),\n-                _ if c::WSAGetLastError() == c::WSAESHUTDOWN => Ok(0),\n-                _ => Err(last_error()),\n+            )\n+        };\n+\n+        match result {\n+            0 => Ok(nread as usize),\n+            _ => {\n+                let error = unsafe { c::WSAGetLastError() };\n+\n+                if error == c::WSAESHUTDOWN {\n+                    Ok(0)\n+                } else {\n+                    Err(io::Error::from_raw_os_error(error))\n+                }\n             }\n         }\n     }\n@@ -285,27 +317,34 @@ impl Socket {\n         buf: &mut [u8],\n         flags: c_int,\n     ) -> io::Result<(usize, SocketAddr)> {\n-        let mut storage: c::SOCKADDR_STORAGE_LH = unsafe { mem::zeroed() };\n+        let mut storage = unsafe { mem::zeroed::<c::SOCKADDR_STORAGE_LH>() };\n         let mut addrlen = mem::size_of_val(&storage) as c::socklen_t;\n-        let len = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n+        let length = cmp::min(buf.len(), <wrlen_t>::MAX as usize) as wrlen_t;\n \n         // On unix when a socket is shut down all further reads return 0, so we\n         // do the same on windows to map a shut down socket to returning EOF.\n-        unsafe {\n-            match c::recvfrom(\n+        let result = unsafe {\n+            c::recvfrom(\n                 self.0,\n-                buf.as_mut_ptr() as *mut c_void,\n-                len,\n+                buf.as_mut_ptr() as *mut _,\n+                length,\n                 flags,\n                 &mut storage as *mut _ as *mut _,\n                 &mut addrlen,\n-            ) {\n-                -1 if c::WSAGetLastError() == c::WSAESHUTDOWN => {\n+            )\n+        };\n+\n+        match result {\n+            c::SOCKET_ERROR => {\n+                let error = unsafe { c::WSAGetLastError() };\n+\n+                if error == c::WSAESHUTDOWN {\n                     Ok((0, net::sockaddr_to_addr(&storage, addrlen as usize)?))\n+                } else {\n+                    Err(io::Error::from_raw_os_error(error))\n                 }\n-                -1 => Err(last_error()),\n-                n => Ok((n as usize, net::sockaddr_to_addr(&storage, addrlen as usize)?)),\n             }\n+            _ => Ok((result as usize, net::sockaddr_to_addr(&storage, addrlen as usize)?)),\n         }\n     }\n \n@@ -318,20 +357,20 @@ impl Socket {\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        let len = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n+        let length = cmp::min(bufs.len(), c::DWORD::MAX as usize) as c::DWORD;\n         let mut nwritten = 0;\n-        unsafe {\n-            cvt(c::WSASend(\n+        let result = unsafe {\n+            c::WSASend(\n                 self.0,\n-                bufs.as_ptr() as *const c::WSABUF as *mut c::WSABUF,\n-                len,\n+                bufs.as_ptr() as *const c::WSABUF as *mut _,\n+                length,\n                 &mut nwritten,\n                 0,\n                 ptr::null_mut(),\n                 ptr::null_mut(),\n-            ))?;\n-        }\n-        Ok(nwritten as usize)\n+            )\n+        };\n+        cvt(result).map(|_| nwritten as usize)\n     }\n \n     #[inline]\n@@ -384,14 +423,14 @@ impl Socket {\n             Shutdown::Read => c::SD_RECEIVE,\n             Shutdown::Both => c::SD_BOTH,\n         };\n-        cvt(unsafe { c::shutdown(self.0, how) })?;\n-        Ok(())\n+        let result = unsafe { c::shutdown(self.0, how) };\n+        cvt(result).map(drop)\n     }\n \n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         let mut nonblocking = nonblocking as c_ulong;\n-        let r = unsafe { c::ioctlsocket(self.0, c::FIONBIO as c_int, &mut nonblocking) };\n-        if r == 0 { Ok(()) } else { Err(io::Error::last_os_error()) }\n+        let result = unsafe { c::ioctlsocket(self.0, c::FIONBIO as c_int, &mut nonblocking) };\n+        cvt(result).map(drop)\n     }\n \n     pub fn set_nodelay(&self, nodelay: bool) -> io::Result<()> {"}, {"sha": "46fe3e2408f39df962ffbccc789daf505c4ebe51", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -965,14 +965,8 @@ fn render_assoc_item(\n     }\n }\n \n-const ALLOWED_ATTRIBUTES: &[Symbol] = &[\n-    sym::export_name,\n-    sym::link_section,\n-    sym::must_use,\n-    sym::no_mangle,\n-    sym::repr,\n-    sym::non_exhaustive,\n-];\n+const ALLOWED_ATTRIBUTES: &[Symbol] =\n+    &[sym::export_name, sym::link_section, sym::no_mangle, sym::repr, sym::non_exhaustive];\n \n fn attributes(it: &clean::Item) -> Vec<String> {\n     it.attrs"}, {"sha": "6a588fbd56e75945b2c5ae02936d8e5a99084f7f", "filename": "src/test/rustdoc/attributes.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/src%2Ftest%2Frustdoc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/src%2Ftest%2Frustdoc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fattributes.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -8,14 +8,6 @@ pub extern \"C\" fn f() {}\n #[export_name = \"bar\"]\n pub extern \"C\" fn g() {}\n \n-// @matches foo/enum.Foo.html '//*[@class=\"rust enum\"]' \\\n-//      '#\\[repr\\(i64\\)\\]\\n#\\[must_use\\]'\n-#[repr(i64)]\n-#[must_use]\n-pub enum Foo {\n-    Bar,\n-}\n-\n // @has foo/struct.Repr.html '//*[@class=\"docblock type-decl\"]' '#[repr(C, align(8))]'\n #[repr(C, align(8))]\n pub struct Repr;"}, {"sha": "15910e1e9006d1e8ff738a7c8814ecda10c483c1", "filename": "src/test/rustdoc/cap-lints.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/src%2Ftest%2Frustdoc%2Fcap-lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b/src%2Ftest%2Frustdoc%2Fcap-lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcap-lints.rs?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -3,8 +3,7 @@\n // therefore should not concern itself with the lints.\n #[deny(warnings)]\n \n-// @has cap_lints/struct.Foo.html //pre '#[must_use]'\n-#[must_use]\n+// @has cap_lints/struct.Foo.html //* 'Struct Foo'\n pub struct Foo {\n     field: i32,\n }"}, {"sha": "b52557fe220eed84ce95a5ad49b0647df1baa1fa", "filename": "src/test/rustdoc/must-use.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/246571a846e29691bd535d531365acd318857207/src%2Ftest%2Frustdoc%2Fmust-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246571a846e29691bd535d531365acd318857207/src%2Ftest%2Frustdoc%2Fmust-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmust-use.rs?ref=246571a846e29691bd535d531365acd318857207", "patch": "@@ -1,11 +0,0 @@\n-// @has must_use/struct.Struct.html //pre '#[must_use]'\n-#[must_use]\n-pub struct Struct {\n-    field: i32,\n-}\n-\n-// @has must_use/enum.Enum.html //pre '#[must_use = \"message\"]'\n-#[must_use = \"message\"]\n-pub enum Enum {\n-    Variant(i32),\n-}"}, {"sha": "d0dfb8759e66531284c6d371bad083c301afa305", "filename": "src/test/rustdoc/trait-attributes.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/246571a846e29691bd535d531365acd318857207/src%2Ftest%2Frustdoc%2Ftrait-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/246571a846e29691bd535d531365acd318857207/src%2Ftest%2Frustdoc%2Ftrait-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ftrait-attributes.rs?ref=246571a846e29691bd535d531365acd318857207", "patch": "@@ -1,21 +0,0 @@\n-#![crate_name = \"foo\"]\n-\n-\n-pub trait Foo {\n-    // @has foo/trait.Foo.html '//div[@id=\"tymethod.foo\"]//div[@class=\"code-attribute\"]' '#[must_use]'\n-    #[must_use]\n-    fn foo();\n-}\n-\n-#[must_use]\n-pub struct Bar;\n-\n-impl Bar {\n-    // @has foo/struct.Bar.html '//div[@id=\"method.bar\"]//div[@class=\"code-attribute\"]' '#[must_use]'\n-    #[must_use]\n-    pub fn bar() {}\n-\n-    // @has foo/struct.Bar.html '//div[@id=\"method.bar2\"]//div[@class=\"code-attribute\"]' '#[must_use]'\n-    #[must_use]\n-    pub fn bar2() {}\n-}"}, {"sha": "f0618a8f06a464840079f30b3e25bcdcca3922a3", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=607d6b00d4e0e0475b8de9d0c870b7126fdcdf6b", "patch": "@@ -1 +1 @@\n-Subproject commit 13da28cc2bc1b59f7af817eca36927a71edb023c\n+Subproject commit f0618a8f06a464840079f30b3e25bcdcca3922a3"}]}