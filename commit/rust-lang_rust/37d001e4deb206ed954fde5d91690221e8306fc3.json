{"sha": "37d001e4deb206ed954fde5d91690221e8306fc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3ZDAwMWU0ZGViMjA2ZWQ5NTRmZGU1ZDkxNjkwMjIxZTgzMDZmYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-29T19:10:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-29T19:10:33Z"}, "message": "Auto merge of #61317 - oli-obk:rollup-tm5qivq, r=oli-obk\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #60549 (do not print panic message on doctest failures)\n - #60885 (strip synstructure consts from compiler docs)\n - #61217 (Account for short-hand init structs when suggesting conversion)\n - #61261 (is_union returns ty to avoid computing it twice)\n - #61293 (Print const generics properly in rustdoc)\n - #61310 (split libcore::mem into multiple files)\n - #61313 (Simplify Set1::insert)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "075fbce72732c7c2fa6fa00f98ce61d349e979b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/075fbce72732c7c2fa6fa00f98ce61d349e979b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37d001e4deb206ed954fde5d91690221e8306fc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37d001e4deb206ed954fde5d91690221e8306fc3", "html_url": "https://github.com/rust-lang/rust/commit/37d001e4deb206ed954fde5d91690221e8306fc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37d001e4deb206ed954fde5d91690221e8306fc3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81970852e172c04322cbf8ba23effabeb491c83c", "url": "https://api.github.com/repos/rust-lang/rust/commits/81970852e172c04322cbf8ba23effabeb491c83c", "html_url": "https://github.com/rust-lang/rust/commit/81970852e172c04322cbf8ba23effabeb491c83c"}, {"sha": "b742d7ee6a81bf6acada69b0375b0566926aba23", "url": "https://api.github.com/repos/rust-lang/rust/commits/b742d7ee6a81bf6acada69b0375b0566926aba23", "html_url": "https://github.com/rust-lang/rust/commit/b742d7ee6a81bf6acada69b0375b0566926aba23"}], "stats": {"total": 3268, "additions": 1761, "deletions": 1507}, "files": [{"sha": "e082fc5088aa2116018324345c5b9d9947b5e46e", "filename": "Cargo.lock", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -860,7 +860,7 @@ dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2875,7 +2875,7 @@ dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"quote 0.6.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -3428,7 +3428,7 @@ dependencies = [\n \n [[package]]\n name = \"synstructure\"\n-version = \"0.10.1\"\n+version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"proc-macro2 0.4.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4367,7 +4367,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum syn 0.11.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d3b891b9015c88c576343b9b3e41c2c11a51c219ef067b264bd9c8aa9b441dad\"\n \"checksum syn 0.15.22 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ae8b29eb5210bc5cf63ed6149cbf9adfc82ac0be023d8735c176ee74a2db4da7\"\n \"checksum synom 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a393066ed9010ebaed60b9eafa373d4b1baac186dd7e008555b0f702b51945b6\"\n-\"checksum synstructure 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"73687139bf99285483c96ac0add482c3776528beac1d97d444f6e91f203a2015\"\n+\"checksum synstructure 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"02353edf96d6e4dc81aea2d8490a7e9db177bf8acb0e951c24940bf866cb313f\"\n \"checksum tar 0.4.20 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a303ba60a099fcd2aaa646b14d2724591a96a75283e4b7ed3d1a1658909d9ae2\"\n \"checksum tempfile 3.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e91405c14320e5c79b3d148e1c86f40749a36e490642202a31689cb1a3452b2\"\n \"checksum tendril 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9de21546595a0873061940d994bbbc5c35f024ae4fd61ec5c5b159115684f508\""}, {"sha": "5605ec34083becb7a8c59969f25fd66f37098f6e", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -728,7 +728,7 @@ impl Step for Rustc {\n \n         // Build cargo command.\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items --passes strip-hidden\");\n         compile::rustc_cargo(builder, &mut cargo);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`."}, {"sha": "40f4354213b40849bf253c7d1bb10bab04a86761", "filename": "src/libcore/mem.rs", "status": "removed", "additions": 0, "deletions": 1406, "changes": 1406, "blob_url": "https://github.com/rust-lang/rust/blob/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81970852e172c04322cbf8ba23effabeb491c83c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=81970852e172c04322cbf8ba23effabeb491c83c", "patch": "@@ -1,1406 +0,0 @@\n-//! Basic functions for dealing with memory.\n-//!\n-//! This module contains functions for querying the size and alignment of\n-//! types, initializing and manipulating memory.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use crate::clone;\n-use crate::cmp;\n-use crate::fmt;\n-use crate::hash;\n-use crate::intrinsics;\n-use crate::marker::{Copy, PhantomData, Sized};\n-use crate::ptr;\n-use crate::ops::{Deref, DerefMut};\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[doc(inline)]\n-pub use crate::intrinsics::transmute;\n-\n-/// Takes ownership and \"forgets\" about the value **without running its destructor**.\n-///\n-/// Any resources the value manages, such as heap memory or a file handle, will linger\n-/// forever in an unreachable state. However, it does not guarantee that pointers\n-/// to this memory will remain valid.\n-///\n-/// * If you want to leak memory, see [`Box::leak`][leak].\n-/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`][into_raw].\n-/// * If you want to dispose of a value properly, running its destructor, see\n-/// [`mem::drop`][drop].\n-///\n-/// # Safety\n-///\n-/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n-/// do not include a guarantee that destructors will always run. For example,\n-/// a program can create a reference cycle using [`Rc`][rc], or call\n-/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n-/// `mem::forget` from safe code does not fundamentally change Rust's safety\n-/// guarantees.\n-///\n-/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n-/// so `forget` is only recommended for specialized use cases like those shown below.\n-///\n-/// Because forgetting a value is allowed, any `unsafe` code you write must\n-/// allow for this possibility. You cannot return a value and expect that the\n-/// caller will necessarily run the value's destructor.\n-///\n-/// [rc]: ../../std/rc/struct.Rc.html\n-/// [exit]: ../../std/process/fn.exit.html\n-///\n-/// # Examples\n-///\n-/// Leak an I/O object, never closing the file:\n-///\n-/// ```no_run\n-/// use std::mem;\n-/// use std::fs::File;\n-///\n-/// let file = File::open(\"foo.txt\").unwrap();\n-/// mem::forget(file);\n-/// ```\n-///\n-/// The practical use cases for `forget` are rather specialized and mainly come\n-/// up in unsafe or FFI code.\n-///\n-/// [drop]: fn.drop.html\n-/// [uninit]: fn.uninitialized.html\n-/// [clone]: ../clone/trait.Clone.html\n-/// [swap]: fn.swap.html\n-/// [box]: ../../std/boxed/struct.Box.html\n-/// [leak]: ../../std/boxed/struct.Box.html#method.leak\n-/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn forget<T>(t: T) {\n-    ManuallyDrop::new(t);\n-}\n-\n-/// Like [`forget`], but also accepts unsized values.\n-///\n-/// This function is just a shim intended to be removed when the `unsized_locals` feature gets\n-/// stabilized.\n-///\n-/// [`forget`]: fn.forget.html\n-#[inline]\n-#[unstable(feature = \"forget_unsized\", issue = \"0\")]\n-pub fn forget_unsized<T: ?Sized>(t: T) {\n-    unsafe { intrinsics::forget(t) }\n-}\n-\n-/// Returns the size of a type in bytes.\n-///\n-/// More specifically, this is the offset in bytes between successive elements\n-/// in an array with that item type including alignment padding. Thus, for any\n-/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n-///\n-/// In general, the size of a type is not stable across compilations, but\n-/// specific types such as primitives are.\n-///\n-/// The following table gives the size for primitives.\n-///\n-/// Type | size_of::\\<Type>()\n-/// ---- | ---------------\n-/// () | 0\n-/// bool | 1\n-/// u8 | 1\n-/// u16 | 2\n-/// u32 | 4\n-/// u64 | 8\n-/// u128 | 16\n-/// i8 | 1\n-/// i16 | 2\n-/// i32 | 4\n-/// i64 | 8\n-/// i128 | 16\n-/// f32 | 4\n-/// f64 | 8\n-/// char | 4\n-///\n-/// Furthermore, `usize` and `isize` have the same size.\n-///\n-/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n-/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n-///\n-/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n-/// have the same size. Likewise for `*const T` and `*mut T`.\n-///\n-/// # Size of `#[repr(C)]` items\n-///\n-/// The `C` representation for items has a defined layout. With this layout,\n-/// the size of items is also stable as long as all fields have a stable size.\n-///\n-/// ## Size of Structs\n-///\n-/// For `structs`, the size is determined by the following algorithm.\n-///\n-/// For each field in the struct ordered by declaration order:\n-///\n-/// 1. Add the size of the field.\n-/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n-///\n-/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n-/// The alignment of the struct is usually the largest alignment of all its\n-/// fields; this can be changed with the use of `repr(align(N))`.\n-///\n-/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n-///\n-/// ## Size of Enums\n-///\n-/// Enums that carry no data other than the discriminant have the same size as C enums\n-/// on the platform they are compiled for.\n-///\n-/// ## Size of Unions\n-///\n-/// The size of a union is the size of its largest field.\n-///\n-/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// // Some primitives\n-/// assert_eq!(4, mem::size_of::<i32>());\n-/// assert_eq!(8, mem::size_of::<f64>());\n-/// assert_eq!(0, mem::size_of::<()>());\n-///\n-/// // Some arrays\n-/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n-/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n-/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n-///\n-///\n-/// // Pointer size equality\n-/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n-/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n-/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n-/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n-/// ```\n-///\n-/// Using `#[repr(C)]`.\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// #[repr(C)]\n-/// struct FieldStruct {\n-///     first: u8,\n-///     second: u16,\n-///     third: u8\n-/// }\n-///\n-/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n-/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n-/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n-/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n-/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n-/// // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n-/// // fields is 2), so add 1 to the size for padding. Size is 6.\n-/// assert_eq!(6, mem::size_of::<FieldStruct>());\n-///\n-/// #[repr(C)]\n-/// struct TupleStruct(u8, u16, u8);\n-///\n-/// // Tuple structs follow the same rules.\n-/// assert_eq!(6, mem::size_of::<TupleStruct>());\n-///\n-/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n-/// // by putting `third` before `second`.\n-/// #[repr(C)]\n-/// struct FieldStructOptimized {\n-///     first: u8,\n-///     third: u8,\n-///     second: u16\n-/// }\n-///\n-/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n-///\n-/// // Union size is the size of the largest field.\n-/// #[repr(C)]\n-/// union ExampleUnion {\n-///     smaller: u8,\n-///     larger: u16\n-/// }\n-///\n-/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n-/// ```\n-///\n-/// [alignment]: ./fn.align_of.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_promotable]\n-pub const fn size_of<T>() -> usize {\n-    intrinsics::size_of::<T>()\n-}\n-\n-/// Returns the size of the pointed-to value in bytes.\n-///\n-/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n-/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n-/// then `size_of_val` can be used to get the dynamically-known size.\n-///\n-/// [slice]: ../../std/primitive.slice.html\n-/// [trait object]: ../../book/ch17-02-trait-objects.html\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::size_of_val(&5i32));\n-///\n-/// let x: [u8; 13] = [0; 13];\n-/// let y: &[u8] = &x;\n-/// assert_eq!(13, mem::size_of_val(y));\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::size_of_val(val) }\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of a type.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![allow(deprecated)]\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::min_align_of::<i32>());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\n-pub fn min_align_of<T>() -> usize {\n-    intrinsics::min_align_of::<T>()\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![allow(deprecated)]\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::min_align_of_val(&5i32));\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\n-pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::min_align_of_val(val) }\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of a type.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::align_of::<i32>());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_promotable]\n-pub const fn align_of<T>() -> usize {\n-    intrinsics::min_align_of::<T>()\n-}\n-\n-/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n-///\n-/// Every reference to a value of the type `T` must be a multiple of this number.\n-///\n-/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// assert_eq!(4, mem::align_of_val(&5i32));\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n-    unsafe { intrinsics::min_align_of_val(val) }\n-}\n-\n-/// Returns `true` if dropping values of type `T` matters.\n-///\n-/// This is purely an optimization hint, and may be implemented conservatively:\n-/// it may return `true` for types that don't actually need to be dropped.\n-/// As such always returning `true` would be a valid implementation of\n-/// this function. However if this function actually returns `false`, then you\n-/// can be certain dropping `T` has no side effect.\n-///\n-/// Low level implementations of things like collections, which need to manually\n-/// drop their data, should use this function to avoid unnecessarily\n-/// trying to drop all their contents when they are destroyed. This might not\n-/// make a difference in release builds (where a loop that has no side-effects\n-/// is easily detected and eliminated), but is often a big win for debug builds.\n-///\n-/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n-/// can be reduced to some small number of drop_in_place calls, using this is\n-/// unnecessary. In particular note that you can drop_in_place a slice, and that\n-/// will do a single needs_drop check for all the values.\n-///\n-/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n-/// needs_drop explicitly. Types like HashMap, on the other hand, have to drop\n-/// values one at a time and should use this API.\n-///\n-///\n-/// # Examples\n-///\n-/// Here's an example of how a collection might make use of needs_drop:\n-///\n-/// ```\n-/// use std::{mem, ptr};\n-///\n-/// pub struct MyCollection<T> {\n-/// #   data: [T; 1],\n-///     /* ... */\n-/// }\n-/// # impl<T> MyCollection<T> {\n-/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n-/// #   fn free_buffer(&mut self) {}\n-/// # }\n-///\n-/// impl<T> Drop for MyCollection<T> {\n-///     fn drop(&mut self) {\n-///         unsafe {\n-///             // drop the data\n-///             if mem::needs_drop::<T>() {\n-///                 for x in self.iter_mut() {\n-///                     ptr::drop_in_place(x);\n-///                 }\n-///             }\n-///             self.free_buffer();\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[inline]\n-#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n-pub const fn needs_drop<T>() -> bool {\n-    intrinsics::needs_drop::<T>()\n-}\n-\n-/// Creates a value whose bytes are all zero.\n-///\n-/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n-/// It is useful for FFI sometimes, but should generally be avoided.\n-///\n-/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n-/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n-/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n-/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n-/// that there always is a valid value in a variable it considers initialized.\n-///\n-/// [zeroed]: union.MaybeUninit.html#method.zeroed\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [inv]: union.MaybeUninit.html#initialization-invariant\n-///\n-/// # Examples\n-///\n-/// Correct usage of this function: initializing an integer with zero.\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// let x: i32 = unsafe { mem::zeroed() };\n-/// assert_eq!(0, x);\n-/// ```\n-///\n-/// *Incorrect* usage of this function: initializing a reference with zero.\n-///\n-/// ```no_run\n-/// use std::mem;\n-///\n-/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn zeroed<T>() -> T {\n-    intrinsics::panic_if_uninhabited::<T>();\n-    intrinsics::init()\n-}\n-\n-/// Bypasses Rust's normal memory-initialization checks by pretending to\n-/// produce a value of type `T`, while doing nothing at all.\n-///\n-/// **This functon is deprecated.** Use [`MaybeUninit<T>`] instead.\n-///\n-/// The reason for deprecation is that the function basically cannot be used\n-/// correctly: [the Rust compiler assumes][inv] that values are properly initialized.\n-/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n-/// undefined behavior for returning a `bool` that is not definitely either `true`\n-/// or `false`. Worse, truly uninitialized memory like what gets returned here\n-/// is special in that the compiler knows that it does not have a fixed value.\n-/// This makes it undefined behavior to have uninitialized data in a variable even\n-/// if that variable has an integer type.\n-/// (Notice that the rules around uninitialized integers are not finalized yet, but\n-/// until they are, it is advisable to avoid them.)\n-///\n-/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n-/// [inv]: union.MaybeUninit.html#initialization-invariant\n-#[inline]\n-#[rustc_deprecated(since = \"1.38.0\", reason = \"use `mem::MaybeUninit` instead\")]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn uninitialized<T>() -> T {\n-    intrinsics::panic_if_uninhabited::<T>();\n-    intrinsics::uninit()\n-}\n-\n-/// Swaps the values at two mutable locations, without deinitializing either one.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// let mut x = 5;\n-/// let mut y = 42;\n-///\n-/// mem::swap(&mut x, &mut y);\n-///\n-/// assert_eq!(42, x);\n-/// assert_eq!(5, y);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn swap<T>(x: &mut T, y: &mut T) {\n-    unsafe {\n-        ptr::swap_nonoverlapping_one(x, y);\n-    }\n-}\n-\n-/// Moves `src` into the referenced `dest`, returning the previous `dest` value.\n-///\n-/// Neither value is dropped.\n-///\n-/// # Examples\n-///\n-/// A simple example:\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// let mut v: Vec<i32> = vec![1, 2];\n-///\n-/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n-/// assert_eq!(vec![1, 2], old_v);\n-/// assert_eq!(vec![3, 4, 5], v);\n-/// ```\n-///\n-/// `replace` allows consumption of a struct field by replacing it with another value.\n-/// Without `replace` you can run into issues like these:\n-///\n-/// ```compile_fail,E0507\n-/// struct Buffer<T> { buf: Vec<T> }\n-///\n-/// impl<T> Buffer<T> {\n-///     fn get_and_reset(&mut self) -> Vec<T> {\n-///         // error: cannot move out of dereference of `&mut`-pointer\n-///         let buf = self.buf;\n-///         self.buf = Vec::new();\n-///         buf\n-///     }\n-/// }\n-/// ```\n-///\n-/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n-/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n-/// `self`, allowing it to be returned:\n-///\n-/// ```\n-/// # #![allow(dead_code)]\n-/// use std::mem;\n-///\n-/// # struct Buffer<T> { buf: Vec<T> }\n-/// impl<T> Buffer<T> {\n-///     fn get_and_reset(&mut self) -> Vec<T> {\n-///         mem::replace(&mut self.buf, Vec::new())\n-///     }\n-/// }\n-/// ```\n-///\n-/// [`Clone`]: ../../std/clone/trait.Clone.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n-    swap(dest, &mut src);\n-    src\n-}\n-\n-/// Disposes of a value.\n-///\n-/// This does call the argument's implementation of [`Drop`][drop].\n-///\n-/// This effectively does nothing for types which implement `Copy`, e.g.\n-/// integers. Such values are copied and _then_ moved into the function, so the\n-/// value persists after this function call.\n-///\n-/// This function is not magic; it is literally defined as\n-///\n-/// ```\n-/// pub fn drop<T>(_x: T) { }\n-/// ```\n-///\n-/// Because `_x` is moved into the function, it is automatically dropped before\n-/// the function returns.\n-///\n-/// [drop]: ../ops/trait.Drop.html\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// let v = vec![1, 2, 3];\n-///\n-/// drop(v); // explicitly drop the vector\n-/// ```\n-///\n-/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n-/// release a [`RefCell`] borrow:\n-///\n-/// ```\n-/// use std::cell::RefCell;\n-///\n-/// let x = RefCell::new(1);\n-///\n-/// let mut mutable_borrow = x.borrow_mut();\n-/// *mutable_borrow = 1;\n-///\n-/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n-///\n-/// let borrow = x.borrow();\n-/// println!(\"{}\", *borrow);\n-/// ```\n-///\n-/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n-///\n-/// ```\n-/// #[derive(Copy, Clone)]\n-/// struct Foo(u8);\n-///\n-/// let x = 1;\n-/// let y = Foo(2);\n-/// drop(x); // a copy of `x` is moved and dropped\n-/// drop(y); // a copy of `y` is moved and dropped\n-///\n-/// println!(\"x: {}, y: {}\", x, y.0); // still available\n-/// ```\n-///\n-/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n-/// [`Copy`]: ../../std/marker/trait.Copy.html\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn drop<T>(_x: T) { }\n-\n-/// Interprets `src` as having type `&U`, and then reads `src` without moving\n-/// the contained value.\n-///\n-/// This function will unsafely assume the pointer `src` is valid for\n-/// [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading\n-/// the `&U`. It will also unsafely create a copy of the contained value instead of\n-/// moving out of `src`.\n-///\n-/// It is not a compile-time error if `T` and `U` have different sizes, but it\n-/// is highly encouraged to only invoke this function where `T` and `U` have the\n-/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n-/// `T`.\n-///\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-/// [size_of]: fn.size_of.html\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// #[repr(packed)]\n-/// struct Foo {\n-///     bar: u8,\n-/// }\n-///\n-/// let foo_slice = [10u8];\n-///\n-/// unsafe {\n-///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n-///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n-///     assert_eq!(foo_struct.bar, 10);\n-///\n-///     // Modify the copied data\n-///     foo_struct.bar = 20;\n-///     assert_eq!(foo_struct.bar, 20);\n-/// }\n-///\n-/// // The contents of 'foo_slice' should not have changed\n-/// assert_eq!(foo_slice, [10]);\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n-    ptr::read_unaligned(src as *const T as *const U)\n-}\n-\n-/// Opaque type representing the discriminant of an enum.\n-///\n-/// See the [`discriminant`] function in this module for more information.\n-///\n-/// [`discriminant`]: fn.discriminant.html\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n-\n-// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> Copy for Discriminant<T> {}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> clone::Clone for Discriminant<T> {\n-    fn clone(&self) -> Self {\n-        *self\n-    }\n-}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> cmp::PartialEq for Discriminant<T> {\n-    fn eq(&self, rhs: &Self) -> bool {\n-        self.0 == rhs.0\n-    }\n-}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> cmp::Eq for Discriminant<T> {}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> hash::Hash for Discriminant<T> {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        self.0.hash(state);\n-    }\n-}\n-\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-impl<T> fmt::Debug for Discriminant<T> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt.debug_tuple(\"Discriminant\")\n-           .field(&self.0)\n-           .finish()\n-    }\n-}\n-\n-/// Returns a value uniquely identifying the enum variant in `v`.\n-///\n-/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n-/// return value is unspecified.\n-///\n-/// # Stability\n-///\n-/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n-/// of some variant will not change between compilations with the same compiler.\n-///\n-/// # Examples\n-///\n-/// This can be used to compare enums that carry data, while disregarding\n-/// the actual data:\n-///\n-/// ```\n-/// use std::mem;\n-///\n-/// enum Foo { A(&'static str), B(i32), C(i32) }\n-///\n-/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n-/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n-/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n-/// ```\n-#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n-pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n-    unsafe {\n-        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n-    }\n-}\n-\n-/// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n-///\n-/// This wrapper is 0-cost.\n-///\n-/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n-/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n-/// about all values being initialized at their type.  In particular, initializing\n-/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n-/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n-///\n-/// # Examples\n-///\n-/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n-/// the type:\n-///\n-/// ```rust\n-/// use std::mem::ManuallyDrop;\n-/// struct Peach;\n-/// struct Banana;\n-/// struct Melon;\n-/// struct FruitBox {\n-///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n-///     peach: ManuallyDrop<Peach>,\n-///     melon: Melon, // Field that\u2019s independent of the other two.\n-///     banana: ManuallyDrop<Banana>,\n-/// }\n-///\n-/// impl Drop for FruitBox {\n-///     fn drop(&mut self) {\n-///         unsafe {\n-///             // Explicit ordering in which field destructors are run specified in the intuitive\n-///             // location \u2013 the destructor of the structure containing the fields.\n-///             // Moreover, one can now reorder fields within the struct however much they want.\n-///             ManuallyDrop::drop(&mut self.peach);\n-///             ManuallyDrop::drop(&mut self.banana);\n-///         }\n-///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n-///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n-///     }\n-/// }\n-/// ```\n-///\n-/// [`mem::zeroed`]: fn.zeroed.html\n-/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-#[lang = \"manually_drop\"]\n-#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-#[repr(transparent)]\n-pub struct ManuallyDrop<T: ?Sized> {\n-    value: T,\n-}\n-\n-impl<T> ManuallyDrop<T> {\n-    /// Wrap a value to be manually dropped.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::mem::ManuallyDrop;\n-    /// ManuallyDrop::new(Box::new(()));\n-    /// ```\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline(always)]\n-    pub const fn new(value: T) -> ManuallyDrop<T> {\n-        ManuallyDrop { value }\n-    }\n-\n-    /// Extracts the value from the `ManuallyDrop` container.\n-    ///\n-    /// This allows the value to be dropped again.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// use std::mem::ManuallyDrop;\n-    /// let x = ManuallyDrop::new(Box::new(()));\n-    /// let _: Box<()> = ManuallyDrop::into_inner(x); // This drops the `Box`.\n-    /// ```\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline(always)]\n-    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {\n-        slot.value\n-    }\n-\n-    /// Takes the contained value out.\n-    ///\n-    /// This method is primarily intended for moving out values in drop.\n-    /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n-    /// you can use this method to take the value and use it however desired.\n-    /// `Drop` will be invoked on the returned value following normal end-of-scope rules.\n-    ///\n-    /// If you have ownership of the container, you can use [`ManuallyDrop::into_inner`] instead.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function semantically moves out the contained value without preventing further usage.\n-    /// It is up to the user of this method to ensure that this container is not used again.\n-    ///\n-    /// [`ManuallyDrop::drop`]: #method.drop\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n-    #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n-    #[unstable(feature = \"manually_drop_take\", issue = \"55422\")]\n-    #[inline]\n-    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n-        ManuallyDrop::into_inner(ptr::read(slot))\n-    }\n-}\n-\n-impl<T: ?Sized> ManuallyDrop<T> {\n-    /// Manually drops the contained value.\n-    ///\n-    /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n-    ///\n-    /// # Safety\n-    ///\n-    /// This function runs the destructor of the contained value and thus the wrapped value\n-    /// now represents uninitialized data. It is up to the user of this method to ensure the\n-    /// uninitialized data is not actually used.\n-    ///\n-    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n-    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-    #[inline]\n-    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n-        ptr::drop_in_place(&mut slot.value)\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T: ?Sized> Deref for ManuallyDrop<T> {\n-    type Target = T;\n-    #[inline(always)]\n-    fn deref(&self) -> &T {\n-        &self.value\n-    }\n-}\n-\n-#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n-impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n-    #[inline(always)]\n-    fn deref_mut(&mut self) -> &mut T {\n-        &mut self.value\n-    }\n-}\n-\n-/// A wrapper type to construct uninitialized instances of `T`.\n-///\n-/// # Initialization invariant\n-///\n-/// The compiler, in general, assumes that variables are properly initialized\n-/// at their respective type. For example, a variable of reference type must\n-/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n-/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n-/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n-/// ever gets used to access memory:\n-///\n-/// ```rust,no_run\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n-/// // The equivalent code with `MaybeUninit<&i32>`:\n-/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior!\n-/// ```\n-///\n-/// This is exploited by the compiler for various optimizations, such as eliding\n-/// run-time checks and optimizing `enum` layout.\n-///\n-/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n-/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n-///\n-/// ```rust,no_run\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n-/// // The equivalent code with `MaybeUninit<bool>`:\n-/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n-/// ```\n-///\n-/// Moreover, uninitialized memory is special in that the compiler knows that\n-/// it does not have a fixed value. This makes it undefined behavior to have\n-/// uninitialized data in a variable even if that variable has an integer type,\n-/// which otherwise can hold any *fixed* bit pattern:\n-///\n-/// ```rust,no_run\n-/// use std::mem::{self, MaybeUninit};\n-///\n-/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n-/// // The equivalent code with `MaybeUninit<i32>`:\n-/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n-/// ```\n-/// (Notice that the rules around uninitialized integers are not finalized yet, but\n-/// until they are, it is advisable to avoid them.)\n-///\n-/// On top of that, remember that most types have additional invariants beyond merely\n-/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n-/// is considered initialized because the only requirement the compiler knows about it\n-/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n-/// *immediate* undefined behavior, but will cause undefined behavior with most\n-/// safe operations (including dropping it).\n-///\n-/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n-///\n-/// # Examples\n-///\n-/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n-/// It is a signal to the compiler indicating that the data here might *not*\n-/// be initialized:\n-///\n-/// ```rust\n-/// use std::mem::MaybeUninit;\n-///\n-/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n-/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n-/// let mut x = MaybeUninit::<&i32>::uninit();\n-/// // Set it to a valid value.\n-/// unsafe { x.as_mut_ptr().write(&0); }\n-/// // Extract the initialized data -- this is only allowed *after* properly\n-/// // initializing `x`!\n-/// let x = unsafe { x.assume_init() };\n-/// ```\n-///\n-/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n-///\n-/// You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n-/// any of the run-time tracking and without any of the safety checks.\n-///\n-/// ## out-pointers\n-///\n-/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n-/// from a function, pass it a pointer to some (uninitialized) memory to put the\n-/// result into. This can be useful when it is important for the caller to control\n-/// how the memory the result is stored in gets allocated, and you want to avoid\n-/// unnecessary moves.\n-///\n-/// ```\n-/// use std::mem::MaybeUninit;\n-///\n-/// unsafe fn make_vec(out: *mut Vec<i32>) {\n-///     // `write` does not drop the old contents, which is important.\n-///     out.write(vec![1, 2, 3]);\n-/// }\n-///\n-/// let mut v = MaybeUninit::uninit();\n-/// unsafe { make_vec(v.as_mut_ptr()); }\n-/// // Now we know `v` is initialized! This also makes sure the vector gets\n-/// // properly dropped.\n-/// let v = unsafe { v.assume_init() };\n-/// assert_eq!(&v, &[1, 2, 3]);\n-/// ```\n-///\n-/// ## Initializing an array element-by-element\n-///\n-/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n-///\n-/// ```\n-/// use std::mem::{self, MaybeUninit};\n-/// use std::ptr;\n-///\n-/// let data = {\n-///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n-///     // safe because the type we are claiming to have initialized here is a\n-///     // bunch of `MaybeUninit`s, which do not require initialization.\n-///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n-///         MaybeUninit::uninit().assume_init()\n-///     };\n-///\n-///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n-///     // we have a memory leak, but there is no memory safety issue.\n-///     for elem in &mut data[..] {\n-///         unsafe { ptr::write(elem.as_mut_ptr(), vec![42]); }\n-///     }\n-///\n-///     // Everything is initialized. Transmute the array to the\n-///     // initialized type.\n-///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n-/// };\n-///\n-/// assert_eq!(&data[0], &[42]);\n-/// ```\n-///\n-/// You can also work with partially initialized arrays, which could\n-/// be found in low-level datastructures.\n-///\n-/// ```\n-/// use std::mem::MaybeUninit;\n-/// use std::ptr;\n-///\n-/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n-/// // safe because the type we are claiming to have initialized here is a\n-/// // bunch of `MaybeUninit`s, which do not require initialization.\n-/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n-/// // Count the number of elements we have assigned.\n-/// let mut data_len: usize = 0;\n-///\n-/// for elem in &mut data[0..500] {\n-///     unsafe { ptr::write(elem.as_mut_ptr(), String::from(\"hello\")); }\n-///     data_len += 1;\n-/// }\n-///\n-/// // For each item in the array, drop if we allocated it.\n-/// for elem in &mut data[0..data_len] {\n-///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n-/// }\n-/// ```\n-///\n-/// ## Initializing a struct field-by-field\n-///\n-/// There is currently no supported way to create a raw pointer or reference\n-/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n-/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n-/// to its fields.\n-///\n-/// [ub]: ../../reference/behavior-considered-undefined.html\n-///\n-/// # Layout\n-///\n-/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n-///\n-/// ```rust\n-/// use std::mem::{MaybeUninit, size_of, align_of};\n-/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n-/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n-/// ```\n-///\n-/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n-/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n-/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n-/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n-/// optimizations, potentially resulting in a larger size:\n-///\n-/// ```rust\n-/// # use std::mem::{MaybeUninit, size_of};\n-/// assert_eq!(size_of::<Option<bool>>(), 1);\n-/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n-/// ```\n-#[allow(missing_debug_implementations)]\n-#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-#[derive(Copy)]\n-pub union MaybeUninit<T> {\n-    uninit: (),\n-    value: ManuallyDrop<T>,\n-}\n-\n-#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-impl<T: Copy> Clone for MaybeUninit<T> {\n-    #[inline(always)]\n-    fn clone(&self) -> Self {\n-        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n-        *self\n-    }\n-}\n-\n-impl<T> MaybeUninit<T> {\n-    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n-    /// It is safe to call [`assume_init`] on the return value of this function.\n-    ///\n-    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n-    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    ///\n-    /// [`assume_init`]: #method.assume_init\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub const fn new(val: T) -> MaybeUninit<T> {\n-        MaybeUninit { value: ManuallyDrop::new(val) }\n-    }\n-\n-    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n-    ///\n-    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n-    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    ///\n-    /// See the [type-level documentation][type] for some examples.\n-    ///\n-    /// [type]: union.MaybeUninit.html\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub const fn uninit() -> MaybeUninit<T> {\n-        MaybeUninit { uninit: () }\n-    }\n-\n-    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n-    /// filled with `0` bytes. It depends on `T` whether that already makes for\n-    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n-    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n-    /// be null.\n-    ///\n-    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n-    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n-    ///\n-    /// # Example\n-    ///\n-    /// Correct usage of this function: initializing a struct with zero, where all\n-    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n-    /// let x = unsafe { x.assume_init() };\n-    /// assert_eq!(x, (0, false));\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n-    /// cannot hold 0 as a valid value.\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// enum NotZero { One = 1, Two = 2 };\n-    ///\n-    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n-    /// let x = unsafe { x.assume_init() };\n-    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n-    /// // This is undefined behavior.\n-    /// ```\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline]\n-    pub fn zeroed() -> MaybeUninit<T> {\n-        let mut u = MaybeUninit::<T>::uninit();\n-        unsafe {\n-            u.as_mut_ptr().write_bytes(0u8, 1);\n-        }\n-        u\n-    }\n-\n-    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n-    /// without dropping it, so be careful not to use this twice unless you want to\n-    /// skip running the destructor. For your convenience, this also returns a mutable\n-    /// reference to the (now safely initialized) contents of `self`.\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn write(&mut self, val: T) -> &mut T {\n-        unsafe {\n-            self.value = ManuallyDrop::new(val);\n-            self.get_mut()\n-        }\n-    }\n-\n-    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n-    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n-    /// (except inside an `UnsafeCell<T>`).\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n-    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n-    /// let x_vec = unsafe { &*x.as_ptr() };\n-    /// assert_eq!(x_vec.len(), 3);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_vec = unsafe { &*x.as_ptr() };\n-    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n-    /// ```\n-    ///\n-    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n-    /// until they are, it is advisable to avoid them.)\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub fn as_ptr(&self) -> *const T {\n-        unsafe { &*self.value as *const T }\n-    }\n-\n-    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n-    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n-    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n-    /// // This is okay because we initialized it.\n-    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n-    /// x_vec.push(3);\n-    /// assert_eq!(x_vec.len(), 4);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n-    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n-    /// ```\n-    ///\n-    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n-    /// until they are, it is advisable to avoid them.)\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub fn as_mut_ptr(&mut self) -> *mut T {\n-        unsafe { &mut *self.value as *mut T }\n-    }\n-\n-    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n-    /// to ensure that the data will get dropped, because the resulting `T` is\n-    /// subject to the usual drop handling.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n-    /// behavior. The [type-level documentation][inv] contains more information about\n-    /// this initialization invariant.\n-    ///\n-    /// [inv]: #initialization-invariant\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<bool>::uninit();\n-    /// unsafe { x.as_mut_ptr().write(true); }\n-    /// let x_init = unsafe { x.assume_init() };\n-    /// assert_eq!(x_init, true);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n-    /// let x_init = unsafe { x.assume_init() };\n-    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n-    /// ```\n-    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n-    #[inline(always)]\n-    pub unsafe fn assume_init(self) -> T {\n-        intrinsics::panic_if_uninhabited::<T>();\n-        ManuallyDrop::into_inner(self.value)\n-    }\n-\n-    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n-    /// to the usual drop handling.\n-    ///\n-    /// Whenever possible, it is preferrable to use [`assume_init`] instead, which\n-    /// prevents duplicating the content of the `MaybeUninit<T>`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior. The [type-level documentation][inv] contains more information about\n-    /// this initialization invariant.\n-    ///\n-    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n-    /// multiple copies of the data (by calling `read` multiple times, or first\n-    /// calling `read` and then [`assume_init`]), it is your responsibility\n-    /// to ensure that that data may indeed be duplicated.\n-    ///\n-    /// [inv]: #initialization-invariant\n-    /// [`assume_init`]: #method.assume_init\n-    ///\n-    /// # Examples\n-    ///\n-    /// Correct usage of this method:\n-    ///\n-    /// ```rust\n-    /// #![feature(maybe_uninit_extra)]\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<u32>::uninit();\n-    /// x.write(13);\n-    /// let x1 = unsafe { x.read() };\n-    /// // `u32` is `Copy`, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n-    /// assert_eq!(x1, x2);\n-    ///\n-    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n-    /// x.write(None);\n-    /// let x1 = unsafe { x.read() };\n-    /// // Duplicating a `None` value is okay, so we may read multiple times.\n-    /// let x2 = unsafe { x.read() };\n-    /// assert_eq!(x1, x2);\n-    /// ```\n-    ///\n-    /// *Incorrect* usage of this method:\n-    ///\n-    /// ```rust,no_run\n-    /// #![feature(maybe_uninit_extra)]\n-    /// use std::mem::MaybeUninit;\n-    ///\n-    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n-    /// x.write(Some(vec![0,1,2]));\n-    /// let x1 = unsafe { x.read() };\n-    /// let x2 = unsafe { x.read() };\n-    /// // We now created two copies of the same vector, leading to a double-free when\n-    /// // they both get dropped!\n-    /// ```\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub unsafe fn read(&self) -> T {\n-        intrinsics::panic_if_uninhabited::<T>();\n-        self.as_ptr().read()\n-    }\n-\n-    /// Gets a reference to the contained value.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub unsafe fn get_ref(&self) -> &T {\n-        &*self.value\n-    }\n-\n-    /// Gets a mutable reference to the contained value.\n-    ///\n-    /// # Safety\n-    ///\n-    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n-    /// state. Calling this when the content is not yet fully initialized causes undefined\n-    /// behavior.\n-    // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n-    // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n-    // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub unsafe fn get_mut(&mut self) -> &mut T {\n-        &mut *self.value\n-    }\n-\n-    /// Gets a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n-        this as *const [MaybeUninit<T>] as *const T\n-    }\n-\n-    /// Gets a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n-    #[inline(always)]\n-    pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n-        this as *mut [MaybeUninit<T>] as *mut T\n-    }\n-}"}, {"sha": "3ad1223e331ece91ca1b996e2e87bcc94c3e5786", "filename": "src/libcore/mem/manually_drop.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,146 @@\n+use crate::ptr;\n+use crate::ops::{Deref, DerefMut};\n+\n+/// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n+///\n+/// This wrapper is 0-cost.\n+///\n+/// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n+/// As a consequence, it has *no effect* on the assumptions that the compiler makes\n+/// about all values being initialized at their type.  In particular, initializing\n+/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+/// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n+///\n+/// # Examples\n+///\n+/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n+/// the type:\n+///\n+/// ```rust\n+/// use std::mem::ManuallyDrop;\n+/// struct Peach;\n+/// struct Banana;\n+/// struct Melon;\n+/// struct FruitBox {\n+///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n+///     peach: ManuallyDrop<Peach>,\n+///     melon: Melon, // Field that\u2019s independent of the other two.\n+///     banana: ManuallyDrop<Banana>,\n+/// }\n+///\n+/// impl Drop for FruitBox {\n+///     fn drop(&mut self) {\n+///         unsafe {\n+///             // Explicit ordering in which field destructors are run specified in the intuitive\n+///             // location \u2013 the destructor of the structure containing the fields.\n+///             // Moreover, one can now reorder fields within the struct however much they want.\n+///             ManuallyDrop::drop(&mut self.peach);\n+///             ManuallyDrop::drop(&mut self.banana);\n+///         }\n+///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n+///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n+///     }\n+/// }\n+/// ```\n+///\n+/// [`mem::zeroed`]: fn.zeroed.html\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+#[lang = \"manually_drop\"]\n+#[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[repr(transparent)]\n+pub struct ManuallyDrop<T: ?Sized> {\n+    value: T,\n+}\n+\n+impl<T> ManuallyDrop<T> {\n+    /// Wrap a value to be manually dropped.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::mem::ManuallyDrop;\n+    /// ManuallyDrop::new(Box::new(()));\n+    /// ```\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline(always)]\n+    pub const fn new(value: T) -> ManuallyDrop<T> {\n+        ManuallyDrop { value }\n+    }\n+\n+    /// Extracts the value from the `ManuallyDrop` container.\n+    ///\n+    /// This allows the value to be dropped again.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// use std::mem::ManuallyDrop;\n+    /// let x = ManuallyDrop::new(Box::new(()));\n+    /// let _: Box<()> = ManuallyDrop::into_inner(x); // This drops the `Box`.\n+    /// ```\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline(always)]\n+    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {\n+        slot.value\n+    }\n+\n+    /// Takes the contained value out.\n+    ///\n+    /// This method is primarily intended for moving out values in drop.\n+    /// Instead of using [`ManuallyDrop::drop`] to manually drop the value,\n+    /// you can use this method to take the value and use it however desired.\n+    /// `Drop` will be invoked on the returned value following normal end-of-scope rules.\n+    ///\n+    /// If you have ownership of the container, you can use [`ManuallyDrop::into_inner`] instead.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function semantically moves out the contained value without preventing further usage.\n+    /// It is up to the user of this method to ensure that this container is not used again.\n+    ///\n+    /// [`ManuallyDrop::drop`]: #method.drop\n+    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n+    #[must_use = \"if you don't need the value, you can use `ManuallyDrop::drop` instead\"]\n+    #[unstable(feature = \"manually_drop_take\", issue = \"55422\")]\n+    #[inline]\n+    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {\n+        ManuallyDrop::into_inner(ptr::read(slot))\n+    }\n+}\n+\n+impl<T: ?Sized> ManuallyDrop<T> {\n+    /// Manually drops the contained value.\n+    ///\n+    /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function runs the destructor of the contained value and thus the wrapped value\n+    /// now represents uninitialized data. It is up to the user of this method to ensure the\n+    /// uninitialized data is not actually used.\n+    ///\n+    /// [`ManuallyDrop::into_inner`]: #method.into_inner\n+    #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+    #[inline]\n+    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n+        ptr::drop_in_place(&mut slot.value)\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: ?Sized> Deref for ManuallyDrop<T> {\n+    type Target = T;\n+    #[inline(always)]\n+    fn deref(&self) -> &T {\n+        &self.value\n+    }\n+}\n+\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+impl<T: ?Sized> DerefMut for ManuallyDrop<T> {\n+    #[inline(always)]\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut self.value\n+    }\n+}"}, {"sha": "eeff9d0303a3b83f8b96e3c10248ae8ea115a45b", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "added", "additions": 519, "deletions": 0, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,519 @@\n+use crate::intrinsics;\n+use crate::mem::ManuallyDrop;\n+\n+/// A wrapper type to construct uninitialized instances of `T`.\n+///\n+/// # Initialization invariant\n+///\n+/// The compiler, in general, assumes that variables are properly initialized\n+/// at their respective type. For example, a variable of reference type must\n+/// be aligned and non-NULL. This is an invariant that must *always* be upheld,\n+/// even in unsafe code. As a consequence, zero-initializing a variable of reference\n+/// type causes instantaneous [undefined behavior][ub], no matter whether that reference\n+/// ever gets used to access memory:\n+///\n+/// ```rust,no_run\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: &i32 = unsafe { mem::zeroed() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<&i32>`:\n+/// let x: &i32 = unsafe { MaybeUninit::zeroed().assume_init() }; // undefined behavior!\n+/// ```\n+///\n+/// This is exploited by the compiler for various optimizations, such as eliding\n+/// run-time checks and optimizing `enum` layout.\n+///\n+/// Similarly, entirely uninitialized memory may have any content, while a `bool` must\n+/// always be `true` or `false`. Hence, creating an uninitialized `bool` is undefined behavior:\n+///\n+/// ```rust,no_run\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let b: bool = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<bool>`:\n+/// let b: bool = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n+/// ```\n+///\n+/// Moreover, uninitialized memory is special in that the compiler knows that\n+/// it does not have a fixed value. This makes it undefined behavior to have\n+/// uninitialized data in a variable even if that variable has an integer type,\n+/// which otherwise can hold any *fixed* bit pattern:\n+///\n+/// ```rust,no_run\n+/// use std::mem::{self, MaybeUninit};\n+///\n+/// let x: i32 = unsafe { mem::uninitialized() }; // undefined behavior!\n+/// // The equivalent code with `MaybeUninit<i32>`:\n+/// let x: i32 = unsafe { MaybeUninit::uninit().assume_init() }; // undefined behavior!\n+/// ```\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n+///\n+/// On top of that, remember that most types have additional invariants beyond merely\n+/// being considered initialized at the type level. For example, a `1`-initialized [`Vec<T>`]\n+/// is considered initialized because the only requirement the compiler knows about it\n+/// is that the data pointer must be non-null. Creating such a `Vec<T>` does not cause\n+/// *immediate* undefined behavior, but will cause undefined behavior with most\n+/// safe operations (including dropping it).\n+///\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+///\n+/// # Examples\n+///\n+/// `MaybeUninit<T>` serves to enable unsafe code to deal with uninitialized data.\n+/// It is a signal to the compiler indicating that the data here might *not*\n+/// be initialized:\n+///\n+/// ```rust\n+/// use std::mem::MaybeUninit;\n+///\n+/// // Create an explicitly uninitialized reference. The compiler knows that data inside\n+/// // a `MaybeUninit<T>` may be invalid, and hence this is not UB:\n+/// let mut x = MaybeUninit::<&i32>::uninit();\n+/// // Set it to a valid value.\n+/// unsafe { x.as_mut_ptr().write(&0); }\n+/// // Extract the initialized data -- this is only allowed *after* properly\n+/// // initializing `x`!\n+/// let x = unsafe { x.assume_init() };\n+/// ```\n+///\n+/// The compiler then knows to not make any incorrect assumptions or optimizations on this code.\n+///\n+/// You can think of `MaybeUninit<T>` as being a bit like `Option<T>` but without\n+/// any of the run-time tracking and without any of the safety checks.\n+///\n+/// ## out-pointers\n+///\n+/// You can use `MaybeUninit<T>` to implement \"out-pointers\": instead of returning data\n+/// from a function, pass it a pointer to some (uninitialized) memory to put the\n+/// result into. This can be useful when it is important for the caller to control\n+/// how the memory the result is stored in gets allocated, and you want to avoid\n+/// unnecessary moves.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+///\n+/// unsafe fn make_vec(out: *mut Vec<i32>) {\n+///     // `write` does not drop the old contents, which is important.\n+///     out.write(vec![1, 2, 3]);\n+/// }\n+///\n+/// let mut v = MaybeUninit::uninit();\n+/// unsafe { make_vec(v.as_mut_ptr()); }\n+/// // Now we know `v` is initialized! This also makes sure the vector gets\n+/// // properly dropped.\n+/// let v = unsafe { v.assume_init() };\n+/// assert_eq!(&v, &[1, 2, 3]);\n+/// ```\n+///\n+/// ## Initializing an array element-by-element\n+///\n+/// `MaybeUninit<T>` can be used to initialize a large array element-by-element:\n+///\n+/// ```\n+/// use std::mem::{self, MaybeUninit};\n+/// use std::ptr;\n+///\n+/// let data = {\n+///     // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+///     // safe because the type we are claiming to have initialized here is a\n+///     // bunch of `MaybeUninit`s, which do not require initialization.\n+///     let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {\n+///         MaybeUninit::uninit().assume_init()\n+///     };\n+///\n+///     // Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,\n+///     // we have a memory leak, but there is no memory safety issue.\n+///     for elem in &mut data[..] {\n+///         unsafe { ptr::write(elem.as_mut_ptr(), vec![42]); }\n+///     }\n+///\n+///     // Everything is initialized. Transmute the array to the\n+///     // initialized type.\n+///     unsafe { mem::transmute::<_, [Vec<u32>; 1000]>(data) }\n+/// };\n+///\n+/// assert_eq!(&data[0], &[42]);\n+/// ```\n+///\n+/// You can also work with partially initialized arrays, which could\n+/// be found in low-level datastructures.\n+///\n+/// ```\n+/// use std::mem::MaybeUninit;\n+/// use std::ptr;\n+///\n+/// // Create an uninitialized array of `MaybeUninit`. The `assume_init` is\n+/// // safe because the type we are claiming to have initialized here is a\n+/// // bunch of `MaybeUninit`s, which do not require initialization.\n+/// let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };\n+/// // Count the number of elements we have assigned.\n+/// let mut data_len: usize = 0;\n+///\n+/// for elem in &mut data[0..500] {\n+///     unsafe { ptr::write(elem.as_mut_ptr(), String::from(\"hello\")); }\n+///     data_len += 1;\n+/// }\n+///\n+/// // For each item in the array, drop if we allocated it.\n+/// for elem in &mut data[0..data_len] {\n+///     unsafe { ptr::drop_in_place(elem.as_mut_ptr()); }\n+/// }\n+/// ```\n+///\n+/// ## Initializing a struct field-by-field\n+///\n+/// There is currently no supported way to create a raw pointer or reference\n+/// to a field of a struct inside `MaybeUninit<Struct>`. That means it is not possible\n+/// to create a struct by calling `MaybeUninit::uninit::<Struct>()` and then writing\n+/// to its fields.\n+///\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+///\n+/// # Layout\n+///\n+/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n+///\n+/// ```rust\n+/// use std::mem::{MaybeUninit, size_of, align_of};\n+/// assert_eq!(size_of::<MaybeUninit<u64>>(), size_of::<u64>());\n+/// assert_eq!(align_of::<MaybeUninit<u64>>(), align_of::<u64>());\n+/// ```\n+///\n+/// However remember that a type *containing* a `MaybeUninit<T>` is not necessarily the same\n+/// layout; Rust does not in general guarantee that the fields of a `Foo<T>` have the same order as\n+/// a `Foo<U>` even if `T` and `U` have the same size and alignment. Furthermore because any bit\n+/// value is valid for a `MaybeUninit<T>` the compiler can't apply non-zero/niche-filling\n+/// optimizations, potentially resulting in a larger size:\n+///\n+/// ```rust\n+/// # use std::mem::{MaybeUninit, size_of};\n+/// assert_eq!(size_of::<Option<bool>>(), 1);\n+/// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n+/// ```\n+#[allow(missing_debug_implementations)]\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+#[derive(Copy)]\n+pub union MaybeUninit<T> {\n+    uninit: (),\n+    value: ManuallyDrop<T>,\n+}\n+\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+impl<T: Copy> Clone for MaybeUninit<T> {\n+    #[inline(always)]\n+    fn clone(&self) -> Self {\n+        // Not calling `T::clone()`, we cannot know if we are initialized enough for that.\n+        *self\n+    }\n+}\n+\n+impl<T> MaybeUninit<T> {\n+    /// Creates a new `MaybeUninit<T>` initialized with the given value.\n+    /// It is safe to call [`assume_init`] on the return value of this function.\n+    ///\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// [`assume_init`]: #method.assume_init\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub const fn new(val: T) -> MaybeUninit<T> {\n+        MaybeUninit { value: ManuallyDrop::new(val) }\n+    }\n+\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state.\n+    ///\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// See the [type-level documentation][type] for some examples.\n+    ///\n+    /// [type]: union.MaybeUninit.html\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub const fn uninit() -> MaybeUninit<T> {\n+        MaybeUninit { uninit: () }\n+    }\n+\n+    /// Creates a new `MaybeUninit<T>` in an uninitialized state, with the memory being\n+    /// filled with `0` bytes. It depends on `T` whether that already makes for\n+    /// proper initialization. For example, `MaybeUninit<usize>::zeroed()` is initialized,\n+    /// but `MaybeUninit<&'static i32>::zeroed()` is not because references must not\n+    /// be null.\n+    ///\n+    /// Note that dropping a `MaybeUninit<T>` will never call `T`'s drop code.\n+    /// It is your responsibility to make sure `T` gets dropped if it got initialized.\n+    ///\n+    /// # Example\n+    ///\n+    /// Correct usage of this function: initializing a struct with zero, where all\n+    /// fields of the struct can hold the bit-pattern 0 as a valid value.\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<(u8, bool)>::zeroed();\n+    /// let x = unsafe { x.assume_init() };\n+    /// assert_eq!(x, (0, false));\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this function: initializing a struct with zero, where some fields\n+    /// cannot hold 0 as a valid value.\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// enum NotZero { One = 1, Two = 2 };\n+    ///\n+    /// let x = MaybeUninit::<(u8, NotZero)>::zeroed();\n+    /// let x = unsafe { x.assume_init() };\n+    /// // Inside a pair, we create a `NotZero` that does not have a valid discriminant.\n+    /// // This is undefined behavior.\n+    /// ```\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline]\n+    pub fn zeroed() -> MaybeUninit<T> {\n+        let mut u = MaybeUninit::<T>::uninit();\n+        unsafe {\n+            u.as_mut_ptr().write_bytes(0u8, 1);\n+        }\n+        u\n+    }\n+\n+    /// Sets the value of the `MaybeUninit<T>`. This overwrites any previous value\n+    /// without dropping it, so be careful not to use this twice unless you want to\n+    /// skip running the destructor. For your convenience, this also returns a mutable\n+    /// reference to the (now safely initialized) contents of `self`.\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn write(&mut self, val: T) -> &mut T {\n+        unsafe {\n+            self.value = ManuallyDrop::new(val);\n+            self.get_mut()\n+        }\n+    }\n+\n+    /// Gets a pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    /// Writing to memory that this pointer (non-transitively) points to is undefined behavior\n+    /// (except inside an `UnsafeCell<T>`).\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<T>`. This is okay because we initialized it.\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// assert_eq!(x_vec.len(), 3);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_vec = unsafe { &*x.as_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    ///\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub fn as_ptr(&self) -> *const T {\n+        unsafe { &*self.value as *const T }\n+    }\n+\n+    /// Gets a mutable pointer to the contained value. Reading from this pointer or turning it\n+    /// into a reference is undefined behavior unless the `MaybeUninit<T>` is initialized.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// unsafe { x.as_mut_ptr().write(vec![0,1,2]); }\n+    /// // Create a reference into the `MaybeUninit<Vec<u32>>`.\n+    /// // This is okay because we initialized it.\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// x_vec.push(3);\n+    /// assert_eq!(x_vec.len(), 4);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_vec = unsafe { &mut *x.as_mut_ptr() };\n+    /// // We have created a reference to an uninitialized vector! This is undefined behavior.\n+    /// ```\n+    ///\n+    /// (Notice that the rules around references to uninitialized data are not finalized yet, but\n+    /// until they are, it is advisable to avoid them.)\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        unsafe { &mut *self.value as *mut T }\n+    }\n+\n+    /// Extracts the value from the `MaybeUninit<T>` container. This is a great way\n+    /// to ensure that the data will get dropped, because the resulting `T` is\n+    /// subject to the usual drop handling.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes immediate undefined\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n+    ///\n+    /// [inv]: #initialization-invariant\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<bool>::uninit();\n+    /// unsafe { x.as_mut_ptr().write(true); }\n+    /// let x_init = unsafe { x.assume_init() };\n+    /// assert_eq!(x_init, true);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let x = MaybeUninit::<Vec<u32>>::uninit();\n+    /// let x_init = unsafe { x.assume_init() };\n+    /// // `x` had not been initialized yet, so this last line caused undefined behavior.\n+    /// ```\n+    #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+    #[inline(always)]\n+    pub unsafe fn assume_init(self) -> T {\n+        intrinsics::panic_if_uninhabited::<T>();\n+        ManuallyDrop::into_inner(self.value)\n+    }\n+\n+    /// Reads the value from the `MaybeUninit<T>` container. The resulting `T` is subject\n+    /// to the usual drop handling.\n+    ///\n+    /// Whenever possible, it is preferrable to use [`assume_init`] instead, which\n+    /// prevents duplicating the content of the `MaybeUninit<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior. The [type-level documentation][inv] contains more information about\n+    /// this initialization invariant.\n+    ///\n+    /// Moreover, this leaves a copy of the same data behind in the `MaybeUninit<T>`. When using\n+    /// multiple copies of the data (by calling `read` multiple times, or first\n+    /// calling `read` and then [`assume_init`]), it is your responsibility\n+    /// to ensure that that data may indeed be duplicated.\n+    ///\n+    /// [inv]: #initialization-invariant\n+    /// [`assume_init`]: #method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// Correct usage of this method:\n+    ///\n+    /// ```rust\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<u32>::uninit();\n+    /// x.write(13);\n+    /// let x1 = unsafe { x.read() };\n+    /// // `u32` is `Copy`, so we may read multiple times.\n+    /// let x2 = unsafe { x.read() };\n+    /// assert_eq!(x1, x2);\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n+    /// x.write(None);\n+    /// let x1 = unsafe { x.read() };\n+    /// // Duplicating a `None` value is okay, so we may read multiple times.\n+    /// let x2 = unsafe { x.read() };\n+    /// assert_eq!(x1, x2);\n+    /// ```\n+    ///\n+    /// *Incorrect* usage of this method:\n+    ///\n+    /// ```rust,no_run\n+    /// #![feature(maybe_uninit_extra)]\n+    /// use std::mem::MaybeUninit;\n+    ///\n+    /// let mut x = MaybeUninit::<Option<Vec<u32>>>::uninit();\n+    /// x.write(Some(vec![0,1,2]));\n+    /// let x1 = unsafe { x.read() };\n+    /// let x2 = unsafe { x.read() };\n+    /// // We now created two copies of the same vector, leading to a double-free when\n+    /// // they both get dropped!\n+    /// ```\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn read(&self) -> T {\n+        intrinsics::panic_if_uninhabited::<T>();\n+        self.as_ptr().read()\n+    }\n+\n+    /// Gets a reference to the contained value.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn get_ref(&self) -> &T {\n+        &*self.value\n+    }\n+\n+    /// Gets a mutable reference to the contained value.\n+    ///\n+    /// # Safety\n+    ///\n+    /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n+    /// state. Calling this when the content is not yet fully initialized causes undefined\n+    /// behavior.\n+    // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n+    // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n+    // a final decision about the rules before stabilization.\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub unsafe fn get_mut(&mut self) -> &mut T {\n+        &mut *self.value\n+    }\n+\n+    /// Gets a pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n+        this as *const [MaybeUninit<T>] as *const T\n+    }\n+\n+    /// Gets a mutable pointer to the first element of the array.\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[inline(always)]\n+    pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n+        this as *mut [MaybeUninit<T>] as *mut T\n+    }\n+}"}, {"sha": "91449f09936aa2597487e6f5aa10e3cb1893df3b", "filename": "src/libcore/mem/mod.rs", "status": "added", "additions": 752, "deletions": 0, "changes": 752, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,752 @@\n+//! Basic functions for dealing with memory.\n+//!\n+//! This module contains functions for querying the size and alignment of\n+//! types, initializing and manipulating memory.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+use crate::clone;\n+use crate::cmp;\n+use crate::fmt;\n+use crate::hash;\n+use crate::intrinsics;\n+use crate::marker::{Copy, PhantomData, Sized};\n+use crate::ptr;\n+\n+mod manually_drop;\n+#[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n+pub use manually_drop::ManuallyDrop;\n+\n+mod maybe_uninit;\n+#[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n+pub use maybe_uninit::MaybeUninit;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[doc(inline)]\n+pub use crate::intrinsics::transmute;\n+\n+/// Takes ownership and \"forgets\" about the value **without running its destructor**.\n+///\n+/// Any resources the value manages, such as heap memory or a file handle, will linger\n+/// forever in an unreachable state. However, it does not guarantee that pointers\n+/// to this memory will remain valid.\n+///\n+/// * If you want to leak memory, see [`Box::leak`][leak].\n+/// * If you want to obtain a raw pointer to the memory, see [`Box::into_raw`][into_raw].\n+/// * If you want to dispose of a value properly, running its destructor, see\n+/// [`mem::drop`][drop].\n+///\n+/// # Safety\n+///\n+/// `forget` is not marked as `unsafe`, because Rust's safety guarantees\n+/// do not include a guarantee that destructors will always run. For example,\n+/// a program can create a reference cycle using [`Rc`][rc], or call\n+/// [`process::exit`][exit] to exit without running destructors. Thus, allowing\n+/// `mem::forget` from safe code does not fundamentally change Rust's safety\n+/// guarantees.\n+///\n+/// That said, leaking resources such as memory or I/O objects is usually undesirable,\n+/// so `forget` is only recommended for specialized use cases like those shown below.\n+///\n+/// Because forgetting a value is allowed, any `unsafe` code you write must\n+/// allow for this possibility. You cannot return a value and expect that the\n+/// caller will necessarily run the value's destructor.\n+///\n+/// [rc]: ../../std/rc/struct.Rc.html\n+/// [exit]: ../../std/process/fn.exit.html\n+///\n+/// # Examples\n+///\n+/// Leak an I/O object, never closing the file:\n+///\n+/// ```no_run\n+/// use std::mem;\n+/// use std::fs::File;\n+///\n+/// let file = File::open(\"foo.txt\").unwrap();\n+/// mem::forget(file);\n+/// ```\n+///\n+/// The practical use cases for `forget` are rather specialized and mainly come\n+/// up in unsafe or FFI code.\n+///\n+/// [drop]: fn.drop.html\n+/// [uninit]: fn.uninitialized.html\n+/// [clone]: ../clone/trait.Clone.html\n+/// [swap]: fn.swap.html\n+/// [box]: ../../std/boxed/struct.Box.html\n+/// [leak]: ../../std/boxed/struct.Box.html#method.leak\n+/// [into_raw]: ../../std/boxed/struct.Box.html#method.into_raw\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn forget<T>(t: T) {\n+    ManuallyDrop::new(t);\n+}\n+\n+/// Like [`forget`], but also accepts unsized values.\n+///\n+/// This function is just a shim intended to be removed when the `unsized_locals` feature gets\n+/// stabilized.\n+///\n+/// [`forget`]: fn.forget.html\n+#[inline]\n+#[unstable(feature = \"forget_unsized\", issue = \"0\")]\n+pub fn forget_unsized<T: ?Sized>(t: T) {\n+    unsafe { intrinsics::forget(t) }\n+}\n+\n+/// Returns the size of a type in bytes.\n+///\n+/// More specifically, this is the offset in bytes between successive elements\n+/// in an array with that item type including alignment padding. Thus, for any\n+/// type `T` and length `n`, `[T; n]` has a size of `n * size_of::<T>()`.\n+///\n+/// In general, the size of a type is not stable across compilations, but\n+/// specific types such as primitives are.\n+///\n+/// The following table gives the size for primitives.\n+///\n+/// Type | size_of::\\<Type>()\n+/// ---- | ---------------\n+/// () | 0\n+/// bool | 1\n+/// u8 | 1\n+/// u16 | 2\n+/// u32 | 4\n+/// u64 | 8\n+/// u128 | 16\n+/// i8 | 1\n+/// i16 | 2\n+/// i32 | 4\n+/// i64 | 8\n+/// i128 | 16\n+/// f32 | 4\n+/// f64 | 8\n+/// char | 4\n+///\n+/// Furthermore, `usize` and `isize` have the same size.\n+///\n+/// The types `*const T`, `&T`, `Box<T>`, `Option<&T>`, and `Option<Box<T>>` all have\n+/// the same size. If `T` is Sized, all of those types have the same size as `usize`.\n+///\n+/// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n+/// have the same size. Likewise for `*const T` and `*mut T`.\n+///\n+/// # Size of `#[repr(C)]` items\n+///\n+/// The `C` representation for items has a defined layout. With this layout,\n+/// the size of items is also stable as long as all fields have a stable size.\n+///\n+/// ## Size of Structs\n+///\n+/// For `structs`, the size is determined by the following algorithm.\n+///\n+/// For each field in the struct ordered by declaration order:\n+///\n+/// 1. Add the size of the field.\n+/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n+///\n+/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n+/// The alignment of the struct is usually the largest alignment of all its\n+/// fields; this can be changed with the use of `repr(align(N))`.\n+///\n+/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n+///\n+/// ## Size of Enums\n+///\n+/// Enums that carry no data other than the discriminant have the same size as C enums\n+/// on the platform they are compiled for.\n+///\n+/// ## Size of Unions\n+///\n+/// The size of a union is the size of its largest field.\n+///\n+/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// // Some primitives\n+/// assert_eq!(4, mem::size_of::<i32>());\n+/// assert_eq!(8, mem::size_of::<f64>());\n+/// assert_eq!(0, mem::size_of::<()>());\n+///\n+/// // Some arrays\n+/// assert_eq!(8, mem::size_of::<[i32; 2]>());\n+/// assert_eq!(12, mem::size_of::<[i32; 3]>());\n+/// assert_eq!(0, mem::size_of::<[i32; 0]>());\n+///\n+///\n+/// // Pointer size equality\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<*const i32>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Box<i32>>());\n+/// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n+/// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n+/// ```\n+///\n+/// Using `#[repr(C)]`.\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// #[repr(C)]\n+/// struct FieldStruct {\n+///     first: u8,\n+///     second: u16,\n+///     third: u8\n+/// }\n+///\n+/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n+/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n+/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n+/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n+/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n+/// // Finally, the alignment of the struct is 2 (because the largest alignment amongst its\n+/// // fields is 2), so add 1 to the size for padding. Size is 6.\n+/// assert_eq!(6, mem::size_of::<FieldStruct>());\n+///\n+/// #[repr(C)]\n+/// struct TupleStruct(u8, u16, u8);\n+///\n+/// // Tuple structs follow the same rules.\n+/// assert_eq!(6, mem::size_of::<TupleStruct>());\n+///\n+/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n+/// // by putting `third` before `second`.\n+/// #[repr(C)]\n+/// struct FieldStructOptimized {\n+///     first: u8,\n+///     third: u8,\n+///     second: u16\n+/// }\n+///\n+/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n+///\n+/// // Union size is the size of the largest field.\n+/// #[repr(C)]\n+/// union ExampleUnion {\n+///     smaller: u8,\n+///     larger: u16\n+/// }\n+///\n+/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n+/// ```\n+///\n+/// [alignment]: ./fn.align_of.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_promotable]\n+pub const fn size_of<T>() -> usize {\n+    intrinsics::size_of::<T>()\n+}\n+\n+/// Returns the size of the pointed-to value in bytes.\n+///\n+/// This is usually the same as `size_of::<T>()`. However, when `T` *has* no\n+/// statically-known size, e.g., a slice [`[T]`][slice] or a [trait object],\n+/// then `size_of_val` can be used to get the dynamically-known size.\n+///\n+/// [slice]: ../../std/primitive.slice.html\n+/// [trait object]: ../../book/ch17-02-trait-objects.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::size_of_val(&5i32));\n+///\n+/// let x: [u8; 13] = [0; 13];\n+/// let y: &[u8] = &x;\n+/// assert_eq!(13, mem::size_of_val(y));\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn size_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::size_of_val(val) }\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![allow(deprecated)]\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of::<i32>());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(reason = \"use `align_of` instead\", since = \"1.2.0\")]\n+pub fn min_align_of<T>() -> usize {\n+    intrinsics::min_align_of::<T>()\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![allow(deprecated)]\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::min_align_of_val(&5i32));\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(reason = \"use `align_of_val` instead\", since = \"1.2.0\")]\n+pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of a type.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// This is the alignment used for struct fields. It may be smaller than the preferred alignment.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of::<i32>());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_promotable]\n+pub const fn align_of<T>() -> usize {\n+    intrinsics::min_align_of::<T>()\n+}\n+\n+/// Returns the [ABI]-required minimum alignment of the type of the value that `val` points to.\n+///\n+/// Every reference to a value of the type `T` must be a multiple of this number.\n+///\n+/// [ABI]: https://en.wikipedia.org/wiki/Application_binary_interface\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// assert_eq!(4, mem::align_of_val(&5i32));\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn align_of_val<T: ?Sized>(val: &T) -> usize {\n+    unsafe { intrinsics::min_align_of_val(val) }\n+}\n+\n+/// Returns `true` if dropping values of type `T` matters.\n+///\n+/// This is purely an optimization hint, and may be implemented conservatively:\n+/// it may return `true` for types that don't actually need to be dropped.\n+/// As such always returning `true` would be a valid implementation of\n+/// this function. However if this function actually returns `false`, then you\n+/// can be certain dropping `T` has no side effect.\n+///\n+/// Low level implementations of things like collections, which need to manually\n+/// drop their data, should use this function to avoid unnecessarily\n+/// trying to drop all their contents when they are destroyed. This might not\n+/// make a difference in release builds (where a loop that has no side-effects\n+/// is easily detected and eliminated), but is often a big win for debug builds.\n+///\n+/// Note that `ptr::drop_in_place` already performs this check, so if your workload\n+/// can be reduced to some small number of drop_in_place calls, using this is\n+/// unnecessary. In particular note that you can drop_in_place a slice, and that\n+/// will do a single needs_drop check for all the values.\n+///\n+/// Types like Vec therefore just `drop_in_place(&mut self[..])` without using\n+/// needs_drop explicitly. Types like HashMap, on the other hand, have to drop\n+/// values one at a time and should use this API.\n+///\n+///\n+/// # Examples\n+///\n+/// Here's an example of how a collection might make use of needs_drop:\n+///\n+/// ```\n+/// use std::{mem, ptr};\n+///\n+/// pub struct MyCollection<T> {\n+/// #   data: [T; 1],\n+///     /* ... */\n+/// }\n+/// # impl<T> MyCollection<T> {\n+/// #   fn iter_mut(&mut self) -> &mut [T] { &mut self.data }\n+/// #   fn free_buffer(&mut self) {}\n+/// # }\n+///\n+/// impl<T> Drop for MyCollection<T> {\n+///     fn drop(&mut self) {\n+///         unsafe {\n+///             // drop the data\n+///             if mem::needs_drop::<T>() {\n+///                 for x in self.iter_mut() {\n+///                     ptr::drop_in_place(x);\n+///                 }\n+///             }\n+///             self.free_buffer();\n+///         }\n+///     }\n+/// }\n+/// ```\n+#[inline]\n+#[stable(feature = \"needs_drop\", since = \"1.21.0\")]\n+pub const fn needs_drop<T>() -> bool {\n+    intrinsics::needs_drop::<T>()\n+}\n+\n+/// Creates a value whose bytes are all zero.\n+///\n+/// This has the same effect as [`MaybeUninit::zeroed().assume_init()`][zeroed].\n+/// It is useful for FFI sometimes, but should generally be avoided.\n+///\n+/// There is no guarantee that an all-zero byte-pattern represents a valid value of\n+/// some type `T`. For example, the all-zero byte-pattern is not a valid value\n+/// for reference types (`&T` and `&mut T`). Using `zeroed` on such types\n+/// causes immediate [undefined behavior][ub] because [the Rust compiler assumes][inv]\n+/// that there always is a valid value in a variable it considers initialized.\n+///\n+/// [zeroed]: union.MaybeUninit.html#method.zeroed\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n+///\n+/// # Examples\n+///\n+/// Correct usage of this function: initializing an integer with zero.\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let x: i32 = unsafe { mem::zeroed() };\n+/// assert_eq!(0, x);\n+/// ```\n+///\n+/// *Incorrect* usage of this function: initializing a reference with zero.\n+///\n+/// ```no_run\n+/// use std::mem;\n+///\n+/// let _x: &i32 = unsafe { mem::zeroed() }; // Undefined behavior!\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn zeroed<T>() -> T {\n+    intrinsics::panic_if_uninhabited::<T>();\n+    intrinsics::init()\n+}\n+\n+/// Bypasses Rust's normal memory-initialization checks by pretending to\n+/// produce a value of type `T`, while doing nothing at all.\n+///\n+/// **This functon is deprecated.** Use [`MaybeUninit<T>`] instead.\n+///\n+/// The reason for deprecation is that the function basically cannot be used\n+/// correctly: [the Rust compiler assumes][inv] that values are properly initialized.\n+/// As a consequence, calling e.g. `mem::uninitialized::<bool>()` causes immediate\n+/// undefined behavior for returning a `bool` that is not definitely either `true`\n+/// or `false`. Worse, truly uninitialized memory like what gets returned here\n+/// is special in that the compiler knows that it does not have a fixed value.\n+/// This makes it undefined behavior to have uninitialized data in a variable even\n+/// if that variable has an integer type.\n+/// (Notice that the rules around uninitialized integers are not finalized yet, but\n+/// until they are, it is advisable to avoid them.)\n+///\n+/// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+/// [inv]: union.MaybeUninit.html#initialization-invariant\n+#[inline]\n+#[rustc_deprecated(since = \"1.38.0\", reason = \"use `mem::MaybeUninit` instead\")]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn uninitialized<T>() -> T {\n+    intrinsics::panic_if_uninhabited::<T>();\n+    intrinsics::uninit()\n+}\n+\n+/// Swaps the values at two mutable locations, without deinitializing either one.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut x = 5;\n+/// let mut y = 42;\n+///\n+/// mem::swap(&mut x, &mut y);\n+///\n+/// assert_eq!(42, x);\n+/// assert_eq!(5, y);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn swap<T>(x: &mut T, y: &mut T) {\n+    unsafe {\n+        ptr::swap_nonoverlapping_one(x, y);\n+    }\n+}\n+\n+/// Moves `src` into the referenced `dest`, returning the previous `dest` value.\n+///\n+/// Neither value is dropped.\n+///\n+/// # Examples\n+///\n+/// A simple example:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// let mut v: Vec<i32> = vec![1, 2];\n+///\n+/// let old_v = mem::replace(&mut v, vec![3, 4, 5]);\n+/// assert_eq!(vec![1, 2], old_v);\n+/// assert_eq!(vec![3, 4, 5], v);\n+/// ```\n+///\n+/// `replace` allows consumption of a struct field by replacing it with another value.\n+/// Without `replace` you can run into issues like these:\n+///\n+/// ```compile_fail,E0507\n+/// struct Buffer<T> { buf: Vec<T> }\n+///\n+/// impl<T> Buffer<T> {\n+///     fn get_and_reset(&mut self) -> Vec<T> {\n+///         // error: cannot move out of dereference of `&mut`-pointer\n+///         let buf = self.buf;\n+///         self.buf = Vec::new();\n+///         buf\n+///     }\n+/// }\n+/// ```\n+///\n+/// Note that `T` does not necessarily implement [`Clone`], so it can't even clone and reset\n+/// `self.buf`. But `replace` can be used to disassociate the original value of `self.buf` from\n+/// `self`, allowing it to be returned:\n+///\n+/// ```\n+/// # #![allow(dead_code)]\n+/// use std::mem;\n+///\n+/// # struct Buffer<T> { buf: Vec<T> }\n+/// impl<T> Buffer<T> {\n+///     fn get_and_reset(&mut self) -> Vec<T> {\n+///         mem::replace(&mut self.buf, Vec::new())\n+///     }\n+/// }\n+/// ```\n+///\n+/// [`Clone`]: ../../std/clone/trait.Clone.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn replace<T>(dest: &mut T, mut src: T) -> T {\n+    swap(dest, &mut src);\n+    src\n+}\n+\n+/// Disposes of a value.\n+///\n+/// This does call the argument's implementation of [`Drop`][drop].\n+///\n+/// This effectively does nothing for types which implement `Copy`, e.g.\n+/// integers. Such values are copied and _then_ moved into the function, so the\n+/// value persists after this function call.\n+///\n+/// This function is not magic; it is literally defined as\n+///\n+/// ```\n+/// pub fn drop<T>(_x: T) { }\n+/// ```\n+///\n+/// Because `_x` is moved into the function, it is automatically dropped before\n+/// the function returns.\n+///\n+/// [drop]: ../ops/trait.Drop.html\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// let v = vec![1, 2, 3];\n+///\n+/// drop(v); // explicitly drop the vector\n+/// ```\n+///\n+/// Since [`RefCell`] enforces the borrow rules at runtime, `drop` can\n+/// release a [`RefCell`] borrow:\n+///\n+/// ```\n+/// use std::cell::RefCell;\n+///\n+/// let x = RefCell::new(1);\n+///\n+/// let mut mutable_borrow = x.borrow_mut();\n+/// *mutable_borrow = 1;\n+///\n+/// drop(mutable_borrow); // relinquish the mutable borrow on this slot\n+///\n+/// let borrow = x.borrow();\n+/// println!(\"{}\", *borrow);\n+/// ```\n+///\n+/// Integers and other types implementing [`Copy`] are unaffected by `drop`.\n+///\n+/// ```\n+/// #[derive(Copy, Clone)]\n+/// struct Foo(u8);\n+///\n+/// let x = 1;\n+/// let y = Foo(2);\n+/// drop(x); // a copy of `x` is moved and dropped\n+/// drop(y); // a copy of `y` is moved and dropped\n+///\n+/// println!(\"x: {}, y: {}\", x, y.0); // still available\n+/// ```\n+///\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`Copy`]: ../../std/marker/trait.Copy.html\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn drop<T>(_x: T) { }\n+\n+/// Interprets `src` as having type `&U`, and then reads `src` without moving\n+/// the contained value.\n+///\n+/// This function will unsafely assume the pointer `src` is valid for\n+/// [`size_of::<U>`][size_of] bytes by transmuting `&T` to `&U` and then reading\n+/// the `&U`. It will also unsafely create a copy of the contained value instead of\n+/// moving out of `src`.\n+///\n+/// It is not a compile-time error if `T` and `U` have different sizes, but it\n+/// is highly encouraged to only invoke this function where `T` and `U` have the\n+/// same size. This function triggers [undefined behavior][ub] if `U` is larger than\n+/// `T`.\n+///\n+/// [ub]: ../../reference/behavior-considered-undefined.html\n+/// [size_of]: fn.size_of.html\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// #[repr(packed)]\n+/// struct Foo {\n+///     bar: u8,\n+/// }\n+///\n+/// let foo_slice = [10u8];\n+///\n+/// unsafe {\n+///     // Copy the data from 'foo_slice' and treat it as a 'Foo'\n+///     let mut foo_struct: Foo = mem::transmute_copy(&foo_slice);\n+///     assert_eq!(foo_struct.bar, 10);\n+///\n+///     // Modify the copied data\n+///     foo_struct.bar = 20;\n+///     assert_eq!(foo_struct.bar, 20);\n+/// }\n+///\n+/// // The contents of 'foo_slice' should not have changed\n+/// assert_eq!(foo_slice, [10]);\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    ptr::read_unaligned(src as *const T as *const U)\n+}\n+\n+/// Opaque type representing the discriminant of an enum.\n+///\n+/// See the [`discriminant`] function in this module for more information.\n+///\n+/// [`discriminant`]: fn.discriminant.html\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+pub struct Discriminant<T>(u64, PhantomData<fn() -> T>);\n+\n+// N.B. These trait implementations cannot be derived because we don't want any bounds on T.\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> Copy for Discriminant<T> {}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> clone::Clone for Discriminant<T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> cmp::PartialEq for Discriminant<T> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.0 == rhs.0\n+    }\n+}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> cmp::Eq for Discriminant<T> {}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> hash::Hash for Discriminant<T> {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.0.hash(state);\n+    }\n+}\n+\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+impl<T> fmt::Debug for Discriminant<T> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt.debug_tuple(\"Discriminant\")\n+           .field(&self.0)\n+           .finish()\n+    }\n+}\n+\n+/// Returns a value uniquely identifying the enum variant in `v`.\n+///\n+/// If `T` is not an enum, calling this function will not result in undefined behavior, but the\n+/// return value is unspecified.\n+///\n+/// # Stability\n+///\n+/// The discriminant of an enum variant may change if the enum definition changes. A discriminant\n+/// of some variant will not change between compilations with the same compiler.\n+///\n+/// # Examples\n+///\n+/// This can be used to compare enums that carry data, while disregarding\n+/// the actual data:\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// enum Foo { A(&'static str), B(i32), C(i32) }\n+///\n+/// assert!(mem::discriminant(&Foo::A(\"bar\")) == mem::discriminant(&Foo::A(\"baz\")));\n+/// assert!(mem::discriminant(&Foo::B(1))     == mem::discriminant(&Foo::B(2)));\n+/// assert!(mem::discriminant(&Foo::B(3))     != mem::discriminant(&Foo::C(3)));\n+/// ```\n+#[stable(feature = \"discriminant_value\", since = \"1.21.0\")]\n+pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n+    unsafe {\n+        Discriminant(intrinsics::discriminant_value(v), PhantomData)\n+    }\n+}"}, {"sha": "593a09b6866dbb8335b58c42b5be149941b1bf64", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -170,16 +170,11 @@ pub enum Set1<T> {\n \n impl<T: PartialEq> Set1<T> {\n     pub fn insert(&mut self, value: T) {\n-        if let Set1::Empty = *self {\n-            *self = Set1::One(value);\n-            return;\n-        }\n-        if let Set1::One(ref old) = *self {\n-            if *old == value {\n-                return;\n-            }\n-        }\n-        *self = Set1::Many;\n+        *self = match self {\n+            Set1::Empty => Set1::One(value),\n+            Set1::One(old) if *old == value => return,\n+            _ => Set1::Many,\n+        };\n     }\n }\n "}, {"sha": "f989ebc6dfd8e0210c707e4523b7a550f176b64f", "filename": "src/librustc_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2FCargo.toml?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -8,7 +8,7 @@ edition = \"2018\"\n proc-macro = true\n \n [dependencies]\n-synstructure = \"0.10.1\"\n+synstructure = \"0.10.2\"\n syn = { version = \"0.15.22\", features = [\"full\"] }\n proc-macro2 = \"0.4.24\"\n quote = \"0.6.10\""}, {"sha": "e3a79b24cabe8c5cfebe606fa5fa107d60e89a38", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -595,12 +595,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) -> (String, String, String, String) {\n         // Define a small closure that we can use to check if the type of a place\n         // is a union.\n-        let is_union = |place: &Place<'tcx>| -> bool {\n-            place.ty(self.mir, self.infcx.tcx).ty\n-                .ty_adt_def()\n-                .map(|adt| adt.is_union())\n-                .unwrap_or(false)\n+        let union_ty = |place: &Place<'tcx>| -> Option<Ty<'tcx>> {\n+            let ty = place.ty(self.mir, self.infcx.tcx).ty;\n+            ty.ty_adt_def().filter(|adt| adt.is_union()).map(|_| ty)\n         };\n+        let describe_place = |place| self.describe_place(place).unwrap_or_else(|| \"_\".to_owned());\n \n         // Start with an empty tuple, so we can use the functions on `Option` to reduce some\n         // code duplication (particularly around returning an empty description in the failure\n@@ -619,7 +618,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let mut current = first_borrowed_place;\n                 while let Place::Projection(box Projection { base, elem }) = current {\n                     match elem {\n-                        ProjectionElem::Field(field, _) if is_union(base) => {\n+                        ProjectionElem::Field(field, _) if union_ty(base).is_some() => {\n                             return Some((base, field));\n                         },\n                         _ => current = base,\n@@ -632,34 +631,32 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // borrowed place and look for a access to a different field of the same union.\n                 let mut current = second_borrowed_place;\n                 while let Place::Projection(box Projection { base, elem }) = current {\n-                    match elem {\n-                        ProjectionElem::Field(field, _) if {\n-                            is_union(base) && field != target_field && base == target_base\n-                        } => {\n-                            let desc_base = self.describe_place(base)\n-                                .unwrap_or_else(|| \"_\".to_owned());\n-                            let desc_first = self.describe_place(first_borrowed_place)\n-                                .unwrap_or_else(|| \"_\".to_owned());\n-                            let desc_second = self.describe_place(second_borrowed_place)\n-                                .unwrap_or_else(|| \"_\".to_owned());\n-\n-                            // Also compute the name of the union type, eg. `Foo` so we\n-                            // can add a helpful note with it.\n-                            let ty = base.ty(self.mir, self.infcx.tcx).ty;\n-\n-                            return Some((desc_base, desc_first, desc_second, ty.to_string()));\n-                        },\n-                        _ => current = base,\n+                    if let ProjectionElem::Field(field, _) = elem {\n+                        if let Some(union_ty) = union_ty(base) {\n+                            if field != target_field && base == target_base {\n+                                return Some((\n+                                    describe_place(base),\n+                                    describe_place(first_borrowed_place),\n+                                    describe_place(second_borrowed_place),\n+                                    union_ty.to_string(),\n+                                ));\n+                            }\n+                        }\n                     }\n+\n+                    current = base;\n                 }\n                 None\n             })\n             .unwrap_or_else(|| {\n                 // If we didn't find a field access into a union, or both places match, then\n                 // only return the description of the first place.\n-                let desc_place = self.describe_place(first_borrowed_place)\n-                    .unwrap_or_else(|| \"_\".to_owned());\n-                (desc_place, \"\".to_string(), \"\".to_string(), \"\".to_string())\n+                (\n+                    describe_place(first_borrowed_place),\n+                    \"\".to_string(),\n+                    \"\".to_string(),\n+                    \"\".to_string(),\n+                )\n             })\n     }\n "}, {"sha": "c3ea9ff40a84341b6dafd36ee91dd44a58b157a8", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -270,7 +270,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    fn is_hir_id_from_struct_pattern_shorthand_field(&self, hir_id: hir::HirId, sp: Span) -> bool {\n+    crate fn is_hir_id_from_struct_pattern_shorthand_field(\n+        &self,\n+        hir_id: hir::HirId,\n+        sp: Span,\n+    ) -> bool {\n         let cm = self.sess().source_map();\n         let parent_id = self.tcx.hir().get_parent_node_by_hir_id(hir_id);\n         if let Some(parent) = self.tcx.hir().find_by_hir_id(parent_id) {"}, {"sha": "c5b85d52566d3ea2a767e468fcaef4c5cf2b6b0f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -5010,6 +5010,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Applicability::MachineApplicable,\n             );\n         } else if !self.check_for_cast(err, expr, found, expected) {\n+            let is_struct_pat_shorthand_field = self.is_hir_id_from_struct_pattern_shorthand_field(\n+                expr.hir_id,\n+                expr.span,\n+            );\n             let methods = self.get_conversion_methods(expr.span, expected, found);\n             if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n                 let mut suggestions = iter::repeat(&expr_text).zip(methods.iter())\n@@ -5019,14 +5023,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             None  // do not suggest code that is already there (#53348)\n                         } else {\n                             let method_call_list = [\".to_vec()\", \".to_string()\"];\n-                            if receiver.ends_with(\".clone()\")\n+                            let sugg = if receiver.ends_with(\".clone()\")\n                                     && method_call_list.contains(&method_call.as_str()) {\n                                 let max_len = receiver.rfind(\".\").unwrap();\n-                                Some(format!(\"{}{}\", &receiver[..max_len], method_call))\n-                            }\n-                            else {\n-                                Some(format!(\"{}{}\", receiver, method_call))\n-                            }\n+                                format!(\"{}{}\", &receiver[..max_len], method_call)\n+                            } else {\n+                                format!(\"{}{}\", receiver, method_call)\n+                            };\n+                            Some(if is_struct_pat_shorthand_field {\n+                                format!(\"{}: {}\", receiver, sugg)\n+                            } else {\n+                                sugg\n+                            })\n                         }\n                     }).peekable();\n                 if suggestions.peek().is_some() {"}, {"sha": "e68ad6a7c3b4bc375c6e5a8f7db6c0298cd67aaa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -3145,10 +3145,7 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n     fn clean(&self, cx: &DocContext<'_>) -> Constant {\n         Constant {\n             type_: self.ty.clean(cx),\n-            expr: match self.val {\n-                ConstValue::Param(ty::ParamConst { name, .. }) => format!(\"{}\", name),\n-                e => format!(\"{:?}\", e), // FIXME generic consts with expressions\n-            },\n+            expr: format!(\"{}\", self),\n         }\n     }\n }"}, {"sha": "9d1a0cc074c8814a40f6a16dc4d5bd04419bd6ea", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 114, "deletions": 25, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -17,7 +17,7 @@ use std::io::prelude::*;\n use std::io;\n use std::panic::{self, AssertUnwindSafe};\n use std::path::PathBuf;\n-use std::process::Command;\n+use std::process::{self, Command};\n use std::str;\n use std::sync::{Arc, Mutex};\n use syntax::symbol::sym;\n@@ -160,13 +160,45 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n     opts\n }\n \n-fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n-            cfgs: Vec<String>, libs: Vec<SearchPath>,\n-            cg: CodegenOptions, externs: Externs,\n-            should_panic: bool, no_run: bool, as_test_harness: bool,\n-            compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions,\n-            maybe_sysroot: Option<PathBuf>, linker: Option<PathBuf>, edition: Edition,\n-            persist_doctests: Option<PathBuf>) {\n+/// Documentation test failure modes.\n+enum TestFailure {\n+    /// The test failed to compile.\n+    CompileError,\n+    /// The test is marked `compile_fail` but compiled successfully.\n+    UnexpectedCompilePass,\n+    /// The test failed to compile (as expected) but the compiler output did not contain all\n+    /// expected error codes.\n+    MissingErrorCodes(Vec<String>),\n+    /// The test binary was unable to be executed.\n+    ExecutionError(io::Error),\n+    /// The test binary exited with a non-zero exit code.\n+    ///\n+    /// This typically means an assertion in the test failed or another form of panic occurred.\n+    ExecutionFailure(process::Output),\n+    /// The test is marked `should_panic` but the test binary executed successfully.\n+    UnexpectedRunPass,\n+}\n+\n+fn run_test(\n+    test: &str,\n+    cratename: &str,\n+    filename: &FileName,\n+    line: usize,\n+    cfgs: Vec<String>,\n+    libs: Vec<SearchPath>,\n+    cg: CodegenOptions,\n+    externs: Externs,\n+    should_panic: bool,\n+    no_run: bool,\n+    as_test_harness: bool,\n+    compile_fail: bool,\n+    mut error_codes: Vec<String>,\n+    opts: &TestOptions,\n+    maybe_sysroot: Option<PathBuf>,\n+    linker: Option<PathBuf>,\n+    edition: Edition,\n+    persist_doctests: Option<PathBuf>,\n+) -> Result<(), TestFailure> {\n     let (test, line_offset) = match panic::catch_unwind(|| {\n         make_test(test, Some(cratename), as_test_harness, opts, edition)\n     }) {\n@@ -307,44 +339,43 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n \n     match (compile_result, compile_fail) {\n         (Ok(()), true) => {\n-            panic!(\"test compiled while it wasn't supposed to\")\n+            return Err(TestFailure::UnexpectedCompilePass);\n         }\n         (Ok(()), false) => {}\n         (Err(_), true) => {\n-            if error_codes.len() > 0 {\n+            if !error_codes.is_empty() {\n                 let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n                 error_codes.retain(|err| !out.contains(err));\n+\n+                if !error_codes.is_empty() {\n+                    return Err(TestFailure::MissingErrorCodes(error_codes));\n+                }\n             }\n         }\n         (Err(_), false) => {\n-            panic!(\"couldn't compile the test\")\n+            return Err(TestFailure::CompileError);\n         }\n     }\n \n-    if error_codes.len() > 0 {\n-        panic!(\"Some expected error codes were not found: {:?}\", error_codes);\n+    if no_run {\n+        return Ok(());\n     }\n \n-    if no_run { return }\n-\n     // Run the code!\n     let mut cmd = Command::new(output_file);\n \n     match cmd.output() {\n-        Err(e) => panic!(\"couldn't run the test: {}{}\", e,\n-                        if e.kind() == io::ErrorKind::PermissionDenied {\n-                            \" - maybe your tempdir is mounted with noexec?\"\n-                        } else { \"\" }),\n+        Err(e) => return Err(TestFailure::ExecutionError(e)),\n         Ok(out) => {\n             if should_panic && out.status.success() {\n-                panic!(\"test executable succeeded when it should have failed\");\n+                return Err(TestFailure::UnexpectedRunPass);\n             } else if !should_panic && !out.status.success() {\n-                panic!(\"test executable failed:\\n{}\\n{}\\n\",\n-                       str::from_utf8(&out.stdout).unwrap_or(\"\"),\n-                       str::from_utf8(&out.stderr).unwrap_or(\"\"));\n+                return Err(TestFailure::ExecutionFailure(out));\n             }\n         }\n     }\n+\n+    Ok(())\n }\n \n /// Transforms a test into code that can be compiled into a Rust binary, and returns the number of\n@@ -711,7 +742,7 @@ impl Tester for Collector {\n                 allow_fail: config.allow_fail,\n             },\n             testfn: testing::DynTestFn(box move || {\n-                run_test(\n+                let res = run_test(\n                     &test,\n                     &cratename,\n                     &filename,\n@@ -730,7 +761,65 @@ impl Tester for Collector {\n                     linker,\n                     edition,\n                     persist_doctests\n-                )\n+                );\n+\n+                if let Err(err) = res {\n+                    match err {\n+                        TestFailure::CompileError => {\n+                            eprint!(\"Couldn't compile the test.\");\n+                        }\n+                        TestFailure::UnexpectedCompilePass => {\n+                            eprint!(\"Test compiled successfully, but it's marked `compile_fail`.\");\n+                        }\n+                        TestFailure::UnexpectedRunPass => {\n+                            eprint!(\"Test executable succeeded, but it's marked `should_panic`.\");\n+                        }\n+                        TestFailure::MissingErrorCodes(codes) => {\n+                            eprint!(\"Some expected error codes were not found: {:?}\", codes);\n+                        }\n+                        TestFailure::ExecutionError(err) => {\n+                            eprint!(\"Couldn't run the test: {}\", err);\n+                            if err.kind() == io::ErrorKind::PermissionDenied {\n+                                eprint!(\" - maybe your tempdir is mounted with noexec?\");\n+                            }\n+                        }\n+                        TestFailure::ExecutionFailure(out) => {\n+                            let reason = if let Some(code) = out.status.code() {\n+                                format!(\"exit code {}\", code)\n+                            } else {\n+                                String::from(\"terminated by signal\")\n+                            };\n+\n+                            eprintln!(\"Test executable failed ({}).\", reason);\n+\n+                            // FIXME(#12309): An unfortunate side-effect of capturing the test\n+                            // executable's output is that the relative ordering between the test's\n+                            // stdout and stderr is lost. However, this is better than the\n+                            // alternative: if the test executable inherited the parent's I/O\n+                            // handles the output wouldn't be captured at all, even on success.\n+                            //\n+                            // The ordering could be preserved if the test process' stderr was\n+                            // redirected to stdout, but that functionality does not exist in the\n+                            // standard library, so it may not be portable enough.\n+                            let stdout = str::from_utf8(&out.stdout).unwrap_or_default();\n+                            let stderr = str::from_utf8(&out.stderr).unwrap_or_default();\n+\n+                            if !stdout.is_empty() || !stderr.is_empty() {\n+                                eprintln!();\n+\n+                                if !stdout.is_empty() {\n+                                    eprintln!(\"stdout:\\n{}\", stdout);\n+                                }\n+\n+                                if !stderr.is_empty() {\n+                                    eprintln!(\"stderr:\\n{}\", stderr);\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+                    panic::resume_unwind(box ());\n+                }\n             }),\n         });\n     }"}, {"sha": "297d6efd45fee44aff913a50a5e85bd178688cfd", "filename": "src/test/rustdoc-ui/failed-doctest-compile-fail.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,11 @@\n+// FIXME: if/when the output of the test harness can be tested on its own, this test should be\n+// adapted to use that, and that normalize line can go away\n+\n+// compile-flags:--test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// failure-status: 101\n+\n+/// ```compile_fail\n+/// println!(\"Hello\");\n+/// ```\n+pub struct Foo;"}, {"sha": "74e33d7beebeb66ae72032915f25bd6387b52eaf", "filename": "src/test/rustdoc-ui/failed-doctest-compile-fail.stdout", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-compile-fail.stdout?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,14 @@\n+\n+running 1 test\n+test $DIR/failed-doctest-compile-fail.rs - Foo (line 8) ... FAILED\n+\n+failures:\n+\n+---- $DIR/failed-doctest-compile-fail.rs - Foo (line 8) stdout ----\n+Test compiled successfully, but it's marked `compile_fail`.\n+\n+failures:\n+    $DIR/failed-doctest-compile-fail.rs - Foo (line 8)\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "62102062d4991381c1a8d23d43536a03089742e7", "filename": "src/test/rustdoc-ui/failed-doctest-missing-codes.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,11 @@\n+// FIXME: if/when the output of the test harness can be tested on its own, this test should be\n+// adapted to use that, and that normalize line can go away\n+\n+// compile-flags:--test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// failure-status: 101\n+\n+/// ```compile_fail,E0004\n+/// let x: () = 5i32;\n+/// ```\n+pub struct Foo;"}, {"sha": "d206b721765b2470d7b5b877046fda122fe1a8fc", "filename": "src/test/rustdoc-ui/failed-doctest-missing-codes.stdout", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-missing-codes.stdout?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,26 @@\n+\n+running 1 test\n+test $DIR/failed-doctest-missing-codes.rs - Foo (line 8) ... FAILED\n+\n+failures:\n+\n+---- $DIR/failed-doctest-missing-codes.rs - Foo (line 8) stdout ----\n+error[E0308]: mismatched types\n+ --> $DIR/failed-doctest-missing-codes.rs:9:13\n+  |\n+3 | let x: () = 5i32;\n+  |             ^^^^ expected (), found i32\n+  |\n+  = note: expected type `()`\n+             found type `i32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`.\n+Some expected error codes were not found: [\"E0004\"]\n+\n+failures:\n+    $DIR/failed-doctest-missing-codes.rs - Foo (line 8)\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "d2cdeb8f8f50e8d110b884464e8b15611830bf0e", "filename": "src/test/rustdoc-ui/failed-doctest-output.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -5,10 +5,13 @@\n // compile-flags:--test\n // normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n // failure-status: 101\n-// rustc-env:RUST_BACKTRACE=0\n \n // doctest fails at runtime\n /// ```\n+/// println!(\"stdout 1\");\n+/// eprintln!(\"stderr 1\");\n+/// println!(\"stdout 2\");\n+/// eprintln!(\"stderr 2\");\n /// panic!(\"oh no\");\n /// ```\n pub struct SomeStruct;"}, {"sha": "0c42c652d786c724b1e23dd3afb398e41902d608", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -1,35 +1,39 @@\n \n running 2 tests\n-test $DIR/failed-doctest-output.rs - OtherStruct (line 17) ... FAILED\n-test $DIR/failed-doctest-output.rs - SomeStruct (line 11) ... FAILED\n+test $DIR/failed-doctest-output.rs - OtherStruct (line 20) ... FAILED\n+test $DIR/failed-doctest-output.rs - SomeStruct (line 10) ... FAILED\n \n failures:\n \n----- $DIR/failed-doctest-output.rs - OtherStruct (line 17) stdout ----\n+---- $DIR/failed-doctest-output.rs - OtherStruct (line 20) stdout ----\n error[E0425]: cannot find value `no` in this scope\n- --> $DIR/failed-doctest-output.rs:18:1\n+ --> $DIR/failed-doctest-output.rs:21:1\n   |\n 3 | no\n   | ^^ not found in this scope\n \n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0425`.\n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:320:13\n+Couldn't compile the test.\n+---- $DIR/failed-doctest-output.rs - SomeStruct (line 10) stdout ----\n+Test executable failed (exit code 101).\n+\n+stdout:\n+stdout 1\n+stdout 2\n+\n+stderr:\n+stderr 1\n+stderr 2\n+thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:7:1\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n----- $DIR/failed-doctest-output.rs - SomeStruct (line 11) stdout ----\n-thread '$DIR/failed-doctest-output.rs - SomeStruct (line 11)' panicked at 'test executable failed:\n-\n-thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n-note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n-\n-', src/librustdoc/test.rs:342:17\n \n \n failures:\n-    $DIR/failed-doctest-output.rs - OtherStruct (line 17)\n-    $DIR/failed-doctest-output.rs - SomeStruct (line 11)\n+    $DIR/failed-doctest-output.rs - OtherStruct (line 20)\n+    $DIR/failed-doctest-output.rs - SomeStruct (line 10)\n \n test result: FAILED. 0 passed; 2 failed; 0 ignored; 0 measured; 0 filtered out\n "}, {"sha": "400fb97804aabcef1e0b1de46bc9983d89ab2828", "filename": "src/test/rustdoc-ui/failed-doctest-should-panic.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,11 @@\n+// FIXME: if/when the output of the test harness can be tested on its own, this test should be\n+// adapted to use that, and that normalize line can go away\n+\n+// compile-flags:--test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// failure-status: 101\n+\n+/// ```should_panic\n+/// println!(\"Hello, world!\");\n+/// ```\n+pub struct Foo;"}, {"sha": "081b64b50af9b9aba65269cd2371c117bf865878", "filename": "src/test/rustdoc-ui/failed-doctest-should-panic.stdout", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-should-panic.stdout?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,14 @@\n+\n+running 1 test\n+test $DIR/failed-doctest-should-panic.rs - Foo (line 8) ... FAILED\n+\n+failures:\n+\n+---- $DIR/failed-doctest-should-panic.rs - Foo (line 8) stdout ----\n+Test executable succeeded, but it's marked `should_panic`.\n+\n+failures:\n+    $DIR/failed-doctest-should-panic.rs - Foo (line 8)\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "0350c016436071649470192ac656dcd9fd830ea0", "filename": "src/test/rustdoc-ui/unparseable-doc-test.stdout", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -13,9 +13,7 @@ error: unterminated double quote string\n \n error: aborting due to previous error\n \n-thread '$DIR/unparseable-doc-test.rs - foo (line 6)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:320:13\n-note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n-\n+Couldn't compile the test.\n \n failures:\n     $DIR/unparseable-doc-test.rs - foo (line 6)"}, {"sha": "ed45d339728bc3863fd3975fc227f885e2af3d81", "filename": "src/test/rustdoc/const-generics/add-impl.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,21 @@\n+// ignore-tidy-linelength\n+\n+#![feature(const_generics)]\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::Add;\n+\n+// @has foo/struct.Simd.html '//pre[@class=\"rust struct\"]' 'pub struct Simd<T, const WIDTH: usize>'\n+pub struct Simd<T, const WIDTH: usize> {\n+    inner: T,\n+}\n+\n+// @has foo/struct.Simd.html '//div[@id=\"implementations-list\"]/h3/code' 'impl Add<Simd<u8, 16>> for Simd<u8, 16>'\n+impl Add for Simd<u8, 16> {\n+    type Output = Self;\n+\n+    fn add(self, rhs: Self) -> Self::Output {\n+        Self { inner: 0 }\n+    }\n+}"}, {"sha": "85ee6d3376b2725c26a880899e760f6ceff1e2a0", "filename": "src/test/rustdoc/const-generics/const-impl.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-impl.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -1,7 +1,8 @@\n+// ignore-tidy-linelength\n+\n #![feature(const_generics)]\n-#![crate_name = \"foo\"]\n \n-// ignore-tidy-linelength\n+#![crate_name = \"foo\"]\n \n pub enum Order {\n     Sorted,", "previous_filename": "src/test/rustdoc/generic-const.rs"}, {"sha": "113ec29239616c4a4fd470ee2d70d5dc9741f797", "filename": "src/test/ui/consts/const-size_of-cycle.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-size_of-cycle.stderr?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -5,7 +5,7 @@ LL |     bytes: [u8; std::mem::size_of::<Foo>()]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: ...which requires const-evaluating `Foo::bytes::{{constant}}#0`...\n-  --> $SRC_DIR/libcore/mem.rs:LL:COL\n+  --> $SRC_DIR/libcore/mem/mod.rs:LL:COL\n    |\n LL |     intrinsics::size_of::<T>()\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "075b07f56520398df7cfecad7a7307b126ae19f6", "filename": "src/test/ui/suggestions/issue-52820.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Fui%2Fsuggestions%2Fissue-52820.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Fui%2Fsuggestions%2Fissue-52820.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-52820.rs?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,12 @@\n+struct Bravery {\n+    guts: String,\n+    brains: String,\n+}\n+\n+fn main() {\n+    let guts = \"mettle\";\n+    let _ = Bravery {\n+        guts, //~ ERROR mismatched types\n+        brains: guts.clone(), //~ ERROR mismatched types\n+    };\n+}"}, {"sha": "fb568aca250e773b048c32840f7ae1767c462d59", "filename": "src/test/ui/suggestions/issue-52820.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Fui%2Fsuggestions%2Fissue-52820.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Fui%2Fsuggestions%2Fissue-52820.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-52820.stderr?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -0,0 +1,27 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-52820.rs:9:9\n+   |\n+LL |         guts,\n+   |         ^^^^\n+   |         |\n+   |         expected struct `std::string::String`, found &str\n+   |         help: try using a conversion method: `guts: guts.to_string()`\n+   |\n+   = note: expected type `std::string::String`\n+              found type `&str`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-52820.rs:10:17\n+   |\n+LL |         brains: guts.clone(),\n+   |                 ^^^^^^^^^^^^\n+   |                 |\n+   |                 expected struct `std::string::String`, found &str\n+   |                 help: try using a conversion method: `guts.to_string()`\n+   |\n+   = note: expected type `std::string::String`\n+              found type `&str`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "7e308f107ba00049bbc71b69f57afec35b51bc60", "filename": "src/test/ui/type_length_limit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/37d001e4deb206ed954fde5d91690221e8306fc3/src%2Ftest%2Fui%2Ftype_length_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype_length_limit.stderr?ref=37d001e4deb206ed954fde5d91690221e8306fc3", "patch": "@@ -1,5 +1,5 @@\n error: reached the type-length limit while instantiating `std::mem::drop::<std::option::Op... G), (G, G, G), (G, G, G))))))>>`\n-  --> $SRC_DIR/libcore/mem.rs:LL:COL\n+  --> $SRC_DIR/libcore/mem/mod.rs:LL:COL\n    |\n LL | pub fn drop<T>(_x: T) { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^"}]}