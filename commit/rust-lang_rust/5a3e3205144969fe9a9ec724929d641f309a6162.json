{"sha": "5a3e3205144969fe9a9ec724929d641f309a6162", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhM2UzMjA1MTQ0OTY5ZmU5YTllYzcyNDkyOWQ2NDFmMzA5YTYxNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-21T06:55:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-21T06:55:20Z"}, "message": "auto merge of #6647 : alexcrichton/rust/unnecessary-alloc, r=graydon\n\nThis adds a lint mode for detecting unnecessary allocations on the heap. This isn't super fancy, currently it only has two rules\r\n\r\n1. For a function's arguments, if you allocate a `[~|@]str` literal, when the type of the argument is a `&str`, emit a warning.\r\n2. For the same case, emit warnings for boxed vectors when slices are required.\r\n\r\nAfter adding the lint, I rampaged through the libraries and removed all the unnecessary allocations I could find.", "tree": {"sha": "e8ba741b28071f02dc553238f8b3e24496f8b676", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8ba741b28071f02dc553238f8b3e24496f8b676"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a3e3205144969fe9a9ec724929d641f309a6162", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a3e3205144969fe9a9ec724929d641f309a6162", "html_url": "https://github.com/rust-lang/rust/commit/5a3e3205144969fe9a9ec724929d641f309a6162", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a3e3205144969fe9a9ec724929d641f309a6162/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d49a9dbc7ff342804112906760d87604f14f22c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d49a9dbc7ff342804112906760d87604f14f22c5", "html_url": "https://github.com/rust-lang/rust/commit/d49a9dbc7ff342804112906760d87604f14f22c5"}, {"sha": "82fa0018c80c8f64cb1b446a7e59492d9ad97b1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/82fa0018c80c8f64cb1b446a7e59492d9ad97b1d", "html_url": "https://github.com/rust-lang/rust/commit/82fa0018c80c8f64cb1b446a7e59492d9ad97b1d"}], "stats": {"total": 2125, "additions": 1095, "deletions": 1030}, "files": [{"sha": "b2a30e50992c885988b441e116e74c7aac9c62ce", "filename": "src/libcore/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -509,7 +509,7 @@ pub fn self_exe_path() -> Option<Path> {\n  * Otherwise, homedir returns option::none.\n  */\n pub fn homedir() -> Option<Path> {\n-    return match getenv(~\"HOME\") {\n+    return match getenv(\"HOME\") {\n         Some(ref p) => if !str::is_empty(*p) {\n           Some(Path(*p))\n         } else {"}, {"sha": "53169554ec5e7a414dae1a65060132ef21be1c20", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -1808,7 +1808,7 @@ pub fn to_utf16(s: &str) -> ~[u16] {\n             ch -= 0x1_0000_u32;\n             let w1 = 0xD800_u16 | ((ch >> 10) as u16);\n             let w2 = 0xDC00_u16 | ((ch as u16) & 0x3FF_u16);\n-            u.push_all(~[w1, w2])\n+            u.push_all([w1, w2])\n         }\n     }\n     u"}, {"sha": "8da378fdc97ce95ce0016848d9deb0fe9a808cf4", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -178,7 +178,7 @@ pub mod ct {\n                 i += 1;\n \n                 if i >= lim {\n-                    err(~\"unterminated conversion at end of string\");\n+                    err(\"unterminated conversion at end of string\");\n                 } else if s[i] == '%' as u8 {\n                     push_slice(&mut pieces, s, h, i);\n                     i += 1;\n@@ -309,7 +309,7 @@ pub mod ct {\n \n     pub fn parse_type(s: &str, i: uint, lim: uint, err: ErrorFn) ->\n         Parsed<Ty> {\n-        if i >= lim { err(~\"missing type in conversion\"); }\n+        if i >= lim { err(\"missing type in conversion\"); }\n \n         // FIXME (#2249): Do we really want two signed types here?\n         // How important is it to be printf compatible?"}, {"sha": "f999c20a7d0ec73f301b6784acb23091cde6c195", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -387,8 +387,8 @@ pub mod write {\n                 fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n             }\n             &None => {\n-                sess.fatal(~\"need Android NDK path for building \\\n-                             (--android-cross-path)\")\n+                sess.fatal(\"need Android NDK path for building \\\n+                            (--android-cross-path)\")\n             }\n         };\n         let mut cc_args = ~[];\n@@ -403,7 +403,7 @@ pub mod write {\n             sess.err(fmt!(\"building with `%s` failed with code %d\",\n                         cc_prog, prog.status));\n             sess.note(fmt!(\"%s arguments: %s\",\n-                        cc_prog, str::connect(cc_args, ~\" \")));\n+                        cc_prog, str::connect(cc_args, \" \")));\n             sess.note(prog.err + prog.out);\n             sess.abort_if_errors();\n         }\n@@ -566,7 +566,7 @@ pub fn build_link_meta(sess: Session,\n                                   || fmt!(\"output file name `%s` doesn't\\\n                                            appear to have a stem\",\n                                           output.to_str())).to_managed();\n-                warn_missing(sess, ~\"name\", name);\n+                warn_missing(sess, \"name\", name);\n                 name\n               }\n             };\n@@ -577,7 +577,7 @@ pub fn build_link_meta(sess: Session,\n               Some(v) => v,\n               None => {\n                 let vers = @\"0.0\";\n-                warn_missing(sess, ~\"vers\", vers);\n+                warn_missing(sess, \"vers\", vers);\n                 vers\n               }\n             };\n@@ -618,9 +618,9 @@ pub fn symbol_hash(tcx: ty::ctxt,\n \n     symbol_hasher.reset();\n     write_string(symbol_hasher, link_meta.name);\n-    write_string(symbol_hasher, ~\"-\");\n+    write_string(symbol_hasher, \"-\");\n     write_string(symbol_hasher, link_meta.extras_hash);\n-    write_string(symbol_hasher, ~\"-\");\n+    write_string(symbol_hasher, \"-\");\n     write_string(symbol_hasher, encoder::encoded_ty(tcx, t));\n     let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with _ so that it never blends into adjacent digits\n@@ -770,8 +770,8 @@ pub fn link_binary(sess: Session,\n                         fmt!(\"%s/bin/arm-linux-androideabi-gcc\", path)\n                     }\n                     &None => {\n-                        sess.fatal(~\"need Android NDK path for linking \\\n-                                     (--android-cross-path)\")\n+                        sess.fatal(\"need Android NDK path for linking \\\n+                                    (--android-cross-path)\")\n                     }\n                 }\n             } else if sess.targ_cfg.os == session::os_win32 {\n@@ -798,21 +798,21 @@ pub fn link_binary(sess: Session,\n \n     debug!(\"output: %s\", output.to_str());\n     let cc_args = link_args(sess, obj_filename, out_filename, lm);\n-    debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, ~\" \"));\n+    debug!(\"%s link args: %s\", cc_prog, str::connect(cc_args, \" \"));\n     // We run 'cc' here\n     let prog = run::program_output(cc_prog, cc_args);\n     if 0 != prog.status {\n         sess.err(fmt!(\"linking with `%s` failed with code %d\",\n                       cc_prog, prog.status));\n         sess.note(fmt!(\"%s arguments: %s\",\n-                       cc_prog, str::connect(cc_args, ~\" \")));\n+                       cc_prog, str::connect(cc_args, \" \")));\n         sess.note(prog.err + prog.out);\n         sess.abort_if_errors();\n     }\n \n     // Clean up on Darwin\n     if sess.targ_cfg.os == session::os_macos {\n-        run::run_program(~\"dsymutil\", ~[output.to_str()]);\n+        run::run_program(\"dsymutil\", [output.to_str()]);\n     }\n \n     // Remove the temporary object file if we aren't saving temps\n@@ -920,27 +920,26 @@ pub fn link_args(sess: Session,\n     // On linux librt and libdl are an indirect dependencies via rustrt,\n     // and binutils 2.22+ won't add them automatically\n     if sess.targ_cfg.os == session::os_linux {\n-        args.push_all(~[~\"-lrt\", ~\"-ldl\"]);\n+        args.push_all([~\"-lrt\", ~\"-ldl\"]);\n \n         // LLVM implements the `frem` instruction as a call to `fmod`,\n         // which lives in libm. Similar to above, on some linuxes we\n         // have to be explicit about linking to it. See #2510\n         args.push(~\"-lm\");\n     }\n     else if sess.targ_cfg.os == session::os_android {\n-        args.push_all(~[~\"-ldl\", ~\"-llog\",  ~\"-lsupc++\",\n-                           ~\"-lgnustl_shared\"]);\n+        args.push_all([~\"-ldl\", ~\"-llog\",  ~\"-lsupc++\", ~\"-lgnustl_shared\"]);\n         args.push(~\"-lm\");\n     }\n \n     if sess.targ_cfg.os == session::os_freebsd {\n-        args.push_all(~[~\"-pthread\", ~\"-lrt\",\n-                        ~\"-L/usr/local/lib\", ~\"-lexecinfo\",\n-                        ~\"-L/usr/local/lib/gcc46\",\n-                        ~\"-L/usr/local/lib/gcc44\", ~\"-lstdc++\",\n-                        ~\"-Wl,-z,origin\",\n-                        ~\"-Wl,-rpath,/usr/local/lib/gcc46\",\n-                        ~\"-Wl,-rpath,/usr/local/lib/gcc44\"]);\n+        args.push_all([~\"-pthread\", ~\"-lrt\",\n+                       ~\"-L/usr/local/lib\", ~\"-lexecinfo\",\n+                       ~\"-L/usr/local/lib/gcc46\",\n+                       ~\"-L/usr/local/lib/gcc44\", ~\"-lstdc++\",\n+                       ~\"-Wl,-z,origin\",\n+                       ~\"-Wl,-rpath,/usr/local/lib/gcc46\",\n+                       ~\"-Wl,-rpath,/usr/local/lib/gcc44\"]);\n     }\n \n     // OS X 10.6 introduced 'compact unwind info', which is produced by the"}, {"sha": "0dd37f0b9070aec4868b15102185fbaea1cacd3f", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -86,9 +86,9 @@ fn get_rpaths(os: session::os,\n         }\n     }\n \n-    log_rpaths(~\"relative\", rel_rpaths);\n-    log_rpaths(~\"absolute\", abs_rpaths);\n-    log_rpaths(~\"fallback\", fallback_rpaths);\n+    log_rpaths(\"relative\", rel_rpaths);\n+    log_rpaths(\"absolute\", abs_rpaths);\n+    log_rpaths(\"fallback\", fallback_rpaths);\n \n     let mut rpaths = rel_rpaths;\n     rpaths.push_all(abs_rpaths);"}, {"sha": "33c70a3d4259f48b0e0d5dbf03df8f38424d3bb6", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 64, "deletions": 45, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -376,7 +376,7 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n         match node {\n           pprust::node_expr(s, expr) => {\n             pp::space(s.s);\n-            pp::word(s.s, ~\"as\");\n+            pp::word(s.s, \"as\");\n             pp::space(s.s);\n             pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n             pprust::pclose(s);\n@@ -442,33 +442,33 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n }\n \n pub fn get_os(triple: &str) -> Option<session::os> {\n-    if str::contains(triple, ~\"win32\") ||\n-               str::contains(triple, ~\"mingw32\") {\n+    if str::contains(triple, \"win32\") ||\n+               str::contains(triple, \"mingw32\") {\n             Some(session::os_win32)\n-        } else if str::contains(triple, ~\"darwin\") {\n+        } else if str::contains(triple, \"darwin\") {\n             Some(session::os_macos)\n-        } else if str::contains(triple, ~\"android\") {\n+        } else if str::contains(triple, \"android\") {\n             Some(session::os_android)\n-        } else if str::contains(triple, ~\"linux\") {\n+        } else if str::contains(triple, \"linux\") {\n             Some(session::os_linux)\n-        } else if str::contains(triple, ~\"freebsd\") {\n+        } else if str::contains(triple, \"freebsd\") {\n             Some(session::os_freebsd)\n         } else { None }\n }\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    if str::contains(triple, ~\"i386\") ||\n-        str::contains(triple, ~\"i486\") ||\n-               str::contains(triple, ~\"i586\") ||\n-               str::contains(triple, ~\"i686\") ||\n-               str::contains(triple, ~\"i786\") {\n+    if str::contains(triple, \"i386\") ||\n+        str::contains(triple, \"i486\") ||\n+               str::contains(triple, \"i586\") ||\n+               str::contains(triple, \"i686\") ||\n+               str::contains(triple, \"i786\") {\n             Some(abi::X86)\n-        } else if str::contains(triple, ~\"x86_64\") {\n+        } else if str::contains(triple, \"x86_64\") {\n             Some(abi::X86_64)\n-        } else if str::contains(triple, ~\"arm\") ||\n-                      str::contains(triple, ~\"xscale\") {\n+        } else if str::contains(triple, \"arm\") ||\n+                      str::contains(triple, \"xscale\") {\n             Some(abi::Arm)\n-        } else if str::contains(triple, ~\"mips\") {\n+        } else if str::contains(triple, \"mips\") {\n             Some(abi::Mips)\n         } else { None }\n }\n@@ -508,6 +508,7 @@ pub fn build_target_config(sopts: @session::options,\n     return target_cfg;\n }\n \n+#[cfg(stage0)]\n pub fn host_triple() -> ~str {\n     // Get the host triple out of the build environment. This ensures that our\n     // idea of the host triple is the same as for the set of libraries we've\n@@ -525,19 +526,37 @@ pub fn host_triple() -> ~str {\n         };\n }\n \n+#[cfg(not(stage0))]\n+pub fn host_triple() -> ~str {\n+    // Get the host triple out of the build environment. This ensures that our\n+    // idea of the host triple is the same as for the set of libraries we've\n+    // actually built.  We can't just take LLVM's host triple because they\n+    // normalize all ix86 architectures to i386.\n+\n+    // FIXME (#2400): Instead of grabbing the host triple we really should\n+    // be grabbing (at compile time) the target triple that this rustc is\n+    // built with and calling that (at runtime) the host triple.\n+    let ht = env!(\"CFG_BUILD_TRIPLE\");\n+    return if ht != \"\" {\n+            ht.to_owned()\n+        } else {\n+            fail!(\"rustc built without CFG_BUILD_TRIPLE\")\n+        };\n+}\n+\n pub fn build_session_options(binary: @~str,\n                              matches: &getopts::Matches,\n                              demitter: diagnostic::Emitter)\n                           -> @session::options {\n-    let crate_type = if opt_present(matches, ~\"lib\") {\n+    let crate_type = if opt_present(matches, \"lib\") {\n         session::lib_crate\n-    } else if opt_present(matches, ~\"bin\") {\n+    } else if opt_present(matches, \"bin\") {\n         session::bin_crate\n     } else {\n         session::unknown_crate\n     };\n-    let parse_only = opt_present(matches, ~\"parse-only\");\n-    let no_trans = opt_present(matches, ~\"no-trans\");\n+    let parse_only = opt_present(matches, \"parse-only\");\n+    let no_trans = opt_present(matches, \"no-trans\");\n \n     let lint_levels = [lint::allow, lint::warn,\n                        lint::deny, lint::forbid];\n@@ -553,7 +572,7 @@ pub fn build_session_options(binary: @~str,\n         let flags = vec::append(getopts::opt_strs(matches, level_short),\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n-            let lint_name = str::replace(*lint_name, ~\"-\", ~\"_\");\n+            let lint_name = str::replace(*lint_name, \"-\", \"_\");\n             match lint_dict.find(&lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n@@ -567,7 +586,7 @@ pub fn build_session_options(binary: @~str,\n     }\n \n     let mut debugging_opts = 0u;\n-    let debug_flags = getopts::opt_strs(matches, ~\"Z\");\n+    let debug_flags = getopts::opt_strs(matches, \"Z\");\n     let debug_map = session::debugging_opts_map();\n     for debug_flags.each |debug_flag| {\n         let mut this_bit = 0u;\n@@ -589,31 +608,31 @@ pub fn build_session_options(binary: @~str,\n     let output_type =\n         if parse_only || no_trans {\n             link::output_type_none\n-        } else if opt_present(matches, ~\"S\") &&\n-                  opt_present(matches, ~\"emit-llvm\") {\n+        } else if opt_present(matches, \"S\") &&\n+                  opt_present(matches, \"emit-llvm\") {\n             link::output_type_llvm_assembly\n-        } else if opt_present(matches, ~\"S\") {\n+        } else if opt_present(matches, \"S\") {\n             link::output_type_assembly\n-        } else if opt_present(matches, ~\"c\") {\n+        } else if opt_present(matches, \"c\") {\n             link::output_type_object\n-        } else if opt_present(matches, ~\"emit-llvm\") {\n+        } else if opt_present(matches, \"emit-llvm\") {\n             link::output_type_bitcode\n         } else { link::output_type_exe };\n-    let sysroot_opt = getopts::opt_maybe_str(matches, ~\"sysroot\");\n+    let sysroot_opt = getopts::opt_maybe_str(matches, \"sysroot\");\n     let sysroot_opt = sysroot_opt.map(|m| @Path(*m));\n-    let target_opt = getopts::opt_maybe_str(matches, ~\"target\");\n-    let target_feature_opt = getopts::opt_maybe_str(matches, ~\"target-feature\");\n-    let save_temps = getopts::opt_present(matches, ~\"save-temps\");\n+    let target_opt = getopts::opt_maybe_str(matches, \"target\");\n+    let target_feature_opt = getopts::opt_maybe_str(matches, \"target-feature\");\n+    let save_temps = getopts::opt_present(matches, \"save-temps\");\n     let opt_level = {\n         if (debugging_opts & session::no_opt) != 0 {\n             No\n-        } else if opt_present(matches, ~\"O\") {\n-            if opt_present(matches, ~\"opt-level\") {\n+        } else if opt_present(matches, \"O\") {\n+            if opt_present(matches, \"opt-level\") {\n                 early_error(demitter, ~\"-O and --opt-level both provided\");\n             }\n             Default\n-        } else if opt_present(matches, ~\"opt-level\") {\n-            match getopts::opt_str(matches, ~\"opt-level\") {\n+        } else if opt_present(matches, \"opt-level\") {\n+            match getopts::opt_str(matches, \"opt-level\") {\n               ~\"0\" => No,\n               ~\"1\" => Less,\n               ~\"2\" => Default,\n@@ -641,20 +660,20 @@ pub fn build_session_options(binary: @~str,\n         Some(s) => s\n     };\n \n-    let addl_lib_search_paths = getopts::opt_strs(matches, ~\"L\").map(|s| Path(*s));\n-    let linker = getopts::opt_maybe_str(matches, ~\"linker\");\n-    let linker_args = getopts::opt_strs(matches, ~\"link-args\").flat_map( |a| {\n+    let addl_lib_search_paths = getopts::opt_strs(matches, \"L\").map(|s| Path(*s));\n+    let linker = getopts::opt_maybe_str(matches, \"linker\");\n+    let linker_args = getopts::opt_strs(matches, \"link-args\").flat_map( |a| {\n         let mut args = ~[];\n         for str::each_split_char(*a, ' ') |arg| {\n             args.push(str::to_owned(arg));\n         }\n         args\n     });\n \n-    let cfg = parse_cfgspecs(getopts::opt_strs(matches, ~\"cfg\"), demitter);\n-    let test = opt_present(matches, ~\"test\");\n+    let cfg = parse_cfgspecs(getopts::opt_strs(matches, \"cfg\"), demitter);\n+    let test = opt_present(matches, \"test\");\n     let android_cross_path = getopts::opt_maybe_str(\n-        matches, ~\"android-cross-path\");\n+        matches, \"android-cross-path\");\n \n     let sopts = @session::options {\n         crate_type: crate_type,\n@@ -732,9 +751,9 @@ pub fn parse_pretty(sess: Session, name: &str) -> pp_mode {\n       &\"expanded,identified\" => ppm_expanded_identified,\n       &\"identified\" => ppm_identified,\n       _ => {\n-        sess.fatal(~\"argument to `pretty` must be one of `normal`, \\\n-                     `expanded`, `typed`, `identified`, \\\n-                     or `expanded,identified`\");\n+        sess.fatal(\"argument to `pretty` must be one of `normal`, \\\n+                    `expanded`, `typed`, `identified`, \\\n+                    or `expanded,identified`\");\n       }\n     }\n }\n@@ -875,7 +894,7 @@ pub fn build_output_filenames(input: &input,\n         }\n \n         if *odir != None {\n-            sess.warn(~\"ignoring --out-dir flag due to -o flag.\");\n+            sess.warn(\"ignoring --out-dir flag due to -o flag.\");\n         }\n       }\n     }"}, {"sha": "e2cc285fb7afc76f46db8966144d59dea3437e11", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -332,7 +332,7 @@ pub fn building_library(req_crate_type: crate_type,\n         } else {\n             match syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n-                ~\"crate_type\") {\n+                \"crate_type\") {\n               Some(@~\"lib\") => true,\n               _ => false\n             }"}, {"sha": "6341b1c155ccab9f69aa62e3b4d87fe717a012f2", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -175,7 +175,7 @@ fn in_cfg(cfg: ast::crate_cfg, attrs: ~[ast::attribute]) -> bool {\n pub fn metas_in_cfg(cfg: ast::crate_cfg,\n                     metas: ~[@ast::meta_item]) -> bool {\n     // The \"cfg\" attributes on the item\n-    let cfg_metas = attr::find_meta_items_by_name(metas, ~\"cfg\");\n+    let cfg_metas = attr::find_meta_items_by_name(metas, \"cfg\");\n \n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for"}, {"sha": "b3e045d8af9a87ee720d4f6f8fbb677793eba83c", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -28,7 +28,7 @@ pub fn maybe_inject_libcore_ref(sess: Session,\n }\n \n fn use_core(crate: @ast::crate) -> bool {\n-    !attr::attrs_contains_name(crate.node.attrs, ~\"no_core\")\n+    !attr::attrs_contains_name(crate.node.attrs, \"no_core\")\n }\n \n fn inject_libcore_ref(sess: Session,"}, {"sha": "fd26971629580896b4c73c539d0beacecc829a3c", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -25,7 +25,7 @@ pub fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n         match item {\n           Some(i) => i,\n           None => {\n-            sess.fatal(~\"no item found in intrinsic module\");\n+            sess.fatal(\"no item found in intrinsic module\");\n           }\n         };\n "}, {"sha": "eb199f6e1083415c007783044670fcd4b4d24365", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -93,8 +93,8 @@ fn strip_test_functions(crate: @ast::crate) -> @ast::crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n     do config::strip_items(crate) |attrs| {\n-        !attr::contains_name(attr::attr_metas(attrs), ~\"test\") &&\n-        !attr::contains_name(attr::attr_metas(attrs), ~\"bench\")\n+        !attr::contains_name(attr::attr_metas(attrs), \"test\") &&\n+        !attr::contains_name(attr::attr_metas(attrs), \"bench\")\n     }\n }\n \n@@ -148,7 +148,7 @@ fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n             let sess = cx.sess;\n             sess.span_fatal(\n                 i.span,\n-                ~\"unsafe functions cannot be used for tests\");\n+                \"unsafe functions cannot be used for tests\");\n           }\n           _ => {\n             debug!(\"this is a test function\");\n@@ -172,7 +172,7 @@ fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n \n fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n     let has_test_attr = !attr::find_attrs_by_name(i.attrs,\n-                                                  ~\"test\").is_empty();\n+                                                  \"test\").is_empty();\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         match &i.node {\n@@ -193,15 +193,15 @@ fn is_test_fn(cx: @mut TestCtxt, i: @ast::item) -> bool {\n         let sess = cx.sess;\n         sess.span_err(\n             i.span,\n-            ~\"functions used as tests must have signature fn() -> ().\"\n+            \"functions used as tests must have signature fn() -> ().\"\n         );\n     }\n     return has_test_attr && has_test_signature(i);\n }\n \n fn is_bench_fn(i: @ast::item) -> bool {\n     let has_bench_attr =\n-        vec::len(attr::find_attrs_by_name(i.attrs, ~\"bench\")) > 0u;\n+        vec::len(attr::find_attrs_by_name(i.attrs, \"bench\")) > 0u;\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         match i.node {\n@@ -239,7 +239,7 @@ fn is_ignored(cx: @mut TestCtxt, i: @ast::item) -> bool {\n }\n \n fn should_fail(i: @ast::item) -> bool {\n-    vec::len(attr::find_attrs_by_name(i.attrs, ~\"should_fail\")) > 0u\n+    vec::len(attr::find_attrs_by_name(i.attrs, \"should_fail\")) > 0u\n }\n \n fn add_test_module(cx: &TestCtxt, m: &ast::_mod) -> ast::_mod {\n@@ -373,7 +373,7 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n fn is_std(cx: &TestCtxt) -> bool {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n-        match attr::last_meta_item_value_str_by_name(items, ~\"name\") {\n+        match attr::last_meta_item_value_str_by_name(items, \"name\") {\n           Some(@~\"std\") => true,\n           _ => false\n         }"}, {"sha": "d40257879d0ec1c68c91b2488606a30d291fbe18", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -99,7 +99,7 @@ fn warn_if_multiple_versions(e: @mut Env,\n             diag.handler().warn(\n                 fmt!(\"using multiple versions of crate `%s`\", *name));\n             for matches.each |match_| {\n-                diag.span_note(match_.span, ~\"used here\");\n+                diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(\n                         @~\"link\", /*bad*/copy *match_.metas))\n@@ -164,7 +164,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n             ast::named => {\n                 let foreign_name =\n                     match attr::first_attr_value_str_by_name(i.attrs,\n-                                                            ~\"link_name\") {\n+                                                             \"link_name\") {\n                         Some(nn) => {\n                             if *nn == ~\"\" {\n                                 e.diag.span_fatal(\n@@ -176,7 +176,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n                         }\n                         None => e.intr.get(i.ident)\n                     };\n-                if attr::find_attrs_by_name(i.attrs, ~\"nolink\").is_empty() {\n+                if attr::find_attrs_by_name(i.attrs, \"nolink\").is_empty() {\n                     already_added =\n                         !cstore::add_used_library(cstore, foreign_name);\n                 }\n@@ -272,7 +272,7 @@ fn resolve_crate(e: @mut Env,\n \n         let cname =\n             match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n-                                                         ~\"name\") {\n+                                                         \"name\") {\n                 Some(v) => v,\n                 None => e.intr.get(ident),\n             };"}, {"sha": "de440632b1fdb8407d086eb8d5e4661d1088538c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -186,7 +186,7 @@ fn translated_parent_item_opt(cnum: ast::crate_num, d: ebml::Doc) ->\n \n fn item_reqd_and_translated_parent_item(cnum: ast::crate_num,\n                                         d: ebml::Doc) -> ast::def_id {\n-    let trait_did = item_parent_item(d).expect(~\"item without parent\");\n+    let trait_did = item_parent_item(d).expect(\"item without parent\");\n     ast::def_id { crate: cnum, node: trait_did.node }\n }\n \n@@ -785,8 +785,8 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n         let fty = match ty::get(ty).sty {\n             ty::ty_bare_fn(ref f) => copy *f,\n             _ => {\n-                tcx.diag.handler().bug(~\"get_provided_trait_methods(): id \\\n-                                         has non-function type\");\n+                tcx.diag.handler().bug(\"get_provided_trait_methods(): id \\\n+                                        has non-function type\");\n             }\n         };\n \n@@ -1064,7 +1064,7 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n         out.write_str(fmt!(\"%s\\n\", pprust::attribute_to_str(*attr, intr)));\n     }\n \n-    out.write_str(~\"\\n\\n\");\n+    out.write_str(\"\\n\\n\");\n }\n \n pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n@@ -1097,15 +1097,15 @@ pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n }\n \n fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: @io::Writer) {\n-    out.write_str(~\"=External Dependencies=\\n\");\n+    out.write_str(\"=External Dependencies=\\n\");\n \n     for get_crate_deps(intr, data).each |dep| {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n                  dep.cnum, *intr.get(dep.name), *dep.hash, *dep.vers));\n     }\n \n-    out.write_str(~\"\\n\");\n+    out.write_str(\"\\n\");\n }\n \n pub fn get_crate_hash(data: @~[u8]) -> @~str {\n@@ -1118,7 +1118,7 @@ pub fn get_crate_vers(data: @~[u8]) -> @~str {\n     let attrs = decoder::get_crate_attributes(data);\n     let linkage_attrs = attr::find_linkage_metas(attrs);\n \n-    match attr::last_meta_item_value_str_by_name(linkage_attrs, ~\"vers\") {\n+    match attr::last_meta_item_value_str_by_name(linkage_attrs, \"vers\") {\n         Some(ver) => ver,\n         None => @~\"0.0\"\n     }"}, {"sha": "5fc05fe79209c32c29433ee1f1d707ce9a17d869", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -846,7 +846,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n                 struct_def.fields[0].node.kind == ast::unnamed_field {\n             let ctor_id = match struct_def.ctor_id {\n                 Some(ctor_id) => ctor_id,\n-                None => ecx.tcx.sess.bug(~\"struct def didn't have ctor id\"),\n+                None => ecx.tcx.sess.bug(\"struct def didn't have ctor id\"),\n             };\n \n             encode_info_for_struct_ctor(ecx,\n@@ -1067,7 +1067,7 @@ fn encode_info_for_items(ecx: @EncodeContext,\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n     encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n-                        crate_node_id, ~[],\n+                        crate_node_id, [],\n                         syntax::parse::token::special_idents::invalid);\n     visit::visit_crate(crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |_e, _cx, _v| { },\n@@ -1235,8 +1235,8 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n \n         let other_items =\n             {\n-                let tmp = attr::remove_meta_items_by_name(items, ~\"name\");\n-                attr::remove_meta_items_by_name(tmp, ~\"vers\")\n+                let tmp = attr::remove_meta_items_by_name(items, \"name\");\n+                attr::remove_meta_items_by_name(tmp, \"vers\")\n             };\n \n         let meta_items = vec::append(~[name_item, vers_item], other_items);"}, {"sha": "7a7ee03b705fd4387e0e3f8022bd3797ad23edc0", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -127,7 +127,7 @@ pub fn get_rustpkg_sysroot() -> Result<Path, ~str> {\n }\n \n pub fn get_rustpkg_root() -> Result<Path, ~str> {\n-    match os::getenv(~\"RUSTPKG_ROOT\") {\n+    match os::getenv(\"RUSTPKG_ROOT\") {\n         Some(ref _p) => result::Ok(Path((*_p))),\n         None => match os::homedir() {\n           Some(ref _q) => result::Ok((*_q).push(\".rustpkg\")),\n@@ -181,5 +181,5 @@ pub fn libdir() -> ~str {\n    if str::is_empty(libdir) {\n       fail!(\"rustc compiled without CFG_LIBDIR environment variable\");\n    }\n-   libdir\n+   libdir.to_owned()\n }"}, {"sha": "75639e8c689e1bebf0a099742dc2fb4aeba76bb4", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -120,7 +120,7 @@ fn find_library_crate_aux(\n     } else {\n         cx.diag.span_err(\n             cx.span, fmt!(\"multiple matching crates for `%s`\", *crate_name));\n-        cx.diag.handler().note(~\"candidates:\");\n+        cx.diag.handler().note(\"candidates:\");\n         for matches.each |&(ident, data)| {\n             cx.diag.handler().note(fmt!(\"path: %s\", ident));\n             let attrs = decoder::get_crate_attributes(data);\n@@ -132,7 +132,7 @@ fn find_library_crate_aux(\n }\n \n pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @~str {\n-    let name_items = attr::find_meta_items_by_name(metas, ~\"name\");\n+    let name_items = attr::find_meta_items_by_name(metas, \"name\");\n     match name_items.last_opt() {\n         Some(i) => {\n             match attr::get_meta_item_value_str(*i) {"}, {"sha": "b1be0fb599eea9eb2ed0671d820a8038791e2602", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -155,7 +155,7 @@ fn enc_region(w: @io::Writer, cx: @ctxt, r: ty::Region) {\n       }\n       ty::re_infer(_) => {\n         // these should not crop up after typeck\n-        cx.diag.handler().bug(~\"Cannot encode region variables\");\n+        cx.diag.handler().bug(\"Cannot encode region variables\");\n       }\n     }\n }\n@@ -301,7 +301,7 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n         enc_bare_fn_ty(w, cx, f);\n       }\n       ty::ty_infer(_) => {\n-        cx.diag.handler().bug(~\"Cannot encode inference variable types\");\n+        cx.diag.handler().bug(\"Cannot encode inference variable types\");\n       }\n       ty::ty_param(param_ty {idx: id, def_id: did}) => {\n         w.write_char('p');\n@@ -321,15 +321,15 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n       }\n       ty::ty_opaque_box => w.write_char('B'),\n       ty::ty_struct(def, ref substs) => {\n-          debug!(\"~~~~ %s\", ~\"a[\");\n+          debug!(\"~~~~ %s\", \"a[\");\n           w.write_str(&\"a[\");\n           let s = (cx.ds)(def);\n           debug!(\"~~~~ %s\", s);\n           w.write_str(s);\n-          debug!(\"~~~~ %s\", ~\"|\");\n+          debug!(\"~~~~ %s\", \"|\");\n           w.write_char('|');\n           enc_substs(w, cx, substs);\n-          debug!(\"~~~~ %s\", ~\"]\");\n+          debug!(\"~~~~ %s\", \"]\");\n           w.write_char(']');\n       }\n       ty::ty_err => fail!(\"Shouldn't encode error type\")"}, {"sha": "5188f464504a676bd8b3de1d26f830f35f0e366c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -614,10 +614,10 @@ fn encode_vtable_res(ecx: @e::EncodeContext,\n fn encode_vtable_origin(ecx: @e::EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n-    do ebml_w.emit_enum(~\"vtable_origin\") |ebml_w| {\n+    do ebml_w.emit_enum(\"vtable_origin\") |ebml_w| {\n         match *vtable_origin {\n           typeck::vtable_static(def_id, ref tys, vtable_res) => {\n-            do ebml_w.emit_enum_variant(~\"vtable_static\", 0u, 3u) |ebml_w| {\n+            do ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u) |ebml_w| {\n                 do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n                     ebml_w.emit_def_id(def_id)\n                 }\n@@ -630,7 +630,7 @@ fn encode_vtable_origin(ecx: @e::EncodeContext,\n             }\n           }\n           typeck::vtable_param(pn, bn) => {\n-            do ebml_w.emit_enum_variant(~\"vtable_param\", 1u, 2u) |ebml_w| {\n+            do ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) |ebml_w| {\n                 do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n                     ebml_w.emit_uint(pn);\n                 }\n@@ -756,20 +756,20 @@ impl ebml_writer_helpers for writer::Encoder {\n                  ecx: @e::EncodeContext,\n                  tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_struct(\"ty_param_bounds_and_ty\", 2) |this| {\n-            do this.emit_struct_field(~\"generics\", 0) |this| {\n+            do this.emit_struct_field(\"generics\", 0) |this| {\n                 do this.emit_struct(\"Generics\", 2) |this| {\n-                    do this.emit_struct_field(~\"type_param_defs\", 0) |this| {\n+                    do this.emit_struct_field(\"type_param_defs\", 0) |this| {\n                         do this.emit_from_vec(*tpbt.generics.type_param_defs)\n                                 |this, type_param_def| {\n                             this.emit_type_param_def(ecx, type_param_def);\n                         }\n                     }\n-                    do this.emit_struct_field(~\"region_param\", 1) |this| {\n+                    do this.emit_struct_field(\"region_param\", 1) |this| {\n                         tpbt.generics.region_param.encode(this);\n                     }\n                 }\n             }\n-            do this.emit_struct_field(~\"ty\", 1) |this| {\n+            do this.emit_struct_field(\"ty\", 1) |this| {\n                 this.emit_ty(ecx, tpbt.ty);\n             }\n         }"}, {"sha": "ce9027e257958b046b4e3d5c590f8b50768d8ec7", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -719,15 +719,15 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n                         None,\n                         expr.callee_id,\n                         expr.span,\n-                        ~[rval]);\n+                        [rval]);\n       }\n       ast::expr_unary(*) | ast::expr_index(*)\n       if this.bccx.method_map.contains_key(&expr.id) => {\n         this.check_call(expr,\n                         None,\n                         expr.callee_id,\n                         expr.span,\n-                        ~[]);\n+                        []);\n       }\n       _ => { }\n     }"}, {"sha": "bc3db4602b03c16870b83cf13ba555819a988e9d", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -79,7 +79,7 @@ pub fn check_crate(\n     visit::visit_crate(crate, bccx, v);\n \n     if tcx.sess.borrowck_stats() {\n-        io::println(~\"--- borrowck stats ---\");\n+        io::println(\"--- borrowck stats ---\");\n         io::println(fmt!(\"paths requiring guarantees: %u\",\n                         bccx.stats.guaranteed_paths));\n         io::println(fmt!(\"paths requiring loans     : %s\",\n@@ -557,27 +557,27 @@ pub impl BorrowckCtxt {\n             err_out_of_root_scope(super_scope, sub_scope) => {\n                 note_and_explain_region(\n                     self.tcx,\n-                    ~\"managed value would have to be rooted for \",\n+                    \"managed value would have to be rooted for \",\n                     sub_scope,\n-                    ~\"...\");\n+                    \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    ~\"...but can only be rooted for \",\n+                    \"...but can only be rooted for \",\n                     super_scope,\n-                    ~\"\");\n+                    \"\");\n             }\n \n             err_out_of_scope(super_scope, sub_scope) => {\n                 note_and_explain_region(\n                     self.tcx,\n-                    ~\"borrowed pointer must be valid for \",\n+                    \"borrowed pointer must be valid for \",\n                     sub_scope,\n-                    ~\"...\");\n+                    \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    ~\"...but borrowed value is only valid for \",\n+                    \"...but borrowed value is only valid for \",\n                     super_scope,\n-                    ~\"\");\n+                    \"\");\n           }\n         }\n     }"}, {"sha": "7a815681173139560386465b05376ed6af51950e", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -129,7 +129,7 @@ pub fn raw_pat(p: @pat) -> @pat {\n \n pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n     assert!((!pats.is_empty()));\n-    let ext = match is_useful(cx, &pats.map(|p| ~[*p]), ~[wild()]) {\n+    let ext = match is_useful(cx, &pats.map(|p| ~[*p]), [wild()]) {\n         not_useful => {\n             // This is good, wildcard pattern isn't reachable\n             return;"}, {"sha": "9c9f72adc4df2ddf5ccb9609f614996b5fb4c4a5", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -357,7 +357,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::stmt_mac(*) => {\n-                self.tcx().sess.span_bug(stmt.span, ~\"unexpanded macro\");\n+                self.tcx().sess.span_bug(stmt.span, \"unexpanded macro\");\n             }\n         }\n     }\n@@ -724,7 +724,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_mac(*) => {\n-                self.tcx().sess.span_bug(expr.span, ~\"unexpanded macro\");\n+                self.tcx().sess.span_bug(expr.span, \"unexpanded macro\");\n             }\n         }\n "}, {"sha": "e478f29adf90a4e28d60ae4ffffec6d62b72a5d3", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -78,7 +78,7 @@ fn find_item(item: @item, ctxt: @mut EntryContext, visitor: EntryVisitor) {\n                             } else {\n                                 ctxt.session.span_err(\n                                     item.span,\n-                                    ~\"multiple 'main' functions\");\n+                                    \"multiple 'main' functions\");\n                             }\n                         } else {\n                             // This isn't main\n@@ -89,23 +89,23 @@ fn find_item(item: @item, ctxt: @mut EntryContext, visitor: EntryVisitor) {\n                 }\n             }\n \n-            if attrs_contains_name(item.attrs, ~\"main\") {\n+            if attrs_contains_name(item.attrs, \"main\") {\n                 if ctxt.attr_main_fn.is_none() {\n                     ctxt.attr_main_fn = Some((item.id, item.span));\n                 } else {\n                     ctxt.session.span_err(\n                         item.span,\n-                        ~\"multiple 'main' functions\");\n+                        \"multiple 'main' functions\");\n                 }\n             }\n \n-            if attrs_contains_name(item.attrs, ~\"start\") {\n+            if attrs_contains_name(item.attrs, \"start\") {\n                 if ctxt.start_fn.is_none() {\n                     ctxt.start_fn = Some((item.id, item.span));\n                 } else {\n                     ctxt.session.span_err(\n                         item.span,\n-                        ~\"multiple 'start' functions\");\n+                        \"multiple 'start' functions\");\n                 }\n             }\n         }\n@@ -129,15 +129,15 @@ fn configure_main(ctxt: @mut EntryContext) {\n     } else {\n         if !*this.session.building_library {\n             // No main function\n-            this.session.err(~\"main function not found\");\n+            this.session.err(\"main function not found\");\n             if !this.non_main_fns.is_empty() {\n                 // There were some functions named 'main' though. Try to give the user a hint.\n-                this.session.note(~\"the main function must be defined at the crate level \\\n-                                    but you have one or more functions named 'main' that are not \\\n-                                    defined at the crate level. Either move the definition or \\\n-                                    attach the `#[main]` attribute to override this behavior.\");\n+                this.session.note(\"the main function must be defined at the crate level \\\n+                                   but you have one or more functions named 'main' that are not \\\n+                                   defined at the crate level. Either move the definition or \\\n+                                   attach the `#[main]` attribute to override this behavior.\");\n                 for this.non_main_fns.each |&(_, span)| {\n-                    this.session.span_note(span, ~\"here is a function named 'main'\");\n+                    this.session.span_note(span, \"here is a function named 'main'\");\n                 }\n             }\n             this.session.abort_if_errors();"}, {"sha": "bade18e1787a1ce38c8c94869e5e1228b94db913", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -122,7 +122,7 @@ fn check_item(item: @item, cx: Context, visitor: visit::vt<Context>) {\n         match item.node {\n             item_impl(_, Some(trait_ref), self_type, _) => {\n                 match cx.tcx.def_map.find(&trait_ref.ref_id) {\n-                    None => cx.tcx.sess.bug(~\"trait ref not in def map!\"),\n+                    None => cx.tcx.sess.bug(\"trait ref not in def map!\"),\n                     Some(&trait_def) => {\n                         let trait_def_id = ast_util::def_id_of_def(trait_def);\n                         if cx.tcx.lang_items.drop_trait() == trait_def_id {\n@@ -270,7 +270,7 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n             // Even though the callee_id may have been the id with\n             // node_type_substs, e.id is correct here.\n             ty::method_call_type_param_defs(cx.tcx, cx.method_map, e.id).expect(\n-                ~\"non path/method call expr has type substs??\")\n+                \"non path/method call expr has type substs??\")\n           }\n         };\n         if ts.len() != type_param_defs.len() {"}, {"sha": "b14197649379b863af88840ed4b625ff43fe4c01", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 72, "deletions": 2, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -79,6 +79,7 @@ pub enum lint {\n     unused_variable,\n     dead_assignment,\n     unused_mut,\n+    unnecessary_allocation,\n }\n \n pub fn level_to_str(lv: level) -> &'static str {\n@@ -242,6 +243,13 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         desc: \"detect mut variables which don't need to be mutable\",\n         default: warn\n     }),\n+\n+    (\"unnecessary_allocation\",\n+     LintSpec {\n+        lint: unnecessary_allocation,\n+        desc: \"detects unnecessary allocations that can be eliminated\",\n+        default: warn\n+    }),\n ];\n \n /*\n@@ -431,7 +439,7 @@ pub fn each_lint(sess: session::Session,\n             let metas = match meta.node {\n                 ast::meta_list(_, ref metas) => metas,\n                 _ => {\n-                    sess.span_err(meta.span, ~\"malformed lint attribute\");\n+                    sess.span_err(meta.span, \"malformed lint attribute\");\n                     loop;\n                 }\n             };\n@@ -443,7 +451,7 @@ pub fn each_lint(sess: session::Session,\n                         }\n                     }\n                     _ => {\n-                        sess.span_err(meta.span, ~\"malformed lint attribute\");\n+                        sess.span_err(meta.span, \"malformed lint attribute\");\n                     }\n                 }\n             }\n@@ -881,6 +889,67 @@ fn lint_session(cx: @mut Context) -> visit::vt<()> {\n     })\n }\n \n+fn lint_unnecessary_allocations(cx: @mut Context) -> visit::vt<()> {\n+    // If the expression `e` has an allocated type, but `t` dictates that it's\n+    // something like a slice (doesn't need allocation), emit a warning with the\n+    // specified span.\n+    //\n+    // Currently, this only applies to string and vector literals with sigils in\n+    // front. Those can have the sigil removed to get a borrowed pointer\n+    // automatically.\n+    fn check(cx: @mut Context, e: @ast::expr, t: ty::t) {\n+        match e.node {\n+            ast::expr_vstore(e2, ast::expr_vstore_uniq) |\n+            ast::expr_vstore(e2, ast::expr_vstore_box) => {\n+                match e2.node {\n+                    ast::expr_lit(@codemap::spanned{\n+                            node: ast::lit_str(*), _}) |\n+                    ast::expr_vec(*) => {}\n+                    _ => return\n+                }\n+            }\n+\n+            _ => return\n+        }\n+\n+        match ty::get(t).sty {\n+            ty::ty_estr(ty::vstore_slice(*)) |\n+            ty::ty_evec(_, ty::vstore_slice(*)) => {\n+                cx.span_lint(unnecessary_allocation,\n+                             e.span, \"unnecessary allocation, the sigil can be \\\n+                                      removed\");\n+            }\n+\n+            _ => ()\n+        }\n+    }\n+\n+    let visit_expr: @fn(@ast::expr) = |e| {\n+        match e.node {\n+            ast::expr_call(c, ref args, _) => {\n+                let t = ty::node_id_to_type(cx.tcx, c.id);\n+                let s = ty::ty_fn_sig(t);\n+                for vec::each2(*args, s.inputs) |e, t| {\n+                    check(cx, *e, *t);\n+                }\n+            }\n+            ast::expr_method_call(_, _, _, ref args, _) => {\n+                let t = ty::node_id_to_type(cx.tcx, e.callee_id);\n+                let s = ty::ty_fn_sig(t);\n+                for vec::each2(*args, s.inputs) |e, t| {\n+                    check(cx, *e, *t);\n+                }\n+            }\n+            _ => {}\n+        }\n+    };\n+\n+    visit::mk_simple_visitor(@visit::SimpleVisitor {\n+        visit_expr: visit_expr,\n+        .. *visit::default_simple_visitor()\n+    })\n+}\n+\n pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     let cx = @mut Context {\n         dict: @get_lint_dict(),\n@@ -908,6 +977,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     cx.add_lint(lint_unused_unsafe(cx));\n     cx.add_lint(lint_unused_mut(cx));\n     cx.add_lint(lint_session(cx));\n+    cx.add_lint(lint_unnecessary_allocations(cx));\n \n     // type inference doesn't like this being declared below, we need to tell it\n     // what the type of this first function is..."}, {"sha": "4608f773a1c2696def3f019dc541cec1338fe21e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -726,7 +726,7 @@ pub impl Liveness {\n         for uint::range(0, self.ir.num_vars) |var_idx| {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n-                wr.write_str(~\" \");\n+                wr.write_str(\" \");\n                 wr.write_str(Variable(var_idx).to_str());\n             }\n         }\n@@ -750,7 +750,7 @@ pub impl Liveness {\n                     loop_scope.len()\n                 };\n                 if len == 0 {\n-                    self.tcx.sess.span_bug(sp, ~\"break outside loop\");\n+                    self.tcx.sess.span_bug(sp, \"break outside loop\");\n                 } else {\n                     // FIXME(#5275): this shouldn't have to be a method...\n                     self.last_loop_scope()\n@@ -766,18 +766,18 @@ pub impl Liveness {\n \n     fn ln_str(&self, ln: LiveNode) -> ~str {\n         do io::with_str_writer |wr| {\n-            wr.write_str(~\"[ln(\");\n+            wr.write_str(\"[ln(\");\n             wr.write_uint(*ln);\n-            wr.write_str(~\") of kind \");\n+            wr.write_str(\") of kind \");\n             wr.write_str(fmt!(\"%?\", copy self.ir.lnks[*ln]));\n-            wr.write_str(~\" reads\");\n+            wr.write_str(\" reads\");\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n-            wr.write_str(~\"  writes\");\n+            wr.write_str(\"  writes\");\n             self.write_vars(wr, ln, |idx| self.users[idx].writer );\n-            wr.write_str(~\" \");\n-            wr.write_str(~\" precedes \");\n+            wr.write_str(\" \");\n+            wr.write_str(\" precedes \");\n             wr.write_str((copy self.successors[*ln]).to_str());\n-            wr.write_str(~\"]\");\n+            wr.write_str(\"]\");\n         }\n     }\n \n@@ -1195,7 +1195,7 @@ pub impl Liveness {\n           expr_log(l, r) |\n           expr_index(l, r) |\n           expr_binary(_, l, r) => {\n-            self.propagate_through_exprs(~[l, r], succ)\n+            self.propagate_through_exprs([l, r], succ)\n           }\n \n           expr_addr_of(_, e) |"}, {"sha": "6ce074b52649269a465525a65b5ab00c1b1a9fc8", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -400,7 +400,7 @@ pub fn check_crate(tcx: ty::ctxt,\n             // Do not check privacy inside items with the resolve_unexported\n             // attribute. This is used for the test runner.\n             if !attr::contains_name(attr::attr_metas(/*bad*/copy item.attrs),\n-                                    ~\"!resolve_unexported\") {\n+                                    \"!resolve_unexported\") {\n                 visit::visit_item(item, method_map, visitor);\n             }\n         },"}, {"sha": "cbe9e908da4f93a97571a1dcff45ce6500e5aebd", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -381,7 +381,7 @@ pub fn resolve_stmt(stmt: @ast::stmt, cx: Context, visitor: visit::vt<Context>)\n             let expr_cx = Context {parent: Some(stmt_id), ..cx};\n             visit::visit_stmt(stmt, expr_cx, visitor);\n         }\n-        ast::stmt_mac(*) => cx.sess.bug(~\"unexpanded macro\")\n+        ast::stmt_mac(*) => cx.sess.bug(\"unexpanded macro\")\n     }\n }\n "}, {"sha": "12ad7251645f8a750bad03ed914e901e758b1469", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -2600,7 +2600,7 @@ pub impl Resolver {\n                         match result {\n                             Failed => {\n                                 self.session.span_err(span,\n-                                                      ~\"unresolved name\");\n+                                                      \"unresolved name\");\n                                 return Failed;\n                             }\n                             Indeterminate => {\n@@ -2982,7 +2982,7 @@ pub impl Resolver {\n         if index != import_count {\n             let sn = self.session.codemap.span_to_snippet(imports[index].span);\n             if str::contains(sn, \"::\") {\n-                self.session.span_err(imports[index].span, ~\"unresolved import\");\n+                self.session.span_err(imports[index].span, \"unresolved import\");\n             } else {\n                 let err = fmt!(\"unresolved import (maybe you meant `%s::*`?)\",\n                                sn.slice(0, sn.len() - 1)); // -1 to adjust for semicolon\n@@ -3265,14 +3265,14 @@ pub impl Resolver {\n \n                         self.session.span_err(\n                             span,\n-                            ~\"attempted dynamic environment-capture\");\n+                            \"attempted dynamic environment-capture\");\n                     } else {\n                         // This was an attempt to use a type parameter outside\n                         // its scope.\n \n                         self.session.span_err(span,\n-                                              ~\"attempt to use a type \\\n-                                               argument out of scope\");\n+                                              \"attempt to use a type \\\n+                                              argument out of scope\");\n                     }\n \n                     return None;\n@@ -3287,23 +3287,23 @@ pub impl Resolver {\n \n                         self.session.span_err(\n                             span,\n-                            ~\"attempted dynamic environment-capture\");\n+                            \"attempted dynamic environment-capture\");\n                     } else {\n                         // This was an attempt to use a type parameter outside\n                         // its scope.\n \n                         self.session.span_err(span,\n-                                              ~\"attempt to use a type \\\n-                                               argument out of scope\");\n+                                              \"attempt to use a type \\\n+                                              argument out of scope\");\n                     }\n \n                     return None;\n                 }\n                 ConstantItemRibKind => {\n                     // Still doesn't deal with upvars\n                     self.session.span_err(span,\n-                                          ~\"attempt to use a non-constant \\\n-                                            value in a constant\");\n+                                          \"attempt to use a non-constant \\\n+                                           value in a constant\");\n \n                 }\n             }\n@@ -3368,7 +3368,7 @@ pub impl Resolver {\n         // This is used to allow the test runner to run unexported tests.\n         let orig_xray_flag = self.xray_context;\n         if contains_name(attr_metas(item.attrs),\n-                         ~\"!resolve_unexported\") {\n+                         \"!resolve_unexported\") {\n             self.xray_context = Xray;\n         }\n \n@@ -3440,8 +3440,8 @@ pub impl Resolver {\n                                                 visitor) {\n                             None =>\n                                 self.session.span_err(trt.path.span,\n-                                                      ~\"attempt to derive a \\\n-                                                       nonexistent trait\"),\n+                                                      \"attempt to derive a \\\n+                                                      nonexistent trait\"),\n                             Some(def) => {\n                                 // Write a mapping from the trait ID to the\n                                 // definition of the trait into the definition\n@@ -3715,8 +3715,8 @@ pub impl Resolver {\n         match self.resolve_path(trait_reference.path, TypeNS, true, visitor) {\n             None => {\n                 self.session.span_err(trait_reference.path.span,\n-                                      ~\"attempt to implement an \\\n-                                        unknown trait\");\n+                                      \"attempt to implement an \\\n+                                       unknown trait\");\n             }\n             Some(def) => {\n                 self.record_def(trait_reference.ref_id, def);\n@@ -4110,8 +4110,8 @@ pub impl Resolver {\n                         }\n                         FoundConst(_) => {\n                             self.session.span_err(pattern.span,\n-                                                  ~\"only refutable patterns \\\n-                                                    allowed here\");\n+                                                  \"only refutable patterns \\\n+                                                   allowed here\");\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `%s`\",\n@@ -4211,7 +4211,7 @@ pub impl Resolver {\n                         }\n                         None => {\n                             self.session.span_err(path.span,\n-                                                  ~\"unresolved enum variant\");\n+                                                  \"unresolved enum variant\");\n                         }\n                     }\n \n@@ -4239,8 +4239,8 @@ pub impl Resolver {\n                         }\n                         None => {\n                             self.session.span_err(path.span,\n-                                                  ~\"unresolved enum variant, \\\n-                                                    struct or const\");\n+                                                  \"unresolved enum variant, \\\n+                                                   struct or const\");\n                         }\n                     }\n \n@@ -4614,8 +4614,8 @@ pub impl Resolver {\n                         Some(dl_def(def)) => return Some(def),\n                         _ => {\n                             self.session.span_bug(span,\n-                                                  ~\"self wasn't mapped to a \\\n-                                                    def?!\")\n+                                                  \"self wasn't mapped to a \\\n+                                                   def?!\")\n                         }\n                     }\n                 }\n@@ -4845,8 +4845,8 @@ pub impl Resolver {\n                     }\n                     Some(_) => {\n                         self.session.span_bug(expr.span,\n-                                              ~\"label wasn't mapped to a \\\n-                                                label def!\")\n+                                              \"label wasn't mapped to a \\\n+                                               label def!\")\n                     }\n                 }\n             }\n@@ -4855,8 +4855,8 @@ pub impl Resolver {\n                 match self.resolve_self_value_in_local_ribs(expr.span) {\n                     None => {\n                         self.session.span_err(expr.span,\n-                                              ~\"`self` is not allowed in \\\n-                                                this context\")\n+                                              \"`self` is not allowed in \\\n+                                               this context\")\n                     }\n                     Some(def) => self.record_def(expr.id, def),\n                 }"}, {"sha": "fa545f033a584d85a1572db5cf562a09c9a0ca9b", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -296,7 +296,7 @@ pub fn variant_opt(bcx: block, pat_id: ast::node_id)\n             return lit(UnitLikeStructLit(pat_id));\n         }\n         _ => {\n-            ccx.sess.bug(~\"non-variant or struct in variant_opt()\");\n+            ccx.sess.bug(\"non-variant or struct in variant_opt()\");\n         }\n     }\n }\n@@ -891,10 +891,10 @@ pub fn extract_vec_elems(bcx: block,\n \n     let mut elems = do vec::from_fn(elem_count) |i| {\n         match slice {\n-            None => GEPi(bcx, base, ~[i]),\n-            Some(n) if i < n => GEPi(bcx, base, ~[i]),\n+            None => GEPi(bcx, base, [i]),\n+            Some(n) if i < n => GEPi(bcx, base, [i]),\n             Some(n) if i > n => {\n-                InBoundsGEP(bcx, base, ~[\n+                InBoundsGEP(bcx, base, [\n                     Sub(bcx, count,\n                         C_int(bcx.ccx(), (elem_count - i) as int))])\n             }\n@@ -1089,11 +1089,8 @@ pub fn compare_values(cx: block,\n             let scratch_rhs = alloca(cx, val_ty(rhs));\n             Store(cx, rhs, scratch_rhs);\n             let did = cx.tcx().lang_items.uniq_str_eq_fn();\n-            let bcx = callee::trans_lang_call(cx, did,\n-                                                        ~[scratch_lhs,\n-                                                          scratch_rhs],\n-                                                        expr::SaveIn(\n-                                                         scratch_result.val));\n+            let bcx = callee::trans_lang_call(cx, did, [scratch_lhs, scratch_rhs],\n+                                              expr::SaveIn(scratch_result.val));\n             let result = scratch_result.to_result(bcx);\n             Result {\n                 bcx: result.bcx,\n@@ -1103,18 +1100,16 @@ pub fn compare_values(cx: block,\n         ty::ty_estr(_) => {\n             let scratch_result = scratch_datum(cx, ty::mk_bool(), false);\n             let did = cx.tcx().lang_items.str_eq_fn();\n-            let bcx = callee::trans_lang_call(cx, did,\n-                                                        ~[lhs, rhs],\n-                                                        expr::SaveIn(\n-                                                         scratch_result.val));\n+            let bcx = callee::trans_lang_call(cx, did, [lhs, rhs],\n+                                              expr::SaveIn(scratch_result.val));\n             let result = scratch_result.to_result(bcx);\n             Result {\n                 bcx: result.bcx,\n                 val: bool_to_i1(result.bcx, result.val)\n             }\n         }\n         _ => {\n-            cx.tcx().sess.bug(~\"only scalars and strings supported in \\\n+            cx.tcx().sess.bug(\"only scalars and strings supported in \\\n                                 compare_values\");\n         }\n     }\n@@ -1343,7 +1338,7 @@ pub fn compile_submatch(bcx: block,\n         let tup_repr = adt::represent_type(bcx.ccx(), tup_ty);\n         let n_tup_elts = match ty::get(tup_ty).sty {\n           ty::ty_tup(ref elts) => elts.len(),\n-          _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n+          _ => ccx.sess.bug(\"non-tuple type in tuple pattern\")\n         };\n         let tup_vals = do vec::from_fn(n_tup_elts) |i| {\n             adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n@@ -1362,7 +1357,7 @@ pub fn compile_submatch(bcx: block,\n                     ty::lookup_struct_fields(tcx, struct_id).len();\n             }\n             _ => {\n-                ccx.sess.bug(~\"non-struct type in tuple struct pattern\");\n+                ccx.sess.bug(\"non-struct type in tuple struct pattern\");\n             }\n         }\n \n@@ -1478,8 +1473,8 @@ pub fn compile_submatch(bcx: block,\n                       }\n                       _ => {\n                           bcx.sess().bug(\n-                              ~\"in compile_submatch, expected \\\n-                                trans_opt to return a single_result\")\n+                              \"in compile_submatch, expected \\\n+                               trans_opt to return a single_result\")\n                       }\n                   }\n               }\n@@ -1689,7 +1684,7 @@ pub fn trans_match_inner(scope_cx: block,\n         }\n     };\n     let lldiscr = discr_datum.to_ref_llval(bcx);\n-    compile_submatch(bcx, matches, ~[lldiscr], chk);\n+    compile_submatch(bcx, matches, [lldiscr], chk);\n \n     let mut arm_cxs = ~[];\n     for arm_datas.each |arm_data| {"}, {"sha": "4d1c4851e1f6b7b82fd68941a96acbc48c0afe72", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -158,7 +158,7 @@ fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n \n             if cases.len() == 0 {\n                 // Uninhabitable; represent as unit\n-                return Univariant(mk_struct(cx, ~[], false), false);\n+                return Univariant(mk_struct(cx, [], false), false);\n             }\n \n             if cases.all(|c| c.tys.len() == 0) {\n@@ -206,7 +206,7 @@ fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n             let discr = ~[ty::mk_int()];\n             return General(cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n         }\n-        _ => cx.sess.bug(~\"adt::represent_type called on non-ADT type\")\n+        _ => cx.sess.bug(\"adt::represent_type called on non-ADT type\")\n     }\n }\n \n@@ -353,7 +353,7 @@ pub fn trans_case(bcx: block, r: &Repr, discr: int) -> _match::opt_result {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n         }\n         Univariant(*) => {\n-            bcx.ccx().sess.bug(~\"no cases for univariants or structs\")\n+            bcx.ccx().sess.bug(\"no cases for univariants or structs\")\n         }\n         General(*) => {\n             _match::single_result(rslt(bcx, C_int(bcx.ccx(), discr)))\n@@ -423,7 +423,7 @@ pub fn trans_field_ptr(bcx: block, r: &Repr, val: ValueRef, discr: int,\n     // someday), it will need to return a possibly-new bcx as well.\n     match *r {\n         CEnum(*) => {\n-            bcx.ccx().sess.bug(~\"element access in C-like enum\")\n+            bcx.ccx().sess.bug(\"element access in C-like enum\")\n         }\n         Univariant(ref st, _dtor) => {\n             assert_eq!(discr, 0);\n@@ -468,8 +468,7 @@ fn struct_field_ptr(bcx: block, st: &Struct, val: ValueRef, ix: uint,\n pub fn trans_drop_flag_ptr(bcx: block, r: &Repr, val: ValueRef) -> ValueRef {\n     match *r {\n         Univariant(ref st, true) => GEPi(bcx, val, [0, st.fields.len() - 1]),\n-        _ => bcx.ccx().sess.bug(~\"tried to get drop flag of non-droppable \\\n-                                  type\")\n+        _ => bcx.ccx().sess.bug(\"tried to get drop flag of non-droppable type\")\n     }\n }\n \n@@ -600,7 +599,7 @@ pub fn const_get_discrim(ccx: @CrateContext, r: &Repr, val: ValueRef)\n pub fn const_get_field(ccx: @CrateContext, r: &Repr, val: ValueRef,\n                        _discr: int, ix: uint) -> ValueRef {\n     match *r {\n-        CEnum(*) => ccx.sess.bug(~\"element access in C-like enum const\"),\n+        CEnum(*) => ccx.sess.bug(\"element access in C-like enum const\"),\n         Univariant(*) => const_struct_field(ccx, val, ix),\n         General(*) => const_struct_field(ccx, val, ix + 1),\n         NullablePointer{ _ } => const_struct_field(ccx, val, ix)"}, {"sha": "94ca02b22554b41f15279be9b70e464fc3617da8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 163, "deletions": 165, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -235,7 +235,7 @@ pub fn umin(cx: block, a: ValueRef, b: ValueRef) -> ValueRef {\n pub fn ptr_offs(bcx: block, base: ValueRef, sz: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"ptr_offs\");\n     let raw = PointerCast(bcx, base, T_ptr(T_i8()));\n-    InBoundsGEP(bcx, raw, ~[sz])\n+    InBoundsGEP(bcx, raw, [sz])\n }\n \n // Increment a pointer by a given amount and then cast it to be a pointer\n@@ -296,7 +296,7 @@ pub fn malloc_raw_dyn(bcx: block,\n     let bcx = callee::trans_lang_call(\n         bcx,\n         langcall,\n-        ~[tydesc, size],\n+        [tydesc, size],\n         expr::SaveIn(rval));\n     let r = rslt(bcx, PointerCast(bcx, Load(bcx, rval), llty));\n     maybe_set_managed_unique_rc(r.bcx, r.val, heap);\n@@ -314,7 +314,7 @@ pub fn malloc_raw_dyn(bcx: block,\n pub fn non_gc_box_cast(bcx: block, val: ValueRef) -> ValueRef {\n     unsafe {\n         debug!(\"non_gc_box_cast\");\n-        add_comment(bcx, ~\"non_gc_box_cast\");\n+        add_comment(bcx, \"non_gc_box_cast\");\n         assert!(llvm::LLVMGetPointerAddressSpace(val_ty(val)) ==\n                      gc_box_addrspace || bcx.unreachable);\n         let non_gc_t = T_ptr(llvm::LLVMGetElementType(val_ty(val)));\n@@ -563,8 +563,8 @@ pub fn compare_scalar_types(cx: block,\n         }\n         _ => {\n             // Should never get here, because t is scalar.\n-            cx.sess().bug(~\"non-scalar type passed to \\\n-                            compare_scalar_types\")\n+            cx.sess().bug(\"non-scalar type passed to \\\n+                           compare_scalar_types\")\n         }\n     }\n }\n@@ -579,8 +579,8 @@ pub fn compare_scalar_values(cx: block,\n                           -> ValueRef {\n     let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n     fn die(cx: block) -> ! {\n-        cx.tcx().sess.bug(~\"compare_scalar_values: must be a\\\n-          comparison operator\");\n+        cx.tcx().sess.bug(\"compare_scalar_values: must be a\\\n+                           comparison operator\");\n     }\n     match nt {\n       nil_type => {\n@@ -720,18 +720,18 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n                           _match::single_result(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n                           }\n-                          _ => ccx.sess.unimpl(~\"value from adt::trans_case \\\n-                                                 in iter_structural_ty\")\n+                          _ => ccx.sess.unimpl(\"value from adt::trans_case \\\n+                                                in iter_structural_ty\")\n                       }\n                       Br(variant_cx, next_cx.llbb);\n                   }\n                   cx = next_cx;\n               }\n-              _ => ccx.sess.unimpl(~\"value from adt::trans_switch \\\n-                                     in iter_structural_ty\")\n+              _ => ccx.sess.unimpl(\"value from adt::trans_switch \\\n+                                    in iter_structural_ty\")\n           }\n       }\n-      _ => cx.sess().unimpl(~\"type in iter_structural_ty\")\n+      _ => cx.sess().unimpl(\"type in iter_structural_ty\")\n     }\n     return cx;\n }\n@@ -959,7 +959,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // The landing pad return type (the type being propagated). Not sure what\n     // this represents but it's determined by the personality function and\n     // this is what the EH proposal example uses.\n-    let llretty = T_struct(~[T_ptr(T_i8()), T_i32()], false);\n+    let llretty = T_struct([T_ptr(T_i8()), T_i32()], false);\n     // The exception handling personality function. This is the C++\n     // personality function __gxx_personality_v0, wrapped in our naming\n     // convention.\n@@ -972,7 +972,7 @@ pub fn get_landing_pad(bcx: block) -> BasicBlockRef {\n     // Because we may have unwound across a stack boundary, we must call into\n     // the runtime to figure out which stack segment we are on and place the\n     // stack limit back into the TLS.\n-    Call(pad_bcx, bcx.ccx().upcalls.reset_stack_limit, ~[]);\n+    Call(pad_bcx, bcx.ccx().upcalls.reset_stack_limit, []);\n \n     // We store the retval in a function-central alloca, so that calls to\n     // Resume can find it.\n@@ -1159,7 +1159,7 @@ pub fn trans_stmt(cx: block, s: &ast::stmt) -> block {\n                 ast::decl_item(i) => trans_item(*cx.fcx.ccx, i)\n             }\n         }\n-        ast::stmt_mac(*) => cx.tcx().sess.bug(~\"unexpanded macro\")\n+        ast::stmt_mac(*) => cx.tcx().sess.bug(\"unexpanded macro\")\n     }\n \n     return bcx;\n@@ -1462,7 +1462,7 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(1i32);\n     let volatile = C_i1(false);\n-    Call(cx, memcpy, ~[dst_ptr, src_ptr, size, align, volatile]);\n+    Call(cx, memcpy, [dst_ptr, src_ptr, size, align, volatile]);\n }\n \n pub fn memcpy_ty(bcx: block, dst: ValueRef, src: ValueRef, t: ty::t) {\n@@ -1509,7 +1509,7 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n     let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n     let align = C_i32(1i32);\n     let volatile = C_i1(false);\n-    Call(cx, llintrinsicfn, ~[llptr, llzeroval, size, align, volatile]);\n+    Call(cx, llintrinsicfn, [llptr, llzeroval, size, align, volatile]);\n }\n \n pub fn alloc_ty(bcx: block, t: ty::t) -> ValueRef {\n@@ -1559,9 +1559,9 @@ pub struct BasicBlocks {\n pub fn mk_standard_basic_blocks(llfn: ValueRef) -> BasicBlocks {\n     unsafe {\n         BasicBlocks {\n-            sa: str::as_c_str(~\"static_allocas\",\n+            sa: str::as_c_str(\"static_allocas\",\n                            |buf| llvm::LLVMAppendBasicBlock(llfn, buf)),\n-            rt: str::as_c_str(~\"return\",\n+            rt: str::as_c_str(\"return\",\n                            |buf| llvm::LLVMAppendBasicBlock(llfn, buf))\n         }\n     }\n@@ -2057,8 +2057,7 @@ pub fn trans_tuple_struct(ccx: @CrateContext,\n         let llarg = match fcx.llargs.get_copy(&field.node.id) {\n             local_mem(x) => x,\n             _ => {\n-                ccx.tcx.sess.bug(~\"trans_tuple_struct: llarg wasn't \\\n-                                   local_mem\")\n+                ccx.tcx.sess.bug(\"trans_tuple_struct: llarg wasn't local_mem\")\n             }\n         };\n         let arg_ty = arg_tys[i];\n@@ -2105,15 +2104,15 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::item) {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n                                       vec::append(/*bad*/copy *path,\n-                                                  ~[path_name(item.ident)]),\n+                                                  [path_name(item.ident)]),\n                                       decl,\n                                       body,\n                                       llfndecl,\n                                       item.id);\n         } else if !generics.is_type_parameterized() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n-                     vec::append(/*bad*/copy *path, ~[path_name(item.ident)]),\n+                     vec::append(/*bad*/copy *path, [path_name(item.ident)]),\n                      decl,\n                      body,\n                      llfndecl,\n@@ -2263,8 +2262,8 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n \n     fn create_main(ccx: @CrateContext, main_llfn: ValueRef) -> ValueRef {\n         let nt = ty::mk_nil();\n-        let llfty = type_of_fn(ccx, ~[], nt);\n-        let llfdecl = decl_fn(ccx.llmod, ~\"_rust_main\",\n+        let llfty = type_of_fn(ccx, [], nt);\n+        let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::CCallConv, llfty);\n \n         let fcx = new_fn_ctxt(ccx, ~[], llfdecl, nt, None);\n@@ -2287,19 +2286,19 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n     fn create_entry_fn(ccx: @CrateContext,\n                        rust_main: ValueRef,\n                        use_start_lang_item: bool) {\n-        let llfty = T_fn(~[ccx.int_type, T_ptr(T_ptr(T_i8()))], ccx.int_type);\n+        let llfty = T_fn([ccx.int_type, T_ptr(T_ptr(T_i8()))], ccx.int_type);\n \n         // FIXME #4404 android JNI hacks\n         let llfn = if *ccx.sess.building_library {\n-            decl_cdecl_fn(ccx.llmod, ~\"amain\", llfty)\n+            decl_cdecl_fn(ccx.llmod, \"amain\", llfty)\n         } else {\n             let main_name = match ccx.sess.targ_cfg.os {\n                 session::os_win32 => ~\"WinMain@16\",\n                 _ => ~\"main\",\n             };\n             decl_cdecl_fn(ccx.llmod, main_name, llfty)\n         };\n-        let llbb = str::as_c_str(~\"top\", |buf| {\n+        let llbb = str::as_c_str(\"top\", |buf| {\n             unsafe {\n                 llvm::LLVMAppendBasicBlock(llfn, buf)\n             }\n@@ -2310,7 +2309,7 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n \n             let start_def_id = ccx.tcx.lang_items.start_fn();\n             if start_def_id.crate == ast::local_crate {\n-                ccx.sess.bug(~\"start lang item is never in the local crate\")\n+                ccx.sess.bug(\"start lang item is never in the local crate\")\n             } else {\n                 let start_fn_type = csearch::get_type(ccx.tcx,\n                                                       start_def_id).ty;\n@@ -2328,8 +2327,8 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = ccx.tcx.lang_items.start_fn();\n                 let start_fn = if start_def_id.crate == ast::local_crate {\n-                    ccx.sess.bug(~\"start lang item is never in the local \\\n-                                   crate\")\n+                    ccx.sess.bug(\"start lang item is never in the local \\\n+                                  crate\")\n                 } else {\n                     let start_fn_type = csearch::get_type(ccx.tcx,\n                             start_def_id).ty;\n@@ -2391,7 +2390,7 @@ pub fn item_path(ccx: @CrateContext, i: @ast::item) -> path {\n             // separate map for paths?\n         _ => fail!(\"item_path\")\n     };\n-    vec::append(/*bad*/copy *base, ~[path_name(i.ident)])\n+    vec::append(/*bad*/copy *base, [path_name(i.ident)])\n }\n \n pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n@@ -2404,7 +2403,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n         let val = match tcx.items.get_copy(&id) {\n           ast_map::node_item(i, pth) => {\n             let my_path = vec::append(/*bad*/copy *pth,\n-                                      ~[path_name(i.ident)]);\n+                                      [path_name(i.ident)]);\n             match i.node {\n               ast::item_const(_, expr) => {\n                 let typ = ty::node_id_to_type(tcx, i.id);\n@@ -2442,8 +2441,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             debug!(\"get_item_val(): processing a node_trait_method\");\n             match *trait_method {\n               ast::required(_) => {\n-                ccx.sess.bug(~\"unexpected variant: required trait method in \\\n-                               get_item_val()\");\n+                ccx.sess.bug(\"unexpected variant: required trait method in \\\n+                              get_item_val()\");\n               }\n               ast::provided(m) => {\n                 exprt = true;\n@@ -2461,7 +2460,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                 ast::foreign_item_fn(*) => {\n                     register_fn(ccx, ni.span,\n                                 vec::append(/*bad*/copy *pth,\n-                                            ~[path_name(ni.ident)]),\n+                                            [path_name(ni.ident)]),\n                                 ni.id,\n                                 ni.attrs)\n                 }\n@@ -2486,8 +2485,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                 ast::tuple_variant_kind(ref args) => {\n                     assert!(args.len() != 0u);\n                     let pth = vec::append(/*bad*/copy *pth,\n-                                          ~[path_name(enm.ident),\n-                                            path_name((*v).node.name)]);\n+                                          [path_name(enm.ident),\n+                                           path_name((*v).node.name)]);\n                     llfn = match enm.node {\n                       ast::item_enum(_, _) => {\n                         register_fn(ccx, (*v).span, pth, id, enm.attrs)\n@@ -2507,8 +2506,8 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n             // Only register the constructor if this is a tuple-like struct.\n             match struct_def.ctor_id {\n                 None => {\n-                    tcx.sess.bug(~\"attempt to register a constructor of \\\n-                                       a non-tuple-like struct\")\n+                    tcx.sess.bug(\"attempt to register a constructor of \\\n+                                  a non-tuple-like struct\")\n                 }\n                 Some(ctor_id) => {\n                     let llfn = register_fn(ccx,\n@@ -2541,7 +2540,7 @@ pub fn register_method(ccx: @CrateContext,\n                        pth: @ast_map::path,\n                        m: @ast::method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n-    let pth = vec::append(/*bad*/copy *pth, ~[path_name((ccx.names)(\"meth\")),\n+    let pth = vec::append(/*bad*/copy *pth, [path_name((ccx.names)(\"meth\")),\n                                   path_name(m.ident)]);\n     let llfn = register_fn_full(ccx, m.span, pth, id, m.attrs, mty);\n     set_inline_hint_if_appr(m.attrs, llfn);\n@@ -2559,7 +2558,7 @@ pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n         let mut i = 0;\n         let path = item_path(ccx, it);\n         for (*enum_definition).variants.each |variant| {\n-            let p = vec::append(/*bad*/copy path, ~[\n+            let p = vec::append(/*bad*/copy path, [\n                 path_name(variant.node.name),\n                 path_name(special_idents::descrim)\n             ]);\n@@ -2617,126 +2616,126 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n     let T_trap_args: ~[TypeRef] = ~[];\n     let T_frameaddress_args: ~[TypeRef] = ~[T_i32()];\n     let gcroot =\n-        decl_cdecl_fn(llmod, ~\"llvm.gcroot\",\n-                      T_fn(~[T_ptr(T_ptr(T_i8())), T_ptr(T_i8())],\n+        decl_cdecl_fn(llmod, \"llvm.gcroot\",\n+                      T_fn([T_ptr(T_ptr(T_i8())), T_ptr(T_i8())],\n                            T_void()));\n     let gcread =\n-        decl_cdecl_fn(llmod, ~\"llvm.gcread\",\n-                      T_fn(~[T_ptr(T_i8()), T_ptr(T_ptr(T_i8()))],\n+        decl_cdecl_fn(llmod, \"llvm.gcread\",\n+                      T_fn([T_ptr(T_i8()), T_ptr(T_ptr(T_i8()))],\n                            T_void()));\n     let memcpy32 =\n-        decl_cdecl_fn(llmod, ~\"llvm.memcpy.p0i8.p0i8.i32\",\n+        decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i32\",\n                       T_fn(copy T_memcpy32_args, T_void()));\n     let memcpy64 =\n-        decl_cdecl_fn(llmod, ~\"llvm.memcpy.p0i8.p0i8.i64\",\n+        decl_cdecl_fn(llmod, \"llvm.memcpy.p0i8.p0i8.i64\",\n                       T_fn(copy T_memcpy64_args, T_void()));\n     let memmove32 =\n-        decl_cdecl_fn(llmod, ~\"llvm.memmove.p0i8.p0i8.i32\",\n+        decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i32\",\n                       T_fn(T_memcpy32_args, T_void()));\n     let memmove64 =\n-        decl_cdecl_fn(llmod, ~\"llvm.memmove.p0i8.p0i8.i64\",\n+        decl_cdecl_fn(llmod, \"llvm.memmove.p0i8.p0i8.i64\",\n                       T_fn(T_memcpy64_args, T_void()));\n     let memset32 =\n-        decl_cdecl_fn(llmod, ~\"llvm.memset.p0i8.i32\",\n+        decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i32\",\n                       T_fn(T_memset32_args, T_void()));\n     let memset64 =\n-        decl_cdecl_fn(llmod, ~\"llvm.memset.p0i8.i64\",\n+        decl_cdecl_fn(llmod, \"llvm.memset.p0i8.i64\",\n                       T_fn(T_memset64_args, T_void()));\n-    let trap = decl_cdecl_fn(llmod, ~\"llvm.trap\", T_fn(T_trap_args,\n+    let trap = decl_cdecl_fn(llmod, \"llvm.trap\", T_fn(T_trap_args,\n                                                       T_void()));\n-    let frameaddress = decl_cdecl_fn(llmod, ~\"llvm.frameaddress\",\n+    let frameaddress = decl_cdecl_fn(llmod, \"llvm.frameaddress\",\n                                      T_fn(T_frameaddress_args,\n                                           T_ptr(T_i8())));\n-    let sqrtf32 = decl_cdecl_fn(llmod, ~\"llvm.sqrt.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let sqrtf64 = decl_cdecl_fn(llmod, ~\"llvm.sqrt.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let powif32 = decl_cdecl_fn(llmod, ~\"llvm.powi.f32\",\n-                                T_fn(~[T_f32(), T_i32()], T_f32()));\n-    let powif64 = decl_cdecl_fn(llmod, ~\"llvm.powi.f64\",\n-                                T_fn(~[T_f64(), T_i32()], T_f64()));\n-    let sinf32 = decl_cdecl_fn(llmod, ~\"llvm.sin.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let sinf64 = decl_cdecl_fn(llmod, ~\"llvm.sin.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let cosf32 = decl_cdecl_fn(llmod, ~\"llvm.cos.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let cosf64 = decl_cdecl_fn(llmod, ~\"llvm.cos.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let powf32 = decl_cdecl_fn(llmod, ~\"llvm.pow.f32\",\n-                                T_fn(~[T_f32(), T_f32()], T_f32()));\n-    let powf64 = decl_cdecl_fn(llmod, ~\"llvm.pow.f64\",\n-                                T_fn(~[T_f64(), T_f64()], T_f64()));\n-    let expf32 = decl_cdecl_fn(llmod, ~\"llvm.exp.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let expf64 = decl_cdecl_fn(llmod, ~\"llvm.exp.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let exp2f32 = decl_cdecl_fn(llmod, ~\"llvm.exp2.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let exp2f64 = decl_cdecl_fn(llmod, ~\"llvm.exp2.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let logf32 = decl_cdecl_fn(llmod, ~\"llvm.log.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let logf64 = decl_cdecl_fn(llmod, ~\"llvm.log.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let log10f32 = decl_cdecl_fn(llmod, ~\"llvm.log10.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let log10f64 = decl_cdecl_fn(llmod, ~\"llvm.log10.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let log2f32 = decl_cdecl_fn(llmod, ~\"llvm.log2.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let log2f64 = decl_cdecl_fn(llmod, ~\"llvm.log2.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let fmaf32 = decl_cdecl_fn(llmod, ~\"llvm.fma.f32\",\n-                                T_fn(~[T_f32(), T_f32(), T_f32()], T_f32()));\n-    let fmaf64 = decl_cdecl_fn(llmod, ~\"llvm.fma.f64\",\n-                                T_fn(~[T_f64(), T_f64(), T_f64()], T_f64()));\n-    let fabsf32 = decl_cdecl_fn(llmod, ~\"llvm.fabs.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let fabsf64 = decl_cdecl_fn(llmod, ~\"llvm.fabs.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let floorf32 = decl_cdecl_fn(llmod, ~\"llvm.floor.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let floorf64 = decl_cdecl_fn(llmod, ~\"llvm.floor.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let ceilf32 = decl_cdecl_fn(llmod, ~\"llvm.ceil.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let ceilf64 = decl_cdecl_fn(llmod, ~\"llvm.ceil.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let truncf32 = decl_cdecl_fn(llmod, ~\"llvm.trunc.f32\",\n-                                T_fn(~[T_f32()], T_f32()));\n-    let truncf64 = decl_cdecl_fn(llmod, ~\"llvm.trunc.f64\",\n-                                T_fn(~[T_f64()], T_f64()));\n-    let ctpop8 = decl_cdecl_fn(llmod, ~\"llvm.ctpop.i8\",\n-                                T_fn(~[T_i8()], T_i8()));\n-    let ctpop16 = decl_cdecl_fn(llmod, ~\"llvm.ctpop.i16\",\n-                                T_fn(~[T_i16()], T_i16()));\n-    let ctpop32 = decl_cdecl_fn(llmod, ~\"llvm.ctpop.i32\",\n-                                T_fn(~[T_i32()], T_i32()));\n-    let ctpop64 = decl_cdecl_fn(llmod, ~\"llvm.ctpop.i64\",\n-                                T_fn(~[T_i64()], T_i64()));\n-    let ctlz8 = decl_cdecl_fn(llmod, ~\"llvm.ctlz.i8\",\n-                                T_fn(~[T_i8(), T_i1()], T_i8()));\n-    let ctlz16 = decl_cdecl_fn(llmod, ~\"llvm.ctlz.i16\",\n-                                T_fn(~[T_i16(), T_i1()], T_i16()));\n-    let ctlz32 = decl_cdecl_fn(llmod, ~\"llvm.ctlz.i32\",\n-                                T_fn(~[T_i32(), T_i1()], T_i32()));\n-    let ctlz64 = decl_cdecl_fn(llmod, ~\"llvm.ctlz.i64\",\n-                                T_fn(~[T_i64(), T_i1()], T_i64()));\n-    let cttz8 = decl_cdecl_fn(llmod, ~\"llvm.cttz.i8\",\n-                                T_fn(~[T_i8(), T_i1()], T_i8()));\n-    let cttz16 = decl_cdecl_fn(llmod, ~\"llvm.cttz.i16\",\n-                                T_fn(~[T_i16(), T_i1()], T_i16()));\n-    let cttz32 = decl_cdecl_fn(llmod, ~\"llvm.cttz.i32\",\n-                                T_fn(~[T_i32(), T_i1()], T_i32()));\n-    let cttz64 = decl_cdecl_fn(llmod, ~\"llvm.cttz.i64\",\n-                                T_fn(~[T_i64(), T_i1()], T_i64()));\n-    let bswap16 = decl_cdecl_fn(llmod, ~\"llvm.bswap.i16\",\n-                                T_fn(~[T_i16()], T_i16()));\n-    let bswap32 = decl_cdecl_fn(llmod, ~\"llvm.bswap.i32\",\n-                                T_fn(~[T_i32()], T_i32()));\n-    let bswap64 = decl_cdecl_fn(llmod, ~\"llvm.bswap.i64\",\n-                                T_fn(~[T_i64()], T_i64()));\n+    let sqrtf32 = decl_cdecl_fn(llmod, \"llvm.sqrt.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let sqrtf64 = decl_cdecl_fn(llmod, \"llvm.sqrt.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let powif32 = decl_cdecl_fn(llmod, \"llvm.powi.f32\",\n+                                T_fn([T_f32(), T_i32()], T_f32()));\n+    let powif64 = decl_cdecl_fn(llmod, \"llvm.powi.f64\",\n+                                T_fn([T_f64(), T_i32()], T_f64()));\n+    let sinf32 = decl_cdecl_fn(llmod, \"llvm.sin.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let sinf64 = decl_cdecl_fn(llmod, \"llvm.sin.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let cosf32 = decl_cdecl_fn(llmod, \"llvm.cos.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let cosf64 = decl_cdecl_fn(llmod, \"llvm.cos.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let powf32 = decl_cdecl_fn(llmod, \"llvm.pow.f32\",\n+                                T_fn([T_f32(), T_f32()], T_f32()));\n+    let powf64 = decl_cdecl_fn(llmod, \"llvm.pow.f64\",\n+                                T_fn([T_f64(), T_f64()], T_f64()));\n+    let expf32 = decl_cdecl_fn(llmod, \"llvm.exp.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let expf64 = decl_cdecl_fn(llmod, \"llvm.exp.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let exp2f32 = decl_cdecl_fn(llmod, \"llvm.exp2.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let exp2f64 = decl_cdecl_fn(llmod, \"llvm.exp2.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let logf32 = decl_cdecl_fn(llmod, \"llvm.log.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let logf64 = decl_cdecl_fn(llmod, \"llvm.log.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let log10f32 = decl_cdecl_fn(llmod, \"llvm.log10.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let log10f64 = decl_cdecl_fn(llmod, \"llvm.log10.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let log2f32 = decl_cdecl_fn(llmod, \"llvm.log2.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let log2f64 = decl_cdecl_fn(llmod, \"llvm.log2.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let fmaf32 = decl_cdecl_fn(llmod, \"llvm.fma.f32\",\n+                                T_fn([T_f32(), T_f32(), T_f32()], T_f32()));\n+    let fmaf64 = decl_cdecl_fn(llmod, \"llvm.fma.f64\",\n+                                T_fn([T_f64(), T_f64(), T_f64()], T_f64()));\n+    let fabsf32 = decl_cdecl_fn(llmod, \"llvm.fabs.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let fabsf64 = decl_cdecl_fn(llmod, \"llvm.fabs.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let floorf32 = decl_cdecl_fn(llmod, \"llvm.floor.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let floorf64 = decl_cdecl_fn(llmod, \"llvm.floor.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let ceilf32 = decl_cdecl_fn(llmod, \"llvm.ceil.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let ceilf64 = decl_cdecl_fn(llmod, \"llvm.ceil.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let truncf32 = decl_cdecl_fn(llmod, \"llvm.trunc.f32\",\n+                                T_fn([T_f32()], T_f32()));\n+    let truncf64 = decl_cdecl_fn(llmod, \"llvm.trunc.f64\",\n+                                T_fn([T_f64()], T_f64()));\n+    let ctpop8 = decl_cdecl_fn(llmod, \"llvm.ctpop.i8\",\n+                                T_fn([T_i8()], T_i8()));\n+    let ctpop16 = decl_cdecl_fn(llmod, \"llvm.ctpop.i16\",\n+                                T_fn([T_i16()], T_i16()));\n+    let ctpop32 = decl_cdecl_fn(llmod, \"llvm.ctpop.i32\",\n+                                T_fn([T_i32()], T_i32()));\n+    let ctpop64 = decl_cdecl_fn(llmod, \"llvm.ctpop.i64\",\n+                                T_fn([T_i64()], T_i64()));\n+    let ctlz8 = decl_cdecl_fn(llmod, \"llvm.ctlz.i8\",\n+                                T_fn([T_i8(), T_i1()], T_i8()));\n+    let ctlz16 = decl_cdecl_fn(llmod, \"llvm.ctlz.i16\",\n+                                T_fn([T_i16(), T_i1()], T_i16()));\n+    let ctlz32 = decl_cdecl_fn(llmod, \"llvm.ctlz.i32\",\n+                                T_fn([T_i32(), T_i1()], T_i32()));\n+    let ctlz64 = decl_cdecl_fn(llmod, \"llvm.ctlz.i64\",\n+                                T_fn([T_i64(), T_i1()], T_i64()));\n+    let cttz8 = decl_cdecl_fn(llmod, \"llvm.cttz.i8\",\n+                                T_fn([T_i8(), T_i1()], T_i8()));\n+    let cttz16 = decl_cdecl_fn(llmod, \"llvm.cttz.i16\",\n+                                T_fn([T_i16(), T_i1()], T_i16()));\n+    let cttz32 = decl_cdecl_fn(llmod, \"llvm.cttz.i32\",\n+                                T_fn([T_i32(), T_i1()], T_i32()));\n+    let cttz64 = decl_cdecl_fn(llmod, \"llvm.cttz.i64\",\n+                                T_fn([T_i64(), T_i1()], T_i64()));\n+    let bswap16 = decl_cdecl_fn(llmod, \"llvm.bswap.i16\",\n+                                T_fn([T_i16()], T_i16()));\n+    let bswap32 = decl_cdecl_fn(llmod, \"llvm.bswap.i32\",\n+                                T_fn([T_i32()], T_i32()));\n+    let bswap64 = decl_cdecl_fn(llmod, \"llvm.bswap.i64\",\n+                                T_fn([T_i64()], T_i64()));\n \n     let mut intrinsics = HashMap::new();\n     intrinsics.insert(~\"llvm.gcroot\", gcroot);\n@@ -2801,12 +2800,11 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n                               intrinsics: &mut HashMap<~str, ValueRef>) {\n     let declare =\n-        decl_cdecl_fn(llmod, ~\"llvm.dbg.declare\",\n-                      T_fn(~[T_metadata(), T_metadata()], T_void()));\n+        decl_cdecl_fn(llmod, \"llvm.dbg.declare\",\n+                      T_fn([T_metadata(), T_metadata()], T_void()));\n     let value =\n-        decl_cdecl_fn(llmod, ~\"llvm.dbg.value\",\n-                      T_fn(~[T_metadata(), T_i64(), T_metadata()],\n-                           T_void()));\n+        decl_cdecl_fn(llmod, \"llvm.dbg.value\",\n+                      T_fn([T_metadata(), T_i64(), T_metadata()], T_void()));\n     intrinsics.insert(~\"llvm.dbg.declare\", declare);\n     intrinsics.insert(~\"llvm.dbg.value\", value);\n }\n@@ -2815,7 +2813,7 @@ pub fn trap(bcx: block) {\n     let v: ~[ValueRef] = ~[];\n     match bcx.ccx().intrinsics.find(&~\"llvm.trap\") {\n       Some(&x) => { Call(bcx, x, v); },\n-      _ => bcx.sess().bug(~\"unbound llvm.trap in trap\")\n+      _ => bcx.sess().bug(\"unbound llvm.trap in trap\")\n     }\n }\n \n@@ -2838,21 +2836,21 @@ pub fn decl_gc_metadata(ccx: @CrateContext, llmod_id: &str) {\n }\n \n pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n-    let elttype = T_struct(~[ccx.int_type, ccx.int_type], false);\n+    let elttype = T_struct([ccx.int_type, ccx.int_type], false);\n     let maptype = T_array(elttype, ccx.module_data.len() + 1);\n-    let map = str::as_c_str(~\"_rust_mod_map\", |buf| {\n+    let map = str::as_c_str(\"_rust_mod_map\", |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n         }\n     });\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n     for ccx.module_data.each |key, &val| {\n-        let elt = C_struct(~[p2i(ccx, C_cstr(ccx, @/*bad*/ copy *key)),\n+        let elt = C_struct([p2i(ccx, C_cstr(ccx, @/*bad*/ copy *key)),\n                             p2i(ccx, val)]);\n         elts.push(elt);\n     }\n-    let term = C_struct(~[C_int(ccx, 0), C_int(ccx, 0)]);\n+    let term = C_struct([C_int(ccx, 0), C_int(ccx, 0)]);\n     elts.push(term);\n     unsafe {\n         llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n@@ -2876,7 +2874,7 @@ pub fn decl_crate_map(sess: session::Session, mapmeta: LinkMeta,\n     };\n     let sym_name = ~\"_rust_crate_map_\" + mapname;\n     let arrtype = T_array(int_type, n_subcrates as uint);\n-    let maptype = T_struct(~[T_i32(), T_ptr(T_i8()), int_type, arrtype], false);\n+    let maptype = T_struct([T_i32(), T_ptr(T_i8()), int_type, arrtype], false);\n     let map = str::as_c_str(sym_name, |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(llmod, maptype, buf)\n@@ -2919,11 +2917,11 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n \n     unsafe {\n         llvm::LLVMSetInitializer(map, C_struct(\n-            ~[C_i32(1),\n-              lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn,\n-                                                    T_ptr(T_i8())),\n-              p2i(ccx, create_module_map(ccx)),\n-              C_array(ccx.int_type, subcrates)]));\n+            [C_i32(1),\n+             lib::llvm::llvm::LLVMConstPointerCast(llannihilatefn,\n+                                                   T_ptr(T_i8())),\n+             p2i(ccx, create_module_map(ccx)),\n+             C_array(ccx.int_type, subcrates)]));\n     }\n }\n \n@@ -2950,8 +2948,8 @@ pub fn write_metadata(cx: @CrateContext, crate: &ast::crate) {\n     if !*cx.sess.building_library { return; }\n     let encode_parms = crate_ctxt_to_encode_parms(cx);\n     let llmeta = C_bytes(encoder::encode_metadata(encode_parms, crate));\n-    let llconst = C_struct(~[llmeta]);\n-    let mut llglobal = str::as_c_str(~\"rust_metadata\", |buf| {\n+    let llconst = C_struct([llmeta]);\n+    let mut llglobal = str::as_c_str(\"rust_metadata\", |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(cx.llmod, val_ty(llconst), buf)\n         }\n@@ -2965,11 +2963,11 @@ pub fn write_metadata(cx: @CrateContext, crate: &ast::crate) {\n \n         let t_ptr_i8 = T_ptr(T_i8());\n         llglobal = llvm::LLVMConstBitCast(llglobal, t_ptr_i8);\n-        let llvm_used = str::as_c_str(~\"llvm.used\", |buf| {\n+        let llvm_used = str::as_c_str(\"llvm.used\", |buf| {\n             llvm::LLVMAddGlobal(cx.llmod, T_array(t_ptr_i8, 1u), buf)\n         });\n         lib::llvm::SetLinkage(llvm_used, lib::llvm::AppendingLinkage);\n-        llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, ~[llglobal]));\n+        llvm::LLVMSetInitializer(llvm_used, C_array(t_ptr_i8, [llglobal]));\n     }\n }\n \n@@ -3122,7 +3120,7 @@ pub fn trans_crate(sess: session::Session,\n         // Translate the metadata.\n         write_metadata(ccx, crate);\n         if ccx.sess.trans_stats() {\n-            io::println(~\"--- trans stats ---\");\n+            io::println(\"--- trans stats ---\");\n             io::println(fmt!(\"n_static_tydescs: %u\",\n                              ccx.stats.n_static_tydescs));\n             io::println(fmt!(\"n_glues_created: %u\","}, {"sha": "965516d8983cbdf40711daa138c8fd3b7463c1af", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -190,7 +190,7 @@ pub fn Invoke(cx: block,\n            val_str(cx.ccx().tn, Fn),\n            str::connect(vec::map(Args, |a| val_str(cx.ccx().tn,\n                                                    *a).to_owned()),\n-                        ~\", \"));\n+                        \", \"));\n     unsafe {\n         count_insn(cx, \"invoke\");\n         llvm::LLVMBuildInvoke(B(cx),\n@@ -864,7 +864,7 @@ pub fn _UndefReturn(cx: block, Fn: ValueRef) -> ValueRef {\n         let ty = val_ty(Fn);\n         let retty = if llvm::LLVMGetTypeKind(ty) == lib::llvm::Integer {\n             llvm::LLVMGetReturnType(ty) } else { ccx.int_type };\n-            count_insn(cx, ~\"\");\n+            count_insn(cx, \"\");\n         return llvm::LLVMGetUndef(retty);\n     }\n }\n@@ -882,17 +882,17 @@ pub fn add_comment(bcx: block, text: &str) {\n     unsafe {\n         let ccx = bcx.ccx();\n         if ccx.sess.asm_comments() {\n-            let sanitized = str::replace(text, ~\"$\", ~\"\");\n+            let sanitized = str::replace(text, \"$\", \"\");\n             let comment_text = ~\"# \" +\n-                str::replace(sanitized, ~\"\\n\", ~\"\\n\\t# \");\n+                str::replace(sanitized, \"\\n\", \"\\n\\t# \");\n             let asm = str::as_c_str(comment_text, |c| {\n-                str::as_c_str(~\"\", |e| {\n-                    count_insn(bcx, ~\"inlineasm\");\n-                    llvm::LLVMConstInlineAsm(T_fn(~[], T_void()), c, e,\n+                str::as_c_str(\"\", |e| {\n+                    count_insn(bcx, \"inlineasm\");\n+                    llvm::LLVMConstInlineAsm(T_fn([], T_void()), c, e,\n                                              False, False)\n                 })\n             });\n-            Call(bcx, asm, ~[]);\n+            Call(bcx, asm, []);\n         }\n     }\n }\n@@ -1064,7 +1064,7 @@ pub fn Trap(cx: block) {\n         let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n         let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n         let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n-        let T: ValueRef = str::as_c_str(~\"llvm.trap\", |buf| {\n+        let T: ValueRef = str::as_c_str(\"llvm.trap\", |buf| {\n             llvm::LLVMGetNamedFunction(M, buf)\n         });\n         assert!((T as int != 0));"}, {"sha": "c6f4d230419733c24b05faef01a5d9dbffb22ba2", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -177,7 +177,7 @@ pub impl FnType {\n             }\n         }\n \n-        let llretval = load_inbounds(bcx, llargbundle, ~[ 0, arg_tys.len() ]);\n+        let llretval = load_inbounds(bcx, llargbundle, [ 0, arg_tys.len() ]);\n         let llretval = if self.ret_ty.cast {\n             let retptr = BitCast(bcx, llretval, T_ptr(self.ret_ty.ty));\n             Load(bcx, retptr)"}, {"sha": "6fbefb1d8aedae3e70e34f3f09a9d10d61dff051", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -379,7 +379,7 @@ pub fn trans_lang_call(bcx: block,\n                                 trans_fn_ref_with_vtables_to_callee(bcx,\n                                                                     did,\n                                                                     0,\n-                                                                    ~[],\n+                                                                    [],\n                                                                     None)\n                              },\n                              ArgVals(args),\n@@ -717,8 +717,7 @@ pub fn trans_arg_expr(bcx: block,\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n-                        arg_expr.span, ~\"ret_flag with non-loop-\\\n-                                         body expr\");\n+                        arg_expr.span, \"ret_flag with non-loop-body expr\");\n                 }\n             }\n         }"}, {"sha": "3a14d72e9bfdb4e9b5173ad5a4d004647e872974", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -317,7 +317,7 @@ pub fn load_environment(fcx: fn_ctxt,\n         Some(ll) => ll,\n         None => {\n             let ll =\n-                str::as_c_str(~\"load_env\",\n+                str::as_c_str(\"load_env\",\n                               |buf|\n                               unsafe {\n                                 llvm::LLVMAppendBasicBlock(fcx.llfn, buf)\n@@ -516,7 +516,7 @@ pub fn make_opaque_cbox_take_glue(\n         let bcx = callee::trans_lang_call(\n             bcx,\n             bcx.tcx().lang_items.exchange_malloc_fn(),\n-            ~[opaque_tydesc, sz],\n+            [opaque_tydesc, sz],\n             expr::SaveIn(rval));\n         let cbox_out = PointerCast(bcx, Load(bcx, rval), llopaquecboxty);\n         call_memcpy(bcx, cbox_out, cbox_in, sz);\n@@ -589,7 +589,7 @@ pub fn make_opaque_cbox_free_glue(\n             ast::ManagedSigil => glue::trans_free(bcx, cbox),\n             ast::OwnedSigil => glue::trans_exchange_free(bcx, cbox),\n             ast::BorrowedSigil => {\n-                bcx.sess().bug(~\"impossible\")\n+                bcx.sess().bug(\"impossible\")\n             }\n         }\n     }"}, {"sha": "115cf52056f402187a1a3e209f4ba683969cda83", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -781,7 +781,7 @@ pub fn T_void() -> TypeRef {\n }\n \n pub fn T_nil() -> TypeRef {\n-    return T_struct(~[], false)\n+    return T_struct([], false)\n }\n \n pub fn T_metadata() -> TypeRef { unsafe { return llvm::LLVMMetadataType(); } }\n@@ -864,7 +864,7 @@ pub fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n }\n \n pub fn T_fn_pair(cx: @CrateContext, tfn: TypeRef) -> TypeRef {\n-    return T_struct(~[T_ptr(tfn), T_opaque_cbox_ptr(cx)], false);\n+    return T_struct([T_ptr(tfn), T_opaque_cbox_ptr(cx)], false);\n }\n \n pub fn T_ptr(t: TypeRef) -> TypeRef {\n@@ -903,7 +903,7 @@ pub fn set_struct_body(t: TypeRef, elts: &[TypeRef], packed: bool) {\n     }\n }\n \n-pub fn T_empty_struct() -> TypeRef { return T_struct(~[], false); }\n+pub fn T_empty_struct() -> TypeRef { return T_struct([], false); }\n \n // A vtable is, in reality, a vtable pointer followed by zero or more pointers\n // to tydescs and other vtables that it closes over. But the types and number\n@@ -912,7 +912,7 @@ pub fn T_empty_struct() -> TypeRef { return T_struct(~[], false); }\n pub fn T_vtable() -> TypeRef { T_array(T_ptr(T_i8()), 1u) }\n \n pub fn T_task(targ_cfg: @session::config) -> TypeRef {\n-    let t = T_named_struct(~\"task\");\n+    let t = T_named_struct(\"task\");\n \n     // Refcount\n     // Delegate pointer\n@@ -960,11 +960,11 @@ pub fn T_generic_glue_fn(cx: @CrateContext) -> TypeRef {\n }\n \n pub fn T_tydesc(targ_cfg: @session::config) -> TypeRef {\n-    let tydesc = T_named_struct(~\"tydesc\");\n+    let tydesc = T_named_struct(\"tydesc\");\n     let tydescpp = T_ptr(T_ptr(tydesc));\n     let pvoid = T_ptr(T_i8());\n     let glue_fn_ty =\n-        T_ptr(T_fn(~[T_ptr(T_nil()), T_ptr(T_nil()), tydescpp,\n+        T_ptr(T_fn([T_ptr(T_nil()), T_ptr(T_nil()), tydescpp,\n                     pvoid], T_void()));\n \n     let int_type = T_int(targ_cfg);\n@@ -990,9 +990,9 @@ pub fn T_vector(t: TypeRef, n: uint) -> TypeRef {\n \n // Interior vector.\n pub fn T_vec2(targ_cfg: @session::config, t: TypeRef) -> TypeRef {\n-    return T_struct(~[T_int(targ_cfg), // fill\n-                      T_int(targ_cfg), // alloc\n-                      T_array(t, 0u)], // elements\n+    return T_struct([T_int(targ_cfg), // fill\n+                     T_int(targ_cfg), // alloc\n+                     T_array(t, 0u)], // elements\n                     false);\n }\n \n@@ -1028,7 +1028,7 @@ pub fn T_box_header(cx: @CrateContext) -> TypeRef {\n }\n \n pub fn T_box(cx: @CrateContext, t: TypeRef) -> TypeRef {\n-    return T_struct(vec::append(T_box_header_fields(cx), ~[t]), false);\n+    return T_struct(vec::append(T_box_header_fields(cx), [t]), false);\n }\n \n pub fn T_box_ptr(t: TypeRef) -> TypeRef {\n@@ -1046,7 +1046,7 @@ pub fn T_opaque_box_ptr(cx: @CrateContext) -> TypeRef {\n }\n \n pub fn T_unique(cx: @CrateContext, t: TypeRef) -> TypeRef {\n-    return T_struct(vec::append(T_box_header_fields(cx), ~[t]), false);\n+    return T_struct(vec::append(T_box_header_fields(cx), [t]), false);\n }\n \n pub fn T_unique_ptr(t: TypeRef) -> TypeRef {\n@@ -1056,12 +1056,12 @@ pub fn T_unique_ptr(t: TypeRef) -> TypeRef {\n }\n \n pub fn T_port(cx: @CrateContext, _t: TypeRef) -> TypeRef {\n-    return T_struct(~[cx.int_type], false); // Refcount\n+    return T_struct([cx.int_type], false); // Refcount\n \n }\n \n pub fn T_chan(cx: @CrateContext, _t: TypeRef) -> TypeRef {\n-    return T_struct(~[cx.int_type], false); // Refcount\n+    return T_struct([cx.int_type], false); // Refcount\n \n }\n \n@@ -1085,16 +1085,16 @@ pub fn T_captured_tydescs(cx: @CrateContext, n: uint) -> TypeRef {\n pub fn T_opaque_trait(cx: @CrateContext, store: ty::TraitStore) -> TypeRef {\n     match store {\n         ty::BoxTraitStore => {\n-            T_struct(~[T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)], false)\n+            T_struct([T_ptr(cx.tydesc_type), T_opaque_box_ptr(cx)], false)\n         }\n         ty::UniqTraitStore => {\n-            T_struct(~[T_ptr(cx.tydesc_type),\n-                       T_unique_ptr(T_unique(cx, T_i8())),\n-                       T_ptr(cx.tydesc_type)],\n+            T_struct([T_ptr(cx.tydesc_type),\n+                      T_unique_ptr(T_unique(cx, T_i8())),\n+                      T_ptr(cx.tydesc_type)],\n                      false)\n         }\n         ty::RegionTraitStore(_) => {\n-            T_struct(~[T_ptr(cx.tydesc_type), T_ptr(T_i8())], false)\n+            T_struct([T_ptr(cx.tydesc_type), T_ptr(T_i8())], false)\n         }\n     }\n }\n@@ -1130,7 +1130,7 @@ pub fn C_floating(s: &str, t: TypeRef) -> ValueRef {\n }\n \n pub fn C_nil() -> ValueRef {\n-    return C_struct(~[]);\n+    return C_struct([]);\n }\n \n pub fn C_bool(b: bool) -> ValueRef {\n@@ -1193,7 +1193,7 @@ pub fn C_estr_slice(cx: @CrateContext, s: @~str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n-        C_struct(~[cs, C_uint(cx, len + 1u /* +1 for null */)])\n+        C_struct([cs, C_uint(cx, len + 1u /* +1 for null */)])\n     }\n }\n "}, {"sha": "ac85a9f5eaca94e96ac203066741aca979f0962e", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -165,7 +165,7 @@ pub fn get_const_val(cx: @CrateContext, def_id: ast::def_id) -> ValueRef {\n             }, _) => {\n                 trans_const(cx, subexpr, def_id.node);\n             }\n-            _ => cx.tcx.sess.bug(~\"expected a const to be an item\")\n+            _ => cx.tcx.sess.bug(\"expected a const to be an item\")\n         }\n     }\n     cx.const_values.get_copy(&def_id.node)\n@@ -177,7 +177,7 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n     match cx.tcx.adjustments.find(&e.id) {\n         None => { }\n         Some(&@ty::AutoAddEnv(ty::re_static, ast::BorrowedSigil)) => {\n-            llconst = C_struct(~[llconst, C_null(T_opaque_box_ptr(cx))])\n+            llconst = C_struct([llconst, C_null(T_opaque_box_ptr(cx))])\n         }\n         Some(&@ty::AutoAddEnv(ref r, ref s)) => {\n             cx.sess.span_bug(e.span, fmt!(\"unexpected static function: \\\n@@ -213,7 +213,7 @@ pub fn const_expr(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                                                           val_ty(llconst));\n                             assert_eq!(abi::slice_elt_base, 0);\n                             assert_eq!(abi::slice_elt_len, 1);\n-                            llconst = C_struct(~[llptr, size]);\n+                            llconst = C_struct([llptr, size]);\n                         }\n                         _ => {\n                             cx.sess.span_bug(e.span,\n@@ -450,8 +450,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                         llvm::LLVMConstIntCast(iv, llty, s)\n                     }\n                     expr::cast_float => llvm::LLVMConstUIToFP(iv, llty),\n-                    _ => cx.sess.bug(~\"enum cast destination is not \\\n-                                       integral or float\")\n+                    _ => cx.sess.bug(\"enum cast destination is not \\\n+                                      integral or float\")\n                 }\n               }\n               (expr::cast_pointer, expr::cast_pointer) => {\n@@ -462,7 +462,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               }\n               _ => {\n                 cx.sess.impossible_case(e.span,\n-                                        ~\"bad combination of types for cast\")\n+                                        \"bad combination of types for cast\")\n               }\n             }\n           }\n@@ -512,7 +512,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 llvm::LLVMSetGlobalConstant(gv, True);\n                 SetLinkage(gv, PrivateLinkage);\n                 let p = const_ptrcast(cx, gv, llunitty);\n-                C_struct(~[p, sz])\n+                C_struct([p, sz])\n               }\n               _ => cx.sess.span_bug(e.span, \"bad const-slice expr\")\n             }"}, {"sha": "a1b673be667854784868b1be763e44d38066597b", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -93,14 +93,14 @@ pub fn trans_if(bcx: block,\n             trans_block(else_bcx_in, blk, dest)\n           }\n           // would be nice to have a constraint on ifs\n-          _ => bcx.tcx().sess.bug(~\"strange alternative in if\")\n+          _ => bcx.tcx().sess.bug(\"strange alternative in if\")\n         }\n       }\n       _ => else_bcx_in\n     };\n     let else_bcx_out = trans_block_cleanups(else_bcx_out,\n                                             block_cleanups(else_bcx_in));\n-    return join_blocks(bcx, ~[then_bcx_out, else_bcx_out]);\n+    return join_blocks(bcx, [then_bcx_out, else_bcx_out]);\n \n }\n \n@@ -228,7 +228,7 @@ pub fn trans_log(log_ex: @ast::expr,\n             let val = val_datum.to_ref_llval(bcx);\n             let did = bcx.tcx().lang_items.log_type_fn();\n             let bcx = callee::trans_lang_call_with_type_params(\n-                bcx, did, ~[level, val], ~[val_datum.ty], expr::Ignore);\n+                bcx, did, [level, val], [val_datum.ty], expr::Ignore);\n             bcx\n         }\n     }"}, {"sha": "0582853d9e1a7a1e6a8cacfc6adc9e23df5cec12", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -217,7 +217,7 @@ fn create_compile_unit(cx: @CrateContext) -> @Metadata<CompileUnitMetadata> {\n                          llstr(env!(\"CFG_VERSION\")),\n                          lli1(true), // deprecated: main compile unit\n                          lli1(cx.sess.opts.optimize != session::No),\n-                         llstr(~\"\"), // flags (???)\n+                         llstr(\"\"), // flags (???)\n                          lli32(0) // runtime version (???)\n                         ];\n     let unit_node = llmdnode(unit_metadata);\n@@ -368,7 +368,7 @@ fn create_basic_type(cx: @CrateContext, t: ty::t, span: span)\n             ast::ty_f32 => (~\"f32\", DW_ATE_float),\n             ast::ty_f64 => (~\"f64\", DW_ATE_float)\n         },\n-        _ => cx.sess.bug(~\"debuginfo::create_basic_type - t is invalid type\")\n+        _ => cx.sess.bug(\"debuginfo::create_basic_type - t is invalid type\")\n     };\n \n     let fname = filename_from_span(cx, span);\n@@ -522,7 +522,7 @@ fn create_tuple(cx: @CrateContext, t: ty::t, elements: &[ty::t], span: span)\n     for elements.each |element| {\n         let ty_md = create_ty(cx, *element, span);\n         let (size, align) = size_and_align_of(cx, *element);\n-        add_member(scx, ~\"\", line_from_span(cx.sess.codemap, span) as int,\n+        add_member(scx, \"\", line_from_span(cx.sess.codemap, span) as int,\n                    size as int, align as int, ty_md.node);\n     }\n     let mdval = @Metadata {\n@@ -539,7 +539,7 @@ fn voidptr() -> (ValueRef, int, int) {\n     let null = ptr::null();\n     let size = sys::size_of::<ValueRef>() as int;\n     let align = sys::min_align_of::<ValueRef>() as int;\n-    let vp = create_derived_type(PointerTypeTag, null, ~\"\", 0,\n+    let vp = create_derived_type(PointerTypeTag, null, \"\", 0,\n                                  size, align, 0, null);\n     return (vp, size, align);\n }\n@@ -561,16 +561,16 @@ fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n     let refcount_type = create_basic_type(cx, int_t, span);\n     let name = ty_to_str(cx.tcx, contents);\n     let scx = create_structure(file_node, @fmt!(\"box<%s>\", name), 0);\n-    add_member(scx, ~\"refcnt\", 0, sys::size_of::<uint>() as int,\n+    add_member(scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n                sys::min_align_of::<uint>() as int, refcount_type.node);\n     // the tydesc and other pointers should be irrelevant to the\n     // debugger, so treat them as void* types\n     let (vp, vpsize, vpalign) = voidptr();\n-    add_member(scx, ~\"tydesc\", 0, vpsize, vpalign, vp);\n-    add_member(scx, ~\"prev\", 0, vpsize, vpalign, vp);\n-    add_member(scx, ~\"next\", 0, vpsize, vpalign, vp);\n+    add_member(scx, \"tydesc\", 0, vpsize, vpalign, vp);\n+    add_member(scx, \"prev\", 0, vpsize, vpalign, vp);\n+    add_member(scx, \"next\", 0, vpsize, vpalign, vp);\n     let (size, align) = size_and_align_of(cx, contents);\n-    add_member(scx, ~\"boxed\", 0, size, align, boxed.node);\n+    add_member(scx, \"boxed\", 0, size, align, boxed.node);\n     let llnode = finish_structure(scx);\n     let mdval = @Metadata {\n         node: llnode,\n@@ -619,7 +619,7 @@ fn create_fixed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     let (size, align) = size_and_align_of(cx, elem_t);\n-    let subrange = llmdnode(~[lltag(SubrangeTag), lli64(0), lli64(len - 1)]);\n+    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(len - 1)]);\n     let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n     let array = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n                                       size * len, align, 0, Some(t_md.node),\n@@ -641,18 +641,18 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     let vec_scx = create_structure(file_node,\n                                @/*bad*/ copy ty_to_str(cx.tcx, vec_t), 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n-    add_member(vec_scx, ~\"fill\", 0, sys::size_of::<libc::size_t>() as int,\n+    add_member(vec_scx, \"fill\", 0, sys::size_of::<libc::size_t>() as int,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    add_member(vec_scx, ~\"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n+    add_member(vec_scx, \"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    let subrange = llmdnode(~[lltag(SubrangeTag), lli64(0), lli64(0)]);\n+    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(0)]);\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n     let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n     let data_ptr = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n                                          arr_size, arr_align, 0,\n                                          Some(elem_ty_md.node),\n                                          Some(~[subrange]));\n-    add_member(vec_scx, ~\"data\", 0, 0, // clang says the size should be 0\n+    add_member(vec_scx, \"data\", 0, 0, // clang says the size should be 0\n                sys::min_align_of::<u8>() as int, data_ptr);\n     let llnode = finish_structure(vec_scx);\n     let vec_md = @Metadata {\n@@ -665,15 +665,15 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n     let box_scx = create_structure(file_node, @fmt!(\"box<%s>\", name), 0);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n-    add_member(box_scx, ~\"refcnt\", 0, sys::size_of::<uint>() as int,\n+    add_member(box_scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n                sys::min_align_of::<uint>() as int, refcount_type.node);\n     let (vp, vpsize, vpalign) = voidptr();\n-    add_member(box_scx, ~\"tydesc\", 0, vpsize, vpalign, vp);\n-    add_member(box_scx, ~\"prev\", 0, vpsize, vpalign, vp);\n-    add_member(box_scx, ~\"next\", 0, vpsize, vpalign, vp);\n+    add_member(box_scx, \"tydesc\", 0, vpsize, vpalign, vp);\n+    add_member(box_scx, \"prev\", 0, vpsize, vpalign, vp);\n+    add_member(box_scx, \"next\", 0, vpsize, vpalign, vp);\n     let size = 2 * sys::size_of::<int>() as int;\n     let align = sys::min_align_of::<int>() as int;\n-    add_member(box_scx, ~\"boxed\", 0, size, align, vec_md.node);\n+    add_member(box_scx, \"boxed\", 0, size, align, vec_md.node);\n     let llnode = finish_structure(box_scx);\n     let mdval = @Metadata {\n         node: llnode,\n@@ -693,8 +693,8 @@ fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n     let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n     let scx = create_structure(file_node, @ty_to_str(cx.tcx, vec_t), 0);\n     let (_, ptr_size, ptr_align) = voidptr();\n-    add_member(scx, ~\"vec\", 0, ptr_size, ptr_align, elem_ptr.node);\n-    add_member(scx, ~\"length\", 0, sys::size_of::<uint>() as int,\n+    add_member(scx, \"vec\", 0, ptr_size, ptr_align, elem_ptr.node);\n+    add_member(scx, \"length\", 0, sys::size_of::<uint>() as int,\n                sys::min_align_of::<uint>() as int, uint_type.node);\n     let llnode = finish_structure(scx);\n     let mdval = @Metadata {\n@@ -715,7 +715,7 @@ fn create_fn_ty(cx: @CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t\n     let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n     let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span).node };\n     let members = ~[output_ptr_md.node, vp] + inputs_vals;\n-    let llnode = create_composite_type(SubroutineTag, ~\"\", file_node.node,\n+    let llnode = create_composite_type(SubroutineTag, \"\", file_node.node,\n                                        0, 0, 0, 0, None, Some(members));\n     let mdval = @Metadata {\n         node: llnode,\n@@ -802,7 +802,7 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n         ty::ty_tup(ref elements) => {\n             create_tuple(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(~\"debuginfo: unexpected type in create_ty\")\n+        _ => cx.sess.bug(\"debuginfo: unexpected type in create_ty\")\n     }\n }\n \n@@ -869,7 +869,7 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         }\n       }\n     };\n-    let declargs = ~[llmdnode(~[llptr]), mdnode];\n+    let declargs = ~[llmdnode([llptr]), mdnode];\n     trans::build::Call(bcx, *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n                        declargs);\n     return mdval;\n@@ -918,7 +918,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n             let llptr = match fcx.llargs.get_copy(&arg.id) {\n               local_mem(v) | local_imm(v) => v,\n             };\n-            let declargs = ~[llmdnode(~[llptr]), mdnode];\n+            let declargs = ~[llmdnode([llptr]), mdnode];\n             trans::build::Call(bcx,\n                                *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n                                declargs);\n@@ -1003,7 +1003,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n     } else {\n         llnull()\n     };\n-    let sub_node = create_composite_type(SubroutineTag, ~\"\", file_node, 0, 0,\n+    let sub_node = create_composite_type(SubroutineTag, \"\", file_node, 0, 0,\n                                          0, 0, option::None,\n                                          option::Some(~[ty_node]));\n \n@@ -1013,7 +1013,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n                        llstr(*cx.sess.str_of(ident)),\n                         //XXX fully-qualified C++ name:\n                        llstr(*cx.sess.str_of(ident)),\n-                       llstr(~\"\"), //XXX MIPS name?????\n+                       llstr(\"\"), //XXX MIPS name?????\n                        file_node,\n                        lli32(loc.line as int),\n                        sub_node,"}, {"sha": "f457cc80da8983a450f3141634c48ec2272c1fd4", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -885,9 +885,9 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         };\n \n         let vt = tvec::vec_types(bcx, base_datum.ty);\n-        base::maybe_name_value(bcx.ccx(), vt.llunit_size, ~\"unit_sz\");\n+        base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n         let scaled_ix = Mul(bcx, ix_val, vt.llunit_size);\n-        base::maybe_name_value(bcx.ccx(), scaled_ix, ~\"scaled_ix\");\n+        base::maybe_name_value(bcx.ccx(), scaled_ix, \"scaled_ix\");\n \n         let mut (bcx, base, len) =\n             base_datum.get_vec_base_and_len(bcx, index_expr.span,\n@@ -907,7 +907,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n             controlflow::trans_fail_bounds_check(bcx, index_expr.span,\n                                                  ix_val, unscaled_len)\n         };\n-        let elt = InBoundsGEP(bcx, base, ~[ix_val]);\n+        let elt = InBoundsGEP(bcx, base, [ix_val]);\n         let elt = PointerCast(bcx, elt, T_ptr(vt.llunit_ty));\n         return DatumBlock {\n             bcx: bcx,\n@@ -1110,8 +1110,8 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                                struct_fields(tcx, variant_id, substs))\n                         }\n                         _ => {\n-                            tcx.sess.bug(~\"resolve didn't map this expr to a \\\n-                                           variant ID\")\n+                            tcx.sess.bug(\"resolve didn't map this expr to a \\\n+                                          variant ID\")\n                         }\n                     }\n                 }\n@@ -1168,7 +1168,7 @@ fn trans_rec_or_struct(bcx: block,\n             }\n             None => {\n                 if need_base.any(|b| *b) {\n-                    tcx.sess.span_bug(expr_span, ~\"missing fields and no base expr\")\n+                    tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n                 }\n                 None\n             }\n@@ -1313,9 +1313,9 @@ fn trans_unary_datum(bcx: block,\n             trans_boxed_expr(bcx, un_ty, sub_expr, sub_ty, heap)\n         }\n         ast::deref => {\n-            bcx.sess().bug(~\"deref expressions should have been \\\n-                             translated using trans_lvalue(), not \\\n-                             trans_unary_datum()\")\n+            bcx.sess().bug(\"deref expressions should have been \\\n+                            translated using trans_lvalue(), not \\\n+                            trans_unary_datum()\")\n         }\n     };\n \n@@ -1482,8 +1482,8 @@ fn trans_lazy_binop(bcx: block,\n     }\n \n     Br(past_rhs, join.llbb);\n-    let phi = Phi(join, T_bool(), ~[lhs, rhs], ~[past_lhs.llbb,\n-                                                 past_rhs.llbb]);\n+    let phi = Phi(join, T_bool(), [lhs, rhs], [past_lhs.llbb,\n+                                               past_rhs.llbb]);\n \n     return immediate_rvalue_bcx(join, phi, binop_ty);\n }\n@@ -1644,10 +1644,10 @@ fn trans_imm_cast(bcx: block, expr: @ast::expr,\n                                               val_ty(lldiscrim_a),\n                                               lldiscrim_a, true),\n                     cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n-                    _ => ccx.sess.bug(~\"translating unsupported cast.\")\n+                    _ => ccx.sess.bug(\"translating unsupported cast.\")\n                 }\n             }\n-            _ => ccx.sess.bug(~\"translating unsupported cast.\")\n+            _ => ccx.sess.bug(\"translating unsupported cast.\")\n         };\n     return immediate_rvalue_bcx(bcx, newval, t_out);\n }"}, {"sha": "0ed0eb31c0b2777fc53d967f3a275a9c59f603f9", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -51,7 +51,7 @@ fn abi_info(ccx: @CrateContext) -> @cabi::ABIInfo {\n }\n \n pub fn link_name(ccx: @CrateContext, i: @ast::foreign_item) -> @~str {\n-     match attr::first_attr_value_str_by_name(i.attrs, ~\"link_name\") {\n+     match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n         Some(ln) => ln,\n     }\n@@ -106,7 +106,7 @@ fn foreign_signature(ccx: @CrateContext, fn_sig: &ty::FnSig)\n fn shim_types(ccx: @CrateContext, id: ast::node_id) -> ShimTypes {\n     let fn_sig = match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n         ty::ty_bare_fn(ref fn_ty) => copy fn_ty.sig,\n-        _ => ccx.sess.bug(~\"c_arg_and_ret_lltys called on non-function type\")\n+        _ => ccx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\")\n     };\n     let llsig = foreign_signature(ccx, &fn_sig);\n     let bundle_ty = T_struct(vec::append_one(copy llsig.llarg_tys,\n@@ -122,7 +122,7 @@ fn shim_types(ccx: @CrateContext, id: ast::node_id) -> ShimTypes {\n         llsig: llsig,\n         ret_def: ret_def,\n         bundle_ty: bundle_ty,\n-        shim_fn_ty: T_fn(~[T_ptr(bundle_ty)], T_nil()),\n+        shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_nil()),\n         fn_ty: fn_ty\n     }\n }\n@@ -207,7 +207,7 @@ fn build_wrap_fn_(ccx: @CrateContext,\n     // Create call itself.\n     let llshimfnptr = PointerCast(bcx, llshimfn, T_ptr(T_i8()));\n     let llrawargbundle = PointerCast(bcx, llargbundle, T_ptr(T_i8()));\n-    Call(bcx, shim_upcall, ~[llrawargbundle, llshimfnptr]);\n+    Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]);\n     ret_builder(bcx, tys, llargbundle);\n \n     // Perform a custom version of `finish_fn`. First, tie up the header\n@@ -521,18 +521,18 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                     llargval = Load(bcx, llargval);\n                 }\n \n-                store_inbounds(bcx, llargval, llargbundle, ~[0u, i]);\n+                store_inbounds(bcx, llargval, llargbundle, [0u, i]);\n             }\n             let llretptr = bcx.fcx.llretptr.get();\n-            store_inbounds(bcx, llretptr, llargbundle, ~[0u, n]);\n+            store_inbounds(bcx, llretptr, llargbundle, [0u, n]);\n         }\n \n         fn build_ret(bcx: block,\n                      shim_types: &ShimTypes,\n                      llargbundle: ValueRef) {\n             let _icx = bcx.insn_ctxt(\"foreign::wrap::build_ret\");\n             let arg_count = shim_types.fn_sig.inputs.len();\n-            let llretptr = load_inbounds(bcx, llargbundle, ~[0, arg_count]);\n+            let llretptr = load_inbounds(bcx, llargbundle, [0, arg_count]);\n             Store(bcx, Load(bcx, llretptr), bcx.fcx.llretptr.get());\n             build_return(bcx);\n         }\n@@ -808,7 +808,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         }\n         ~\"frame_address\" => {\n             let frameaddress = *ccx.intrinsics.get(&~\"llvm.frameaddress\");\n-            let frameaddress_val = Call(bcx, frameaddress, ~[C_i32(0i32)]);\n+            let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]);\n             let star_u8 = ty::mk_imm_ptr(\n                 bcx.tcx(),\n                 ty::mk_mach_uint(ast::ty_u8));\n@@ -836,9 +836,9 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             // XXX This is a hack to grab the address of this particular\n             // native function. There should be a general in-language\n             // way to do this\n-            let llfty = type_of_fn(bcx.ccx(), ~[], ty::mk_nil());\n+            let llfty = type_of_fn(bcx.ccx(), [], ty::mk_nil());\n             let morestack_addr = decl_cdecl_fn(\n-                bcx.ccx().llmod, ~\"__morestack\", llfty);\n+                bcx.ccx().llmod, \"__morestack\", llfty);\n             let morestack_addr = PointerCast(bcx, morestack_addr,\n                                              T_ptr(T_nil()));\n             Store(bcx, morestack_addr, fcx.llretptr.get());\n@@ -851,7 +851,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let volatile = C_i1(false);\n             let llfn = *bcx.ccx().intrinsics.get(\n                 &~\"llvm.memmove.p0i8.p0i8.i32\");\n-            Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n+            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n         }\n         ~\"memmove64\" => {\n             let dst_ptr = get_param(decl, first_real_arg);\n@@ -861,248 +861,248 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let volatile = C_i1(false);\n             let llfn = *bcx.ccx().intrinsics.get(\n                 &~\"llvm.memmove.p0i8.p0i8.i64\");\n-            Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n+            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n         }\n         ~\"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f32\");\n-            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n         }\n         ~\"sqrtf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f64\");\n-            Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n         }\n         ~\"powif32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powif = *ccx.intrinsics.get(&~\"llvm.powi.f32\");\n-            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n         }\n         ~\"powif64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powif = *ccx.intrinsics.get(&~\"llvm.powi.f64\");\n-            Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n         }\n         ~\"sinf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f32\");\n-            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n         }\n         ~\"sinf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f64\");\n-            Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n         }\n         ~\"cosf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f32\");\n-            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n         }\n         ~\"cosf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f64\");\n-            Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n         }\n         ~\"powf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powf = *ccx.intrinsics.get(&~\"llvm.pow.f32\");\n-            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n         }\n         ~\"powf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n             let powf = *ccx.intrinsics.get(&~\"llvm.pow.f64\");\n-            Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n         }\n         ~\"expf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let expf = *ccx.intrinsics.get(&~\"llvm.exp.f32\");\n-            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n         }\n         ~\"expf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let expf = *ccx.intrinsics.get(&~\"llvm.exp.f64\");\n-            Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n         }\n         ~\"exp2f32\" => {\n             let x = get_param(decl, first_real_arg);\n             let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f32\");\n-            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n         }\n         ~\"exp2f64\" => {\n             let x = get_param(decl, first_real_arg);\n             let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f64\");\n-            Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n         }\n         ~\"logf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let logf = *ccx.intrinsics.get(&~\"llvm.log.f32\");\n-            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n         }\n         ~\"logf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let logf = *ccx.intrinsics.get(&~\"llvm.log.f64\");\n-            Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n         }\n         ~\"log10f32\" => {\n             let x = get_param(decl, first_real_arg);\n             let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f32\");\n-            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n         }\n         ~\"log10f64\" => {\n             let x = get_param(decl, first_real_arg);\n             let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f64\");\n-            Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n         }\n         ~\"log2f32\" => {\n             let x = get_param(decl, first_real_arg);\n             let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f32\");\n-            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n         }\n         ~\"log2f64\" => {\n             let x = get_param(decl, first_real_arg);\n             let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f64\");\n-            Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n         }\n         ~\"fmaf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n             let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f32\");\n-            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n         }\n         ~\"fmaf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n             let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f64\");\n-            Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n         }\n         ~\"fabsf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f32\");\n-            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n         }\n         ~\"fabsf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f64\");\n-            Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n         }\n         ~\"floorf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f32\");\n-            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n         }\n         ~\"floorf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f64\");\n-            Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n         }\n         ~\"ceilf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f32\");\n-            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n         }\n         ~\"ceilf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f64\");\n-            Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n         }\n         ~\"truncf32\" => {\n             let x = get_param(decl, first_real_arg);\n             let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f32\");\n-            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n         }\n         ~\"truncf64\" => {\n             let x = get_param(decl, first_real_arg);\n             let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f64\");\n-            Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr.get());\n+            Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n         }\n         ~\"ctpop8\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i8\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n         ~\"ctpop16\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i16\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n         ~\"ctpop32\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i32\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n         ~\"ctpop64\" => {\n             let x = get_param(decl, first_real_arg);\n             let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i64\");\n-            Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n         ~\"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n         ~\"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n         ~\"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n         ~\"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n-            Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n         ~\"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n-            Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n         ~\"bswap16\" => {\n             let x = get_param(decl, first_real_arg);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i16\");\n-            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n         }\n         ~\"bswap32\" => {\n             let x = get_param(decl, first_real_arg);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i32\");\n-            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n         }\n         ~\"bswap64\" => {\n             let x = get_param(decl, first_real_arg);\n             let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i64\");\n-            Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr.get())\n+            Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n         }\n         _ => {\n             // Could we make this an enum rather than a string? does it get\n@@ -1207,7 +1207,7 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n             let n = tys.fn_sig.inputs.len();\n \n             if !ty::type_is_immediate(tys.fn_sig.output) {\n-                let llretptr = load_inbounds(bcx, llargbundle, ~[0u, n]);\n+                let llretptr = load_inbounds(bcx, llargbundle, [0u, n]);\n                 llargvals.push(llretptr);\n             } else {\n                 llargvals.push(C_null(T_ptr(T_i8())));\n@@ -1239,7 +1239,7 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n                 let arg_count = shim_types.fn_sig.inputs.len();\n                 let llretptr = load_inbounds(bcx,\n                                              llargbundle,\n-                                             ~[0, arg_count]);\n+                                             [0, arg_count]);\n                 Store(bcx, llretval, llretptr);\n             } else {\n                 // NB: The return pointer in the Rust ABI function is wired"}, {"sha": "048acdc07a1201703a4257f1675329c9b7fe3dbf", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -42,7 +42,7 @@ pub fn trans_free(cx: block, v: ValueRef) -> block {\n     callee::trans_lang_call(\n         cx,\n         cx.tcx().lang_items.free_fn(),\n-        ~[PointerCast(cx, v, T_ptr(T_i8()))],\n+        [PointerCast(cx, v, T_ptr(T_i8()))],\n         expr::Ignore)\n }\n \n@@ -51,7 +51,7 @@ pub fn trans_exchange_free(cx: block, v: ValueRef) -> block {\n     callee::trans_lang_call(\n         cx,\n         cx.tcx().lang_items.exchange_free_fn(),\n-        ~[PointerCast(cx, v, T_ptr(T_i8()))],\n+        [PointerCast(cx, v, T_ptr(T_i8()))],\n         expr::Ignore)\n }\n \n@@ -100,7 +100,7 @@ pub fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n       ty::ty_estr(ty::vstore_box) => {\n         decr_refcnt_maybe_free(bcx, v, t)\n       }\n-      _ => bcx.tcx().sess.bug(~\"drop_ty_immediate: non-box ty\")\n+      _ => bcx.tcx().sess.bug(\"drop_ty_immediate: non-box ty\")\n     }\n }\n \n@@ -147,7 +147,7 @@ pub fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n         Store(bcx, v, vp);\n         free_ty(bcx, vp, t)\n       }\n-      _ => bcx.tcx().sess.bug(~\"free_ty_immediate: non-box ty\")\n+      _ => bcx.tcx().sess.bug(\"free_ty_immediate: non-box ty\")\n     }\n }\n \n@@ -269,7 +269,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"take\");\n             ti.take_glue = Some(glue_fn);\n-            make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, ~\"take\");\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, \"take\");\n             debug!(\"--- lazily_emit_tydesc_glue TAKE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n@@ -282,7 +282,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"drop\");\n             ti.drop_glue = Some(glue_fn);\n-            make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, ~\"drop\");\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, \"drop\");\n             debug!(\"--- lazily_emit_tydesc_glue DROP %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n@@ -295,7 +295,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"free\");\n             ti.free_glue = Some(glue_fn);\n-            make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, ~\"free\");\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, \"free\");\n             debug!(\"--- lazily_emit_tydesc_glue FREE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n@@ -308,7 +308,7 @@ pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n             let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"visit\");\n             ti.visit_glue = Some(glue_fn);\n-            make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, ~\"visit\");\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, \"visit\");\n             debug!(\"--- lazily_emit_tydesc_glue VISIT %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty));\n           }\n@@ -379,8 +379,8 @@ pub fn call_tydesc_glue_full(bcx: block,\n         }\n     };\n \n-    Call(bcx, llfn, ~[C_null(T_ptr(T_nil())), C_null(T_ptr(T_nil())),\n-                      C_null(T_ptr(T_ptr(bcx.ccx().tydesc_type))), llrawptr]);\n+    Call(bcx, llfn, [C_null(T_ptr(T_nil())), C_null(T_ptr(T_nil())),\n+                     C_null(T_ptr(T_ptr(bcx.ccx().tydesc_type))), llrawptr]);\n }\n \n // See [Note-arg-mode]\n@@ -394,7 +394,7 @@ pub fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: uint)\n \n pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let _icx = bcx.insn_ctxt(\"make_visit_glue\");\n-    let bcx = do with_scope(bcx, None, ~\"visitor cleanup\") |bcx| {\n+    let bcx = do with_scope(bcx, None, \"visitor cleanup\") |bcx| {\n         let mut bcx = bcx;\n         let (visitor_trait, object_ty) = ty::visitor_object_ty(bcx.tcx());\n         let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), object_ty)));\n@@ -820,14 +820,14 @@ pub fn emit_tydescs(ccx: @CrateContext) {\n \n         let tydesc =\n             C_named_struct(ccx.tydesc_type,\n-                           ~[ti.size, // size\n-                             ti.align, // align\n-                             take_glue, // take_glue\n-                             drop_glue, // drop_glue\n-                             free_glue, // free_glue\n-                             visit_glue, // visit_glue\n-                             shape, // shape\n-                             shape_tables]); // shape_tables\n+                           [ti.size, // size\n+                            ti.align, // align\n+                            take_glue, // take_glue\n+                            drop_glue, // drop_glue\n+                            free_glue, // free_glue\n+                            visit_glue, // visit_glue\n+                            shape, // shape\n+                            shape_tables]); // shape_tables\n \n         unsafe {\n             let gvar = ti.tydesc;"}, {"sha": "8c88119107f788d9e615dbc472beb390da9a9e78", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -77,14 +77,14 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n                   ccx.external.insert(there.id, Some(here.id.node));\n               }\n             }\n-            _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n-                  non-enum parent\")\n+            _ => ccx.sess.bug(\"maybe_instantiate_inline: item has a \\\n+                               non-enum parent\")\n           }\n           if translate { trans_item(ccx, item); }\n           local_def(my_id)\n         }\n         csearch::found_parent(_, _) => {\n-            ccx.sess.bug(~\"maybe_get_item_ast returned a found_parent \\\n+            ccx.sess.bug(\"maybe_get_item_ast returned a found_parent \\\n              with a non-item parent\");\n         }\n         csearch::found(ast::ii_method(impl_did, mth)) => {\n@@ -98,7 +98,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n               let llfn = get_item_val(ccx, mth.id);\n               let path = vec::append(\n                   ty::item_path(ccx.tcx, impl_did),\n-                  ~[path_name(mth.ident)]);\n+                  [path_name(mth.ident)]);\n               let self_kind = match mth.explicit_self.node {\n                   ast::sty_static => no_self,\n                   _ => {"}, {"sha": "bd3c630fbb7b03724817867a6f377b1f72478ee3", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -150,6 +150,6 @@ pub fn static_size_of_enum(cx: @CrateContext, t: ty::t) -> uint {\n             cx.enum_sizes.insert(t, max_size);\n             return max_size;\n         }\n-        _ => cx.sess.bug(~\"static_size_of_enum called on non-enum\")\n+        _ => cx.sess.bug(\"static_size_of_enum called on non-enum\")\n     }\n }"}, {"sha": "c6af3178d503d3cedd0cfb5d21241c5c346e61b3", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -213,8 +213,8 @@ pub fn trans_method_callee(bcx: block,\n             // Make sure to fail with a readable error message if\n             // there's some internal error here\n             if !(method_index < supertrait_method_def_ids.len()) {\n-                tcx.sess.bug(~\"trans_method_callee: supertrait method \\\n-                               index is out of bounds\");\n+                tcx.sess.bug(\"trans_method_callee: supertrait method \\\n+                              index is out of bounds\");\n             }\n             // Get the method name using the method index in the origin\n             let method_name =\n@@ -657,11 +657,11 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     let self_mode;\n     match explicit_self {\n         ast::sty_static => {\n-            bcx.tcx().sess.bug(~\"shouldn't see static method here\");\n+            bcx.tcx().sess.bug(\"shouldn't see static method here\");\n         }\n         ast::sty_value => {\n-            bcx.tcx().sess.bug(~\"methods with by-value self should not be \\\n-                               called on objects\");\n+            bcx.tcx().sess.bug(\"methods with by-value self should not be \\\n+                                called on objects\");\n         }\n         ast::sty_region(*) => {\n             // As before, we need to pass a pointer to a pointer to the\n@@ -691,7 +691,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             // Pass a pointer to the box.\n             match store {\n                 ty::BoxTraitStore => llself = llbox,\n-                _ => bcx.tcx().sess.bug(~\"@self receiver with non-@Trait\")\n+                _ => bcx.tcx().sess.bug(\"@self receiver with non-@Trait\")\n             }\n \n             let llscratch = alloca(bcx, val_ty(llself));\n@@ -704,7 +704,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             // Pass the unique pointer.\n             match store {\n                 ty::UniqTraitStore => llself = llbox,\n-                _ => bcx.tcx().sess.bug(~\"~self receiver with non-~Trait\")\n+                _ => bcx.tcx().sess.bug(\"~self receiver with non-~Trait\")\n             }\n \n             let llscratch = alloca(bcx, val_ty(llself));"}, {"sha": "f07cf58c6e9b61da46415e143a20b2b37ca1eb61", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -120,23 +120,23 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         (pt, m.ident, m.span)\n       }\n       ast_map::node_trait_method(@ast::required(_), _, _) => {\n-        ccx.tcx.sess.bug(~\"Can't monomorphize a required trait method\")\n+        ccx.tcx.sess.bug(\"Can't monomorphize a required trait method\")\n       }\n       ast_map::node_expr(*) => {\n-        ccx.tcx.sess.bug(~\"Can't monomorphize an expr\")\n+        ccx.tcx.sess.bug(\"Can't monomorphize an expr\")\n       }\n       ast_map::node_stmt(*) => {\n-        ccx.tcx.sess.bug(~\"Can't monomorphize a stmt\")\n+        ccx.tcx.sess.bug(\"Can't monomorphize a stmt\")\n       }\n-      ast_map::node_arg(*) => ccx.tcx.sess.bug(~\"Can't monomorphize an arg\"),\n+      ast_map::node_arg(*) => ccx.tcx.sess.bug(\"Can't monomorphize an arg\"),\n       ast_map::node_block(*) => {\n-          ccx.tcx.sess.bug(~\"Can't monomorphize a block\")\n+          ccx.tcx.sess.bug(\"Can't monomorphize a block\")\n       }\n       ast_map::node_local(*) => {\n-          ccx.tcx.sess.bug(~\"Can't monomorphize a local\")\n+          ccx.tcx.sess.bug(\"Can't monomorphize a local\")\n       }\n       ast_map::node_callee_scope(*) => {\n-          ccx.tcx.sess.bug(~\"Can't monomorphize a callee-scope\")\n+          ccx.tcx.sess.bug(\"Can't monomorphize a callee-scope\")\n       }\n       ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n     };\n@@ -169,8 +169,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n \n     let pt = vec::append(/*bad*/copy *pt,\n-                         ~[path_name((ccx.names)(\n-                             *ccx.sess.str_of(name)))]);\n+                         [path_name((ccx.names)(*ccx.sess.str_of(name)))]);\n     let s = mangle_exported_name(ccx, /*bad*/copy pt, mono_ty);\n \n     let mk_lldecl = || {\n@@ -206,7 +205,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         d\n       }\n       ast_map::node_item(*) => {\n-          ccx.tcx.sess.bug(~\"Can't monomorphize this kind of item\")\n+          ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n       }\n       ast_map::node_foreign_item(i, _, _, _) => {\n           let d = mk_lldecl();\n@@ -225,7 +224,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                                    this_tv.disr_val, psubsts, d);\n             }\n             ast::struct_variant_kind(_) =>\n-                ccx.tcx.sess.bug(~\"can't monomorphize struct variants\"),\n+                ccx.tcx.sess.bug(\"can't monomorphize struct variants\"),\n         }\n         d\n       }\n@@ -257,8 +256,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         set_inline_hint(d);\n         base::trans_tuple_struct(ccx,\n                                  /*bad*/copy struct_def.fields,\n-                                 struct_def.ctor_id.expect(~\"ast-mapped tuple struct \\\n-                                                             didn't have a ctor id\"),\n+                                 struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n+                                                            didn't have a ctor id\"),\n                                  psubsts,\n                                  d);\n         d"}, {"sha": "471d8218ec4e74acc4abdb189512a36799f5eb0f", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -212,8 +212,8 @@ fn traverse_inline_body(cx: @mut ctx, body: &blk) {\n               }\n               Some(_) => {}\n               None => {\n-                cx.tcx.sess.span_bug(e.span, ~\"expr_method_call not in \\\n-                                               method map\");\n+                cx.tcx.sess.span_bug(e.span, \"expr_method_call not in \\\n+                                              method map\");\n               }\n             }\n           }"}, {"sha": "ab40d41dfe939ebc1065306eb16d2eb879f2a970", "filename": "src/librustc/middle/trans/shape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -48,8 +48,8 @@ pub fn mk_global(ccx: @CrateContext,\n \n pub fn mk_ctxt(llmod: ModuleRef) -> Ctxt {\n     unsafe {\n-        let llshapetablesty = trans::common::T_named_struct(~\"shapes\");\n-        let _llshapetables = str::as_c_str(~\"shapes\", |buf| {\n+        let llshapetablesty = trans::common::T_named_struct(\"shapes\");\n+        let _llshapetables = str::as_c_str(\"shapes\", |buf| {\n             llvm::LLVMAddGlobal(llmod, llshapetablesty, buf)\n         });\n "}, {"sha": "29e026189db7c245dea8f938640449a74897ed62", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -45,8 +45,8 @@ pub fn expand_boxed_vec_ty(tcx: ty::ctxt, t: ty::t) -> ty::t {\n       ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) => {\n         ty::mk_imm_box(tcx, unboxed_vec_ty)\n       }\n-      _ => tcx.sess.bug(~\"non boxed-vec type \\\n-                          in tvec::expand_boxed_vec_ty\")\n+      _ => tcx.sess.bug(\"non boxed-vec type \\\n+                         in tvec::expand_boxed_vec_ty\")\n     }\n }\n \n@@ -74,7 +74,7 @@ pub fn pointer_add(bcx: block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let _icx = bcx.insn_ctxt(\"tvec::pointer_add\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n-    return PointerCast(bcx, InBoundsGEP(bcx, bptr, ~[bytes]), old_ty);\n+    return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n pub fn alloc_raw(bcx: block, unit_ty: ty::t,\n@@ -313,7 +313,7 @@ pub fn trans_uniq_or_managed_vstore(bcx: block,\n                     let bcx = callee::trans_lang_call(\n                         bcx,\n                         bcx.tcx().lang_items.strdup_uniq_fn(),\n-                        ~[ llptrval, llsizeval ],\n+                        [ llptrval, llsizeval ],\n                         expr::SaveIn(lldestval.to_ref_llval(bcx)));\n                     return DatumBlock {\n                         bcx: bcx,\n@@ -564,15 +564,15 @@ pub fn iter_vec_raw(bcx: block, data_ptr: ValueRef, vec_ty: ty::t,\n     let header_bcx = base::sub_block(bcx, \"iter_vec_loop_header\");\n     Br(bcx, header_bcx.llbb);\n     let data_ptr =\n-        Phi(header_bcx, val_ty(data_ptr), ~[data_ptr], ~[bcx.llbb]);\n+        Phi(header_bcx, val_ty(data_ptr), [data_ptr], [bcx.llbb]);\n     let not_yet_at_end =\n         ICmp(header_bcx, lib::llvm::IntULT, data_ptr, data_end_ptr);\n     let body_bcx = base::sub_block(header_bcx, \"iter_vec_loop_body\");\n     let next_bcx = base::sub_block(header_bcx, \"iter_vec_next\");\n     CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n     let body_bcx = f(body_bcx, data_ptr, unit_ty);\n     AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n-                                           ~[C_int(bcx.ccx(), 1)]),\n+                                           [C_int(bcx.ccx(), 1)]),\n                      body_bcx.llbb);\n     Br(body_bcx, header_bcx.llbb);\n     return next_bcx;"}, {"sha": "10c2a21e288bf42e2037fd41b445e9ab037a6695", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -70,7 +70,7 @@ pub fn type_of_fn_from_ty(cx: @CrateContext, fty: ty::t) -> TypeRef {\n         ty::ty_closure(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n         ty::ty_bare_fn(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n         _ => {\n-            cx.sess.bug(~\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n+            cx.sess.bug(\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n         }\n     }\n }\n@@ -90,7 +90,7 @@ pub fn type_of_non_gc_box(cx: @CrateContext, t: ty::t) -> TypeRef {\n             T_ptr(T_unique(cx, type_of(cx, mt.ty)))\n           }\n           _ => {\n-            cx.sess.bug(~\"non-box in type_of_non_gc_box\");\n+            cx.sess.bug(\"non-box in type_of_non_gc_box\");\n           }\n         }\n     }\n@@ -135,11 +135,11 @@ pub fn sizing_type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n \n         ty::ty_estr(ty::vstore_slice(*)) |\n         ty::ty_evec(_, ty::vstore_slice(*)) => {\n-            T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())], false)\n+            T_struct([T_ptr(T_i8()), T_ptr(T_i8())], false)\n         }\n \n         ty::ty_bare_fn(*) => T_ptr(T_i8()),\n-        ty::ty_closure(*) => T_struct(~[T_ptr(T_i8()), T_ptr(T_i8())], false),\n+        ty::ty_closure(*) => T_struct([T_ptr(T_i8()), T_ptr(T_i8())], false),\n         ty::ty_trait(_, _, store, _) => T_opaque_trait(cx, store),\n \n         ty::ty_estr(ty::vstore_fixed(size)) => T_array(T_i8(), size),\n@@ -239,15 +239,11 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n       ty::ty_rptr(_, ref mt) => T_ptr(type_of(cx, mt.ty)),\n \n       ty::ty_evec(ref mt, ty::vstore_slice(_)) => {\n-        T_struct(~[T_ptr(type_of(cx, mt.ty)),\n-                   T_uint_ty(cx, ast::ty_u)],\n-                 false)\n+        T_struct([T_ptr(type_of(cx, mt.ty)), T_uint_ty(cx, ast::ty_u)], false)\n       }\n \n       ty::ty_estr(ty::vstore_slice(_)) => {\n-        T_struct(~[T_ptr(T_i8()),\n-                   T_uint_ty(cx, ast::ty_u)],\n-                 false)\n+        T_struct([T_ptr(T_i8()), T_uint_ty(cx, ast::ty_u)], false)\n       }\n \n       ty::ty_estr(ty::vstore_fixed(n)) => {\n@@ -282,10 +278,10 @@ pub fn type_of(cx: @CrateContext, t: ty::t) -> TypeRef {\n                                         substs.tps))\n         }\n       }\n-      ty::ty_self(*) => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n-      ty::ty_infer(*) => cx.tcx.sess.bug(~\"type_of with ty_infer\"),\n-      ty::ty_param(*) => cx.tcx.sess.bug(~\"type_of with ty_param\"),\n-      ty::ty_err(*) => cx.tcx.sess.bug(~\"type_of with ty_err\")\n+      ty::ty_self(*) => cx.tcx.sess.unimpl(\"type_of: ty_self\"),\n+      ty::ty_infer(*) => cx.tcx.sess.bug(\"type_of with ty_infer\"),\n+      ty::ty_param(*) => cx.tcx.sess.bug(\"type_of with ty_param\"),\n+      ty::ty_err(*) => cx.tcx.sess.bug(\"type_of with ty_err\")\n     };\n \n     cx.lltypes.insert(t, llty);\n@@ -336,8 +332,8 @@ pub fn llvm_type_name(cx: @CrateContext,\n }\n \n pub fn type_of_dtor(ccx: @CrateContext, self_ty: ty::t) -> TypeRef {\n-    T_fn(~[T_ptr(T_i8()),                   // output pointer\n-           T_ptr(type_of(ccx, self_ty))],   // self arg\n+    T_fn([T_ptr(T_i8()),                   // output pointer\n+          T_ptr(type_of(ccx, self_ty))],   // self arg\n          T_nil())\n }\n \n@@ -351,6 +347,5 @@ pub fn type_of_rooted(ccx: @CrateContext, t: ty::t) -> TypeRef {\n pub fn type_of_glue_fn(ccx: @CrateContext, t: ty::t) -> TypeRef {\n     let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n     let llty = T_ptr(type_of(ccx, t));\n-    return T_fn(~[T_ptr(T_nil()), T_ptr(T_nil()), tydescpp, llty],\n-                T_nil());\n+    return T_fn([T_ptr(T_nil()), T_ptr(T_nil()), tydescpp, llty], T_nil());\n }"}, {"sha": "9fd6204311253ddf908fe86a8c626b424dd3570b", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -78,7 +78,7 @@ pub fn return_to_mut(mut bcx: block,\n         bcx = callee::trans_lang_call(\n             bcx,\n             bcx.tcx().lang_items.unrecord_borrow_fn(),\n-            ~[\n+            [\n                 box_ptr,\n                 bits_val,\n                 filename_val,\n@@ -90,7 +90,7 @@ pub fn return_to_mut(mut bcx: block,\n     callee::trans_lang_call(\n         bcx,\n         bcx.tcx().lang_items.return_to_mut_fn(),\n-        ~[\n+        [\n             box_ptr,\n             bits_val,\n             filename_val,\n@@ -153,7 +153,7 @@ fn root(datum: &Datum,\n             bcx = callee::trans_lang_call(\n                 bcx,\n                 freeze_did,\n-                ~[\n+                [\n                     box_ptr,\n                     filename,\n                     line\n@@ -164,7 +164,7 @@ fn root(datum: &Datum,\n                 bcx = callee::trans_lang_call(\n                     bcx,\n                     bcx.tcx().lang_items.record_borrow_fn(),\n-                    ~[\n+                    [\n                         box_ptr,\n                         Load(bcx, scratch_bits.val),\n                         filename,\n@@ -193,8 +193,6 @@ fn perform_write_guard(datum: &Datum,\n     callee::trans_lang_call(\n         bcx,\n         bcx.tcx().lang_items.check_not_borrowed_fn(),\n-        ~[PointerCast(bcx, llval, T_ptr(T_i8())),\n-          filename,\n-          line],\n+        [PointerCast(bcx, llval, T_ptr(T_i8())), filename, line],\n         expr::Ignore)\n }"}, {"sha": "2067431a9ef4725ad7fa00390d63374aa7072603", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -1481,7 +1481,7 @@ pub fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n         ty_param(p) => tps[p.idx],\n         ty_self(_) => {\n             match self_ty_opt {\n-                None => cx.sess.bug(~\"ty_self unexpected here\"),\n+                None => cx.sess.bug(\"ty_self unexpected here\"),\n                 Some(self_ty) => {\n                     subst_tps(cx, tps, self_ty_opt, self_ty)\n                 }\n@@ -1582,8 +1582,7 @@ pub fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     match get(ty).sty {\n       ty_estr(_) => return mk_mach_uint(ast::ty_u8),\n       ty_evec(mt, _) | ty_unboxed_vec(mt) => return mt.ty,\n-      _ => cx.sess.bug(\n-          ~\"sequence_element_type called on non-sequence value\"),\n+      _ => cx.sess.bug(\"sequence_element_type called on non-sequence value\"),\n     }\n }\n \n@@ -2133,7 +2132,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             ty_type => TC_NONE,\n \n             ty_err => {\n-                cx.sess.bug(~\"Asked to compute contents of fictitious type\");\n+                cx.sess.bug(\"Asked to compute contents of fictitious type\");\n             }\n         };\n \n@@ -2471,7 +2470,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       }\n \n       ty_infer(*) | ty_self(*) | ty_err => {\n-        cx.sess.bug(~\"non concrete type in type_is_pod\");\n+        cx.sess.bug(\"non concrete type in type_is_pod\");\n       }\n     }\n \n@@ -3519,29 +3518,29 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n pub fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n     match *err {\n         terr_regions_does_not_outlive(subregion, superregion) => {\n-            note_and_explain_region(cx, ~\"\", subregion, ~\"...\");\n-            note_and_explain_region(cx, ~\"...does not necessarily outlive \",\n-                                    superregion, ~\"\");\n+            note_and_explain_region(cx, \"\", subregion, \"...\");\n+            note_and_explain_region(cx, \"...does not necessarily outlive \",\n+                                    superregion, \"\");\n         }\n         terr_regions_not_same(region1, region2) => {\n-            note_and_explain_region(cx, ~\"\", region1, ~\"...\");\n-            note_and_explain_region(cx, ~\"...is not the same lifetime as \",\n-                                    region2, ~\"\");\n+            note_and_explain_region(cx, \"\", region1, \"...\");\n+            note_and_explain_region(cx, \"...is not the same lifetime as \",\n+                                    region2, \"\");\n         }\n         terr_regions_no_overlap(region1, region2) => {\n-            note_and_explain_region(cx, ~\"\", region1, ~\"...\");\n-            note_and_explain_region(cx, ~\"...does not overlap \",\n-                                    region2, ~\"\");\n+            note_and_explain_region(cx, \"\", region1, \"...\");\n+            note_and_explain_region(cx, \"...does not overlap \",\n+                                    region2, \"\");\n         }\n         terr_regions_insufficiently_polymorphic(_, conc_region) => {\n             note_and_explain_region(cx,\n-                                    ~\"concrete lifetime that was found is \",\n-                                    conc_region, ~\"\");\n+                                    \"concrete lifetime that was found is \",\n+                                    conc_region, \"\");\n         }\n         terr_regions_overly_polymorphic(_, conc_region) => {\n             note_and_explain_region(cx,\n-                                    ~\"expected concrete lifetime is \",\n-                                    conc_region, ~\"\");\n+                                    \"expected concrete lifetime is \",\n+                                    conc_region, \"\");\n         }\n         _ => {}\n     }\n@@ -3691,7 +3690,7 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n     if struct_did.crate != ast::local_crate {\n         // XXX: Cross-crate functionality.\n-        cx.sess.unimpl(~\"constructor ID of cross-crate tuple structs\");\n+        cx.sess.unimpl(\"constructor ID of cross-crate tuple structs\");\n     }\n \n     match cx.items.find(&struct_did.node) {\n@@ -3701,10 +3700,10 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n                     struct_def.ctor_id.map(|ctor_id|\n                         ast_util::local_def(*ctor_id))\n                 }\n-                _ => cx.sess.bug(~\"called struct_ctor_id on non-struct\")\n+                _ => cx.sess.bug(\"called struct_ctor_id on non-struct\")\n             }\n         }\n-        _ => cx.sess.bug(~\"called struct_ctor_id on non-struct\")\n+        _ => cx.sess.bug(\"called struct_ctor_id on non-struct\")\n     }\n }\n \n@@ -3869,7 +3868,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                             disr_val = match const_eval::eval_const_expr(cx,\n                                                                          ex) {\n                               const_eval::const_int(val) => val as int,\n-                              _ => cx.sess.bug(~\"tag_variants: bad disr expr\")\n+                              _ => cx.sess.bug(\"tag_variants: bad disr expr\")\n                             }\n                           }\n                           _ => disr_val += 1\n@@ -3888,7 +3887,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n                 }\n             })\n           }\n-          _ => cx.sess.bug(~\"tag_variants: id not bound to an enum\")\n+          _ => cx.sess.bug(\"tag_variants: id not bound to an enum\")\n         }\n     };\n     cx.enum_var_cache.insert(id, result);\n@@ -3908,7 +3907,7 @@ pub fn enum_variant_with_id(cx: ctxt,\n         if variant.id == variant_id { return variant; }\n         i += 1;\n     }\n-    cx.sess.bug(~\"enum_variant_with_id(): no variant exists with that ID\");\n+    cx.sess.bug(\"enum_variant_with_id(): no variant exists with that ID\");\n }\n \n \n@@ -4003,7 +4002,7 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n             ast::item_struct(struct_def, _) => {\n                struct_field_tys(struct_def.fields)\n             }\n-            _ => cx.sess.bug(~\"struct ID bound to non-struct\")\n+            _ => cx.sess.bug(\"struct ID bound to non-struct\")\n          }\n        }\n        Some(&ast_map::node_variant(ref variant, _, _)) => {\n@@ -4012,8 +4011,8 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n               struct_field_tys(struct_def.fields)\n             }\n             _ => {\n-              cx.sess.bug(~\"struct ID bound to enum variant that isn't \\\n-                            struct-like\")\n+              cx.sess.bug(\"struct ID bound to enum variant that isn't \\\n+                           struct-like\")\n             }\n           }\n        }\n@@ -4037,7 +4036,7 @@ pub fn lookup_struct_field(cx: ctxt,\n     match vec::find(lookup_struct_fields(cx, parent),\n                  |f| f.id.node == field_id.node) {\n         Some(t) => t,\n-        None => cx.sess.bug(~\"struct ID not found in parent's fields\")\n+        None => cx.sess.bug(\"struct ID not found in parent's fields\")\n     }\n }\n \n@@ -4338,11 +4337,11 @@ pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n             None => // try autoderef!\n                 match deref(tcx, self_ty, false) {\n                     Some(some_ty) => get_impl_id(tcx, trait_id, some_ty.ty),\n-                    None => tcx.sess.bug(~\"get_impl_id: no impl of trait for \\\n-                                           this type\")\n+                    None => tcx.sess.bug(\"get_impl_id: no impl of trait for \\\n+                                          this type\")\n             }\n         },\n-        None => tcx.sess.bug(~\"get_impl_id: trait isn't in trait_impls\")\n+        None => tcx.sess.bug(\"get_impl_id: trait isn't in trait_impls\")\n     }\n }\n "}, {"sha": "d45882cc17b05fcf47f694b30e19c1da7f986884", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -1462,7 +1462,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                        )\n                      -> ty::t {\n         match method::lookup(fcx, op_ex, self_ex,\n-                             op_ex.callee_id, opname, self_t, ~[],\n+                             op_ex.callee_id, opname, self_t, [],\n                              deref_args, CheckTraitsOnly, autoderef_receiver) {\n             Some(ref origin) => {\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n@@ -1876,7 +1876,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                        } else {\n                                            \"s\"\n                                        },\n-                                       str::connect(missing_fields, ~\", \")));\n+                                       str::connect(missing_fields, \", \")));\n              }\n         }\n \n@@ -2111,7 +2111,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     }\n                     None => fcx.tcx().sess.impossible_case(\n                         expr.span,\n-                        ~\"loop body must have an expected type\")\n+                        \"loop body must have an expected type\")\n                 }\n             }\n         };\n@@ -2397,7 +2397,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n           }\n           fcx.write_nil(id);\n       }\n-      ast::expr_mac(_) => tcx.sess.bug(~\"unexpanded macro\"),\n+      ast::expr_mac(_) => tcx.sess.bug(\"unexpanded macro\"),\n       ast::expr_break(_) => { fcx.write_bot(id); }\n       ast::expr_again(_) => { fcx.write_bot(id); }\n       ast::expr_ret(expr_opt) => {\n@@ -2551,7 +2551,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 None => {\n                     fcx.tcx().sess.impossible_case(\n                         expr.span,\n-                        ~\"do body must have expected type\")\n+                        \"do body must have expected type\")\n                 }\n             }\n         };\n@@ -2911,7 +2911,7 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::stmt)  {\n         saw_bot |= ty::type_is_bot(expr_ty);\n         saw_err |= ty::type_is_error(expr_ty);\n       }\n-      ast::stmt_mac(*) => fcx.ccx.tcx.sess.bug(~\"unexpanded macro\")\n+      ast::stmt_mac(*) => fcx.ccx.tcx.sess.bug(\"unexpanded macro\")\n     }\n     if saw_bot {\n         fcx.write_bot(node_id);"}, {"sha": "0a38e021879cb9e8f845ac527b35223387d4d052", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -1642,19 +1642,19 @@ pub impl RegionVarBindings {\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"first, the lifetime must be contained by \",\n+                        \"first, the lifetime must be contained by \",\n                         upper_bound_1.region,\n-                        ~\"...\");\n+                        \"...\");\n \n                     self.tcx.sess.span_note(\n                         upper_bound_1.span,\n                         fmt!(\"...due to the following expression\"));\n \n                     note_and_explain_region(\n                         self.tcx,\n-                        ~\"but, the lifetime must also be contained by \",\n+                        \"but, the lifetime must also be contained by \",\n                         upper_bound_2.region,\n-                        ~\"...\");\n+                        \"...\");\n \n                     self.tcx.sess.span_note(\n                         upper_bound_2.span,"}, {"sha": "048a6588ba2c58e364a1b2bb2399b1e7048dde93", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -382,9 +382,9 @@ fn check_for_entry_fn(ccx: @mut CrateCtxt) {\n           Some((id, sp)) => match *tcx.sess.entry_type {\n               Some(session::EntryMain) => check_main_fn_ty(ccx, id, sp),\n               Some(session::EntryStart) => check_start_fn_ty(ccx, id, sp),\n-              None => tcx.sess.bug(~\"entry function without a type\")\n+              None => tcx.sess.bug(\"entry function without a type\")\n           },\n-          None => tcx.sess.bug(~\"type checking without entry function\")\n+          None => tcx.sess.bug(\"type checking without entry function\")\n         }\n     }\n }"}, {"sha": "310b0c964eee4f83c27566f777b42ab8e6c36a75", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -137,7 +137,7 @@ pub mod lib {\n pub fn version(argv0: &str) {\n     let mut vers = ~\"unknown version\";\n     let env_vers = env!(\"CFG_VERSION\");\n-    if env_vers.len() != 0 { vers = env_vers; }\n+    if env_vers.len() != 0 { vers = env_vers.to_owned(); }\n     io::println(fmt!(\"%s %s\", argv0, vers));\n     io::println(fmt!(\"host: %s\", host_triple()));\n }\n@@ -168,11 +168,11 @@ Available lint options:\n     }\n     io::println(fmt!(\"\\nAvailable lint checks:\\n\"));\n     io::println(fmt!(\"    %s  %7.7s  %s\",\n-                     padded(max_key, ~\"name\"), ~\"default\", ~\"meaning\"));\n+                     padded(max_key, \"name\"), \"default\", \"meaning\"));\n     io::println(fmt!(\"    %s  %7.7s  %s\\n\",\n-                     padded(max_key, ~\"----\"), ~\"-------\", ~\"-------\"));\n+                     padded(max_key, \"----\"), \"-------\", \"-------\"));\n     for lint_dict.each |k, v| {\n-        let k = str::replace(*k, ~\"_\", ~\"-\");\n+        let k = str::replace(*k, \"_\", \"-\");\n         io::println(fmt!(\"    %s  %7.7s  %s\",\n                          padded(max_key, k),\n                          match v.default {\n@@ -183,7 +183,7 @@ Available lint options:\n                          },\n                          v.desc));\n     }\n-    io::println(~\"\");\n+    io::println(\"\");\n }\n \n pub fn describe_debug_flags() {\n@@ -211,24 +211,24 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n           }\n         };\n \n-    if opt_present(matches, ~\"h\") || opt_present(matches, ~\"help\") {\n+    if opt_present(matches, \"h\") || opt_present(matches, \"help\") {\n         usage(*binary);\n         return;\n     }\n \n-    let lint_flags = vec::append(getopts::opt_strs(matches, ~\"W\"),\n-                                 getopts::opt_strs(matches, ~\"warn\"));\n+    let lint_flags = vec::append(getopts::opt_strs(matches, \"W\"),\n+                                 getopts::opt_strs(matches, \"warn\"));\n     if lint_flags.contains(&~\"help\") {\n         describe_warnings();\n         return;\n     }\n \n-    if getopts::opt_strs(matches, ~\"Z\").contains(&~\"help\") {\n+    if getopts::opt_strs(matches, \"Z\").contains(&~\"help\") {\n         describe_debug_flags();\n         return;\n     }\n \n-    if opt_present(matches, ~\"v\") || opt_present(matches, ~\"version\") {\n+    if opt_present(matches, \"v\") || opt_present(matches, \"version\") {\n         version(*binary);\n         return;\n     }\n@@ -248,12 +248,12 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n \n     let sopts = build_session_options(binary, matches, demitter);\n     let sess = build_session(sopts, demitter);\n-    let odir = getopts::opt_maybe_str(matches, ~\"out-dir\");\n+    let odir = getopts::opt_maybe_str(matches, \"out-dir\");\n     let odir = odir.map(|o| Path(*o));\n-    let ofile = getopts::opt_maybe_str(matches, ~\"o\");\n+    let ofile = getopts::opt_maybe_str(matches, \"o\");\n     let ofile = ofile.map(|o| Path(*o));\n     let cfg = build_configuration(sess, binary, &input);\n-    let pretty = getopts::opt_default(matches, ~\"pretty\", \"normal\").map(\n+    let pretty = getopts::opt_default(matches, \"pretty\", \"normal\").map(\n                     |a| parse_pretty(sess, *a));\n     match pretty {\n       Some::<pp_mode>(ppm) => {\n@@ -262,7 +262,7 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n       }\n       None::<pp_mode> => {/* continue */ }\n     }\n-    let ls = opt_present(matches, ~\"ls\");\n+    let ls = opt_present(matches, \"ls\");\n     if ls {\n         match input {\n           file_input(ref ifile) => {\n@@ -334,7 +334,7 @@ pub fn monitor(f: ~fn(diagnostic::Emitter)) {\n             if p.recv() == done {\n                 diagnostic::emit(\n                     None,\n-                    diagnostic::ice_msg(~\"unexpected failure\"),\n+                    diagnostic::ice_msg(\"unexpected failure\"),\n                     diagnostic::error);\n \n                 for ["}, {"sha": "06adb6cc364af21b26555d78551bde1be4d29369", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -409,13 +409,13 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_uniq(ref tm) => ~\"~\" + mt_to_str(cx, tm),\n       ty_ptr(ref tm) => ~\"*\" + mt_to_str(cx, tm),\n       ty_rptr(r, ref tm) => {\n-        region_to_str_space(cx, ~\"&\", r) + mt_to_str(cx, tm)\n+        region_to_str_space(cx, \"&\", r) + mt_to_str(cx, tm)\n       }\n       ty_unboxed_vec(ref tm) => { ~\"unboxed_vec<\" + mt_to_str(cx, tm) + ~\">\" }\n       ty_type => ~\"type\",\n       ty_tup(ref elems) => {\n         let strs = elems.map(|elem| ty_to_str(cx, *elem));\n-        ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n+        ~\"(\" + str::connect(strs, \",\") + ~\")\"\n       }\n       ty_closure(ref f) => {\n           closure_to_str(cx, f)\n@@ -428,11 +428,11 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_param(param_ty {idx: id, def_id: did}) => {\n           if cx.sess.verbose() {\n               fmt!(\"'%s:%?\",\n-                   str::from_bytes(~[('a' as u8) + (id as u8)]),\n+                   str::from_bytes([('a' as u8) + (id as u8)]),\n                    did)\n           } else {\n               fmt!(\"'%s\",\n-                   str::from_bytes(~[('a' as u8) + (id as u8)]))\n+                   str::from_bytes([('a' as u8) + (id as u8)]))\n           }\n       }\n       ty_self(*) => ~\"Self\",\n@@ -450,7 +450,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_evec(ref mt, vs) => {\n         vstore_ty_to_str(cx, mt, vs)\n       }\n-      ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), ~\"str\"),\n+      ty_estr(vs) => fmt!(\"%s%s\", vstore_to_str(cx, vs), \"str\"),\n       ty_opaque_box => ~\"@?\",\n       ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"closure&\",\n       ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"closure@\","}, {"sha": "57cd03e16a09777b2a44a044ffc60ef7da3ed5de", "filename": "src/libstd/dlist.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdlist.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -136,10 +136,10 @@ priv impl<T> DList<T> {\n         }\n         if !nobe.linked { fail!(\"That node isn't linked to any dlist.\") }\n         if !((nobe.prev.is_some()\n-              || managed::mut_ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+              || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n                                  nobe)) &&\n              (nobe.next.is_some()\n-              || managed::mut_ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+              || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n                                  nobe))) {\n             fail!(\"That node isn't on this dlist.\")\n         }\n@@ -514,10 +514,10 @@ impl<T> BaseIter<T> for @mut DList<T> {\n             }\n             if !nobe.linked ||\n                 (!((nobe.prev.is_some()\n-                    || managed::mut_ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+                    || managed::mut_ptr_eq(self.hd.expect(\"headless dlist?\"),\n                                            nobe))\n                    && (nobe.next.is_some()\n-                    || managed::mut_ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+                    || managed::mut_ptr_eq(self.tl.expect(\"tailless dlist?\"),\n                                            nobe)))) {\n                 fail!(\"Removing a dlist node during iteration is forbidden!\")\n             }"}, {"sha": "6a9a60baae6a291c479c0350a944e04258485da2", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -587,7 +587,7 @@ pub mod groups {\n      */\n     pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n-        let desc_sep = ~\"\\n\" + str::repeat(~\" \", 24);\n+        let desc_sep = ~\"\\n\" + str::repeat(\" \", 24);\n \n         let rows = vec::map(opts, |optref| {\n             let OptGroup{short_name: short_name,\n@@ -597,7 +597,7 @@ pub mod groups {\n                          hasarg: hasarg,\n                          _} = copy *optref;\n \n-            let mut row = str::repeat(~\" \", 4);\n+            let mut row = str::repeat(\" \", 4);\n \n             // short option\n             row += match short_name.len() {\n@@ -623,7 +623,7 @@ pub mod groups {\n             // here we just need to indent the start of the description\n             let rowlen = row.len();\n             row += if rowlen < 24 {\n-                str::repeat(~\" \", 24 - rowlen)\n+                str::repeat(\" \", 24 - rowlen)\n             } else {\n                 copy desc_sep\n             };\n@@ -650,7 +650,7 @@ pub mod groups {\n \n         return str::to_owned(brief)    +\n                ~\"\\n\\nOptions:\\n\"         +\n-               str::connect(rows, ~\"\\n\") +\n+               str::connect(rows, \"\\n\") +\n                ~\"\\n\\n\";\n     }\n } // end groups module"}, {"sha": "44e965b5c43207252f9c2bfb8b1c433a1bde8eb7", "filename": "src/libstd/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -524,9 +524,9 @@ priv impl Parser {\n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n \n         match self.ch {\n-          'n' => self.parse_ident(~\"ull\", Null),\n-          't' => self.parse_ident(~\"rue\", Boolean(true)),\n-          'f' => self.parse_ident(~\"alse\", Boolean(false)),\n+          'n' => self.parse_ident(\"ull\", Null),\n+          't' => self.parse_ident(\"rue\", Boolean(true)),\n+          'f' => self.parse_ident(\"alse\", Boolean(false)),\n           '0' .. '9' | '-' => self.parse_number(),\n           '\"' =>\n             match self.parse_str() {"}, {"sha": "da81f730eda82b8ae05ca4f200732442aff6ed63", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -26,7 +26,7 @@ pub fn md4(msg: &[u8]) -> Quad {\n     let orig_len: u64 = (msg.len() * 8u) as u64;\n \n     // pad message\n-    let mut msg = vec::append(vec::to_owned(msg), ~[0x80u8]);\n+    let mut msg = vec::append(vec::to_owned(msg), [0x80u8]);\n     let mut bitlen = orig_len + 8u64;\n     while (bitlen + 64u64) % 512u64 > 0u64 {\n         msg.push(0u8);"}, {"sha": "fb57c717be960772d8a88c3f5e5c239b8bd430dd", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -350,7 +350,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n             }\n         }\n     }\n-    return str::connect(strvec, ~\"&\");\n+    return str::connect(strvec, \"&\");\n }\n \n // returns the scheme and the rest of the url, or a parsing error\n@@ -390,7 +390,7 @@ enum Input {\n // returns userinfo, host, port, and unparsed part, or an error\n fn get_authority(rawurl: &str) ->\n     Result<(Option<UserInfo>, ~str, Option<~str>, ~str), ~str> {\n-    if !str::starts_with(rawurl, ~\"//\") {\n+    if !str::starts_with(rawurl, \"//\") {\n         // there is no authority.\n         return Ok((None, ~\"\", None, rawurl.to_str()));\n     }\n@@ -575,7 +575,7 @@ fn get_path(rawurl: &str, authority: bool) ->\n     }\n \n     if authority {\n-        if end != 0 && !str::starts_with(rawurl, ~\"/\") {\n+        if end != 0 && !str::starts_with(rawurl, \"/\") {\n             return Err(~\"Non-empty path must begin with\\\n                                '/' in presence of authority.\");\n         }\n@@ -588,8 +588,8 @@ fn get_path(rawurl: &str, authority: bool) ->\n // returns the parsed query and the fragment, if present\n fn get_query_fragment(rawurl: &str) ->\n     Result<(Query, Option<~str>), ~str> {\n-    if !str::starts_with(rawurl, ~\"?\") {\n-        if str::starts_with(rawurl, ~\"#\") {\n+    if !str::starts_with(rawurl, \"?\") {\n+        if str::starts_with(rawurl, \"#\") {\n             let f = decode_component(str::slice(rawurl,\n                                                 1,\n                                                 str::len(rawurl)).to_owned());"}, {"sha": "04444789f827a4235b3341b5b9e2c060ca49f96f", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -106,7 +106,7 @@ Section: Adding things to a rope\n  * * this function executes in near-constant time\n  */\n pub fn append_char(rope: Rope, char: char) -> Rope {\n-    return append_str(rope, @str::from_chars(~[char]));\n+    return append_str(rope, @str::from_chars([char]));\n }\n \n /**\n@@ -127,7 +127,7 @@ pub fn append_str(rope: Rope, str: @~str) -> Rope {\n  * * this function executes in near-constant time\n  */\n pub fn prepend_char(rope: Rope, char: char) -> Rope {\n-    return prepend_str(rope, @str::from_chars(~[char]));\n+    return prepend_str(rope, @str::from_chars([char]));\n }\n \n /**"}, {"sha": "d7051d734698fc4c6f366270a7a702bb8dfabf62", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -177,7 +177,7 @@ pub fn sha1() -> @Sha1 {\n             let b = (hpart >> 16u32 & 0xFFu32) as u8;\n             let c = (hpart >> 8u32 & 0xFFu32) as u8;\n             let d = (hpart & 0xFFu32) as u8;\n-            rs = vec::append(copy rs, ~[a, b, c, d]);\n+            rs = vec::append(copy rs, [a, b, c, d]);\n         }\n         return rs;\n     }"}, {"sha": "fcac70622104d053b394a542c34c2ee1c83c5762", "filename": "src/libstd/term.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -35,19 +35,19 @@ pub static color_bright_magenta: u8 = 13u8;\n pub static color_bright_cyan: u8 = 14u8;\n pub static color_bright_white: u8 = 15u8;\n \n-pub fn esc(writer: @io::Writer) { writer.write(~[0x1bu8, '[' as u8]); }\n+pub fn esc(writer: @io::Writer) { writer.write([0x1bu8, '[' as u8]); }\n \n /// Reset the foreground and background colors to default\n pub fn reset(writer: @io::Writer) {\n     esc(writer);\n-    writer.write(~['0' as u8, 'm' as u8]);\n+    writer.write(['0' as u8, 'm' as u8]);\n }\n \n /// Returns true if the terminal supports color\n pub fn color_supported() -> bool {\n     let supported_terms = ~[~\"xterm-color\", ~\"xterm\",\n                            ~\"screen-bce\", ~\"xterm-256color\"];\n-    return match os::getenv(~\"TERM\") {\n+    return match os::getenv(\"TERM\") {\n           option::Some(ref env) => {\n             for supported_terms.each |term| {\n                 if *term == *env { return true; }\n@@ -62,8 +62,8 @@ pub fn set_color(writer: @io::Writer, first_char: u8, color: u8) {\n     assert!((color < 16u8));\n     esc(writer);\n     let mut color = color;\n-    if color >= 8u8 { writer.write(~['1' as u8, ';' as u8]); color -= 8u8; }\n-    writer.write(~[first_char, ('0' as u8) + color, 'm' as u8]);\n+    if color >= 8u8 { writer.write(['1' as u8, ';' as u8]); color -= 8u8; }\n+    writer.write([first_char, ('0' as u8) + color, 'm' as u8]);\n }\n \n /// Set the foreground color"}, {"sha": "4046ce83c9dcf86530e2e5cf0f9f1f3af5f73133", "filename": "src/libstd/test.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -131,12 +131,12 @@ type OptRes = Either<TestOpts, ~str>;\n // Parses command line arguments into test options\n pub fn parse_opts(args: &[~str]) -> OptRes {\n     let args_ = vec::tail(args);\n-    let opts = ~[getopts::optflag(~\"ignored\"),\n-                 getopts::optflag(~\"test\"),\n-                 getopts::optflag(~\"bench\"),\n-                 getopts::optopt(~\"save\"),\n-                 getopts::optopt(~\"diff\"),\n-                 getopts::optopt(~\"logfile\")];\n+    let opts = ~[getopts::optflag(\"ignored\"),\n+                 getopts::optflag(\"test\"),\n+                 getopts::optflag(\"bench\"),\n+                 getopts::optopt(\"save\"),\n+                 getopts::optopt(\"diff\"),\n+                 getopts::optopt(\"logfile\")];\n     let matches =\n         match getopts::getopts(args_, opts) {\n           Ok(m) => m,\n@@ -148,19 +148,19 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n             option::Some(copy (matches).free[0])\n         } else { option::None };\n \n-    let run_ignored = getopts::opt_present(&matches, ~\"ignored\");\n+    let run_ignored = getopts::opt_present(&matches, \"ignored\");\n \n-    let logfile = getopts::opt_maybe_str(&matches, ~\"logfile\");\n+    let logfile = getopts::opt_maybe_str(&matches, \"logfile\");\n     let logfile = logfile.map(|s| Path(*s));\n \n-    let run_benchmarks = getopts::opt_present(&matches, ~\"bench\");\n+    let run_benchmarks = getopts::opt_present(&matches, \"bench\");\n     let run_tests = ! run_benchmarks ||\n-        getopts::opt_present(&matches, ~\"test\");\n+        getopts::opt_present(&matches, \"test\");\n \n-    let save_results = getopts::opt_maybe_str(&matches, ~\"save\");\n+    let save_results = getopts::opt_maybe_str(&matches, \"save\");\n     let save_results = save_results.map(|s| Path(*s));\n \n-    let compare_results = getopts::opt_maybe_str(&matches, ~\"diff\");\n+    let compare_results = getopts::opt_maybe_str(&matches, \"diff\");\n     let compare_results = compare_results.map(|s| Path(*s));\n \n     let test_opts = TestOpts {\n@@ -220,18 +220,18 @@ pub fn run_tests_console(opts: &TestOpts,\n               TrOk => {\n                 st.passed += 1;\n                 write_ok(st.out, st.use_color);\n-                st.out.write_line(~\"\");\n+                st.out.write_line(\"\");\n               }\n               TrFailed => {\n                 st.failed += 1;\n                 write_failed(st.out, st.use_color);\n-                st.out.write_line(~\"\");\n+                st.out.write_line(\"\");\n                 st.failures.push(test);\n               }\n               TrIgnored => {\n                 st.ignored += 1;\n                 write_ignored(st.out, st.use_color);\n-                st.out.write_line(~\"\");\n+                st.out.write_line(\"\");\n               }\n               TrBench(bs) => {\n                 st.benchmarked += 1u;\n@@ -246,8 +246,8 @@ pub fn run_tests_console(opts: &TestOpts,\n \n     let log_out = match opts.logfile {\n         Some(ref path) => match io::file_writer(path,\n-                                                ~[io::Create,\n-                                                  io::Truncate]) {\n+                                                [io::Create,\n+                                                 io::Truncate]) {\n           result::Ok(w) => Some(w),\n           result::Err(ref s) => {\n               fail!(\"can't open output file: %s\", *s)\n@@ -318,19 +318,19 @@ pub fn run_tests_console(opts: &TestOpts,\n     }\n \n     fn write_ok(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, ~\"ok\", term::color_green, use_color);\n+        write_pretty(out, \"ok\", term::color_green, use_color);\n     }\n \n     fn write_failed(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, ~\"FAILED\", term::color_red, use_color);\n+        write_pretty(out, \"FAILED\", term::color_red, use_color);\n     }\n \n     fn write_ignored(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, ~\"ignored\", term::color_yellow, use_color);\n+        write_pretty(out, \"ignored\", term::color_yellow, use_color);\n     }\n \n     fn write_bench(out: @io::Writer, use_color: bool) {\n-        write_pretty(out, ~\"bench\", term::color_cyan, use_color);\n+        write_pretty(out, \"bench\", term::color_cyan, use_color);\n     }\n \n     fn write_pretty(out: @io::Writer,\n@@ -348,7 +348,7 @@ pub fn run_tests_console(opts: &TestOpts,\n }\n \n fn print_failures(st: &ConsoleTestState) {\n-    st.out.write_line(~\"\\nfailures:\");\n+    st.out.write_line(\"\\nfailures:\");\n     let mut failures = ~[];\n     for uint::range(0, vec::uniq_len(&const st.failures)) |i| {\n         let name = copy st.failures[i].name;"}, {"sha": "565ce2d0dd3b3e42f02c29044c7ccda2f5a75ea0", "filename": "src/libstd/time.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -199,7 +199,7 @@ pub impl Tm {\n      * Return a string of the current time in the form\n      * \"Thu Jan  1 00:00:00 1970\".\n      */\n-    fn ctime(&self) -> ~str { self.strftime(~\"%c\") }\n+    fn ctime(&self) -> ~str { self.strftime(\"%c\") }\n \n     /// Formats the time according to the format string.\n     fn strftime(&self, format: &str) -> ~str {\n@@ -214,9 +214,9 @@ pub impl Tm {\n      */\n     fn rfc822(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n-            self.strftime(~\"%a, %d %b %Y %T GMT\")\n+            self.strftime(\"%a, %d %b %Y %T GMT\")\n         } else {\n-            self.strftime(~\"%a, %d %b %Y %T %Z\")\n+            self.strftime(\"%a, %d %b %Y %T %Z\")\n         }\n     }\n \n@@ -227,7 +227,7 @@ pub impl Tm {\n      * utc:   \"Thu, 22 Mar 2012 14:53:18 -0000\"\n      */\n     fn rfc822z(&self) -> ~str {\n-        self.strftime(~\"%a, %d %b %Y %T %z\")\n+        self.strftime(\"%a, %d %b %Y %T %z\")\n     }\n \n     /**\n@@ -238,9 +238,9 @@ pub impl Tm {\n      */\n     fn rfc3339(&self) -> ~str {\n         if self.tm_gmtoff == 0_i32 {\n-            self.strftime(~\"%Y-%m-%dT%H:%M:%SZ\")\n+            self.strftime(\"%Y-%m-%dT%H:%M:%SZ\")\n         } else {\n-            let s = self.strftime(~\"%Y-%m-%dT%H:%M:%S\");\n+            let s = self.strftime(\"%Y-%m-%dT%H:%M:%S\");\n             let sign = if self.tm_gmtoff > 0_i32 { '+' } else { '-' };\n             let mut m = i32::abs(self.tm_gmtoff) / 60_i32;\n             let h = m / 60_i32;\n@@ -326,7 +326,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn parse_type(s: &str, pos: uint, ch: char, tm: &mut Tm)\n       -> Result<uint, ~str> {\n         match ch {\n-          'A' => match match_strs(s, pos, ~[\n+          'A' => match match_strs(s, pos, [\n               (~\"Sunday\", 0_i32),\n               (~\"Monday\", 1_i32),\n               (~\"Tuesday\", 2_i32),\n@@ -338,7 +338,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n             None => Err(~\"Invalid day\")\n           },\n-          'a' => match match_strs(s, pos, ~[\n+          'a' => match match_strs(s, pos, [\n               (~\"Sun\", 0_i32),\n               (~\"Mon\", 1_i32),\n               (~\"Tue\", 2_i32),\n@@ -350,7 +350,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             Some(item) => { let (v, pos) = item; tm.tm_wday = v; Ok(pos) }\n             None => Err(~\"Invalid day\")\n           },\n-          'B' => match match_strs(s, pos, ~[\n+          'B' => match match_strs(s, pos, [\n               (~\"January\", 0_i32),\n               (~\"February\", 1_i32),\n               (~\"March\", 2_i32),\n@@ -367,7 +367,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             Some(item) => { let (v, pos) = item; tm.tm_mon = v; Ok(pos) }\n             None => Err(~\"Invalid month\")\n           },\n-          'b' | 'h' => match match_strs(s, pos, ~[\n+          'b' | 'h' => match match_strs(s, pos, [\n               (~\"Jan\", 0_i32),\n               (~\"Feb\", 1_i32),\n               (~\"Mar\", 2_i32),\n@@ -488,13 +488,13 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n           }\n           'n' => parse_char(s, pos, '\\n'),\n           'P' => match match_strs(s, pos,\n-                                  ~[(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n+                                  [(~\"am\", 0_i32), (~\"pm\", 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n             None => Err(~\"Invalid hour\")\n           },\n           'p' => match match_strs(s, pos,\n-                                  ~[(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n+                                  [(~\"AM\", 0_i32), (~\"PM\", 12_i32)]) {\n \n             Some(item) => { let (v, pos) = item; tm.tm_hour += v; Ok(pos) }\n             None => Err(~\"Invalid hour\")\n@@ -579,7 +579,7 @@ priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n             }\n           }\n           'Z' => {\n-            if match_str(s, pos, ~\"UTC\") || match_str(s, pos, ~\"GMT\") {\n+            if match_str(s, pos, \"UTC\") || match_str(s, pos, \"GMT\") {\n                 tm.tm_gmtoff = 0_i32;\n                 tm.tm_zone = ~\"UTC\";\n                 Ok(pos + 3u)"}, {"sha": "5b08f59b35c2eae090b2118bbf5aa259c265c84f", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -107,7 +107,7 @@ pub struct Ctx {\n pub type vt = visit::vt<@mut Ctx>;\n \n pub fn extend(cx: @mut Ctx, elt: ident) -> @path {\n-    @(vec::append(copy cx.path, ~[path_name(elt)]))\n+    @(vec::append(copy cx.path, [path_name(elt)]))\n }\n \n pub fn mk_ast_map_visitor() -> vt {"}, {"sha": "e209fd14b5e02c9136be92b95eca8709b0bf5b53", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -21,7 +21,7 @@ use core::to_bytes;\n \n pub fn path_name_i(idents: &[ident], intr: @token::ident_interner) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map(|i| copy *intr.get(*i)), ~\"::\")\n+    str::connect(idents.map(|i| copy *intr.get(*i)), \"::\")\n }\n \n "}, {"sha": "981df1156df594b3f776b2e56fc2ede03474b4af", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -291,7 +291,7 @@ pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n  * linkage\n  */\n pub fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n-    do find_attrs_by_name(attrs, ~\"link\").flat_map |attr| {\n+    do find_attrs_by_name(attrs, \"link\").flat_map |attr| {\n         match attr.node.value.node {\n             ast::meta_list(_, ref items) => /* FIXME (#2543) */ copy *items,\n             _ => ~[]\n@@ -314,9 +314,9 @@ pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n         match attr.node.value.node {\n           ast::meta_word(@~\"inline\") => ia_hint,\n           ast::meta_list(@~\"inline\", ref items) => {\n-            if !find_meta_items_by_name(*items, ~\"always\").is_empty() {\n+            if !find_meta_items_by_name(*items, \"always\").is_empty() {\n                 ia_always\n-            } else if !find_meta_items_by_name(*items, ~\"never\").is_empty() {\n+            } else if !find_meta_items_by_name(*items, \"never\").is_empty() {\n                 ia_never\n             } else {\n                 ia_hint"}, {"sha": "21e2ad82b1493e2dbbf712a6e7a668dc1e240921", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -218,7 +218,7 @@ pub fn emit(cmsp: Option<(@codemap::CodeMap, span)>, msg: &str, lvl: level) {\n         print_macro_backtrace(cm, sp);\n       }\n       None => {\n-        print_diagnostic(~\"\", lvl, msg);\n+        print_diagnostic(\"\", lvl, msg);\n       }\n     }\n }\n@@ -296,7 +296,7 @@ fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n         print_diagnostic(*ss, note,\n                          fmt!(\"in expansion of %s!\", ei.callee.name));\n         let ss = cm.span_to_str(ei.call_site);\n-        print_diagnostic(ss, note, ~\"expansion site\");\n+        print_diagnostic(ss, note, \"expansion site\");\n         print_macro_backtrace(cm, ei.call_site);\n     }\n }"}, {"sha": "2a7f8c8865b815f631722da55ddeb69712af5e6e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -250,7 +250,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n         fn call_site(&self) -> span {\n             match *self.backtrace {\n                 Some(@ExpandedFrom(CallInfo {call_site: cs, _})) => cs,\n-                None => self.bug(~\"missing top span\")\n+                None => self.bug(\"missing top span\")\n             }\n         }\n         fn print_backtrace(&self) { }\n@@ -276,7 +276,7 @@ pub fn mk_ctxt(parse_sess: @mut parse::ParseSess, cfg: ast::crate_cfg)\n               })) => {\n                 *self.backtrace = prev\n               }\n-              _ => self.bug(~\"tried to pop without a push\")\n+              _ => self.bug(\"tried to pop without a push\")\n             }\n         }\n         fn span_fatal(&self, sp: span, msg: &str) -> ! {"}, {"sha": "da32cc1162513ace905847743d99427d4fd0387b", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -21,15 +21,13 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n         if i & 1 == 1 {\n             match *e {\n                 ast::tt_tok(_, token::COMMA) => (),\n-                _ => cx.span_fatal(sp, ~\"concat_idents! \\\n-                                         expecting comma.\")\n+                _ => cx.span_fatal(sp, \"concat_idents! expecting comma.\")\n             }\n         } else {\n             match *e {\n                 ast::tt_tok(_, token::IDENT(ident,_)) =>\n                 res_str += cx.str_of(ident),\n-                _ => cx.span_fatal(sp, ~\"concat_idents! \\\n-                                         requires ident args.\")\n+                _ => cx.span_fatal(sp, \"concat_idents! requires ident args.\")\n             }\n         }\n     }"}, {"sha": "fe20511204632de22a0e98a1ad9c299b1ac6c122", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -291,7 +291,7 @@ fn expand_deriving_decodable_struct_method(\n             unnamed_field => {\n                 cx.span_unimpl(\n                     span,\n-                    ~\"unnamed fields with `deriving(Decodable)`\"\n+                    \"unnamed fields with `deriving(Decodable)`\"\n                 );\n             }\n         }"}, {"sha": "b1df8405d7627b56341d696aae54cc03c5cfdbfc", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -321,7 +321,7 @@ fn expand_deriving_encodable_struct_method(\n             unnamed_field => {\n                 cx.span_unimpl(\n                     span,\n-                    ~\"unnamed fields with `deriving(Encodable)`\"\n+                    \"unnamed fields with `deriving(Encodable)`\"\n                 );\n             }\n         }"}, {"sha": "2fc9dadfe2c1bdd51cc2248e8370bd0cb7dd93d1", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -539,8 +539,8 @@ impl<'self> MethodDef<'self> {\n                     (opt_id, field, other_fields)\n                 }\n             }\n-            [] => { cx.span_bug(span, ~\"No self arguments to non-static \\\n-                                        method in generic `deriving`\") }\n+            [] => { cx.span_bug(span, \"No self arguments to non-static \\\n+                                       method in generic `deriving`\") }\n         };\n \n         // body of the inner most destructuring match\n@@ -658,8 +658,8 @@ impl<'self> MethodDef<'self> {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n             if matches_so_far.len() == 0 {\n-                cx.span_bug(span, ~\"no self match on an enum in generic \\\n-                                    `deriving`\");\n+                cx.span_bug(span, \"no self match on an enum in generic \\\n+                                   `deriving`\");\n             }\n             // we currently have a vec of vecs, where each\n             // subvec is the fields of one of the arguments,\n@@ -718,8 +718,8 @@ impl<'self> MethodDef<'self> {\n                 // make a matching-variant match, and a _ match.\n                 let index = match matching {\n                     Some(i) => i,\n-                    None => cx.span_bug(span, ~\"Non-matching variants when required to \\\n-                                                be matching in generic `deriving`\")\n+                    None => cx.span_bug(span, \"Non-matching variants when required to \\\n+                                               be matching in generic `deriving`\")\n                 };\n \n                 // matching-variant match"}, {"sha": "6f4429af12d75ac5671deb2a834c6326b4c23e0e", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -67,11 +67,11 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n \n     match mitem.node {\n         meta_name_value(_, ref l) => {\n-            cx.span_err(l.span, ~\"unexpected value in `deriving`\");\n+            cx.span_err(l.span, \"unexpected value in `deriving`\");\n             in_items\n         }\n         meta_word(_) | meta_list(_, []) => {\n-            cx.span_warn(mitem.span, ~\"empty trait list in `deriving`\");\n+            cx.span_warn(mitem.span, \"empty trait list in `deriving`\");\n             in_items\n         }\n         meta_list(_, ref titems) => {"}, {"sha": "f155cb3790faab26bba2724b64ae9fa3f1d431e6", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -49,6 +49,6 @@ fn to_str_substructure(cx: @ext_ctxt, span: span, substr: &Substructure) -> @exp\n                                     cx.ident_of(\"log_str\")],\n                                   ~[self_addr])\n         }\n-        _ => cx.span_bug(span, ~\"Invalid number of arguments in `deriving(ToStr)`\")\n+        _ => cx.span_bug(span, \"Invalid number of arguments in `deriving(ToStr)`\")\n     }\n }"}, {"sha": "5fc3aeb789c109197d744569af1e35a82d4fe0f6", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -167,8 +167,8 @@ pub impl Ty {\n             Literal(ref p) => {\n                 p.to_path(cx, span, self_ty, self_generics)\n             }\n-            Ptr(*) => { cx.span_bug(span, ~\"Pointer in a path in generic `deriving`\") }\n-            Tuple(*) => { cx.span_bug(span, ~\"Tuple in a path in generic `deriving`\") }\n+            Ptr(*) => { cx.span_bug(span, \"Pointer in a path in generic `deriving`\") }\n+            Tuple(*) => { cx.span_bug(span, \"Tuple in a path in generic `deriving`\") }\n         }\n     }\n }"}, {"sha": "4be75d9ee5b578d96af9cb38b42fc5b3b81a90df", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -18,7 +18,7 @@ use ast;\n use codemap::span;\n use ext::base::*;\n use ext::base;\n-use ext::build::mk_uniq_str;\n+use ext::build::mk_base_str;\n \n pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n@@ -29,8 +29,8 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     // Option<str> rather than just an maybe-empty string.\n \n     let e = match os::getenv(var) {\n-      None => mk_uniq_str(cx, sp, ~\"\"),\n-      Some(ref s) => mk_uniq_str(cx, sp, copy *s)\n+      None => mk_base_str(cx, sp, ~\"\"),\n+      Some(ref s) => mk_base_str(cx, sp, copy *s)\n     };\n     MRExpr(e)\n }"}, {"sha": "ff0cf6f28ad8f9200ae0f89e5258ee9d2462f370", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -234,7 +234,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         item_mac(codemap::spanned { node: mac_invoc_tt(pth, ref tts), _}) => {\n             (pth, copy *tts)\n         }\n-        _ => cx.span_bug(it.span, ~\"invalid item macro invocation\")\n+        _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n@@ -377,8 +377,7 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n             // see note below about treatment of exts table\n             with_exts_frame!(extsbox,orig(blk,sp,fld))\n         },\n-        _ => cx.span_bug(sp,\n-                         ~\"expected ScopeMacros binding for \\\" block\\\"\")\n+        _ => cx.span_bug(sp, \"expected ScopeMacros binding for \\\" block\\\"\")\n     }\n }\n \n@@ -628,7 +627,7 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n                                               attrs,\n                                               parse_sess) {\n         Some(item) => item,\n-        None => cx.bug(~\"expected core macros to parse correctly\")\n+        None => cx.bug(\"expected core macros to parse correctly\")\n     };\n     // This is run for its side-effects on the expander env,\n     // as it registers all the core macros as expanders."}, {"sha": "24046faa6849d1e930520f6acdd4cfa084f4c2c5", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -88,7 +88,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n                 let count_is_args = ~[count_lit];\n                 return mk_call_global(cx, sp, count_is_path, count_is_args);\n               }\n-              _ => cx.span_unimpl(sp, ~\"unimplemented fmt! conversion\")\n+              _ => cx.span_unimpl(sp, \"unimplemented fmt! conversion\")\n             }\n         }\n         fn make_ty(cx: @ext_ctxt, sp: span, t: Ty) -> @ast::expr {"}, {"sha": "104e5f94d17703555f2393ac74aab31421524213", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -85,7 +85,7 @@ pub fn analyze(proto: @mut protocol_, _cx: @ext_ctxt) {\n     }\n \n     if self_live.len() > 0 {\n-        let states = str::connect(self_live.map(|s| copy s.name), ~\" \");\n+        let states = str::connect(self_live.map(|s| copy s.name), \" \");\n \n         debug!(\"protocol %s is unbounded due to loops involving: %s\",\n                copy proto.name, states);"}, {"sha": "28c8c9a704d9049d8552e7a3d01c63fb738258ec", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -114,7 +114,7 @@ impl proto_parser for parser::Parser {\n             self.bump();\n             None\n           }\n-          _ => self.fatal(~\"invalid next state\")\n+          _ => self.fatal(\"invalid next state\")\n         };\n \n         state.add_message(mname, *self.span, args, next);"}, {"sha": "8a9c714e7e939a8315d788f8eda5a8031acd46ff", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -96,7 +96,7 @@ impl gen_send for message {\n                          name,\n                          str::connect(vec::append_one(\n                            arg_names.map(|x| cx.str_of(*x)),\n-                             ~\"s\"), ~\", \"));\n+                             ~\"s\"), \", \"));\n \n             if !try {\n                 body += fmt!(\"::core::pipes::send(pipe, message);\\n\");\n@@ -148,7 +148,7 @@ impl gen_send for message {\n                 }\n                 else {\n                     ~\"(\" + str::connect(arg_names.map(|x| copy *x),\n-                                        ~\", \") + ~\")\"\n+                                        \", \") + ~\")\"\n                 };\n \n                 let mut body = ~\"{ \";"}, {"sha": "2134c2ba19bffa548aeb5ea5f721ccce4bd16d9d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -86,7 +86,7 @@ pub mod rt {\n \n     impl<'self> ToSource for &'self [@ast::item] {\n         fn to_source(&self, cx: @ext_ctxt) -> ~str {\n-            str::connect(self.map(|i| i.to_source(cx)), ~\"\\n\\n\")\n+            str::connect(self.map(|i| i.to_source(cx)), \"\\n\\n\")\n         }\n     }\n \n@@ -98,7 +98,7 @@ pub mod rt {\n \n     impl<'self> ToSource for &'self [@ast::Ty] {\n         fn to_source(&self, cx: @ext_ctxt) -> ~str {\n-            str::connect(self.map(|i| i.to_source(cx)), ~\", \")\n+            str::connect(self.map(|i| i.to_source(cx)), \", \")\n         }\n     }\n \n@@ -421,7 +421,7 @@ fn id_ext(cx: @ext_ctxt, str: &str) -> ast::ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: @ext_ctxt, sp: span, ident: ast::ident) -> @ast::expr {\n-    let e_str = build::mk_uniq_str(cx, sp, cx.str_of(ident));\n+    let e_str = build::mk_base_str(cx, sp, cx.str_of(ident));\n     build::mk_method_call(cx, sp,\n                           build::mk_path(cx, sp, ids_ext(cx, ~[~\"ext_cx\"])),\n                           id_ext(cx, \"ident_of\"),"}, {"sha": "c0d9b3f06af560b25a108f39b4f41ea419085a06", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -67,7 +67,7 @@ pub fn expand_mod(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(mk_base_str(cx, sp,\n                               str::connect(cx.mod_path().map(\n-                                  |x| cx.str_of(*x)), ~\"::\")))\n+                                  |x| cx.str_of(*x)), \"::\")))\n }\n \n // include! : parse the given file as an expr"}, {"sha": "0ecb3b2a3f47f3e3d25e84223df798b500431d3e", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -39,7 +39,7 @@ pub fn expand_trace_macros(cx: @ext_ctxt,\n     } else if rust_parser.is_keyword(\"false\") {\n         cx.set_trace_macros(false);\n     } else {\n-        cx.span_fatal(sp, ~\"trace_macros! only accepts `true` or `false`\")\n+        cx.span_fatal(sp, \"trace_macros! only accepts `true` or `false`\")\n     }\n \n     rust_parser.bump();"}, {"sha": "a34045a883eec06caa8afc3b8b2ecc05e497b265", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -371,7 +371,7 @@ pub fn parse(\n                              *sess.interner.get(bind))\n                       }\n                       _ => fail!()\n-                    } }), ~\" or \");\n+                    } }), \" or \");\n                 return error(sp, fmt!(\n                     \"Local ambiguity: multiple parsing options: \\\n                      built-in NTs %s or %u other options.\",\n@@ -413,7 +413,7 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n     match name {\n       \"item\" => match p.parse_item(~[]) {\n         Some(i) => token::nt_item(i),\n-        None => p.fatal(~\"expected an item keyword\")\n+        None => p.fatal(\"expected an item keyword\")\n       },\n       \"block\" => token::nt_block(p.parse_block()),\n       \"stmt\" => token::nt_stmt(p.parse_stmt(~[])),"}, {"sha": "d34eca342e93e5b8d226777256c3fbcda73cf427", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -64,12 +64,12 @@ pub fn add_new_extension(cx: @ext_ctxt,\n     // Extract the arguments:\n     let lhses = match *argument_map.get(&lhs_nm) {\n         @matched_seq(ref s, _) => /* FIXME (#2543) */ @copy *s,\n-        _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n+        _ => cx.span_bug(sp, \"wrong-structured lhs\")\n     };\n \n     let rhses = match *argument_map.get(&rhs_nm) {\n       @matched_seq(ref s, _) => /* FIXME (#2543) */ @copy *s,\n-      _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n+      _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n@@ -114,10 +114,10 @@ pub fn add_new_extension(cx: @ext_ctxt,\n                                     (*tts).slice(1u,(*tts).len()-1u).to_owned()\n                                 }\n                                 _ => cx.span_fatal(\n-                                    sp, ~\"macro rhs must be delimited\")\n+                                    sp, \"macro rhs must be delimited\")\n                             }\n                         },\n-                        _ => cx.span_bug(sp, ~\"bad thing in rhs\")\n+                        _ => cx.span_bug(sp, \"bad thing in rhs\")\n                     };\n                     // rhs has holes ( `$id` and `$(...)` that need filled)\n                     let trncbr = new_tt_reader(s_d, itr, Some(named_matches),\n@@ -139,7 +139,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n                   error(sp, ref msg) => cx.span_fatal(sp, (*msg))\n                 }\n               }\n-              _ => cx.bug(~\"non-matcher found in parsed lhses\")\n+              _ => cx.bug(\"non-matcher found in parsed lhses\")\n             }\n         }\n         cx.span_fatal(best_fail_spot, best_fail_msg);"}, {"sha": "d806801b7d172b715714f4a22ac511e327f6a691", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -234,9 +234,9 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n               lis_unconstrained => {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */\n-                      ~\"attempted to repeat an expression \\\n-                        containing no syntax \\\n-                        variables matched as repeating at this depth\");\n+                      \"attempted to repeat an expression \\\n+                       containing no syntax \\\n+                       variables matched as repeating at this depth\");\n                   }\n                   lis_contradiction(ref msg) => {\n                       /* FIXME #2887 blame macro invoker instead*/\n@@ -247,8 +247,8 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                       if !zerok {\n                         r.sp_diag.span_fatal(sp, /* FIXME #2887 blame invoker\n                         */\n-                                             ~\"this must repeat at least \\\n-                                               once\");\n+                                             \"this must repeat at least \\\n+                                              once\");\n                           }\n \n                     r.stack.idx += 1u;"}, {"sha": "d947fa43ca7e83bb083b6b7ae9669be40d60d33d", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -51,7 +51,7 @@ impl parser_attr for Parser {\n                     self.span.hi\n                 );\n                 if attr.node.style != ast::attr_outer {\n-                  self.fatal(~\"expected outer comment\");\n+                  self.fatal(\"expected outer comment\");\n                 }\n                 attrs += ~[attr];\n                 self.bump();"}, {"sha": "da7ad6ffeffcc23ca9fb6e55497f9005989bdf29", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -33,15 +33,15 @@ pub struct cmnt {\n }\n \n pub fn is_doc_comment(s: &str) -> bool {\n-    (s.starts_with(~\"///\") && !is_line_non_doc_comment(s)) ||\n-    s.starts_with(~\"//!\") ||\n-    (s.starts_with(~\"/**\") && !is_block_non_doc_comment(s)) ||\n-    s.starts_with(~\"/*!\")\n+    (s.starts_with(\"///\") && !is_line_non_doc_comment(s)) ||\n+    s.starts_with(\"//!\") ||\n+    (s.starts_with(\"/**\") && !is_block_non_doc_comment(s)) ||\n+    s.starts_with(\"/*!\")\n }\n \n pub fn doc_comment_style(comment: &str) -> ast::attr_style {\n     assert!(is_doc_comment(comment));\n-    if comment.starts_with(~\"//!\") || comment.starts_with(~\"/*!\") {\n+    if comment.starts_with(\"//!\") || comment.starts_with(\"/*!\") {\n         ast::attr_inner\n     } else {\n         ast::attr_outer\n@@ -92,14 +92,14 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         };\n     }\n \n-    if comment.starts_with(~\"//\") {\n+    if comment.starts_with(\"//\") {\n         // FIXME #5475:\n         // return comment.slice(3u, comment.len()).trim().to_owned();\n         let r = comment.slice(3u, comment.len()); return r.trim().to_owned();\n \n     }\n \n-    if comment.starts_with(~\"/*\") {\n+    if comment.starts_with(\"/*\") {\n         let mut lines = ~[];\n         for str::each_line_any(comment.slice(3u, comment.len() - 2u)) |line| {\n             lines.push(line.to_owned())\n@@ -108,7 +108,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         let lines = block_trim(lines, ~\"\\t \", None);\n         let lines = block_trim(lines, ~\"*\", Some(1u));\n         let lines = block_trim(lines, ~\"\\t \", None);\n-        return str::connect(lines, ~\"\\n\");\n+        return str::connect(lines, \"\\n\");\n     }\n \n     fail!(\"not a doc-comment: %s\", comment);"}, {"sha": "6e85b814b31e86174d9db53a07973c602a8943dd", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -104,9 +104,7 @@ pub impl Parser {\n                 i\n             }\n             token::INTERPOLATED(token::nt_ident(*)) => {\n-                self.bug(\n-                    ~\"ident interpolation not converted to real token\"\n-                );\n+                self.bug(\"ident interpolation not converted to real token\");\n             }\n             _ => {\n                 self.fatal("}, {"sha": "2de27285ce2b1b605d1d9beecc8ec9a3b5461b59", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -354,7 +354,7 @@ pub impl Parser {\n     fn get_lifetime(&self, tok: &token::Token) -> ast::ident {\n         match *tok {\n             token::LIFETIME(ref ident) => copy *ident,\n-            _ => self.bug(~\"not a lifetime\"),\n+            _ => self.bug(\"not a lifetime\"),\n         }\n     }\n \n@@ -434,7 +434,7 @@ pub impl Parser {\n         });\n \n         fn parse_onceness(this: &Parser) -> Onceness {\n-            if this.eat_keyword(~\"once\") {\n+            if this.eat_keyword(\"once\") {\n                 Once\n             } else {\n                 Many\n@@ -1354,7 +1354,7 @@ pub impl Parser {\n                 self.bump();\n                 match *self.token {\n                     token::LPAREN | token::LBRACE => {}\n-                    _ => self.fatal(~\"expected open delimiter\")\n+                    _ => self.fatal(\"expected open delimiter\")\n                 };\n \n                 let ket = token::flip_delimiter(&*self.token);\n@@ -1520,7 +1520,7 @@ pub impl Parser {\n                 self.bump();\n                 (Some(sep), zerok)\n             } else {\n-                self.fatal(~\"expected `*` or `+`\");\n+                self.fatal(\"expected `*` or `+`\");\n             }\n         }\n     }\n@@ -1587,7 +1587,7 @@ pub impl Parser {\n \n         match *self.token {\n             token::EOF => {\n-                self.fatal(~\"file ended with unbalanced delimiters\");\n+                self.fatal(\"file ended with unbalanced delimiters\");\n             }\n             token::LPAREN | token::LBRACE | token::LBRACKET => {\n                 let close_delim = token::flip_delimiter(&*self.token);\n@@ -1602,7 +1602,7 @@ pub impl Parser {\n                                 |p| p.parse_token_tree()\n                             ),\n                             // the close delimiter:\n-                            ~[parse_any_tt_tok(self)]\n+                            [parse_any_tt_tok(self)]\n                         )\n                     )\n                 )\n@@ -1635,7 +1635,7 @@ pub impl Parser {\n                     token::flip_delimiter(self.token)\n                 )\n             }\n-            _ => self.fatal(~\"expected open delimiter\")\n+            _ => self.fatal(\"expected open delimiter\")\n         }\n     }\n \n@@ -1678,7 +1678,7 @@ pub impl Parser {\n                     token::RPAREN\n                 );\n                 if ms.len() == 0u {\n-                    self.fatal(~\"repetition body must be nonempty\");\n+                    self.fatal(\"repetition body must be nonempty\");\n                 }\n                 let (sep, zerok) = self.parse_sep_and_zerok();\n                 match_seq(ms, sep, zerok, name_idx_lo, *name_idx)\n@@ -1996,15 +1996,15 @@ pub impl Parser {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append(args, ~[last_arg]);\n+                let args = vec::append(args, [last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n             }\n             expr_method_call(f, i, /*bad*/ copy tps,\n                              /*bad*/ copy args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                let args = vec::append(args, ~[last_arg]);\n+                let args = vec::append(args, [last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi,\n                              expr_method_call(f, i, tps, args, sugar))\n             }\n@@ -2575,7 +2575,7 @@ pub impl Parser {\n             // XXX: Remove after snapshot.\n         }\n         if !is_plain_ident(&*self.token) {\n-            self.fatal(~\"expected ident\");\n+            self.fatal(\"expected ident\");\n         }\n         let name = self.parse_ident();\n         self.expect(&token::COLON);\n@@ -2597,7 +2597,7 @@ pub impl Parser {\n             // If we have attributes then we should have an item\n             if !current_attrs.is_empty() {\n                 p.span_err(*p.last_span,\n-                           ~\"expected item after attributes\");\n+                           \"expected item after attributes\");\n             }\n         }\n \n@@ -2664,7 +2664,7 @@ pub impl Parser {\n                                     \"view items must be declared at the top of the block\");\n                 }\n                 iovi_foreign_item(_) => {\n-                    self.fatal(~\"foreign items are not allowed here\");\n+                    self.fatal(\"foreign items are not allowed here\");\n                 }\n                 iovi_none() => { /* fallthrough */ }\n             }\n@@ -3528,7 +3528,7 @@ pub impl Parser {\n \n         if first && attrs_remaining_len > 0u {\n             // We parsed attributes for the first item but didn't find it\n-            self.span_err(*self.last_span,~\"expected item after attributes\");\n+            self.span_err(*self.last_span, \"expected item after attributes\");\n         }\n \n         ast::_mod { view_items: view_items, items: items }\n@@ -3583,7 +3583,7 @@ pub impl Parser {\n                 let (main_mod, new_mod) =\n                     match (main_mod_item, new_mod_item) {\n                     (item_mod(m), item_mod(n)) => (m, n),\n-                    _ => self.bug(~\"parsed mod item should be mod\")\n+                    _ => self.bug(\"parsed mod item should be mod\")\n                 };\n                 let merged_mod = ast::_mod {\n                     view_items: main_mod.view_items + new_mod.view_items,\n@@ -3600,7 +3600,7 @@ pub impl Parser {\n     fn push_mod_path(&self, id: ident, attrs: ~[ast::attribute]) {\n         let default_path = self.sess.interner.get(id);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n-            attrs, ~\"path\") {\n+            attrs, \"path\") {\n \n             Some(d) => copy *d,\n             None => copy *default_path\n@@ -3623,7 +3623,7 @@ pub impl Parser {\n         let mod_path = Path(\".\").push_many(*mod_path_stack);\n         let default_path = *self.sess.interner.get(id) + ~\".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n-            outer_attrs, ~\"path\") {\n+            outer_attrs, \"path\") {\n             Some(d) => {\n                 let path = Path(copy *d);\n                 if !path.is_absolute {\n@@ -3660,7 +3660,7 @@ pub impl Parser {\n         return (ast::item_mod(m0), mod_attrs);\n \n         fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n-            match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n+            match ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n                 Some(d) => copy *d,\n                 None => default\n             }\n@@ -3915,7 +3915,7 @@ pub impl Parser {\n         }\n         self.expect(&token::RBRACE);\n         if (have_disr && !all_nullary) {\n-            self.fatal(~\"discriminator values can only be used with a c-like \\\n+            self.fatal(\"discriminator values can only be used with a c-like \\\n                         enum\");\n         }\n \n@@ -4209,7 +4209,7 @@ pub impl Parser {\n                     || self.look_ahead(2) == token::LBRACE) {\n             // MACRO INVOCATION ITEM\n             if attrs.len() > 0 {\n-                self.fatal(~\"attrs on macros are not yet supported\");\n+                self.fatal(\"attrs on macros are not yet supported\");\n             }\n \n             // item macro.\n@@ -4235,7 +4235,7 @@ pub impl Parser {\n                         |p| p.parse_token_tree()\n                     )\n                 }\n-                _ => self.fatal(~\"expected open delimiter\")\n+                _ => self.fatal(\"expected open delimiter\")\n             };\n             // single-variant-enum... :\n             let m = ast::mac_invoc_tt(pth, tts);\n@@ -4262,9 +4262,9 @@ pub impl Parser {\n             iovi_none =>\n                 None,\n             iovi_view_item(_) =>\n-                self.fatal(~\"view items are not allowed here\"),\n+                self.fatal(\"view items are not allowed here\"),\n             iovi_foreign_item(_) =>\n-                self.fatal(~\"foreign items are not allowed here\"),\n+                self.fatal(\"foreign items are not allowed here\"),\n             iovi_item(item) =>\n                 Some(item)\n         }\n@@ -4404,7 +4404,7 @@ pub impl Parser {\n             let metadata = self.parse_optional_meta();\n             view_item_extern_mod(ident, metadata, self.get_id())\n         } else {\n-            self.bug(~\"expected view item\");\n+            self.bug(\"expected view item\");\n         };\n         self.expect(&token::SEMI);\n         @ast::view_item { node: node,\n@@ -4551,7 +4551,7 @@ pub impl Parser {\n                 self.bump();\n                 self.id_to_str(s)\n             }\n-            _ =>  self.fatal(~\"expected string literal\")\n+            _ =>  self.fatal(\"expected string literal\")\n         }\n     }\n }"}, {"sha": "055336a6d95325347f4fe40a17765b47890df27b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -173,14 +173,14 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n       LIT_INT_UNSUFFIXED(i) => { i.to_str() }\n       LIT_FLOAT(s, t) => {\n         let mut body = copy *in.get(s);\n-        if body.ends_with(~\".\") {\n+        if body.ends_with(\".\") {\n             body = body + ~\"0\";  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n       LIT_FLOAT_UNSUFFIXED(s) => {\n         let mut body = copy *in.get(s);\n-        if body.ends_with(~\".\") {\n+        if body.ends_with(\".\") {\n             body = body + ~\"0\";  // `10.f` is not a float literal\n         }\n         body"}, {"sha": "6b2ee61545e6da80d273f3c24480cd00ab0fa5a7", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -437,7 +437,7 @@ pub impl Printer {\n     }\n     fn print_newline(&mut self, amount: int) {\n         debug!(\"NEWLINE %d\", amount);\n-        (*self.out).write_str(~\"\\n\");\n+        (*self.out).write_str(\"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n     }"}, {"sha": "a535e5d195f2a75fc69c8249e26ba5e4b1708c25", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 211, "deletions": 211, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -227,17 +227,17 @@ pub fn box(s: @ps, u: uint, b: pp::breaks) {\n     pp::box(s.s, u, b);\n }\n \n-pub fn nbsp(s: @ps) { word(s.s, ~\" \"); }\n+pub fn nbsp(s: @ps) { word(s.s, \" \"); }\n \n pub fn word_nbsp(s: @ps, w: &str) { word(s.s, w); nbsp(s); }\n \n pub fn word_space(s: @ps, w: &str) { word(s.s, w); space(s.s); }\n \n-pub fn popen(s: @ps) { word(s.s, ~\"(\"); }\n+pub fn popen(s: @ps) { word(s.s, \"(\"); }\n \n-pub fn pclose(s: @ps) { word(s.s, ~\")\"); }\n+pub fn pclose(s: @ps) { word(s.s, \")\"); }\n \n-pub fn head(s: @ps, w: ~str) {\n+pub fn head(s: @ps, w: &str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n@@ -249,7 +249,7 @@ pub fn head(s: @ps, w: ~str) {\n }\n \n pub fn bopen(s: @ps) {\n-    word(s.s, ~\"{\");\n+    word(s.s, \"{\");\n     end(s); // close the head-box\n }\n \n@@ -260,7 +260,7 @@ pub fn bclose_maybe_open (s: @ps, span: codemap::span, indented: uint,\n                           close_box: bool) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n-    word(s.s, ~\"}\");\n+    word(s.s, \"}\");\n     if close_box {\n         end(s); // close the outer-box\n     }\n@@ -304,18 +304,18 @@ pub fn break_offset_if_not_bol(s: @ps, n: uint, off: int) {\n // Synthesizes a comment that was not textually present in the original source\n // file.\n pub fn synth_comment(s: @ps, text: ~str) {\n-    word(s.s, ~\"/*\");\n+    word(s.s, \"/*\");\n     space(s.s);\n     word(s.s, text);\n     space(s.s);\n-    word(s.s, ~\"*/\");\n+    word(s.s, \"*/\");\n }\n \n pub fn commasep<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN)) {\n     box(s, 0u, b);\n     let mut first = true;\n     for elts.each |elt| {\n-        if first { first = false; } else { word_space(s, ~\",\"); }\n+        if first { first = false; } else { word_space(s, \",\"); }\n         op(s, *elt);\n     }\n     end(s);\n@@ -332,7 +332,7 @@ pub fn commasep_cmnt<IN: Copy>(s: @ps, b: breaks, elts: &[IN], op: &fn(@ps, IN),\n         op(s, *elt);\n         i += 1u;\n         if i < len {\n-            word(s.s, ~\",\");\n+            word(s.s, \",\");\n             maybe_print_trailing_comment(s, get_span(*elt),\n                                          Some(get_span(elts[i]).hi));\n             space_if_not_bol(s);\n@@ -374,31 +374,31 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     match ty.node {\n-      ast::ty_nil => word(s.s, ~\"()\"),\n-      ast::ty_bot => word(s.s, ~\"!\"),\n-      ast::ty_box(ref mt) => { word(s.s, ~\"@\"); print_mt(s, mt); }\n-      ast::ty_uniq(ref mt) => { word(s.s, ~\"~\"); print_mt(s, mt); }\n+      ast::ty_nil => word(s.s, \"()\"),\n+      ast::ty_bot => word(s.s, \"!\"),\n+      ast::ty_box(ref mt) => { word(s.s, \"@\"); print_mt(s, mt); }\n+      ast::ty_uniq(ref mt) => { word(s.s, \"~\"); print_mt(s, mt); }\n       ast::ty_vec(ref mt) => {\n-        word(s.s, ~\"[\");\n+        word(s.s, \"[\");\n         match mt.mutbl {\n-          ast::m_mutbl => word_space(s, ~\"mut\"),\n-          ast::m_const => word_space(s, ~\"const\"),\n+          ast::m_mutbl => word_space(s, \"mut\"),\n+          ast::m_const => word_space(s, \"const\"),\n           ast::m_imm => ()\n         }\n         print_type(s, mt.ty);\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n       }\n-      ast::ty_ptr(ref mt) => { word(s.s, ~\"*\"); print_mt(s, mt); }\n+      ast::ty_ptr(ref mt) => { word(s.s, \"*\"); print_mt(s, mt); }\n       ast::ty_rptr(lifetime, ref mt) => {\n-          word(s.s, ~\"&\");\n+          word(s.s, \"&\");\n           print_opt_lifetime(s, lifetime);\n           print_mt(s, mt);\n       }\n       ast::ty_tup(ref elts) => {\n         popen(s);\n         commasep(s, inconsistent, *elts, print_type);\n         if elts.len() == 1 {\n-            word(s.s, ~\",\");\n+            word(s.s, \",\");\n         }\n         pclose(s);\n       }\n@@ -418,16 +418,16 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n       }\n       ast::ty_path(path, _) => print_path(s, path, false),\n       ast::ty_fixed_length_vec(ref mt, v) => {\n-        word(s.s, ~\"[\");\n+        word(s.s, \"[\");\n         match mt.mutbl {\n-            ast::m_mutbl => word_space(s, ~\"mut\"),\n-            ast::m_const => word_space(s, ~\"const\"),\n+            ast::m_mutbl => word_space(s, \"mut\"),\n+            ast::m_const => word_space(s, \"const\"),\n             ast::m_imm => ()\n         }\n         print_type(s, mt.ty);\n-        word(s.s, ~\", ..\");\n+        word(s.s, \", ..\");\n         print_expr(s, v);\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n       }\n       ast::ty_mac(_) => {\n           fail!(\"print_type doesn't know how to print a ty_mac\");\n@@ -449,15 +449,15 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n         print_fn(s, decl, Some(purity), AbiSet::Rust(), item.ident, generics, None,\n                  ast::inherited);\n         end(s); // end head-ibox\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n         end(s); // end the outer fn box\n       }\n       ast::foreign_item_const(t) => {\n-        head(s, ~\"static\");\n+        head(s, \"static\");\n         print_ident(s, item.ident);\n-        word_space(s, ~\":\");\n+        word_space(s, \":\");\n         print_type(s, t);\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n         end(s); // end the head-ibox\n         end(s); // end the outer cbox\n       }\n@@ -474,14 +474,14 @@ pub fn print_item(s: @ps, item: @ast::item) {\n       ast::item_const(ty, expr) => {\n         head(s, visibility_qualified(item.vis, ~\"static\"));\n         print_ident(s, item.ident);\n-        word_space(s, ~\":\");\n+        word_space(s, \":\");\n         print_type(s, ty);\n         space(s.s);\n         end(s); // end the head-ibox\n \n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_expr(s, expr);\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n         end(s); // end the outer cbox\n \n       }\n@@ -496,7 +496,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n             None,\n             item.vis\n         );\n-        word(s.s, ~\" \");\n+        word(s.s, \" \");\n         print_block_with_attrs(s, body, item.attrs);\n       }\n       ast::item_mod(ref _mod) => {\n@@ -512,7 +512,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         word_nbsp(s, nmod.abis.to_str());\n         match nmod.sort {\n             ast::named => {\n-                word_nbsp(s, ~\"mod\");\n+                word_nbsp(s, \"mod\");\n                 print_ident(s, item.ident);\n                 nbsp(s);\n             }\n@@ -531,9 +531,9 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         end(s); // end the inner ibox\n \n         space(s.s);\n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_type(s, ty);\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n         end(s); // end the outer ibox\n       }\n       ast::item_enum(ref enum_definition, ref params) => {\n@@ -562,7 +562,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n             Some(t) => {\n                 print_trait_ref(s, t);\n                 space(s.s);\n-                word_space(s, ~\"for\");\n+                word_space(s, \"for\");\n             }\n             None => ()\n         };\n@@ -571,7 +571,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         space(s.s);\n \n         if methods.len() == 0 {\n-            word(s.s, ~\";\");\n+            word(s.s, \";\");\n         } else {\n             bopen(s);\n             for methods.each |meth| {\n@@ -585,16 +585,16 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         print_ident(s, item.ident);\n         print_generics(s, generics);\n         if traits.len() != 0u {\n-            word(s.s, ~\":\");\n+            word(s.s, \":\");\n             for traits.eachi |i, trait_| {\n                 nbsp(s);\n                 if i != 0 {\n-                    word_space(s, ~\"+\");\n+                    word_space(s, \"+\");\n                 }\n                 print_path(s, trait_.path, false);\n             }\n         }\n-        word(s.s, ~\" \");\n+        word(s.s, \" \");\n         bopen(s);\n         for methods.each |meth| {\n             print_trait_method(s, meth);\n@@ -605,7 +605,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n                                    _}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n-        word(s.s, ~\"! \");\n+        word(s.s, \"! \");\n         print_ident(s, item.ident);\n         cbox(s, indent_unit);\n         popen(s);\n@@ -641,7 +641,7 @@ pub fn print_variants(s: @ps,\n         print_outer_attributes(s, v.node.attrs);\n         ibox(s, indent_unit);\n         print_variant(s, v);\n-        word(s.s, ~\",\");\n+        word(s.s, \",\");\n         end(s);\n         maybe_print_trailing_comment(s, v.span, None);\n     }\n@@ -692,7 +692,7 @@ pub fn print_struct(s: @ps,\n             }\n             pclose(s);\n         }\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n         end(s);\n         end(s); // close the outer-box\n     } else {\n@@ -709,9 +709,9 @@ pub fn print_struct(s: @ps,\n                     print_outer_attributes(s, field.node.attrs);\n                     print_visibility(s, visibility);\n                     print_ident(s, ident);\n-                    word_nbsp(s, ~\":\");\n+                    word_nbsp(s, \":\");\n                     print_type(s, field.node.ty);\n-                    word(s.s, ~\",\");\n+                    word(s.s, \",\");\n                 }\n             }\n         }\n@@ -734,17 +734,17 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n           word(s.s, parse::token::to_str(s.intr, tk));\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n-        word(s.s, ~\"$(\");\n+        word(s.s, \"$(\");\n         for (*tts).each() |tt_elt| { print_tt(s, tt_elt); }\n-        word(s.s, ~\")\");\n+        word(s.s, \")\");\n         match (*sep) {\n           Some(ref tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n           None => ()\n         }\n-        word(s.s, if zerok { ~\"*\" } else { ~\"+\" });\n+        word(s.s, if zerok { \"*\" } else { \"+\" });\n       }\n       ast::tt_nonterminal(_, name) => {\n-        word(s.s, ~\"$\");\n+        word(s.s, \"$\");\n         print_ident(s, name);\n       }\n     }\n@@ -776,15 +776,15 @@ pub fn print_variant(s: @ps, v: &ast::variant) {\n             }\n         }\n         ast::struct_variant_kind(struct_def) => {\n-            head(s, ~\"\");\n+            head(s, \"\");\n             let generics = ast_util::empty_generics();\n             print_struct(s, struct_def, &generics, v.node.name, v.span);\n         }\n     }\n     match v.node.disr_expr {\n       Some(d) => {\n         space(s.s);\n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_expr(s, d);\n       }\n       _ => ()\n@@ -798,7 +798,7 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     print_ty_fn(s, None, None, None, m.purity, ast::Many,\n                 &m.decl, Some(m.ident), Some(&m.generics),\n                 Some(/*bad*/ copy m.explicit_self.node));\n-    word(s.s, ~\";\");\n+    word(s.s, \";\");\n }\n \n pub fn print_trait_method(s: @ps, m: &ast::trait_method) {\n@@ -815,7 +815,7 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n     print_fn(s, &meth.decl, Some(meth.purity), AbiSet::Rust(),\n              meth.ident, &meth.generics, Some(meth.explicit_self.node),\n              meth.vis);\n-    word(s.s, ~\" \");\n+    word(s.s, \" \");\n     print_block_with_attrs(s, &meth.body, meth.attrs);\n }\n \n@@ -837,7 +837,7 @@ pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n           ast::attr_inner => {\n             print_attribute(s, *attr);\n             if !attr.node.is_sugared_doc {\n-                word(s.s, ~\";\");\n+                word(s.s, \";\");\n             }\n             count += 1;\n           }\n@@ -855,9 +855,9 @@ pub fn print_attribute(s: @ps, attr: ast::attribute) {\n         let comment = attr::get_meta_item_value_str(meta).get();\n         word(s.s, *comment);\n     } else {\n-        word(s.s, ~\"#[\");\n+        word(s.s, \"#[\");\n         print_meta_item(s, attr.node.value);\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n     }\n }\n \n@@ -875,15 +875,15 @@ pub fn print_stmt(s: @ps, st: &ast::stmt) {\n       ast::stmt_semi(expr, _) => {\n         space_if_not_bol(s);\n         print_expr(s, expr);\n-        word(s.s, ~\";\");\n+        word(s.s, \";\");\n       }\n       ast::stmt_mac(ref mac, semi) => {\n         space_if_not_bol(s);\n         print_mac(s, mac);\n-        if semi { word(s.s, ~\";\"); }\n+        if semi { word(s.s, \";\"); }\n       }\n     }\n-    if parse::classify::stmt_ends_with_semi(st) { word(s.s, ~\";\"); }\n+    if parse::classify::stmt_ends_with_semi(st) { word(s.s, \";\"); }\n     maybe_print_trailing_comment(s, st.span, None);\n }\n \n@@ -925,7 +925,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n                                       attrs: &[ast::attribute],\n                                       close_box: bool) {\n     match blk.node.rules {\n-      ast::unsafe_blk => word_space(s, ~\"unsafe\"),\n+      ast::unsafe_blk => word_space(s, \"unsafe\"),\n       ast::default_blk => ()\n     }\n     maybe_print_comment(s, blk.span.lo);\n@@ -956,8 +956,8 @@ pub fn print_possibly_embedded_block_(s: @ps,\n \n pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n                 elseopt: Option<@ast::expr>, chk: bool) {\n-    head(s, ~\"if\");\n-    if chk { word_nbsp(s, ~\"check\"); }\n+    head(s, \"if\");\n+    if chk { word_nbsp(s, \"check\"); }\n     print_expr(s, test);\n     space(s.s);\n     print_block(s, blk);\n@@ -969,7 +969,7 @@ pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n               ast::expr_if(i, ref t, e) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, ~\" else if \");\n+                word(s.s, \" else if \");\n                 print_expr(s, i);\n                 space(s.s);\n                 print_block(s, t);\n@@ -979,7 +979,7 @@ pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n               ast::expr_block(ref b) => {\n                 cbox(s, indent_unit - 1u);\n                 ibox(s, 0u);\n-                word(s.s, ~\" else \");\n+                word(s.s, \" else \");\n                 print_block(s, b);\n               }\n               // BLEAH, constraints would be great here\n@@ -998,7 +998,7 @@ pub fn print_mac(s: @ps, m: &ast::mac) {\n     match m.node {\n       ast::mac_invoc_tt(pth, ref tts) => {\n         print_path(s, pth, false);\n-        word(s.s, ~\"!\");\n+        word(s.s, \"!\");\n         popen(s);\n         print_tts(s, *tts);\n         pclose(s);\n@@ -1009,28 +1009,28 @@ pub fn print_mac(s: @ps, m: &ast::mac) {\n pub fn print_vstore(s: @ps, t: ast::vstore) {\n     match t {\n         ast::vstore_fixed(Some(i)) => word(s.s, fmt!(\"%u\", i)),\n-        ast::vstore_fixed(None) => word(s.s, ~\"_\"),\n-        ast::vstore_uniq => word(s.s, ~\"~\"),\n-        ast::vstore_box => word(s.s, ~\"@\"),\n+        ast::vstore_fixed(None) => word(s.s, \"_\"),\n+        ast::vstore_uniq => word(s.s, \"~\"),\n+        ast::vstore_box => word(s.s, \"@\"),\n         ast::vstore_slice(r) => {\n-            word(s.s, ~\"&\");\n+            word(s.s, \"&\");\n             print_opt_lifetime(s, r);\n         }\n     }\n }\n \n pub fn print_expr_vstore(s: @ps, t: ast::expr_vstore) {\n     match t {\n-      ast::expr_vstore_uniq => word(s.s, ~\"~\"),\n-      ast::expr_vstore_box => word(s.s, ~\"@\"),\n+      ast::expr_vstore_uniq => word(s.s, \"~\"),\n+      ast::expr_vstore_box => word(s.s, \"@\"),\n       ast::expr_vstore_mut_box => {\n-        word(s.s, ~\"@\");\n-        word(s.s, ~\"mut\");\n+        word(s.s, \"@\");\n+        word(s.s, \"mut\");\n       }\n-      ast::expr_vstore_slice => word(s.s, ~\"&\"),\n+      ast::expr_vstore_slice => word(s.s, \"&\"),\n       ast::expr_vstore_mut_slice => {\n-        word(s.s, ~\"&\");\n-        word(s.s, ~\"mut\");\n+        word(s.s, \"&\");\n+        word(s.s, \"mut\");\n       }\n     }\n }\n@@ -1041,11 +1041,11 @@ pub fn print_call_pre(s: @ps,\n                    -> Option<@ast::expr> {\n     match sugar {\n         ast::DoSugar => {\n-            head(s, ~\"do\");\n+            head(s, \"do\");\n             Some(base_args.pop())\n         }\n         ast::ForSugar => {\n-            head(s, ~\"for\");\n+            head(s, \"for\");\n             Some(base_args.pop())\n         }\n         ast::NoSugar => None\n@@ -1082,9 +1082,9 @@ pub fn print_call_post(s: @ps,\n pub fn print_expr(s: @ps, expr: @ast::expr) {\n     fn print_field(s: @ps, field: ast::field) {\n         ibox(s, indent_unit);\n-        if field.node.mutbl == ast::m_mutbl { word_nbsp(s, ~\"mut\"); }\n+        if field.node.mutbl == ast::m_mutbl { word_nbsp(s, \"mut\"); }\n         print_ident(s, field.node.ident);\n-        word_space(s, ~\":\");\n+        word_space(s, \":\");\n         print_expr(s, field.node.expr);\n         end(s);\n     }\n@@ -1101,53 +1101,53 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         },\n       ast::expr_vec(ref exprs, mutbl) => {\n         ibox(s, indent_unit);\n-        word(s.s, ~\"[\");\n+        word(s.s, \"[\");\n         if mutbl == ast::m_mutbl {\n-            word(s.s, ~\"mut\");\n+            word(s.s, \"mut\");\n             if exprs.len() > 0u { nbsp(s); }\n         }\n         commasep_exprs(s, inconsistent, *exprs);\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n         end(s);\n       }\n \n       ast::expr_repeat(element, count, mutbl) => {\n         ibox(s, indent_unit);\n-        word(s.s, ~\"[\");\n+        word(s.s, \"[\");\n         if mutbl == ast::m_mutbl {\n-            word(s.s, ~\"mut\");\n+            word(s.s, \"mut\");\n             nbsp(s);\n         }\n         print_expr(s, element);\n-        word(s.s, ~\",\");\n-        word(s.s, ~\"..\");\n+        word(s.s, \",\");\n+        word(s.s, \"..\");\n         print_expr(s, count);\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n         end(s);\n       }\n \n       ast::expr_struct(path, ref fields, wth) => {\n         print_path(s, path, true);\n-        word(s.s, ~\"{\");\n+        word(s.s, \"{\");\n         commasep_cmnt(s, consistent, (*fields), print_field, get_span);\n         match wth {\n             Some(expr) => {\n                 ibox(s, indent_unit);\n-                word(s.s, ~\",\");\n+                word(s.s, \",\");\n                 space(s.s);\n-                word(s.s, ~\"..\");\n+                word(s.s, \"..\");\n                 print_expr(s, expr);\n                 end(s);\n             }\n-            _ => (word(s.s, ~\",\"))\n+            _ => (word(s.s, \",\"))\n         }\n-        word(s.s, ~\"}\");\n+        word(s.s, \"}\");\n       }\n       ast::expr_tup(ref exprs) => {\n         popen(s);\n         commasep_exprs(s, inconsistent, *exprs);\n         if exprs.len() == 1 {\n-            word(s.s, ~\",\");\n+            word(s.s, \",\");\n         }\n         pclose(s);\n       }\n@@ -1161,12 +1161,12 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         let mut base_args = copy *args;\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n-        word(s.s, ~\".\");\n+        word(s.s, \".\");\n         print_ident(s, ident);\n         if tys.len() > 0u {\n-            word(s.s, ~\"::<\");\n+            word(s.s, \"::<\");\n             commasep(s, inconsistent, *tys, print_type);\n-            word(s.s, ~\">\");\n+            word(s.s, \">\");\n         }\n         print_call_post(s, sugar, &blk, &mut base_args);\n       }\n@@ -1181,7 +1181,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_expr(s, expr);\n       }\n       ast::expr_addr_of(m, expr) => {\n-        word(s.s, ~\"&\");\n+        word(s.s, \"&\");\n         print_mutability(s, m);\n         // Avoid `& &e` => `&&e`.\n         match (m, &expr.node) {\n@@ -1194,32 +1194,32 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n       ast::expr_cast(expr, ty) => {\n         print_expr(s, expr);\n         space(s.s);\n-        word_space(s, ~\"as\");\n+        word_space(s, \"as\");\n         print_type(s, ty);\n       }\n       ast::expr_if(test, ref blk, elseopt) => {\n         print_if(s, test, blk, elseopt, false);\n       }\n       ast::expr_while(test, ref blk) => {\n-        head(s, ~\"while\");\n+        head(s, \"while\");\n         print_expr(s, test);\n         space(s.s);\n         print_block(s, blk);\n       }\n       ast::expr_loop(ref blk, opt_ident) => {\n         for opt_ident.each |ident| {\n-            word(s.s, ~\"'\");\n+            word(s.s, \"'\");\n             print_ident(s, *ident);\n-            word_space(s, ~\":\");\n+            word_space(s, \":\");\n         }\n-        head(s, ~\"loop\");\n+        head(s, \"loop\");\n         space(s.s);\n         print_block(s, blk);\n       }\n       ast::expr_match(expr, ref arms) => {\n         cbox(s, indent_unit);\n         ibox(s, 4);\n-        word_nbsp(s, ~\"match\");\n+        word_nbsp(s, \"match\");\n         print_expr(s, expr);\n         space(s.s);\n         bopen(s);\n@@ -1232,19 +1232,19 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n             for arm.pats.each |p| {\n                 if first {\n                     first = false;\n-                } else { space(s.s); word_space(s, ~\"|\"); }\n+                } else { space(s.s); word_space(s, \"|\"); }\n                 print_refutable_pat(s, *p);\n             }\n             space(s.s);\n             match arm.guard {\n               Some(e) => {\n-                word_space(s, ~\"if\");\n+                word_space(s, \"if\");\n                 print_expr(s, e);\n                 space(s.s);\n               }\n               None => ()\n             }\n-            word_space(s, ~\"=>\");\n+            word_space(s, \"=>\");\n \n             // Extract the expression from the extra block the parser adds\n             // in the case of foo => expr\n@@ -1268,7 +1268,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n                         }\n                         if !expr_is_simple_block(expr)\n                             && i < len - 1 {\n-                            word(s.s, ~\",\");\n+                            word(s.s, \",\");\n                         }\n                         end(s); // close enclosing cbox\n                     }\n@@ -1321,97 +1321,97 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         ibox(s, 0u);\n         print_block(s, blk);\n       }\n-      ast::expr_copy(e) => { word_space(s, ~\"copy\"); print_expr(s, e); }\n+      ast::expr_copy(e) => { word_space(s, \"copy\"); print_expr(s, e); }\n       ast::expr_assign(lhs, rhs) => {\n         print_expr(s, lhs);\n         space(s.s);\n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n       ast::expr_assign_op(op, lhs, rhs) => {\n         print_expr(s, lhs);\n         space(s.s);\n         word(s.s, ast_util::binop_to_str(op));\n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n       ast::expr_field(expr, id, ref tys) => {\n         print_expr(s, expr);\n-        word(s.s, ~\".\");\n+        word(s.s, \".\");\n         print_ident(s, id);\n         if tys.len() > 0u {\n-            word(s.s, ~\"::<\");\n+            word(s.s, \"::<\");\n             commasep(s, inconsistent, *tys, print_type);\n-            word(s.s, ~\">\");\n+            word(s.s, \">\");\n         }\n       }\n       ast::expr_index(expr, index) => {\n         print_expr(s, expr);\n-        word(s.s, ~\"[\");\n+        word(s.s, \"[\");\n         print_expr(s, index);\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n       }\n       ast::expr_path(path) => print_path(s, path, true),\n-      ast::expr_self => word(s.s, ~\"self\"),\n+      ast::expr_self => word(s.s, \"self\"),\n       ast::expr_break(opt_ident) => {\n-        word(s.s, ~\"break\");\n+        word(s.s, \"break\");\n         space(s.s);\n         for opt_ident.each |ident| {\n-            word(s.s, ~\"'\");\n+            word(s.s, \"'\");\n             print_ident(s, *ident);\n             space(s.s);\n         }\n       }\n       ast::expr_again(opt_ident) => {\n-        word(s.s, ~\"loop\");\n+        word(s.s, \"loop\");\n         space(s.s);\n         for opt_ident.each |ident| {\n-            word(s.s, ~\"'\");\n+            word(s.s, \"'\");\n             print_ident(s, *ident);\n             space(s.s)\n         }\n       }\n       ast::expr_ret(result) => {\n-        word(s.s, ~\"return\");\n+        word(s.s, \"return\");\n         match result {\n-          Some(expr) => { word(s.s, ~\" \"); print_expr(s, expr); }\n+          Some(expr) => { word(s.s, \" \"); print_expr(s, expr); }\n           _ => ()\n         }\n       }\n       ast::expr_log(lexp, expr) => {\n-        word(s.s, ~\"__log\");\n+        word(s.s, \"__log\");\n         popen(s);\n         print_expr(s, lexp);\n-        word(s.s, ~\",\");\n+        word(s.s, \",\");\n         space_if_not_bol(s);\n         print_expr(s, expr);\n         pclose(s);\n       }\n       ast::expr_inline_asm(ref a) => {\n         if a.volatile {\n-            word(s.s, ~\"__volatile__ asm!\");\n+            word(s.s, \"__volatile__ asm!\");\n         } else {\n-            word(s.s, ~\"asm!\");\n+            word(s.s, \"asm!\");\n         }\n         popen(s);\n         print_string(s, *a.asm);\n-        word_space(s, ~\":\");\n+        word_space(s, \":\");\n         for a.outputs.each |&(co, o)| {\n             print_string(s, *co);\n             popen(s);\n             print_expr(s, o);\n             pclose(s);\n-            word_space(s, ~\",\");\n+            word_space(s, \",\");\n         }\n-        word_space(s, ~\":\");\n+        word_space(s, \":\");\n         for a.inputs.each |&(co, o)| {\n             print_string(s, *co);\n             popen(s);\n             print_expr(s, o);\n             pclose(s);\n-            word_space(s, ~\",\");\n+            word_space(s, \",\");\n         }\n-        word_space(s, ~\":\");\n+        word_space(s, \":\");\n         print_string(s, *a.clobbers);\n         pclose(s);\n       }\n@@ -1430,7 +1430,7 @@ pub fn print_local_decl(s: @ps, loc: @ast::local) {\n     print_irrefutable_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n       ast::ty_infer => (),\n-      _ => { word_space(s, ~\":\"); print_type(s, loc.node.ty); }\n+      _ => { word_space(s, \":\"); print_type(s, loc.node.ty); }\n     }\n }\n \n@@ -1440,12 +1440,12 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n       ast::decl_local(ref locs) => {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n-        word_nbsp(s, ~\"let\");\n+        word_nbsp(s, \"let\");\n \n         // if any are mut, all are mut\n         if locs.any(|l| l.node.is_mutbl) {\n             assert!(locs.all(|l| l.node.is_mutbl));\n-            word_nbsp(s, ~\"mut\");\n+            word_nbsp(s, \"mut\");\n         }\n \n         fn print_local(s: @ps, loc: @ast::local) {\n@@ -1455,7 +1455,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n             match loc.node.init {\n               Some(init) => {\n                 nbsp(s);\n-                word_space(s, ~\"=\");\n+                word_space(s, \"=\");\n                 print_expr(s, init);\n               }\n               _ => ()\n@@ -1475,34 +1475,34 @@ pub fn print_ident(s: @ps, ident: ast::ident) {\n pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n     print_local_decl(s, loc);\n     space(s.s);\n-    word_space(s, ~\"in\");\n+    word_space(s, \"in\");\n     print_expr(s, coll);\n }\n \n pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n-    if path.global { word(s.s, ~\"::\"); }\n+    if path.global { word(s.s, \"::\"); }\n     let mut first = true;\n     for path.idents.each |id| {\n-        if first { first = false; } else { word(s.s, ~\"::\"); }\n+        if first { first = false; } else { word(s.s, \"::\"); }\n         print_ident(s, *id);\n     }\n     if path.rp.is_some() || !path.types.is_empty() {\n-        if colons_before_params { word(s.s, ~\"::\"); }\n+        if colons_before_params { word(s.s, \"::\"); }\n \n         if path.rp.is_some() || !path.types.is_empty() {\n-            word(s.s, ~\"<\");\n+            word(s.s, \"<\");\n \n             for path.rp.each |r| {\n                 print_lifetime(s, *r);\n                 if !path.types.is_empty() {\n-                    word_space(s, ~\",\");\n+                    word_space(s, \",\");\n                 }\n             }\n \n             commasep(s, inconsistent, path.types, print_type);\n \n-            word(s.s, ~\">\");\n+            word(s.s, \">\");\n         }\n     }\n }\n@@ -1522,24 +1522,24 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     match pat.node {\n-      ast::pat_wild => word(s.s, ~\"_\"),\n+      ast::pat_wild => word(s.s, \"_\"),\n       ast::pat_ident(binding_mode, path, sub) => {\n           if refutable {\n               match binding_mode {\n                   ast::bind_by_ref(mutbl) => {\n-                      word_nbsp(s, ~\"ref\");\n+                      word_nbsp(s, \"ref\");\n                       print_mutability(s, mutbl);\n                   }\n                   ast::bind_by_copy => {\n-                      word_nbsp(s, ~\"copy\");\n+                      word_nbsp(s, \"copy\");\n                   }\n                   ast::bind_infer => {}\n               }\n           }\n           print_path(s, path, true);\n           match sub {\n               Some(p) => {\n-                  word(s.s, ~\"@\");\n+                  word(s.s, \"@\");\n                   print_pat(s, p, refutable);\n               }\n               None => ()\n@@ -1548,7 +1548,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n       ast::pat_enum(path, ref args_) => {\n         print_path(s, path, true);\n         match *args_ {\n-          None => word(s.s, ~\"(*)\"),\n+          None => word(s.s, \"(*)\"),\n           Some(ref args) => {\n             if !args.is_empty() {\n               popen(s);\n@@ -1561,11 +1561,11 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n       }\n       ast::pat_struct(path, ref fields, etc) => {\n         print_path(s, path, true);\n-        word(s.s, ~\"{\");\n+        word(s.s, \"{\");\n         fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n             cbox(s, indent_unit);\n             print_ident(s, f.ident);\n-            word_space(s, ~\":\");\n+            word_space(s, \":\");\n             print_pat(s, f.pat, refutable);\n             end(s);\n         }\n@@ -1574,53 +1574,53 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n                       |s, f| print_field(s,f,refutable),\n                       get_span);\n         if etc {\n-            if fields.len() != 0u { word_space(s, ~\",\"); }\n-            word(s.s, ~\"_\");\n+            if fields.len() != 0u { word_space(s, \",\"); }\n+            word(s.s, \"_\");\n         }\n-        word(s.s, ~\"}\");\n+        word(s.s, \"}\");\n       }\n       ast::pat_tup(ref elts) => {\n         popen(s);\n         commasep(s, inconsistent, *elts, |s, p| print_pat(s, p, refutable));\n         if elts.len() == 1 {\n-            word(s.s, ~\",\");\n+            word(s.s, \",\");\n         }\n         pclose(s);\n       }\n       ast::pat_box(inner) => {\n-          word(s.s, ~\"@\");\n+          word(s.s, \"@\");\n           print_pat(s, inner, refutable);\n       }\n       ast::pat_uniq(inner) => {\n-          word(s.s, ~\"~\");\n+          word(s.s, \"~\");\n           print_pat(s, inner, refutable);\n       }\n       ast::pat_region(inner) => {\n-          word(s.s, ~\"&\");\n+          word(s.s, \"&\");\n           print_pat(s, inner, refutable);\n       }\n       ast::pat_lit(e) => print_expr(s, e),\n       ast::pat_range(begin, end) => {\n         print_expr(s, begin);\n         space(s.s);\n-        word(s.s, ~\"..\");\n+        word(s.s, \"..\");\n         print_expr(s, end);\n       }\n       ast::pat_vec(ref before, slice, ref after) => {\n-        word(s.s, ~\"[\");\n+        word(s.s, \"[\");\n         do commasep(s, inconsistent, *before) |s, p| {\n             print_pat(s, p, refutable);\n         }\n         for slice.each |&p| {\n-            if !before.is_empty() { word_space(s, ~\",\"); }\n-            word(s.s, ~\"..\");\n+            if !before.is_empty() { word_space(s, \",\"); }\n+            word(s.s, \"..\");\n             print_pat(s, p, refutable);\n-            if !after.is_empty() { word_space(s, ~\",\"); }\n+            if !after.is_empty() { word_space(s, \",\"); }\n         }\n         do commasep(s, inconsistent, *after) |s, p| {\n             print_pat(s, p, refutable);\n         }\n-        word(s.s, ~\"]\");\n+        word(s.s, \"]\");\n       }\n     }\n     (s.ann.post)(ann_node);\n@@ -1634,18 +1634,18 @@ pub fn explicit_self_to_str(explicit_self: ast::explicit_self_, intr: @ident_int\n pub fn print_explicit_self(s: @ps, explicit_self: ast::explicit_self_) -> bool {\n     match explicit_self {\n         ast::sty_static => { return false; }\n-        ast::sty_value => { word(s.s, ~\"self\"); }\n+        ast::sty_value => { word(s.s, \"self\"); }\n         ast::sty_region(lt, m) => {\n-            word(s.s, ~\"&\");\n+            word(s.s, \"&\");\n             print_opt_lifetime(s, lt);\n             print_mutability(s, m);\n-            word(s.s, ~\"self\");\n+            word(s.s, \"self\");\n         }\n         ast::sty_box(m) => {\n-            word(s.s, ~\"@\"); print_mutability(s, m); word(s.s, ~\"self\");\n+            word(s.s, \"@\"); print_mutability(s, m); word(s.s, \"self\");\n         }\n         ast::sty_uniq(m) => {\n-            word(s.s, ~\"~\"); print_mutability(s, m); word(s.s, ~\"self\");\n+            word(s.s, \"~\"); print_mutability(s, m); word(s.s, \"self\");\n         }\n     }\n     return true;\n@@ -1659,7 +1659,7 @@ pub fn print_fn(s: @ps,\n                 generics: &ast::Generics,\n                 opt_explicit_self: Option<ast::explicit_self_>,\n                 vis: ast::visibility) {\n-    head(s, ~\"\");\n+    head(s, \"\");\n     print_fn_header_info(s, opt_explicit_self, purity, abis, ast::Many, None, vis);\n     nbsp(s);\n     print_ident(s, name);\n@@ -1678,7 +1678,7 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n     }\n \n     for decl.inputs.each |arg| {\n-        if first { first = false; } else { word_space(s, ~\",\"); }\n+        if first { first = false; } else { word_space(s, \",\"); }\n         print_arg(s, *arg);\n     }\n \n@@ -1696,22 +1696,22 @@ pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n         ast::ty_nil => {}\n         _ => {\n             space_if_not_bol(s);\n-            word_space(s, ~\"->\");\n+            word_space(s, \"->\");\n             print_type(s, decl.output);\n         }\n     }\n }\n \n pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n-    word(s.s, ~\"|\");\n+    word(s.s, \"|\");\n     print_fn_args(s, decl, None);\n-    word(s.s, ~\"|\");\n+    word(s.s, \"|\");\n \n     match decl.output.node {\n         ast::ty_infer => {}\n         _ => {\n             space_if_not_bol(s);\n-            word_space(s, ~\"->\");\n+            word_space(s, \"->\");\n             print_type(s, decl.output);\n         }\n     }\n@@ -1721,33 +1721,33 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n \n pub fn print_bounds(s: @ps, bounds: @OptVec<ast::TyParamBound>) {\n     if !bounds.is_empty() {\n-        word(s.s, ~\":\");\n+        word(s.s, \":\");\n         let mut first = true;\n         for bounds.each |bound| {\n             nbsp(s);\n             if first {\n                 first = false;\n             } else {\n-                word_space(s, ~\"+\");\n+                word_space(s, \"+\");\n             }\n \n             match *bound {\n                 TraitTyParamBound(tref) => print_trait_ref(s, tref),\n-                RegionTyParamBound => word(s.s, ~\"'static\"),\n+                RegionTyParamBound => word(s.s, \"'static\"),\n             }\n         }\n     }\n }\n \n pub fn print_lifetime(s: @ps, lifetime: &ast::Lifetime) {\n-    word(s.s, ~\"'\");\n+    word(s.s, \"'\");\n     print_ident(s, lifetime.ident);\n }\n \n pub fn print_generics(s: @ps, generics: &ast::Generics) {\n     let total = generics.lifetimes.len() + generics.ty_params.len();\n     if total > 0 {\n-        word(s.s, ~\"<\");\n+        word(s.s, \"<\");\n         fn print_item(s: @ps, generics: &ast::Generics, idx: uint) {\n             if idx < generics.lifetimes.len() {\n                 let lifetime = generics.lifetimes.get(idx);\n@@ -1767,7 +1767,7 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n \n         commasep(s, inconsistent, ints,\n                  |s, i| print_item(s, generics, i));\n-        word(s.s, ~\">\");\n+        word(s.s, \">\");\n     }\n }\n \n@@ -1777,7 +1777,7 @@ pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n       ast::meta_word(name) => word(s.s, *name),\n       ast::meta_name_value(name, value) => {\n         word_space(s, *name);\n-        word_space(s, ~\"=\");\n+        word_space(s, \"=\");\n         print_literal(s, @value);\n       }\n       ast::meta_list(name, ref items) => {\n@@ -1801,23 +1801,23 @@ pub fn print_view_path(s: @ps, vp: @ast::view_path) {\n         if path.idents[path.idents.len()-1u] != ident {\n             print_ident(s, ident);\n             space(s.s);\n-            word_space(s, ~\"=\");\n+            word_space(s, \"=\");\n         }\n         print_path(s, path, false);\n       }\n \n       ast::view_path_glob(path, _) => {\n         print_path(s, path, false);\n-        word(s.s, ~\"::*\");\n+        word(s.s, \"::*\");\n       }\n \n       ast::view_path_list(path, ref idents, _) => {\n         print_path(s, path, false);\n-        word(s.s, ~\"::{\");\n+        word(s.s, \"::{\");\n         do commasep(s, inconsistent, (*idents)) |s, w| {\n             print_ident(s, w.node.name);\n         }\n-        word(s.s, ~\"}\");\n+        word(s.s, \"}\");\n       }\n     }\n }\n@@ -1833,7 +1833,7 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n     print_visibility(s, item.vis);\n     match item.node {\n         ast::view_item_extern_mod(id, ref mta, _) => {\n-            head(s, ~\"extern mod\");\n+            head(s, \"extern mod\");\n             print_ident(s, id);\n             if !mta.is_empty() {\n                 popen(s);\n@@ -1843,19 +1843,19 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n         }\n \n         ast::view_item_use(ref vps) => {\n-            head(s, ~\"use\");\n+            head(s, \"use\");\n             print_view_paths(s, *vps);\n         }\n     }\n-    word(s.s, ~\";\");\n+    word(s.s, \";\");\n     end(s); // end inner head-block\n     end(s); // end outer head-block\n }\n \n pub fn print_mutability(s: @ps, mutbl: ast::mutability) {\n     match mutbl {\n-      ast::m_mutbl => word_nbsp(s, ~\"mut\"),\n-      ast::m_const => word_nbsp(s, ~\"const\"),\n+      ast::m_mutbl => word_nbsp(s, \"mut\"),\n+      ast::m_const => word_nbsp(s, \"const\"),\n       ast::m_imm => {/* nothing */ }\n     }\n }\n@@ -1868,7 +1868,7 @@ pub fn print_mt(s: @ps, mt: &ast::mt) {\n pub fn print_arg(s: @ps, input: ast::arg) {\n     ibox(s, indent_unit);\n     if input.is_mutbl {\n-        word_space(s, ~\"mut\");\n+        word_space(s, \"mut\");\n     }\n     match input.ty.node {\n       ast::ty_infer => print_irrefutable_pat(s, input.pat),\n@@ -1881,7 +1881,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n             }\n             _ => {\n                 print_irrefutable_pat(s, input.pat);\n-                word(s.s, ~\":\");\n+                word(s.s, \":\");\n                 space(s.s);\n             }\n         }\n@@ -1910,8 +1910,8 @@ pub fn print_ty_fn(s: @ps,\n     print_opt_lifetime(s, opt_region);\n     print_purity(s, purity);\n     print_onceness(s, onceness);\n-    word(s.s, ~\"fn\");\n-    match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n+    word(s.s, \"fn\");\n+    match id { Some(id) => { word(s.s, \" \"); print_ident(s, id); } _ => () }\n     match generics { Some(g) => print_generics(s, g), _ => () }\n     zerobreak(s.s);\n \n@@ -1924,7 +1924,7 @@ pub fn print_ty_fn(s: @ps,\n         first = !print_explicit_self(s, *explicit_self);\n     }\n     for decl.inputs.each |arg| {\n-        if first { first = false; } else { word_space(s, ~\",\"); }\n+        if first { first = false; } else { word_space(s, \",\"); }\n         print_arg(s, *arg);\n     }\n     end(s);\n@@ -1937,8 +1937,8 @@ pub fn print_ty_fn(s: @ps,\n         _ => {\n             space_if_not_bol(s);\n             ibox(s, indent_unit);\n-            word_space(s, ~\"->\");\n-            if decl.cf == ast::noreturn { word_nbsp(s, ~\"!\"); }\n+            word_space(s, \"->\");\n+            if decl.cf == ast::noreturn { word_nbsp(s, \"!\"); }\n             else { print_type(s, decl.output); }\n             end(s);\n         }\n@@ -2024,9 +2024,9 @@ pub fn print_literal(s: @ps, lit: @ast::lit) {\n         word(s.s, *f + ast_util::float_ty_to_str(t));\n       }\n       ast::lit_float_unsuffixed(f) => word(s.s, *f),\n-      ast::lit_nil => word(s.s, ~\"()\"),\n+      ast::lit_nil => word(s.s, \"()\"),\n       ast::lit_bool(val) => {\n-        if val { word(s.s, ~\"true\"); } else { word(s.s, ~\"false\"); }\n+        if val { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n       }\n     }\n }\n@@ -2082,7 +2082,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n         }\n       }\n       comments::trailing => {\n-        word(s.s, ~\" \");\n+        word(s.s, \" \");\n         if cmnt.lines.len() == 1u {\n             word(s.s, cmnt.lines[0]);\n             hardbreak(s.s);\n@@ -2109,9 +2109,9 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n }\n \n pub fn print_string(s: @ps, st: &str) {\n-    word(s.s, ~\"\\\"\");\n+    word(s.s, \"\\\"\");\n     word(s.s, str::escape_default(st));\n-    word(s.s, ~\"\\\"\");\n+    word(s.s, \"\\\"\");\n }\n \n pub fn to_str<T: Copy>(t: T, f: @fn(@ps, T), intr: @ident_interner) -> ~str {\n@@ -2146,7 +2146,7 @@ pub fn print_opt_purity(s: @ps, opt_purity: Option<ast::purity>) {\n pub fn print_extern_opt_abis(s: @ps, opt_abis: Option<AbiSet>) {\n     match opt_abis {\n         Some(abis) => {\n-            word_nbsp(s, ~\"extern\");\n+            word_nbsp(s, \"extern\");\n             word_nbsp(s, abis.to_str());\n         }\n         None => {}\n@@ -2155,9 +2155,9 @@ pub fn print_extern_opt_abis(s: @ps, opt_abis: Option<AbiSet>) {\n \n pub fn print_opt_sigil(s: @ps, opt_sigil: Option<ast::Sigil>) {\n     match opt_sigil {\n-        Some(ast::BorrowedSigil) => { word(s.s, ~\"&\"); }\n-        Some(ast::OwnedSigil) => { word(s.s, ~\"~\"); }\n-        Some(ast::ManagedSigil) => { word(s.s, ~\"@\"); }\n+        Some(ast::BorrowedSigil) => { word(s.s, \"&\"); }\n+        Some(ast::OwnedSigil) => { word(s.s, \"~\"); }\n+        Some(ast::ManagedSigil) => { word(s.s, \"@\"); }\n         None => {}\n     };\n }\n@@ -2172,7 +2172,7 @@ pub fn print_fn_header_info(s: @ps,\n     word(s.s, visibility_qualified(vis, ~\"\"));\n \n     if abis != AbiSet::Rust() {\n-        word_nbsp(s, ~\"extern\");\n+        word_nbsp(s, \"extern\");\n         word_nbsp(s, abis.to_str());\n \n         if opt_purity != Some(ast::extern_fn) {\n@@ -2183,7 +2183,7 @@ pub fn print_fn_header_info(s: @ps,\n     }\n \n     print_onceness(s, onceness);\n-    word(s.s, ~\"fn\");\n+    word(s.s, \"fn\");\n     print_opt_sigil(s, opt_sigil);\n }\n \n@@ -2219,7 +2219,7 @@ pub fn print_purity(s: @ps, p: ast::purity) {\n \n pub fn print_onceness(s: @ps, o: ast::Onceness) {\n     match o {\n-        ast::Once => { word_nbsp(s, ~\"once\"); }\n+        ast::Once => { word_nbsp(s, \"once\"); }\n         ast::Many => {}\n     }\n }"}, {"sha": "dc5936777c9fe784e2db6451a7ac157b919870f4", "filename": "src/test/compile-fail/lint-unused-imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a3e3205144969fe9a9ec724929d641f309a6162/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-imports.rs?ref=5a3e3205144969fe9a9ec724929d641f309a6162", "patch": "@@ -55,8 +55,8 @@ fn main() {\n     cal(foo::Point{x:3, y:9});\n     let a = 3;\n     ignore(a);\n-    io::stdout().write_str(~\"a\");\n-    let _a = do map(~[2]) |&x| {\n+    io::stdout().write_str(\"a\");\n+    let _a = do map([2]) |&x| {\n       x + 2\n     };\n }"}]}