{"sha": "e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZjFhYmY1Zjc2MDUyNGY3NWI0ZDRiY2ZlOGIxMTBlYmE1ZWE4ZmU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-20T14:01:27Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-07-20T14:01:27Z"}, "message": "Correctly generate link fragments for associated items", "tree": {"sha": "637a8ff566d377e91919e54780d38342d7d4a0f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/637a8ff566d377e91919e54780d38342d7d4a0f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "html_url": "https://github.com/rust-lang/rust/commit/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "113beab47310dc7c69409b194b10ff29ea7d307a", "url": "https://api.github.com/repos/rust-lang/rust/commits/113beab47310dc7c69409b194b10ff29ea7d307a", "html_url": "https://github.com/rust-lang/rust/commit/113beab47310dc7c69409b194b10ff29ea7d307a"}], "stats": {"total": 280, "additions": 160, "deletions": 120}, "files": [{"sha": "8c411c6906d398aff339bb628da20bdfb709f2fb", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 150, "deletions": 110, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "patch": "@@ -10,6 +10,7 @@ mod intra_doc_links;\n use itertools::Itertools;\n use pulldown_cmark::{BrokenLink, CowStr, Event, InlineStr, LinkType, Options, Parser, Tag};\n use pulldown_cmark_to_cmark::{cmark_with_options, Options as CmarkOptions};\n+use stdx::format_to;\n use url::Url;\n \n use hir::{\n@@ -31,12 +32,12 @@ use crate::{\n pub(crate) type DocumentationLink = String;\n \n /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n-pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> String {\n+pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: Definition) -> String {\n     let mut cb = broken_link_clone_cb;\n     let doc =\n         Parser::new_with_broken_link_callback(markdown, Options::ENABLE_TASKLISTS, Some(&mut cb));\n \n-    let doc = map_links(doc, |target, title: &str| {\n+    let doc = map_links(doc, |target, title| {\n         // This check is imperfect, there's some overlap between valid intra-doc links\n         // and valid URLs so we choose to be too eager to try to resolve what might be\n         // a URL.\n@@ -46,10 +47,10 @@ pub(crate) fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Defi\n             // Two possibilities:\n             // * path-based links: `../../module/struct.MyStruct.html`\n             // * module-based links (AKA intra-doc links): `super::super::module::MyStruct`\n-            if let Some(rewritten) = rewrite_intra_doc_link(db, *definition, target, title) {\n+            if let Some(rewritten) = rewrite_intra_doc_link(db, definition, target, title) {\n                 return rewritten;\n             }\n-            if let Definition::ModuleDef(def) = *definition {\n+            if let Definition::ModuleDef(def) = definition {\n                 if let Some(target) = rewrite_url_link(db, def, target) {\n                     return (target, title.to_string());\n                 }\n@@ -77,9 +78,9 @@ pub(crate) fn remove_links(markdown: &str) -> String {\n     };\n     let doc = Parser::new_with_broken_link_callback(markdown, opts, Some(&mut cb));\n     let doc = doc.filter_map(move |evt| match evt {\n-        Event::Start(Tag::Link(link_type, ref target, ref title)) => {\n+        Event::Start(Tag::Link(link_type, target, title)) => {\n             if link_type == LinkType::Inline && target.contains(\"://\") {\n-                Some(Event::Start(Tag::Link(link_type, target.clone(), title.clone())))\n+                Some(Event::Start(Tag::Link(link_type, target, title)))\n             } else {\n                 drop_link = true;\n                 None\n@@ -135,11 +136,11 @@ pub(crate) fn external_docs(\n }\n \n /// Extracts all links from a given markdown text.\n-pub(crate) fn extract_definitions_from_markdown(\n-    markdown: &str,\n+pub(crate) fn extract_definitions_from_docs(\n+    docs: &hir::Documentation,\n ) -> Vec<(TextRange, String, Option<hir::Namespace>)> {\n     Parser::new_with_broken_link_callback(\n-        markdown,\n+        docs.as_str(),\n         Options::ENABLE_TASKLISTS,\n         Some(&mut broken_link_clone_cb),\n     )\n@@ -294,7 +295,7 @@ fn get_doc_link(db: &RootDatabase, definition: Definition) -> Option<String> {\n         _ => None,\n     };\n \n-    get_doc_url(db, &krate)?\n+    get_doc_base_url(db, &krate)?\n         .join(&base)\n         .ok()\n         .and_then(|mut url| {\n@@ -316,35 +317,37 @@ fn rewrite_intra_doc_link(\n     target: &str,\n     title: &str,\n ) -> Option<(String, String)> {\n-    let link = if target.is_empty() { title } else { target };\n-    let (link, ns) = parse_intra_doc_link(link);\n+    let (link, ns) = parse_intra_doc_link(target);\n     let resolved = resolve_doc_path_for_def(db, def, link, ns)?;\n     let krate = resolved.module(db)?.krate();\n-    let canonical_path = resolved.canonical_path(db)?;\n-    let mut new_url = get_doc_url(db, &krate)?\n+    let mut mod_path = String::new();\n+    resolved\n+        .module(db)?\n+        .path_to_root(db)\n+        .into_iter()\n+        .rev()\n+        .flat_map(|it| it.name(db))\n+        .for_each(|name| format_to!(mod_path, \"{}/\", name));\n+    let mut new_url = get_doc_base_url(db, &krate)?\n         .join(&format!(\"{}/\", krate.display_name(db)?))\n         .ok()?\n-        .join(&canonical_path.replace(\"::\", \"/\"))\n-        .ok()?\n-        .join(&get_symbol_filename(db, &resolved)?)\n+        .join(&mod_path)\n         .ok()?;\n-\n-    if let ModuleDef::Trait(t) = resolved {\n-        if let Some(assoc_item) = t.items(db).into_iter().find_map(|assoc_item| {\n-            if let Some(name) = assoc_item.name(db) {\n-                if *link == format!(\"{}::{}\", canonical_path, name) {\n-                    return Some(assoc_item);\n-                }\n-            }\n-            None\n-        }) {\n-            if let Some(fragment) =\n-                get_symbol_fragment(db, &FieldOrAssocItem::AssocItem(assoc_item))\n-            {\n-                new_url = new_url.join(&fragment).ok()?;\n-            }\n+    if let Some(assoc_item) = resolved.as_assoc_item(db) {\n+        let resolved = match assoc_item.container(db) {\n+            AssocItemContainer::Trait(t) => t.into(),\n+            AssocItemContainer::Impl(i) => i.self_ty(db).as_adt()?.into(),\n         };\n-    }\n+        new_url = new_url.join(&get_symbol_filename(db, &resolved)?).ok()?;\n+        let frag = match assoc_item {\n+            AssocItem::Function(f) => format!(\"method.{}\", f.name(db)),\n+            AssocItem::Const(c) => format!(\"associatedconstant.{}\", c.name(db)?),\n+            AssocItem::TypeAlias(ta) => format!(\"associatedtype.{}\", ta.name(db)),\n+        };\n+        new_url.set_fragment(Some(&frag));\n+    } else {\n+        new_url = new_url.join(&get_symbol_filename(db, &resolved)?).ok()?;\n+    };\n \n     Some((new_url.into(), strip_prefixes_suffixes(title).to_string()))\n }\n@@ -360,7 +363,7 @@ fn rewrite_url_link(db: &RootDatabase, def: ModuleDef, target: &str) -> Option<S\n     let canonical_path = def.canonical_path(db)?;\n     let base = format!(\"{}/{}\", krate.display_name(db)?, canonical_path.replace(\"::\", \"/\"));\n \n-    get_doc_url(db, &krate)\n+    get_doc_base_url(db, &krate)\n         .and_then(|url| url.join(&base).ok())\n         .and_then(|url| {\n             get_symbol_filename(db, &def).as_deref().map(|f| url.join(f).ok()).flatten()\n@@ -378,14 +381,18 @@ fn map_links<'e>(\n     let mut link_target: Option<CowStr> = None;\n \n     events.map(move |evt| match evt {\n-        Event::Start(Tag::Link(_link_type, ref target, _)) => {\n+        Event::Start(Tag::Link(_, ref target, _)) => {\n             in_link = true;\n             link_target = Some(target.clone());\n             evt\n         }\n-        Event::End(Tag::Link(link_type, _target, _)) => {\n+        Event::End(Tag::Link(link_type, target, _)) => {\n             in_link = false;\n-            Event::End(Tag::Link(link_type, link_target.take().unwrap(), CowStr::Borrowed(\"\")))\n+            Event::End(Tag::Link(\n+                link_type,\n+                link_target.take().unwrap_or(target),\n+                CowStr::Borrowed(\"\"),\n+            ))\n         }\n         Event::Text(s) if in_link => {\n             let (link_target_s, link_name) = callback(&link_target.take().unwrap(), &s);\n@@ -407,7 +414,7 @@ fn map_links<'e>(\n /// https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.next\n /// ^^^^^^^^^^^^^^^^^^^^^^^^^^\n /// ```\n-fn get_doc_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n+fn get_doc_base_url(db: &RootDatabase, krate: &Crate) -> Option<Url> {\n     krate\n         .get_html_root_url(db)\n         .or_else(|| {\n@@ -491,13 +498,6 @@ mod tests {\n \n     use super::*;\n \n-    fn check_external_docs(ra_fixture: &str, expect: Expect) {\n-        let (analysis, position) = fixture::position(ra_fixture);\n-        let url = analysis.external_docs(position).unwrap().expect(\"could not find url for symbol\");\n-\n-        expect.assert_eq(&url)\n-    }\n-\n     #[test]\n     fn test_doc_url_crate() {\n         check_external_docs(\n@@ -536,26 +536,27 @@ pub fn fo$0o() {}\n         check_external_docs(\n             r#\"\n pub struct Foo;\n-\n impl Foo {\n     pub fn met$0hod() {}\n }\n-\n \"#,\n             expect![[r##\"https://docs.rs/test/*/test/struct.Foo.html#method.method\"##]],\n         );\n     }\n \n     #[test]\n-    fn test_doc_url_trait_provided_method() {\n+    fn test_doc_url_impl_trait_method() {\n         check_external_docs(\n             r#\"\n-pub trait Bar {\n-    fn met$0hod() {}\n+pub struct Foo;\n+pub trait Trait {\n+    fn met hod();\n+}\n+impl Trait for Foo {\n+    pub fn met$0hod() {}\n }\n-\n \"#,\n-            expect![[r##\"https://docs.rs/test/*/test/trait.Bar.html#method.method\"##]],\n+            expect![[r##\"https://docs.rs/test/*/test/struct.Foo.html#method.method\"##]],\n         );\n     }\n \n@@ -566,7 +567,6 @@ pub trait Bar {\n pub trait Foo {\n     fn met$0hod();\n }\n-\n \"#,\n             expect![[r##\"https://docs.rs/test/*/test/trait.Foo.html#tymethod.method\"##]],\n         );\n@@ -624,50 +624,66 @@ fn foo() {\n         )\n     }\n \n+    #[test]\n+    fn test_trait_items() {\n+        check_doc_links(\n+            r#\"\n+/// [`Trait`]\n+/// [`Trait::Type`]\n+/// [`Trait::CONST`]\n+/// [`Trait::func`]\n+trait Trait$0 {\n+   // ^^^^^ Trait\n+    type Type;\n+      // ^^^^ Trait::Type\n+    const CONST: usize;\n+       // ^^^^^ Trait::CONST\n+    fn func();\n+    // ^^^^ Trait::func\n+}\n+        \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_rewrite() {\n+        check_rewrite(\n+            r#\"\n+pub trait Foo {\n+    fn buzz() -> usize;\n+}\n+/// [Foo][buzz]\n+///\n+/// [buzz]: Foo::buzz\n+pub struct Bar$0;\n+\"#,\n+            expect![[r###\"[Foo](https://docs.rs/test/*/test/trait.Foo.html#method.buzz)\"###]],\n+        )\n+    }\n+\n+    fn check_external_docs(ra_fixture: &str, expect: Expect) {\n+        let (analysis, position) = fixture::position(ra_fixture);\n+        let url = analysis.external_docs(position).unwrap().expect(\"could not find url for symbol\");\n+\n+        expect.assert_eq(&url)\n+    }\n+\n+    fn check_rewrite(ra_fixture: &str, expect: Expect) {\n+        let (analysis, position) = fixture::position(ra_fixture);\n+        let sema = &Semantics::new(&*analysis.db);\n+        let (cursor_def, docs) = def_under_cursor(sema, &position);\n+        let res = rewrite_links(sema.db, docs.as_str(), cursor_def);\n+        expect.assert_eq(&res)\n+    }\n+\n     fn check_doc_links(ra_fixture: &str) {\n-        fn node_to_def(\n-            sema: &Semantics<RootDatabase>,\n-            node: &SyntaxNode,\n-        ) -> Option<Option<(Option<hir::Documentation>, Definition)>> {\n-            Some(match_ast! {\n-                match node {\n-                    ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-                    ast::Module(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n-                    ast::Fn(it)          => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n-                    ast::Struct(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n-                    ast::Union(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n-                    ast::Enum(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n-                    ast::Variant(it)     => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n-                    ast::Trait(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n-                    ast::Static(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n-                    ast::Const(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n-                    ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n-                    ast::Impl(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::SelfType(def))),\n-                    ast::RecordField(it) => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),\n-                    ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),\n-                    ast::Macro(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Macro(def))),\n-                    // ast::Use(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n-                    _ => return None,\n-                }\n-            })\n-        }\n         let key_fn = |&(FileRange { file_id, range }, _): &_| (file_id, range.start());\n \n         let (analysis, position, mut expected) = fixture::annotations(ra_fixture);\n         expected.sort_by_key(key_fn);\n         let sema = &Semantics::new(&*analysis.db);\n-        let (docs, cursor_def) = sema\n-            .parse(position.file_id)\n-            .syntax()\n-            .token_at_offset(position.offset)\n-            .next()\n-            .unwrap()\n-            .ancestors()\n-            .find_map(|it| node_to_def(sema, &it))\n-            .expect(\"no def found\")\n-            .unwrap();\n-        let docs = docs.expect(\"no docs found for cursor def\");\n-        let defs = extract_definitions_from_markdown(docs.as_str());\n+        let (cursor_def, docs) = def_under_cursor(sema, &position);\n+        let defs = extract_definitions_from_docs(&docs);\n         let actual: Vec<_> = defs\n             .into_iter()\n             .map(|(_, link, ns)| {\n@@ -685,24 +701,48 @@ fn foo() {\n         assert_eq!(expected, actual);\n     }\n \n-    #[test]\n-    fn test_trait_items() {\n-        check_doc_links(\n-            r#\"\n-/// [`Trait`]\n-/// [`Trait::Type`]\n-/// [`Trait::CONST`]\n-/// [`Trait::func`]\n-trait Trait$0 {\n-   // ^^^^^ Trait\n-    type Type;\n-      // ^^^^ Trait::Type\n-    const CONST: usize;\n-       // ^^^^^ Trait::CONST\n-    fn func();\n-    // ^^^^ Trait::func\n-}\n-        \"#,\n-        )\n+    fn def_under_cursor(\n+        sema: &Semantics<RootDatabase>,\n+        position: &FilePosition,\n+    ) -> (Definition, hir::Documentation) {\n+        let (docs, def) = sema\n+            .parse(position.file_id)\n+            .syntax()\n+            .token_at_offset(position.offset)\n+            .next()\n+            .unwrap()\n+            .ancestors()\n+            .find_map(|it| node_to_def(sema, &it))\n+            .expect(\"no def found\")\n+            .unwrap();\n+        let docs = docs.expect(\"no docs found for cursor def\");\n+        (def, docs)\n+    }\n+\n+    fn node_to_def(\n+        sema: &Semantics<RootDatabase>,\n+        node: &SyntaxNode,\n+    ) -> Option<Option<(Option<hir::Documentation>, Definition)>> {\n+        Some(match_ast! {\n+            match node {\n+                ast::SourceFile(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+                ast::Module(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Module(def)))),\n+                ast::Fn(it)          => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Function(def)))),\n+                ast::Struct(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Struct(def))))),\n+                ast::Union(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Union(def))))),\n+                ast::Enum(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Adt(hir::Adt::Enum(def))))),\n+                ast::Variant(it)     => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Variant(def)))),\n+                ast::Trait(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Trait(def)))),\n+                ast::Static(it)      => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Static(def)))),\n+                ast::Const(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::Const(def)))),\n+                ast::TypeAlias(it)   => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::ModuleDef(hir::ModuleDef::TypeAlias(def)))),\n+                ast::Impl(it)        => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::SelfType(def))),\n+                ast::RecordField(it) => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),\n+                ast::TupleField(it)  => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Field(def))),\n+                ast::Macro(it)       => sema.to_def(&it).map(|def| (def.docs(sema.db), Definition::Macro(def))),\n+                // ast::Use(it) => sema.to_def(&it).map(|def| (Box::new(it) as _, def.attrs(sema.db))),\n+                _ => return None,\n+            }\n+        })\n     }\n }"}, {"sha": "4a0290727418bc482e8cfa76fea4a400d4653c75", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "patch": "@@ -12,7 +12,7 @@ use syntax::{ast, match_ast, AstNode, AstToken, SyntaxKind::*, SyntaxToken, Text\n \n use crate::{\n     display::{ToNav, TryToNav},\n-    doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n+    doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n@@ -46,7 +46,7 @@ pub(crate) fn goto_definition(\n \n         let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n         let (_, link, ns) =\n-            extract_definitions_from_markdown(docs.as_str()).into_iter().find(|(range, ..)| {\n+            extract_definitions_from_docs(&docs).into_iter().find(|(range, ..)| {\n                 doc_mapping.map(*range).map_or(false, |InFile { file_id, value: range }| {\n                     file_id == position.file_id.into() && range.contains(position.offset)\n                 })"}, {"sha": "93b1cf1c907a02a306315aba78c6d5ceaf00a9e5", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n use crate::{\n     display::{macro_label, TryToNav},\n     doc_links::{\n-        doc_attributes, extract_definitions_from_markdown, remove_links, resolve_doc_path_for_def,\n+        doc_attributes, extract_definitions_from_docs, remove_links, resolve_doc_path_for_def,\n         rewrite_links,\n     },\n     markdown_remove::remove_markdown,\n@@ -119,7 +119,7 @@ pub(crate) fn hover(\n                     let (attributes, def) = doc_attributes(&sema, &node)?;\n                     let (docs, doc_mapping) = attributes.docs_with_rangemap(db)?;\n                     let (idl_range, link, ns) =\n-                        extract_definitions_from_markdown(docs.as_str()).into_iter().find_map(|(range, link, ns)| {\n+                        extract_definitions_from_docs(&docs).into_iter().find_map(|(range, link, ns)| {\n                             let hir::InFile { file_id, value: range } = doc_mapping.map(range)?;\n                             if file_id == position.file_id.into() && range.contains(position.offset) {\n                                 Some((range, link, ns))\n@@ -369,7 +369,7 @@ fn process_markup(\n     let markup = if !config.markdown() {\n         remove_markdown(markup)\n     } else if config.links_in_hover {\n-        rewrite_links(db, markup, &def)\n+        rewrite_links(db, markup, def)\n     } else {\n         remove_links(markup)\n     };\n@@ -2090,7 +2090,7 @@ pub trait Foo {\n /// [buzz]: Foo::buzz\n pub struct B$0ar\n \"#,\n-            expect![[r#\"\n+            expect![[r##\"\n                 *Bar*\n \n                 ```rust\n@@ -2103,8 +2103,8 @@ pub struct B$0ar\n \n                 ---\n \n-                [Foo](https://docs.rs/test/*/test/trait.Foo.html#tymethod.buzz)\n-            \"#]],\n+                [Foo](https://docs.rs/test/*/test/trait.Foo.html#method.buzz)\n+            \"##]],\n         );\n     }\n "}, {"sha": "72da4bc0f1f6ac203f4ab7acdd5008e1473f3731", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=e8f1abf5f760524f75b4d4bcfe8b110eba5ea8fe", "patch": "@@ -11,7 +11,7 @@ use syntax::{\n };\n \n use crate::{\n-    doc_links::{doc_attributes, extract_definitions_from_markdown, resolve_doc_path_for_def},\n+    doc_links::{doc_attributes, extract_definitions_from_docs, resolve_doc_path_for_def},\n     Analysis, HlMod, HlRange, HlTag, RootDatabase,\n };\n \n@@ -104,7 +104,7 @@ pub(super) fn doc_comment(\n     let mut string;\n \n     if let Some((docs, doc_mapping)) = attributes.docs_with_rangemap(sema.db) {\n-        extract_definitions_from_markdown(docs.as_str())\n+        extract_definitions_from_docs(&docs)\n             .into_iter()\n             .filter_map(|(range, link, ns)| {\n                 let def = resolve_doc_path_for_def(sema.db, def, &link, ns)?;"}]}