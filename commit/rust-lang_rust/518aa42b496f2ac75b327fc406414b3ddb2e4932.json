{"sha": "518aa42b496f2ac75b327fc406414b3ddb2e4932", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOGFhNDJiNDk2ZjJhYzc1YjMyN2ZjNDA2NDE0YjNkZGIyZTQ5MzI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-27T13:47:58Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-06-27T13:47:58Z"}, "message": "Implement all binops for integers", "tree": {"sha": "f6f6cc3c38593e1de6222384c3bb240442b3c6fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6f6cc3c38593e1de6222384c3bb240442b3c6fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/518aa42b496f2ac75b327fc406414b3ddb2e4932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/518aa42b496f2ac75b327fc406414b3ddb2e4932", "html_url": "https://github.com/rust-lang/rust/commit/518aa42b496f2ac75b327fc406414b3ddb2e4932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/518aa42b496f2ac75b327fc406414b3ddb2e4932/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5508d44e2be18441db6bd596d5b9f63202b6b61b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5508d44e2be18441db6bd596d5b9f63202b6b61b", "html_url": "https://github.com/rust-lang/rust/commit/5508d44e2be18441db6bd596d5b9f63202b6b61b"}], "stats": {"total": 70, "additions": 38, "deletions": 32}, "files": [{"sha": "b4b58afbafe1375bcddae5fa6f04aa4644794b56", "filename": "build.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/518aa42b496f2ac75b327fc406414b3ddb2e4932/build.sh", "raw_url": "https://github.com/rust-lang/rust/raw/518aa42b496f2ac75b327fc406414b3ddb2e4932/build.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build.sh?ref=518aa42b496f2ac75b327fc406414b3ddb2e4932", "patch": "@@ -1,3 +1,4 @@\n cargo build || exit 1\n \n rustc -Zcodegen-backend=$(pwd)/target/debug/librustc_codegen_cretonne.so example.rs --crate-type lib -Og\n+rustc -Zcodegen-backend=$(pwd)/target/debug/librustc_codegen_cretonne.so ../rust/src/libcore/lib.rs --crate-type lib -Og"}, {"sha": "acedf51acf9e38584bbcfbf592a895b85200a85a", "filename": "src/base.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/518aa42b496f2ac75b327fc406414b3ddb2e4932/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/518aa42b496f2ac75b327fc406414b3ddb2e4932/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=518aa42b496f2ac75b327fc406414b3ddb2e4932", "patch": "@@ -342,63 +342,37 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n                 },\n                 Rvalue::BinaryOp(bin_op, lhs, rhs) => {\n                     let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let layout = fx.layout_of(ty);\n                     let lhs = trans_operand(fx, lhs).load_value(fx);\n                     let rhs = trans_operand(fx, rhs).load_value(fx);\n \n                     let res = match ty.sty {\n                         TypeVariants::TyUint(_) => {\n-                            match bin_op {\n-                                BinOp::Add => fx.bcx.ins().iadd(lhs, rhs),\n-                                BinOp::Sub => fx.bcx.ins().isub(lhs, rhs),\n-                                BinOp::Mul => fx.bcx.ins().imul(lhs, rhs),\n-                                BinOp::Div => fx.bcx.ins().udiv(lhs, rhs),\n-                                bin_op => unimplemented!(\"checked uint bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n-                            }\n+                            trans_int_binop(fx, *bin_op, lhs, rhs, ty, false, false)\n                         }\n                         TypeVariants::TyInt(_) => {\n-                            match bin_op {\n-                                BinOp::Add => fx.bcx.ins().iadd(lhs, rhs),\n-                                BinOp::Sub => fx.bcx.ins().isub(lhs, rhs),\n-                                BinOp::Mul => fx.bcx.ins().imul(lhs, rhs),\n-                                BinOp::Div => fx.bcx.ins().sdiv(lhs, rhs),\n-                                bin_op => unimplemented!(\"checked int bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n-                            }\n+                            trans_int_binop(fx, *bin_op, lhs, rhs, ty, true, false)\n                         }\n                         _ => unimplemented!(),\n                     };\n-                    lval.write_cvalue(fx, CValue::ByVal(res, layout));\n+                    lval.write_cvalue(fx, res);\n                 }\n                 Rvalue::CheckedBinaryOp(bin_op, lhs, rhs) => {\n                     // TODO correctly write output tuple\n \n                     let ty = fx.monomorphize(&lhs.ty(&fx.mir.local_decls, fx.tcx));\n-                    let layout = fx.layout_of(ty);\n                     let lhs = trans_operand(fx, lhs).load_value(fx);\n                     let rhs = trans_operand(fx, rhs).load_value(fx);\n \n                     let res = match ty.sty {\n                         TypeVariants::TyUint(_) => {\n-                            match bin_op {\n-                                BinOp::Add => fx.bcx.ins().iadd(lhs, rhs),\n-                                BinOp::Sub => fx.bcx.ins().isub(lhs, rhs),\n-                                BinOp::Mul => fx.bcx.ins().imul(lhs, rhs),\n-                                BinOp::Div => fx.bcx.ins().udiv(lhs, rhs),\n-                                bin_op => unimplemented!(\"checked uint bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n-                            }\n+                            trans_int_binop(fx, *bin_op, lhs, rhs, ty, false, true)\n                         }\n                         TypeVariants::TyInt(_) => {\n-                            match bin_op {\n-                                BinOp::Add => fx.bcx.ins().iadd(lhs, rhs),\n-                                BinOp::Sub => fx.bcx.ins().isub(lhs, rhs),\n-                                BinOp::Mul => fx.bcx.ins().imul(lhs, rhs),\n-                                BinOp::Div => fx.bcx.ins().sdiv(lhs, rhs),\n-                                bin_op => unimplemented!(\"checked int bin op {:?} {:?} {:?}\", bin_op, lhs, rhs),\n-                            }\n+                            trans_int_binop(fx, *bin_op, lhs, rhs, ty, true, true)\n                         }\n                         _ => unimplemented!(),\n                     };\n-                    lval.write_cvalue(fx, CValue::ByVal(res, layout));\n+                    lval.write_cvalue(fx, res);\n                     unimplemented!(\"checked bin op {:?}\", bin_op);\n                 }\n                 Rvalue::Cast(CastKind::ReifyFnPointer, operand, ty) => {\n@@ -480,6 +454,37 @@ fn trans_stmt<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, stmt: &Statement<'tcx\n     }\n }\n \n+fn trans_int_binop<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, bin_op: BinOp, lhs: Value, rhs: Value, ty: Ty<'tcx>, signed: bool, checked: bool) -> CValue<'tcx> {\n+    let res = match (bin_op, signed) {\n+        (BinOp::Add, _) => fx.bcx.ins().iadd(lhs, rhs),\n+        (BinOp::Sub, _) => fx.bcx.ins().isub(lhs, rhs),\n+        (BinOp::Mul, _) => fx.bcx.ins().imul(lhs, rhs),\n+        (BinOp::Div, false) => fx.bcx.ins().udiv(lhs, rhs),\n+        (BinOp::Div, true) => fx.bcx.ins().sdiv(lhs, rhs),\n+        (BinOp::Rem, false) => fx.bcx.ins().urem(lhs, rhs),\n+        (BinOp::Rem, true) => fx.bcx.ins().srem(lhs, rhs),\n+        (BinOp::BitXor, _) => fx.bcx.ins().bxor(lhs, rhs),\n+        (BinOp::BitAnd, _) => fx.bcx.ins().band(lhs, rhs),\n+        (BinOp::BitOr, _) => fx.bcx.ins().bor(lhs, rhs),\n+        (BinOp::Shl, _) => fx.bcx.ins().ishl(lhs, rhs),\n+        (BinOp::Shr, false) => fx.bcx.ins().ushr(lhs, rhs),\n+        (BinOp::Shr, true) => fx.bcx.ins().sshr(lhs, rhs),\n+        (BinOp::Eq, _) => fx.bcx.ins().icmp(IntCC::Equal , lhs, rhs),\n+        (BinOp::Lt, false) => fx.bcx.ins().icmp(IntCC::UnsignedLessThan , lhs, rhs),\n+        (BinOp::Lt, true) => fx.bcx.ins().icmp(IntCC::SignedLessThan , lhs, rhs),\n+        (BinOp::Le, false) => fx.bcx.ins().icmp(IntCC::UnsignedLessThanOrEqual , lhs, rhs),\n+        (BinOp::Le, true) => fx.bcx.ins().icmp(IntCC::SignedLessThanOrEqual , lhs, rhs),\n+        (BinOp::Ne, _) => fx.bcx.ins().icmp(IntCC::NotEqual , lhs, rhs),\n+        (BinOp::Ge, false) => fx.bcx.ins().icmp(IntCC::UnsignedGreaterThanOrEqual , lhs, rhs),\n+        (BinOp::Ge, true) => fx.bcx.ins().icmp(IntCC::SignedGreaterThanOrEqual , lhs, rhs),\n+        (BinOp::Gt, false) => fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan , lhs, rhs),\n+        (BinOp::Gt, true) => fx.bcx.ins().icmp(IntCC::SignedGreaterThan , lhs, rhs),\n+        (BinOp::Offset, _) => bug!(\"bin op Offset on non ptr lhs: {:?} rhs: {:?}\", lhs, rhs),\n+    };\n+    // TODO: return correct value for checked binops\n+    CValue::ByVal(res, fx.layout_of(ty))\n+}\n+\n fn trans_place<'a, 'tcx: 'a>(fx: &mut FunctionCx<'a, 'tcx>, place: &Place<'tcx>) -> CPlace<'tcx> {\n     match place {\n         Place::Local(local) => fx.get_local_place(*local),"}]}