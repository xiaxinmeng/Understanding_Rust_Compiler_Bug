{"sha": "763f9234b052c7911dc4cf952a81a85c51c57784", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2M2Y5MjM0YjA1MmM3OTExZGM0Y2Y5NTJhODFhODVjNTFjNTc3ODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-06T12:08:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-06-06T12:08:50Z"}, "message": "Auto merge of #34006 - eddyb:mir-const-fixes, r=nikomatsakis\n\n [MIR] Fix double-rounding of float constants and ignore NaN sign in tests.\n\nFixes #32805 by handling f32 and f64 separately in rustc_const_eval.\n\nAlso removes `#[rustc_no_mir]` from a couple libstd tests by ignoring NaN sign.\nTurns out that runtime evaluation of `0.0 / 0.0` produces a NaN with the sign bit set,\nwhereas LLVM constant folds it to a NaN with the sign bit unset, which we were testing for.", "tree": {"sha": "c83b1d980341b8d64a939aaa459f1100bf513b03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c83b1d980341b8d64a939aaa459f1100bf513b03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/763f9234b052c7911dc4cf952a81a85c51c57784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/763f9234b052c7911dc4cf952a81a85c51c57784", "html_url": "https://github.com/rust-lang/rust/commit/763f9234b052c7911dc4cf952a81a85c51c57784", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/763f9234b052c7911dc4cf952a81a85c51c57784/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a4a13a5bc34deeb764d768f1c5f30dddce1b5f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a4a13a5bc34deeb764d768f1c5f30dddce1b5f9", "html_url": "https://github.com/rust-lang/rust/commit/4a4a13a5bc34deeb764d768f1c5f30dddce1b5f9"}, {"sha": "f158a2f69de48b2f4dc8053441c24c7e2d253ff1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f158a2f69de48b2f4dc8053441c24c7e2d253ff1", "html_url": "https://github.com/rust-lang/rust/commit/f158a2f69de48b2f4dc8053441c24c7e2d253ff1"}], "stats": {"total": 409, "additions": 302, "deletions": 107}, "files": [{"sha": "3482971cd1999c0507abc2b959d498534a950766", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -12,14 +12,12 @@ use syntax::parse::token::InternedString;\n use syntax::ast;\n use std::rc::Rc;\n use hir::def_id::DefId;\n-use std::hash;\n-use std::mem::transmute;\n use rustc_const_math::*;\n use self::ConstVal::*;\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal {\n-    Float(f64),\n+    Float(ConstFloat),\n     Integral(ConstInt),\n     Str(InternedString),\n     ByteStr(Rc<Vec<u8>>),\n@@ -36,55 +34,10 @@ pub enum ConstVal {\n     Dummy,\n }\n \n-impl hash::Hash for ConstVal {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        match *self {\n-            Float(a) => unsafe { transmute::<_,u64>(a) }.hash(state),\n-            Integral(a) => a.hash(state),\n-            Str(ref a) => a.hash(state),\n-            ByteStr(ref a) => a.hash(state),\n-            Bool(a) => a.hash(state),\n-            Struct(a) => a.hash(state),\n-            Tuple(a) => a.hash(state),\n-            Function(a) => a.hash(state),\n-            Array(a, n) => { a.hash(state); n.hash(state) },\n-            Repeat(a, n) => { a.hash(state); n.hash(state) },\n-            Char(c) => c.hash(state),\n-            Dummy => ().hash(state),\n-        }\n-    }\n-}\n-\n-/// Note that equality for `ConstVal` means that the it is the same\n-/// constant, not that the rust values are equal. In particular, `NaN\n-/// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n-/// are considering unequal).\n-impl PartialEq for ConstVal {\n-    fn eq(&self, other: &ConstVal) -> bool {\n-        match (self, other) {\n-            (&Float(a), &Float(b)) => unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)},\n-            (&Integral(a), &Integral(b)) => a == b,\n-            (&Str(ref a), &Str(ref b)) => a == b,\n-            (&ByteStr(ref a), &ByteStr(ref b)) => a == b,\n-            (&Bool(a), &Bool(b)) => a == b,\n-            (&Struct(a), &Struct(b)) => a == b,\n-            (&Tuple(a), &Tuple(b)) => a == b,\n-            (&Function(a), &Function(b)) => a == b,\n-            (&Array(a, an), &Array(b, bn)) => (a == b) && (an == bn),\n-            (&Repeat(a, an), &Repeat(b, bn)) => (a == b) && (an == bn),\n-            (&Char(a), &Char(b)) => a == b,\n-            (&Dummy, &Dummy) => true, // FIXME: should this be false?\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl Eq for ConstVal { }\n-\n impl ConstVal {\n     pub fn description(&self) -> &'static str {\n         match *self {\n-            Float(_) => \"float\",\n+            Float(f) => f.description(),\n             Integral(i) => i.description(),\n             Str(_) => \"string literal\",\n             ByteStr(_) => \"byte string literal\","}, {"sha": "5637b44335e0fc65586f4faf1863208565c6aa5c", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -621,18 +621,19 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match (eval_const_expr_partial(tcx, &a, ty_hint, fn_args)?,\n                eval_const_expr_partial(tcx, &b, b_ty, fn_args)?) {\n           (Float(a), Float(b)) => {\n+            use std::cmp::Ordering::*;\n             match op.node {\n-              hir::BiAdd => Float(a + b),\n-              hir::BiSub => Float(a - b),\n-              hir::BiMul => Float(a * b),\n-              hir::BiDiv => Float(a / b),\n-              hir::BiRem => Float(a % b),\n-              hir::BiEq => Bool(a == b),\n-              hir::BiLt => Bool(a < b),\n-              hir::BiLe => Bool(a <= b),\n-              hir::BiNe => Bool(a != b),\n-              hir::BiGe => Bool(a >= b),\n-              hir::BiGt => Bool(a > b),\n+              hir::BiAdd => Float(math!(e, a + b)),\n+              hir::BiSub => Float(math!(e, a - b)),\n+              hir::BiMul => Float(math!(e, a * b)),\n+              hir::BiDiv => Float(math!(e, a / b)),\n+              hir::BiRem => Float(math!(e, a % b)),\n+              hir::BiEq => Bool(math!(e, a.try_cmp(b)) == Equal),\n+              hir::BiLt => Bool(math!(e, a.try_cmp(b)) == Less),\n+              hir::BiLe => Bool(math!(e, a.try_cmp(b)) != Greater),\n+              hir::BiNe => Bool(math!(e, a.try_cmp(b)) != Equal),\n+              hir::BiGe => Bool(math!(e, a.try_cmp(b)) != Less),\n+              hir::BiGt => Bool(math!(e, a.try_cmp(b)) == Greater),\n               _ => signal!(e, InvalidOpForFloats(op.node)),\n             }\n           }\n@@ -1078,13 +1079,13 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::\n             }\n         },\n         ty::TyFloat(ast::FloatTy::F64) => match val.erase_type() {\n-            Infer(u) => Ok(Float(u as f64)),\n-            InferSigned(i) => Ok(Float(i as f64)),\n+            Infer(u) => Ok(Float(F64(u as f64))),\n+            InferSigned(i) => Ok(Float(F64(i as f64))),\n             _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n         },\n         ty::TyFloat(ast::FloatTy::F32) => match val.erase_type() {\n-            Infer(u) => Ok(Float(u as f32 as f64)),\n-            InferSigned(i) => Ok(Float(i as f32 as f64)),\n+            Infer(u) => Ok(Float(F32(u as f32))),\n+            InferSigned(i) => Ok(Float(F32(i as f32))),\n             _ => bug!(\"ConstInt::erase_type returned something other than Infer/InferSigned\"),\n         },\n         ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n@@ -1097,13 +1098,35 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::\n     }\n }\n \n-fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, f: f64, ty: ty::Ty) -> CastResult {\n+fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              val: ConstFloat,\n+                              ty: ty::Ty) -> CastResult {\n     match ty.sty {\n-        ty::TyInt(_) if f >= 0.0 => cast_const_int(tcx, Infer(f as u64), ty),\n-        ty::TyInt(_) => cast_const_int(tcx, InferSigned(f as i64), ty),\n-        ty::TyUint(_) if f >= 0.0 => cast_const_int(tcx, Infer(f as u64), ty),\n-        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(f)),\n-        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(f as f32 as f64)),\n+        ty::TyInt(_) | ty::TyUint(_) => {\n+            let i = match val {\n+                F32(f) if f >= 0.0 => Infer(f as u64),\n+                FInfer { f64: f, .. } |\n+                F64(f) if f >= 0.0 => Infer(f as u64),\n+\n+                F32(f) => InferSigned(f as i64),\n+                FInfer { f64: f, .. } |\n+                F64(f) => InferSigned(f as i64)\n+            };\n+\n+            if let (InferSigned(_), &ty::TyUint(_)) = (i, &ty.sty) {\n+                return Err(CannotCast);\n+            }\n+\n+            cast_const_int(tcx, i, ty)\n+        }\n+        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(match val {\n+            F32(f) => f as f64,\n+            FInfer { f64: f, .. } | F64(f) => f\n+        }))),\n+        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(match val {\n+            F64(f) => f as f32,\n+            FInfer { f32: f, .. } | F32(f) => f\n+        }))),\n         _ => Err(CannotCast),\n     }\n }\n@@ -1161,33 +1184,43 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n             infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n-        LitKind::Float(ref n, _) |\n+        LitKind::Float(ref n, fty) => {\n+            Ok(Float(parse_float(n, Some(fty), span)))\n+        }\n         LitKind::FloatUnsuffixed(ref n) => {\n-            if let Ok(x) = n.parse::<f64>() {\n-                Ok(Float(x))\n-            } else {\n-                // FIXME(#31407) this is only necessary because float parsing is buggy\n-                span_bug!(span, \"could not evaluate float literal (see issue #31407)\");\n-            }\n+            let fty_hint = match ty_hint.map(|t| &t.sty) {\n+                Some(&ty::TyFloat(fty)) => Some(fty),\n+                _ => None\n+            };\n+            Ok(Float(parse_float(n, fty_hint, span)))\n         }\n         LitKind::Bool(b) => Ok(Bool(b)),\n         LitKind::Char(c) => Ok(Char(c)),\n     }\n }\n \n+fn parse_float(num: &str, fty_hint: Option<ast::FloatTy>, span: Span) -> ConstFloat {\n+    let val = match fty_hint {\n+        Some(ast::FloatTy::F32) => num.parse::<f32>().map(F32),\n+        Some(ast::FloatTy::F64) => num.parse::<f64>().map(F64),\n+        None => {\n+            num.parse::<f32>().and_then(|f32| {\n+                num.parse::<f64>().map(|f64| {\n+                    FInfer { f32: f32, f64: f64 }\n+                })\n+            })\n+        }\n+    };\n+    val.unwrap_or_else(|_| {\n+        // FIXME(#31407) this is only necessary because float parsing is buggy\n+        span_bug!(span, \"could not evaluate float literal (see issue #31407)\");\n+    })\n+}\n+\n pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n     match (a, b) {\n         (&Integral(a), &Integral(b)) => a.try_cmp(b).ok(),\n-        (&Float(a), &Float(b)) => {\n-            // This is pretty bad but it is the existing behavior.\n-            Some(if a == b {\n-                Ordering::Equal\n-            } else if a < b {\n-                Ordering::Less\n-            } else {\n-                Ordering::Greater\n-            })\n-        }\n+        (&Float(a), &Float(b)) => a.try_cmp(b).ok(),\n         (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n         (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n         (&ByteStr(ref a), &ByteStr(ref b)) => Some(a.cmp(b)),"}, {"sha": "e4eb0f2c97eb9d5bf77f276155e17804d934ed82", "filename": "src/librustc_const_math/err.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -45,17 +45,17 @@ impl ConstMathErr {\n         use self::Op::*;\n         match *self {\n             NotInRange => \"inferred value out of range\",\n-            CmpBetweenUnequalTypes => \"compared two integrals of different types\",\n-            UnequalTypes(Add) => \"tried to add two integrals of different types\",\n-            UnequalTypes(Sub) => \"tried to subtract two integrals of different types\",\n-            UnequalTypes(Mul) => \"tried to multiply two integrals of different types\",\n-            UnequalTypes(Div) => \"tried to divide two integrals of different types\",\n+            CmpBetweenUnequalTypes => \"compared two values of different types\",\n+            UnequalTypes(Add) => \"tried to add two values of different types\",\n+            UnequalTypes(Sub) => \"tried to subtract two values of different types\",\n+            UnequalTypes(Mul) => \"tried to multiply two values of different types\",\n+            UnequalTypes(Div) => \"tried to divide two values of different types\",\n             UnequalTypes(Rem) => {\n-                \"tried to calculate the remainder of two integrals of different types\"\n+                \"tried to calculate the remainder of two values of different types\"\n             },\n-            UnequalTypes(BitAnd) => \"tried to bitand two integrals of different types\",\n-            UnequalTypes(BitOr) => \"tried to bitor two integrals of different types\",\n-            UnequalTypes(BitXor) => \"tried to xor two integrals of different types\",\n+            UnequalTypes(BitAnd) => \"tried to bitand two values of different types\",\n+            UnequalTypes(BitOr) => \"tried to bitor two values of different types\",\n+            UnequalTypes(BitXor) => \"tried to xor two values of different types\",\n             UnequalTypes(_) => unreachable!(),\n             Overflow(Add) => \"attempted to add with overflow\",\n             Overflow(Sub) => \"attempted to subtract with overflow\","}, {"sha": "4610c183e1b1f3f52f3809738bc1e366df36b7ed", "filename": "src/librustc_const_math/float.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cmp::Ordering;\n+use std::hash;\n+use std::mem::transmute;\n+\n+use super::err::*;\n+\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum ConstFloat {\n+    F32(f32),\n+    F64(f64),\n+\n+    // When the type isn't known, we have to operate on both possibilities.\n+    FInfer {\n+        f32: f32,\n+        f64: f64\n+    }\n+}\n+pub use self::ConstFloat::*;\n+\n+impl ConstFloat {\n+    /// Description of the type, not the value\n+    pub fn description(&self) -> &'static str {\n+        match *self {\n+            FInfer {..} => \"float\",\n+            F32(_) => \"f32\",\n+            F64(_) => \"f64\",\n+        }\n+    }\n+\n+    pub fn is_nan(&self) -> bool {\n+        match *self {\n+            F32(f) => f.is_nan(),\n+            F64(f) => f.is_nan(),\n+            FInfer { f32, f64 } => f32.is_nan() || f64.is_nan()\n+        }\n+    }\n+\n+    /// Compares the values if they are of the same type\n+    pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n+        match (self, rhs) {\n+            (F64(a), F64(b)) |\n+            (F64(a), FInfer { f64: b, .. }) |\n+            (FInfer { f64: a, .. }, F64(b)) |\n+            (FInfer { f64: a, .. }, FInfer { f64: b, .. })  => {\n+                // This is pretty bad but it is the existing behavior.\n+                Ok(if a == b {\n+                    Ordering::Equal\n+                } else if a < b {\n+                    Ordering::Less\n+                } else {\n+                    Ordering::Greater\n+                })\n+            }\n+\n+            (F32(a), F32(b)) |\n+            (F32(a), FInfer { f32: b, .. }) |\n+            (FInfer { f32: a, .. }, F32(b)) => {\n+                Ok(if a == b {\n+                    Ordering::Equal\n+                } else if a < b {\n+                    Ordering::Less\n+                } else {\n+                    Ordering::Greater\n+                })\n+            }\n+\n+            _ => Err(CmpBetweenUnequalTypes),\n+        }\n+    }\n+}\n+\n+/// Note that equality for `ConstFloat` means that the it is the same\n+/// constant, not that the rust values are equal. In particular, `NaN\n+/// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n+/// are considering unequal).\n+impl PartialEq for ConstFloat {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (*self, *other) {\n+            (F64(a), F64(b)) |\n+            (F64(a), FInfer { f64: b, .. }) |\n+            (FInfer { f64: a, .. }, F64(b)) |\n+            (FInfer { f64: a, .. }, FInfer { f64: b, .. }) => {\n+                unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)}\n+            }\n+            (F32(a), F32(b)) => {\n+                unsafe{transmute::<_,u32>(a) == transmute::<_,u32>(b)}\n+            }\n+            _ => false\n+        }\n+    }\n+}\n+\n+impl Eq for ConstFloat {}\n+\n+impl hash::Hash for ConstFloat {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        match *self {\n+            F64(a) | FInfer { f64: a, .. } => {\n+                unsafe { transmute::<_,u64>(a) }.hash(state)\n+            }\n+            F32(a) => {\n+                unsafe { transmute::<_,u32>(a) }.hash(state)\n+            }\n+        }\n+    }\n+}\n+\n+impl ::std::fmt::Display for ConstFloat {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        match *self {\n+            FInfer { f64, .. } => write!(fmt, \"{}\", f64),\n+            F32(f) => write!(fmt, \"{}f32\", f),\n+            F64(f) => write!(fmt, \"{}f64\", f),\n+        }\n+    }\n+}\n+\n+macro_rules! derive_binop {\n+    ($op:ident, $func:ident) => {\n+        impl ::std::ops::$op for ConstFloat {\n+            type Output = Result<Self, ConstMathErr>;\n+            fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n+                match (self, rhs) {\n+                    (F32(a), F32(b)) |\n+                    (F32(a), FInfer { f32: b, .. }) |\n+                    (FInfer { f32: a, .. }, F32(b)) => Ok(F32(a.$func(b))),\n+\n+                    (F64(a), F64(b)) |\n+                    (FInfer { f64: a, .. }, F64(b)) |\n+                    (F64(a), FInfer { f64: b, .. }) => Ok(F64(a.$func(b))),\n+\n+                    (FInfer { f32: a32, f64: a64 },\n+                     FInfer { f32: b32, f64: b64 }) => Ok(FInfer {\n+                        f32: a32.$func(b32),\n+                        f64: a64.$func(b64)\n+                    }),\n+\n+                    _ => Err(UnequalTypes(Op::$op)),\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+derive_binop!(Add, add);\n+derive_binop!(Sub, sub);\n+derive_binop!(Mul, mul);\n+derive_binop!(Div, div);\n+derive_binop!(Rem, rem);\n+\n+impl ::std::ops::Neg for ConstFloat {\n+    type Output = Self;\n+    fn neg(self) -> Self {\n+        match self {\n+            F32(f) => F32(-f),\n+            F64(f) => F64(-f),\n+            FInfer { f32, f64 } => FInfer {\n+                f32: -f32,\n+                f64: -f64\n+            }\n+        }\n+    }\n+}"}, {"sha": "741dd4107e001e0886d8484fb744e01445357ad9", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -32,11 +32,13 @@\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+mod float;\n mod int;\n mod us;\n mod is;\n mod err;\n \n+pub use float::*;\n pub use int::*;\n pub use us::*;\n pub use is::*;"}, {"sha": "c3501140fc0a51e5292ac58cc375fd33ee4c8ff2", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -56,7 +56,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     // Returns a zero literal operand for the appropriate type, works for\n-    // bool, char, integers and floats.\n+    // bool, char and integers.\n     pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = match ty.sty {\n             ty::TyBool => {\n@@ -93,7 +93,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 Literal::Value { value: ConstVal::Integral(val) }\n             }\n-            ty::TyFloat(_) => Literal::Value { value: ConstVal::Float(0.0) },\n             _ => {\n                 span_bug!(span, \"Invalid type for zero_literal: `{:?}`\", ty)\n             }"}, {"sha": "f5fdd87b167a1a7425cf6b6e4a3d765cef918bda", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -12,6 +12,7 @@ use llvm::{self, ValueRef};\n use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::ErrKind;\n use rustc_const_math::ConstInt::*;\n+use rustc_const_math::ConstFloat::*;\n use rustc_const_math::ConstMathErr;\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n@@ -63,7 +64,9 @@ impl<'tcx> Const<'tcx> {\n                              -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n         let val = match cv {\n-            ConstVal::Float(v) => C_floating_f64(v, llty),\n+            ConstVal::Float(F32(v)) => C_floating_f64(v as f64, llty),\n+            ConstVal::Float(F64(v)) => C_floating_f64(v, llty),\n+            ConstVal::Float(FInfer {..}) => bug!(\"MIR must not use `{:?}`\", cv),\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(I8(v)) => C_integral(Type::i8(ccx), v as u64, true),\n             ConstVal::Integral(I16(v)) => C_integral(Type::i16(ccx), v as u64, true),\n@@ -81,14 +84,14 @@ impl<'tcx> Const<'tcx> {\n                 let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n                 C_integral(Type::int(ccx), u, false)\n             },\n-            ConstVal::Integral(Infer(v)) => C_integral(llty, v as u64, false),\n-            ConstVal::Integral(InferSigned(v)) => C_integral(llty, v as u64, true),\n+            ConstVal::Integral(Infer(_)) |\n+            ConstVal::Integral(InferSigned(_)) => bug!(\"MIR must not use `{:?}`\", cv),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n             ConstVal::Struct(_) | ConstVal::Tuple(_) |\n             ConstVal::Array(..) | ConstVal::Repeat(..) |\n             ConstVal::Function(_) => {\n-                bug!(\"MIR must not use {:?} (which refers to a local ID)\", cv)\n+                bug!(\"MIR must not use `{:?}` (which refers to a local ID)\", cv)\n             }\n             ConstVal::Char(c) => C_integral(Type::char(ccx), c as u64, false),\n             ConstVal::Dummy => bug!(),"}, {"sha": "ff80a4e305359c1349df1bb6c50062e4ef231423", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -1382,7 +1382,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[rustc_no_mir] // FIXME #27840 MIR NAN ends up negative.\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f32.integer_decode(), (13176795, -22, 1));\n         assert_eq!((-8573.5918555f32).integer_decode(), (8779358, -10, -1));\n@@ -1391,7 +1390,11 @@ mod tests {\n         assert_eq!((-0f32).integer_decode(), (0, -150, -1));\n         assert_eq!(INFINITY.integer_decode(), (8388608, 105, 1));\n         assert_eq!(NEG_INFINITY.integer_decode(), (8388608, 105, -1));\n-        assert_eq!(NAN.integer_decode(), (12582912, 105, 1));\n+\n+        // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+        // It can vary between runtime operations and LLVM folding.\n+        let (nan_m, nan_e, _nan_s) = NAN.integer_decode();\n+        assert_eq!((nan_m, nan_e), (12582912, 105));\n     }\n \n     #[test]"}, {"sha": "b775031787084c97cf7efe85a1c8bb0c4cc946f7", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -1277,7 +1277,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[rustc_no_mir] // FIXME #27840 MIR NAN ends up negative.\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906, -51, 1));\n         assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931, -39, -1));\n@@ -1286,7 +1285,11 @@ mod tests {\n         assert_eq!((-0f64).integer_decode(), (0, -1075, -1));\n         assert_eq!(INFINITY.integer_decode(), (4503599627370496, 972, 1));\n         assert_eq!(NEG_INFINITY.integer_decode(), (4503599627370496, 972, -1));\n-        assert_eq!(NAN.integer_decode(), (6755399441055744, 972, 1));\n+\n+        // Ignore the \"sign\" (quiet / signalling flag) of NAN.\n+        // It can vary between runtime operations and LLVM folding.\n+        let (nan_m, nan_e, _nan_s) = NAN.integer_decode();\n+        assert_eq!((nan_m, nan_e), (6755399441055744, 972));\n     }\n \n     #[test]"}, {"sha": "ea49cf3e7bedb66cd0069980e7cd6bb4e009fe41", "filename": "src/test/run-pass/issue-32805.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Ftest%2Frun-pass%2Fissue-32805.rs", "raw_url": "https://github.com/rust-lang/rust/raw/763f9234b052c7911dc4cf952a81a85c51c57784/src%2Ftest%2Frun-pass%2Fissue-32805.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-32805.rs?ref=763f9234b052c7911dc4cf952a81a85c51c57784", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_mir]\n+fn const_mir() -> f32 { 9007199791611905.0 }\n+\n+#[rustc_no_mir]\n+fn const_old() -> f32 { 9007199791611905.0 }\n+\n+fn main() {\n+    let original = \"9007199791611905.0\"; // (1<<53)+(1<<29)+1\n+    let expected = \"9007200000000000\";\n+\n+    assert_eq!(const_mir().to_string(), expected);\n+    assert_eq!(const_old().to_string(), expected);\n+    assert_eq!(original.parse::<f32>().unwrap().to_string(), expected);\n+}"}]}