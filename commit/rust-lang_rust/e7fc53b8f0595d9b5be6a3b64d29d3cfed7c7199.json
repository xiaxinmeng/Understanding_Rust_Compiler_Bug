{"sha": "e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZmM1M2I4ZjA1OTVkOWI1YmU2YTNiNjRkMjlkM2NmZWQ3YzcxOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-09T14:25:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-09T14:25:04Z"}, "message": "Auto merge of #39686 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 5 pull requests\n\n- Successful merges: #39595, #39601, #39602, #39615, #39647\n- Failed merges:", "tree": {"sha": "1b65f5fd9621cfea56eafd05603c31eaf4cc2ae8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b65f5fd9621cfea56eafd05603c31eaf4cc2ae8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "html_url": "https://github.com/rust-lang/rust/commit/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1129ce51a6cc83ea7d7283fce194948feef4e319", "url": "https://api.github.com/repos/rust-lang/rust/commits/1129ce51a6cc83ea7d7283fce194948feef4e319", "html_url": "https://github.com/rust-lang/rust/commit/1129ce51a6cc83ea7d7283fce194948feef4e319"}, {"sha": "116bdacf6bedaba3d9ec83d202e2ca6fa54d8395", "url": "https://api.github.com/repos/rust-lang/rust/commits/116bdacf6bedaba3d9ec83d202e2ca6fa54d8395", "html_url": "https://github.com/rust-lang/rust/commit/116bdacf6bedaba3d9ec83d202e2ca6fa54d8395"}], "stats": {"total": 466, "additions": 279, "deletions": 187}, "files": [{"sha": "29a5e7bcafb7abf330cb3920c83bf727f265d8f5", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -14,6 +14,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   zlib1g-dev \\\n   g++-arm-linux-gnueabi \\\n   g++-arm-linux-gnueabihf \\\n+  gcc-sparc64-linux-gnu \\\n+  libc6-dev-sparc64-cross \\\n   bzip2 \\\n   patch\n \n@@ -60,9 +62,11 @@ ENV TARGETS=$TARGETS,mipsel-unknown-linux-musl\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,arm-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n+ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n \n ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n-    CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc\n+    CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n+    CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc\n \n # Suppress some warnings in the openwrt toolchains we downloaded\n ENV STAGING_DIR=/tmp"}, {"sha": "50248fabfcd451e879df2855fb59604b64b34dec", "filename": "src/libcore/fmt/float.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use fmt::{Formatter, Result, LowerExp, UpperExp, Display, Debug};\n+use num::flt2dec;\n+\n+// Common code of floating point Debug and Display.\n+fn float_to_decimal_common<T>(fmt: &mut Formatter, num: &T, negative_zero: bool) -> Result\n+    where T: flt2dec::DecodableFloat\n+{\n+    let force_sign = fmt.sign_plus();\n+    let sign = match (force_sign, negative_zero) {\n+        (false, false) => flt2dec::Sign::Minus,\n+        (false, true)  => flt2dec::Sign::MinusRaw,\n+        (true,  false) => flt2dec::Sign::MinusPlus,\n+        (true,  true)  => flt2dec::Sign::MinusPlusRaw,\n+    };\n+\n+    let mut buf = [0; 1024]; // enough for f32 and f64\n+    let mut parts = [flt2dec::Part::Zero(0); 16];\n+    let formatted = if let Some(precision) = fmt.precision {\n+        flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n+                                    precision, false, &mut buf, &mut parts)\n+    } else {\n+        flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n+                                 0, false, &mut buf, &mut parts)\n+    };\n+    fmt.pad_formatted_parts(&formatted)\n+}\n+\n+// Common code of floating point LowerExp and UpperExp.\n+fn float_to_exponential_common<T>(fmt: &mut Formatter, num: &T, upper: bool) -> Result\n+    where T: flt2dec::DecodableFloat\n+{\n+    let force_sign = fmt.sign_plus();\n+    let sign = match force_sign {\n+        false => flt2dec::Sign::Minus,\n+        true  => flt2dec::Sign::MinusPlus,\n+    };\n+\n+    let mut buf = [0; 1024]; // enough for f32 and f64\n+    let mut parts = [flt2dec::Part::Zero(0); 16];\n+    let formatted = if let Some(precision) = fmt.precision {\n+        // 1 integral digit + `precision` fractional digits = `precision + 1` total digits\n+        flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n+                                  precision + 1, upper, &mut buf, &mut parts)\n+    } else {\n+        flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n+                                     (0, 0), upper, &mut buf, &mut parts)\n+    };\n+    fmt.pad_formatted_parts(&formatted)\n+}\n+\n+macro_rules! floating {\n+    ($ty:ident) => (\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Debug for $ty {\n+            fn fmt(&self, fmt: &mut Formatter) -> Result {\n+                float_to_decimal_common(fmt, self, true)\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Display for $ty {\n+            fn fmt(&self, fmt: &mut Formatter) -> Result {\n+                float_to_decimal_common(fmt, self, false)\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl LowerExp for $ty {\n+            fn fmt(&self, fmt: &mut Formatter) -> Result {\n+                float_to_exponential_common(fmt, self, false)\n+            }\n+        }\n+\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl UpperExp for $ty {\n+            fn fmt(&self, fmt: &mut Formatter) -> Result {\n+                float_to_exponential_common(fmt, self, true)\n+            }\n+        }\n+    )\n+}\n+\n+floating! { f32 }\n+floating! { f64 }"}, {"sha": "eb086c201812a3f0c9e3671c2abed863615aff66", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 83, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -21,6 +21,10 @@ use result;\n use slice;\n use str;\n \n+mod float;\n+mod num;\n+mod builders;\n+\n #[unstable(feature = \"fmt_flags_align\", issue = \"27726\")]\n /// Possible alignments returned by `Formatter::align`\n #[derive(Debug)]\n@@ -38,9 +42,6 @@ pub enum Alignment {\n #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n pub use self::builders::{DebugStruct, DebugTuple, DebugSet, DebugList, DebugMap};\n \n-mod num;\n-mod builders;\n-\n #[unstable(feature = \"fmt_internals\", reason = \"internal to format_args!\",\n            issue = \"0\")]\n #[doc(hidden)]\n@@ -1511,86 +1512,6 @@ impl<'a, T: ?Sized> Pointer for &'a mut T {\n     }\n }\n \n-// Common code of floating point Debug and Display.\n-fn float_to_decimal_common<T>(fmt: &mut Formatter, num: &T, negative_zero: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n-{\n-    let force_sign = fmt.sign_plus();\n-    let sign = match (force_sign, negative_zero) {\n-        (false, false) => flt2dec::Sign::Minus,\n-        (false, true)  => flt2dec::Sign::MinusRaw,\n-        (true,  false) => flt2dec::Sign::MinusPlus,\n-        (true,  true)  => flt2dec::Sign::MinusPlusRaw,\n-    };\n-\n-    let mut buf = [0; 1024]; // enough for f32 and f64\n-    let mut parts = [flt2dec::Part::Zero(0); 16];\n-    let formatted = if let Some(precision) = fmt.precision {\n-        flt2dec::to_exact_fixed_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n-                                    precision, false, &mut buf, &mut parts)\n-    } else {\n-        flt2dec::to_shortest_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n-                                 0, false, &mut buf, &mut parts)\n-    };\n-    fmt.pad_formatted_parts(&formatted)\n-}\n-\n-// Common code of floating point LowerExp and UpperExp.\n-fn float_to_exponential_common<T>(fmt: &mut Formatter, num: &T, upper: bool) -> Result\n-    where T: flt2dec::DecodableFloat\n-{\n-    let force_sign = fmt.sign_plus();\n-    let sign = match force_sign {\n-        false => flt2dec::Sign::Minus,\n-        true  => flt2dec::Sign::MinusPlus,\n-    };\n-\n-    let mut buf = [0; 1024]; // enough for f32 and f64\n-    let mut parts = [flt2dec::Part::Zero(0); 16];\n-    let formatted = if let Some(precision) = fmt.precision {\n-        // 1 integral digit + `precision` fractional digits = `precision + 1` total digits\n-        flt2dec::to_exact_exp_str(flt2dec::strategy::grisu::format_exact, *num, sign,\n-                                  precision + 1, upper, &mut buf, &mut parts)\n-    } else {\n-        flt2dec::to_shortest_exp_str(flt2dec::strategy::grisu::format_shortest, *num, sign,\n-                                     (0, 0), upper, &mut buf, &mut parts)\n-    };\n-    fmt.pad_formatted_parts(&formatted)\n-}\n-\n-macro_rules! floating { ($ty:ident) => {\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Debug for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_decimal_common(fmt, self, true)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl Display for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_decimal_common(fmt, self, false)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl LowerExp for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_exponential_common(fmt, self, false)\n-        }\n-    }\n-\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl UpperExp for $ty {\n-        fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            float_to_exponential_common(fmt, self, true)\n-        }\n-    }\n-} }\n-floating! { f32 }\n-floating! { f64 }\n-\n // Implementation of Display/Debug for various core types\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "695001312e4d5aeac1a40c15f9b0b9397906a8bd", "filename": "src/libcoretest/fmt/float.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibcoretest%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibcoretest%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Ffloat.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -9,11 +9,29 @@\n // except according to those terms.\n \n #[test]\n-fn test_format_float() {\n-    assert!(\"1\" == format!(\"{:.0}\", 1.0f64));\n-    assert!(\"9\" == format!(\"{:.0}\", 9.4f64));\n-    assert!(\"10\" == format!(\"{:.0}\", 9.9f64));\n-    assert!(\"9.8\" == format!(\"{:.1}\", 9.849f64));\n-    assert!(\"9.9\" == format!(\"{:.1}\", 9.851f64));\n-    assert!(\"1\" == format!(\"{:.0}\", 0.5f64));\n+fn test_format_f64() {\n+    assert_eq!(\"1\", format!(\"{:.0}\", 1.0f64));\n+    assert_eq!(\"9\", format!(\"{:.0}\", 9.4f64));\n+    assert_eq!(\"10\", format!(\"{:.0}\", 9.9f64));\n+    assert_eq!(\"9.8\", format!(\"{:.1}\", 9.849f64));\n+    assert_eq!(\"9.9\", format!(\"{:.1}\", 9.851f64));\n+    assert_eq!(\"1\", format!(\"{:.0}\", 0.5f64));\n+    assert_eq!(\"1.23456789e6\", format!(\"{:e}\", 1234567.89f64));\n+    assert_eq!(\"1.23456789e3\", format!(\"{:e}\", 1234.56789f64));\n+    assert_eq!(\"1.23456789E6\", format!(\"{:E}\", 1234567.89f64));\n+    assert_eq!(\"1.23456789E3\", format!(\"{:E}\", 1234.56789f64));\n+}\n+\n+#[test]\n+fn test_format_f32() {\n+    assert_eq!(\"1\", format!(\"{:.0}\", 1.0f32));\n+    assert_eq!(\"9\", format!(\"{:.0}\", 9.4f32));\n+    assert_eq!(\"10\", format!(\"{:.0}\", 9.9f32));\n+    assert_eq!(\"9.8\", format!(\"{:.1}\", 9.849f32));\n+    assert_eq!(\"9.9\", format!(\"{:.1}\", 9.851f32));\n+    assert_eq!(\"1\", format!(\"{:.0}\", 0.5f32));\n+    assert_eq!(\"1.2345679e6\", format!(\"{:e}\", 1234567.89f32));\n+    assert_eq!(\"1.2345679e3\", format!(\"{:e}\", 1234.56789f32));\n+    assert_eq!(\"1.2345679E6\", format!(\"{:E}\", 1234567.89f32));\n+    assert_eq!(\"1.2345679E3\", format!(\"{:E}\", 1234.56789f32));\n }"}, {"sha": "8d8264b967a31a1a8cebe2a05110564106b6e909", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -1 +1 @@\n-Subproject commit cb7f66732175e6171587ed69656b7aae7dd2e6ec\n+Subproject commit 8d8264b967a31a1a8cebe2a05110564106b6e909"}, {"sha": "627753039bae3af63540160913ace07d18d34f0c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -202,7 +202,9 @@ impl<'tcx> cmt_<'tcx> {\n             Categorization::Downcast(ref cmt, _) => {\n                 if let Categorization::Local(_) = cmt.cat {\n                     if let ty::TyAdt(def, _) = self.ty.sty {\n-                        return def.struct_variant().find_field_named(name).map(|x| x.did);\n+                        if def.is_struct() {\n+                            return def.struct_variant().find_field_named(name).map(|x| x.did);\n+                        }\n                     }\n                     None\n                 } else {"}, {"sha": "6203679a510585ef03ae82a7e475d5d44a022725", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -26,6 +26,7 @@ use middle::resolve_lifetime;\n use middle::stability;\n use mir::Mir;\n use ty::subst::{Kind, Substs};\n+use ty::ReprOptions;\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n@@ -672,9 +673,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn alloc_adt_def(self,\n                          did: DefId,\n                          kind: AdtKind,\n-                         variants: Vec<ty::VariantDef>)\n+                         variants: Vec<ty::VariantDef>,\n+                         repr: ReprOptions)\n                          -> &'gcx ty::AdtDef {\n-        let def = ty::AdtDef::new(self, did, kind, variants);\n+        let def = ty::AdtDef::new(self, did, kind, variants, repr);\n         self.global_arenas.adt_def.alloc(def)\n     }\n "}, {"sha": "3a463e981a6272e152b598113b32bdd4154de9fd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 39, "deletions": 63, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -15,7 +15,7 @@ pub use self::Primitive::*;\n use infer::InferCtxt;\n use session::Session;\n use traits;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n \n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n@@ -437,7 +437,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr(tcx: TyCtxt, ty: Ty, hints: &[attr::ReprAttr], min: i64, max: i64)\n+    fn repr_discr(tcx: TyCtxt, ty: Ty, repr: &ReprOptions, min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -449,34 +449,24 @@ impl Integer {\n         let mut min_from_extern = None;\n         let min_default = I8;\n \n-        for &r in hints.iter() {\n-            match r {\n-                attr::ReprInt(ity) => {\n-                    let discr = Integer::from_attr(&tcx.data_layout, ity);\n-                    let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n-                    if discr < fit {\n-                        bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n-                              discriminant range of enum `{}\", ty)\n-                    }\n-                    return (discr, ity.is_signed());\n-                }\n-                attr::ReprExtern => {\n-                    match &tcx.sess.target.target.arch[..] {\n-                        // WARNING: the ARM EABI has two variants; the one corresponding\n-                        // to `at_least == I32` appears to be used on Linux and NetBSD,\n-                        // but some systems may use the variant corresponding to no\n-                        // lower bound.  However, we don't run on those yet...?\n-                        \"arm\" => min_from_extern = Some(I32),\n-                        _ => min_from_extern = Some(I32),\n-                    }\n-                }\n-                attr::ReprAny => {},\n-                attr::ReprPacked => {\n-                    bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n-                }\n-                attr::ReprSimd => {\n-                    bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n-                }\n+        if let Some(ity) = repr.int {\n+            let discr = Integer::from_attr(&tcx.data_layout, ity);\n+            let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+            if discr < fit {\n+                bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                  discriminant range of enum `{}\", ty)\n+            }\n+            return (discr, ity.is_signed());\n+        }\n+\n+        if repr.c {\n+            match &tcx.sess.target.target.arch[..] {\n+                // WARNING: the ARM EABI has two variants; the one corresponding\n+                // to `at_least == I32` appears to be used on Linux and NetBSD,\n+                // but some systems may use the variant corresponding to no\n+                // lower bound.  However, we don't run on those yet...?\n+                \"arm\" => min_from_extern = Some(I32),\n+                _ => min_from_extern = Some(I32),\n             }\n         }\n \n@@ -568,9 +558,9 @@ enum StructKind {\n impl<'a, 'gcx, 'tcx> Struct {\n     // FIXME(camlorn): reprs need a better representation to deal with multiple reprs on one type.\n     fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n-                  reprs: &[attr::ReprAttr], kind: StructKind,\n+                  repr: &ReprOptions, kind: StructKind,\n                   scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n-        let packed = reprs.contains(&attr::ReprPacked);\n+        let packed = repr.packed;\n         let mut ret = Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             packed: packed,\n@@ -580,27 +570,16 @@ impl<'a, 'gcx, 'tcx> Struct {\n             min_size: Size::from_bytes(0),\n         };\n \n-        // Anything with ReprExtern or ReprPacked doesn't optimize.\n+        // Anything with repr(C) or repr(packed) doesn't optimize.\n         // Neither do  1-member and 2-member structs.\n         // In addition, code in trans assume that 2-element structs can become pairs.\n         // It's easier to just short-circuit here.\n-        let mut can_optimize = fields.len() > 2 || StructKind::EnumVariant == kind;\n-        if can_optimize {\n-            // This exhaustive match makes new reprs force the adder to modify this function.\n-            // Otherwise, things can silently break.\n-            // Note the inversion, return true to stop optimizing.\n-            can_optimize = !reprs.iter().any(|r| {\n-                match *r {\n-                    attr::ReprAny | attr::ReprInt(_) => false,\n-                    attr::ReprExtern | attr::ReprPacked => true,\n-                    attr::ReprSimd => bug!(\"Simd  vectors should be represented as layout::Vector\")\n-                }\n-            });\n-        }\n+        let mut can_optimize = (fields.len() > 2 || StructKind::EnumVariant == kind)\n+            && ! (repr.c || repr.packed);\n \n         // Disable field reordering until we can decide what to do.\n         // The odd pattern here avoids a warning about the value never being read.\n-        if can_optimize { can_optimize = false }\n+        if can_optimize { can_optimize = false; }\n \n         let (optimize, sort_ascending) = match kind {\n             StructKind::AlwaysSizedUnivariant => (can_optimize, false),\n@@ -1092,7 +1071,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // The never type.\n             ty::TyNever => Univariant {\n-                variant: Struct::new(dl, &vec![], &[],\n+                variant: Struct::new(dl, &vec![], &ReprOptions::default(),\n                   StructKind::AlwaysSizedUnivariant, ty)?,\n                 non_zero: false\n             },\n@@ -1135,12 +1114,12 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyFnDef(..) => {\n                 Univariant {\n                     variant: Struct::new(dl, &vec![],\n-                      &[], StructKind::AlwaysSizedUnivariant, ty)?,\n+                      &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?,\n                     non_zero: false\n                 }\n             }\n             ty::TyDynamic(..) => {\n-                let mut unit = Struct::new(dl, &vec![], &[],\n+                let mut unit = Struct::new(dl, &vec![], &ReprOptions::default(),\n                   StructKind::AlwaysSizedUnivariant, ty)?;\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }\n@@ -1152,7 +1131,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let st = Struct::new(dl,\n                     &tys.map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &[],\n+                    &ReprOptions::default(),\n                     StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n@@ -1163,7 +1142,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let st = Struct::new(dl,\n                     &tys.iter().map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &[], StructKind::AlwaysSizedUnivariant, ty)?;\n+                    &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n@@ -1187,16 +1166,13 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                let hints = &tcx.lookup_repr_hints(def.did)[..];\n-\n                 if def.variants.is_empty() {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hints.len(), 0);\n \n                     return success(Univariant {\n                         variant: Struct::new(dl, &vec![],\n-                          &hints[..], StructKind::AlwaysSizedUnivariant, ty)?,\n+                          &def.repr, StructKind::AlwaysSizedUnivariant, ty)?,\n                         non_zero: false\n                     });\n                 }\n@@ -1219,7 +1195,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                     // FIXME: should handle i128? signed-value based impl is weird and hard to\n                     // grok.\n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..],\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &def.repr,\n                                                               min,\n                                                               max);\n                     return success(CEnum {\n@@ -1232,7 +1208,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     });\n                 }\n \n-                if !def.is_enum() || def.variants.len() == 1 && hints.is_empty() {\n+                if !def.is_enum() || def.variants.len() == 1 {\n                     // Struct, or union, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n@@ -1259,7 +1235,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n-                        let st = Struct::new(dl, &fields, &hints[..],\n+                        let st = Struct::new(dl, &fields, &def.repr,\n                           kind, ty)?;\n                         let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n                         Univariant { variant: st, non_zero: non_zero }\n@@ -1282,7 +1258,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n-                if variants.len() == 2 && hints.is_empty() {\n+                if variants.len() == 2 && !def.repr.c {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n@@ -1315,7 +1291,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         let st = Struct::new(dl,\n                             &variants[discr].iter().map(|ty| ty.layout(infcx))\n                               .collect::<Result<Vec<_>, _>>()?,\n-                            &hints[..], StructKind::AlwaysSizedUnivariant, ty)?;\n+                            &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n \n                         // We have to fix the last element of path here.\n                         let mut i = *path.last().unwrap();\n@@ -1338,7 +1314,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // The general case.\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, ty, &hints[..], 0, discr_max);\n+                let (min_ity, _) = Integer::repr_discr(tcx, ty, &def.repr, 0, discr_max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n@@ -1356,7 +1332,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     fields.insert(0, &discr);\n                     let st = Struct::new(dl,\n                         &fields,\n-                        &hints[..], StructKind::EnumVariant, ty)?;\n+                        &def.repr, StructKind::EnumVariant, ty)?;\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n                     // It is important to skip the first field."}, {"sha": "beb286108a034cfd7e86181a6c04aa939a76fd35", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -1327,7 +1327,8 @@ pub struct AdtDef {\n     pub did: DefId,\n     pub variants: Vec<VariantDef>,\n     destructor: Cell<Option<DefId>>,\n-    flags: Cell<AdtFlags>\n+    flags: Cell<AdtFlags>,\n+    pub repr: ReprOptions,\n }\n \n impl PartialEq for AdtDef {\n@@ -1356,11 +1357,38 @@ impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n+/// Represents the repr options provided by the user,\n+#[derive(Copy, Clone, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n+pub struct ReprOptions {\n+    pub c: bool,\n+    pub packed: bool,\n+    pub simd: bool,\n+    pub int: Option<attr::IntType>,\n+}\n+\n+impl ReprOptions {\n+    pub fn new<'a, 'gcx, 'tcx>(tcx: &TyCtxt<'a, 'gcx, 'tcx>, did: DefId) -> ReprOptions {\n+        let mut ret = ReprOptions::default();\n+        let attrs = tcx.lookup_repr_hints(did);\n+        for r in attrs.iter() {\n+            match *r {\n+                attr::ReprExtern => ret.c = true,\n+                attr::ReprPacked => ret.packed = true,\n+                attr::ReprSimd => ret.simd = true,\n+                attr::ReprInt(i) => ret.int = Some(i),\n+                attr::ReprAny => (),\n+            }\n+        }\n+        ret\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n-           variants: Vec<VariantDef>) -> Self {\n+           variants: Vec<VariantDef>,\n+           repr: ReprOptions) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n@@ -1385,6 +1413,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             variants: variants,\n             flags: Cell::new(flags),\n             destructor: Cell::new(None),\n+            repr: repr,\n         }\n     }\n "}, {"sha": "bb99be20f64d30ed46e4c0e1a6f53bc7605782ea", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -425,8 +425,8 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::ForeignImmStatic => Def::Static(did, false),\n             EntryKind::MutStatic |\n             EntryKind::ForeignMutStatic => Def::Static(did, true),\n-            EntryKind::Struct(_) => Def::Struct(did),\n-            EntryKind::Union(_) => Def::Union(did),\n+            EntryKind::Struct(_, _) => Def::Struct(did),\n+            EntryKind::Union(_, _) => Def::Union(did),\n             EntryKind::Fn(_) |\n             EntryKind::ForeignFn(_) => Def::Fn(did),\n             EntryKind::Method(_) => Def::Method(did),\n@@ -435,7 +435,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Mod(_) => Def::Mod(did),\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n-            EntryKind::Enum => Def::Enum(did),\n+            EntryKind::Enum(_) => Def::Enum(did),\n             EntryKind::MacroDef(_) => Def::Macro(did),\n \n             EntryKind::ForeignMod |\n@@ -519,8 +519,8 @@ impl<'a, 'tcx> CrateMetadata {\n                    -> (ty::VariantDef, Option<DefIndex>) {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n-            EntryKind::Struct(data) |\n-            EntryKind::Union(data) => data.decode(self),\n+            EntryKind::Struct(data, _) |\n+            EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n@@ -547,7 +547,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n         let mut ctor_index = None;\n-        let variants = if let EntryKind::Enum = item.kind {\n+        let variants = if let EntryKind::Enum(_) = item.kind {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n@@ -561,14 +561,14 @@ impl<'a, 'tcx> CrateMetadata {\n             ctor_index = struct_ctor;\n             vec![variant]\n         };\n-        let kind = match item.kind {\n-            EntryKind::Enum => ty::AdtKind::Enum,\n-            EntryKind::Struct(_) => ty::AdtKind::Struct,\n-            EntryKind::Union(_) => ty::AdtKind::Union,\n+        let (kind, repr) = match item.kind {\n+            EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n+            EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n+            EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let adt = tcx.alloc_adt_def(did, kind, variants);\n+        let adt = tcx.alloc_adt_def(did, kind, variants, repr);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n             tcx.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n@@ -881,16 +881,16 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n         match self.entry(node_id).kind {\n-            EntryKind::Struct(data) |\n-            EntryKind::Union(data) |\n+            EntryKind::Struct(data, _) |\n+            EntryKind::Union(data, _) |\n             EntryKind::Variant(data) => data.decode(self).ctor_kind,\n             _ => CtorKind::Fictive,\n         }\n     }\n \n     pub fn get_struct_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n         match self.entry(node_id).kind {\n-            EntryKind::Struct(data) => {\n+            EntryKind::Struct(data, _) => {\n                 data.decode(self).struct_ctor.map(|index| self.local_def_id(index))\n             }\n             _ => None,"}, {"sha": "f4ff5f4626f3587e9a36ec97e7a61cd3352bacc4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -20,7 +20,7 @@ use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::traits::specialization_graph;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, ReprOptions};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FxHashMap, NodeSet};\n@@ -401,8 +401,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n         }\n \n+        let repr_options = get_repr_options(&tcx, adt_def_id);\n+\n         Entry {\n-            kind: EntryKind::Struct(self.lazy(&data)),\n+            kind: EntryKind::Struct(self.lazy(&data), repr_options),\n             visibility: self.lazy(&ctor_vis),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),\n@@ -659,7 +661,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemTy(..) => EntryKind::Type,\n-            hir::ItemEnum(..) => EntryKind::Enum,\n+            hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n             hir::ItemStruct(ref struct_def, _) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n@@ -671,20 +673,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 } else {\n                     None\n                 };\n+\n+                let repr_options = get_repr_options(&tcx, def_id);\n+\n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u128_unchecked(),\n                     struct_ctor: struct_ctor,\n-                }))\n+                }), repr_options)\n             }\n             hir::ItemUnion(..) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n+                let repr_options = get_repr_options(&tcx, def_id);\n \n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u128_unchecked(),\n                     struct_ctor: None,\n-                }))\n+                }), repr_options)\n             }\n             hir::ItemDefaultImpl(..) => {\n                 let data = ImplData {\n@@ -1419,3 +1425,11 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     result\n }\n+\n+pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: &TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {\n+    let ty = tcx.item_type(did);\n+    match ty.sty {\n+        ty::TyAdt(ref def, _) => return def.repr,\n+        _ => bug!(\"{} is not an ADT\", ty),\n+    }\n+}"}, {"sha": "10aa4784aa2e13611efd3d0f50cdd67833f360b1", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, ReprOptions};\n use rustc_back::PanicStrategy;\n \n use rustc_serialize as serialize;\n@@ -228,11 +228,11 @@ pub enum EntryKind<'tcx> {\n     ForeignMutStatic,\n     ForeignMod,\n     Type,\n-    Enum,\n+    Enum(ReprOptions),\n     Field,\n     Variant(Lazy<VariantData>),\n-    Struct(Lazy<VariantData>),\n-    Union(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>, ReprOptions),\n+    Union(Lazy<VariantData>, ReprOptions),\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),"}, {"sha": "7936db65c44acd2a2b54e1ee7f9f83d4c50ae005", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -65,7 +65,7 @@ use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{ConstContext, report_const_eval_err};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n+use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rustc::dep_graph::DepNode;\n@@ -1006,7 +1006,8 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ctor_id = if !def.is_struct() { Some(ccx.tcx.hir.local_def_id(def.id())) } else { None };\n     let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n                                                ConstInt::Infer(0), def)];\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants);\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants,\n+        ReprOptions::new(&ccx.tcx, did));\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n         ccx.tcx.adt_defs.borrow_mut().insert(ctor_id, adt);\n@@ -1024,7 +1025,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let did = ccx.tcx.hir.local_def_id(it.id);\n     let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n \n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants);\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(&ccx.tcx, did));\n     ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n@@ -1112,7 +1113,7 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n     }).collect();\n \n-    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants);\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(&ccx.tcx, did));\n     tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }"}, {"sha": "bcdafefa2472b370ef466afa6e8f70490ef1d297", "filename": "src/test/ui/did_you_mean/issue-39544.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum X {\n+    Y\n+}\n+\n+struct Z {\n+    x: X\n+}\n+\n+fn main() {\n+    let z = Z { x: X::Y };\n+    let _ = &mut z.x;\n+}"}, {"sha": "c0088f39ad3e17d842dd6c43a143beeb9c911d88", "filename": "src/test/ui/did_you_mean/issue-39544.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.stderr?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -0,0 +1,8 @@\n+error: cannot borrow immutable field `z.x` as mutable\n+  --> $DIR/issue-39544.rs:21:18\n+   |\n+21 |     let _ = &mut z.x;\n+   |                  ^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "2a24edd4e3f330633b05a87d2ac32091c3a340ff", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=e7fc53b8f0595d9b5be6a3b64d29d3cfed7c7199", "patch": "@@ -78,6 +78,7 @@ static TARGETS: &'static [&'static str] = &[\n     \"powerpc64-unknown-linux-gnu\",\n     \"powerpc64le-unknown-linux-gnu\",\n     \"s390x-unknown-linux-gnu\",\n+    \"sparc64-unknown-linux-gnu\",\n     \"wasm32-unknown-emscripten\",\n     \"x86_64-apple-darwin\",\n     \"x86_64-apple-ios\","}]}