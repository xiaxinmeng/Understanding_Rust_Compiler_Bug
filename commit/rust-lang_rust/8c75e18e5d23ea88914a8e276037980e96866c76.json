{"sha": "8c75e18e5d23ea88914a8e276037980e96866c76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNzVlMThlNWQyM2VhODg5MTRhOGUyNzYwMzc5ODBlOTY4NjZjNzY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-02-28T15:17:44Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2018-03-13T23:52:17Z"}, "message": "test for putting back check on json", "tree": {"sha": "fcac2bc7c09146cebc73746ce915bb1319580ed8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcac2bc7c09146cebc73746ce915bb1319580ed8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c75e18e5d23ea88914a8e276037980e96866c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c75e18e5d23ea88914a8e276037980e96866c76", "html_url": "https://github.com/rust-lang/rust/commit/8c75e18e5d23ea88914a8e276037980e96866c76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c75e18e5d23ea88914a8e276037980e96866c76/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c29085761b0bf5b9add4bd008268651feae495bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c29085761b0bf5b9add4bd008268651feae495bd", "html_url": "https://github.com/rust-lang/rust/commit/c29085761b0bf5b9add4bd008268651feae495bd"}], "stats": {"total": 206, "additions": 127, "deletions": 79}, "files": [{"sha": "945ecce7ab3e26abf432a80d8ff46b014617af6b", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=8c75e18e5d23ea88914a8e276037980e96866c76", "patch": "@@ -92,7 +92,8 @@ impl<'a> DiagnosticBuilder<'a> {\n             Level::Bug |\n             Level::Fatal |\n             Level::PhaseFatal |\n-            Level::Error => {\n+            Level::Error |\n+            Level::FailureNote => {\n                 true\n             }\n "}, {"sha": "3b6e6db7f46c3452b12dfa202e791c91a8227a8a", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 35, "deletions": 54, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=8c75e18e5d23ea88914a8e276037980e96866c76", "patch": "@@ -21,7 +21,7 @@ use atty;\n use std::borrow::Cow;\n use std::io::prelude::*;\n use std::io;\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::cmp::min;\n use termcolor::{StandardStream, ColorChoice, ColorSpec, BufferWriter};\n use termcolor::{WriteColor, Color, Buffer};\n@@ -33,6 +33,11 @@ const ANONYMIZED_LINE_NUM: &str = \"LL\";\n pub trait Emitter {\n     /// Emit a structured diagnostic.\n     fn emit(&mut self, db: &DiagnosticBuilder);\n+\n+    /// Check if should show explanations about \"rustc --explain\"\n+    fn should_show_explain(&self) -> bool {\n+        true\n+    }\n }\n \n impl Emitter for EmitterWriter {\n@@ -80,6 +85,10 @@ impl Emitter for EmitterWriter {\n                                    &children,\n                                    &suggestions);\n     }\n+\n+    fn should_show_explain(&self) -> bool {\n+        !self.short_message\n+    }\n }\n \n /// maximum number of lines we will print for each error; arbitrary.\n@@ -114,7 +123,6 @@ pub struct EmitterWriter {\n     cm: Option<Lrc<CodeMapper>>,\n     short_message: bool,\n     teach: bool,\n-    error_codes: HashSet<String>,\n     ui_testing: bool,\n }\n \n@@ -124,34 +132,6 @@ struct FileWithAnnotatedLines {\n     multiline_depth: usize,\n }\n \n-impl Drop for EmitterWriter {\n-    fn drop(&mut self) {\n-        if !self.short_message && !self.error_codes.is_empty() {\n-            let mut error_codes = self.error_codes.clone().into_iter().collect::<Vec<_>>();\n-            let mut dst = self.dst.writable();\n-            error_codes.sort();\n-            if error_codes.len() > 1 {\n-                let limit = if error_codes.len() > 9 { 9 } else { error_codes.len() };\n-                writeln!(dst,\n-                         \"You've got a few errors: {}{}\",\n-                         error_codes[..limit].join(\", \"),\n-                         if error_codes.len() > 9 { \"...\" } else { \"\" }\n-                        ).expect(\"failed to give tips...\");\n-                writeln!(dst,\n-                         \"If you want more information on an error, try using \\\n-                          \\\"rustc --explain {}\\\"\",\n-                         &error_codes[0]).expect(\"failed to give tips...\");\n-            } else {\n-                writeln!(dst,\n-                         \"If you want more information on this error, try using \\\n-                          \\\"rustc --explain {}\\\"\",\n-                         &error_codes[0]).expect(\"failed to give tips...\");\n-            }\n-            dst.flush().expect(\"failed to emit errors\");\n-        }\n-    }\n-}\n-\n impl EmitterWriter {\n     pub fn stderr(color_config: ColorConfig,\n                   code_map: Option<Lrc<CodeMapper>>,\n@@ -164,7 +144,6 @@ impl EmitterWriter {\n             cm: code_map,\n             short_message,\n             teach,\n-            error_codes: HashSet::new(),\n             ui_testing: false,\n         }\n     }\n@@ -179,7 +158,6 @@ impl EmitterWriter {\n             cm: code_map,\n             short_message,\n             teach,\n-            error_codes: HashSet::new(),\n             ui_testing: false,\n         }\n     }\n@@ -993,18 +971,26 @@ impl EmitterWriter {\n                 buffer.prepend(0, \" \", Style::NoStyle);\n             }\n             draw_note_separator(&mut buffer, 0, max_line_num_len + 1);\n-            buffer.append(0, &level.to_string(), Style::HeaderMsg);\n-            buffer.append(0, \": \", Style::NoStyle);\n+            let level_str = level.to_string();\n+            if !level_str.is_empty() {\n+                buffer.append(0, &level_str, Style::HeaderMsg);\n+                buffer.append(0, \": \", Style::NoStyle);\n+            }\n             self.msg_to_buffer(&mut buffer, msg, max_line_num_len, \"note\", None);\n         } else {\n-            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n+            let level_str = level.to_string();\n+            if !level_str.is_empty() {\n+                buffer.append(0, &level_str, Style::Level(level.clone()));\n+            }\n             // only render error codes, not lint codes\n             if let Some(DiagnosticId::Error(ref code)) = *code {\n                 buffer.append(0, \"[\", Style::Level(level.clone()));\n                 buffer.append(0, &code, Style::Level(level.clone()));\n                 buffer.append(0, \"]\", Style::Level(level.clone()));\n             }\n-            buffer.append(0, \": \", Style::HeaderMsg);\n+            if !level_str.is_empty() {\n+                buffer.append(0, \": \", Style::HeaderMsg);\n+            }\n             for &(ref text, _) in msg.iter() {\n                 buffer.append(0, text, Style::HeaderMsg);\n             }\n@@ -1020,14 +1006,12 @@ impl EmitterWriter {\n             if primary_span != &&DUMMY_SP {\n                 (cm.lookup_char_pos(primary_span.lo()), cm)\n             } else {\n-                emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message,\n-                                    &mut self.error_codes)?;\n+                emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n                 return Ok(());\n             }\n         } else {\n             // If we don't have span information, emit and exit\n-            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message,\n-                                &mut self.error_codes)?;\n+            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n             return Ok(());\n         };\n         if let Ok(pos) =\n@@ -1200,8 +1184,7 @@ impl EmitterWriter {\n         }\n \n         // final step: take our styled buffer, render it, then output it\n-        emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message,\n-                            &mut self.error_codes)?;\n+        emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n \n         Ok(())\n \n@@ -1218,8 +1201,11 @@ impl EmitterWriter {\n             let mut buffer = StyledBuffer::new();\n \n             // Render the suggestion message\n-            buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n-            buffer.append(0, \": \", Style::HeaderMsg);\n+            let level_str = level.to_string();\n+            if !level_str.is_empty() {\n+                buffer.append(0, &level_str, Style::Level(level.clone()));\n+                buffer.append(0, \": \", Style::HeaderMsg);\n+            }\n             self.msg_to_buffer(&mut buffer,\n                                &[(suggestion.msg.to_owned(), Style::NoStyle)],\n                                max_line_num_len,\n@@ -1289,8 +1275,7 @@ impl EmitterWriter {\n                 let msg = format!(\"and {} other candidates\", suggestions.len() - MAX_SUGGESTIONS);\n                 buffer.puts(row_num, 0, &msg, Style::NoStyle);\n             }\n-            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message,\n-                                &mut self.error_codes)?;\n+            emit_to_destination(&buffer.render(), level, &mut self.dst, self.short_message)?;\n         }\n         Ok(())\n     }\n@@ -1321,7 +1306,7 @@ impl EmitterWriter {\n                         draw_col_separator_no_space(&mut buffer, 0, max_line_num_len + 1);\n                     }\n                     match emit_to_destination(&buffer.render(), level, &mut self.dst,\n-                                              self.short_message, &mut self.error_codes) {\n+                                              self.short_message) {\n                         Ok(()) => (),\n                         Err(e) => panic!(\"failed to emit error: {}\", e)\n                     }\n@@ -1416,8 +1401,7 @@ fn overlaps(a1: &Annotation, a2: &Annotation, padding: usize) -> bool {\n fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n                        lvl: &Level,\n                        dst: &mut Destination,\n-                       short_message: bool,\n-                       error_codes: &mut HashSet<String>)\n+                       short_message: bool)\n                        -> io::Result<()> {\n     use lock;\n \n@@ -1436,16 +1420,13 @@ fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n     // same buffering approach.  Instead, we use a global Windows mutex, which we acquire long\n     // enough to output the full error message, then we release.\n     let _buffer_lock = lock::acquire_global_lock(\"rustc_errors\");\n-    for line in rendered_buffer {\n+    for (pos, line) in rendered_buffer.iter().enumerate() {\n         for part in line {\n             dst.apply_style(lvl.clone(), part.style)?;\n             write!(dst, \"{}\", part.text)?;\n-            if !short_message && part.text.len() == 12 && part.text.starts_with(\"error[E\") {\n-                error_codes.insert(part.text[6..11].to_owned());\n-            }\n             dst.reset()?;\n         }\n-        if !short_message {\n+        if !short_message && (!lvl.is_failure_note() || pos != rendered_buffer.len() - 1) {\n             write!(dst, \"\\n\")?;\n         }\n     }"}, {"sha": "7148969191f2b6caaa49c233e04c8270902e625c", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=8c75e18e5d23ea88914a8e276037980e96866c76", "patch": "@@ -509,12 +509,14 @@ impl Handler {\n     pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n     }\n+    pub fn failure(&self, msg: &str) {\n+        DiagnosticBuilder::new(self, FailureNote, msg).emit()\n+    }\n     pub fn fatal(&self, msg: &str) -> FatalError {\n         if self.flags.treat_err_as_bug {\n             self.bug(msg);\n         }\n-        let mut db = DiagnosticBuilder::new(self, Fatal, msg);\n-        db.emit();\n+        DiagnosticBuilder::new(self, Fatal, msg).emit();\n         FatalError\n     }\n     pub fn err(&self, msg: &str) {\n@@ -567,8 +569,39 @@ impl Handler {\n                 s = format!(\"aborting due to {} previous errors\", self.err_count());\n             }\n         }\n+        let err = self.fatal(&s);\n+\n+        let can_show_explain = self.emitter.borrow().should_show_explain();\n+        let are_there_diagnostics = !self.tracked_diagnostic_codes.borrow().is_empty();\n+        if can_show_explain && are_there_diagnostics {\n+            let mut error_codes =\n+                self.tracked_diagnostic_codes.borrow()\n+                                             .clone()\n+                                             .into_iter()\n+                                             .filter_map(|x| match x {\n+                                                 DiagnosticId::Error(ref s) => Some(s.clone()),\n+                                                 _ => None,\n+                                             })\n+                                             .collect::<Vec<_>>();\n+            if !error_codes.is_empty() {\n+                error_codes.sort();\n+                if error_codes.len() > 1 {\n+                    let limit = if error_codes.len() > 9 { 9 } else { error_codes.len() };\n+                    self.failure(&format!(\"Some errors occurred: {}{}\",\n+                                          error_codes[..limit].join(\", \"),\n+                                          if error_codes.len() > 9 { \"...\" } else { \".\" }));\n+                    self.failure(&format!(\"For more information about an error, try \\\n+                                           `rustc --explain {}`.\",\n+                                          &error_codes[0]));\n+                } else {\n+                    self.failure(&format!(\"For more information about this error, try \\\n+                                           `rustc --explain {}`.\",\n+                                          &error_codes[0]));\n+                }\n+            }\n+        }\n \n-        self.fatal(&s).raise();\n+        err.raise();\n     }\n     pub fn emit(&self, msp: &MultiSpan, msg: &str, lvl: Level) {\n         if lvl == Warning && !self.flags.can_emit_warnings {\n@@ -654,6 +687,7 @@ pub enum Level {\n     Note,\n     Help,\n     Cancelled,\n+    FailureNote,\n }\n \n impl fmt::Display for Level {\n@@ -682,9 +716,10 @@ impl Level {\n                 spec.set_fg(Some(Color::Cyan))\n                     .set_intense(true);\n             }\n+            FailureNote => {}\n             Cancelled => unreachable!(),\n         }\n-        return spec\n+        spec\n     }\n \n     pub fn to_str(self) -> &'static str {\n@@ -694,7 +729,15 @@ impl Level {\n             Warning => \"warning\",\n             Note => \"note\",\n             Help => \"help\",\n+            FailureNote => \"\",\n             Cancelled => panic!(\"Shouldn't call on cancelled error\"),\n         }\n     }\n+\n+    pub fn is_failure_note(&self) -> bool {\n+        match *self {\n+            FailureNote => true,\n+            _ => false,\n+        }\n+    }\n }"}, {"sha": "761d1e511d52bb8a1d1d67b87148481264a55dc7", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=8c75e18e5d23ea88914a8e276037980e96866c76", "patch": "@@ -24,6 +24,7 @@ struct Diagnostic {\n     level: String,\n     spans: Vec<DiagnosticSpan>,\n     children: Vec<Diagnostic>,\n+    rendered: Option<String>,\n }\n \n #[derive(Deserialize, Clone)]\n@@ -56,6 +57,25 @@ struct DiagnosticCode {\n     explanation: Option<String>,\n }\n \n+pub fn extract_rendered(output: &str, proc_res: &ProcRes) -> String {\n+    output.lines()\n+        .filter_map(|line| if line.starts_with('{') {\n+            match serde_json::from_str::<Diagnostic>(line) {\n+                Ok(diagnostic) => diagnostic.rendered,\n+                Err(error) => {\n+                    proc_res.fatal(Some(&format!(\"failed to decode compiler output as json: \\\n+                                                  `{}`\\noutput: {}\\nline: {}\",\n+                                                 error,\n+                                                 line,\n+                                                 output)));\n+                }\n+            }\n+        } else {\n+            None\n+        })\n+        .collect()\n+}\n+\n pub fn parse_output(file_name: &str, output: &str, proc_res: &ProcRes) -> Vec<Error> {\n     output.lines()\n         .flat_map(|line| parse_line(file_name, line, output, proc_res))"}, {"sha": "953a13a3f582035a45ced2040dd2d03292635043", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c75e18e5d23ea88914a8e276037980e96866c76/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=8c75e18e5d23ea88914a8e276037980e96866c76", "patch": "@@ -248,7 +248,7 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_cfail_test(&self) {\n-        let proc_res = self.compile_test(&[]);\n+        let proc_res = self.compile_test();\n         self.check_if_test_should_compile(&proc_res);\n         self.check_no_compiler_crash(&proc_res);\n \n@@ -267,7 +267,7 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_rfail_test(&self) {\n-        let proc_res = self.compile_test(&[]);\n+        let proc_res = self.compile_test();\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -309,7 +309,7 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_rpass_test(&self) {\n-        let proc_res = self.compile_test(&[]);\n+        let proc_res = self.compile_test();\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -336,7 +336,7 @@ impl<'test> TestCx<'test> {\n             return self.run_rpass_test();\n         }\n \n-        let mut proc_res = self.compile_test(&[]);\n+        let mut proc_res = self.compile_test();\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -578,7 +578,7 @@ impl<'test> TestCx<'test> {\n         let mut cmds = commands.join(\"\\n\");\n \n         // compile test file (it should have 'compile-flags:-g' in the header)\n-        let compiler_run_result = self.compile_test(&[]);\n+        let compiler_run_result = self.compile_test();\n         if !compiler_run_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compiler_run_result);\n         }\n@@ -835,7 +835,7 @@ impl<'test> TestCx<'test> {\n \n     fn run_debuginfo_lldb_test_no_opt(&self) {\n         // compile test file (it should have 'compile-flags:-g' in the header)\n-        let compile_result = self.compile_test(&[]);\n+        let compile_result = self.compile_test();\n         if !compile_result.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &compile_result);\n         }\n@@ -1272,15 +1272,12 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn compile_test(&self, extra_args: &[&'static str]) -> ProcRes {\n+    fn compile_test(&self) -> ProcRes {\n         let mut rustc = self.make_compile_args(\n             &self.testpaths.file,\n             TargetLocation::ThisFile(self.make_exe_name()),\n         );\n \n-        if !extra_args.is_empty() {\n-            rustc.args(extra_args);\n-        }\n         rustc.arg(\"-L\").arg(&self.aux_output_dir_name());\n \n         match self.config.mode {\n@@ -1626,12 +1623,14 @@ impl<'test> TestCx<'test> {\n                 if self.props.error_patterns.is_empty() {\n                     rustc.args(&[\"--error-format\", \"json\"]);\n                 }\n+                if !self.props.disable_ui_testing_normalization {\n+                    rustc.arg(\"-Zui-testing\");\n+                }\n             }\n             Ui => {\n-                // In case no \"--error-format\" has been given in the test, we'll compile\n-                // a first time to get the compiler's output then compile with\n-                // \"--error-format json\" to check if all expected errors are actually there\n-                // and that no new one appeared.\n+                if !self.props.compile_flags.iter().any(|s| s.starts_with(\"--error-format\")) {\n+                    rustc.args(&[\"--error-format\", \"json\"]);\n+                }\n                 if !self.props.disable_ui_testing_normalization {\n                     rustc.arg(\"-Zui-testing\");\n                 }\n@@ -2114,7 +2113,7 @@ impl<'test> TestCx<'test> {\n     fn run_codegen_units_test(&self) {\n         assert!(self.revision.is_none(), \"revisions not relevant here\");\n \n-        let proc_res = self.compile_test(&[]);\n+        let proc_res = self.compile_test();\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);\n@@ -2505,7 +2504,7 @@ impl<'test> TestCx<'test> {\n             .iter()\n             .any(|s| s.contains(\"--error-format\"));\n \n-        let proc_res = self.compile_test(&[]);\n+        let proc_res = self.compile_test();\n         self.check_if_test_should_compile(&proc_res);\n \n         let expected_stderr_path = self.expected_output_path(UI_STDERR);\n@@ -2517,8 +2516,13 @@ impl<'test> TestCx<'test> {\n         let normalized_stdout =\n             self.normalize_output(&proc_res.stdout, &self.props.normalize_stdout);\n \n-        let normalized_stderr = self.normalize_output(&proc_res.stderr,\n-                                                      &self.props.normalize_stderr);\n+        let stderr = if explicit {\n+            proc_res.stderr.clone()\n+        } else {\n+            json::extract_rendered(&proc_res.stderr, &proc_res)\n+        };\n+\n+        let normalized_stderr = self.normalize_output(&stderr, &self.props.normalize_stderr);\n \n         let mut errors = 0;\n         errors += self.compare_output(\"stdout\", &normalized_stdout, &expected_stdout);\n@@ -2551,7 +2555,6 @@ impl<'test> TestCx<'test> {\n             }\n         }\n         if !explicit {\n-            let proc_res = self.compile_test(&[\"--error-format\", \"json\"]);\n             if !expected_errors.is_empty() || !proc_res.status.success() {\n                 // \"// error-pattern\" comments\n                 self.check_expected_errors(expected_errors, &proc_res);\n@@ -2563,7 +2566,7 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn run_mir_opt_test(&self) {\n-        let proc_res = self.compile_test(&[]);\n+        let proc_res = self.compile_test();\n \n         if !proc_res.status.success() {\n             self.fatal_proc_rec(\"compilation failed!\", &proc_res);"}]}