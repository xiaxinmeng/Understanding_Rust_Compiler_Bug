{"sha": "08ed338f561b000ce5672b55c0545fa7f3f13591", "node_id": "C_kwDOAAsO6NoAKDA4ZWQzMzhmNTYxYjAwMGNlNTY3MmI1NWMwNTQ1ZmE3ZjNmMTM1OTE", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2021-10-08T16:10:17Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-01-06T09:32:42Z"}, "message": "sess/cg: re-introduce split dwarf kind\n\nIn #79570, `-Z split-dwarf-kind={none,single,split}` was replaced by `-C\nsplit-debuginfo={off,packed,unpacked}`. `-C split-debuginfo`'s packed\nand unpacked aren't exact parallels to single and split, respectively.\n\nOn Unix, `-C split-debuginfo=packed` will put debuginfo into object\nfiles and package debuginfo into a DWARF package file (`.dwp`) and\n`-C split-debuginfo=unpacked` will put debuginfo into dwarf object files\nand won't package it.\n\nIn the initial implementation of Split DWARF, split mode wrote sections\nwhich did not require relocation into a DWARF object (`.dwo`) file which\nwas ignored by the linker and then packaged those DWARF objects into\nDWARF packages (`.dwp`). In single mode, sections which did not require\nrelocation were written into object files but ignored by the linker and\nwere not packaged. However, both split and single modes could be\npackaged or not, the primary difference in behaviour was where the\ndebuginfo sections that did not require link-time relocation were\nwritten (in a DWARF object or the object file).\n\nThis commit re-introduces a `-Z split-dwarf-kind` flag, which can be\nused to pick between split and single modes when `-C split-debuginfo` is\nused to enable Split DWARF (either packed or unpacked).\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "a8424b9dcb8661419799e23e4ca8dd08e2fd9da8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8424b9dcb8661419799e23e4ca8dd08e2fd9da8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08ed338f561b000ce5672b55c0545fa7f3f13591", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08ed338f561b000ce5672b55c0545fa7f3f13591", "html_url": "https://github.com/rust-lang/rust/commit/08ed338f561b000ce5672b55c0545fa7f3f13591", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08ed338f561b000ce5672b55c0545fa7f3f13591/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1ce0e6a00593493a12e0e3662119786c761f375", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ce0e6a00593493a12e0e3662119786c761f375", "html_url": "https://github.com/rust-lang/rust/commit/f1ce0e6a00593493a12e0e3662119786c761f375"}], "stats": {"total": 245, "additions": 184, "deletions": 61}, "files": [{"sha": "384596dfff5033c3e010d3bc27f634f00bfc5f1b", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=08ed338f561b000ce5672b55c0545fa7f3f13591", "patch": "@@ -23,7 +23,7 @@ use rustc_errors::{FatalError, Handler, Level};\n use rustc_fs_util::{link_or_copy, path_to_c_string};\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{self, Lto, OutputType, Passes, SwitchWithOptPath};\n+use rustc_session::config::{self, Lto, OutputType, Passes, SplitDwarfKind, SwitchWithOptPath};\n use rustc_session::Session;\n use rustc_span::symbol::sym;\n use rustc_span::InnerSpan;\n@@ -106,7 +106,11 @@ pub fn create_informational_target_machine(sess: &Session) -> &'static mut llvm:\n \n pub fn create_target_machine(tcx: TyCtxt<'_>, mod_name: &str) -> &'static mut llvm::TargetMachine {\n     let split_dwarf_file = if tcx.sess.target_can_use_split_dwarf() {\n-        tcx.output_filenames(()).split_dwarf_path(tcx.sess.split_debuginfo(), Some(mod_name))\n+        tcx.output_filenames(()).split_dwarf_path(\n+            tcx.sess.split_debuginfo(),\n+            tcx.sess.opts.debugging_opts.split_dwarf_kind,\n+            Some(mod_name),\n+        )\n     } else {\n         None\n     };\n@@ -892,17 +896,18 @@ pub(crate) unsafe fn codegen(\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &*module.name);\n \n                 let dwo_out = cgcx.output_filenames.temp_path_dwo(module_name);\n-                let dwo_out = match cgcx.split_debuginfo {\n-                    // Don't change how DWARF is emitted in single mode (or when disabled).\n-                    SplitDebuginfo::Off | SplitDebuginfo::Packed => None,\n-                    // Emit (a subset of the) DWARF into a separate file in split mode.\n-                    SplitDebuginfo::Unpacked => {\n-                        if cgcx.target_can_use_split_dwarf {\n-                            Some(dwo_out.as_path())\n-                        } else {\n-                            None\n-                        }\n-                    }\n+                let dwo_out = match (cgcx.split_debuginfo, cgcx.split_dwarf_kind) {\n+                    // Don't change how DWARF is emitted when disabled.\n+                    (SplitDebuginfo::Off, _) => None,\n+                    // Don't provide a DWARF object path if split debuginfo is enabled but this is\n+                    // a platform that doesn't support Split DWARF.\n+                    _ if !cgcx.target_can_use_split_dwarf => None,\n+                    // Don't provide a DWARF object path in single mode, sections will be written\n+                    // into the object as normal but ignored by linker.\n+                    (_, SplitDwarfKind::Single) => None,\n+                    // Emit (a subset of the) DWARF into a separate dwarf object file in split\n+                    // mode.\n+                    (_, SplitDwarfKind::Split) => Some(dwo_out.as_path()),\n                 };\n \n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n@@ -939,7 +944,9 @@ pub(crate) unsafe fn codegen(\n \n     Ok(module.into_compiled_module(\n         config.emit_obj != EmitObj::None,\n-        cgcx.target_can_use_split_dwarf && cgcx.split_debuginfo == SplitDebuginfo::Unpacked,\n+        cgcx.target_can_use_split_dwarf\n+            && cgcx.split_debuginfo != SplitDebuginfo::Off\n+            && cgcx.split_dwarf_kind == SplitDwarfKind::Split,\n         config.emit_bc,\n         &cgcx.output_filenames,\n     ))"}, {"sha": "e8d35cf5697f1050df9f6dfeda5fdffe9e4d003c", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=08ed338f561b000ce5672b55c0545fa7f3f13591", "patch": "@@ -1072,7 +1072,11 @@ pub fn compile_unit_metadata<'ll, 'tcx>(\n     let output_filenames = tcx.output_filenames(());\n     let split_name = if tcx.sess.target_can_use_split_dwarf() {\n         output_filenames\n-            .split_dwarf_path(tcx.sess.split_debuginfo(), Some(codegen_unit_name))\n+            .split_dwarf_path(\n+                tcx.sess.split_debuginfo(),\n+                tcx.sess.opts.debugging_opts.split_dwarf_kind,\n+                Some(codegen_unit_name),\n+            )\n             // We get a path relative to the working directory from split_dwarf_path\n             .map(|f| tcx.sess.source_map().path_mapping().map_prefix(f).0)\n     } else {"}, {"sha": "a59ccc63222c73f2927c7beb5e45053aed1007e4", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=08ed338f561b000ce5672b55c0545fa7f3f13591", "patch": "@@ -5,7 +5,7 @@ use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::dependency_format::Linkage;\n use rustc_session::config::{self, CFGuard, CrateType, DebugInfo, LdImpl, Strip};\n-use rustc_session::config::{OutputFilenames, OutputType, PrintRequest};\n+use rustc_session::config::{OutputFilenames, OutputType, PrintRequest, SplitDwarfKind};\n use rustc_session::cstore::DllImport;\n use rustc_session::output::{check_file_is_writeable, invalid_output_for_target, out_filename};\n use rustc_session::search_paths::PathKind;\n@@ -134,31 +134,47 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n         }\n     }\n \n-    // Remove the temporary object file and metadata if we aren't saving temps\n+    // Remove the temporary object file and metadata if we aren't saving temps.\n     sess.time(\"link_binary_remove_temps\", || {\n-        if !sess.opts.cg.save_temps {\n-            let remove_temps_from_module = |module: &CompiledModule| {\n-                if let Some(ref obj) = module.object {\n-                    ensure_removed(sess.diagnostic(), obj);\n-                }\n-\n-                if let Some(ref obj) = module.dwarf_object {\n-                    ensure_removed(sess.diagnostic(), obj);\n-                }\n-            };\n+        // If the user requests that temporaries are saved, don't delete any.\n+        if sess.opts.cg.save_temps {\n+            return;\n+        }\n \n-            if sess.opts.output_types.should_link() && !preserve_objects_for_their_debuginfo(sess) {\n-                for module in &codegen_results.modules {\n-                    remove_temps_from_module(module);\n-                }\n+        let remove_temps_from_module = |module: &CompiledModule| {\n+            if let Some(ref obj) = module.object {\n+                ensure_removed(sess.diagnostic(), obj);\n             }\n+        };\n \n-            if let Some(ref metadata_module) = codegen_results.metadata_module {\n-                remove_temps_from_module(metadata_module);\n+        // Otherwise, always remove the metadata and allocator module temporaries.\n+        if let Some(ref metadata_module) = codegen_results.metadata_module {\n+            remove_temps_from_module(metadata_module);\n+        }\n+\n+        if let Some(ref allocator_module) = codegen_results.allocator_module {\n+            remove_temps_from_module(allocator_module);\n+        }\n+\n+        // If no requested outputs require linking, then the object temporaries should\n+        // be kept.\n+        if !sess.opts.output_types.should_link() {\n+            return;\n+        }\n+\n+        // Potentially keep objects for their debuginfo.\n+        let (preserve_objects, preserve_dwarf_objects) = preserve_objects_for_their_debuginfo(sess);\n+        debug!(?preserve_objects, ?preserve_dwarf_objects);\n+\n+        for module in &codegen_results.modules {\n+            if !preserve_objects {\n+                remove_temps_from_module(module);\n             }\n \n-            if let Some(ref allocator_module) = codegen_results.allocator_module {\n-                remove_temps_from_module(allocator_module);\n+            if !preserve_dwarf_objects {\n+                if let Some(ref obj) = module.dwarf_object {\n+                    ensure_removed(sess.diagnostic(), obj);\n+                }\n             }\n         }\n     });\n@@ -1138,26 +1154,36 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n     bug!(\"Not enough information provided to determine how to invoke the linker\");\n }\n \n-/// Returns a boolean indicating whether we should preserve the object files on\n-/// the filesystem for their debug information. This is often useful with\n-/// split-dwarf like schemes.\n-fn preserve_objects_for_their_debuginfo(sess: &Session) -> bool {\n+/// Returns a pair of boolean indicating whether we should preserve the object and\n+/// dwarf object files on the filesystem for their debug information. This is often\n+/// useful with split-dwarf like schemes.\n+fn preserve_objects_for_their_debuginfo(sess: &Session) -> (bool, bool) {\n     // If the objects don't have debuginfo there's nothing to preserve.\n     if sess.opts.debuginfo == config::DebugInfo::None {\n-        return false;\n+        return (false, false);\n     }\n \n     // If we're only producing artifacts that are archives, no need to preserve\n     // the objects as they're losslessly contained inside the archives.\n-    let output_linked =\n-        sess.crate_types().iter().any(|&x| x != CrateType::Rlib && x != CrateType::Staticlib);\n-    if !output_linked {\n-        return false;\n+    if sess.crate_types().iter().all(|&x| x.is_archive()) {\n+        return (false, false);\n+    }\n+\n+    match (sess.split_debuginfo(), sess.opts.debugging_opts.split_dwarf_kind) {\n+        // If there is no split debuginfo then do not preserve objects.\n+        (SplitDebuginfo::Off, _) => (false, false),\n+        // If there is packed split debuginfo, then the debuginfo in the objects\n+        // has been packaged and the objects can be deleted.\n+        (SplitDebuginfo::Packed, _) => (false, false),\n+        // If there is unpacked split debuginfo and the current target can not use\n+        // split dwarf, then keep objects.\n+        (SplitDebuginfo::Unpacked, _) if !sess.target_can_use_split_dwarf() => (true, false),\n+        // If there is unpacked split debuginfo and the target can use split dwarf, then\n+        // keep the object containing that debuginfo (whether that is an object file or\n+        // dwarf object file depends on the split dwarf kind).\n+        (SplitDebuginfo::Unpacked, SplitDwarfKind::Single) => (true, false),\n+        (SplitDebuginfo::Unpacked, SplitDwarfKind::Split) => (false, true),\n     }\n-\n-    // \"unpacked\" split debuginfo means that we leave object files as the\n-    // debuginfo is found in the original object files themselves\n-    sess.split_debuginfo() == SplitDebuginfo::Unpacked\n }\n \n fn archive_search_paths(sess: &Session) -> Vec<PathBuf> {"}, {"sha": "bea454458c4c028170767eac17cd63b29acb43a9", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=08ed338f561b000ce5672b55c0545fa7f3f13591", "patch": "@@ -286,7 +286,11 @@ impl TargetMachineFactoryConfig {\n         module_name: &str,\n     ) -> TargetMachineFactoryConfig {\n         let split_dwarf_file = if cgcx.target_can_use_split_dwarf {\n-            cgcx.output_filenames.split_dwarf_path(cgcx.split_debuginfo, Some(module_name))\n+            cgcx.output_filenames.split_dwarf_path(\n+                cgcx.split_debuginfo,\n+                cgcx.split_dwarf_kind,\n+                Some(module_name),\n+            )\n         } else {\n             None\n         };\n@@ -329,6 +333,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     pub target_arch: String,\n     pub debuginfo: config::DebugInfo,\n     pub split_debuginfo: rustc_target::spec::SplitDebuginfo,\n+    pub split_dwarf_kind: rustc_session::config::SplitDwarfKind,\n \n     // Number of cgus excluding the allocator/metadata modules\n     pub total_cgus: usize,\n@@ -1060,6 +1065,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         target_arch: tcx.sess.target.arch.clone(),\n         debuginfo: tcx.sess.opts.debuginfo,\n         split_debuginfo: tcx.sess.split_debuginfo(),\n+        split_dwarf_kind: tcx.sess.opts.debugging_opts.split_dwarf_kind,\n     };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen."}, {"sha": "62b351f5e0279a54eabbcdbe6386df03ebdf4585", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=08ed338f561b000ce5672b55c0545fa7f3f13591", "patch": "@@ -231,6 +231,37 @@ pub enum DebugInfo {\n     Full,\n }\n \n+/// Split debug-information is enabled by `-C split-debuginfo`, this enum is only used if split\n+/// debug-information is enabled (in either `Packed` or `Unpacked` modes), and the platform\n+/// uses DWARF for debug-information.\n+///\n+/// Some debug-information requires link-time relocation and some does not. LLVM can partition\n+/// the debuginfo into sections depending on whether or not it requires link-time relocation. Split\n+/// DWARF provides a mechanism which allows the linker to skip the sections which don't require\n+/// link-time relocation - either by putting those sections in DWARF object files, or by keeping\n+/// them in the object file in such a way that the linker will skip them.\n+#[derive(Clone, Copy, Debug, PartialEq, Hash)]\n+pub enum SplitDwarfKind {\n+    /// Sections which do not require relocation are written into object file but ignored by the\n+    /// linker.\n+    Single,\n+    /// Sections which do not require relocation are written into a DWARF object (`.dwo`) file\n+    /// which is ignored by the linker.\n+    Split,\n+}\n+\n+impl FromStr for SplitDwarfKind {\n+    type Err = ();\n+\n+    fn from_str(s: &str) -> Result<Self, ()> {\n+        Ok(match s {\n+            \"single\" => SplitDwarfKind::Single,\n+            \"split\" => SplitDwarfKind::Split,\n+            _ => return Err(()),\n+        })\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n #[derive(Encodable, Decodable)]\n pub enum OutputType {\n@@ -378,7 +409,7 @@ impl OutputTypes {\n         self.0.len()\n     }\n \n-    // Returns `true` if any of the output types require codegen or linking.\n+    /// Returns `true` if any of the output types require codegen or linking.\n     pub fn should_codegen(&self) -> bool {\n         self.0.keys().any(|k| match *k {\n             OutputType::Bitcode\n@@ -391,7 +422,7 @@ impl OutputTypes {\n         })\n     }\n \n-    // Returns `true` if any of the output types require linking.\n+    /// Returns `true` if any of the output types require linking.\n     pub fn should_link(&self) -> bool {\n         self.0.keys().any(|k| match *k {\n             OutputType::Bitcode\n@@ -681,18 +712,23 @@ impl OutputFilenames {\n     pub fn split_dwarf_path(\n         &self,\n         split_debuginfo_kind: SplitDebuginfo,\n+        split_dwarf_kind: SplitDwarfKind,\n         cgu_name: Option<&str>,\n     ) -> Option<PathBuf> {\n         let obj_out = self.temp_path(OutputType::Object, cgu_name);\n         let dwo_out = self.temp_path_dwo(cgu_name);\n-        match split_debuginfo_kind {\n-            SplitDebuginfo::Off => None,\n+        match (split_debuginfo_kind, split_dwarf_kind) {\n+            (SplitDebuginfo::Off, SplitDwarfKind::Single | SplitDwarfKind::Split) => None,\n             // Single mode doesn't change how DWARF is emitted, but does add Split DWARF attributes\n             // (pointing at the path which is being determined here). Use the path to the current\n             // object file.\n-            SplitDebuginfo::Packed => Some(obj_out),\n+            (SplitDebuginfo::Packed | SplitDebuginfo::Unpacked, SplitDwarfKind::Single) => {\n+                Some(obj_out)\n+            }\n             // Split mode emits the DWARF into a different file, use that path.\n-            SplitDebuginfo::Unpacked => Some(dwo_out),\n+            (SplitDebuginfo::Packed | SplitDebuginfo::Unpacked, SplitDwarfKind::Split) => {\n+                Some(dwo_out)\n+            }\n         }\n     }\n }\n@@ -821,6 +857,18 @@ pub enum CrateType {\n \n impl_stable_hash_via_hash!(CrateType);\n \n+impl CrateType {\n+    /// When generated, is this crate type an archive?\n+    pub fn is_archive(&self) -> bool {\n+        match *self {\n+            CrateType::Rlib | CrateType::Staticlib => true,\n+            CrateType::Executable | CrateType::Dylib | CrateType::Cdylib | CrateType::ProcMacro => {\n+                false\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone, Hash, Debug, PartialEq, Eq)]\n pub enum Passes {\n     Some(Vec<String>),"}, {"sha": "0b9623d1c7d6f69c4e99cd5265fc27e618e9b666", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=08ed338f561b000ce5672b55c0545fa7f3f13591", "patch": "@@ -412,6 +412,8 @@ mod desc {\n     pub const parse_wasi_exec_model: &str = \"either `command` or `reactor`\";\n     pub const parse_split_debuginfo: &str =\n         \"one of supported split-debuginfo modes (`off`, `packed`, or `unpacked`)\";\n+    pub const parse_split_dwarf_kind: &str =\n+        \"one of supported split dwarf modes (`split` or `single`)\";\n     pub const parse_gcc_ld: &str = \"one of: no value, `lld`\";\n     pub const parse_stack_protector: &str =\n         \"one of (`none` (default), `basic`, `strong`, or `all`)\";\n@@ -941,6 +943,14 @@ mod parse {\n         true\n     }\n \n+    crate fn parse_split_dwarf_kind(slot: &mut SplitDwarfKind, v: Option<&str>) -> bool {\n+        match v.and_then(|s| SplitDwarfKind::from_str(s).ok()) {\n+            Some(e) => *slot = e,\n+            _ => return false,\n+        }\n+        true\n+    }\n+\n     crate fn parse_gcc_ld(slot: &mut Option<LdImpl>, v: Option<&str>) -> bool {\n         match v {\n             None => *slot = None,\n@@ -1403,6 +1413,14 @@ options! {\n         \"control stack smash protection strategy (`rustc --print stack-protector-strategies` for details)\"),\n     strip: Strip = (Strip::None, parse_strip, [UNTRACKED],\n         \"tell the linker which information to strip (`none` (default), `debuginfo` or `symbols`)\"),\n+    split_dwarf_kind: SplitDwarfKind = (SplitDwarfKind::Split, parse_split_dwarf_kind, [UNTRACKED],\n+        \"split dwarf variant (only if -Csplit-debuginfo is enabled and on relevant platform)\n+        (default: `split`)\n+\n+        `split`: sections which do not require relocation are written into a DWARF object (`.dwo`)\n+                 file which is ignored by the linker\n+        `single`: sections which do not require relocation are written into object file but ignored\n+                  by the linker\"),\n     split_dwarf_inlining: bool = (true, parse_bool, [UNTRACKED],\n         \"provide minimal debug info in the object/executable to facilitate online \\\n          symbolication/stack traces in the absence of .dwo/.dwp files when using Split DWARF\"),"}, {"sha": "ca1949b9f75a3668de55bc9b49b68f93a161997d", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ed338f561b000ce5672b55c0545fa7f3f13591/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=08ed338f561b000ce5672b55c0545fa7f3f13591", "patch": "@@ -479,7 +479,7 @@ pub enum SplitDebuginfo {\n     ///\n     /// * Windows - not supported\n     /// * macOS - supported, scattered object files\n-    /// * ELF - supported, scattered `*.dwo` files\n+    /// * ELF - supported, scattered `*.dwo` or `*.o` files (see `SplitDwarfKind`)\n     Unpacked,\n }\n "}, {"sha": "292fe5ae55b84e566da0666041d1219b6d1f429c", "filename": "src/test/run-make-fulldeps/split-debuginfo/Makefile", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/08ed338f561b000ce5672b55c0545fa7f3f13591/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/08ed338f561b000ce5672b55c0545fa7f3f13591/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fsplit-debuginfo%2FMakefile?ref=08ed338f561b000ce5672b55c0545fa7f3f13591", "patch": "@@ -44,16 +44,30 @@ off:\n \t[ ! -f $(TMPDIR)/*.dwp ]\n \t[ ! -f $(TMPDIR)/*.dwo ]\n \n-packed:\n-\t$(RUSTC) foo.rs -g -C split-debuginfo=packed -Z unstable-options\n+packed: packed-split packed-single\n+\n+packed-split:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=packed -Z unstable-options -Zsplit-dwarf-kind=split\n+\tls $(TMPDIR)/*.dwp\n+\trm -rf $(TMPDIR)/*.dwp $(TMPDIR)/*.dwo\n+\n+packed-single:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=packed -Z unstable-options -Zsplit-dwarf-kind=single\n \tls $(TMPDIR)/*.dwp\n \tls $(TMPDIR)/*.dwo && exit 1 || exit 0\n \trm -rf $(TMPDIR)/*.dwp\n \n-unpacked:\n-\t$(RUSTC) foo.rs -g -C split-debuginfo=unpacked -Z unstable-options\n+unpacked: unpacked-split unpacked-single\n+\n+unpacked-split:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=unpacked -Z unstable-options -Zsplit-dwarf-kind=split\n \tls $(TMPDIR)/*.dwp && exit 1 || exit 0\n \tls $(TMPDIR)/*.dwo\n-\trm -rf $(TMPDIR)/*.dwo\n+\trm -rf $(TMPDIR)/*.dwp $(TMPDIR)/*.dwo\n+\n+unpacked-single:\n+\t$(RUSTC) foo.rs -g -C split-debuginfo=unpacked -Z unstable-options -Zsplit-dwarf-kind=single\n+\tls $(TMPDIR)/*.dwp && exit 1 || exit 0\n+\tls $(TMPDIR)/*.dwo && exit 1 || exit 0\n endif\n endif"}]}