{"sha": "042e0d02d74862796e9716abee07455b5e885151", "node_id": "C_kwDOAAsO6NoAKDA0MmUwZDAyZDc0ODYyNzk2ZTk3MTZhYmVlMDc0NTViNWU4ODUxNTE", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-19T15:27:22Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-08-20T11:33:41Z"}, "message": "Merge \"EnterSpan\" events to reduce code blocks DOM size", "tree": {"sha": "ab91319ba8467041d5ba0ac8230dd9e47893b67a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab91319ba8467041d5ba0ac8230dd9e47893b67a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/042e0d02d74862796e9716abee07455b5e885151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/042e0d02d74862796e9716abee07455b5e885151", "html_url": "https://github.com/rust-lang/rust/commit/042e0d02d74862796e9716abee07455b5e885151", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/042e0d02d74862796e9716abee07455b5e885151/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "934d259b8ca1237c3fb50be21b8bba5ec8e6a7ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/934d259b8ca1237c3fb50be21b8bba5ec8e6a7ce", "html_url": "https://github.com/rust-lang/rust/commit/934d259b8ca1237c3fb50be21b8bba5ec8e6a7ce"}], "stats": {"total": 91, "additions": 68, "deletions": 23}, "files": [{"sha": "562a5933025f2da3514c07d46612e5fa669466dd", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 68, "deletions": 23, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/042e0d02d74862796e9716abee07455b5e885151/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042e0d02d74862796e9716abee07455b5e885151/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=042e0d02d74862796e9716abee07455b5e885151", "patch": "@@ -141,7 +141,7 @@ fn write_pending_elems(\n     if !done {\n         // We only want to \"open\" the tag ourselves if we have more than one pending and if the current\n         // parent tag is not the same as our pending content.\n-        let open_tag_ourselves = pending_elems.len() > 1;\n+        let open_tag_ourselves = pending_elems.len() > 1 && current_class.is_some();\n         let close_tag = if open_tag_ourselves {\n             enter_span(out, current_class.unwrap(), &href_context)\n         } else {\n@@ -158,6 +158,18 @@ fn write_pending_elems(\n     *current_class = None;\n }\n \n+fn handle_exit_span(\n+    out: &mut Buffer,\n+    href_context: &Option<HrefContext<'_, '_, '_>>,\n+    pending_elems: &mut Vec<(&str, Option<Class>)>,\n+    closing_tags: &mut Vec<(&str, Class)>,\n+) {\n+    let class = closing_tags.last().expect(\"ExitSpan without EnterSpan\").1;\n+    // We flush everything just in case...\n+    write_pending_elems(out, href_context, pending_elems, &mut Some(class), closing_tags);\n+    exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\").0);\n+}\n+\n /// Check if two `Class` can be merged together. In the following rules, \"unclassified\" means `None`\n /// basically (since it's `Option<Class>`). The following rules apply:\n ///\n@@ -171,7 +183,7 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n         (Some(c1), Some(c2)) => c1.is_equal_to(c2),\n         (Some(Class::Ident(_)), None) | (None, Some(Class::Ident(_))) => true,\n         (Some(_), None) | (None, Some(_)) => text.trim().is_empty(),\n-        _ => false,\n+        (None, None) => true,\n     }\n }\n \n@@ -196,6 +208,9 @@ fn write_code(\n     let src = src.replace(\"\\r\\n\", \"\\n\");\n     // It contains the closing tag and the associated `Class`.\n     let mut closing_tags: Vec<(&'static str, Class)> = Vec::new();\n+    // This is used because we don't automatically generate the closing tag on `ExitSpan` in\n+    // case an `EnterSpan` event with the same class follows.\n+    let mut pending_exit_span: Option<Class> = None;\n     // The following two variables are used to group HTML elements with same `class` attributes\n     // to reduce the DOM size.\n     let mut current_class: Option<Class> = None;\n@@ -211,9 +226,21 @@ fn write_code(\n     .highlight(&mut |highlight| {\n         match highlight {\n             Highlight::Token { text, class } => {\n+                // If we received a `ExitSpan` event and then have a non-compatible `Class`, we\n+                // need to close the `<span>`.\n+                if let Some(pending) = pending_exit_span &&\n+                    !can_merge(Some(pending), class, text) {\n+                        handle_exit_span(\n+                            out,\n+                            &href_context,\n+                            &mut pending_elems,\n+                            &mut closing_tags,\n+                        );\n+                        pending_exit_span = None;\n+                        current_class = class.map(Class::dummy);\n                 // If the two `Class` are different, time to flush the current content and start\n                 // a new one.\n-                if !can_merge(current_class, class, text) {\n+                } else if !can_merge(current_class, class, text) {\n                     write_pending_elems(\n                         out,\n                         &href_context,\n@@ -228,30 +255,48 @@ fn write_code(\n                 pending_elems.push((text, class));\n             }\n             Highlight::EnterSpan { class } => {\n-                // We flush everything just in case...\n-                write_pending_elems(\n-                    out,\n-                    &href_context,\n-                    &mut pending_elems,\n-                    &mut current_class,\n-                    &closing_tags,\n-                );\n-                closing_tags.push((enter_span(out, class, &href_context), class))\n+                let mut should_add = true;\n+                if pending_exit_span.is_some() {\n+                    if !can_merge(Some(class), pending_exit_span, \"\") {\n+                        handle_exit_span(out, &href_context, &mut pending_elems, &mut closing_tags);\n+                    } else {\n+                        should_add = false;\n+                    }\n+                } else {\n+                    // We flush everything just in case...\n+                    write_pending_elems(\n+                        out,\n+                        &href_context,\n+                        &mut pending_elems,\n+                        &mut current_class,\n+                        &closing_tags,\n+                    );\n+                }\n+                current_class = None;\n+                pending_exit_span = None;\n+                if should_add {\n+                    let closing_tag = enter_span(out, class, &href_context);\n+                    closing_tags.push((closing_tag, class));\n+                }\n             }\n             Highlight::ExitSpan => {\n-                // We flush everything just in case...\n-                write_pending_elems(\n-                    out,\n-                    &href_context,\n-                    &mut pending_elems,\n-                    &mut current_class,\n-                    &closing_tags,\n-                );\n-                exit_span(out, closing_tags.pop().expect(\"ExitSpan without EnterSpan\").0)\n+                current_class = None;\n+                pending_exit_span =\n+                    Some(closing_tags.last().as_ref().expect(\"ExitSpan without EnterSpan\").1);\n             }\n         };\n     });\n-    write_pending_elems(out, &href_context, &mut pending_elems, &mut current_class, &closing_tags);\n+    if pending_exit_span.is_some() {\n+        handle_exit_span(out, &href_context, &mut pending_elems, &mut closing_tags);\n+    } else {\n+        write_pending_elems(\n+            out,\n+            &href_context,\n+            &mut pending_elems,\n+            &mut current_class,\n+            &closing_tags,\n+        );\n+    }\n }\n \n fn write_footer(out: &mut Buffer, playground_button: Option<&str>) {\n@@ -761,7 +806,7 @@ impl<'a> Classifier<'a> {\n             TokenKind::CloseBracket => {\n                 if self.in_attribute {\n                     self.in_attribute = false;\n-                    sink(Highlight::Token { text: \"]\", class: Some(Class::Attribute) });\n+                    sink(Highlight::Token { text: \"]\", class: None });\n                     sink(Highlight::ExitSpan);\n                     return;\n                 }"}]}