{"sha": "c12f5fc006cab3c8276d186545bef4ab99db3673", "node_id": "C_kwDOAAsO6NoAKGMxMmY1ZmMwMDZjYWIzYzgyNzZkMTg2NTQ1YmVmNGFiOTlkYjM2NzM", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-20T11:29:25Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-07-20T11:29:25Z"}, "message": "no leak_check -> commit_unconditionally is noop", "tree": {"sha": "577ea555fc57fba16cda146dce86c2e7c7e23528", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/577ea555fc57fba16cda146dce86c2e7c7e23528"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c12f5fc006cab3c8276d186545bef4ab99db3673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c12f5fc006cab3c8276d186545bef4ab99db3673", "html_url": "https://github.com/rust-lang/rust/commit/c12f5fc006cab3c8276d186545bef4ab99db3673", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c12f5fc006cab3c8276d186545bef4ab99db3673/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b", "html_url": "https://github.com/rust-lang/rust/commit/748cb1f01d623f2afd0d8b84fda7e2c8f7a11c7b"}], "stats": {"total": 353, "additions": 167, "deletions": 186}, "files": [{"sha": "f14224c7f98f0ac5e1d4d2049bdfcf83b0283af8", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 145, "deletions": 162, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/c12f5fc006cab3c8276d186545bef4ab99db3673/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c12f5fc006cab3c8276d186545bef4ab99db3673/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=c12f5fc006cab3c8276d186545bef4ab99db3673", "patch": "@@ -158,67 +158,65 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligation: &TraitObligation<'tcx>,\n         idx: usize,\n     ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n-        self.infcx.commit_unconditionally(|_| {\n-            let tcx = self.tcx();\n-\n-            let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n-            let placeholder_trait_predicate =\n-                self.infcx().replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n-            let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n-            let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n-            let (def_id, substs) = match *placeholder_self_ty.kind() {\n-                ty::Projection(proj) => (proj.item_def_id, proj.substs),\n-                ty::Opaque(def_id, substs) => (def_id, substs),\n-                _ => bug!(\"projection candidate for unexpected type: {:?}\", placeholder_self_ty),\n-            };\n+        let tcx = self.tcx();\n \n-            let candidate_predicate =\n-                tcx.bound_item_bounds(def_id).map_bound(|i| i[idx]).subst(tcx, substs);\n-            let candidate = candidate_predicate\n-                .to_opt_poly_trait_pred()\n-                .expect(\"projection candidate is not a trait predicate\")\n-                .map_bound(|t| t.trait_ref);\n-            let mut obligations = Vec::new();\n-            let candidate = normalize_with_depth_to(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                candidate,\n-                &mut obligations,\n-            );\n+        let trait_predicate = self.infcx.shallow_resolve(obligation.predicate);\n+        let placeholder_trait_predicate =\n+            self.infcx().replace_bound_vars_with_placeholders(trait_predicate).trait_ref;\n+        let placeholder_self_ty = placeholder_trait_predicate.self_ty();\n+        let placeholder_trait_predicate = ty::Binder::dummy(placeholder_trait_predicate);\n+        let (def_id, substs) = match *placeholder_self_ty.kind() {\n+            ty::Projection(proj) => (proj.item_def_id, proj.substs),\n+            ty::Opaque(def_id, substs) => (def_id, substs),\n+            _ => bug!(\"projection candidate for unexpected type: {:?}\", placeholder_self_ty),\n+        };\n \n-            obligations.extend(self.infcx.commit_if_ok(|_| {\n-                self.infcx\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .sup(placeholder_trait_predicate, candidate)\n-                    .map(|InferOk { obligations, .. }| obligations)\n-                    .map_err(|_| Unimplemented)\n-            })?);\n-\n-            if let ty::Projection(..) = placeholder_self_ty.kind() {\n-                let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates;\n-                debug!(?predicates, \"projection predicates\");\n-                for predicate in predicates {\n-                    let normalized = normalize_with_depth_to(\n-                        self,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        predicate,\n-                        &mut obligations,\n-                    );\n-                    obligations.push(Obligation::with_depth(\n-                        obligation.cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        obligation.param_env,\n-                        normalized,\n-                    ));\n-                }\n+        let candidate_predicate =\n+            tcx.bound_item_bounds(def_id).map_bound(|i| i[idx]).subst(tcx, substs);\n+        let candidate = candidate_predicate\n+            .to_opt_poly_trait_pred()\n+            .expect(\"projection candidate is not a trait predicate\")\n+            .map_bound(|t| t.trait_ref);\n+        let mut obligations = Vec::new();\n+        let candidate = normalize_with_depth_to(\n+            self,\n+            obligation.param_env,\n+            obligation.cause.clone(),\n+            obligation.recursion_depth + 1,\n+            candidate,\n+            &mut obligations,\n+        );\n+\n+        obligations.extend(self.infcx.commit_if_ok(|_| {\n+            self.infcx\n+                .at(&obligation.cause, obligation.param_env)\n+                .sup(placeholder_trait_predicate, candidate)\n+                .map(|InferOk { obligations, .. }| obligations)\n+                .map_err(|_| Unimplemented)\n+        })?);\n+\n+        if let ty::Projection(..) = placeholder_self_ty.kind() {\n+            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates;\n+            debug!(?predicates, \"projection predicates\");\n+            for predicate in predicates {\n+                let normalized = normalize_with_depth_to(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    predicate,\n+                    &mut obligations,\n+                );\n+                obligations.push(Obligation::with_depth(\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    obligation.param_env,\n+                    normalized,\n+                ));\n             }\n+        }\n \n-            Ok(obligations)\n-        })\n+        Ok(obligations)\n     }\n \n     fn confirm_param_candidate(\n@@ -314,19 +312,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ensure_sufficient_stack(|| {\n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n \n-            let trait_obligations: Vec<PredicateObligation<'_>> =\n-                self.infcx.commit_unconditionally(|_| {\n-                    let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n-                    let trait_ref = self.infcx.replace_bound_vars_with_placeholders(poly_trait_ref);\n-                    self.impl_or_trait_obligations(\n-                        &cause,\n-                        obligation.recursion_depth + 1,\n-                        obligation.param_env,\n-                        trait_def_id,\n-                        &trait_ref.substs,\n-                        obligation.predicate,\n-                    )\n-                });\n+            let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n+            let trait_ref = self.infcx.replace_bound_vars_with_placeholders(poly_trait_ref);\n+            let trait_obligations: Vec<PredicateObligation<'_>> = self.impl_or_trait_obligations(\n+                &cause,\n+                obligation.recursion_depth + 1,\n+                obligation.param_env,\n+                trait_def_id,\n+                &trait_ref.substs,\n+                obligation.predicate,\n+            );\n \n             let mut obligations = self.collect_predicates_for_types(\n                 obligation.param_env,\n@@ -355,19 +350,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.commit_unconditionally(|_| {\n-            let substs = self.rematch_impl(impl_def_id, obligation);\n-            debug!(?substs, \"impl substs\");\n-            ensure_sufficient_stack(|| {\n-                self.vtable_impl(\n-                    impl_def_id,\n-                    substs,\n-                    &obligation.cause,\n-                    obligation.recursion_depth + 1,\n-                    obligation.param_env,\n-                    obligation.predicate,\n-                )\n-            })\n+        let substs = self.rematch_impl(impl_def_id, obligation);\n+        debug!(?substs, \"impl substs\");\n+        ensure_sufficient_stack(|| {\n+            self.vtable_impl(\n+                impl_def_id,\n+                substs,\n+                &obligation.cause,\n+                obligation.recursion_depth + 1,\n+                obligation.param_env,\n+                obligation.predicate,\n+            )\n         })\n     }\n \n@@ -614,25 +607,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) -> ImplSourceTraitAliasData<'tcx, PredicateObligation<'tcx>> {\n         debug!(?obligation, ?alias_def_id, \"confirm_trait_alias_candidate\");\n \n-        self.infcx.commit_unconditionally(|_| {\n-            let predicate = self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n-            let trait_ref = predicate.trait_ref;\n-            let trait_def_id = trait_ref.def_id;\n-            let substs = trait_ref.substs;\n+        let predicate = self.infcx().replace_bound_vars_with_placeholders(obligation.predicate);\n+        let trait_ref = predicate.trait_ref;\n+        let trait_def_id = trait_ref.def_id;\n+        let substs = trait_ref.substs;\n \n-            let trait_obligations = self.impl_or_trait_obligations(\n-                &obligation.cause,\n-                obligation.recursion_depth,\n-                obligation.param_env,\n-                trait_def_id,\n-                &substs,\n-                obligation.predicate,\n-            );\n+        let trait_obligations = self.impl_or_trait_obligations(\n+            &obligation.cause,\n+            obligation.recursion_depth,\n+            obligation.param_env,\n+            trait_def_id,\n+            &substs,\n+            obligation.predicate,\n+        );\n \n-            debug!(?trait_def_id, ?trait_obligations, \"trait alias obligations\");\n+        debug!(?trait_def_id, ?trait_obligations, \"trait alias obligations\");\n \n-            ImplSourceTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n-        })\n+        ImplSourceTraitAliasData { alias_def_id, substs, nested: trait_obligations }\n     }\n \n     fn confirm_generator_candidate(\n@@ -730,15 +721,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Normalize the obligation and expected trait refs together, because why not\n         let Normalized { obligations: nested, value: (obligation_trait_ref, expected_trait_ref) } =\n             ensure_sufficient_stack(|| {\n-                self.infcx.commit_unconditionally(|_| {\n-                    normalize_with_depth(\n-                        self,\n-                        obligation.param_env,\n-                        obligation.cause.clone(),\n-                        obligation.recursion_depth + 1,\n-                        (obligation_trait_ref, expected_trait_ref),\n-                    )\n-                })\n+                normalize_with_depth(\n+                    self,\n+                    obligation.param_env,\n+                    obligation.cause.clone(),\n+                    obligation.recursion_depth + 1,\n+                    (obligation_trait_ref, expected_trait_ref),\n+                )\n             });\n \n         self.infcx\n@@ -1114,32 +1103,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // first check it like a regular impl candidate.\n         // This is copied from confirm_impl_candidate but remaps the predicate to `~const Drop` beforehand.\n         if let Some(impl_def_id) = impl_def_id {\n-            let obligations = self.infcx.commit_unconditionally(|_| {\n-                let mut new_obligation = obligation.clone();\n-                new_obligation.predicate = new_obligation.predicate.map_bound(|mut trait_pred| {\n-                    trait_pred.trait_ref.def_id = drop_trait;\n-                    trait_pred\n-                });\n-                let substs = self.rematch_impl(impl_def_id, &new_obligation);\n-                debug!(?substs, \"impl substs\");\n-\n-                let cause = obligation.derived_cause(|derived| {\n-                    ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n-                        derived,\n-                        impl_def_id,\n-                        span: obligation.cause.span,\n-                    }))\n-                });\n-                ensure_sufficient_stack(|| {\n-                    self.vtable_impl(\n-                        impl_def_id,\n-                        substs,\n-                        &cause,\n-                        new_obligation.recursion_depth + 1,\n-                        new_obligation.param_env,\n-                        obligation.predicate,\n-                    )\n-                })\n+            let mut new_obligation = obligation.clone();\n+            new_obligation.predicate = new_obligation.predicate.map_bound(|mut trait_pred| {\n+                trait_pred.trait_ref.def_id = drop_trait;\n+                trait_pred\n+            });\n+            let substs = self.rematch_impl(impl_def_id, &new_obligation);\n+            debug!(?substs, \"impl substs\");\n+\n+            let cause = obligation.derived_cause(|derived| {\n+                ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n+                    derived,\n+                    impl_def_id,\n+                    span: obligation.cause.span,\n+                }))\n+            });\n+            let obligations = ensure_sufficient_stack(|| {\n+                self.vtable_impl(\n+                    impl_def_id,\n+                    substs,\n+                    &cause,\n+                    new_obligation.recursion_depth + 1,\n+                    new_obligation.param_env,\n+                    obligation.predicate,\n+                )\n             });\n             nested.extend(obligations.nested);\n         }\n@@ -1190,34 +1177,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // If we have a projection type, make sure to normalize it so we replace it\n                 // with a fresh infer variable\n                 ty::Projection(..) => {\n-                    self.infcx.commit_unconditionally(|_| {\n-                        let predicate = normalize_with_depth_to(\n-                            self,\n-                            obligation.param_env,\n-                            cause.clone(),\n-                            obligation.recursion_depth + 1,\n-                            self_ty\n-                                .rebind(ty::TraitPredicate {\n-                                    trait_ref: ty::TraitRef {\n-                                        def_id: self\n-                                            .tcx()\n-                                            .require_lang_item(LangItem::Destruct, None),\n-                                        substs: self.tcx().mk_substs_trait(nested_ty, &[]),\n-                                    },\n-                                    constness: ty::BoundConstness::ConstIfConst,\n-                                    polarity: ty::ImplPolarity::Positive,\n-                                })\n-                                .to_predicate(tcx),\n-                            &mut nested,\n-                        );\n-\n-                        nested.push(Obligation::with_depth(\n-                            cause.clone(),\n-                            obligation.recursion_depth + 1,\n-                            obligation.param_env,\n-                            predicate,\n-                        ));\n-                    });\n+                    let predicate = normalize_with_depth_to(\n+                        self,\n+                        obligation.param_env,\n+                        cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        self_ty\n+                            .rebind(ty::TraitPredicate {\n+                                trait_ref: ty::TraitRef {\n+                                    def_id: self.tcx().require_lang_item(LangItem::Destruct, None),\n+                                    substs: self.tcx().mk_substs_trait(nested_ty, &[]),\n+                                },\n+                                constness: ty::BoundConstness::ConstIfConst,\n+                                polarity: ty::ImplPolarity::Positive,\n+                            })\n+                            .to_predicate(tcx),\n+                        &mut nested,\n+                    );\n+\n+                    nested.push(Obligation::with_depth(\n+                        cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        predicate,\n+                    ));\n                 }\n \n                 // If we have any other type (e.g. an ADT), just register a nested obligation"}, {"sha": "2d8122e4128e8b699ffc5d021e3c5db149502eec", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c12f5fc006cab3c8276d186545bef4ab99db3673/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c12f5fc006cab3c8276d186545bef4ab99db3673/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=c12f5fc006cab3c8276d186545bef4ab99db3673", "patch": "@@ -2081,30 +2081,28 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .flat_map(|ty| {\n                 let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(*ty); // <----/\n \n-                self.infcx.commit_unconditionally(|_| {\n-                    let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);\n-                    let Normalized { value: normalized_ty, mut obligations } =\n-                        ensure_sufficient_stack(|| {\n-                            project::normalize_with_depth(\n-                                self,\n-                                param_env,\n-                                cause.clone(),\n-                                recursion_depth,\n-                                placeholder_ty,\n-                            )\n-                        });\n-                    let placeholder_obligation = predicate_for_trait_def(\n-                        self.tcx(),\n-                        param_env,\n-                        cause.clone(),\n-                        trait_def_id,\n-                        recursion_depth,\n-                        normalized_ty,\n-                        &[],\n-                    );\n-                    obligations.push(placeholder_obligation);\n-                    obligations\n-                })\n+                let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);\n+                let Normalized { value: normalized_ty, mut obligations } =\n+                    ensure_sufficient_stack(|| {\n+                        project::normalize_with_depth(\n+                            self,\n+                            param_env,\n+                            cause.clone(),\n+                            recursion_depth,\n+                            placeholder_ty,\n+                        )\n+                    });\n+                let placeholder_obligation = predicate_for_trait_def(\n+                    self.tcx(),\n+                    param_env,\n+                    cause.clone(),\n+                    trait_def_id,\n+                    recursion_depth,\n+                    normalized_ty,\n+                    &[],\n+                );\n+                obligations.push(placeholder_obligation);\n+                obligations\n             })\n             .collect()\n     }"}]}