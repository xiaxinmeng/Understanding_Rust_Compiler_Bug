{"sha": "c9f0f47bbba3d02a6389af14aaf1c3d1d088d191", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZjBmNDdiYmJhM2QwMmE2Mzg5YWYxNGFhZjFjM2QxZDA4OGQxOTE=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-29T12:02:06Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-29T12:02:06Z"}, "message": "simplify", "tree": {"sha": "c9c05d051033087b008e4058ff212eeadab3d1de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9c05d051033087b008e4058ff212eeadab3d1de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191", "html_url": "https://github.com/rust-lang/rust/commit/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "411eee76147b0730e1eb5afe84d13558de2ee082", "url": "https://api.github.com/repos/rust-lang/rust/commits/411eee76147b0730e1eb5afe84d13558de2ee082", "html_url": "https://github.com/rust-lang/rust/commit/411eee76147b0730e1eb5afe84d13558de2ee082"}], "stats": {"total": 177, "additions": 92, "deletions": 85}, "files": [{"sha": "610fec65a74627219b3fb4e08bfdc3c246038a47", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 90, "deletions": 83, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=c9f0f47bbba3d02a6389af14aaf1c3d1d088d191", "patch": "@@ -3,9 +3,11 @@\n //! This module uses a bit of static metadata to provide completions\n //! for built-in attributes.\n \n+use std::mem;\n+\n use once_cell::sync::Lazy;\n use rustc_hash::{FxHashMap, FxHashSet};\n-use syntax::{ast, AstNode, SyntaxKind, T};\n+use syntax::{ast, AstNode, NodeOrToken, SyntaxKind, T};\n \n use crate::{\n     context::CompletionContext,\n@@ -105,82 +107,92 @@ const fn attr(\n }\n \n macro_rules! attrs {\n+    // attributes applicable to all items\n     [@ { item $($tt:tt)* } {$($acc:tt)*}] => {\n         attrs!(@ { $($tt)* } { $($acc)*, \"deprecated\", \"doc\", \"dochidden\", \"docalias\", \"must_use\", \"no_mangle\" })\n     };\n+    // attributes applicable to all adts\n     [@ { adt $($tt:tt)* } {$($acc:tt)*}] => {\n         attrs!(@ { $($tt)* } { $($acc)*, \"derive\", \"repr\" })\n     };\n+    // attributes applicable to all linkable things aka functions/statics\n     [@ { linkable $($tt:tt)* } {$($acc:tt)*}] => {\n-        attrs!(@ { $($tt)* } { $($acc)*, \"export_name\", \"link_name\", \"link_section\" }) };\n-    [@ { $ty:ident $($tt:tt)* } {$($acc:tt)*}] => { compile_error!(concat!(\"unknown attr subtype \", stringify!($ty)))\n+        attrs!(@ { $($tt)* } { $($acc)*, \"export_name\", \"link_name\", \"link_section\" })\n+    };\n+    // error fallback for nicer error message\n+    [@ { $ty:ident $($tt:tt)* } {$($acc:tt)*}] => {\n+        compile_error!(concat!(\"unknown attr subtype \", stringify!($ty)))\n     };\n+    // general push down accumulation\n     [@ { $lit:literal $($tt:tt)*} {$($acc:tt)*}] => {\n         attrs!(@ { $($tt)* } { $($acc)*, $lit })\n     };\n     [@ {$($tt:tt)+} {$($tt2:tt)*}] => {\n         compile_error!(concat!(\"Unexpected input \", stringify!($($tt)+)))\n     };\n+    // final output construction\n     [@ {} {$($tt:tt)*}] => { &[$($tt)*] as _ };\n+    // starting matcher\n     [$($tt:tt),*] => {\n         attrs!(@ { $($tt)* } { \"allow\", \"cfg\", \"cfg_attr\", \"deny\", \"forbid\", \"warn\" })\n     };\n }\n \n #[rustfmt::skip]\n static KIND_TO_ATTRIBUTES: Lazy<FxHashMap<SyntaxKind, &[&str]>> = Lazy::new(|| {\n+    use SyntaxKind::*;\n     std::array::IntoIter::new([\n         (\n-            SyntaxKind::SOURCE_FILE,\n+            SOURCE_FILE,\n             attrs!(\n                 item,\n                 \"crate_name\", \"feature\", \"no_implicit_prelude\", \"no_main\", \"no_std\",\n                 \"recursion_limit\", \"type_length_limit\", \"windows_subsystem\"\n             ),\n         ),\n-        (SyntaxKind::MODULE, attrs!(item, \"no_implicit_prelude\", \"path\")),\n-        (SyntaxKind::ITEM_LIST, attrs!(item, \"no_implicit_prelude\")),\n-        (SyntaxKind::MACRO_RULES, attrs!(item, \"macro_export\", \"macro_use\")),\n-        (SyntaxKind::MACRO_DEF, attrs!(item)),\n-        (SyntaxKind::EXTERN_CRATE, attrs!(item, \"macro_use\", \"no_link\")),\n-        (SyntaxKind::USE, attrs!(item)),\n-        (SyntaxKind::TYPE_ALIAS, attrs!(item)),\n-        (SyntaxKind::STRUCT, attrs!(item, adt, \"non_exhaustive\")),\n-        (SyntaxKind::ENUM, attrs!(item, adt, \"non_exhaustive\")),\n-        (SyntaxKind::UNION, attrs!(item, adt)),\n-        (SyntaxKind::CONST, attrs!(item)),\n+        (MODULE, attrs!(item, \"no_implicit_prelude\", \"path\")),\n+        (ITEM_LIST, attrs!(item, \"no_implicit_prelude\")),\n+        (MACRO_RULES, attrs!(item, \"macro_export\", \"macro_use\")),\n+        (MACRO_DEF, attrs!(item)),\n+        (EXTERN_CRATE, attrs!(item, \"macro_use\", \"no_link\")),\n+        (USE, attrs!(item)),\n+        (TYPE_ALIAS, attrs!(item)),\n+        (STRUCT, attrs!(item, adt, \"non_exhaustive\")),\n+        (ENUM, attrs!(item, adt, \"non_exhaustive\")),\n+        (UNION, attrs!(item, adt)),\n+        (CONST, attrs!(item)),\n         (\n-            SyntaxKind::FN,\n+            FN,\n             attrs!(\n                 item, linkable,\n                 \"cold\", \"ignore\", \"inline\", \"must_use\", \"panic_handler\", \"proc_macro\",\n                 \"proc_macro_derive\", \"proc_macro_attribute\", \"should_panic\", \"target_feature\",\n                 \"test\", \"track_caller\"\n             ),\n         ),\n-        (SyntaxKind::STATIC, attrs!(item, linkable, \"global_allocator\", \"used\")),\n-        (SyntaxKind::TRAIT, attrs!(item, \"must_use\")),\n-        (SyntaxKind::IMPL, attrs!(item, \"automatically_derived\")),\n-        (SyntaxKind::ASSOC_ITEM_LIST, attrs!(item)),\n-        (SyntaxKind::EXTERN_BLOCK, attrs!(item, \"link\")),\n-        (SyntaxKind::EXTERN_ITEM_LIST, attrs!(item, \"link\")),\n-        (SyntaxKind::MACRO_CALL, attrs!()),\n-        (SyntaxKind::SELF_PARAM, attrs!()),\n-        (SyntaxKind::PARAM, attrs!()),\n-        (SyntaxKind::RECORD_FIELD, attrs!()),\n-        (SyntaxKind::VARIANT, attrs!(\"non_exhaustive\")),\n-        (SyntaxKind::TYPE_PARAM, attrs!()),\n-        (SyntaxKind::CONST_PARAM, attrs!()),\n-        (SyntaxKind::LIFETIME_PARAM, attrs!()),\n-        (SyntaxKind::LET_STMT, attrs!()),\n-        (SyntaxKind::EXPR_STMT, attrs!()),\n-        (SyntaxKind::LITERAL, attrs!()),\n-        (SyntaxKind::RECORD_EXPR_FIELD_LIST, attrs!()),\n-        (SyntaxKind::RECORD_EXPR_FIELD, attrs!()),\n-        (SyntaxKind::MATCH_ARM_LIST, attrs!()),\n-        (SyntaxKind::MATCH_ARM, attrs!()),\n-        (SyntaxKind::IDENT_PAT, attrs!()),\n-        (SyntaxKind::RECORD_PAT_FIELD, attrs!()),\n+        (STATIC, attrs!(item, linkable, \"global_allocator\", \"used\")),\n+        (TRAIT, attrs!(item, \"must_use\")),\n+        (IMPL, attrs!(item, \"automatically_derived\")),\n+        (ASSOC_ITEM_LIST, attrs!(item)),\n+        (EXTERN_BLOCK, attrs!(item, \"link\")),\n+        (EXTERN_ITEM_LIST, attrs!(item, \"link\")),\n+        (MACRO_CALL, attrs!()),\n+        (SELF_PARAM, attrs!()),\n+        (PARAM, attrs!()),\n+        (RECORD_FIELD, attrs!()),\n+        (VARIANT, attrs!(\"non_exhaustive\")),\n+        (TYPE_PARAM, attrs!()),\n+        (CONST_PARAM, attrs!()),\n+        (LIFETIME_PARAM, attrs!()),\n+        (LET_STMT, attrs!()),\n+        (EXPR_STMT, attrs!()),\n+        (LITERAL, attrs!()),\n+        (RECORD_EXPR_FIELD_LIST, attrs!()),\n+        (RECORD_EXPR_FIELD, attrs!()),\n+        (MATCH_ARM_LIST, attrs!()),\n+        (MATCH_ARM, attrs!()),\n+        (IDENT_PAT, attrs!()),\n+        (RECORD_PAT_FIELD, attrs!()),\n     ])\n     .collect()\n });\n@@ -257,62 +269,57 @@ const ATTRIBUTES: &[AttrCompletion] = &[\n     .prefer_inner(),\n ];\n \n-#[test]\n-fn attributes_are_sorted() {\n-    let mut attrs = ATTRIBUTES.iter().map(|attr| attr.key());\n-    let mut prev = attrs.next().unwrap();\n-\n-    attrs.for_each(|next| {\n-        assert!(\n-            prev < next,\n-            r#\"Attributes are not sorted, \"{}\" should come after \"{}\"\"#,\n-            prev,\n-            next\n-        );\n-        prev = next;\n-    });\n-}\n-\n-fn parse_comma_sep_input(derive_input: ast::TokenTree) -> Result<FxHashSet<String>, ()> {\n-    match (derive_input.left_delimiter_token(), derive_input.right_delimiter_token()) {\n-        (Some(left_paren), Some(right_paren))\n-            if left_paren.kind() == T!['('] && right_paren.kind() == T![')'] =>\n-        {\n-            let mut input_derives = FxHashSet::default();\n-            let mut current_derive = String::new();\n-            for token in derive_input\n-                .syntax()\n-                .children_with_tokens()\n-                .filter_map(|token| token.into_token())\n-                .skip_while(|token| token != &left_paren)\n-                .skip(1)\n-                .take_while(|token| token != &right_paren)\n-            {\n-                if T![,] == token.kind() {\n-                    if !current_derive.is_empty() {\n-                        input_derives.insert(current_derive);\n-                        current_derive = String::new();\n-                    }\n-                } else {\n-                    current_derive.push_str(token.text().trim());\n-                }\n-            }\n-\n+fn parse_comma_sep_input(derive_input: ast::TokenTree) -> Option<FxHashSet<String>> {\n+    let (l_paren, r_paren) = derive_input.l_paren_token().zip(derive_input.r_paren_token())?;\n+    let mut input_derives = FxHashSet::default();\n+    let mut current_derive = String::new();\n+    for token in derive_input\n+        .syntax()\n+        .children_with_tokens()\n+        .filter_map(NodeOrToken::into_token)\n+        .skip_while(|token| token != &l_paren)\n+        .skip(1)\n+        .take_while(|token| token != &r_paren)\n+    {\n+        if token.kind() == T![,] {\n             if !current_derive.is_empty() {\n-                input_derives.insert(current_derive);\n+                input_derives.insert(mem::take(&mut current_derive));\n             }\n-            Ok(input_derives)\n+        } else {\n+            current_derive.push_str(token.text().trim());\n         }\n-        _ => Err(()),\n     }\n+\n+    if !current_derive.is_empty() {\n+        input_derives.insert(current_derive);\n+    }\n+    Some(input_derives)\n }\n \n #[cfg(test)]\n mod tests {\n+    use super::*;\n+\n     use expect_test::{expect, Expect};\n \n     use crate::{test_utils::completion_list, CompletionKind};\n \n+    #[test]\n+    fn attributes_are_sorted() {\n+        let mut attrs = ATTRIBUTES.iter().map(|attr| attr.key());\n+        let mut prev = attrs.next().unwrap();\n+\n+        attrs.for_each(|next| {\n+            assert!(\n+                prev < next,\n+                r#\"ATTRIBUTES array is not sorted, \"{}\" should come after \"{}\"\"#,\n+                prev,\n+                next\n+            );\n+            prev = next;\n+        });\n+    }\n+\n     fn check(ra_fixture: &str, expect: Expect) {\n         let actual = completion_list(ra_fixture, CompletionKind::Attribute);\n         expect.assert_eq(&actual);"}, {"sha": "7b0a778a226e975303b0cc03440548de17ace6b7", "filename": "crates/ide_completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=c9f0f47bbba3d02a6389af14aaf1c3d1d088d191", "patch": "@@ -14,7 +14,7 @@ pub(super) fn complete_derive(\n     ctx: &CompletionContext,\n     derive_input: ast::TokenTree,\n ) {\n-    if let Ok(existing_derives) = super::parse_comma_sep_input(derive_input) {\n+    if let Some(existing_derives) = super::parse_comma_sep_input(derive_input) {\n         for derive_completion in DEFAULT_DERIVE_COMPLETIONS\n             .iter()\n             .filter(|completion| !existing_derives.contains(completion.label))"}, {"sha": "115c6cfe0cb273ec8daa56ece04ce65c583a8d76", "filename": "crates/ide_completion/src/completions/attribute/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9f0f47bbba3d02a6389af14aaf1c3d1d088d191/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=c9f0f47bbba3d02a6389af14aaf1c3d1d088d191", "patch": "@@ -13,7 +13,7 @@ pub(super) fn complete_lint(\n     derive_input: ast::TokenTree,\n     lints_completions: &[LintCompletion],\n ) {\n-    if let Ok(existing_lints) = super::parse_comma_sep_input(derive_input) {\n+    if let Some(existing_lints) = super::parse_comma_sep_input(derive_input) {\n         for lint_completion in lints_completions\n             .into_iter()\n             .filter(|completion| !existing_lints.contains(completion.label))"}]}