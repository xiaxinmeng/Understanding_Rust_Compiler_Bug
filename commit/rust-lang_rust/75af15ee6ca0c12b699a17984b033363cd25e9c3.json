{"sha": "75af15ee6ca0c12b699a17984b033363cd25e9c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1YWYxNWVlNmNhMGMxMmI2OTlhMTc5ODRiMDMzMzYzY2QyNWU5YzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-20T10:18:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-20T10:18:34Z"}, "message": "Auto merge of #49190 - kennytm:rollup, r=kennytm\n\nRollup of 17 pull requests\n\n- Successful merges: #46518, #48810, #48834, #48902, #49004, #49092, #49096, #49099, #49104, #49125, #49139, #49152, #49157, #49161, #49166, #49176, #49184\n- Failed merges:", "tree": {"sha": "02642ba3cf3431e3bfd86a75287965ffa6603048", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02642ba3cf3431e3bfd86a75287965ffa6603048"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75af15ee6ca0c12b699a17984b033363cd25e9c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75af15ee6ca0c12b699a17984b033363cd25e9c3", "html_url": "https://github.com/rust-lang/rust/commit/75af15ee6ca0c12b699a17984b033363cd25e9c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75af15ee6ca0c12b699a17984b033363cd25e9c3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b99172311c640c33f70676df7f75a899a999711c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b99172311c640c33f70676df7f75a899a999711c", "html_url": "https://github.com/rust-lang/rust/commit/b99172311c640c33f70676df7f75a899a999711c"}, {"sha": "57b821112eccebaa2a00bfa1193da55f5b677dc5", "url": "https://api.github.com/repos/rust-lang/rust/commits/57b821112eccebaa2a00bfa1193da55f5b677dc5", "html_url": "https://github.com/rust-lang/rust/commit/57b821112eccebaa2a00bfa1193da55f5b677dc5"}], "stats": {"total": 1678, "additions": 1029, "deletions": 649}, "files": [{"sha": "de7036db29f4afa5883a39e467731f8da575b764", "filename": "config.toml.example", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -243,11 +243,6 @@\n # compiler.\n #codegen-units = 1\n \n-# Whether to enable ThinLTO (and increase the codegen units to either a default\n-# or the configured value). On by default. If we want the fastest possible\n-# compiler, we should disable this.\n-#thinlto = true\n-\n # Whether or not debug assertions are enabled for the compiler and standard\n # library. Also enables compilation of debug! and trace! logging macros.\n #debug-assertions = false"}, {"sha": "26508dec4bba23c5200ed66226eda415449126a0", "filename": "src/Cargo.lock", "status": "modified", "additions": 47, "deletions": 92, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -236,18 +236,6 @@ dependencies = [\n  \"serde_json 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"cargo_metadata\"\n-version = \"0.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"cargo_metadata\"\n version = \"0.5.3\"\n@@ -588,15 +576,6 @@ dependencies = [\n  \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"env_logger\"\n-version = \"0.4.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"env_logger\"\n version = \"0.5.5\"\n@@ -1490,7 +1469,7 @@ dependencies = [\n  \"rls-rustc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustfmt-nightly 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustfmt-nightly 0.4.1\",\n  \"serde 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1585,7 +1564,7 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_cratesio_shim\"\n-version = \"29.0.0\"\n+version = \"67.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1594,57 +1573,62 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"29.0.0\"\n+version = \"67.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ena 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot_core 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"stable_deref_trait 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"29.0.0\"\n+version = \"67.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-ap-rustc_data_structures 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"termcolor 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"29.0.0\"\n+version = \"67.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"rustc-ap-syntax\"\n-version = \"29.0.0\"\n+version = \"67.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_cratesio_shim 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_data_structures 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax_pos 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_cratesio_shim 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_errors 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax_pos 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax_pos\"\n-version = \"29.0.0\"\n+version = \"67.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rustc-ap-rustc_data_structures 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-serialize 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-rustc_data_structures 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-serialize 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -2066,52 +2050,26 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"0.3.8\"\n+version = \"0.4.1\"\n dependencies = [\n- \"cargo_metadata 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"cargo_metadata 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"derive-new 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"itertools 0.7.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_derive 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde_json 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"rustfmt-nightly\"\n-version = \"0.4.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"cargo_metadata 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"derive-new 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"diff 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"getopts 0.2.15 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-rustc_errors 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-ap-syntax 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-ap-syntax 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2146,15 +2104,6 @@ name = \"scopeguard\"\n version = \"0.3.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"semver\"\n-version = \"0.8.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serde 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"semver\"\n version = \"0.9.0\"\n@@ -2424,6 +2373,15 @@ dependencies = [\n  \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"term\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"byteorder 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"termcolor\"\n version = \"0.3.5\"\n@@ -2737,7 +2695,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f2f382711e76b9de6c744cc00d0497baba02fb00a787f088c879f01d09468e32\"\n \"checksum byteorder 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"652805b7e73fada9d85e9a6682a4abd490cb52d96aeecc12e33a0de34dfd0d23\"\n \"checksum cargo_metadata 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be1057b8462184f634c3a208ee35b0f935cfd94b694b26deadccd98732088d7b\"\n-\"checksum cargo_metadata 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"20d6fb2b5574726329c85cdba0df0347fddfec3cf9c8b588f9931708280f5643\"\n \"checksum cargo_metadata 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b5caae26de3704081ef638f87f05a6891b04f2b7d5ce9429a3de21095528ae22\"\n \"checksum cc 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fedf677519ac9e865c4ff43ef8f930773b37ed6e6ea61b6b83b400a7b5787f49\"\n \"checksum cfg-if 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c819a1287eb618df47cc647173c5c4c66ba19d888a6e50d605672aed3140de\"\n@@ -2764,7 +2721,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum endian-type 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c34f04666d835ff5d62e058c3995147c06f42fe86ff053337632bca83e42702d\"\n \"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n-\"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n \"checksum env_logger 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f0628f04f7c26ebccf40d7fc2c1cf92236c05ec88cf2132641cc956812312f0f\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n \"checksum failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"934799b6c1de475a012a02dab0ace1ace43789ee4b99bcfbf1a2e3e8ced5de82\"\n@@ -2858,21 +2814,19 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rls-rustc 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"885f66b92757420572cbb02e033d4a9558c7413ca9b7ac206f28fd58ffdb44ea\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rls-vfs 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be231e1e559c315bc60ced5ad2cc2d7a9c208ed7d4e2c126500149836fda19bb\"\n-\"checksum rustc-ap-rustc_cratesio_shim 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4ad5e562044ea78a6764dd75ae8afe4b21fde49f4548024b5fdf6345c21fb524\"\n-\"checksum rustc-ap-rustc_data_structures 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d4c0d65325492aba7db72899e3edbab34d39af98c42ab7c7e450c9a288ffe4ad\"\n-\"checksum rustc-ap-rustc_errors 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"87d4ab2e06a671b5b5c5b0359dac346f164c99d059dce6a22feb08f2f56bd182\"\n-\"checksum rustc-ap-serialize 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e0745fa445ff41c4b6699936cf35ce3ca49502377dd7b3929c829594772c3a7b\"\n-\"checksum rustc-ap-syntax 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"82efedabe30f393161e11214a9130edfa01ad476372d1c6f3fec1f8d30488c9d\"\n-\"checksum rustc-ap-syntax_pos 29.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"db9de2e927e280c75b8efab9c5f591ad31082d5d2c4c562c68fdba2ee77286b0\"\n+\"checksum rustc-ap-rustc_cratesio_shim 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"adc16e4a6e50a4ffbd4633d737aedbdfcb565bdf658159e0544266908180a919\"\n+\"checksum rustc-ap-rustc_data_structures 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5ec5f0a018fbec07f64b689ac20f7343ed77939055ca07d2aceb37c832245b1b\"\n+\"checksum rustc-ap-rustc_errors 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8301221cc07002666eed552a089b15000bc954c94b14a460c0653363a7f42f4c\"\n+\"checksum rustc-ap-serialize 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5212ee40fc332d791cacf202ae5fb99197341857c0a14bcdf60541fea7dfc5ed\"\n+\"checksum rustc-ap-syntax 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"168571b3878c6c61aef4bacef95c86d30fa61fb1cff04395d9535c80c196e559\"\n+\"checksum rustc-ap-syntax_pos 67.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cd7a0486f56db583caa665c8b4ff02c4774fe279db1741509437bc8a84c53361\"\n \"checksum rustc-demangle 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11fb43a206a04116ffd7cfcf9bcb941f8eb6cc7ff667272246b0a1c74259a3cb\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n-\"checksum rustfmt-nightly 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"554256054eae37ead2f799ffa9cf8be8249496c6c3cf005c28b7cfa55f4efaa5\"\n \"checksum same-file 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cfb6eded0b06a0b512c8ddbcf04089138c9b4362c2f696f3c3d76039d68f3637\"\n \"checksum schannel 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fbaffce35eb61c5b00846e73128b0cd62717e7c0ec46abbec132370d013975b4\"\n \"checksum scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8674d439c964889e2476f474a3bf198cc9e199e77499960893bac5de7e9218a4\"\n \"checksum scopeguard 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"59a076157c1e2dc561d8de585151ee6965d910dd4dcb5dabb7ae3e83981a6c57\"\n \"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27\"\n-\"checksum semver 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bee2bc909ab2d8d60dab26e8cad85b25d795b14603a0dcb627b78b9d30b6454b\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \"checksum serde 1.0.29 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4763b773978e495252615e814d2ad04773b2c1f85421c7913869a537f35cb406\"\n@@ -2896,6 +2850,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum tar 0.4.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1605d3388ceb50252952ffebab4b5dc43017ead7e4481b175961c283bb951195\"\n \"checksum tempdir 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f73eebdb68c14bcb24aef74ea96079830e7fa7b31a6106e42ea7ee887c1e134e\"\n \"checksum term 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fa63644f74ce96fbeb9b794f66aff2a52d601cbd5e80f4b97123e3899f4570f1\"\n+\"checksum term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5e6b677dd1e8214ea1ef4297f85dbcbed8e8cdddb561040cc998ca2551c37561\"\n \"checksum termcolor 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"56c456352e44f9f91f774ddeeed27c1ec60a2455ed66d692059acfb1d731bda1\"\n \"checksum termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"689a3bdfaab439fd92bc87df5c4c78417d3cbe537487274e9b0b2dce76e92096\"\n \"checksum textwrap 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c0b59b6b4b44d867f1370ef1bd91bfb262bf07bf0ae65c202ea2fbc16153b693\""}, {"sha": "eca06eac7f30788fc7d53e8b723fc53c479ed154", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -221,6 +221,7 @@ fn make_win_dist(\n         \"libsecur32.a\",\n         \"libsetupapi.a\",\n         \"libshell32.a\",\n+        \"libsynchronization.a\",\n         \"libuser32.a\",\n         \"libuserenv.a\",\n         \"libuuid.a\","}, {"sha": "90043e1c716b6720545da4d8d8fa9ab5e50ec659", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -114,7 +114,7 @@\n //! * *nothing* \u21d2 [`Display`]\n //! * `?` \u21d2 [`Debug`]\n //! * `x?` \u21d2 [`Debug`] with lower-case hexadecimal integers\n-//! * `X?` \u21d2 [`Debug`] with lower-case hexadecimal integers\n+//! * `X?` \u21d2 [`Debug`] with upper-case hexadecimal integers\n //! * `o` \u21d2 [`Octal`](trait.Octal.html)\n //! * `x` \u21d2 [`LowerHex`](trait.LowerHex.html)\n //! * `X` \u21d2 [`UpperHex`](trait.UpperHex.html)"}, {"sha": "f45a32d4b94acd8a83f2da8643fb2823f9349c95", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 149, "deletions": 15, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -14,24 +14,154 @@\n \n /// A trait for borrowing data.\n ///\n-/// In general, there may be several ways to \"borrow\" a piece of data.  The\n-/// typical ways of borrowing a type `T` are `&T` (a shared borrow) and `&mut T`\n-/// (a mutable borrow). But types like `Vec<T>` provide additional kinds of\n-/// borrows: the borrowed slices `&[T]` and `&mut [T]`.\n+/// In Rust, it is common to provide different representations of a type for\n+/// different use cases. For instance, storage location and management for a\n+/// value can be specifically chosen as appropriate for a particular use via\n+/// pointer types such as [`Box<T>`] or [`Rc<T>`]. Beyond these generic\n+/// wrappers that can be used with any type, some types provide optional\n+/// facets providing potentially costly functionality. An example for such a\n+/// type is [`String`] which adds the ability to extend a string to the basic\n+/// [`str`]. This requires keeping additional information unnecessary for a\n+/// simple, immutable string.\n ///\n-/// When writing generic code, it is often desirable to abstract over all ways\n-/// of borrowing data from a given type. That is the role of the `Borrow`\n-/// trait: if `T: Borrow<U>`, then `&U` can be borrowed from `&T`.  A given\n-/// type can be borrowed as multiple different types. In particular, `Vec<T>:\n-/// Borrow<Vec<T>>` and `Vec<T>: Borrow<[T]>`.\n+/// These types provide access to the underlying data through references\n+/// to the type of that data. They are said to be \u2018borrowed as\u2019 that type.\n+/// For instance, a [`Box<T>`] can be borrowed as `T` while a [`String`]\n+/// can be borrowed as `str`.\n ///\n-/// If you are implementing `Borrow` and both `Self` and `Borrowed` implement\n-/// `Hash`, `Eq`, and/or `Ord`, they must produce the same result.\n+/// Types express that they can be borrowed as some type `T` by implementing\n+/// `Borrow<T>`, providing a reference to a `T` in the trait\u2019s\n+/// [`borrow`] method. A type is free to borrow as several different types.\n+/// If it wishes to mutably borrow as the type \u2013 allowing the underlying data\n+/// to be modified, it can additionally implement [`BorrowMut<T>`].\n ///\n-/// `Borrow` is very similar to, but different than, `AsRef`. See\n-/// [the book][book] for more.\n+/// Further, when providing implementations for additional traits, it needs\n+/// to be considered whether they should behave identical to those of the\n+/// underlying type as a consequence of acting as a representation of that\n+/// underlying type. Generic code typically uses `Borrow<T>` when it relies\n+/// on the identical behavior of these additional trait implementations.\n+/// These traits will likely appear as additional trait bounds.\n ///\n-/// [book]: ../../book/first-edition/borrow-and-asref.html\n+/// If generic code merely needs to work for all types that can\n+/// provide a reference to related type `T`, it is often better to use\n+/// [`AsRef<T>`] as more types can safely implement it.\n+///\n+/// [`AsRef<T>`]: ../../std/convert/trait.AsRef.html\n+/// [`BorrowMut<T>`]: trait.BorrowMut.html\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+/// [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n+/// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n+/// [`str`]: ../../std/primitive.str.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`borrow`]: #tymethod.borrow\n+///\n+/// # Examples\n+///\n+/// As a data collection, [`HashMap<K, V>`] owns both keys and values. If\n+/// the key\u2019s actual data is wrapped in a managing type of some kind, it\n+/// should, however, still be possible to search for a value using a\n+/// reference to the key\u2019s data. For instance, if the key is a string, then\n+/// it is likely stored with the hash map as a [`String`], while it should\n+/// be possible to search using a [`&str`][`str`]. Thus, `insert` needs to\n+/// operate on a `String` while `get` needs to be able to use a `&str`.\n+///\n+/// Slightly simplified, the relevant parts of `HashMap<K, V>` look like\n+/// this:\n+///\n+/// ```\n+/// use std::borrow::Borrow;\n+/// use std::hash::Hash;\n+///\n+/// pub struct HashMap<K, V> {\n+///     # marker: ::std::marker::PhantomData<(K, V)>,\n+///     // fields omitted\n+/// }\n+///\n+/// impl<K, V> HashMap<K, V> {\n+///     pub fn insert(&self, key: K, value: V) -> Option<V>\n+///     where K: Hash + Eq\n+///     {\n+///         # unimplemented!()\n+///         // ...\n+///     }\n+///\n+///     pub fn get<Q>(&self, k: &Q) -> Option<&V>\n+///     where\n+///         K: Borrow<Q>,\n+///         Q: Hash + Eq + ?Sized\n+///     {\n+///         # unimplemented!()\n+///         // ...\n+///     }\n+/// }\n+/// ```\n+///\n+/// The entire hash map is generic over a key type `K`. Because these keys\n+/// are stored with the hash map, this type has to own the key\u2019s data.\n+/// When inserting a key-value pair, the map is given such a `K` and needs\n+/// to find the correct hash bucket and check if the key is already present\n+/// based on that `K`. It therefore requires `K: Hash + Eq`.\n+///\n+/// When searching for a value in the map, however, having to provide a\n+/// reference to a `K` as the key to search for would require to always\n+/// create such an owned value. For string keys, this would mean a `String`\n+/// value needs to be created just for the search for cases where only a\n+/// `str` is available.\n+///\n+/// Instead, the `get` method is generic over the type of the underlying key\n+/// data, called `Q` in the method signature above. It states that `K`\n+/// borrows as a `Q` by requiring that `K: Borrow<Q>`. By additionally\n+/// requiring `Q: Hash + Eq`, it signals the requirement that `K` and `Q`\n+/// have implementations of the `Hash` and `Eq` traits that produce identical\n+/// results.\n+///\n+/// The implementation of `get` relies in particular on identical\n+/// implementations of `Hash` by determining the key\u2019s hash bucket by calling\n+/// `Hash::hash` on the `Q` value even though it inserted the key based on\n+/// the hash value calculated from the `K` value.\n+///\n+/// As a consequence, the hash map breaks if a `K` wrapping a `Q` value\n+/// produces a different hash than `Q`. For instance, imagine you have a\n+/// type that wraps a string but compares ASCII letters ignoring their case:\n+///\n+/// ```\n+/// pub struct CaseInsensitiveString(String);\n+///\n+/// impl PartialEq for CaseInsensitiveString {\n+///     fn eq(&self, other: &Self) -> bool {\n+///         self.0.eq_ignore_ascii_case(&other.0)\n+///     }\n+/// }\n+///\n+/// impl Eq for CaseInsensitiveString { }\n+/// ```\n+///\n+/// Because two equal values need to produce the same hash value, the\n+/// implementation of `Hash` needs to ignore ASCII case, too:\n+///\n+/// ```\n+/// # use std::hash::{Hash, Hasher};\n+/// # pub struct CaseInsensitiveString(String);\n+/// impl Hash for CaseInsensitiveString {\n+///     fn hash<H: Hasher>(&self, state: &mut H) {\n+///         for c in self.0.as_bytes() {\n+///             c.to_ascii_lowercase().hash(state)\n+///         }\n+///     }\n+/// }\n+/// ```\n+///\n+/// Can `CaseInsensitiveString` implement `Borrow<str>`? It certainly can\n+/// provide a reference to a string slice via its contained owned string.\n+/// But because its `Hash` implementation differs, it behaves differently\n+/// from `str` and therefore must not, in fact, implement `Borrow<str>`.\n+/// If it wants to allow others access to the underlying `str`, it can do\n+/// that via `AsRef<str>` which doesn\u2019t carry any extra requirements.\n+///\n+/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value.\n@@ -59,7 +189,11 @@ pub trait Borrow<Borrowed: ?Sized> {\n \n /// A trait for mutably borrowing data.\n ///\n-/// Similar to `Borrow`, but for mutable borrows.\n+/// As a companion to [`Borrow<T>`] this trait allows a type to borrow as\n+/// an underlying type by providing a mutable reference. See [`Borrow<T>`]\n+/// for more information on borrowing as another type.\n+///\n+/// [`Borrow<T>`]: trait.Borrow.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BorrowMut<Borrowed: ?Sized> : Borrow<Borrowed> {\n     /// Mutably borrows from an owned value."}, {"sha": "fcf06ea319d4382b05d88420bd96237557a7a709", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -49,15 +49,13 @@ doit! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }\n #[doc(hidden)]\n trait GenericRadix {\n     /// The number of digits.\n-    fn base(&self) -> u8;\n+    const BASE: u8;\n \n     /// A radix-specific prefix string.\n-    fn prefix(&self) -> &'static str {\n-        \"\"\n-    }\n+    const PREFIX: &'static str;\n \n     /// Converts an integer to corresponding radix digit.\n-    fn digit(&self, x: u8) -> u8;\n+    fn digit(x: u8) -> u8;\n \n     /// Format an integer using the radix using a formatter.\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -67,14 +65,14 @@ trait GenericRadix {\n         let is_nonnegative = x >= zero;\n         let mut buf = [0; 128];\n         let mut curr = buf.len();\n-        let base = T::from_u8(self.base());\n+        let base = T::from_u8(Self::BASE);\n         if is_nonnegative {\n             // Accumulate each digit of the number from the least significant\n             // to the most significant figure.\n             for byte in buf.iter_mut().rev() {\n-                let n = x % base;              // Get the current place value.\n-                x = x / base;                  // Deaccumulate the number.\n-                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n+                let n = x % base;               // Get the current place value.\n+                x = x / base;                   // Deaccumulate the number.\n+                *byte = Self::digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate.\n@@ -84,9 +82,9 @@ trait GenericRadix {\n         } else {\n             // Do the same as above, but accounting for two's complement.\n             for byte in buf.iter_mut().rev() {\n-                let n = zero - (x % base);     // Get the current place value.\n-                x = x / base;                  // Deaccumulate the number.\n-                *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n+                let n = zero - (x % base);      // Get the current place value.\n+                x = x / base;                   // Deaccumulate the number.\n+                *byte = Self::digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n                 if x == zero {\n                     // No more digits left to accumulate.\n@@ -95,7 +93,7 @@ trait GenericRadix {\n             }\n         }\n         let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };\n-        f.pad_integral(is_nonnegative, self.prefix(), buf)\n+        f.pad_integral(is_nonnegative, Self::PREFIX, buf)\n     }\n }\n \n@@ -122,12 +120,12 @@ struct UpperHex;\n macro_rules! radix {\n     ($T:ident, $base:expr, $prefix:expr, $($x:pat => $conv:expr),+) => {\n         impl GenericRadix for $T {\n-            fn base(&self) -> u8 { $base }\n-            fn prefix(&self) -> &'static str { $prefix }\n-            fn digit(&self, x: u8) -> u8 {\n+            const BASE: u8 = $base;\n+            const PREFIX: &'static str = $prefix;\n+            fn digit(x: u8) -> u8 {\n                 match x {\n                     $($x => $conv,)+\n-                    x => panic!(\"number not in the range 0..{}: {}\", self.base() - 1, x),\n+                    x => panic!(\"number not in the range 0..{}: {}\", Self::BASE - 1, x),\n                 }\n             }\n         }"}, {"sha": "826883fdc3f01de6bf0f3f08ae47f66d6893359a", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -317,11 +317,320 @@ macro_rules! wrapping_impl {\n         }\n         forward_ref_unop! { impl Neg, neg for Wrapping<$t>,\n                 #[stable(feature = \"wrapping_ref\", since = \"1.14.0\")] }\n+\n     )*)\n }\n \n wrapping_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n+macro_rules! wrapping_int_impl {\n+    ($($t:ty)*) => ($(\n+        impl Wrapping<$t> {\n+            /// Returns the number of ones in the binary representation of\n+            /// `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i8> = Wrapping(-0b1000_0000);\n+            ///\n+            /// assert_eq!(n.count_ones(), 1);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn count_ones(self) -> u32 {\n+                self.0.count_ones()\n+            }\n+\n+            /// Returns the number of zeros in the binary representation of\n+            /// `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i8> = Wrapping(-0b1000_0000);\n+            ///\n+            /// assert_eq!(n.count_zeros(), 7);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn count_zeros(self) -> u32 {\n+                self.0.count_zeros()\n+            }\n+\n+            /// Returns the number of leading zeros in the binary representation\n+            /// of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i16> = Wrapping(-1);\n+            ///\n+            /// assert_eq!(n.leading_zeros(), 0);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn leading_zeros(self) -> u32 {\n+                self.0.leading_zeros()\n+            }\n+\n+            /// Returns the number of trailing zeros in the binary representation\n+            /// of `self`.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i8> = Wrapping(-4);\n+            ///\n+            /// assert_eq!(n.trailing_zeros(), 2);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn trailing_zeros(self) -> u32 {\n+                self.0.trailing_zeros()\n+            }\n+\n+            /// Shifts the bits to the left by a specified amount, `n`,\n+            /// wrapping the truncated bits to the end of the resulting\n+            /// integer.\n+            ///\n+            /// Please note this isn't the same operation as `>>`!\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            /// let m: Wrapping<i64> = Wrapping(-0x76543210FEDCBA99);\n+            ///\n+            /// assert_eq!(n.rotate_left(32), m);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn rotate_left(self, n: u32) -> Self {\n+                Wrapping(self.0.rotate_left(n))\n+            }\n+\n+            /// Shifts the bits to the right by a specified amount, `n`,\n+            /// wrapping the truncated bits to the beginning of the resulting\n+            /// integer.\n+            ///\n+            /// Please note this isn't the same operation as `<<`!\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            /// let m: Wrapping<i64> = Wrapping(-0xFEDCBA987654322);\n+            ///\n+            /// assert_eq!(n.rotate_right(4), m);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn rotate_right(self, n: u32) -> Self {\n+                Wrapping(self.0.rotate_right(n))\n+            }\n+\n+            /// Reverses the byte order of the integer.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i16> = Wrapping(0b0000000_01010101);\n+            /// assert_eq!(n, Wrapping(85));\n+            ///\n+            /// let m = n.swap_bytes();\n+            ///\n+            /// assert_eq!(m, Wrapping(0b01010101_00000000));\n+            /// assert_eq!(m, Wrapping(21760));\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn swap_bytes(self) -> Self {\n+                Wrapping(self.0.swap_bytes())\n+            }\n+\n+            /// Converts an integer from big endian to the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(Wrapping::<i64>::from_be(n), n);\n+            /// } else {\n+            ///     assert_eq!(Wrapping::<i64>::from_be(n), n.swap_bytes());\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn from_be(x: Self) -> Self {\n+                Wrapping(<$t>::from_be(x.0))\n+            }\n+\n+            /// Converts an integer from little endian to the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(Wrapping::<i64>::from_le(n), n);\n+            /// } else {\n+            ///     assert_eq!(Wrapping::<i64>::from_le(n), n.swap_bytes());\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn from_le(x: Self) -> Self {\n+                Wrapping(<$t>::from_le(x.0))\n+            }\n+\n+            /// Converts `self` to big endian from the target's endianness.\n+            ///\n+            /// On big endian this is a no-op. On little endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            ///\n+            /// if cfg!(target_endian = \"big\") {\n+            ///     assert_eq!(n.to_be(), n);\n+            /// } else {\n+            ///     assert_eq!(n.to_be(), n.swap_bytes());\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn to_be(self) -> Self {\n+                Wrapping(self.0.to_be())\n+            }\n+\n+            /// Converts `self` to little endian from the target's endianness.\n+            ///\n+            /// On little endian this is a no-op. On big endian the bytes are\n+            /// swapped.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let n: Wrapping<i64> = Wrapping(0x0123456789ABCDEF);\n+            ///\n+            /// if cfg!(target_endian = \"little\") {\n+            ///     assert_eq!(n.to_le(), n);\n+            /// } else {\n+            ///     assert_eq!(n.to_le(), n.swap_bytes());\n+            /// }\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn to_le(self) -> Self {\n+                Wrapping(self.0.to_le())\n+            }\n+\n+            /// Raises self to the power of `exp`, using exponentiation by\n+            /// squaring.\n+            ///\n+            /// # Examples\n+            ///\n+            /// Basic usage:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// let x: Wrapping<i32> = Wrapping(2); // or any other integer type\n+            ///\n+            /// assert_eq!(x.pow(4), Wrapping(16));\n+            /// ```\n+            ///\n+            /// Results that are too large are wrapped:\n+            ///\n+            /// ```\n+            /// #![feature(wrapping_int_impl)]\n+            /// use std::num::Wrapping;\n+            ///\n+            /// // 5 ^ 4 = 625, which is too big for a u8\n+            /// let x: Wrapping<u8> = Wrapping(5);\n+            ///\n+            /// assert_eq!(x.pow(4).0, 113);\n+            /// ```\n+            #[inline]\n+            #[unstable(feature = \"wrapping_int_impl\", issue = \"32463\")]\n+            pub fn pow(self, exp: u32) -> Self {\n+                Wrapping(self.0.wrapping_pow(exp))\n+            }\n+        }\n+    )*)\n+}\n+\n+wrapping_int_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n+\n+\n mod shift_max {\n     #![allow(non_upper_case_globals)]\n "}, {"sha": "f1f383d7ad1262f5c5ae2cf30852d812286314fe", "filename": "src/librustc/dep_graph/README.md", "status": "modified", "additions": 3, "deletions": 294, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2FREADME.md?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1,295 +1,4 @@\n-# Dependency graph for incremental compilation\n+To learn more about how dependency tracking works in rustc, see the [rustc\n+guide].\n \n-This module contains the infrastructure for managing the incremental\n-compilation dependency graph. This README aims to explain how it ought\n-to be used. In this document, we'll first explain the overall\n-strategy, and then share some tips for handling specific scenarios.\n-\n-The high-level idea is that we want to instrument the compiler to\n-track which parts of the AST and other IR are read/written by what.\n-This way, when we come back later, we can look at this graph and\n-determine what work needs to be redone.\n-\n-### The dependency graph\n-\n-The nodes of the graph are defined by the enum `DepNode`. They represent\n-one of three things:\n-\n-1. HIR nodes (like `Hir(DefId)`) represent the HIR input itself.\n-2. Data nodes (like `TypeOfItem(DefId)`) represent some computed\n-   information about a particular item.\n-3. Procedure nodes (like `CoherenceCheckTrait(DefId)`) represent some\n-   procedure that is executing. Usually this procedure is\n-   performing some kind of check for errors. You can think of them as\n-   computed values where the value being computed is `()` (and the\n-   value may fail to be computed, if an error results).\n-\n-An edge `N1 -> N2` is added between two nodes if either:\n-\n-- the value of `N1` is used to compute `N2`;\n-- `N1` is read by the procedure `N2`;\n-- the procedure `N1` writes the value `N2`.\n-\n-The latter two conditions are equivalent to the first one if you think\n-of procedures as values.\n-\n-### Basic tracking\n-\n-There is a very general strategy to ensure that you have a correct, if\n-sometimes overconservative, dependency graph. The two main things you have\n-to do are (a) identify shared state and (b) identify the current tasks.\n-\n-### Identifying shared state\n-\n-Identify \"shared state\" that will be written by one pass and read by\n-another. In particular, we need to identify shared state that will be\n-read \"across items\" -- that is, anything where changes in one item\n-could invalidate work done for other items. So, for example:\n-\n-1. The signature for a function is \"shared state\".\n-2. The computed type of some expression in the body of a function is\n-   not shared state, because if it changes it does not itself\n-   invalidate other functions (though it may be that it causes new\n-   monomorphizations to occur, but that's handled independently).\n-\n-Put another way: if the HIR for an item changes, we are going to\n-recompile that item for sure. But we need the dep tracking map to tell\n-us what *else* we have to recompile. Shared state is anything that is\n-used to communicate results from one item to another.\n-\n-### Identifying the current task, tracking reads/writes, etc\n-\n-FIXME(#42293). This text needs to be rewritten for the new red-green\n-system, which doesn't fully exist yet.\n-\n-#### Dependency tracking map\n-\n-`DepTrackingMap` is a particularly convenient way to correctly store\n-shared state. A `DepTrackingMap` is a special hashmap that will add\n-edges automatically when `get` and `insert` are called. The idea is\n-that, when you get/insert a value for the key `K`, we will add an edge\n-from/to the node `DepNode::Variant(K)` (for some variant specific to\n-the map).\n-\n-Each `DepTrackingMap` is parameterized by a special type `M` that\n-implements `DepTrackingMapConfig`; this trait defines the key and value\n-types of the map, and also defines a fn for converting from the key to\n-a `DepNode` label. You don't usually have to muck about with this by\n-hand, there is a macro for creating it. You can see the complete set\n-of `DepTrackingMap` definitions in `librustc/middle/ty/maps.rs`.\n-\n-As an example, let's look at the `adt_defs` map. The `adt_defs` map\n-maps from the def-id of a struct/enum to its `AdtDef`. It is defined\n-using this macro:\n-\n-```rust\n-dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n-//            ~~~~~~~  ~~~~~~~~~~~~~ ~~~~~     ~~~~~~~~~~~~~~~~~~~~~~\n-//               |           |      Key type       Value type\n-//               |    DepNode variant\n-//      Name of map id type\n-```\n-\n-this indicates that a map id type `AdtDefs` will be created. The key\n-of the map will be a `DefId` and value will be\n-`ty::AdtDefMaster<'tcx>`. The `DepNode` will be created by\n-`DepNode::ItemSignature(K)` for a given key.\n-\n-Once that is done, you can just use the `DepTrackingMap` like any\n-other map:\n-\n-```rust\n-let mut map: DepTrackingMap<M> = DepTrackingMap::new(dep_graph);\n-map.insert(key, value); // registers dep_graph.write\n-map.get(key; // registers dep_graph.read\n-```\n-\n-#### Memoization\n-\n-One particularly interesting case is memoization. If you have some\n-shared state that you compute in a memoized fashion, the correct thing\n-to do is to define a `RefCell<DepTrackingMap>` for it and use the\n-`memoize` helper:\n-\n-```rust\n-map.memoize(key, || /* compute value */)\n-```\n-\n-This will create a graph that looks like\n-\n-    ... -> MapVariant(key) -> CurrentTask\n-\n-where `MapVariant` is the `DepNode` variant that the map is associated with,\n-and `...` are whatever edges the `/* compute value */` closure creates.\n-\n-In particular, using the memoize helper is much better than writing\n-the obvious code yourself:\n-\n-```rust\n-if let Some(result) = map.get(key) {\n-    return result;\n-}\n-let value = /* compute value */;\n-map.insert(key, value);\n-```\n-\n-If you write that code manually, the dependency graph you get will\n-include artificial edges that are not necessary. For example, imagine that\n-two tasks, A and B, both invoke the manual memoization code, but A happens\n-to go first. The resulting graph will be:\n-\n-    ... -> A -> MapVariant(key) -> B\n-    ~~~~~~~~~~~~~~~~~~~~~~~~~~~       // caused by A writing to MapVariant(key)\n-                ~~~~~~~~~~~~~~~~~~~~  // caused by B reading from MapVariant(key)\n-\n-This graph is not *wrong*, but it encodes a path from A to B that\n-should not exist.  In contrast, using the memoized helper, you get:\n-\n-    ... -> MapVariant(key) -> A\n-                 |\n-                 +----------> B\n-\n-which is much cleaner.\n-\n-**Be aware though that the closure is executed with `MapVariant(key)`\n-pushed onto the stack as the current task!** That means that you must\n-add explicit `read` calls for any shared state that it accesses\n-implicitly from its environment. See the section on \"explicit calls to\n-read and write when starting a new subtask\" above for more details.\n-\n-### How to decide where to introduce a new task\n-\n-Certainly, you need at least one task on the stack: any attempt to\n-`read` or `write` shared state will panic if there is no current\n-task. But where does it make sense to introduce subtasks? The basic\n-rule is that a subtask makes sense for any discrete unit of work you\n-may want to skip in the future. Adding a subtask separates out the\n-reads/writes from *that particular subtask* versus the larger\n-context. An example: you might have a 'meta' task for all of borrow\n-checking, and then subtasks for borrow checking individual fns.  (Seen\n-in this light, memoized computations are just a special case where we\n-may want to avoid redoing the work even within the context of one\n-compilation.)\n-\n-The other case where you might want a subtask is to help with refining\n-the reads/writes for some later bit of work that needs to be memoized.\n-For example, we create a subtask for type-checking the body of each\n-fn.  However, in the initial version of incr. comp. at least, we do\n-not expect to actually *SKIP* type-checking -- we only expect to skip\n-trans. However, it's still useful to create subtasks for type-checking\n-individual items, because, otherwise, if a fn sig changes, we won't\n-know which callers are affected -- in fact, because the graph would be\n-so coarse, we'd just have to retrans everything, since we can't\n-distinguish which fns used which fn sigs.\n-\n-### Testing the dependency graph\n-\n-There are various ways to write tests against the dependency graph.\n-The simplest mechanism are the\n-`#[rustc_if_this_changed]` and `#[rustc_then_this_would_need]`\n-annotations. These are used in compile-fail tests to test whether the\n-expected set of paths exist in the dependency graph. As an example,\n-see `src/test/compile-fail/dep-graph-caller-callee.rs`.\n-\n-The idea is that you can annotate a test like:\n-\n-```rust\n-#[rustc_if_this_changed]\n-fn foo() { }\n-\n-#[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK\n-fn bar() { foo(); }\n-\n-#[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path\n-fn baz() { }\n-```\n-\n-This will check whether there is a path in the dependency graph from\n-`Hir(foo)` to `TypeckTables(bar)`. An error is reported for each\n-`#[rustc_then_this_would_need]` annotation that indicates whether a\n-path exists. `//~ ERROR` annotations can then be used to test if a\n-path is found (as demonstrated above).\n-\n-### Debugging the dependency graph\n-\n-#### Dumping the graph\n-\n-The compiler is also capable of dumping the dependency graph for your\n-debugging pleasure. To do so, pass the `-Z dump-dep-graph` flag. The\n-graph will be dumped to `dep_graph.{txt,dot}` in the current\n-directory.  You can override the filename with the `RUST_DEP_GRAPH`\n-environment variable.\n-\n-Frequently, though, the full dep graph is quite overwhelming and not\n-particularly helpful. Therefore, the compiler also allows you to filter\n-the graph. You can filter in three ways:\n-\n-1. All edges originating in a particular set of nodes (usually a single node).\n-2. All edges reaching a particular set of nodes.\n-3. All edges that lie between given start and end nodes.\n-\n-To filter, use the `RUST_DEP_GRAPH_FILTER` environment variable, which should\n-look like one of the following:\n-\n-```\n-source_filter     // nodes originating from source_filter\n--> target_filter  // nodes that can reach target_filter\n-source_filter -> target_filter // nodes in between source_filter and target_filter\n-```\n-\n-`source_filter` and `target_filter` are a `&`-separated list of strings.\n-A node is considered to match a filter if all of those strings appear in its\n-label. So, for example:\n-\n-```\n-RUST_DEP_GRAPH_FILTER='-> TypeckTables'\n-```\n-\n-would select the predecessors of all `TypeckTables` nodes. Usually though you\n-want the `TypeckTables` node for some particular fn, so you might write:\n-\n-```\n-RUST_DEP_GRAPH_FILTER='-> TypeckTables & bar'\n-```\n-\n-This will select only the `TypeckTables` nodes for fns with `bar` in their name.\n-\n-Perhaps you are finding that when you change `foo` you need to re-type-check `bar`,\n-but you don't think you should have to. In that case, you might do:\n-\n-```\n-RUST_DEP_GRAPH_FILTER='Hir&foo -> TypeckTables & bar'\n-```\n-\n-This will dump out all the nodes that lead from `Hir(foo)` to\n-`TypeckTables(bar)`, from which you can (hopefully) see the source\n-of the erroneous edge.\n-\n-#### Tracking down incorrect edges\n-\n-Sometimes, after you dump the dependency graph, you will find some\n-path that should not exist, but you will not be quite sure how it came\n-to be. **When the compiler is built with debug assertions,** it can\n-help you track that down. Simply set the `RUST_FORBID_DEP_GRAPH_EDGE`\n-environment variable to a filter. Every edge created in the dep-graph\n-will be tested against that filter -- if it matches, a `bug!` is\n-reported, so you can easily see the backtrace (`RUST_BACKTRACE=1`).\n-\n-The syntax for these filters is the same as described in the previous\n-section. However, note that this filter is applied to every **edge**\n-and doesn't handle longer paths in the graph, unlike the previous\n-section.\n-\n-Example:\n-\n-You find that there is a path from the `Hir` of `foo` to the type\n-check of `bar` and you don't think there should be. You dump the\n-dep-graph as described in the previous section and open `dep-graph.txt`\n-to see something like:\n-\n-    Hir(foo) -> Collect(bar)\n-    Collect(bar) -> TypeckTables(bar)\n-\n-That first edge looks suspicious to you. So you set\n-`RUST_FORBID_DEP_GRAPH_EDGE` to `Hir&foo -> Collect&bar`, re-run, and\n-then observe the backtrace. Voila, bug fixed!\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/query.html"}, {"sha": "d44f2ec95492f9592456577a4158042ff2a74c90", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -580,7 +580,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// the pop occurs as part of the rollback, so an explicit call is not\n     /// needed (but is also permitted).\n     ///\n-    /// See `README.md` for more details.\n+    /// For more information about how skolemization for HRTBs works, see\n+    /// the [rustc guide].\n+    ///\n+    /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            binder: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot<'a, 'tcx>)"}, {"sha": "0086aed3e7c975b94b41d8b2646139b55be56dca", "filename": "src/librustc/infer/lexical_region_resolve/README.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1,14 +1,16 @@\n # Region inference\n \n+> WARNING: This README is obsolete and will be removed soon! For\n+> more info on how the current borrowck works, see the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir-borrowck.html\n+\n ## Terminology\n \n Note that we use the terms region and lifetime interchangeably.\n \n ## Introduction\n \n-See the [general inference README](../README.md) for an overview of\n-how lexical-region-solving fits into the bigger picture.\n-\n Region inference uses a somewhat more involved algorithm than type\n inference. It is not the most efficient thing ever written though it\n seems to work well enough in practice (famous last words).  The reason"}, {"sha": "07b87e2012dde775df98f09d6c502d3ec8a8aed0", "filename": "src/librustc/infer/region_constraints/README.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2FREADME.md?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1,18 +1,25 @@\n # Region constraint collection\n \n+> WARNING: This README is obsolete and will be removed soon! For\n+> more info on how the current borrowck works, see the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir-borrowck.html\n+\n ## Terminology\n \n Note that we use the terms region and lifetime interchangeably.\n \n ## Introduction\n \n-As described in the [inference README](../README.md), and unlike\n+As described in the rustc guide [chapter on type inference][ti], and unlike\n normal type inference, which is similar in spirit to H-M and thus\n works progressively, the region type inference works by accumulating\n constraints over the course of a function.  Finally, at the end of\n processing a function, we process and solve the constraints all at\n once.\n \n+[ti]: https://rust-lang-nursery.github.io/rustc-guide/type-inference.html\n+\n The constraints are always of one of three possible forms:\n \n - `ConstrainVarSubVar(Ri, Rj)` states that region variable Ri must be"}, {"sha": "e864485539b2d65f3555966fabcd2d704b64e52b", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -468,8 +468,10 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// the APIs in `higher_ranked/mod.rs`, such as\n     /// `skolemize_late_bound_regions` and `plug_leaks`, which will\n     /// guide you on this path (ensure that the `SkolemizationMap` is\n-    /// consumed and you are good).  There are also somewhat extensive\n-    /// comments in `higher_ranked/README.md`.\n+    /// consumed and you are good). For more info on how skolemization\n+    /// for HRTBs works, see the [rustc guide].\n+    ///\n+    /// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n     ///\n     /// The `snapshot` argument to this function is not really used;\n     /// it's just there to make it explicit which snapshot bounds the"}, {"sha": "966353b53a95aefa875399f02271ebdf8aee23a5", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -402,12 +402,10 @@ fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n \n fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     for pat in &arm.pats {\n-        // for struct patterns, take note of which fields used shorthand (`x`\n-        // rather than `x: x`)\n+        // for struct patterns, take note of which fields used shorthand (`x` rather than `x: x`)\n         //\n-        // FIXME: according to the rust-lang-nursery/rustc-guide book and\n-        // librustc/README.md, `NodeId`s are to be phased out in favor of\n-        // `HirId`s; however, we need to match the signature of `each_binding`,\n+        // FIXME: according to the rust-lang-nursery/rustc-guide book, `NodeId`s are to be phased\n+        // out in favor of `HirId`s; however, we need to match the signature of `each_binding`,\n         // which uses `NodeIds`.\n         let mut shorthand_field_ids = NodeSet();\n         if let hir::PatKind::Struct(_, ref fields, _) = pat.node {"}, {"sha": "c7396b34c4689548bd413d4ec8e71b24268105a2", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -11,8 +11,10 @@\n //! This file builds up the `ScopeTree`, which describes\n //! the parent links in the region hierarchy.\n //!\n-//! Most of the documentation on regions can be found in\n-//! `middle/infer/region_constraints/README.md`\n+//! For more information about how MIR-based region-checking works,\n+//! see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir-borrowck.html\n \n use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};"}, {"sha": "64a1729982a3168aae8757340c5fbfcc3da40ce5", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! MIR datatypes and passes. See the module-level [README] for details.\n+//! MIR datatypes and passes. See the [rustc guide] for more info.\n //!\n-//! [README]: https://github.com/rust-lang/rust/blob/master/src/librustc/mir/README.md\n+//! [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir.html\n \n use graphviz::IntoCow;\n use middle::const_val::ConstVal;"}, {"sha": "ab3c619dcdcd0a42e209d72d6a8603855c1cc2d7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -606,6 +606,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         }\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n \n                         // Try to report a help message\n                         if !trait_ref.has_infer_types() &&\n@@ -844,6 +845,54 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n+    /// suggest removing these references until we reach a type that implements the trait.\n+    fn suggest_remove_reference(&self,\n+                                obligation: &PredicateObligation<'tcx>,\n+                                err: &mut DiagnosticBuilder<'tcx>,\n+                                trait_ref: &ty::Binder<ty::TraitRef<'tcx>>) {\n+        let ty::Binder(trait_ref) = trait_ref;\n+        let span = obligation.cause.span;\n+\n+        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+            let refs_number = snippet.chars()\n+                .filter(|c| !c.is_whitespace())\n+                .take_while(|c| *c == '&')\n+                .count();\n+\n+            let mut trait_type = trait_ref.self_ty();\n+            let mut selcx = SelectionContext::new(self);\n+\n+            for refs_remaining in 0..refs_number {\n+                if let ty::TypeVariants::TyRef(_, ty::TypeAndMut{ ty: t_type, mutbl: _ }) =\n+                    trait_type.sty {\n+\n+                    trait_type = t_type;\n+\n+                    let substs = self.tcx.mk_substs_trait(trait_type, &[]);\n+                    let new_trait_ref = ty::TraitRef::new(trait_ref.def_id, substs);\n+                    let new_obligation = Obligation::new(ObligationCause::dummy(),\n+                                                         obligation.param_env,\n+                                                         new_trait_ref.to_predicate());\n+\n+                    if selcx.evaluate_obligation(&new_obligation) {\n+                        let sp = self.tcx.sess.codemap()\n+                            .span_take_while(span, |c| c.is_whitespace() || *c == '&');\n+\n+                        let remove_refs = refs_remaining + 1;\n+                        let format_str = format!(\"consider removing {} leading `&`-references\",\n+                                                 remove_refs);\n+\n+                        err.span_suggestion_short(sp, &format_str, String::from(\"\"));\n+                        break;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n     /// Given some node representing a fn-like thing in the HIR map,\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to"}, {"sha": "e0d662657b7de60574a69a9bf59ecbcb60bdde54", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -36,6 +36,7 @@ use util::nodemap::{DefIdMap, FxHashMap};\n ///   parents of a given specializing impl, which is needed for extracting\n ///   default items amongst other things. In the simple \"chain\" rule, every impl\n ///   has at most one parent.\n+#[derive(RustcEncodable, RustcDecodable)]\n pub struct Graph {\n     // all impls have a parent; the \"root\" impls have as their parent the def_id\n     // of the trait\n@@ -47,6 +48,7 @@ pub struct Graph {\n \n /// Children of a given impl, grouped into blanket/non-blanket varieties as is\n /// done in `TraitDef`.\n+#[derive(RustcEncodable, RustcDecodable)]\n struct Children {\n     // Impls of a trait (or specializations of a given impl). To allow for\n     // quicker lookup, the impls are indexed by a simplified version of their"}, {"sha": "31b3ca44700e96676f076782f02d0af0797279f1", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -28,7 +28,7 @@ pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n /// because we sometimes need to use SimplifiedTypeGen values as stable sorting\n /// keys (in which case we use a DefPathHash as id-type) but in the general case\n /// the non-stable but fast to construct DefId-version is the better choice.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub enum SimplifiedTypeGen<D>\n     where D: Copy + Debug + Ord + Eq + Hash\n {"}, {"sha": "117d92193123564fffb7365427601f2a0a81b0d1", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -727,3 +727,4 @@ impl_disk_cacheable_query!(type_of, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(predicates_of, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(used_trait_imports, |def_id| def_id.is_local());\n impl_disk_cacheable_query!(trans_fn_attrs, |_| true);\n+impl_disk_cacheable_query!(specialization_graph_of, |_| true);"}, {"sha": "04437a1c9e2c2053a9a70c0117e7c8b9a9fc0e8a", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -232,6 +232,7 @@ impl<'sess> OnDiskCache<'sess> {\n                 encode_query_results::<symbol_name, _>(tcx, enc, qri)?;\n                 encode_query_results::<check_match, _>(tcx, enc, qri)?;\n                 encode_query_results::<trans_fn_attrs, _>(tcx, enc, qri)?;\n+                encode_query_results::<specialization_graph_of, _>(tcx, enc, qri)?;\n \n                 // const eval is special, it only encodes successfully evaluated constants\n                 use ty::maps::plumbing::GetCacheInternal;"}, {"sha": "c514679042527f3cbb225dffa0897b93a2519c91", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1003,4 +1003,5 @@ impl_load_from_cache!(\n     PredicatesOfItem => predicates_of,\n     UsedTraitImports => used_trait_imports,\n     TransFnAttrs => trans_fn_attrs,\n+    SpecializationGraph => specialization_graph_of,\n );"}, {"sha": "bb5c7b5fd2a5e0eddf38a9a041837c7415450109", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -991,10 +991,11 @@ pub type Region<'tcx> = &'tcx RegionKind;\n /// the inference variable is supposed to satisfy the relation\n /// *for every value of the skolemized region*. To ensure that doesn't\n /// happen, you can use `leak_check`. This is more clearly explained\n-/// by infer/higher_ranked/README.md.\n+/// by the [rustc guide].\n ///\n /// [1]: http://smallcultfollowing.com/babysteps/blog/2013/10/29/intermingled-parameter-lists/\n /// [2]: http://smallcultfollowing.com/babysteps/blog/2013/11/04/intermingled-parameter-lists/\n+/// [rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trait-hrtb.html\n #[derive(Clone, PartialEq, Eq, Hash, Copy, RustcEncodable, RustcDecodable, PartialOrd, Ord)]\n pub enum RegionKind {\n     // Region bound in a type or fn declaration which will be"}, {"sha": "3c01692c12b3c846957c15f44d2746158808e1f8", "filename": "src/librustc_back/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_back%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_back%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2FREADME.md?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1,6 +1,6 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n-\n `librustc_back` contains some very low-level details that are\n specific to different LLVM targets and so forth.\n+\n+For more information about how trans works, see the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trans.html"}, {"sha": "29f03c06ab75999c5048b74340ee2a87b8cf60b0", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1,5 +1,10 @@\n % The Borrow Checker\n \n+> WARNING: This README is more or less obsolete, and will be removed\n+> soon! The new system is described in the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/mir-borrowck.html\n+\n This pass has the job of enforcing memory safety. This is a subtle\n topic. This docs aim to explain both the practice and the theory\n behind the borrow checker. They start with a high-level overview of"}, {"sha": "93d6247eeae47733af3b4f8833bbb248ceda400c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -253,28 +253,28 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     used_mut_nodes: RefCell<FxHashSet<HirId>>,\n }\n \n-impl<'b, 'tcx: 'b> BorrowckErrors for BorrowckCtxt<'b, 'tcx> {\n-    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'a>\n+impl<'a, 'b, 'tcx: 'b> BorrowckErrors<'a> for &'a BorrowckCtxt<'b, 'tcx> {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n+                                                     sp: S,\n+                                                     msg: &str,\n+                                                     code: DiagnosticId)\n+                                                     -> DiagnosticBuilder<'a>\n     {\n         self.tcx.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'a>\n+    fn struct_span_err<S: Into<MultiSpan>>(self,\n+                                           sp: S,\n+                                           msg: &str)\n+                                           -> DiagnosticBuilder<'a>\n     {\n         self.tcx.sess.struct_span_err(sp, msg)\n     }\n \n-    fn cancel_if_wrong_origin<'a>(&'a self,\n-                                mut diag: DiagnosticBuilder<'a>,\n-                                o: Origin)\n-                                -> DiagnosticBuilder<'a>\n+    fn cancel_if_wrong_origin(self,\n+                              mut diag: DiagnosticBuilder<'a>,\n+                              o: Origin)\n+                              -> DiagnosticBuilder<'a>\n     {\n         if !o.should_emit_errors(self.tcx.borrowck_mode()) {\n             self.tcx.sess.diagnostic().cancel(&mut diag);"}, {"sha": "fef249a9e4eb8e02936c99691908a8f20772965a", "filename": "src/librustc_driver/README.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_driver%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_driver%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FREADME.md?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1,12 +1,10 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n-\n The `driver` crate is effectively the \"main\" function for the rust\n compiler.  It orchestrates the compilation process and \"knits together\"\n the code from the other crates within rustc. This crate itself does\n not contain any of the \"main logic\" of the compiler (though it does\n have some code related to pretty printing or other minor compiler\n options).\n \n+For more information about how the driver works, see the [rustc guide].\n \n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/rustc-driver.html"}, {"sha": "5e15348de5e718a76632bf2e11c1daeceb341e4b", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -52,44 +52,44 @@ impl Origin {\n     }\n }\n \n-pub trait BorrowckErrors {\n-    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'a>;\n-\n-    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'a>;\n+pub trait BorrowckErrors<'cx>: Sized + Copy {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n+                                                     sp: S,\n+                                                     msg: &str,\n+                                                     code: DiagnosticId)\n+                                                     -> DiagnosticBuilder<'cx>;\n+\n+    fn struct_span_err<S: Into<MultiSpan>>(self,\n+                                           sp: S,\n+                                           msg: &str)\n+                                           -> DiagnosticBuilder<'cx>;\n \n     /// Cancels the given error if we shouldn't emit errors for a given\n     /// origin in the current mode.\n     ///\n     /// Always make sure that the error gets passed through this function\n     /// before you return it.\n-    fn cancel_if_wrong_origin<'a>(&'a self,\n-                                diag: DiagnosticBuilder<'a>,\n-                                o: Origin)\n-                                -> DiagnosticBuilder<'a>;\n+    fn cancel_if_wrong_origin(self,\n+                              diag: DiagnosticBuilder<'cx>,\n+                              o: Origin)\n+                              -> DiagnosticBuilder<'cx>;\n \n-    fn cannot_move_when_borrowed(&self, span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder<'_>\n+    fn cannot_move_when_borrowed(self, span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0505,\n                                    \"cannot move out of `{}` because it is borrowed{OGN}\",\n                                    desc, OGN=o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_use_when_mutably_borrowed(&self,\n+    fn cannot_use_when_mutably_borrowed(self,\n                                         span: Span,\n                                         desc: &str,\n                                         borrow_span: Span,\n                                         borrow_desc: &str,\n                                         o: Origin)\n-                                        -> DiagnosticBuilder<'_>\n+                                        -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, span, E0503,\n                          \"cannot use `{}` because it was mutably borrowed{OGN}\",\n@@ -101,28 +101,28 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_uninitialized_variable(&self,\n+    fn cannot_act_on_uninitialized_variable(self,\n                                             span: Span,\n                                             verb: &str,\n                                             desc: &str,\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0381,\n                                    \"{} of possibly uninitialized variable: `{}`{OGN}\",\n                                    verb, desc, OGN=o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_mutably_borrow_multiply(&self,\n+    fn cannot_mutably_borrow_multiply(self,\n                                       new_loan_span: Span,\n                                       desc: &str,\n                                       opt_via: &str,\n                                       old_loan_span: Span,\n                                       old_opt_via: &str,\n                                       old_load_end_span: Option<Span>,\n                                       o: Origin)\n-                                      -> DiagnosticBuilder\n+                                      -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0499,\n                          \"cannot borrow `{}`{} as mutable more than once at a time{OGN}\",\n@@ -148,13 +148,13 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_two_closures(&self,\n+    fn cannot_uniquely_borrow_by_two_closures(self,\n                                               new_loan_span: Span,\n                                               desc: &str,\n                                               old_loan_span: Span,\n                                               old_load_end_span: Option<Span>,\n                                               o: Origin)\n-                                              -> DiagnosticBuilder\n+                                              -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0524,\n                          \"two closures require unique access to `{}` at the same time{OGN}\",\n@@ -173,7 +173,7 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_uniquely_borrow_by_one_closure(&self,\n+    fn cannot_uniquely_borrow_by_one_closure(self,\n                                              new_loan_span: Span,\n                                              desc_new: &str,\n                                              opt_via: &str,\n@@ -182,7 +182,7 @@ pub trait BorrowckErrors {\n                                              old_opt_via: &str,\n                                              previous_end_span: Option<Span>,\n                                              o: Origin)\n-                                             -> DiagnosticBuilder\n+                                             -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0500,\n                          \"closure requires unique access to `{}` but {} is already borrowed{}{OGN}\",\n@@ -197,7 +197,7 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_uniquely_borrowed(&self,\n+    fn cannot_reborrow_already_uniquely_borrowed(self,\n                                                  new_loan_span: Span,\n                                                  desc_new: &str,\n                                                  opt_via: &str,\n@@ -206,7 +206,7 @@ pub trait BorrowckErrors {\n                                                  old_opt_via: &str,\n                                                  previous_end_span: Option<Span>,\n                                                  o: Origin)\n-                                                 -> DiagnosticBuilder\n+                                                 -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, new_loan_span, E0501,\n                          \"cannot borrow `{}`{} as {} because previous closure \\\n@@ -222,7 +222,7 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reborrow_already_borrowed(&self,\n+    fn cannot_reborrow_already_borrowed(self,\n                                         span: Span,\n                                         desc_new: &str,\n                                         msg_new: &str,\n@@ -233,7 +233,7 @@ pub trait BorrowckErrors {\n                                         msg_old: &str,\n                                         old_load_end_span: Option<Span>,\n                                         o: Origin)\n-                                        -> DiagnosticBuilder\n+                                        -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, span, E0502,\n                          \"cannot borrow `{}`{} as {} because {} is also borrowed as {}{}{OGN}\",\n@@ -246,8 +246,8 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_to_borrowed(&self, span: Span, borrow_span: Span, desc: &str, o: Origin)\n-                                 -> DiagnosticBuilder\n+    fn cannot_assign_to_borrowed(self, span: Span, borrow_span: Span, desc: &str, o: Origin)\n+                                 -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, span, E0506,\n                          \"cannot assign to `{}` because it is borrowed{OGN}\",\n@@ -259,8 +259,8 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_into_closure(&self, span: Span, desc: &str, o: Origin)\n-                                -> DiagnosticBuilder\n+    fn cannot_move_into_closure(self, span: Span, desc: &str, o: Origin)\n+                                -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0504,\n                                    \"cannot move `{}` into closure because it is borrowed{OGN}\",\n@@ -269,8 +269,8 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_reassign_immutable(&self, span: Span, desc: &str, is_arg: bool, o: Origin)\n-                                 -> DiagnosticBuilder\n+    fn cannot_reassign_immutable(self, span: Span, desc: &str, is_arg: bool, o: Origin)\n+                                 -> DiagnosticBuilder<'cx>\n     {\n         let msg = if is_arg {\n             \"to immutable argument\"\n@@ -284,22 +284,22 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign(&self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder\n+    fn cannot_assign(self, span: Span, desc: &str, o: Origin) -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0594,\n                                   \"cannot assign to {}{OGN}\",\n                                   desc, OGN=o);\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_static(&self, span: Span, desc: &str, o: Origin)\n-                            -> DiagnosticBuilder\n+    fn cannot_assign_static(self, span: Span, desc: &str, o: Origin)\n+                            -> DiagnosticBuilder<'cx>\n     {\n         self.cannot_assign(span, &format!(\"immutable static item `{}`\", desc), o)\n     }\n \n-    fn cannot_move_out_of(&self, move_from_span: Span, move_from_desc: &str, o: Origin)\n-                          -> DiagnosticBuilder\n+    fn cannot_move_out_of(self, move_from_span: Span, move_from_desc: &str, o: Origin)\n+                          -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, move_from_span, E0507,\n                                        \"cannot move out of {}{OGN}\",\n@@ -311,12 +311,12 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_out_of_interior_noncopy(&self,\n+    fn cannot_move_out_of_interior_noncopy(self,\n                                            move_from_span: Span,\n                                            ty: ty::Ty,\n                                            is_index: bool,\n                                            o: Origin)\n-                                           -> DiagnosticBuilder\n+                                           -> DiagnosticBuilder<'cx>\n     {\n         let type_name = match (&ty.sty, is_index) {\n             (&ty::TyArray(_, _), true) => \"array\",\n@@ -332,11 +332,11 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_move_out_of_interior_of_drop(&self,\n+    fn cannot_move_out_of_interior_of_drop(self,\n                                            move_from_span: Span,\n                                            container_ty: ty::Ty,\n                                            o: Origin)\n-                                           -> DiagnosticBuilder\n+                                           -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, move_from_span, E0509,\n                                        \"cannot move out of type `{}`, \\\n@@ -347,13 +347,13 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_moved_value(&self,\n+    fn cannot_act_on_moved_value(self,\n                                  use_span: Span,\n                                  verb: &str,\n                                  optional_adverb_for_moved: &str,\n                                  moved_path: &str,\n                                  o: Origin)\n-                                 -> DiagnosticBuilder\n+                                 -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, use_span, E0382,\n                                    \"{} of {}moved value: `{}`{OGN}\",\n@@ -362,11 +362,11 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_partially_reinit_an_uninit_struct(&self,\n+    fn cannot_partially_reinit_an_uninit_struct(self,\n                                                 span: Span,\n                                                 uninit_path: &str,\n                                                 o: Origin)\n-                                                -> DiagnosticBuilder\n+                                                -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self,\n                                    span,\n@@ -377,35 +377,35 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn closure_cannot_assign_to_borrowed(&self,\n+    fn closure_cannot_assign_to_borrowed(self,\n                                          span: Span,\n                                          descr: &str,\n                                          o: Origin)\n-                                         -> DiagnosticBuilder\n+                                         -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n                                    descr, OGN=o);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_path_as_mutable(&self,\n+    fn cannot_borrow_path_as_mutable(self,\n                                      span: Span,\n                                      path: &str,\n                                      o: Origin)\n-                                     -> DiagnosticBuilder\n+                                     -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n                                    path, OGN=o);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_across_generator_yield(&self,\n+    fn cannot_borrow_across_generator_yield(self,\n                                             span: Span,\n                                             yield_span: Span,\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self,\n                                        span,\n@@ -417,23 +417,23 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn path_does_not_live_long_enough(&self,\n+    fn path_does_not_live_long_enough(self,\n                                       span: Span,\n                                       path: &str,\n                                       o: Origin)\n-                                      -> DiagnosticBuilder\n+                                      -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n                                    path, OGN=o);\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn lifetime_too_short_for_reborrow(&self,\n+    fn lifetime_too_short_for_reborrow(self,\n                                        span: Span,\n                                        path: &str,\n                                        o: Origin)\n-                                       -> DiagnosticBuilder\n+                                       -> DiagnosticBuilder<'cx>\n     {\n         let err = struct_span_err!(self, span, E0598,\n                                    \"lifetime of {} is too short to guarantee \\\n@@ -443,12 +443,12 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_act_on_capture_in_sharable_fn(&self,\n+    fn cannot_act_on_capture_in_sharable_fn(self,\n                                             span: Span,\n                                             bad_thing: &str,\n                                             help: (Span, &str),\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n     {\n         let (help_span, help_msg) = help;\n         let mut err = struct_span_err!(self, span, E0387,\n@@ -459,11 +459,11 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_assign_into_immutable_reference(&self,\n+    fn cannot_assign_into_immutable_reference(self,\n                                               span: Span,\n                                               bad_thing: &str,\n                                               o: Origin)\n-                                              -> DiagnosticBuilder\n+                                              -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n                                        bad_thing, OGN=o);\n@@ -472,12 +472,12 @@ pub trait BorrowckErrors {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_capture_in_long_lived_closure(&self,\n+    fn cannot_capture_in_long_lived_closure(self,\n                                             closure_span: Span,\n                                             borrowed_path: &str,\n                                             capture_span: Span,\n                                             o: Origin)\n-                                            -> DiagnosticBuilder\n+                                            -> DiagnosticBuilder<'cx>\n     {\n         let mut err = struct_span_err!(self, closure_span, E0373,\n                                        \"closure may outlive the current function, \\\n@@ -491,28 +491,28 @@ pub trait BorrowckErrors {\n     }\n }\n \n-impl<'b, 'gcx, 'tcx> BorrowckErrors for TyCtxt<'b, 'gcx, 'tcx> {\n-    fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n-                                                         sp: S,\n-                                                         msg: &str,\n-                                                         code: DiagnosticId)\n-                                                         -> DiagnosticBuilder<'a>\n+impl<'cx, 'gcx, 'tcx> BorrowckErrors<'cx> for TyCtxt<'cx, 'gcx, 'tcx> {\n+    fn struct_span_err_with_code<S: Into<MultiSpan>>(self,\n+                                                     sp: S,\n+                                                     msg: &str,\n+                                                     code: DiagnosticId)\n+                                                     -> DiagnosticBuilder<'cx>\n     {\n         self.sess.struct_span_err_with_code(sp, msg, code)\n     }\n \n-    fn struct_span_err<'a, S: Into<MultiSpan>>(&'a self,\n-                                               sp: S,\n-                                               msg: &str)\n-                                               -> DiagnosticBuilder<'a>\n+    fn struct_span_err<S: Into<MultiSpan>>(self,\n+                                           sp: S,\n+                                           msg: &str)\n+                                           -> DiagnosticBuilder<'cx>\n     {\n         self.sess.struct_span_err(sp, msg)\n     }\n \n-    fn cancel_if_wrong_origin<'a>(&'a self,\n-                                mut diag: DiagnosticBuilder<'a>,\n-                                o: Origin)\n-                                -> DiagnosticBuilder<'a>\n+    fn cancel_if_wrong_origin(self,\n+                              mut diag: DiagnosticBuilder<'cx>,\n+                              o: Origin)\n+                              -> DiagnosticBuilder<'cx>\n     {\n         if !o.should_emit_errors(self.borrowck_mode()) {\n             self.sess.diagnostic().cancel(&mut diag);"}, {"sha": "e5157a071bf0aa65df72e5ee9cda63508db9d272", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -67,7 +67,7 @@ impl<'a> AstValidator<'a> {\n                                            E0449,\n                                            \"unnecessary visibility qualifier\");\n             if vis.node == VisibilityKind::Public {\n-                err.span_label(vis.span, \"`pub` not needed here\");\n+                err.span_label(vis.span, \"`pub` not permitted here because it's implied\");\n             }\n             if let Some(note) = note {\n                 err.note(note);"}, {"sha": "d1868ba2abb1722760356eb4812c20173ebe063b", "filename": "src/librustc_trans/README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_trans%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_trans%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FREADME.md?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1,7 +1,7 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n-\n The `trans` crate contains the code to convert from MIR into LLVM IR,\n and then from LLVM IR into machine code. In general it contains code\n that runs towards the end of the compilation process.\n+\n+For more information about how trans works, see the [rustc guide].\n+\n+[rustc guide]: https://rust-lang-nursery.github.io/rustc-guide/trans.html"}, {"sha": "701b896b9057bc8b07c3853df3e053845abb6745", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -18,8 +18,9 @@ use syntax::ast;\n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::{self, Span};\n use rustc::hir;\n-use rustc::hir::print;\n use rustc::hir::def::Def;\n+use rustc::hir::map::NodeItem;\n+use rustc::hir::{Item, ItemConst, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use errors::{DiagnosticBuilder, CodeMapper};\n \n@@ -318,6 +319,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       checked_ty: Ty<'tcx>,\n                       expected_ty: Ty<'tcx>)\n                       -> bool {\n+        let parent_id = self.tcx.hir.get_parent_node(expr.id);\n+        match self.tcx.hir.find(parent_id) {\n+            Some(parent) => {\n+                // Shouldn't suggest `.into()` on `const`s.\n+                if let NodeItem(Item { node: ItemConst(_, _), .. }) = parent {\n+                    // FIXME(estebank): modify once we decide to suggest `as` casts\n+                    return false;\n+                }\n+            }\n+            None => {}\n+        };\n+\n         let will_truncate = \"will truncate the source value\";\n         let depending_on_isize = \"will truncate or zero-extend depending on the bit width of \\\n                                   `isize`\";"}, {"sha": "21c1d9d670d65b787c5c0797ae6a171d5842422f", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -239,52 +239,59 @@\n         }\n     }\n \n-    function handleShortcut(ev) {\n-        if (document.activeElement.tagName === \"INPUT\" &&\n-                hasClass(document.getElementById('main'), \"hidden\")) {\n-            return;\n+    function handleEscape(ev, help) {\n+        hideModal();\n+        var search = document.getElementById(\"search\");\n+        if (!hasClass(help, \"hidden\")) {\n+            displayHelp(false, ev);\n+        } else if (!hasClass(search, \"hidden\")) {\n+            ev.preventDefault();\n+            addClass(search, \"hidden\");\n+            removeClass(document.getElementById(\"main\"), \"hidden\");\n         }\n+        defocusSearchBar();\n+    }\n \n+    function handleShortcut(ev) {\n         // Don't interfere with browser shortcuts\n         if (ev.ctrlKey || ev.altKey || ev.metaKey) {\n             return;\n         }\n \n         var help = document.getElementById(\"help\");\n-        switch (getVirtualKey(ev)) {\n-        case \"Escape\":\n-            hideModal();\n-            var search = document.getElementById(\"search\");\n-            if (!hasClass(help, \"hidden\")) {\n-                displayHelp(false, ev);\n-            } else if (!hasClass(search, \"hidden\")) {\n-                ev.preventDefault();\n-                addClass(search, \"hidden\");\n-                removeClass(document.getElementById(\"main\"), \"hidden\");\n+        if (document.activeElement.tagName === \"INPUT\") {\n+            switch (getVirtualKey(ev)) {\n+            case \"Escape\":\n+                handleEscape(ev, help);\n+                break;\n             }\n-            defocusSearchBar();\n-            break;\n+        } else {\n+            switch (getVirtualKey(ev)) {\n+            case \"Escape\":\n+                handleEscape(ev, help);\n+                break;\n \n-        case \"s\":\n-        case \"S\":\n-            displayHelp(false, ev);\n-            hideModal();\n-            ev.preventDefault();\n-            focusSearchBar();\n-            break;\n+            case \"s\":\n+            case \"S\":\n+                displayHelp(false, ev);\n+                hideModal();\n+                ev.preventDefault();\n+                focusSearchBar();\n+                break;\n \n-        case \"+\":\n-        case \"-\":\n-            ev.preventDefault();\n-            toggleAllDocs();\n-            break;\n+            case \"+\":\n+            case \"-\":\n+                ev.preventDefault();\n+                toggleAllDocs();\n+                break;\n \n-        case \"?\":\n-            if (ev.shiftKey) {\n-                hideModal();\n-                displayHelp(true, ev);\n+            case \"?\":\n+                if (ev.shiftKey) {\n+                    hideModal();\n+                    displayHelp(true, ev);\n+                }\n+                break;\n             }\n-            break;\n         }\n     }\n "}, {"sha": "ccaa19acc8379eaaa68424656281cf5cac597409", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -168,8 +168,36 @@ impl<R: Read> BufReader<R> {\n     /// # }\n     /// ```\n     #[unstable(feature = \"bufreader_is_empty\", issue = \"45323\", reason = \"recently added\")]\n+    #[rustc_deprecated(since = \"1.26.0\", reason = \"use .buffer().is_empty() instead\")]\n     pub fn is_empty(&self) -> bool {\n-        self.pos == self.cap\n+        self.buffer().is_empty()\n+    }\n+\n+    /// Returns a reference to the internally buffered data.\n+    ///\n+    /// Unlike `fill_buf`, this will not attempt to fill the buffer if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(bufreader_buffer)]\n+    /// use std::io::{BufReader, BufRead};\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let f = File::open(\"log.txt\")?;\n+    /// let mut reader = BufReader::new(f);\n+    /// assert!(reader.buffer().is_empty());\n+    ///\n+    /// if reader.fill_buf()?.len() > 0 {\n+    ///     assert!(!reader.buffer().is_empty());\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n+    #[unstable(feature = \"bufreader_buffer\", issue = \"45323\")]\n+    pub fn buffer(&self) -> &[u8] {\n+        &self.buf[self.pos..self.cap]\n     }\n \n     /// Unwraps this `BufReader`, returning the underlying reader."}, {"sha": "7214203830e7457b1bea2c1317779bc7cbd8d4a2", "filename": "src/libsyntax/README.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibsyntax%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibsyntax%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FREADME.md?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1,7 +1,9 @@\n-NB: This crate is part of the Rust compiler. For an overview of the\n-compiler as a whole, see\n-[the README.md file found in `librustc`](../librustc/README.md).\n-\n The `syntax` crate contains those things concerned purely with syntax\n \u2013 that is, the AST (\"abstract syntax tree\"), parser, pretty-printer,\n lexer, macro expander, and utilities for traversing ASTs.\n+\n+For more information about how these things work in rustc, see the\n+rustc guide:\n+\n+- [Parsing](https://rust-lang-nursery.github.io/rustc-guide/the-parser.html)\n+- [Macro Expansion](https://rust-lang-nursery.github.io/rustc-guide/macro-expansion.html)"}, {"sha": "73924c4270e669706b2fc027bff54c3fb4a9bce6", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -597,21 +597,6 @@ impl CodeMap {\n         self.span_to_source(sp, |src, start_index, _| src[..start_index].to_string())\n     }\n \n-    /// Given a `Span`, try to get a shorter span ending before the first occurrence of `c` `char`\n-    pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n-        match self.span_to_snippet(sp) {\n-            Ok(snippet) => {\n-                let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_right();\n-                if !snippet.is_empty() && !snippet.contains('\\n') {\n-                    sp.with_hi(BytePos(sp.lo().0 + snippet.len() as u32))\n-                } else {\n-                    sp\n-                }\n-            }\n-            _ => sp,\n-        }\n-    }\n-\n     /// Extend the given `Span` to just after the previous occurrence of `c`. Return the same span\n     /// if no character could be found or if an error occurred while retrieving the code snippet.\n     pub fn span_extend_to_prev_char(&self, sp: Span, c: char) -> Span {\n@@ -646,55 +631,74 @@ impl CodeMap {\n         sp\n     }\n \n+    /// Given a `Span`, try to get a shorter span ending before the first occurrence of `c` `char`\n+    pub fn span_until_char(&self, sp: Span, c: char) -> Span {\n+        match self.span_to_snippet(sp) {\n+            Ok(snippet) => {\n+                let snippet = snippet.split(c).nth(0).unwrap_or(\"\").trim_right();\n+                if !snippet.is_empty() && !snippet.contains('\\n') {\n+                    sp.with_hi(BytePos(sp.lo().0 + snippet.len() as u32))\n+                } else {\n+                    sp\n+                }\n+            }\n+            _ => sp,\n+        }\n+    }\n+\n+    /// Given a `Span`, try to get a shorter span ending just after the first occurrence of `char`\n+    /// `c`.\n+    pub fn span_through_char(&self, sp: Span, c: char) -> Span {\n+        if let Ok(snippet) = self.span_to_snippet(sp) {\n+            if let Some(offset) = snippet.find(c) {\n+                return sp.with_hi(BytePos(sp.lo().0 + (offset + c.len_utf8()) as u32));\n+            }\n+        }\n+        sp\n+    }\n+\n     /// Given a `Span`, get a new `Span` covering the first token and all its trailing whitespace or\n     /// the original `Span`.\n     ///\n     /// If `sp` points to `\"let mut x\"`, then a span pointing at `\"let \"` will be returned.\n     pub fn span_until_non_whitespace(&self, sp: Span) -> Span {\n-        if let Ok(snippet) = self.span_to_snippet(sp) {\n-            let mut offset = 0;\n-            // get the bytes width of all the non-whitespace characters\n-            for c in snippet.chars().take_while(|c| !c.is_whitespace()) {\n-                offset += c.len_utf8();\n-            }\n-            // get the bytes width of all the whitespace characters after that\n-            for c in snippet[offset..].chars().take_while(|c| c.is_whitespace()) {\n-                offset += c.len_utf8();\n+        let mut whitespace_found = false;\n+\n+        self.span_take_while(sp, |c| {\n+            if !whitespace_found && c.is_whitespace() {\n+                whitespace_found = true;\n             }\n-            if offset > 1 {\n-                return sp.with_hi(BytePos(sp.lo().0 + offset as u32));\n+\n+            if whitespace_found && !c.is_whitespace() {\n+                false\n+            } else {\n+                true\n             }\n-        }\n-        sp\n+        })\n     }\n \n     /// Given a `Span`, get a new `Span` covering the first token without its trailing whitespace or\n     /// the original `Span` in case of error.\n     ///\n     /// If `sp` points to `\"let mut x\"`, then a span pointing at `\"let\"` will be returned.\n     pub fn span_until_whitespace(&self, sp: Span) -> Span {\n-        if let Ok(snippet) = self.span_to_snippet(sp) {\n-            let mut offset = 0;\n-            // Get the bytes width of all the non-whitespace characters\n-            for c in snippet.chars().take_while(|c| !c.is_whitespace()) {\n-                offset += c.len_utf8();\n-            }\n-            if offset > 1 {\n-                return sp.with_hi(BytePos(sp.lo().0 + offset as u32));\n-            }\n-        }\n-        sp\n+        self.span_take_while(sp, |c| !c.is_whitespace())\n     }\n \n-    /// Given a `Span`, try to get a shorter span ending just after the first occurrence of `char`\n-    /// `c`.\n-    pub fn span_through_char(&self, sp: Span, c: char) -> Span {\n+    /// Given a `Span`, get a shorter one until `predicate` yields false.\n+    pub fn span_take_while<P>(&self, sp: Span, predicate: P) -> Span\n+        where P: for <'r> FnMut(&'r char) -> bool\n+    {\n         if let Ok(snippet) = self.span_to_snippet(sp) {\n-            if let Some(offset) = snippet.find(c) {\n-                return sp.with_hi(BytePos(sp.lo().0 + (offset + c.len_utf8()) as u32));\n-            }\n+            let offset = snippet.chars()\n+                .take_while(predicate)\n+                .map(|c| c.len_utf8())\n+                .sum::<usize>();\n+\n+            sp.with_hi(BytePos(sp.lo().0 + (offset as u32)))\n+        } else {\n+            sp\n         }\n-        sp\n     }\n \n     pub fn def_span(&self, sp: Span) -> Span {"}, {"sha": "4c3f42d9c6b7d4c2f94406de5f05ed0e6e7843e9", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -90,7 +90,7 @@ impl<'a> Parser<'a> {\n         debug!(\"parse_attribute_with_inner_parse_policy: inner_parse_policy={:?} self.token={:?}\",\n                inner_parse_policy,\n                self.token);\n-        let (span, path, tokens, mut style) = match self.token {\n+        let (span, path, tokens, style) = match self.token {\n             token::Pound => {\n                 let lo = self.span;\n                 self.bump();\n@@ -129,15 +129,6 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        if inner_parse_policy == InnerAttributeParsePolicy::Permitted &&\n-           self.token == token::Semi {\n-            self.bump();\n-            self.span_warn(span,\n-                           \"this inner attribute syntax is deprecated. The new syntax is \\\n-                            `#![foo]`, with a bang and no semicolon\");\n-            style = ast::AttrStyle::Inner;\n-        }\n-\n         Ok(ast::Attribute {\n             id: attr::mk_attr_id(),\n             style,"}, {"sha": "96ec1e6834dff30aa0c129f31b3af9a41349369b", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.x.0` for Cargo where they were released on `date`.\n \n-date: 2018-02-20\n+date: 2018-03-18\n rustc: beta\n cargo: beta\n "}, {"sha": "df3b09ba7c9f34b8f9a2ac7a39223446f98bcb4a", "filename": "src/test/ui/error-codes/E0449.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Ferror-codes%2FE0449.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Ferror-codes%2FE0449.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0449.stderr?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -2,21 +2,21 @@ error[E0449]: unnecessary visibility qualifier\n   --> $DIR/E0449.rs:17:1\n    |\n LL | pub impl Bar {} //~ ERROR E0449\n-   | ^^^ `pub` not needed here\n+   | ^^^ `pub` not permitted here because it's implied\n    |\n    = note: place qualifiers on individual impl items instead\n \n error[E0449]: unnecessary visibility qualifier\n   --> $DIR/E0449.rs:19:1\n    |\n LL | pub impl Foo for Bar { //~ ERROR E0449\n-   | ^^^ `pub` not needed here\n+   | ^^^ `pub` not permitted here because it's implied\n \n error[E0449]: unnecessary visibility qualifier\n   --> $DIR/E0449.rs:20:5\n    |\n LL |     pub fn foo() {} //~ ERROR E0449\n-   |     ^^^ `pub` not needed here\n+   |     ^^^ `pub` not permitted here because it's implied\n \n error: aborting due to 3 previous errors\n "}, {"sha": "866ecd9e1d951986cee50c427ef8bdc542e379f9", "filename": "src/test/ui/issue-49040.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fissue-49040.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fissue-49040.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49040.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_variables)]; //~ ERROR expected item, found `;`\n+fn main() {}"}, {"sha": "b6f624dac7db62b9113376537af7abbcad201fe1", "filename": "src/test/ui/issue-49040.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fissue-49040.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fissue-49040.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49040.stderr?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,8 @@\n+error: expected item, found `;`\n+  --> $DIR/issue-49040.rs:11:28\n+   |\n+LL | #![allow(unused_variables)]; //~ ERROR expected item, found `;`\n+   |                            ^ help: consider removing this semicolon\n+\n+error: aborting due to previous error\n+"}, {"sha": "0f19c48337b1e351554c184ebbe7f0a6ba3c0494", "filename": "src/test/ui/suggest-remove-refs-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = vec![0, 1, 2, 3];\n+\n+    for (i, n) in &v.iter().enumerate() {\n+        //~^ ERROR the trait bound\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "c47b4d283d7cda5195b9edc6087ca8931276e4cc", "filename": "src/test/ui/suggest-remove-refs-1.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-1.stderr?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>: std::iter::Iterator` is not satisfied\n+  --> $DIR/suggest-remove-refs-1.rs:14:19\n+   |\n+LL |     for (i, n) in &v.iter().enumerate() {\n+   |                   -^^^^^^^^^^^^^^^^^^^^\n+   |                   |\n+   |                   `&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator; maybe try calling `.iter()` or a similar method\n+   |                   help: consider removing 1 leading `&`-references\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: required by `std::iter::IntoIterator::into_iter`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c427f697ae1efe297f6b0aa8fba5f7f9a74d4887", "filename": "src/test/ui/suggest-remove-refs-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = vec![0, 1, 2, 3];\n+\n+    for (i, n) in & & & & &v.iter().enumerate() {\n+        //~^ ERROR the trait bound\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "fdd654ea3923f9019a2ecc204be1e0f610ab0d64", "filename": "src/test/ui/suggest-remove-refs-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-2.stderr?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>: std::iter::Iterator` is not satisfied\n+  --> $DIR/suggest-remove-refs-2.rs:14:19\n+   |\n+LL |     for (i, n) in & & & & &v.iter().enumerate() {\n+   |                   ---------^^^^^^^^^^^^^^^^^^^^\n+   |                   |\n+   |                   `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator; maybe try calling `.iter()` or a similar method\n+   |                   help: consider removing 5 leading `&`-references\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: required by `std::iter::IntoIterator::into_iter`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f54ae30caebca921c40229dec68cca855fa352e4", "filename": "src/test/ui/suggest-remove-refs-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let v = vec![0, 1, 2, 3];\n+\n+    for (i, n) in & & &\n+        & &v\n+        .iter()\n+        .enumerate() {\n+        //~^^^^ ERROR the trait bound\n+        println!(\"{}\", i);\n+    }\n+}"}, {"sha": "b0920a0fa523ee2b1850db901d036b29689c8955", "filename": "src/test/ui/suggest-remove-refs-3.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggest-remove-refs-3.stderr?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,19 @@\n+error[E0277]: the trait bound `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>: std::iter::Iterator` is not satisfied\n+  --> $DIR/suggest-remove-refs-3.rs:14:19\n+   |\n+LL |        for (i, n) in & & &\n+   |   ___________________^\n+   |  |___________________|\n+   | ||\n+LL | ||         & &v\n+   | ||___________- help: consider removing 5 leading `&`-references\n+LL | |          .iter()\n+LL | |          .enumerate() {\n+   | |_____________________^ `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>` is not an iterator; maybe try calling `.iter()` or a similar method\n+   |\n+   = help: the trait `std::iter::Iterator` is not implemented for `&&&&&std::iter::Enumerate<std::slice::Iter<'_, {integer}>>`\n+   = note: required by `std::iter::IntoIterator::into_iter`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "ddad4e79cfdaa3e7ee6bdd485905ebd7b0feee41", "filename": "src/test/ui/suggestions/const-type-mismatch.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggestions%2Fconst-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggestions%2Fconst-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-type-mismatch.rs?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// `const`s shouldn't suggest `.into()`\n+\n+const TEN: u8 = 10;\n+const TWELVE: u16 = TEN + 2;\n+//~^ ERROR mismatched types [E0308]\n+\n+fn main() {\n+    const TEN: u8 = 10;\n+    const ALSO_TEN: u16 = TEN;\n+    //~^ ERROR mismatched types [E0308]\n+}"}, {"sha": "965995f82c53a58b9ce434cfa99022723810deec", "filename": "src/test/ui/suggestions/const-type-mismatch.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggestions%2Fconst-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75af15ee6ca0c12b699a17984b033363cd25e9c3/src%2Ftest%2Fui%2Fsuggestions%2Fconst-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-type-mismatch.stderr?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -0,0 +1,15 @@\n+error[E0308]: mismatched types\n+  --> $DIR/const-type-mismatch.rs:14:21\n+   |\n+LL | const TWELVE: u16 = TEN + 2;\n+   |                     ^^^^^^^ expected u16, found u8\n+\n+error[E0308]: mismatched types\n+  --> $DIR/const-type-mismatch.rs:19:27\n+   |\n+LL |     const ALSO_TEN: u16 = TEN;\n+   |                           ^^^ expected u16, found u8\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "87180d9065e7c8070c0ba46eb48ddf8779ef89ac", "filename": "src/tools/rustfmt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt?ref=75af15ee6ca0c12b699a17984b033363cd25e9c3", "patch": "@@ -1 +1 @@\n-Subproject commit 346238f49740d6c98102a6a59811b1625c73a9d7\n+Subproject commit 87180d9065e7c8070c0ba46eb48ddf8779ef89ac"}]}