{"sha": "4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNzVmMWNlMmZhNTdjYTQ2NmU5NGFhNTlkZTliOTM4M2YzYzA1YTQ=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-02-06T17:42:57Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-02-14T07:21:08Z"}, "message": "Add std::process\n\nPer [RFC 579](https://github.com/rust-lang/rfcs/pull/579), this commit\nadds a new `std::process` module. This module is largely based on the\nexisting `std::old_io::process` module, but refactors the API to use\n`OsStr` and other new standards set out by IO reform.\n\nThe existing module is not yet deprecated, to allow for the new API to\nget a bit of testing before a mass migration to it.", "tree": {"sha": "f3eef73ff8e35621235406397244f6ad4e287782", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3eef73ff8e35621235406397244f6ad4e287782"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "html_url": "https://github.com/rust-lang/rust/commit/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39b463f15328f448c13fa990f9fc8897e0af55c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/39b463f15328f448c13fa990f9fc8897e0af55c2", "html_url": "https://github.com/rust-lang/rust/commit/39b463f15328f448c13fa990f9fc8897e0af55c2"}], "stats": {"total": 2087, "additions": 2051, "deletions": 36}, "files": [{"sha": "e6ca1bfdb81685e863e60095566d8af34d54ba7a", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -258,6 +258,7 @@ pub mod os;\n pub mod env;\n pub mod path;\n pub mod old_path;\n+pub mod process;\n pub mod rand;\n pub mod time;\n "}, {"sha": "271a4cdb629b352e2e894e540c50dc45fe68fc8e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -942,6 +942,11 @@ impl PathBuf {\n \n         true\n     }\n+\n+    /// Consume the `PathBuf`, yielding its internal `OsString` storage\n+    pub fn into_os_string(self) -> OsString {\n+        self.inner\n+    }\n }\n \n impl<'a, P: ?Sized + 'a> iter::FromIterator<&'a P> for PathBuf where P: AsPath {"}, {"sha": "d2b98ec89390b1b7798734e3ef7870f3251f8b54", "filename": "src/libstd/process.rs", "status": "added", "additions": 834, "deletions": 0, "changes": 834, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -0,0 +1,834 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Working with processes.\n+\n+#![unstable(feature = \"process\", reason = \"recently added via RFC 579\")]\n+#![allow(non_upper_case_globals)]\n+\n+use prelude::v1::*;\n+use io::prelude::*;\n+\n+use ffi::AsOsStr;\n+use fmt;\n+use io::{self, Error, ErrorKind};\n+use path::AsPath;\n+use libc;\n+use sync::mpsc::{channel, Receiver};\n+use sys::pipe2::{self, AnonPipe};\n+use sys::process2::Process as ProcessImp;\n+use sys::process2::Command as CommandImp;\n+use sys::process2::ExitStatus as ExitStatusImp;\n+use sys_common::{AsInner, AsInnerMut};\n+use thread::Thread;\n+\n+/// Representation of a running or exited child process.\n+///\n+/// This structure is used to represent and manage child processes. A child\n+/// process is created via the `Command` struct, which configures the spawning\n+/// process and can itself be constructed using a builder-style interface.\n+///\n+/// # Example\n+///\n+/// ```should_fail\n+/// # #![feature(process)]\n+///\n+/// use std::process::Command;\n+///\n+/// let output = Command::new(\"/bin/cat\").arg(\"file.txt\").output().unwrap_or_else(|e| {\n+///     panic!(\"failed to execute child: {}\", e)\n+/// });\n+/// let contents = output.stdout;\n+/// assert!(output.status.success());\n+/// ```\n+pub struct Child {\n+    handle: ProcessImp,\n+\n+    /// None until wait() or wait_with_output() is called.\n+    status: Option<ExitStatusImp>,\n+\n+    /// The handle for writing to the child's stdin, if it has been captured\n+    pub stdin: Option<ChildStdin>,\n+\n+    /// The handle for reading from the child's stdout, if it has been captured\n+    pub stdout: Option<ChildStdout>,\n+\n+    /// The handle for reading from the child's stderr, if it has been captured\n+    pub stderr: Option<ChildStderr>,\n+}\n+\n+/// A handle to a child procesess's stdin\n+pub struct ChildStdin {\n+    inner: AnonPipe\n+}\n+\n+impl Write for ChildStdin {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.inner.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+/// A handle to a child procesess's stdout\n+pub struct ChildStdout {\n+    inner: AnonPipe\n+}\n+\n+impl Read for ChildStdout {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+}\n+\n+/// A handle to a child procesess's stderr\n+pub struct ChildStderr {\n+    inner: AnonPipe\n+}\n+\n+impl Read for ChildStderr {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.inner.read(buf)\n+    }\n+}\n+\n+/// The `Command` type acts as a process builder, providing fine-grained control\n+/// over how a new process should be spawned. A default configuration can be\n+/// generated using `Command::new(program)`, where `program` gives a path to the\n+/// program to be executed. Additional builder methods allow the configuration\n+/// to be changed (for example, by adding arguments) prior to spawning:\n+///\n+/// ```\n+/// # #![feature(process)]\n+///\n+/// use std::process::Command;\n+///\n+/// let output = Command::new(\"sh\").arg(\"-c\").arg(\"echo hello\").output().unwrap_or_else(|e| {\n+///   panic!(\"failed to execute process: {}\", e)\n+/// });\n+/// let hello = output.stdout;\n+/// ```\n+pub struct Command {\n+    inner: CommandImp,\n+\n+    // Details explained in the builder methods\n+    stdin: Option<StdioImp>,\n+    stdout: Option<StdioImp>,\n+    stderr: Option<StdioImp>,\n+}\n+\n+impl Command {\n+    /// Constructs a new `Command` for launching the program at\n+    /// path `program`, with the following default configuration:\n+    ///\n+    /// * No arguments to the program\n+    /// * Inherit the current process's environment\n+    /// * Inherit the current process's working directory\n+    /// * Inherit stdin/stdout/stderr for `run` or `status`, but create pipes for `output`\n+    ///\n+    /// Builder methods are provided to change these defaults and\n+    /// otherwise configure the process.\n+    pub fn new<S: AsOsStr + ?Sized>(program: &S) -> Command {\n+        Command {\n+            inner: CommandImp::new(program.as_os_str()),\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n+        }\n+    }\n+\n+    /// Add an argument to pass to the program.\n+    pub fn arg<S: AsOsStr + ?Sized>(&mut self, arg: &S) -> &mut Command {\n+        self.inner.arg(arg.as_os_str());\n+        self\n+    }\n+\n+    /// Add multiple arguments to pass to the program.\n+    pub fn args<S: AsOsStr>(&mut self, args: &[S]) -> &mut Command {\n+        self.inner.args(args.iter().map(AsOsStr::as_os_str));\n+        self\n+    }\n+\n+    /// Inserts or updates an environment variable mapping.\n+    ///\n+    /// Note that environment variable names are case-insensitive (but case-preserving) on Windows,\n+    /// and case-sensitive on all other platforms.\n+    pub fn env<S: ?Sized, T: ?Sized>(&mut self, key: &S, val: &T) -> &mut Command where\n+        S: AsOsStr, T: AsOsStr\n+    {\n+        self.inner.env(key.as_os_str(), val.as_os_str());\n+        self\n+    }\n+\n+    /// Removes an environment variable mapping.\n+    pub fn env_remove<S: ?Sized + AsOsStr>(&mut self, key: &S) -> &mut Command {\n+        self.inner.env_remove(key.as_os_str());\n+        self\n+    }\n+\n+    /// Clears the entire environment map for the child process.\n+    pub fn env_clear(&mut self) -> &mut Command {\n+        self.inner.env_clear();\n+        self\n+    }\n+\n+    /// Set the working directory for the child process.\n+    pub fn current_dir<P: AsPath + ?Sized>(&mut self, dir: &P) -> &mut Command {\n+        self.inner.cwd(dir.as_path().as_os_str());\n+        self\n+    }\n+\n+    /// Configuration for the child process's stdin handle (file descriptor 0).\n+    /// Defaults to `CreatePipe(true, false)` so the input can be written to.\n+    pub fn stdin(&mut self, cfg: Stdio) -> &mut Command {\n+        self.stdin = Some(cfg.0);\n+        self\n+    }\n+\n+    /// Configuration for the child process's stdout handle (file descriptor 1).\n+    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n+    pub fn stdout(&mut self, cfg: Stdio) -> &mut Command {\n+        self.stdout = Some(cfg.0);\n+        self\n+    }\n+\n+    /// Configuration for the child process's stderr handle (file descriptor 2).\n+    /// Defaults to `CreatePipe(false, true)` so the output can be collected.\n+    pub fn stderr(&mut self, cfg: Stdio) -> &mut Command {\n+        self.stderr = Some(cfg.0);\n+        self\n+    }\n+\n+    fn spawn_inner(&self, default_io: StdioImp) -> io::Result<Child> {\n+        let (their_stdin, our_stdin) = try!(\n+            setup_io(self.stdin.as_ref().unwrap_or(&default_io), 0, true)\n+        );\n+        let (their_stdout, our_stdout) = try!(\n+            setup_io(self.stdout.as_ref().unwrap_or(&default_io), 1, false)\n+        );\n+        let (their_stderr, our_stderr) = try!(\n+            setup_io(self.stderr.as_ref().unwrap_or(&default_io), 2, false)\n+        );\n+\n+        match ProcessImp::spawn(&self.inner, their_stdin, their_stdout, their_stderr) {\n+            Err(e) => Err(e),\n+            Ok(handle) => Ok(Child {\n+                handle: handle,\n+                status: None,\n+                stdin: our_stdin.map(|fd| ChildStdin { inner: fd }),\n+                stdout: our_stdout.map(|fd| ChildStdout { inner: fd }),\n+                stderr: our_stderr.map(|fd| ChildStderr { inner: fd }),\n+            })\n+        }\n+    }\n+\n+    /// Executes the command as a child process, returning a handle to it.\n+    ///\n+    /// By default, stdin, stdout and stderr are inherited by the parent.\n+    pub fn spawn(&mut self) -> io::Result<Child> {\n+        self.spawn_inner(StdioImp::Inherit)\n+    }\n+\n+    /// Executes the command as a child process, waiting for it to finish and\n+    /// collecting all of its output.\n+    ///\n+    /// By default, stdin, stdout and stderr are captured (and used to\n+    /// provide the resulting output).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![feature(process)]\n+    /// use std::process::Command;\n+    ///\n+    /// let output = Command::new(\"cat\").arg(\"foot.txt\").output().unwrap_or_else(|e| {\n+    ///     panic!(\"failed to execute process: {}\", e)\n+    /// });\n+    ///\n+    /// println!(\"status: {}\", output.status);\n+    /// println!(\"stdout: {}\", String::from_utf8_lossy(output.stdout.as_slice()));\n+    /// println!(\"stderr: {}\", String::from_utf8_lossy(output.stderr.as_slice()));\n+    /// ```\n+    pub fn output(&mut self) -> io::Result<Output> {\n+        self.spawn_inner(StdioImp::Capture).and_then(|p| p.wait_with_output())\n+    }\n+\n+    /// Executes a command as a child process, waiting for it to finish and\n+    /// collecting its exit status.\n+    ///\n+    /// By default, stdin, stdout and stderr are inherited by the parent.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// # #![feature(process)]\n+    /// use std::process::Command;\n+    ///\n+    /// let status = Command::new(\"ls\").status().unwrap_or_else(|e| {\n+    ///     panic!(\"failed to execute process: {}\", e)\n+    /// });\n+    ///\n+    /// println!(\"process exited with: {}\", status);\n+    /// ```\n+    pub fn status(&mut self) -> io::Result<ExitStatus> {\n+        self.spawn().and_then(|mut p| p.wait())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Command {\n+    /// Format the program and arguments of a Command for display. Any\n+    /// non-utf8 data is lossily converted using the utf8 replacement\n+    /// character.\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"{:?}\", self.inner.program));\n+        for arg in &self.inner.args {\n+            try!(write!(f, \" {:?}\", arg));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl AsInner<CommandImp> for Command {\n+    fn as_inner(&self) -> &CommandImp { &self.inner }\n+}\n+\n+impl AsInnerMut<CommandImp> for Command {\n+    fn as_inner_mut(&mut self) -> &mut CommandImp { &mut self.inner }\n+}\n+\n+fn setup_io(io: &StdioImp, fd: libc::c_int, readable: bool)\n+            -> io::Result<(Option<AnonPipe>, Option<AnonPipe>)>\n+{\n+    use self::StdioImp::*;\n+    Ok(match *io {\n+        Null => {\n+            (None, None)\n+        }\n+        Inherit => {\n+            (Some(AnonPipe::from_fd(fd)), None)\n+        }\n+        Capture => {\n+            let (reader, writer) = try!(unsafe { pipe2::anon_pipe() });\n+            if readable {\n+                (Some(reader), Some(writer))\n+            } else {\n+                (Some(writer), Some(reader))\n+            }\n+        }\n+    })\n+}\n+\n+/// The output of a finished process.\n+#[derive(PartialEq, Eq, Clone)]\n+pub struct Output {\n+    /// The status (exit code) of the process.\n+    pub status: ExitStatus,\n+    /// The data that the process wrote to stdout.\n+    pub stdout: Vec<u8>,\n+    /// The data that the process wrote to stderr.\n+    pub stderr: Vec<u8>,\n+}\n+\n+/// Describes what to do with a standard io stream for a child process.\n+pub struct Stdio(StdioImp);\n+\n+// The internal enum for stdio setup; see below for descriptions.\n+#[derive(Clone)]\n+enum StdioImp {\n+    Capture,\n+    Inherit,\n+    Null,\n+}\n+\n+impl Stdio {\n+    /// A new pipe should be arranged to connect the parent and child processes.\n+    pub fn capture() -> Stdio { Stdio(StdioImp::Capture) }\n+\n+    /// The child inherits from the corresponding parent descriptor.\n+    pub fn inherit() -> Stdio { Stdio(StdioImp::Capture) }\n+\n+    /// This stream will be ignored. This is the equivalent of attaching the\n+    /// stream to `/dev/null`\n+    pub fn null() -> Stdio { Stdio(StdioImp::Capture) }\n+}\n+\n+/// Describes the result of a process after it has terminated.\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(ExitStatusImp);\n+\n+impl ExitStatus {\n+    /// Was termination successful? Signal termination not considered a success,\n+    /// and success is defined as a zero exit status.\n+    pub fn success(&self) -> bool {\n+        self.0.success()\n+    }\n+\n+    /// Return the exit code of the process, if any.\n+    ///\n+    /// On Unix, this will return `None` if the process was terminated\n+    /// by a signal; `std::os::unix` provides an extension trait for\n+    /// extracting the signal and other details from the `ExitStatus`.\n+    pub fn code(&self) -> Option<i32> {\n+        self.0.code()\n+    }\n+}\n+\n+impl AsInner<ExitStatusImp> for ExitStatus {\n+    fn as_inner(&self) -> &ExitStatusImp { &self.0 }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl Child {\n+    /// Forces the child to exit. This is equivalent to sending a\n+    /// SIGKILL on unix platforms.\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        #[cfg(unix)] fn collect_status(p: &mut Child) {\n+            // On Linux (and possibly other unices), a process that has exited will\n+            // continue to accept signals because it is \"defunct\". The delivery of\n+            // signals will only fail once the child has been reaped. For this\n+            // reason, if the process hasn't exited yet, then we attempt to collect\n+            // their status with WNOHANG.\n+            if p.status.is_none() {\n+                match p.handle.try_wait() {\n+                    Some(status) => { p.status = Some(status); }\n+                    None => {}\n+                }\n+            }\n+        }\n+        #[cfg(windows)] fn collect_status(_p: &mut Child) {}\n+\n+        collect_status(self);\n+\n+        // if the process has finished, and therefore had waitpid called,\n+        // and we kill it, then on unix we might ending up killing a\n+        // newer process that happens to have the same (re-used) id\n+        if self.status.is_some() {\n+            return Err(Error::new(\n+                ErrorKind::InvalidInput,\n+                \"invalid argument: can't kill an exited process\",\n+                None\n+            ))\n+        }\n+\n+        unsafe { self.handle.kill() }\n+    }\n+\n+    /// Wait for the child to exit completely, returning the status that it\n+    /// exited with. This function will continue to have the same return value\n+    /// after it has been called at least once.\n+    ///\n+    /// The stdin handle to the child process, if any, will be closed\n+    /// before waiting. This helps avoid deadlock: it ensures that the\n+    /// child does not block waiting for input from the parent, while\n+    /// the parent waits for the child to exit.\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        drop(self.stdin.take());\n+        match self.status {\n+            Some(code) => Ok(ExitStatus(code)),\n+            None => {\n+                let status = try!(self.handle.wait());\n+                self.status = Some(status);\n+                Ok(ExitStatus(status))\n+            }\n+        }\n+    }\n+\n+    /// Simultaneously wait for the child to exit and collect all remaining\n+    /// output on the stdout/stderr handles, returning a `Output`\n+    /// instance.\n+    ///\n+    /// The stdin handle to the child process, if any, will be closed\n+    /// before waiting. This helps avoid deadlock: it ensures that the\n+    /// child does not block waiting for input from the parent, while\n+    /// the parent waits for the child to exit.\n+    pub fn wait_with_output(mut self) -> io::Result<Output> {\n+        drop(self.stdin.take());\n+        fn read<T: Read + Send>(stream: Option<T>) -> Receiver<io::Result<Vec<u8>>> {\n+            let (tx, rx) = channel();\n+            match stream {\n+                Some(stream) => {\n+                    Thread::spawn(move || {\n+                        let mut stream = stream;\n+                        let mut ret = Vec::new();\n+                        let res = stream.read_to_end(&mut ret);\n+                        tx.send(res.map(|_| ret)).unwrap();\n+                    });\n+                }\n+                None => tx.send(Ok(Vec::new())).unwrap()\n+            }\n+            rx\n+        }\n+        let stdout = read(self.stdout.take());\n+        let stderr = read(self.stderr.take());\n+        let status = try!(self.wait());\n+\n+        Ok(Output {\n+            status: status,\n+            stdout: stdout.recv().unwrap().unwrap_or(Vec::new()),\n+            stderr:  stderr.recv().unwrap().unwrap_or(Vec::new()),\n+        })\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use io::ErrorKind;\n+    use io::prelude::*;\n+    use prelude::v1::{Ok, Err, range, drop, Some, None, Vec};\n+    use prelude::v1::{String, Clone};\n+    use prelude::v1::{SliceExt, Str, StrExt, AsSlice, ToString, GenericPath};\n+    use path::Path;\n+    use old_path;\n+    use old_io::fs::PathExtensions;\n+    use rt::running_on_valgrind;\n+    use str;\n+    use super::{Child, Command, Output, ExitStatus, Stdio};\n+    use sync::mpsc::channel;\n+    use thread::Thread;\n+    use time::Duration;\n+\n+    // FIXME(#10380) these tests should not all be ignored on android.\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn smoke() {\n+        let p = Command::new(\"true\").spawn();\n+        assert!(p.is_ok());\n+        let mut p = p.unwrap();\n+        assert!(p.wait().unwrap().success());\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn smoke_failure() {\n+        match Command::new(\"if-this-is-a-binary-then-the-world-has-ended\").spawn() {\n+            Ok(..) => panic!(),\n+            Err(..) => {}\n+        }\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn exit_reported_right() {\n+        let p = Command::new(\"false\").spawn();\n+        assert!(p.is_ok());\n+        let mut p = p.unwrap();\n+        assert!(p.wait().unwrap().code() == Some(1));\n+        drop(p.wait().clone());\n+    }\n+\n+    #[cfg(all(unix, not(target_os=\"android\")))]\n+    #[test]\n+    fn signal_reported_right() {\n+        use os::unix::ExitStatusExt;\n+\n+        let p = Command::new(\"/bin/sh\").arg(\"-c\").arg(\"kill -1 $$\").spawn();\n+        assert!(p.is_ok());\n+        let mut p = p.unwrap();\n+        match p.wait().unwrap().signal() {\n+            Some(1) => {},\n+            result => panic!(\"not terminated by signal 1 (instead, {:?})\", result),\n+        }\n+    }\n+\n+    pub fn run_output(mut cmd: Command) -> String {\n+        let p = cmd.spawn();\n+        assert!(p.is_ok());\n+        let mut p = p.unwrap();\n+        assert!(p.stdout.is_some());\n+        let mut ret = String::new();\n+        p.stdout.as_mut().unwrap().read_to_string(&mut ret).unwrap();\n+        assert!(p.wait().unwrap().success());\n+        return ret;\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn stdout_works() {\n+        let mut cmd = Command::new(\"echo\");\n+        cmd.arg(\"foobar\").stdout(Stdio::capture());\n+        assert_eq!(run_output(cmd), \"foobar\\n\");\n+    }\n+\n+    #[cfg(all(unix, not(target_os=\"android\")))]\n+    #[test]\n+    fn set_current_dir_works() {\n+        let mut cmd = Command::new(\"/bin/sh\");\n+        cmd.arg(\"-c\").arg(\"pwd\")\n+           .current_dir(\"/\")\n+           .stdout(Stdio::capture());\n+        assert_eq!(run_output(cmd), \"/\\n\");\n+    }\n+\n+    #[cfg(all(unix, not(target_os=\"android\")))]\n+    #[test]\n+    fn stdin_works() {\n+        let mut p = Command::new(\"/bin/sh\")\n+                            .arg(\"-c\").arg(\"read line; echo $line\")\n+                            .stdin(Stdio::capture())\n+                            .stdout(Stdio::capture())\n+                            .spawn().unwrap();\n+        p.stdin.as_mut().unwrap().write(\"foobar\".as_bytes()).unwrap();\n+        drop(p.stdin.take());\n+        let mut out = String::new();\n+        p.stdout.as_mut().unwrap().read_to_string(&mut out).unwrap();\n+        assert!(p.wait().unwrap().success());\n+        assert_eq!(out, \"foobar\\n\");\n+    }\n+\n+\n+    #[cfg(all(unix, not(target_os=\"android\")))]\n+    #[test]\n+    fn uid_works() {\n+        use os::unix::*;\n+        use libc;\n+        let mut p = Command::new(\"/bin/sh\")\n+                            .arg(\"-c\").arg(\"true\")\n+                            .uid(unsafe { libc::getuid() })\n+                            .gid(unsafe { libc::getgid() })\n+                            .spawn().unwrap();\n+        assert!(p.wait().unwrap().success());\n+    }\n+\n+    #[cfg(all(unix, not(target_os=\"android\")))]\n+    #[test]\n+    fn uid_to_root_fails() {\n+        use os::unix::*;\n+        use libc;\n+\n+        // if we're already root, this isn't a valid test. Most of the bots run\n+        // as non-root though (android is an exception).\n+        if unsafe { libc::getuid() == 0 } { return }\n+        assert!(Command::new(\"/bin/ls\").uid(0).gid(0).spawn().is_err());\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn test_process_status() {\n+        let mut status = Command::new(\"false\").status().unwrap();\n+        assert!(status.code() == Some(1));\n+\n+        status = Command::new(\"true\").status().unwrap();\n+        assert!(status.success());\n+    }\n+\n+    #[test]\n+    fn test_process_output_fail_to_start() {\n+        match Command::new(\"/no-binary-by-this-name-should-exist\").output() {\n+            Err(e) => assert_eq!(e.kind(), ErrorKind::FileNotFound),\n+            Ok(..) => panic!()\n+        }\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn test_process_output_output() {\n+        let Output {status, stdout, stderr}\n+             = Command::new(\"echo\").arg(\"hello\").output().unwrap();\n+        let output_str = str::from_utf8(stdout.as_slice()).unwrap();\n+\n+        assert!(status.success());\n+        assert_eq!(output_str.trim().to_string(), \"hello\");\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(stderr, Vec::new());\n+        }\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn test_process_output_error() {\n+        let Output {status, stdout, stderr}\n+             = Command::new(\"mkdir\").arg(\".\").output().unwrap();\n+\n+        assert!(status.code() == Some(1));\n+        assert_eq!(stdout, Vec::new());\n+        assert!(!stderr.is_empty());\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn test_finish_once() {\n+        let mut prog = Command::new(\"false\").spawn().unwrap();\n+        assert!(prog.wait().unwrap().code() == Some(1));\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn test_finish_twice() {\n+        let mut prog = Command::new(\"false\").spawn().unwrap();\n+        assert!(prog.wait().unwrap().code() == Some(1));\n+        assert!(prog.wait().unwrap().code() == Some(1));\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn test_wait_with_output_once() {\n+        let prog = Command::new(\"echo\").arg(\"hello\").stdout(Stdio::capture())\n+            .spawn().unwrap();\n+        let Output {status, stdout, stderr} = prog.wait_with_output().unwrap();\n+        let output_str = str::from_utf8(stdout.as_slice()).unwrap();\n+\n+        assert!(status.success());\n+        assert_eq!(output_str.trim().to_string(), \"hello\");\n+        // FIXME #7224\n+        if !running_on_valgrind() {\n+            assert_eq!(stderr, Vec::new());\n+        }\n+    }\n+\n+    #[cfg(all(unix, not(target_os=\"android\")))]\n+    pub fn pwd_cmd() -> Command {\n+        Command::new(\"pwd\")\n+    }\n+    #[cfg(target_os=\"android\")]\n+    pub fn pwd_cmd() -> Command {\n+        let mut cmd = Command::new(\"/system/bin/sh\");\n+        cmd.arg(\"-c\").arg(\"pwd\");\n+        cmd\n+    }\n+\n+    #[cfg(windows)]\n+    pub fn pwd_cmd() -> Command {\n+        let mut cmd = Command::new(\"cmd\");\n+        cmd.arg(\"/c\").arg(\"cd\");\n+        cmd\n+    }\n+\n+    #[test]\n+    fn test_keep_current_working_dir() {\n+        use os;\n+        let prog = pwd_cmd().spawn().unwrap();\n+\n+        let output = String::from_utf8(prog.wait_with_output().unwrap().stdout).unwrap();\n+        let parent_dir = os::getcwd().unwrap();\n+        let child_dir = old_path::Path::new(output.trim());\n+\n+        let parent_stat = parent_dir.stat().unwrap();\n+        let child_stat = child_dir.stat().unwrap();\n+\n+        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n+        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n+    }\n+\n+    #[test]\n+    fn test_change_working_directory() {\n+        use os;\n+        // test changing to the parent of os::getcwd() because we know\n+        // the path exists (and os::getcwd() is not expected to be root)\n+        let parent_dir = os::getcwd().unwrap().dir_path();\n+        let result = pwd_cmd().current_dir(&parent_dir).output().unwrap();\n+\n+        let output = String::from_utf8(result.stdout).unwrap();\n+        let child_dir = old_path::Path::new(output.trim());\n+\n+        let parent_stat = parent_dir.stat().unwrap();\n+        let child_stat = child_dir.stat().unwrap();\n+\n+        assert_eq!(parent_stat.unstable.device, child_stat.unstable.device);\n+        assert_eq!(parent_stat.unstable.inode, child_stat.unstable.inode);\n+    }\n+\n+    #[cfg(all(unix, not(target_os=\"android\")))]\n+    pub fn env_cmd() -> Command {\n+        Command::new(\"env\")\n+    }\n+    #[cfg(target_os=\"android\")]\n+    pub fn env_cmd() -> Command {\n+        let mut cmd = Command::new(\"/system/bin/sh\");\n+        cmd.arg(\"-c\").arg(\"set\");\n+        cmd\n+    }\n+\n+    #[cfg(windows)]\n+    pub fn env_cmd() -> Command {\n+        let mut cmd = Command::new(\"cmd\");\n+        cmd.arg(\"/c\").arg(\"set\");\n+        cmd\n+    }\n+\n+    #[cfg(not(target_os=\"android\"))]\n+    #[test]\n+    fn test_inherit_env() {\n+        use os;\n+        if running_on_valgrind() { return; }\n+\n+        let result = env_cmd().output().unwrap();\n+        let output = String::from_utf8(result.stdout).unwrap();\n+\n+        let r = os::env();\n+        for &(ref k, ref v) in &r {\n+            // don't check windows magical empty-named variables\n+            assert!(k.is_empty() ||\n+                    output.contains(format!(\"{}={}\", *k, *v).as_slice()),\n+                    \"output doesn't contain `{}={}`\\n{}\",\n+                    k, v, output);\n+        }\n+    }\n+    #[cfg(target_os=\"android\")]\n+    #[test]\n+    fn test_inherit_env() {\n+        use os;\n+        if running_on_valgrind() { return; }\n+\n+        let mut result = env_cmd().output().unwrap();\n+        let output = String::from_utf8(result.stdout).unwrap();\n+\n+        let r = os::env();\n+        for &(ref k, ref v) in &r {\n+            // don't check android RANDOM variables\n+            if *k != \"RANDOM\".to_string() {\n+                assert!(output.contains(format!(\"{}={}\",\n+                                                *k,\n+                                                *v).as_slice()) ||\n+                        output.contains(format!(\"{}=\\'{}\\'\",\n+                                                *k,\n+                                                *v).as_slice()));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_override_env() {\n+        use env;\n+\n+        // In some build environments (such as chrooted Nix builds), `env` can\n+        // only be found in the explicitly-provided PATH env variable, not in\n+        // default places such as /bin or /usr/bin. So we need to pass through\n+        // PATH to our sub-process.\n+        let mut cmd = env_cmd();\n+        cmd.env_clear().env(\"RUN_TEST_NEW_ENV\", \"123\");\n+        if let Some(p) = env::var_os(\"PATH\") {\n+            cmd.env(\"PATH\", &p);\n+        }\n+        let result = cmd.output().unwrap();\n+        let output = String::from_utf8_lossy(result.stdout.as_slice()).to_string();\n+\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n+                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+    }\n+\n+    #[test]\n+    fn test_add_to_env() {\n+        let result = env_cmd().env(\"RUN_TEST_NEW_ENV\", \"123\").output().unwrap();\n+        let output = String::from_utf8_lossy(result.stdout.as_slice()).to_string();\n+\n+        assert!(output.contains(\"RUN_TEST_NEW_ENV=123\"),\n+                \"didn't find RUN_TEST_NEW_ENV inside of:\\n\\n{}\", output);\n+    }\n+}"}, {"sha": "6047f94b3b4599428d6fbff2c1a743c358aa3200", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -27,6 +27,7 @@ use core::char::{encode_utf8_raw, encode_utf16_raw};\n use core::str::{char_range_at_raw, next_code_point};\n use core::raw::Slice as RawSlice;\n \n+use ascii::*;\n use borrow::Cow;\n use cmp;\n use fmt;\n@@ -38,6 +39,7 @@ use ops;\n use slice;\n use str;\n use string::{String, CowString};\n+use sys_common::AsInner;\n use unicode::str::{Utf16Item, utf16_items};\n use vec::Vec;\n \n@@ -384,6 +386,10 @@ pub struct Wtf8 {\n     bytes: [u8]\n }\n \n+impl AsInner<[u8]> for Wtf8 {\n+    fn as_inner(&self) -> &[u8] { &self.bytes }\n+}\n+\n // FIXME: https://github.com/rust-lang/rust/issues/18805\n impl PartialEq for Wtf8 {\n     fn eq(&self, other: &Wtf8) -> bool { self.bytes.eq(&other.bytes) }\n@@ -811,6 +817,21 @@ impl<'a, S: Writer + Hasher> Hash<S> for Wtf8 {\n     }\n }\n \n+impl AsciiExt<Wtf8Buf> for Wtf8 {\n+    fn is_ascii(&self) -> bool {\n+        self.bytes.is_ascii()\n+    }\n+    fn to_ascii_uppercase(&self) -> Wtf8Buf {\n+        Wtf8Buf { bytes: self.bytes.to_ascii_uppercase() }\n+    }\n+    fn to_ascii_lowercase(&self) -> Wtf8Buf {\n+        Wtf8Buf { bytes: self.bytes.to_ascii_lowercase() }\n+    }\n+    fn eq_ignore_ascii_case(&self, other: &Wtf8) -> bool {\n+        self.bytes.eq_ignore_ascii_case(&other.bytes)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;"}, {"sha": "bbbe022fbaf619ce9c5cbef9dd978aa97888e2b0", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 73, "deletions": 10, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -31,14 +31,17 @@\n \n #![unstable(feature = \"std_misc\")]\n \n-use ffi::{OsStr, OsString};\n+use prelude::v1::*;\n+\n+use ffi::{CString, OsStr, OsString};\n use fs::{self, Permissions, OpenOptions};\n use net;\n-use libc;\n use mem;\n+use process;\n+use sys;\n use sys::os_str::Buf;\n use sys_common::{AsInner, AsInnerMut, IntoInner, FromInner};\n-use vec::Vec;\n+use libc::{self, gid_t, uid_t};\n \n use old_io;\n \n@@ -121,7 +124,11 @@ impl AsRawFd for net::UdpSocket {\n     fn as_raw_fd(&self) -> Fd { *self.as_inner().socket().as_inner() }\n }\n \n-// Unix-specific extensions to `OsString`.\n+////////////////////////////////////////////////////////////////////////////////\n+// OsString and OsStr\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Unix-specific extensions to `OsString`.\n pub trait OsStringExt {\n     /// Create an `OsString` from a byte vector.\n     fn from_vec(vec: Vec<u8>) -> Self;\n@@ -140,19 +147,28 @@ impl OsStringExt for OsString {\n     }\n }\n \n-// Unix-specific extensions to `OsStr`.\n+/// Unix-specific extensions to `OsStr`.\n pub trait OsStrExt {\n-    fn from_byte_slice(slice: &[u8]) -> &OsStr;\n-    fn as_byte_slice(&self) -> &[u8];\n+    fn from_bytes(slice: &[u8]) -> &OsStr;\n+\n+    /// Get the underlying byte view of the `OsStr` slice.\n+    fn as_bytes(&self) -> &[u8];\n+\n+    /// Convert the `OsStr` slice into a `CString`.\n+    fn to_cstring(&self) -> CString;\n }\n \n impl OsStrExt for OsStr {\n-    fn from_byte_slice(slice: &[u8]) -> &OsStr {\n+    fn from_bytes(slice: &[u8]) -> &OsStr {\n         unsafe { mem::transmute(slice) }\n     }\n-    fn as_byte_slice(&self) -> &[u8] {\n+    fn as_bytes(&self) -> &[u8] {\n         &self.as_inner().inner\n     }\n+\n+    fn to_cstring(&self) -> CString {\n+        CString::from_slice(self.as_bytes())\n+    }\n }\n \n // Unix-specific extensions to `Permissions`\n@@ -181,10 +197,57 @@ impl OpenOptionsExt for OpenOptions {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Process and Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Unix-specific extensions to the `std::process::Command` builder\n+pub trait CommandExt {\n+    /// Sets the child process's user id. This translates to a\n+    /// `setuid` call in the child process. Failure in the `setuid`\n+    /// call will cause the spawn to fail.\n+    fn uid(&mut self, id: uid_t) -> &mut process::Command;\n+\n+    /// Similar to `uid`, but sets the group id of the child process. This has\n+    /// the same semantics as the `uid` field.\n+    fn gid(&mut self, id: gid_t) -> &mut process::Command;\n+}\n+\n+impl CommandExt for process::Command {\n+    fn uid(&mut self, id: uid_t) -> &mut process::Command {\n+        self.as_inner_mut().uid = Some(id);\n+        self\n+    }\n+\n+    fn gid(&mut self, id: gid_t) -> &mut process::Command {\n+        self.as_inner_mut().gid = Some(id);\n+        self\n+    }\n+}\n+\n+/// Unix-specific extensions to `std::process::ExitStatus`\n+pub trait ExitStatusExt {\n+    /// If the process was terminated by a signal, returns that signal.\n+    fn signal(&self) -> Option<i32>;\n+}\n+\n+impl ExitStatusExt for process::ExitStatus {\n+    fn signal(&self) -> Option<i32> {\n+        match *self.as_inner() {\n+            sys::process2::ExitStatus::Signal(s) => Some(s),\n+            _ => None\n+        }\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Prelude\n+////////////////////////////////////////////////////////////////////////////////\n+\n /// A prelude for conveniently writing platform-specific code.\n ///\n /// Includes all extension traits, and some important type definitions.\n pub mod prelude {\n     #[doc(no_inline)]\n-    pub use super::{Fd, AsRawFd, OsStrExt, OsStringExt, PermissionsExt};\n+    pub use super::{Fd, AsRawFd, OsStrExt, OsStringExt, PermissionsExt, CommandExt, ExitStatusExt};\n }"}, {"sha": "e5904b074bcb980cc3fe502b2671de8daf52c4d3", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -139,7 +139,7 @@ impl Drop for ReadDir {\n \n impl DirEntry {\n     pub fn path(&self) -> PathBuf {\n-        self.root.join(<OsStr as OsStrExt>::from_byte_slice(self.name_bytes()))\n+        self.root.join(<OsStr as OsStrExt>::from_bytes(self.name_bytes()))\n     }\n \n     fn name_bytes(&self) -> &[u8] {\n@@ -269,7 +269,7 @@ impl File {\n }\n \n fn cstr(path: &Path) -> CString {\n-    CString::from_slice(path.as_os_str().as_byte_slice())\n+    CString::from_slice(path.as_os_str().as_bytes())\n }\n \n pub fn mkdir(p: &Path) -> io::Result<()> {"}, {"sha": "850189140d1eb494ff9717159d1602779b0d87dd", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -50,7 +50,9 @@ pub mod net;\n pub mod os;\n pub mod os_str;\n pub mod pipe;\n+pub mod pipe2;\n pub mod process;\n+pub mod process2;\n pub mod rwlock;\n pub mod stack_overflow;\n pub mod sync;"}, {"sha": "8a6ef17818a0956b57834360490c9445ea86d185", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -19,11 +19,13 @@ use fmt;\n use iter;\n use libc::{self, c_int, c_char, c_void};\n use mem;\n+use io;\n use old_io::{IoResult, IoError, fs};\n use ptr;\n use slice;\n use str;\n use sys::c;\n+use sys::fd;\n use sys::fs::FileDesc;\n use vec;\n \n@@ -118,7 +120,7 @@ pub struct SplitPaths<'a> {\n \n pub fn split_paths<'a>(unparsed: &'a OsStr) -> SplitPaths<'a> {\n     fn is_colon(b: &u8) -> bool { *b == b':' }\n-    let unparsed = unparsed.as_byte_slice();\n+    let unparsed = unparsed.as_bytes();\n     SplitPaths {\n         iter: unparsed.split(is_colon as fn(&u8) -> bool)\n                       .map(Path::new as fn(&'a [u8]) ->  Path)\n@@ -141,7 +143,7 @@ pub fn join_paths<I, T>(paths: I) -> Result<OsString, JoinPathsError>\n     let sep = b':';\n \n     for (i, path) in paths.enumerate() {\n-        let path = path.as_os_str().as_byte_slice();\n+        let path = path.as_os_str().as_bytes();\n         if i > 0 { joined.push(sep) }\n         if path.contains(&sep) {\n             return Err(JoinPathsError)\n@@ -391,7 +393,7 @@ pub fn env() -> Env {\n \n pub fn getenv(k: &OsStr) -> Option<OsString> {\n     unsafe {\n-        let s = CString::from_slice(k.as_byte_slice());\n+        let s = CString::from_slice(k.as_bytes());\n         let s = libc::getenv(s.as_ptr()) as *const _;\n         if s.is_null() {\n             None\n@@ -403,8 +405,8 @@ pub fn getenv(k: &OsStr) -> Option<OsString> {\n \n pub fn setenv(k: &OsStr, v: &OsStr) {\n     unsafe {\n-        let k = CString::from_slice(k.as_byte_slice());\n-        let v = CString::from_slice(v.as_byte_slice());\n+        let k = CString::from_slice(k.as_bytes());\n+        let v = CString::from_slice(v.as_bytes());\n         if libc::funcs::posix01::unistd::setenv(k.as_ptr(), v.as_ptr(), 1) != 0 {\n             panic!(\"failed setenv: {}\", IoError::last_error());\n         }\n@@ -413,7 +415,7 @@ pub fn setenv(k: &OsStr, v: &OsStr) {\n \n pub fn unsetenv(n: &OsStr) {\n     unsafe {\n-        let nbuf = CString::from_slice(n.as_byte_slice());\n+        let nbuf = CString::from_slice(n.as_bytes());\n         if libc::funcs::posix01::unistd::unsetenv(nbuf.as_ptr()) != 0 {\n             panic!(\"failed unsetenv: {}\", IoError::last_error());\n         }"}, {"sha": "7af2c0f0b2a8ea883d1d5286d256e9e848cc7e7f", "filename": "src/libstd/sys/unix/pipe2.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fpipe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fpipe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe2.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use sys::fd::FileDesc;\n+use io;\n+use libc;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Anonymous pipes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct AnonPipe(FileDesc);\n+\n+pub unsafe fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+    let mut fds = [0; 2];\n+    if libc::pipe(fds.as_mut_ptr()) == 0 {\n+        Ok((AnonPipe::from_fd(fds[0]),\n+            AnonPipe::from_fd(fds[1])))\n+    } else {\n+        Err(io::Error::last_os_error())\n+    }\n+}\n+\n+impl AnonPipe {\n+    pub fn from_fd(fd: libc::c_int) -> AnonPipe {\n+        AnonPipe(FileDesc::new(fd))\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    pub fn raw(&self) -> libc::c_int {\n+        self.0.raw()\n+    }\n+}"}, {"sha": "ab06109076e23f9c1ae730e746dbdcda7c34e0e6", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -32,6 +32,12 @@ pub use sys_common::ProcessConfig;\n \n helper_init! { static HELPER: Helper<Req> }\n \n+/// Unix-specific extensions to the Command builder\n+pub struct CommandExt {\n+    uid: Option<u32>,\n+    gid: Option<u32>,\n+}\n+\n /// The unique id of the process (this should never be negative).\n pub struct Process {\n     pub pid: pid_t"}, {"sha": "5e2c207f3756ae545c9e184a52f56ce64e1189ef", "filename": "src/libstd/sys/unix/process2.rs", "status": "added", "additions": 446, "deletions": 0, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -0,0 +1,446 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use collections::HashMap;\n+use collections::hash_map::Hasher;\n+use env;\n+use ffi::{OsString, OsStr, CString};\n+use fmt;\n+use hash::Hash;\n+use io::{self, Error, ErrorKind};\n+use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n+use mem;\n+use old_io;\n+use os;\n+use os::unix::OsStrExt;\n+use ptr;\n+use sync::mpsc::{channel, Sender, Receiver};\n+use sys::pipe2::AnonPipe;\n+use sys::{self, retry, c, wouldblock, set_nonblocking, ms_to_timeval, cvt};\n+use sys_common::AsInner;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+#[derive(Clone)]\n+pub struct Command {\n+    pub program: CString,\n+    pub args: Vec<CString>,\n+    pub env: Option<HashMap<OsString, OsString>>,\n+    pub cwd: Option<CString>,\n+    pub uid: Option<uid_t>,\n+    pub gid: Option<gid_t>,\n+    pub detach: bool, // not currently exposed in std::process\n+}\n+\n+impl Command {\n+    pub fn new(program: &OsStr) -> Command {\n+        Command {\n+            program: program.to_cstring(),\n+            args: Vec::new(),\n+            env: None,\n+            cwd: None,\n+            uid: None,\n+            gid: None,\n+            detach: false,\n+        }\n+    }\n+\n+    pub fn arg(&mut self, arg: &OsStr) {\n+        self.args.push(arg.to_cstring())\n+    }\n+    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) {\n+        self.args.extend(args.map(OsStrExt::to_cstring))\n+    }\n+    fn init_env_map(&mut self) {\n+        if self.env.is_none() {\n+            self.env = Some(env::vars_os().collect());\n+        }\n+    }\n+    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n+        self.init_env_map();\n+        self.env.as_mut().unwrap().insert(key.to_os_string(), val.to_os_string());\n+    }\n+    pub fn env_remove(&mut self, key: &OsStr) {\n+        self.init_env_map();\n+        self.env.as_mut().unwrap().remove(&key.to_os_string());\n+    }\n+    pub fn env_clear(&mut self) {\n+        self.env = Some(HashMap::new())\n+    }\n+    pub fn cwd(&mut self, dir: &OsStr) {\n+        self.cwd = Some(dir.to_cstring())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Unix exit statuses\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub enum ExitStatus {\n+    /// Normal termination with an exit code.\n+    Code(i32),\n+\n+    /// Termination by signal, with the signal number.\n+    ///\n+    /// Never generated on Windows.\n+    Signal(i32),\n+}\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        *self == ExitStatus::Code(0)\n+    }\n+    pub fn code(&self) -> Option<i32> {\n+        match *self {\n+            ExitStatus::Code(c) => Some(c),\n+            _ => None\n+        }\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            ExitStatus::Code(code) =>  write!(f, \"exit code: {}\", code),\n+            ExitStatus::Signal(code) =>  write!(f, \"signal: {}\", code),\n+        }\n+    }\n+}\n+\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pid: pid_t\n+}\n+\n+const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n+impl Process {\n+    pub fn id(&self) -> pid_t {\n+        self.pid\n+    }\n+\n+    pub unsafe fn kill(&self) -> io::Result<()> {\n+        try!(cvt(libc::funcs::posix88::signal::kill(self.pid, libc::SIGKILL)));\n+        Ok(())\n+    }\n+\n+    pub fn spawn(cfg: &Command,\n+                 in_fd: Option<AnonPipe>, out_fd: Option<AnonPipe>, err_fd: Option<AnonPipe>)\n+                 -> io::Result<Process>\n+    {\n+        use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+        use libc::funcs::bsd44::getdtablesize;\n+\n+        mod rustrt {\n+            extern {\n+                pub fn rust_unset_sigprocmask();\n+            }\n+        }\n+\n+        unsafe fn set_cloexec(fd: c_int) {\n+            let ret = c::ioctl(fd, c::FIOCLEX);\n+            assert_eq!(ret, 0);\n+        }\n+\n+        let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n+\n+        with_envp(cfg.env.as_ref(), |envp: *const c_void| {\n+            with_argv(&cfg.program, &cfg.args, |argv: *const *const libc::c_char| unsafe {\n+                let (input, mut output) = try!(sys::pipe2::anon_pipe());\n+\n+                // We may use this in the child, so perform allocations before the\n+                // fork\n+                let devnull = b\"/dev/null\\0\";\n+\n+                set_cloexec(output.raw());\n+\n+                let pid = fork();\n+                if pid < 0 {\n+                    return Err(Error::last_os_error())\n+                } else if pid > 0 {\n+                    #[inline]\n+                    fn combine(arr: &[u8]) -> i32 {\n+                        let a = arr[0] as u32;\n+                        let b = arr[1] as u32;\n+                        let c = arr[2] as u32;\n+                        let d = arr[3] as u32;\n+\n+                        ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+                    }\n+\n+                    let p = Process{ pid: pid };\n+                    drop(output);\n+                    let mut bytes = [0; 8];\n+\n+                    // loop to handle EINTER\n+                    loop {\n+                        match input.read(&mut bytes) {\n+                            Ok(8) => {\n+                                assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n+                                        \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n+                                let errno = combine(&bytes[0.. 4]);\n+                                assert!(p.wait().is_ok(),\n+                                        \"wait() should either return Ok or panic\");\n+                                return Err(Error::from_os_error(errno))\n+                            }\n+                            Ok(0) => return Ok(p),\n+                            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                            Err(e) => {\n+                                assert!(p.wait().is_ok(),\n+                                        \"wait() should either return Ok or panic\");\n+                                panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n+                            },\n+                            Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                                assert!(p.wait().is_ok(),\n+                                        \"wait() should either return Ok or panic\");\n+                                panic!(\"short read on the CLOEXEC pipe\")\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // And at this point we've reached a special time in the life of the\n+                // child. The child must now be considered hamstrung and unable to\n+                // do anything other than syscalls really. Consider the following\n+                // scenario:\n+                //\n+                //      1. Thread A of process 1 grabs the malloc() mutex\n+                //      2. Thread B of process 1 forks(), creating thread C\n+                //      3. Thread C of process 2 then attempts to malloc()\n+                //      4. The memory of process 2 is the same as the memory of\n+                //         process 1, so the mutex is locked.\n+                //\n+                // This situation looks a lot like deadlock, right? It turns out\n+                // that this is what pthread_atfork() takes care of, which is\n+                // presumably implemented across platforms. The first thing that\n+                // threads to *before* forking is to do things like grab the malloc\n+                // mutex, and then after the fork they unlock it.\n+                //\n+                // Despite this information, libnative's spawn has been witnessed to\n+                // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+                // all collected backtraces point at malloc/free traffic in the\n+                // child spawned process.\n+                //\n+                // For this reason, the block of code below should contain 0\n+                // invocations of either malloc of free (or their related friends).\n+                //\n+                // As an example of not having malloc/free traffic, we don't close\n+                // this file descriptor by dropping the FileDesc (which contains an\n+                // allocation). Instead we just close it manually. This will never\n+                // have the drop glue anyway because this code never returns (the\n+                // child will either exec() or invoke libc::exit)\n+                let _ = libc::close(input.raw());\n+\n+                fn fail(output: &mut AnonPipe) -> ! {\n+                    let errno = sys::os::errno() as u32;\n+                    let bytes = [\n+                        (errno >> 24) as u8,\n+                        (errno >> 16) as u8,\n+                        (errno >>  8) as u8,\n+                        (errno >>  0) as u8,\n+                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+                    ];\n+                    // pipe I/O up to PIPE_BUF bytes should be atomic\n+                    assert!(output.write(&bytes).is_ok());\n+                    unsafe { libc::_exit(1) }\n+                }\n+\n+                rustrt::rust_unset_sigprocmask();\n+\n+                // If a stdio file descriptor is set to be ignored, we don't\n+                // actually close it, but rather open up /dev/null into that\n+                // file descriptor. Otherwise, the first file descriptor opened\n+                // up in the child would be numbered as one of the stdio file\n+                // descriptors, which is likely to wreak havoc.\n+                let setup = |&: src: Option<AnonPipe>, dst: c_int| {\n+                    let src = match src {\n+                        None => {\n+                            let flags = if dst == libc::STDIN_FILENO {\n+                                libc::O_RDONLY\n+                            } else {\n+                                libc::O_RDWR\n+                            };\n+                            libc::open(devnull.as_ptr() as *const _, flags, 0)\n+                        }\n+                        Some(obj) => {\n+                            let fd = obj.raw();\n+                            // Leak the memory and the file descriptor. We're in the\n+                            // child now an all our resources are going to be\n+                            // cleaned up very soon\n+                            mem::forget(obj);\n+                            fd\n+                        }\n+                    };\n+                    src != -1 && retry(|| dup2(src, dst)) != -1\n+                };\n+\n+                if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n+                if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n+                if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n+\n+                // close all other fds\n+                for fd in (3..getdtablesize()).rev() {\n+                    if fd != output.raw() {\n+                        let _ = close(fd as c_int);\n+                    }\n+                }\n+\n+                match cfg.gid {\n+                    Some(u) => {\n+                        if libc::setgid(u as libc::gid_t) != 0 {\n+                            fail(&mut output);\n+                        }\n+                    }\n+                    None => {}\n+                }\n+                match cfg.uid {\n+                    Some(u) => {\n+                        // When dropping privileges from root, the `setgroups` call\n+                        // will remove any extraneous groups. If we don't call this,\n+                        // then even though our uid has dropped, we may still have\n+                        // groups that enable us to do super-user things. This will\n+                        // fail if we aren't root, so don't bother checking the\n+                        // return value, this is just done as an optimistic\n+                        // privilege dropping function.\n+                        extern {\n+                            fn setgroups(ngroups: libc::c_int,\n+                                         ptr: *const libc::c_void) -> libc::c_int;\n+                        }\n+                        let _ = setgroups(0, ptr::null());\n+\n+                        if libc::setuid(u as libc::uid_t) != 0 {\n+                            fail(&mut output);\n+                        }\n+                    }\n+                    None => {}\n+                }\n+                if cfg.detach {\n+                    // Don't check the error of setsid because it fails if we're the\n+                    // process leader already. We just forked so it shouldn't return\n+                    // error, but ignore it anyway.\n+                    let _ = libc::setsid();\n+                }\n+                if !dirp.is_null() && chdir(dirp) == -1 {\n+                    fail(&mut output);\n+                }\n+                if !envp.is_null() {\n+                    *sys::os::environ() = envp as *const _;\n+                }\n+                let _ = execvp(*argv, argv as *mut _);\n+                fail(&mut output);\n+            })\n+        })\n+    }\n+\n+    pub fn wait(&self) -> io::Result<ExitStatus> {\n+        let mut status = 0 as c_int;\n+        try!(cvt(retry(|| unsafe { c::waitpid(self.pid, &mut status, 0) })));\n+        Ok(translate_status(status))\n+    }\n+\n+    pub fn try_wait(&self) -> Option<ExitStatus> {\n+        let mut status = 0 as c_int;\n+        match retry(|| unsafe {\n+            c::waitpid(self.pid, &mut status, c::WNOHANG)\n+        }) {\n+            n if n == self.pid => Some(translate_status(status)),\n+            0 => None,\n+            n => panic!(\"unknown waitpid error `{:?}`: {:?}\", n,\n+                       super::last_error()),\n+        }\n+    }\n+}\n+\n+fn with_argv<T,F>(prog: &CString, args: &[CString], cb: F) -> T\n+    where F : FnOnce(*const *const libc::c_char) -> T\n+{\n+    let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n+\n+    // Convert the CStrings into an array of pointers. Note: the\n+    // lifetime of the various CStrings involved is guaranteed to be\n+    // larger than the lifetime of our invocation of cb, but this is\n+    // technically unsafe as the callback could leak these pointers\n+    // out of our scope.\n+    ptrs.push(prog.as_ptr());\n+    ptrs.extend(args.iter().map(|tmp| tmp.as_ptr()));\n+\n+    // Add a terminating null pointer (required by libc).\n+    ptrs.push(ptr::null());\n+\n+    cb(ptrs.as_ptr())\n+}\n+\n+fn with_envp<T, F>(env: Option<&HashMap<OsString, OsString>>, cb: F) -> T\n+    where F : FnOnce(*const c_void) -> T\n+{\n+    // On posixy systems we can pass a char** for envp, which is a\n+    // null-terminated array of \"k=v\\0\" strings. Since we must create\n+    // these strings locally, yet expose a raw pointer to them, we\n+    // create a temporary vector to own the CStrings that outlives the\n+    // call to cb.\n+    match env {\n+        Some(env) => {\n+            let mut tmps = Vec::with_capacity(env.len());\n+\n+            for pair in env {\n+                let mut kv = Vec::new();\n+                kv.push_all(pair.0.as_bytes());\n+                kv.push('=' as u8);\n+                kv.push_all(pair.1.as_bytes());\n+                kv.push(0); // terminating null\n+                tmps.push(kv);\n+            }\n+\n+            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n+            let mut ptrs: Vec<*const libc::c_char> =\n+                tmps.iter()\n+                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n+                    .collect();\n+            ptrs.push(ptr::null());\n+\n+            cb(ptrs.as_ptr() as *const c_void)\n+        }\n+        _ => cb(ptr::null())\n+    }\n+}\n+\n+fn translate_status(status: c_int) -> ExitStatus {\n+    #![allow(non_snake_case)]\n+    #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+    mod imp {\n+        pub fn WIFEXITED(status: i32) -> bool { (status & 0xff) == 0 }\n+        pub fn WEXITSTATUS(status: i32) -> i32 { (status >> 8) & 0xff }\n+        pub fn WTERMSIG(status: i32) -> i32 { status & 0x7f }\n+    }\n+\n+    #[cfg(any(target_os = \"macos\",\n+              target_os = \"ios\",\n+              target_os = \"freebsd\",\n+              target_os = \"dragonfly\",\n+              target_os = \"openbsd\"))]\n+    mod imp {\n+        pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }\n+        pub fn WEXITSTATUS(status: i32) -> i32 { status >> 8 }\n+        pub fn WTERMSIG(status: i32) -> i32 { status & 0o177 }\n+    }\n+\n+    if imp::WIFEXITED(status) {\n+        ExitStatus::Code(imp::WEXITSTATUS(status))\n+    } else {\n+        ExitStatus::Signal(imp::WTERMSIG(status))\n+    }\n+}"}, {"sha": "8abcd90efe8578a6cab8523babf818b1a12e8b44", "filename": "src/libstd/sys/windows/fs2.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs2.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -225,27 +225,11 @@ impl File {\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let mut read = 0;\n-        try!(cvt(unsafe {\n-            libc::ReadFile(self.handle.raw(),\n-                           buf.as_ptr() as libc::LPVOID,\n-                           buf.len() as libc::DWORD,\n-                           &mut read,\n-                           ptr::null_mut())\n-        }));\n-        Ok(read as usize)\n+        self.handle.read(buf)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let mut amt = 0;\n-        try!(cvt(unsafe {\n-            libc::WriteFile(self.handle.raw(),\n-                            buf.as_ptr() as libc::LPVOID,\n-                            buf.len() as libc::DWORD,\n-                            &mut amt,\n-                            ptr::null_mut())\n-        }));\n-        Ok(amt as usize)\n+        self.handle.write(buf)\n     }\n \n     pub fn flush(&self) -> io::Result<()> { Ok(()) }"}, {"sha": "99de659be41edf7986b81236f3cea90305bb9fc3", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -11,6 +11,10 @@\n use prelude::v1::*;\n \n use libc::{self, HANDLE};\n+use io;\n+use io::ErrorKind;\n+use ptr;\n+use sys::cvt;\n \n pub struct Handle(HANDLE);\n \n@@ -21,7 +25,16 @@ impl Handle {\n     pub fn new(handle: HANDLE) -> Handle {\n         Handle(handle)\n     }\n+\n     pub fn raw(&self) -> HANDLE { self.0 }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        read(self.0, buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        write(self.0, buf)\n+    }\n }\n \n impl Drop for Handle {\n@@ -30,3 +43,34 @@ impl Drop for Handle {\n     }\n }\n \n+\n+pub fn read(h: HANDLE, buf: &mut [u8]) -> io::Result<usize> {\n+    let mut read = 0;\n+    let res = cvt(unsafe {\n+        libc::ReadFile(h, buf.as_ptr() as libc::LPVOID,\n+                       buf.len() as libc::DWORD, &mut read,\n+                       ptr::null_mut())\n+    });\n+\n+    match res {\n+        Ok(_) => Ok(read as usize),\n+\n+        // The special treatment of BrokenPipe is to deal with Windows\n+        // pipe semantics, which yields this error when *reading* from\n+        // a pipe after the other end has closed; we interpret that as\n+        // EOF on the pipe.\n+        Err(ref e) if e.kind() == ErrorKind::BrokenPipe => Ok(0),\n+\n+        Err(e) => Err(e)\n+    }\n+}\n+\n+pub fn write(h: HANDLE, buf: &[u8]) -> io::Result<usize> {\n+    let mut amt = 0;\n+    try!(cvt(unsafe {\n+        libc::WriteFile(h, buf.as_ptr() as libc::LPVOID,\n+                        buf.len() as libc::DWORD, &mut amt,\n+                        ptr::null_mut())\n+    }));\n+    Ok(amt as usize)\n+}"}, {"sha": "4d6d033deee1475cdd12b6d9d399f4b5ce0fe7db", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -47,7 +47,9 @@ pub mod net;\n pub mod os;\n pub mod os_str;\n pub mod pipe;\n+pub mod pipe2;\n pub mod process;\n+pub mod process2;\n pub mod rwlock;\n pub mod stack_overflow;\n pub mod sync;"}, {"sha": "229481e3d57e637c3cc0c24d25f4b9aa186c703b", "filename": "src/libstd/sys/windows/pipe2.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use sys::handle;\n+use io;\n+use libc::{self, c_int, HANDLE};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Anonymous pipes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct AnonPipe {\n+    fd: c_int\n+}\n+\n+pub unsafe fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+    // Windows pipes work subtly differently than unix pipes, and their\n+    // inheritance has to be handled in a different way that I do not\n+    // fully understand. Here we explicitly make the pipe non-inheritable,\n+    // which means to pass it to a subprocess they need to be duplicated\n+    // first, as in std::run.\n+    let mut fds = [0; 2];\n+    match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n+    (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n+        0 => {\n+            assert!(fds[0] != -1 && fds[0] != 0);\n+            assert!(fds[1] != -1 && fds[1] != 0);\n+\n+            Ok((AnonPipe::from_fd(fds[0]), AnonPipe::from_fd(fds[1])))\n+        }\n+        _ => Err(io::Error::last_os_error()),\n+    }\n+}\n+\n+impl AnonPipe {\n+    pub fn from_fd(fd: libc::c_int) -> AnonPipe {\n+        AnonPipe { fd: fd }\n+    }\n+\n+    pub fn raw(&self) -> HANDLE {\n+        unsafe { libc::get_osfhandle(self.fd) as libc::HANDLE }\n+    }\n+\n+    pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        handle::read(self.raw(), buf)\n+    }\n+\n+    pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n+        handle::write(self.raw(), buf)\n+    }\n+}\n+\n+impl Drop for AnonPipe {\n+    fn drop(&mut self) {\n+        // closing stdio file handles makes no sense, so never do it. Also, note\n+        // that errors are ignored when closing a file descriptor. The reason\n+        // for this is that if an error occurs we don't actually know if the\n+        // file descriptor was closed or not, and if we retried (for something\n+        // like EINTR), we might close another valid file descriptor (opened\n+        // after we closed ours.\n+        if self.fd > libc::STDERR_FILENO {\n+            let n = unsafe { libc::close(self.fd) };\n+            if n != 0 {\n+                println!(\"error {} when closing file descriptor {}\", n, self.fd);\n+            }\n+        }\n+    }\n+}"}, {"sha": "19e38196d199fc360f20c199dd5047ed9cf5d939", "filename": "src/libstd/sys/windows/process2.rs", "status": "added", "additions": 479, "deletions": 0, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4175f1ce2fa57ca466e94aa59de9b9383f3c05a4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=4175f1ce2fa57ca466e94aa59de9b9383f3c05a4", "patch": "@@ -0,0 +1,479 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::v1::*;\n+\n+use ascii::*;\n+use collections::HashMap;\n+use collections;\n+use env;\n+use ffi::{OsString, OsStr};\n+use fmt;\n+use io::{self, Error};\n+use libc::{self, c_void};\n+use old_io::fs;\n+use old_path;\n+use os::windows::OsStrExt;\n+use ptr;\n+use sync::{StaticMutex, MUTEX_INIT};\n+use sys::pipe2::AnonPipe;\n+use sys::{self, cvt};\n+use sys::handle::Handle;\n+use sys_common::{AsInner, FromInner};\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+fn mk_key(s: &OsStr) -> OsString {\n+    FromInner::from_inner(sys::os_str::Buf {\n+        inner: s.as_inner().inner.to_ascii_uppercase()\n+    })\n+}\n+\n+#[derive(Clone)]\n+pub struct Command {\n+    pub program: OsString,\n+    pub args: Vec<OsString>,\n+    pub env: Option<HashMap<OsString, OsString>>,\n+    pub cwd: Option<OsString>,\n+    pub detach: bool, // not currently exposed in std::process\n+}\n+\n+impl Command {\n+    pub fn new(program: &OsStr) -> Command {\n+        Command {\n+            program: program.to_os_string(),\n+            args: Vec::new(),\n+            env: None,\n+            cwd: None,\n+            detach: false,\n+        }\n+    }\n+\n+    pub fn arg(&mut self, arg: &OsStr) {\n+        self.args.push(arg.to_os_string())\n+    }\n+    pub fn args<'a, I: Iterator<Item = &'a OsStr>>(&mut self, args: I) {\n+        self.args.extend(args.map(OsStr::to_os_string))\n+    }\n+    fn init_env_map(&mut self){\n+        if self.env.is_none() {\n+            self.env = Some(env::vars_os().map(|(key, val)| {\n+                (mk_key(&key), val)\n+            }).collect());\n+        }\n+    }\n+    pub fn env(&mut self, key: &OsStr, val: &OsStr) {\n+        self.init_env_map();\n+        self.env.as_mut().unwrap().insert(mk_key(key), val.to_os_string());\n+    }\n+    pub fn env_remove(&mut self, key: &OsStr) {\n+        self.init_env_map();\n+        self.env.as_mut().unwrap().remove(&mk_key(key));\n+    }\n+    pub fn env_clear(&mut self) {\n+        self.env = Some(HashMap::new())\n+    }\n+    pub fn cwd(&mut self, dir: &OsStr) {\n+        self.cwd = Some(dir.to_os_string())\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+// `CreateProcess` is racy!\n+// http://support.microsoft.com/kb/315939\n+static CREATE_PROCESS_LOCK: StaticMutex = MUTEX_INIT;\n+\n+/// A value representing a child process.\n+///\n+/// The lifetime of this value is linked to the lifetime of the actual\n+/// process - the Process destructor calls self.finish() which waits\n+/// for the process to terminate.\n+pub struct Process {\n+    /// A HANDLE to the process, which will prevent the pid being\n+    /// re-used until the handle is closed.\n+    handle: Handle,\n+}\n+\n+impl Process {\n+    #[allow(deprecated)]\n+    pub fn spawn(cfg: &Command,\n+                 in_fd: Option<AnonPipe>, out_fd: Option<AnonPipe>, err_fd: Option<AnonPipe>)\n+                 -> io::Result<Process>\n+    {\n+        use libc::types::os::arch::extra::{DWORD, HANDLE, STARTUPINFO};\n+        use libc::consts::os::extra::{\n+            TRUE, FALSE,\n+            STARTF_USESTDHANDLES,\n+            INVALID_HANDLE_VALUE,\n+            DUPLICATE_SAME_ACCESS\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            GetCurrentProcess,\n+            DuplicateHandle,\n+            CloseHandle,\n+            CreateProcessW\n+        };\n+\n+        use env::split_paths;\n+        use mem;\n+        use iter::IteratorExt;\n+        use str::StrExt;\n+\n+        // To have the spawning semantics of unix/windows stay the same, we need to\n+        // read the *child's* PATH if one is provided. See #15149 for more details.\n+        let program = cfg.env.as_ref().and_then(|env| {\n+            for (key, v) in env {\n+                if OsStr::from_str(\"PATH\") != &**key { continue }\n+\n+                // Split the value and test each path to see if the\n+                // program exists.\n+                for path in split_paths(&v) {\n+                    let path = path.join(cfg.program.to_str().unwrap())\n+                                   .with_extension(env::consts::EXE_EXTENSION);\n+                    // FIXME: update with new fs module once it lands\n+                    if fs::stat(&old_path::Path::new(&path)).is_ok() {\n+                        return Some(OsString::from_str(path.as_str().unwrap()))\n+                    }\n+                }\n+                break\n+            }\n+            None\n+        });\n+\n+        unsafe {\n+            let mut si = zeroed_startupinfo();\n+            si.cb = mem::size_of::<STARTUPINFO>() as DWORD;\n+            si.dwFlags = STARTF_USESTDHANDLES;\n+\n+            let cur_proc = GetCurrentProcess();\n+\n+            // Similarly to unix, we don't actually leave holes for the stdio file\n+            // descriptors, but rather open up /dev/null equivalents. These\n+            // equivalents are drawn from libuv's windows process spawning.\n+            let set_fd = |&: fd: &Option<AnonPipe>, slot: &mut HANDLE,\n+                          is_stdin: bool| {\n+                match *fd {\n+                    None => {\n+                        let access = if is_stdin {\n+                            libc::FILE_GENERIC_READ\n+                        } else {\n+                            libc::FILE_GENERIC_WRITE | libc::FILE_READ_ATTRIBUTES\n+                        };\n+                        let size = mem::size_of::<libc::SECURITY_ATTRIBUTES>();\n+                        let mut sa = libc::SECURITY_ATTRIBUTES {\n+                            nLength: size as libc::DWORD,\n+                            lpSecurityDescriptor: ptr::null_mut(),\n+                            bInheritHandle: 1,\n+                        };\n+                        let mut filename: Vec<u16> = \"NUL\".utf16_units().collect();\n+                        filename.push(0);\n+                        *slot = libc::CreateFileW(filename.as_ptr(),\n+                                                  access,\n+                                                  libc::FILE_SHARE_READ |\n+                                                      libc::FILE_SHARE_WRITE,\n+                                                  &mut sa,\n+                                                  libc::OPEN_EXISTING,\n+                                                  0,\n+                                                  ptr::null_mut());\n+                        if *slot == INVALID_HANDLE_VALUE {\n+                            return Err(Error::last_os_error())\n+                        }\n+                    }\n+                    Some(ref pipe) => {\n+                        let orig = pipe.raw();\n+                        if orig == INVALID_HANDLE_VALUE {\n+                            return Err(Error::last_os_error())\n+                        }\n+                        if DuplicateHandle(cur_proc, orig, cur_proc, slot,\n+                                           0, TRUE, DUPLICATE_SAME_ACCESS) == FALSE {\n+                            return Err(Error::last_os_error())\n+                        }\n+                    }\n+                }\n+                Ok(())\n+            };\n+\n+            try!(set_fd(&in_fd, &mut si.hStdInput, true));\n+            try!(set_fd(&out_fd, &mut si.hStdOutput, false));\n+            try!(set_fd(&err_fd, &mut si.hStdError, false));\n+\n+            let mut cmd_str = make_command_line(program.as_ref().unwrap_or(&cfg.program),\n+                                            &cfg.args);\n+            cmd_str.push(0); // add null terminator\n+\n+            let mut pi = zeroed_process_information();\n+            let mut create_err = None;\n+\n+            // stolen from the libuv code.\n+            let mut flags = libc::CREATE_UNICODE_ENVIRONMENT;\n+            if cfg.detach {\n+                flags |= libc::DETACHED_PROCESS | libc::CREATE_NEW_PROCESS_GROUP;\n+            }\n+\n+            with_envp(cfg.env.as_ref(), |envp| {\n+                with_dirp(cfg.cwd.as_ref(), |dirp| {\n+                    let _lock = CREATE_PROCESS_LOCK.lock().unwrap();\n+                    let created = CreateProcessW(ptr::null(),\n+                                                 cmd_str.as_mut_ptr(),\n+                                                 ptr::null_mut(),\n+                                                 ptr::null_mut(),\n+                                                 TRUE,\n+                                                 flags, envp, dirp,\n+                                                 &mut si, &mut pi);\n+                    if created == FALSE {\n+                        create_err = Some(Error::last_os_error());\n+                    }\n+                })\n+            });\n+\n+            assert!(CloseHandle(si.hStdInput) != 0);\n+            assert!(CloseHandle(si.hStdOutput) != 0);\n+            assert!(CloseHandle(si.hStdError) != 0);\n+\n+            match create_err {\n+                Some(err) => return Err(err),\n+                None => {}\n+            }\n+\n+            // We close the thread handle because we don't care about keeping the\n+            // thread id valid, and we aren't keeping the thread handle around to be\n+            // able to close it later. We don't close the process handle however\n+            // because std::we want the process id to stay valid at least until the\n+            // calling code closes the process handle.\n+            assert!(CloseHandle(pi.hThread) != 0);\n+\n+            Ok(Process {\n+                handle: Handle::new(pi.hProcess)\n+            })\n+        }\n+    }\n+\n+    pub unsafe fn kill(&self) -> io::Result<()> {\n+        try!(cvt(libc::TerminateProcess(self.handle.raw(), 1)));\n+        Ok(())\n+    }\n+\n+    pub fn wait(&self) -> io::Result<ExitStatus> {\n+        use libc::consts::os::extra::{\n+            FALSE,\n+            STILL_ACTIVE,\n+            INFINITE,\n+            WAIT_OBJECT_0,\n+        };\n+        use libc::funcs::extra::kernel32::{\n+            GetExitCodeProcess,\n+            WaitForSingleObject,\n+        };\n+\n+        unsafe {\n+            loop {\n+                let mut status = 0;\n+                if GetExitCodeProcess(self.handle.raw(), &mut status) == FALSE {\n+                    let err = Err(Error::last_os_error());\n+                    return err;\n+                }\n+                if status != STILL_ACTIVE {\n+                    return Ok(ExitStatus(status as i32));\n+                }\n+                match WaitForSingleObject(self.handle.raw(), INFINITE) {\n+                    WAIT_OBJECT_0 => {}\n+                    _ => {\n+                        let err = Err(Error::last_os_error());\n+                        return err\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub struct ExitStatus(i32);\n+\n+impl ExitStatus {\n+    pub fn success(&self) -> bool {\n+        self.0 == 0\n+    }\n+    pub fn code(&self) -> Option<i32> {\n+        Some(self.0)\n+    }\n+}\n+\n+impl fmt::Display for ExitStatus {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"exit code: {}\", self.0)\n+    }\n+}\n+\n+fn zeroed_startupinfo() -> libc::types::os::arch::extra::STARTUPINFO {\n+    libc::types::os::arch::extra::STARTUPINFO {\n+        cb: 0,\n+        lpReserved: ptr::null_mut(),\n+        lpDesktop: ptr::null_mut(),\n+        lpTitle: ptr::null_mut(),\n+        dwX: 0,\n+        dwY: 0,\n+        dwXSize: 0,\n+        dwYSize: 0,\n+        dwXCountChars: 0,\n+        dwYCountCharts: 0,\n+        dwFillAttribute: 0,\n+        dwFlags: 0,\n+        wShowWindow: 0,\n+        cbReserved2: 0,\n+        lpReserved2: ptr::null_mut(),\n+        hStdInput: libc::INVALID_HANDLE_VALUE,\n+        hStdOutput: libc::INVALID_HANDLE_VALUE,\n+        hStdError: libc::INVALID_HANDLE_VALUE,\n+    }\n+}\n+\n+fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMATION {\n+    libc::types::os::arch::extra::PROCESS_INFORMATION {\n+        hProcess: ptr::null_mut(),\n+        hThread: ptr::null_mut(),\n+        dwProcessId: 0,\n+        dwThreadId: 0\n+    }\n+}\n+\n+// Produces a wide string *without terminating null*\n+fn make_command_line(prog: &OsStr, args: &[OsString]) -> Vec<u16> {\n+    let mut cmd: Vec<u16> = Vec::new();\n+    append_arg(&mut cmd, prog);\n+    for arg in args {\n+        cmd.push(' ' as u16);\n+        append_arg(&mut cmd, arg);\n+    }\n+    return cmd;\n+\n+    fn append_arg(cmd: &mut Vec<u16>, arg: &OsStr) {\n+        // If an argument has 0 characters then we need to quote it to ensure\n+        // that it actually gets passed through on the command line or otherwise\n+        // it will be dropped entirely when parsed on the other end.\n+        let arg_bytes = &arg.as_inner().inner.as_inner();\n+        let quote = arg_bytes.iter().any(|c| *c == b' ' || *c == b'\\t')\n+            || arg_bytes.len() == 0;\n+        if quote {\n+            cmd.push('\"' as u16);\n+        }\n+\n+        let mut iter = arg.encode_wide();\n+        while let Some(x) = iter.next() {\n+            if x == '\"' as u16 {\n+                // escape quotes\n+                cmd.push('\\\\' as u16);\n+                cmd.push('\"' as u16);\n+            } else if x == '\\\\' as u16 {\n+                // is this a run of backslashes followed by a \" ?\n+                if iter.clone().skip_while(|y| *y == '\\\\' as u16).next() == Some('\"' as u16) {\n+                    // Double it ... NOTE: this behavior is being\n+                    // preserved as it's been part of Rust for a long\n+                    // time, but no one seems to know exactly why this\n+                    // is the right thing to do.\n+                    cmd.push('\\\\' as u16);\n+                    cmd.push('\\\\' as u16);\n+                } else {\n+                    // Push it through unescaped\n+                    cmd.push('\\\\' as u16);\n+                }\n+            } else {\n+                cmd.push(x)\n+            }\n+        }\n+\n+        if quote {\n+            cmd.push('\"' as u16);\n+        }\n+    }\n+}\n+\n+fn with_envp<F, T>(env: Option<&collections::HashMap<OsString, OsString>>, cb: F) -> T\n+    where F: FnOnce(*mut c_void) -> T,\n+{\n+    // On Windows we pass an \"environment block\" which is not a char**, but\n+    // rather a concatenation of null-terminated k=v\\0 sequences, with a final\n+    // \\0 to terminate.\n+    match env {\n+        Some(env) => {\n+            let mut blk = Vec::new();\n+\n+            for pair in env {\n+                blk.extend(pair.0.encode_wide());\n+                blk.push('=' as u16);\n+                blk.extend(pair.1.encode_wide());\n+                blk.push(0);\n+            }\n+            blk.push(0);\n+            cb(blk.as_mut_ptr() as *mut c_void)\n+        }\n+        _ => cb(ptr::null_mut())\n+    }\n+}\n+\n+fn with_dirp<T, F>(d: Option<&OsString>, cb: F) -> T where\n+    F: FnOnce(*const u16) -> T,\n+{\n+    match d {\n+      Some(dir) => {\n+          let mut dir_str: Vec<u16> = dir.encode_wide().collect();\n+          dir_str.push(0);\n+          cb(dir_str.as_ptr())\n+      },\n+      None => cb(ptr::null())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use str;\n+    use ffi::{OsStr, OsString};\n+    use super::make_command_line;\n+\n+    #[test]\n+    fn test_make_command_line() {\n+        fn test_wrapper(prog: &str, args: &[&str]) -> String {\n+            String::from_utf16(\n+                &make_command_line(OsStr::from_str(prog),\n+                                   args.iter()\n+                                       .map(|a| OsString::from_str(a))\n+                                       .collect::<Vec<OsString>>()\n+                                       .as_slice())).unwrap()\n+        }\n+\n+        assert_eq!(\n+            test_wrapper(\"prog\", &[\"aaa\", \"bbb\", \"ccc\"]),\n+            \"prog aaa bbb ccc\"\n+        );\n+\n+        assert_eq!(\n+            test_wrapper(\"C:\\\\Program Files\\\\blah\\\\blah.exe\", &[\"aaa\"]),\n+            \"\\\"C:\\\\Program Files\\\\blah\\\\blah.exe\\\" aaa\"\n+        );\n+        assert_eq!(\n+            test_wrapper(\"C:\\\\Program Files\\\\test\", &[\"aa\\\"bb\"]),\n+            \"\\\"C:\\\\Program Files\\\\test\\\" aa\\\\\\\"bb\"\n+        );\n+        assert_eq!(\n+            test_wrapper(\"echo\", &[\"a b c\"]),\n+            \"echo \\\"a b c\\\"\"\n+        );\n+        assert_eq!(\n+            test_wrapper(\"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\", &[]),\n+            \"\\u{03c0}\\u{042f}\\u{97f3}\\u{00e6}\\u{221e}\"\n+        );\n+    }\n+}"}]}