{"sha": "bbc6b2691ef07401690382103b67509b3189f939", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYzZiMjY5MWVmMDc0MDE2OTAzODIxMDNiNjc1MDliMzE4OWY5Mzk=", "commit": {"author": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-07-01T16:54:02Z"}, "committer": {"name": "Frank Steffahn", "email": "frank.steffahn@stu.uni-kiel.de", "date": "2021-07-28T12:33:35Z"}, "message": "Change __iterator_get_unchecked to work with TrustedRandomAccessNoCoerce", "tree": {"sha": "6328c670fa4e4e02c8b5ddab54f760751a33aee3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6328c670fa4e4e02c8b5ddab54f760751a33aee3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbc6b2691ef07401690382103b67509b3189f939", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc6b2691ef07401690382103b67509b3189f939", "html_url": "https://github.com/rust-lang/rust/commit/bbc6b2691ef07401690382103b67509b3189f939", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbc6b2691ef07401690382103b67509b3189f939/comments", "author": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steffahn", "id": 3986214, "node_id": "MDQ6VXNlcjM5ODYyMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3986214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steffahn", "html_url": "https://github.com/steffahn", "followers_url": "https://api.github.com/users/steffahn/followers", "following_url": "https://api.github.com/users/steffahn/following{/other_user}", "gists_url": "https://api.github.com/users/steffahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/steffahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steffahn/subscriptions", "organizations_url": "https://api.github.com/users/steffahn/orgs", "repos_url": "https://api.github.com/users/steffahn/repos", "events_url": "https://api.github.com/users/steffahn/events{/privacy}", "received_events_url": "https://api.github.com/users/steffahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69dd992f95123451e6b2077b84ab2b54f4f1aeae", "url": "https://api.github.com/repos/rust-lang/rust/commits/69dd992f95123451e6b2077b84ab2b54f4f1aeae", "html_url": "https://github.com/rust-lang/rust/commit/69dd992f95123451e6b2077b84ab2b54f4f1aeae"}], "stats": {"total": 170, "additions": 102, "deletions": 68}, "files": [{"sha": "71a5a4ea831ffe6a12914a4eee5eebf34a33f3a4", "filename": "library/core/src/iter/adapters/cloned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs?ref=bbc6b2691ef07401690382103b67509b3189f939", "patch": "@@ -63,7 +63,7 @@ where\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n     where\n-        Self: TrustedRandomAccess,\n+        Self: TrustedRandomAccessNoCoerce,\n     {\n         // SAFETY: the caller must uphold the contract for\n         // `Iterator::__iterator_get_unchecked`."}, {"sha": "3d3c8da678b8b7f17d73d96c160bb51f7fcb1374", "filename": "library/core/src/iter/adapters/copied.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=bbc6b2691ef07401690382103b67509b3189f939", "patch": "@@ -79,7 +79,7 @@ where\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n     where\n-        Self: TrustedRandomAccess,\n+        Self: TrustedRandomAccessNoCoerce,\n     {\n         // SAFETY: the caller must uphold the contract for\n         // `Iterator::__iterator_get_unchecked`."}, {"sha": "3478a0cd40832b008bf6e46cdc6723897843d959", "filename": "library/core/src/iter/adapters/enumerate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs?ref=bbc6b2691ef07401690382103b67509b3189f939", "patch": "@@ -116,7 +116,7 @@ where\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n     where\n-        Self: TrustedRandomAccess,\n+        Self: TrustedRandomAccessNoCoerce,\n     {\n         // SAFETY: the caller must uphold the contract for\n         // `Iterator::__iterator_get_unchecked`."}, {"sha": "fbf752c6f2024ac54e959f0ab5815eb6d375e653", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=bbc6b2691ef07401690382103b67509b3189f939", "patch": "@@ -132,7 +132,7 @@ where\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n     where\n-        Self: TrustedRandomAccess,\n+        Self: TrustedRandomAccessNoCoerce,\n     {\n         match self.iter {\n             // SAFETY: the caller must uphold the contract for"}, {"sha": "763e253e75a516a0a0b2d1275378994d6de99e51", "filename": "library/core/src/iter/adapters/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs?ref=bbc6b2691ef07401690382103b67509b3189f939", "patch": "@@ -127,7 +127,7 @@ where\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> B\n     where\n-        Self: TrustedRandomAccess,\n+        Self: TrustedRandomAccessNoCoerce,\n     {\n         // SAFETY: the caller must uphold the contract for\n         // `Iterator::__iterator_get_unchecked`."}, {"sha": "8a7f6bf92559fcc1cff5d43612772ffe9095b5d4", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 94, "deletions": 60, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=bbc6b2691ef07401690382103b67509b3189f939", "patch": "@@ -91,7 +91,7 @@ where\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n     where\n-        Self: TrustedRandomAccess,\n+        Self: TrustedRandomAccessNoCoerce,\n     {\n         // SAFETY: `ZipImpl::__iterator_get_unchecked` has same safety\n         // requirements as `Iterator::__iterator_get_unchecked`.\n@@ -126,7 +126,66 @@ trait ZipImpl<A, B> {\n     // This has the same safety requirements as `Iterator::__iterator_get_unchecked`\n     unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n     where\n-        Self: Iterator + TrustedRandomAccess;\n+        Self: Iterator + TrustedRandomAccessNoCoerce;\n+}\n+\n+// Work around limitations of specialization, requiring `default` impls to be repeated\n+// in intermediary impls.\n+macro_rules! zip_impl_general_defaults {\n+    () => {\n+        default fn new(a: A, b: B) -> Self {\n+            Zip {\n+                a,\n+                b,\n+                index: 0, // unused\n+                len: 0,   // unused\n+                a_len: 0, // unused\n+            }\n+        }\n+\n+        #[inline]\n+        default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n+            let x = self.a.next()?;\n+            let y = self.b.next()?;\n+            Some((x, y))\n+        }\n+\n+        #[inline]\n+        default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+            self.super_nth(n)\n+        }\n+\n+        #[inline]\n+        default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n+        where\n+            A: DoubleEndedIterator + ExactSizeIterator,\n+            B: DoubleEndedIterator + ExactSizeIterator,\n+        {\n+            // The function body below only uses `self.a/b.len()` and `self.a/b.next_back()`\n+            // and doesn\u2019t call `next_back` too often, so this implementation is safe in\n+            // the `TrustedRandomAccessNoCoerce` specialization\n+\n+            let a_sz = self.a.len();\n+            let b_sz = self.b.len();\n+            if a_sz != b_sz {\n+                // Adjust a, b to equal length\n+                if a_sz > b_sz {\n+                    for _ in 0..a_sz - b_sz {\n+                        self.a.next_back();\n+                    }\n+                } else {\n+                    for _ in 0..b_sz - a_sz {\n+                        self.b.next_back();\n+                    }\n+                }\n+            }\n+            match (self.a.next_back(), self.b.next_back()) {\n+                (Some(x), Some(y)) => Some((x, y)),\n+                (None, None) => None,\n+                _ => unreachable!(),\n+            }\n+        }\n+    };\n }\n \n // General Zip impl\n@@ -137,54 +196,8 @@ where\n     B: Iterator,\n {\n     type Item = (A::Item, B::Item);\n-    default fn new(a: A, b: B) -> Self {\n-        Zip {\n-            a,\n-            b,\n-            index: 0, // unused\n-            len: 0,   // unused\n-            a_len: 0, // unused\n-        }\n-    }\n-\n-    #[inline]\n-    default fn next(&mut self) -> Option<(A::Item, B::Item)> {\n-        let x = self.a.next()?;\n-        let y = self.b.next()?;\n-        Some((x, y))\n-    }\n \n-    #[inline]\n-    default fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        self.super_nth(n)\n-    }\n-\n-    #[inline]\n-    default fn next_back(&mut self) -> Option<(A::Item, B::Item)>\n-    where\n-        A: DoubleEndedIterator + ExactSizeIterator,\n-        B: DoubleEndedIterator + ExactSizeIterator,\n-    {\n-        let a_sz = self.a.len();\n-        let b_sz = self.b.len();\n-        if a_sz != b_sz {\n-            // Adjust a, b to equal length\n-            if a_sz > b_sz {\n-                for _ in 0..a_sz - b_sz {\n-                    self.a.next_back();\n-                }\n-            } else {\n-                for _ in 0..b_sz - a_sz {\n-                    self.b.next_back();\n-                }\n-            }\n-        }\n-        match (self.a.next_back(), self.b.next_back()) {\n-            (Some(x), Some(y)) => Some((x, y)),\n-            (None, None) => None,\n-            _ => unreachable!(),\n-        }\n-    }\n+    zip_impl_general_defaults! {}\n \n     #[inline]\n     default fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -205,12 +218,35 @@ where\n \n     default unsafe fn get_unchecked(&mut self, _idx: usize) -> <Self as Iterator>::Item\n     where\n-        Self: TrustedRandomAccess,\n+        Self: TrustedRandomAccessNoCoerce,\n     {\n         unreachable!(\"Always specialized\");\n     }\n }\n \n+#[doc(hidden)]\n+impl<A, B> ZipImpl<A, B> for Zip<A, B>\n+where\n+    A: TrustedRandomAccessNoCoerce + Iterator,\n+    B: TrustedRandomAccessNoCoerce + Iterator,\n+{\n+    zip_impl_general_defaults! {}\n+\n+    #[inline]\n+    default fn size_hint(&self) -> (usize, Option<usize>) {\n+        let size = cmp::min(self.a.size(), self.b.size());\n+        (size, Some(size))\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item {\n+        let idx = self.index + idx;\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        unsafe { (self.a.__iterator_get_unchecked(idx), self.b.__iterator_get_unchecked(idx)) }\n+    }\n+}\n+\n #[doc(hidden)]\n impl<A, B> ZipImpl<A, B> for Zip<A, B>\n where\n@@ -330,14 +366,6 @@ where\n             None\n         }\n     }\n-\n-    #[inline]\n-    unsafe fn get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item {\n-        let idx = self.index + idx;\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        unsafe { (self.a.__iterator_get_unchecked(idx), self.b.__iterator_get_unchecked(idx)) }\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -426,7 +454,9 @@ impl<A: Debug, B: Debug> ZipFmt<A, B> for Zip<A, B> {\n     }\n }\n \n-impl<A: Debug + TrustedRandomAccess, B: Debug + TrustedRandomAccess> ZipFmt<A, B> for Zip<A, B> {\n+impl<A: Debug + TrustedRandomAccessNoCoerce, B: Debug + TrustedRandomAccessNoCoerce> ZipFmt<A, B>\n+    for Zip<A, B>\n+{\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // It's *not safe* to call fmt on the contained iterators, since once\n         // we start iterating they're in strange, potentially unsafe, states.\n@@ -448,6 +478,9 @@ impl<A: Debug + TrustedRandomAccess, B: Debug + TrustedRandomAccess> ZipFmt<A, B\n /// for bounds that come from the respective struct/enum definition itself, or bounds involving\n /// traits that themselves come with a guarantee similar to this one.\n ///\n+/// If `Self: ExactSizeIterator` then `self.len()` must always produce results consistent\n+/// with `self.size()`.\n+///\n /// If `Self: Iterator`, then `<Self as Iterator>::__iterator_get_unchecked(&mut self, idx)`\n /// must be safe to call provided the following conditions are met.\n ///\n@@ -463,6 +496,7 @@ impl<A: Debug + TrustedRandomAccess, B: Debug + TrustedRandomAccess> ZipFmt<A, B\n ///     * `std::clone::Clone::clone`\n ///     * `std::iter::Iterator::size_hint`\n ///     * `std::iter::DoubleEndedIterator::next_back`\n+///     * `std::iter::ExactSizeIterator::len`\n ///     * `std::iter::Iterator::__iterator_get_unchecked`\n ///     * `std::iter::TrustedRandomAccessNoCoerce::size`\n /// 5. If `T` is a subtype of `Self`, then `self` is allowed to be coerced\n@@ -532,7 +566,7 @@ unsafe impl<I: Iterator> SpecTrustedRandomAccess for I {\n     }\n }\n \n-unsafe impl<I: Iterator + TrustedRandomAccess> SpecTrustedRandomAccess for I {\n+unsafe impl<I: Iterator + TrustedRandomAccessNoCoerce> SpecTrustedRandomAccess for I {\n     unsafe fn try_get_unchecked(&mut self, index: usize) -> Self::Item {\n         // SAFETY: the caller must uphold the contract for\n         // `Iterator::__iterator_get_unchecked`."}, {"sha": "22782a81378112397f3f02d7c5787d70fc4591fd", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=bbc6b2691ef07401690382103b67509b3189f939", "patch": "@@ -676,7 +676,7 @@ impl<A: Step> Iterator for ops::Range<A> {\n     #[doc(hidden)]\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item\n     where\n-        Self: TrustedRandomAccess,\n+        Self: TrustedRandomAccessNoCoerce,\n     {\n         // SAFETY: The TrustedRandomAccess contract requires that callers only  pass an index\n         // that is in bounds."}, {"sha": "a1a336a05740a76d08cb8d14f4e9b3d2df9f2127", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc6b2691ef07401690382103b67509b3189f939/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=bbc6b2691ef07401690382103b67509b3189f939", "patch": "@@ -5,7 +5,7 @@\n use crate::cmp::{self, Ordering};\n use crate::ops::{ControlFlow, Try};\n \n-use super::super::TrustedRandomAccess;\n+use super::super::TrustedRandomAccessNoCoerce;\n use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n use super::super::{FromIterator, Intersperse, IntersperseWith, Product, Sum, Zip};\n@@ -3464,7 +3464,7 @@ pub trait Iterator {\n     #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n     unsafe fn __iterator_get_unchecked(&mut self, _idx: usize) -> Self::Item\n     where\n-        Self: TrustedRandomAccess,\n+        Self: TrustedRandomAccessNoCoerce,\n     {\n         unreachable!(\"Always specialized\");\n     }"}]}