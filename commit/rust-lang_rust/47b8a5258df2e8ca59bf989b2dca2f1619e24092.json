{"sha": "47b8a5258df2e8ca59bf989b2dca2f1619e24092", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3YjhhNTI1OGRmMmU4Y2E1OWJmOTg5YjJkY2EyZjE2MTllMjQwOTI=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-22T19:00:19Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-08-24T02:40:20Z"}, "message": "Report an ambiguity if both modules and primitives are in scope\n\n- Add a new `prim@` disambiguator, since both modules and primitives are\nin the same namespace\n- Refactor `report_ambiguity` into a closure\n\nAdditionally, I noticed that rustdoc would previously allow\n`[struct@char]` if `char` resolved to a primitive (not if it had a\nDefId). I fixed that and added a test case.", "tree": {"sha": "d60d8b88740bdd46078d478d8f4e15b8238f34d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d60d8b88740bdd46078d478d8f4e15b8238f34d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47b8a5258df2e8ca59bf989b2dca2f1619e24092", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47b8a5258df2e8ca59bf989b2dca2f1619e24092", "html_url": "https://github.com/rust-lang/rust/commit/47b8a5258df2e8ca59bf989b2dca2f1619e24092", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47b8a5258df2e8ca59bf989b2dca2f1619e24092/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "html_url": "https://github.com/rust-lang/rust/commit/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd"}], "stats": {"total": 235, "additions": 192, "deletions": 43}, "files": [{"sha": "bf6d47c885b8986920dbac4dec72c6f7ffdab984", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 109, "deletions": 43, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/47b8a5258df2e8ca59bf989b2dca2f1619e24092/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8a5258df2e8ca59bf989b2dca2f1619e24092/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=47b8a5258df2e8ca59bf989b2dca2f1619e24092", "patch": "@@ -181,7 +181,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn resolve(\n         &self,\n         path_str: &str,\n-        disambiguator: Option<Disambiguator>,\n         ns: Namespace,\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n@@ -218,18 +217,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         return Ok((res, Some(path_str.to_owned())));\n                     }\n                     Res::Def(DefKind::Mod, _) => {\n-                        // This resolved to a module, but we want primitive types to take precedence instead.\n-                        if matches!(\n-                            disambiguator,\n-                            None | Some(Disambiguator::Namespace(Namespace::TypeNS))\n-                        ) {\n-                            if let Some((path, prim)) = is_primitive(path_str, ns) {\n-                                if extra_fragment.is_some() {\n-                                    return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n-                                }\n-                                return Ok((prim, Some(path.to_owned())));\n-                            }\n-                        }\n                         return Ok((res, extra_fragment.clone()));\n                     }\n                     _ => {\n@@ -713,7 +700,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             let resolved_self;\n             let mut path_str;\n             let disambiguator;\n-            let (res, fragment) = {\n+            let (mut res, mut fragment) = {\n                 path_str = if let Ok((d, path)) = Disambiguator::from_str(&link) {\n                     disambiguator = Some(d);\n                     path\n@@ -756,7 +743,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     Some(ns @ (ValueNS | TypeNS)) => {\n                         match self.resolve(\n                             path_str,\n-                            disambiguator,\n                             ns,\n                             &current_item,\n                             base_node,\n@@ -784,7 +770,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 .map(|res| (res, extra_fragment.clone())),\n                             type_ns: match self.resolve(\n                                 path_str,\n-                                disambiguator,\n                                 TypeNS,\n                                 &current_item,\n                                 base_node,\n@@ -802,7 +787,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             },\n                             value_ns: match self.resolve(\n                                 path_str,\n-                                disambiguator,\n                                 ValueNS,\n                                 &current_item,\n                                 base_node,\n@@ -848,13 +832,18 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             if is_derive_trait_collision(&candidates) {\n                                 candidates.macro_ns = None;\n                             }\n+                            let candidates =\n+                                candidates.map(|candidate| candidate.map(|(res, _)| res));\n+                            let candidates = [TypeNS, ValueNS, MacroNS]\n+                                .iter()\n+                                .filter_map(|&ns| candidates[ns].map(|res| (res, ns)));\n                             ambiguity_error(\n                                 cx,\n                                 &item,\n                                 path_str,\n                                 &dox,\n                                 link_range,\n-                                candidates.map(|candidate| candidate.map(|(res, _)| res)),\n+                                candidates.collect(),\n                             );\n                             continue;\n                         }\n@@ -870,13 +859,81 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 }\n             };\n \n+            // Check for a primitive which might conflict with a module\n+            // Report the ambiguity and require that the user specify which one they meant.\n+            // FIXME: could there ever be a primitive not in the type namespace?\n+            if matches!(\n+                disambiguator,\n+                None | Some(Disambiguator::Namespace(Namespace::TypeNS) | Disambiguator::Primitive)\n+            ) && !matches!(res, Res::PrimTy(_))\n+            {\n+                if let Some((path, prim)) = is_primitive(path_str, TypeNS) {\n+                    // `prim@char`\n+                    if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n+                        if fragment.is_some() {\n+                            anchor_failure(\n+                                cx,\n+                                &item,\n+                                path_str,\n+                                &dox,\n+                                link_range,\n+                                AnchorFailure::Primitive,\n+                            );\n+                            continue;\n+                        }\n+                        res = prim;\n+                        fragment = Some(path.to_owned());\n+                    } else {\n+                        // `[char]` when a `char` module is in scope\n+                        let candidates = vec![(res, TypeNS), (prim, TypeNS)];\n+                        ambiguity_error(cx, &item, path_str, &dox, link_range, candidates);\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            let report_mismatch = |specified: Disambiguator, resolved: Disambiguator| {\n+                // The resolved item did not match the disambiguator; give a better error than 'not found'\n+                let msg = format!(\"incompatible link kind for `{}`\", path_str);\n+                report_diagnostic(cx, &msg, &item, &dox, link_range.clone(), |diag, sp| {\n+                    let note = format!(\n+                        \"this link resolved to {} {}, which is not {} {}\",\n+                        resolved.article(),\n+                        resolved.descr(),\n+                        specified.article(),\n+                        specified.descr()\n+                    );\n+                    let suggestion = resolved.display_for(path_str);\n+                    let help_msg =\n+                        format!(\"to link to the {}, use its disambiguator\", resolved.descr());\n+                    diag.note(&note);\n+                    if let Some(sp) = sp {\n+                        diag.span_suggestion(\n+                            sp,\n+                            &help_msg,\n+                            suggestion,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        diag.help(&format!(\"{}: {}\", help_msg, suggestion));\n+                    }\n+                });\n+            };\n             if let Res::PrimTy(_) = res {\n-                item.attrs.links.push((ori_link, None, fragment));\n+                match disambiguator {\n+                    Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n+                        item.attrs.links.push((ori_link, None, fragment))\n+                    }\n+                    Some(other) => {\n+                        report_mismatch(other, Disambiguator::Primitive);\n+                        continue;\n+                    }\n+                }\n             } else {\n                 debug!(\"intra-doc link to {} resolved to {:?}\", path_str, res);\n \n                 // Disallow e.g. linking to enums with `struct@`\n-                if let Res::Def(kind, id) = res {\n+                if let Res::Def(kind, _) = res {\n                     debug!(\"saw kind {:?} with disambiguator {:?}\", kind, disambiguator);\n                     match (self.kind_side_channel.take().unwrap_or(kind), disambiguator) {\n                         | (DefKind::Const | DefKind::ConstParam | DefKind::AssocConst | DefKind::AnonConst, Some(Disambiguator::Kind(DefKind::Const)))\n@@ -890,22 +947,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                         // All of these are valid, so do nothing\n                         => {}\n                         (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n-                        (_, Some(Disambiguator::Kind(expected))) => {\n-                            // The resolved item did not match the disambiguator; give a better error than 'not found'\n-                            let msg = format!(\"incompatible link kind for `{}`\", path_str);\n-                            report_diagnostic(cx, &msg, &item, &dox, link_range, |diag, sp| {\n-                                // HACK(jynelson): by looking at the source I saw the DefId we pass\n-                                // for `expected.descr()` doesn't matter, since it's not a crate\n-                                let note = format!(\"this link resolved to {} {}, which is not {} {}\", kind.article(), kind.descr(id), expected.article(), expected.descr(id));\n-                                let suggestion = Disambiguator::display_for(kind, path_str);\n-                                let help_msg = format!(\"to link to the {}, use its disambiguator\", kind.descr(id));\n-                                diag.note(&note);\n-                                if let Some(sp) = sp {\n-                                    diag.span_suggestion(sp, &help_msg, suggestion, Applicability::MaybeIncorrect);\n-                                } else {\n-                                    diag.help(&format!(\"{}: {}\", help_msg, suggestion));\n-                                }\n-                            });\n+                        (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n+                            report_mismatch(specified, Disambiguator::Kind(kind));\n                             continue;\n                         }\n                     }\n@@ -961,14 +1004,15 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum Disambiguator {\n+    Primitive,\n     Kind(DefKind),\n     Namespace(Namespace),\n }\n \n impl Disambiguator {\n     /// (disambiguator, path_str)\n     fn from_str(link: &str) -> Result<(Self, &str), ()> {\n-        use Disambiguator::{Kind, Namespace as NS};\n+        use Disambiguator::{Kind, Namespace as NS, Primitive};\n \n         let find_suffix = || {\n             let suffixes = [\n@@ -999,6 +1043,7 @@ impl Disambiguator {\n                 \"type\" => NS(Namespace::TypeNS),\n                 \"value\" => NS(Namespace::ValueNS),\n                 \"macro\" => NS(Namespace::MacroNS),\n+                \"prim\" | \"primitive\" => Primitive,\n                 _ => return find_suffix(),\n             };\n             Ok((d, &rest[1..]))\n@@ -1007,7 +1052,12 @@ impl Disambiguator {\n         }\n     }\n \n-    fn display_for(kind: DefKind, path_str: &str) -> String {\n+    fn display_for(self, path_str: &str) -> String {\n+        let kind = match self {\n+            Disambiguator::Primitive => return format!(\"prim@{}\", path_str),\n+            Disambiguator::Kind(kind) => kind,\n+            Disambiguator::Namespace(_) => panic!(\"display_for cannot be used on namespaces\"),\n+        };\n         if kind == DefKind::Macro(MacroKind::Bang) {\n             return format!(\"{}!\", path_str);\n         } else if kind == DefKind::Fn || kind == DefKind::AssocFn {\n@@ -1043,6 +1093,25 @@ impl Disambiguator {\n             Self::Kind(k) => {\n                 k.ns().expect(\"only DefKinds with a valid namespace can be disambiguators\")\n             }\n+            Self::Primitive => TypeNS,\n+        }\n+    }\n+\n+    fn article(self) -> &'static str {\n+        match self {\n+            Self::Namespace(_) => panic!(\"article() doesn't make sense for namespaces\"),\n+            Self::Kind(k) => k.article(),\n+            Self::Primitive => \"a\",\n+        }\n+    }\n+\n+    fn descr(self) -> &'static str {\n+        match self {\n+            Self::Namespace(n) => n.descr(),\n+            // HACK(jynelson): by looking at the source I saw the DefId we pass\n+            // for `expected.descr()` doesn't matter, since it's not a crate\n+            Self::Kind(k) => k.descr(DefId::local(hir::def_id::DefIndex::from_usize(0))),\n+            Self::Primitive => \"builtin type\",\n         }\n     }\n }\n@@ -1183,14 +1252,10 @@ fn ambiguity_error(\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n-    candidates: PerNS<Option<Res>>,\n+    candidates: Vec<(Res, Namespace)>,\n ) {\n     let mut msg = format!(\"`{}` is \", path_str);\n \n-    let candidates = [TypeNS, ValueNS, MacroNS]\n-        .iter()\n-        .filter_map(|&ns| candidates[ns].map(|res| (res, ns)))\n-        .collect::<Vec<_>>();\n     match candidates.as_slice() {\n         [(first_def, _), (second_def, _)] => {\n             msg += &format!(\n@@ -1229,6 +1294,7 @@ fn ambiguity_error(\n                     }\n                     _ => {\n                         let type_ = match (res, ns) {\n+                            (Res::PrimTy(_), _) => \"prim\",\n                             (Res::Def(DefKind::Const, _), _) => \"const\",\n                             (Res::Def(DefKind::Static, _), _) => \"static\",\n                             (Res::Def(DefKind::Struct, _), _) => \"struct\","}, {"sha": "34276fbcf2058cf80e3483113f03619ea4090ecc", "filename": "src/test/rustdoc-ui/intra-link-prim-conflict.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/47b8a5258df2e8ca59bf989b2dca2f1619e24092/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8a5258df2e8ca59bf989b2dca2f1619e24092/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.rs?ref=47b8a5258df2e8ca59bf989b2dca2f1619e24092", "patch": "@@ -0,0 +1,30 @@\n+#![deny(broken_intra_doc_links)]\n+//~^ NOTE lint level is defined\n+\n+/// [char]\n+//~^ ERROR both a module and a builtin type\n+//~| NOTE ambiguous link\n+//~| HELP to link to the module\n+//~| HELP to link to the builtin type\n+\n+/// [type@char]\n+//~^ ERROR both a module and a builtin type\n+//~| NOTE ambiguous link\n+//~| HELP to link to the module\n+//~| HELP to link to the builtin type\n+\n+/// [mod@char] // ok\n+/// [prim@char] // ok\n+\n+/// [struct@char]\n+//~^ ERROR incompatible link\n+//~| HELP use its disambiguator\n+//~| NOTE resolved to a module\n+pub mod char {}\n+\n+pub mod inner {\n+    //! [struct@char]\n+    //~^ ERROR incompatible link\n+    //~| HELP use its disambiguator\n+    //~| NOTE resolved to a builtin type\n+}"}, {"sha": "b28a44266665648d2cc0eda8ed6aac966cdbd291", "filename": "src/test/rustdoc-ui/intra-link-prim-conflict.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/47b8a5258df2e8ca59bf989b2dca2f1619e24092/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47b8a5258df2e8ca59bf989b2dca2f1619e24092/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-prim-conflict.stderr?ref=47b8a5258df2e8ca59bf989b2dca2f1619e24092", "patch": "@@ -0,0 +1,53 @@\n+error: `char` is both a module and a builtin type\n+  --> $DIR/intra-link-prim-conflict.rs:4:6\n+   |\n+LL | /// [char]\n+   |      ^^^^ ambiguous link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/intra-link-prim-conflict.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the module, prefix with the item type\n+   |\n+LL | /// [module@char]\n+   |      ^^^^^^^^^^^\n+help: to link to the builtin type, prefix with the item type\n+   |\n+LL | /// [prim@char]\n+   |      ^^^^^^^^^\n+\n+error: `char` is both a module and a builtin type\n+  --> $DIR/intra-link-prim-conflict.rs:10:6\n+   |\n+LL | /// [type@char]\n+   |      ^^^^^^^^^ ambiguous link\n+   |\n+help: to link to the module, prefix with the item type\n+   |\n+LL | /// [module@char]\n+   |      ^^^^^^^^^^^\n+help: to link to the builtin type, prefix with the item type\n+   |\n+LL | /// [prim@char]\n+   |      ^^^^^^^^^\n+\n+error: incompatible link kind for `char`\n+  --> $DIR/intra-link-prim-conflict.rs:19:6\n+   |\n+LL | /// [struct@char]\n+   |      ^^^^^^^^^^^ help: to link to the module, use its disambiguator: `mod@char`\n+   |\n+   = note: this link resolved to a module, which is not a struct\n+\n+error: incompatible link kind for `char`\n+  --> $DIR/intra-link-prim-conflict.rs:26:10\n+   |\n+LL |     //! [struct@char]\n+   |          ^^^^^^^^^^^ help: to link to the builtin type, use its disambiguator: `prim@char`\n+   |\n+   = note: this link resolved to a builtin type, which is not a struct\n+\n+error: aborting due to 4 previous errors\n+"}]}