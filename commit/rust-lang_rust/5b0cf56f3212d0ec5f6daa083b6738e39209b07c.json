{"sha": "5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMGNmNTZmMzIxMmQwZWM1ZjZkYWEwODNiNjczOGUzOTIwOWIwN2M=", "commit": {"author": {"name": "csmoe", "email": "35686186+csmoe@users.noreply.github.com", "date": "2018-07-11T15:36:06Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-07-16T13:09:17Z"}, "message": "ItemKind", "tree": {"sha": "959399797a7bc5e7937052b421497e50d4f8e373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/959399797a7bc5e7937052b421497e50d4f8e373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "html_url": "https://github.com/rust-lang/rust/commit/5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/comments", "author": {"login": "csmoe", "id": 35686186, "node_id": "MDQ6VXNlcjM1Njg2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/35686186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/csmoe", "html_url": "https://github.com/csmoe", "followers_url": "https://api.github.com/users/csmoe/followers", "following_url": "https://api.github.com/users/csmoe/following{/other_user}", "gists_url": "https://api.github.com/users/csmoe/gists{/gist_id}", "starred_url": "https://api.github.com/users/csmoe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/csmoe/subscriptions", "organizations_url": "https://api.github.com/users/csmoe/orgs", "repos_url": "https://api.github.com/users/csmoe/repos", "events_url": "https://api.github.com/users/csmoe/events{/privacy}", "received_events_url": "https://api.github.com/users/csmoe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7e5d22447264fe8cd5e89326f31bb6f0db3f885b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e5d22447264fe8cd5e89326f31bb6f0db3f885b", "html_url": "https://github.com/rust-lang/rust/commit/7e5d22447264fe8cd5e89326f31bb6f0db3f885b"}], "stats": {"total": 1392, "additions": 696, "deletions": 696}, "files": [{"sha": "3f6d34617c8320d9ef8ef88df1af509c70a27f10", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -38,13 +38,13 @@ enum Target {\n impl Target {\n     fn from_item(item: &hir::Item) -> Target {\n         match item.node {\n-            hir::ItemFn(..) => Target::Fn,\n-            hir::ItemStruct(..) => Target::Struct,\n-            hir::ItemUnion(..) => Target::Union,\n-            hir::ItemEnum(..) => Target::Enum,\n-            hir::ItemConst(..) => Target::Const,\n-            hir::ItemForeignMod(..) => Target::ForeignMod,\n-            hir::ItemStatic(..) => Target::Static,\n+            hir::ItemKind::Fn(..) => Target::Fn,\n+            hir::ItemKind::Struct(..) => Target::Struct,\n+            hir::ItemKind::Union(..) => Target::Union,\n+            hir::ItemKind::Enum(..) => Target::Enum,\n+            hir::ItemKind::Const(..) => Target::Const,\n+            hir::ItemKind::ForeignMod(..) => Target::ForeignMod,\n+            hir::ItemKind::Static(..) => Target::Static,\n             _ => Target::Other,\n         }\n     }\n@@ -340,7 +340,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n }\n \n fn is_c_like_enum(item: &hir::Item) -> bool {\n-    if let hir::ItemEnum(ref def, _) = item.node {\n+    if let hir::ItemKind::Enum(ref def, _) = item.node {\n         for variant in &def.variants {\n             match variant.node.data {\n                 hir::VariantData::Unit(_) => { /* continue */ }"}, {"sha": "8827576cd9c8a7b33f0a6f4b4104206fe37c2885", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -463,23 +463,23 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n     visitor.visit_vis(&item.vis);\n     visitor.visit_name(item.span, item.name);\n     match item.node {\n-        ItemExternCrate(orig_name) => {\n+        ItemKind::ExternCrate(orig_name) => {\n             visitor.visit_id(item.id);\n             if let Some(orig_name) = orig_name {\n                 visitor.visit_name(item.span, orig_name);\n             }\n         }\n-        ItemUse(ref path, _) => {\n+        ItemKind::Use(ref path, _) => {\n             visitor.visit_id(item.id);\n             visitor.visit_path(path, item.id);\n         }\n-        ItemStatic(ref typ, _, body) |\n-        ItemConst(ref typ, body) => {\n+        ItemKind::Static(ref typ, _, body) |\n+        ItemKind::Const(ref typ, body) => {\n             visitor.visit_id(item.id);\n             visitor.visit_ty(typ);\n             visitor.visit_nested_body(body);\n         }\n-        ItemFn(ref declaration, header, ref generics, body_id) => {\n+        ItemKind::Fn(ref declaration, header, ref generics, body_id) => {\n             visitor.visit_fn(FnKind::ItemFn(item.name,\n                                             generics,\n                                             header,\n@@ -490,55 +490,55 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                              item.span,\n                              item.id)\n         }\n-        ItemMod(ref module) => {\n+        ItemKind::Mod(ref module) => {\n             // visit_mod() takes care of visiting the Item's NodeId\n             visitor.visit_mod(module, item.span, item.id)\n         }\n-        ItemForeignMod(ref foreign_module) => {\n+        ItemKind::ForeignMod(ref foreign_module) => {\n             visitor.visit_id(item.id);\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }\n-        ItemGlobalAsm(_) => {\n+        ItemKind::GlobalAsm(_) => {\n             visitor.visit_id(item.id);\n         }\n-        ItemTy(ref typ, ref type_parameters) => {\n+        ItemKind::Ty(ref typ, ref type_parameters) => {\n             visitor.visit_id(item.id);\n             visitor.visit_ty(typ);\n             visitor.visit_generics(type_parameters)\n         }\n-        ItemExistential(ExistTy {ref generics, ref bounds, impl_trait_fn}) => {\n+        ItemKind::Existential(ExistTy {ref generics, ref bounds, impl_trait_fn}) => {\n             visitor.visit_id(item.id);\n             walk_generics(visitor, generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             if let Some(impl_trait_fn) = impl_trait_fn {\n                 visitor.visit_def_mention(Def::Fn(impl_trait_fn))\n             }\n         }\n-        ItemEnum(ref enum_definition, ref type_parameters) => {\n+        ItemKind::Enum(ref enum_definition, ref type_parameters) => {\n             visitor.visit_generics(type_parameters);\n             // visit_enum_def() takes care of visiting the Item's NodeId\n             visitor.visit_enum_def(enum_definition, type_parameters, item.id, item.span)\n         }\n-        ItemImpl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_item_refs) => {\n+        ItemKind::Impl(.., ref type_parameters, ref opt_trait_reference, ref typ, ref impl_item_refs) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(type_parameters);\n             walk_list!(visitor, visit_trait_ref, opt_trait_reference);\n             visitor.visit_ty(typ);\n             walk_list!(visitor, visit_impl_item_ref, impl_item_refs);\n         }\n-        ItemStruct(ref struct_definition, ref generics) |\n-        ItemUnion(ref struct_definition, ref generics) => {\n+        ItemKind::Struct(ref struct_definition, ref generics) |\n+        ItemKind::Union(ref struct_definition, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_id(item.id);\n             visitor.visit_variant_data(struct_definition, item.name, generics, item.id, item.span);\n         }\n-        ItemTrait(.., ref generics, ref bounds, ref trait_item_refs) => {\n+        ItemKind::Trait(.., ref generics, ref bounds, ref trait_item_refs) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);\n             walk_list!(visitor, visit_trait_item_ref, trait_item_refs);\n         }\n-        ItemTraitAlias(ref generics, ref bounds) => {\n+        ItemKind::TraitAlias(ref generics, ref bounds) => {\n             visitor.visit_id(item.id);\n             visitor.visit_generics(generics);\n             walk_list!(visitor, visit_param_bound, bounds);"}, {"sha": "31484f33732803a9cd975963e01caca45cad6bde", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -384,8 +384,8 @@ impl<'a> LoweringContext<'a> {\n \n                 if item_lowered {\n                     let item_generics = match self.lctx.items.get(&item.id).unwrap().node {\n-                        hir::Item_::ItemImpl(_, _, _, ref generics, ..)\n-                        | hir::Item_::ItemTrait(_, _, ref generics, ..) => {\n+                        hir::ItemKind::Impl(_, _, _, ref generics, ..)\n+                        | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                             generics.params.clone()\n                         }\n                         _ => HirVec::new(),\n@@ -1274,7 +1274,7 @@ impl<'a> LoweringContext<'a> {\n         );\n \n         self.with_hir_id_owner(exist_ty_node_id, |lctx| {\n-            let exist_ty_item_kind = hir::ItemExistential(hir::ExistTy {\n+            let exist_ty_item_kind = hir::ItemKind::Existential(hir::ExistTy {\n                 generics: hir::Generics {\n                     params: lifetime_defs,\n                     where_clause: hir::WhereClause {\n@@ -2575,9 +2575,9 @@ impl<'a> LoweringContext<'a> {\n         attrs: &hir::HirVec<Attribute>,\n         vis: &mut hir::Visibility,\n         i: &ItemKind,\n-    ) -> hir::Item_ {\n+    ) -> hir::ItemKind {\n         match *i {\n-            ItemKind::ExternCrate(orig_name) => hir::ItemExternCrate(orig_name),\n+            ItemKind::ExternCrate(orig_name) => hir::ItemKind::ExternCrate(orig_name),\n             ItemKind::Use(ref use_tree) => {\n                 // Start with an empty prefix\n                 let prefix = Path {\n@@ -2589,15 +2589,15 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemStatic(\n+                hir::ItemKind::Static(\n                     self.lower_ty(t, ImplTraitContext::Disallowed),\n                     self.lower_mutability(m),\n                     value,\n                 )\n             }\n             ItemKind::Const(ref t, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemConst(self.lower_ty(t, ImplTraitContext::Disallowed), value)\n+                hir::ItemKind::Const(self.lower_ty(t, ImplTraitContext::Disallowed), value)\n             }\n             ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n@@ -2617,22 +2617,22 @@ impl<'a> LoweringContext<'a> {\n                             decl, Some((fn_def_id, idty)), true, header.asyncness.opt_return_id()),\n                     );\n \n-                    hir::ItemFn(\n+                    hir::ItemKind::Fn(\n                         fn_decl,\n                         this.lower_fn_header(header),\n                         generics,\n                         body_id,\n                     )\n                 })\n             }\n-            ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n-            ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n-            ItemKind::GlobalAsm(ref ga) => hir::ItemGlobalAsm(self.lower_global_asm(ga)),\n-            ItemKind::Ty(ref t, ref generics) => hir::ItemTy(\n+            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(m)),\n+            ItemKind::ForeignMod(ref nm) => hir::ItemKind::ForeignMod(self.lower_foreign_mod(nm)),\n+            ItemKind::GlobalAsm(ref ga) => hir::ItemKind::GlobalAsm(self.lower_global_asm(ga)),\n+            ItemKind::Ty(ref t, ref generics) => hir::ItemKind::Ty(\n                 self.lower_ty(t, ImplTraitContext::Disallowed),\n                 self.lower_generics(generics, ImplTraitContext::Disallowed),\n             ),\n-            ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemEnum(\n+            ItemKind::Enum(ref enum_definition, ref generics) => hir::ItemKind::Enum(\n                 hir::EnumDef {\n                     variants: enum_definition\n                         .variants\n@@ -2644,14 +2644,14 @@ impl<'a> LoweringContext<'a> {\n             ),\n             ItemKind::Struct(ref struct_def, ref generics) => {\n                 let struct_def = self.lower_variant_data(struct_def);\n-                hir::ItemStruct(\n+                hir::ItemKind::Struct(\n                     struct_def,\n                     self.lower_generics(generics, ImplTraitContext::Disallowed),\n                 )\n             }\n             ItemKind::Union(ref vdata, ref generics) => {\n                 let vdata = self.lower_variant_data(vdata);\n-                hir::ItemUnion(\n+                hir::ItemKind::Union(\n                     vdata,\n                     self.lower_generics(generics, ImplTraitContext::Disallowed),\n                 )\n@@ -2711,7 +2711,7 @@ impl<'a> LoweringContext<'a> {\n                     },\n                 );\n \n-                hir::ItemImpl(\n+                hir::ItemKind::Impl(\n                     self.lower_unsafety(unsafety),\n                     self.lower_impl_polarity(polarity),\n                     self.lower_defaultness(defaultness, true /* [1] */),\n@@ -2727,15 +2727,15 @@ impl<'a> LoweringContext<'a> {\n                     .iter()\n                     .map(|item| self.lower_trait_item_ref(item))\n                     .collect();\n-                hir::ItemTrait(\n+                hir::ItemKind::Trait(\n                     self.lower_is_auto(is_auto),\n                     self.lower_unsafety(unsafety),\n                     self.lower_generics(generics, ImplTraitContext::Disallowed),\n                     bounds,\n                     items,\n                 )\n             }\n-            ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemTraitAlias(\n+            ItemKind::TraitAlias(ref generics, ref bounds) => hir::ItemKind::TraitAlias(\n                 self.lower_generics(generics, ImplTraitContext::Disallowed),\n                 self.lower_param_bounds(bounds, ImplTraitContext::Disallowed),\n             ),\n@@ -2754,7 +2754,7 @@ impl<'a> LoweringContext<'a> {\n         vis: &mut hir::Visibility,\n         name: &mut Name,\n         attrs: &hir::HirVec<Attribute>,\n-    ) -> hir::Item_ {\n+    ) -> hir::ItemKind {\n         let path = &tree.prefix;\n \n         match tree.kind {\n@@ -2804,7 +2804,7 @@ impl<'a> LoweringContext<'a> {\n                     self.with_hir_id_owner(new_node_id, |this| {\n                         let new_id = this.lower_node_id(new_node_id);\n                         let path = this.lower_path_extra(def, &path, None, ParamMode::Explicit);\n-                        let item = hir::ItemUse(P(path), hir::UseKind::Single);\n+                        let item = hir::ItemKind::Use(P(path), hir::UseKind::Single);\n                         let vis_kind = match vis.node {\n                             hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n                             hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n@@ -2835,7 +2835,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n \n                 let path = P(self.lower_path_extra(ret_def, &path, None, ParamMode::Explicit));\n-                hir::ItemUse(path, hir::UseKind::Single)\n+                hir::ItemKind::Use(path, hir::UseKind::Single)\n             }\n             UseTreeKind::Glob => {\n                 let path = P(self.lower_path(\n@@ -2851,7 +2851,7 @@ impl<'a> LoweringContext<'a> {\n                     },\n                     ParamMode::Explicit,\n                 ));\n-                hir::ItemUse(path, hir::UseKind::Glob)\n+                hir::ItemKind::Use(path, hir::UseKind::Glob)\n             }\n             UseTreeKind::Nested(ref trees) => {\n                 let prefix = Path {\n@@ -2912,7 +2912,7 @@ impl<'a> LoweringContext<'a> {\n                 // a re-export by accident when `pub`, e.g. in documentation.\n                 let path = P(self.lower_path(id, &prefix, ParamMode::Explicit));\n                 *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n-                hir::ItemUse(path, hir::UseKind::ListStem)\n+                hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }\n         }\n     }"}, {"sha": "5a595d14db7aa5970452c520221835f7cbd38a46", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -47,7 +47,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n \n impl MaybeFnLike for ast::Item {\n     fn is_fn_like(&self) -> bool {\n-        match self.node { ast::ItemFn(..) => true, _ => false, }\n+        match self.node { ast::ItemKind::Fn(..) => true, _ => false, }\n     }\n }\n \n@@ -229,7 +229,7 @@ impl<'a> FnLikeNode<'a> {\n     {\n         match self.node {\n             map::NodeItem(i) => match i.node {\n-                ast::ItemFn(ref decl, header, ref generics, block) =>\n+                ast::ItemKind::Fn(ref decl, header, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n                         name: i.name,"}, {"sha": "0150ba659c900dcb8ea2a32e05d82926c5f04567", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n             this.insert(i.id, NodeItem(i));\n             this.with_parent(i.id, |this| {\n                 match i.node {\n-                    ItemStruct(ref struct_def, _) => {\n+                    ItemKind::Struct(ref struct_def, _) => {\n                         // If this is a tuple-like struct, register the constructor.\n                         if !struct_def.is_struct() {\n                             this.insert(struct_def.id(), NodeStructCtor(struct_def));"}, {"sha": "656f325b4dd89e4fc5616b55869fe74425869f65", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'hir: 'a> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n     fn visit_impl_item_ref(&mut self, _: &'hir hir::ImplItemRef) {\n         // Explicitly do nothing here. ImplItemRefs contain hir::Visibility\n-        // values that actually belong to an ImplItem instead of the ItemImpl\n+        // values that actually belong to an ImplItem instead of the ItemKind::Impl\n         // we are currently in. So for those it's correct that they have a\n         // different owner.\n     }"}, {"sha": "d413a544c4e410e5e535bc7808808eb23491e33e", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -175,7 +175,7 @@ impl<'hir> MapEntry<'hir> {\n         match self {\n             EntryItem(_, _, ref item) => {\n                 match item.node {\n-                    ItemFn(ref fn_decl, _, _, _) => Some(&fn_decl),\n+                    ItemKind::Fn(ref fn_decl, _, _, _) => Some(&fn_decl),\n                     _ => None,\n                 }\n             }\n@@ -209,9 +209,9 @@ impl<'hir> MapEntry<'hir> {\n         match self {\n             EntryItem(_, _, item) => {\n                 match item.node {\n-                    ItemConst(_, body) |\n-                    ItemStatic(.., body) |\n-                    ItemFn(_, _, _, body) => Some(body),\n+                    ItemKind::Const(_, body) |\n+                    ItemKind::Static(.., body) |\n+                    ItemKind::Fn(_, _, _, body) => Some(body),\n                     _ => None,\n                 }\n             }\n@@ -427,25 +427,25 @@ impl<'hir> Map<'hir> {\n                 };\n \n                 match item.node {\n-                    ItemStatic(_, m, _) => Some(Def::Static(def_id(),\n+                    ItemKind::Static(_, m, _) => Some(Def::Static(def_id(),\n                                                             m == MutMutable)),\n-                    ItemConst(..) => Some(Def::Const(def_id())),\n-                    ItemFn(..) => Some(Def::Fn(def_id())),\n-                    ItemMod(..) => Some(Def::Mod(def_id())),\n-                    ItemGlobalAsm(..) => Some(Def::GlobalAsm(def_id())),\n-                    ItemExistential(..) => Some(Def::Existential(def_id())),\n-                    ItemTy(..) => Some(Def::TyAlias(def_id())),\n-                    ItemEnum(..) => Some(Def::Enum(def_id())),\n-                    ItemStruct(..) => Some(Def::Struct(def_id())),\n-                    ItemUnion(..) => Some(Def::Union(def_id())),\n-                    ItemTrait(..) => Some(Def::Trait(def_id())),\n-                    ItemTraitAlias(..) => {\n+                    ItemKind::Const(..) => Some(Def::Const(def_id())),\n+                    ItemKind::Fn(..) => Some(Def::Fn(def_id())),\n+                    ItemKind::Mod(..) => Some(Def::Mod(def_id())),\n+                    ItemKind::GlobalAsm(..) => Some(Def::GlobalAsm(def_id())),\n+                    ItemKind::Existential(..) => Some(Def::Existential(def_id())),\n+                    ItemKind::Ty(..) => Some(Def::TyAlias(def_id())),\n+                    ItemKind::Enum(..) => Some(Def::Enum(def_id())),\n+                    ItemKind::Struct(..) => Some(Def::Struct(def_id())),\n+                    ItemKind::Union(..) => Some(Def::Union(def_id())),\n+                    ItemKind::Trait(..) => Some(Def::Trait(def_id())),\n+                    ItemKind::TraitAlias(..) => {\n                         bug!(\"trait aliases are not yet implemented (see issue #41517)\")\n                     },\n-                    ItemExternCrate(_) |\n-                    ItemUse(..) |\n-                    ItemForeignMod(..) |\n-                    ItemImpl(..) => None,\n+                    ItemKind::ExternCrate(_) |\n+                    ItemKind::Use(..) |\n+                    ItemKind::ForeignMod(..) |\n+                    ItemKind::Impl(..) => None,\n                 }\n             }\n             NodeForeignItem(item) => {\n@@ -587,13 +587,13 @@ impl<'hir> Map<'hir> {\n \n     pub fn body_owner_kind(&self, id: NodeId) -> BodyOwnerKind {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemConst(..), .. }) |\n+            NodeItem(&Item { node: ItemKind::Const(..), .. }) |\n             NodeTraitItem(&TraitItem { node: TraitItemKind::Const(..), .. }) |\n             NodeImplItem(&ImplItem { node: ImplItemKind::Const(..), .. }) |\n             NodeAnonConst(_) => {\n                 BodyOwnerKind::Const\n             }\n-            NodeItem(&Item { node: ItemStatic(_, m, _), .. }) => {\n+            NodeItem(&Item { node: ItemKind::Static(_, m, _), .. }) => {\n                 BodyOwnerKind::Static(m)\n             }\n             // Default to function if it's not a constant or static.\n@@ -603,7 +603,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_owner(&self, id: NodeId) -> NodeId {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemTrait(..), .. }) => id,\n+            NodeItem(&Item { node: ItemKind::Trait(..), .. }) => id,\n             NodeGenericParam(_) => self.get_parent_node(id),\n             _ => {\n                 bug!(\"ty_param_owner: {} not a type parameter\",\n@@ -614,7 +614,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn ty_param_name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n-            NodeItem(&Item { node: ItemTrait(..), .. }) => {\n+            NodeItem(&Item { node: ItemKind::Trait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n             NodeGenericParam(param) => param.name.ident().name,\n@@ -672,14 +672,14 @@ impl<'hir> Map<'hir> {\n                 NodeTraitItem(ref trait_item) => Some(&trait_item.generics),\n                 NodeItem(ref item) => {\n                     match item.node {\n-                        ItemFn(_, _, ref generics, _) |\n-                        ItemTy(_, ref generics) |\n-                        ItemEnum(_, ref generics) |\n-                        ItemStruct(_, ref generics) |\n-                        ItemUnion(_, ref generics) |\n-                        ItemTrait(_, _, ref generics, ..) |\n-                        ItemTraitAlias(ref generics, _) |\n-                        ItemImpl(_, _, _, ref generics, ..) => Some(generics),\n+                        ItemKind::Fn(_, _, ref generics, _) |\n+                        ItemKind::Ty(_, ref generics) |\n+                        ItemKind::Enum(_, ref generics) |\n+                        ItemKind::Struct(_, ref generics) |\n+                        ItemKind::Union(_, ref generics) |\n+                        ItemKind::Trait(_, _, ref generics, ..) |\n+                        ItemKind::TraitAlias(ref generics, _) |\n+                        ItemKind::Impl(_, _, _, ref generics, ..) => Some(generics),\n                         _ => None,\n                     }\n                 }\n@@ -857,7 +857,7 @@ impl<'hir> Map<'hir> {\n     /// module parent is in this map.\n     pub fn get_module_parent(&self, id: NodeId) -> DefId {\n         let id = match self.walk_parent_nodes(id, |node| match *node {\n-            NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n+            NodeItem(&Item { node: ItemKind::Mod(_), .. }) => true,\n             _ => false,\n         }, |_| false) {\n             Ok(id) => id,\n@@ -893,7 +893,7 @@ impl<'hir> Map<'hir> {\n         let abi = match self.find_entry(parent) {\n             Some(EntryItem(_, _, i)) => {\n                 match i.node {\n-                    ItemForeignMod(ref nm) => Some(nm.abi),\n+                    ItemKind::ForeignMod(ref nm) => Some(nm.abi),\n                     _ => None\n                 }\n             }\n@@ -934,8 +934,8 @@ impl<'hir> Map<'hir> {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n                 match i.node {\n-                    ItemStruct(ref struct_def, _) |\n-                    ItemUnion(ref struct_def, _) => struct_def,\n+                    ItemKind::Struct(ref struct_def, _) |\n+                    ItemKind::Union(ref struct_def, _) => struct_def,\n                     _ => {\n                         bug!(\"struct ID bound to non-struct {}\",\n                              self.node_to_string(id));\n@@ -1129,7 +1129,7 @@ impl<'a, 'hir> NodesMatchingSuffix<'a, 'hir> {\n \n             fn item_is_mod(item: &Item) -> bool {\n                 match item.node {\n-                    ItemMod(_) => true,\n+                    ItemKind::Mod(_) => true,\n                     _ => false,\n                 }\n             }\n@@ -1314,22 +1314,22 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n     match map.find(id) {\n         Some(NodeItem(item)) => {\n             let item_str = match item.node {\n-                ItemExternCrate(..) => \"extern crate\",\n-                ItemUse(..) => \"use\",\n-                ItemStatic(..) => \"static\",\n-                ItemConst(..) => \"const\",\n-                ItemFn(..) => \"fn\",\n-                ItemMod(..) => \"mod\",\n-                ItemForeignMod(..) => \"foreign mod\",\n-                ItemGlobalAsm(..) => \"global asm\",\n-                ItemTy(..) => \"ty\",\n-                ItemExistential(..) => \"existential\",\n-                ItemEnum(..) => \"enum\",\n-                ItemStruct(..) => \"struct\",\n-                ItemUnion(..) => \"union\",\n-                ItemTrait(..) => \"trait\",\n-                ItemTraitAlias(..) => \"trait alias\",\n-                ItemImpl(..) => \"impl\",\n+                ItemKind::ExternCrate(..) => \"extern crate\",\n+                ItemKind::Use(..) => \"use\",\n+                ItemKind::Static(..) => \"static\",\n+                ItemKind::Const(..) => \"const\",\n+                ItemKind::Fn(..) => \"fn\",\n+                ItemKind::Mod(..) => \"mod\",\n+                ItemKind::ForeignMod(..) => \"foreign mod\",\n+                ItemKind::GlobalAsm(..) => \"global asm\",\n+                ItemKind::Ty(..) => \"ty\",\n+                ItemKind::Existential(..) => \"existential\",\n+                ItemKind::Enum(..) => \"enum\",\n+                ItemKind::Struct(..) => \"struct\",\n+                ItemKind::Union(..) => \"union\",\n+                ItemKind::Trait(..) => \"trait\",\n+                ItemKind::TraitAlias(..) => \"trait alias\",\n+                ItemKind::Impl(..) => \"impl\",\n             };\n             format!(\"{} {}{}\", item_str, path_str(), id_str)\n         }"}, {"sha": "c1a885d80bf8b0e1f11c9ad3ab6e1ca8b2af503f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -13,7 +13,6 @@\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n pub use self::FunctionRetTy::*;\n-pub use self::Item_::*;\n pub use self::Mutability::*;\n pub use self::PrimTy::*;\n pub use self::UnOp::*;\n@@ -2040,7 +2039,7 @@ pub struct Item {\n     pub id: NodeId,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n-    pub node: Item_,\n+    pub node: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n }\n@@ -2054,96 +2053,96 @@ pub struct FnHeader {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub enum Item_ {\n+pub enum ItemKind {\n     /// An `extern crate` item, with optional *original* crate name if the crate was renamed.\n     ///\n     /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n-    ItemExternCrate(Option<Name>),\n+    ExternCrate(Option<Name>),\n \n     /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n     ///\n     /// or just\n     ///\n     /// `use foo::bar::baz;` (with `as baz` implicitly on the right)\n-    ItemUse(P<Path>, UseKind),\n+    Use(P<Path>, UseKind),\n \n     /// A `static` item\n-    ItemStatic(P<Ty>, Mutability, BodyId),\n+    Static(P<Ty>, Mutability, BodyId),\n     /// A `const` item\n-    ItemConst(P<Ty>, BodyId),\n+    Const(P<Ty>, BodyId),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, FnHeader, Generics, BodyId),\n+    Fn(P<FnDecl>, FnHeader, Generics, BodyId),\n     /// A module\n-    ItemMod(Mod),\n+    Mod(Mod),\n     /// An external module\n-    ItemForeignMod(ForeignMod),\n+    ForeignMod(ForeignMod),\n     /// Module-level inline assembly (from global_asm!)\n-    ItemGlobalAsm(P<GlobalAsm>),\n+    GlobalAsm(P<GlobalAsm>),\n     /// A type alias, e.g. `type Foo = Bar<u8>`\n-    ItemTy(P<Ty>, Generics),\n+    Ty(P<Ty>, Generics),\n     /// A type alias, e.g. `type Foo = Bar<u8>`\n-    ItemExistential(ExistTy),\n+    Existential(ExistTy),\n     /// An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n-    ItemEnum(EnumDef, Generics),\n+    Enum(EnumDef, Generics),\n     /// A struct definition, e.g. `struct Foo<A> {x: A}`\n-    ItemStruct(VariantData, Generics),\n+    Struct(VariantData, Generics),\n     /// A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n-    ItemUnion(VariantData, Generics),\n+    Union(VariantData, Generics),\n     /// Represents a Trait Declaration\n-    ItemTrait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n+    Trait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n     /// Represents a Trait Alias Declaration\n-    ItemTraitAlias(Generics, GenericBounds),\n+    TraitAlias(Generics, GenericBounds),\n \n     /// An implementation, eg `impl<A> Trait for Foo { .. }`\n-    ItemImpl(Unsafety,\n-             ImplPolarity,\n-             Defaultness,\n-             Generics,\n-             Option<TraitRef>, // (optional) trait this impl implements\n-             P<Ty>, // self\n-             HirVec<ImplItemRef>),\n+    Impl(Unsafety,\n+         ImplPolarity,\n+         Defaultness,\n+         Generics,\n+         Option<TraitRef>, // (optional) trait this impl implements\n+         P<Ty>, // self\n+         HirVec<ImplItemRef>),\n }\n \n-impl Item_ {\n+impl ItemKind {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n-            ItemExternCrate(..) => \"extern crate\",\n-            ItemUse(..) => \"use\",\n-            ItemStatic(..) => \"static item\",\n-            ItemConst(..) => \"constant item\",\n-            ItemFn(..) => \"function\",\n-            ItemMod(..) => \"module\",\n-            ItemForeignMod(..) => \"foreign module\",\n-            ItemGlobalAsm(..) => \"global asm\",\n-            ItemTy(..) => \"type alias\",\n-            ItemExistential(..) => \"existential type\",\n-            ItemEnum(..) => \"enum\",\n-            ItemStruct(..) => \"struct\",\n-            ItemUnion(..) => \"union\",\n-            ItemTrait(..) => \"trait\",\n-            ItemTraitAlias(..) => \"trait alias\",\n-            ItemImpl(..) => \"item\",\n+            ItemKind::ExternCrate(..) => \"extern crate\",\n+            ItemKind::Use(..) => \"use\",\n+            ItemKind::Static(..) => \"static item\",\n+            ItemKind::Const(..) => \"constant item\",\n+            ItemKind::Fn(..) => \"function\",\n+            ItemKind::Mod(..) => \"module\",\n+            ItemKind::ForeignMod(..) => \"foreign module\",\n+            ItemKind::GlobalAsm(..) => \"global asm\",\n+            ItemKind::Ty(..) => \"type alias\",\n+            ItemKind::Existential(..) => \"existential type\",\n+            ItemKind::Enum(..) => \"enum\",\n+            ItemKind::Struct(..) => \"struct\",\n+            ItemKind::Union(..) => \"union\",\n+            ItemKind::Trait(..) => \"trait\",\n+            ItemKind::TraitAlias(..) => \"trait alias\",\n+            ItemKind::Impl(..) => \"item\",\n         }\n     }\n \n     pub fn adt_kind(&self) -> Option<AdtKind> {\n         match *self {\n-            ItemStruct(..) => Some(AdtKind::Struct),\n-            ItemUnion(..) => Some(AdtKind::Union),\n-            ItemEnum(..) => Some(AdtKind::Enum),\n+            ItemKind::Struct(..) => Some(AdtKind::Struct),\n+            ItemKind::Union(..) => Some(AdtKind::Union),\n+            ItemKind::Enum(..) => Some(AdtKind::Enum),\n             _ => None,\n         }\n     }\n \n     pub fn generics(&self) -> Option<&Generics> {\n         Some(match *self {\n-            ItemFn(_, _, ref generics, _) |\n-            ItemTy(_, ref generics) |\n-            ItemEnum(_, ref generics) |\n-            ItemStruct(_, ref generics) |\n-            ItemUnion(_, ref generics) |\n-            ItemTrait(_, _, ref generics, _, _) |\n-            ItemImpl(_, _, _, ref generics, _, _, _)=> generics,\n+            ItemKind::Fn(_, _, ref generics, _) |\n+            ItemKind::Ty(_, ref generics) |\n+            ItemKind::Enum(_, ref generics) |\n+            ItemKind::Struct(_, ref generics) |\n+            ItemKind::Union(_, ref generics) |\n+            ItemKind::Trait(_, _, ref generics, _, _) |\n+            ItemKind::Impl(_, _, _, ref generics, _, _, _)=> generics,\n             _ => return None\n         })\n     }"}, {"sha": "e637a18d1cd0a2af9ad998c906f7ade6b87805cd", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -531,7 +531,7 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&item.attrs)?;\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n-            hir::ItemExternCrate(orig_name) => {\n+            hir::ItemKind::ExternCrate(orig_name) => {\n                 self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(orig_name) = orig_name {\n                     self.print_name(orig_name)?;\n@@ -544,7 +544,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n-            hir::ItemUse(ref path, kind) => {\n+            hir::ItemKind::Use(ref path, kind) => {\n                 self.head(&visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_path(path, false)?;\n \n@@ -563,7 +563,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n-            hir::ItemStatic(ref ty, m, expr) => {\n+            hir::ItemKind::Static(ref ty, m, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n@@ -579,7 +579,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemConst(ref ty, expr) => {\n+            hir::ItemKind::Const(ref ty, expr) => {\n                 self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n@@ -592,7 +592,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            hir::ItemFn(ref decl, header, ref typarams, body) => {\n+            hir::ItemKind::Fn(ref decl, header, ref typarams, body) => {\n                 self.head(\"\")?;\n                 self.print_fn(decl,\n                               header,\n@@ -606,27 +606,27 @@ impl<'a> State<'a> {\n                 self.end()?; // need to close a box\n                 self.ann.nested(self, Nested::Body(body))?;\n             }\n-            hir::ItemMod(ref _mod) => {\n+            hir::ItemKind::Mod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_name(item.name)?;\n                 self.nbsp()?;\n                 self.bopen()?;\n                 self.print_mod(_mod, &item.attrs)?;\n                 self.bclose(item.span)?;\n             }\n-            hir::ItemForeignMod(ref nmod) => {\n+            hir::ItemKind::ForeignMod(ref nmod) => {\n                 self.head(\"extern\")?;\n                 self.word_nbsp(&nmod.abi.to_string())?;\n                 self.bopen()?;\n                 self.print_foreign_mod(nmod, &item.attrs)?;\n                 self.bclose(item.span)?;\n             }\n-            hir::ItemGlobalAsm(ref ga) => {\n+            hir::ItemKind::GlobalAsm(ref ga) => {\n                 self.head(&visibility_qualified(&item.vis, \"global asm\"))?;\n                 self.s.word(&ga.asm.as_str())?;\n                 self.end()?\n             }\n-            hir::ItemTy(ref ty, ref generics) => {\n+            hir::ItemKind::Ty(ref ty, ref generics) => {\n                 self.ibox(indent_unit)?;\n                 self.ibox(0)?;\n                 self.word_nbsp(&visibility_qualified(&item.vis, \"type\"))?;\n@@ -641,7 +641,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n-            hir::ItemExistential(ref exist) => {\n+            hir::ItemKind::Existential(ref exist) => {\n                 self.ibox(indent_unit)?;\n                 self.ibox(0)?;\n                 self.word_nbsp(&visibility_qualified(&item.vis, \"existential type\"))?;\n@@ -666,18 +666,18 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer ibox\n             }\n-            hir::ItemEnum(ref enum_definition, ref params) => {\n+            hir::ItemKind::Enum(ref enum_definition, ref params) => {\n                 self.print_enum_def(enum_definition, params, item.name, item.span, &item.vis)?;\n             }\n-            hir::ItemStruct(ref struct_def, ref generics) => {\n+            hir::ItemKind::Struct(ref struct_def, ref generics) => {\n                 self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n-            hir::ItemUnion(ref struct_def, ref generics) => {\n+            hir::ItemKind::Union(ref struct_def, ref generics) => {\n                 self.head(&visibility_qualified(&item.vis, \"union\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n-            hir::ItemImpl(unsafety,\n+            hir::ItemKind::Impl(unsafety,\n                           polarity,\n                           defaultness,\n                           ref generics,\n@@ -722,7 +722,7 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span)?;\n             }\n-            hir::ItemTrait(is_auto, unsafety, ref generics, ref bounds, ref trait_items) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref trait_items) => {\n                 self.head(\"\")?;\n                 self.print_visibility(&item.vis)?;\n                 self.print_is_auto(is_auto)?;\n@@ -749,7 +749,7 @@ impl<'a> State<'a> {\n                 }\n                 self.bclose(item.span)?;\n             }\n-            hir::ItemTraitAlias(ref generics, ref bounds) => {\n+            hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n                 self.head(\"\")?;\n                 self.print_visibility(&item.vis)?;\n                 self.word_nbsp(\"trait\")?;"}, {"sha": "d1fb05ceafbfd28d62adc55103f2b467516b46e2", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -847,23 +847,23 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {\n     }\n }\n \n-impl_stable_hash_for!(enum hir::Item_ {\n-    ItemExternCrate(orig_name),\n-    ItemUse(path, use_kind),\n-    ItemStatic(ty, mutability, body_id),\n-    ItemConst(ty, body_id),\n-    ItemFn(fn_decl, header, generics, body_id),\n-    ItemMod(module),\n-    ItemForeignMod(foreign_mod),\n-    ItemGlobalAsm(global_asm),\n-    ItemTy(ty, generics),\n-    ItemExistential(exist),\n-    ItemEnum(enum_def, generics),\n-    ItemStruct(variant_data, generics),\n-    ItemUnion(variant_data, generics),\n-    ItemTrait(is_auto, unsafety, generics, bounds, item_refs),\n-    ItemTraitAlias(generics, bounds),\n-    ItemImpl(unsafety, impl_polarity, impl_defaultness, generics, trait_ref, ty, impl_item_refs)\n+impl_stable_hash_for!(enum hir::ItemKind {\n+    ExternCrate(orig_name),\n+    Use(path, use_kind),\n+    Static(ty, mutability, body_id),\n+    Const(ty, body_id),\n+    Fn(fn_decl, header, generics, body_id),\n+    Mod(module),\n+    ForeignMod(foreign_mod),\n+    GlobalAsm(global_asm),\n+    Ty(ty, generics),\n+    Existential(exist),\n+    Enum(enum_def, generics),\n+    Struct(variant_data, generics),\n+    Union(variant_data, generics),\n+    Trait(is_auto, unsafety, generics, bounds, item_refs),\n+    TraitAlias(generics, bounds),\n+    Impl(unsafety, impl_polarity, impl_defaultness, generics, trait_ref, ty, impl_item_refs)\n });\n \n impl_stable_hash_for!(struct hir::TraitItemRef {"}, {"sha": "2924016670bf8377b3d4af5b0a7506b46d9318d9", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -691,7 +691,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                     // ```\n                     if let Some(anon_node_id) = tcx.hir.as_local_node_id(def_id) {\n                         let anon_parent_def_id = match tcx.hir.expect_item(anon_node_id).node {\n-                            hir::ItemExistential(hir::ExistTy {\n+                            hir::ItemKind::Existential(hir::ExistTy {\n                                 impl_trait_fn: Some(parent),\n                                 ..\n                             }) => parent,"}, {"sha": "8da0dc365b04e0d1edded2db941b6908f12ae292", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -259,12 +259,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     fn item_scope_tag(item: &hir::Item) -> &'static str {\n         match item.node {\n-            hir::ItemImpl(..) => \"impl\",\n-            hir::ItemStruct(..) => \"struct\",\n-            hir::ItemUnion(..) => \"union\",\n-            hir::ItemEnum(..) => \"enum\",\n-            hir::ItemTrait(..) => \"trait\",\n-            hir::ItemFn(..) => \"function body\",\n+            hir::ItemKind::Impl(..) => \"impl\",\n+            hir::ItemKind::Struct(..) => \"struct\",\n+            hir::ItemKind::Union(..) => \"union\",\n+            hir::ItemKind::Enum(..) => \"enum\",\n+            hir::ItemKind::Trait(..) => \"trait\",\n+            hir::ItemKind::Fn(..) => \"function body\",\n             _ => \"item\",\n         }\n     }"}, {"sha": "21be09b0ba193f0d30e7e42b89cb8776aa948a47", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let fndecl = match self.tcx.hir.get(node_id) {\n                     hir_map::NodeItem(&hir::Item {\n-                        node: hir::ItemFn(ref fndecl, ..),\n+                        node: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n                     }) => &fndecl,\n                     hir_map::NodeTraitItem(&hir::TraitItem {"}, {"sha": "da59bced760d405b06d163f40141a210f013a4fc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -153,21 +153,21 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         match *node {\n             hir_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemStruct(..) | hir::ItemUnion(..) => {\n+                    hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n                         let def = self.tcx.adt_def(def_id);\n                         self.repr_has_repr_c = def.repr.c();\n \n                         intravisit::walk_item(self, &item);\n                     }\n-                    hir::ItemEnum(..) => {\n+                    hir::ItemKind::Enum(..) => {\n                         self.inherited_pub_visibility = item.vis.node.is_pub();\n                         intravisit::walk_item(self, &item);\n                     }\n-                    hir::ItemFn(..)\n-                    | hir::ItemTy(..)\n-                    | hir::ItemStatic(..)\n-                    | hir::ItemConst(..) => {\n+                    hir::ItemKind::Fn(..)\n+                    | hir::ItemKind::Ty(..)\n+                    | hir::ItemKind::Static(..)\n+                    | hir::ItemKind::Const(..) => {\n                         intravisit::walk_item(self, &item);\n                     }\n                     _ => ()\n@@ -349,11 +349,11 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n             self.worklist.push(item.id);\n         }\n         match item.node {\n-            hir::ItemEnum(ref enum_def, _) if allow_dead_code => {\n+            hir::ItemKind::Enum(ref enum_def, _) if allow_dead_code => {\n                 self.worklist.extend(enum_def.variants.iter()\n                                                       .map(|variant| variant.node.data.id()));\n             }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n                     let trait_item = self.krate.trait_item(trait_item_ref.id);\n                     match trait_item.node {\n@@ -369,7 +369,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., ref opt_trait, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref opt_trait, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     let impl_item = self.krate.impl_item(impl_item_ref.id);\n                     if opt_trait.is_some() ||\n@@ -439,7 +439,7 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n     match item.node {\n-        hir::ItemStruct(ref struct_def, _) if !struct_def.is_struct() => {\n+        hir::ItemKind::Struct(ref struct_def, _) if !struct_def.is_struct() => {\n             Some(struct_def.id())\n         }\n         _ => None\n@@ -454,13 +454,13 @@ struct DeadVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n     fn should_warn_about_item(&mut self, item: &hir::Item) -> bool {\n         let should_warn = match item.node {\n-            hir::ItemStatic(..)\n-            | hir::ItemConst(..)\n-            | hir::ItemFn(..)\n-            | hir::ItemTy(..)\n-            | hir::ItemEnum(..)\n-            | hir::ItemStruct(..)\n-            | hir::ItemUnion(..) => true,\n+            hir::ItemKind::Static(..)\n+            | hir::ItemKind::Const(..)\n+            | hir::ItemKind::Fn(..)\n+            | hir::ItemKind::Ty(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Union(..) => true,\n             _ => false\n         };\n         let ctor_id = get_struct_ctor_id(item);\n@@ -554,13 +554,13 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n             // For items that have a definition with a signature followed by a\n             // block, point only at the signature.\n             let span = match item.node {\n-                hir::ItemFn(..) |\n-                hir::ItemMod(..) |\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemTrait(..) |\n-                hir::ItemImpl(..) => self.tcx.sess.codemap().def_span(item.span),\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::Mod(..) |\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Trait(..) |\n+                hir::ItemKind::Impl(..) => self.tcx.sess.codemap().def_span(item.span),\n                 _ => item.span,\n             };\n             self.warn_dead_code("}, {"sha": "feeb508d676c94e726a119e9e3f045de07c602a8", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -16,7 +16,7 @@ use syntax::ast::NodeId;\n use syntax::attr;\n use syntax::entry::EntryPointType;\n use syntax_pos::Span;\n-use hir::{Item, ItemFn, ImplItem, TraitItem};\n+use hir::{Item, ItemKind, ImplItem, TraitItem};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n struct EntryContext<'a, 'tcx: 'a> {\n@@ -91,7 +91,7 @@ pub fn find_entry_point(session: &Session,\n // them in sync.\n fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n     match item.node {\n-        ItemFn(..) => {\n+        ItemKind::Fn(..) => {\n             if attr::contains_name(&item.attrs, \"start\") {\n                 EntryPointType::Start\n             } else if attr::contains_name(&item.attrs, \"main\") {"}, {"sha": "13b1660a7d56ed05d5f0e8068179a99776f0fb1e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -58,8 +58,8 @@ fn item_might_be_inlined(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     match item.node {\n-        hir::ItemImpl(..) |\n-        hir::ItemFn(..) => {\n+        hir::ItemKind::Impl(..) |\n+        hir::ItemKind::Fn(..) => {\n             let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n             generics_require_inlining(generics)\n         }\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match self.tcx.hir.find(node_id) {\n             Some(hir_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(..) =>\n+                    hir::ItemKind::Fn(..) =>\n                         item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             // does too.\n                             let impl_node_id = self.tcx.hir.as_local_node_id(impl_did).unwrap();\n                             match self.tcx.hir.expect_item(impl_node_id).node {\n-                                hir::ItemImpl(..) => {\n+                                hir::ItemKind::Impl(..) => {\n                                     let generics = self.tcx.generics_of(impl_did);\n                                     generics_require_inlining(&generics)\n                                 }\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n             if let hir_map::NodeItem(item) = *node {\n-                let reachable = if let hir::ItemFn(_, header, ..) = item.node {\n+                let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.node {\n                     header.abi != Abi::Rust\n                 } else {\n                     false\n@@ -260,7 +260,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             hir_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemFn(.., body) => {\n+                    hir::ItemKind::Fn(.., body) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n                         if item_might_be_inlined(self.tcx,\n                                                  &item,\n@@ -272,20 +272,20 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // Reachable constants will be inlined into other crates\n                     // unconditionally, so we need to make sure that their\n                     // contents are also reachable.\n-                    hir::ItemConst(_, init) => {\n+                    hir::ItemKind::Const(_, init) => {\n                         self.visit_nested_body(init);\n                     }\n \n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    hir::ItemExternCrate(_) | hir::ItemUse(..) |\n-                    hir::ItemExistential(..) |\n-                    hir::ItemTy(..) | hir::ItemStatic(..) |\n-                    hir::ItemMod(..) | hir::ItemForeignMod(..) |\n-                    hir::ItemImpl(..) | hir::ItemTrait(..) | hir::ItemTraitAlias(..) |\n-                    hir::ItemStruct(..) | hir::ItemEnum(..) |\n-                    hir::ItemUnion(..) |  hir::ItemGlobalAsm(..) => {}\n+                    hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) |\n+                    hir::ItemKind::Existential(..) |\n+                    hir::ItemKind::Ty(..) | hir::ItemKind::Static(..) |\n+                    hir::ItemKind::Mod(..) | hir::ItemKind::ForeignMod(..) |\n+                    hir::ItemKind::Impl(..) | hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) |\n+                    hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) |\n+                    hir::ItemKind::Union(..) |  hir::ItemKind::GlobalAsm(..) => {}\n                 }\n             }\n             hir_map::NodeTraitItem(trait_method) => {\n@@ -356,7 +356,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n         }\n \n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n+        if let hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n             if !self.access_levels.is_reachable(item.id) {\n                 for impl_item_ref in impl_item_refs {\n                     self.worklist.push(impl_item_ref.id.node_id);"}, {"sha": "7953774856fa04fe36fce435a4ac49458bdd0ea5", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -476,49 +476,49 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemFn(ref decl, _, ref generics, _) => {\n+            hir::ItemKind::Fn(ref decl, _, ref generics, _) => {\n                 self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n \n-            hir::ItemExternCrate(_)\n-            | hir::ItemUse(..)\n-            | hir::ItemMod(..)\n-            | hir::ItemForeignMod(..)\n-            | hir::ItemGlobalAsm(..) => {\n+            hir::ItemKind::ExternCrate(_)\n+            | hir::ItemKind::Use(..)\n+            | hir::ItemKind::Mod(..)\n+            | hir::ItemKind::ForeignMod(..)\n+            | hir::ItemKind::GlobalAsm(..) => {\n                 // These sorts of items have no lifetime parameters at all.\n                 intravisit::walk_item(self, item);\n             }\n-            hir::ItemStatic(..) | hir::ItemConst(..) => {\n+            hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => {\n                 // No lifetime parameters, but implied 'static.\n                 let scope = Scope::Elision {\n                     elide: Elide::Exact(Region::Static),\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemExistential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n+            hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n                 // currently existential type declarations are just generated from impl Trait\n                 // items. doing anything on this node is irrelevant, as we currently don't need\n                 // it.\n             }\n-            hir::ItemTy(_, ref generics)\n-            | hir::ItemExistential(hir::ExistTy { impl_trait_fn: None, ref generics, .. })\n-            | hir::ItemEnum(_, ref generics)\n-            | hir::ItemStruct(_, ref generics)\n-            | hir::ItemUnion(_, ref generics)\n-            | hir::ItemTrait(_, _, ref generics, ..)\n-            | hir::ItemTraitAlias(ref generics, ..)\n-            | hir::ItemImpl(_, _, _, ref generics, ..) => {\n+            hir::ItemKind::Ty(_, ref generics)\n+            | hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: None, ref generics, .. })\n+            | hir::ItemKind::Enum(_, ref generics)\n+            | hir::ItemKind::Struct(_, ref generics)\n+            | hir::ItemKind::Union(_, ref generics)\n+            | hir::ItemKind::Trait(_, _, ref generics, ..)\n+            | hir::ItemKind::TraitAlias(ref generics, ..)\n+            | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n                 // Impls permit `'_` to be used and it is equivalent to \"some fresh lifetime name\".\n                 // This is not true for other kinds of items.x\n                 let track_lifetime_uses = match item.node {\n-                    hir::ItemImpl(..) => true,\n+                    hir::ItemKind::Impl(..) => true,\n                     _ => false,\n                 };\n                 // These kinds of items have only early bound lifetime parameters.\n-                let mut index = if let hir::ItemTrait(..) = item.node {\n+                let mut index = if let hir::ItemKind::Trait(..) = item.node {\n                     1 // Self comes before lifetimes\n                 } else {\n                     0\n@@ -675,7 +675,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     //                          ^            ^ this gets resolved in the scope of\n                     //                                         the exist_ty generics\n                     let (generics, bounds) = match self.tcx.hir.expect_item(id).node {\n-                        hir::ItemExistential(hir::ExistTy{ ref generics, ref bounds, .. }) => (\n+                        hir::ItemKind::Existential(hir::ExistTy{ ref generics, ref bounds, .. }) => (\n                             generics,\n                             bounds,\n                         ),\n@@ -1208,11 +1208,11 @@ fn compute_object_lifetime_defaults(\n     let mut map = NodeMap();\n     for item in tcx.hir.krate().items.values() {\n         match item.node {\n-            hir::ItemStruct(_, ref generics)\n-            | hir::ItemUnion(_, ref generics)\n-            | hir::ItemEnum(_, ref generics)\n-            | hir::ItemTy(_, ref generics)\n-            | hir::ItemTrait(_, _, ref generics, ..) => {\n+            hir::ItemKind::Struct(_, ref generics)\n+            | hir::ItemKind::Union(_, ref generics)\n+            | hir::ItemKind::Enum(_, ref generics)\n+            | hir::ItemKind::Ty(_, ref generics)\n+            | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n \n                 // Debugging aid.\n@@ -1485,12 +1485,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut index = 0;\n         if let Some(parent_id) = parent_id {\n             let parent = self.tcx.hir.expect_item(parent_id);\n-            if let hir::ItemTrait(..) = parent.node {\n+            if let hir::ItemKind::Trait(..) = parent.node {\n                 index += 1; // Self comes first.\n             }\n             match parent.node {\n-                hir::ItemTrait(_, _, ref generics, ..)\n-                | hir::ItemImpl(_, _, _, ref generics, ..) => {\n+                hir::ItemKind::Trait(_, _, ref generics, ..)\n+                | hir::ItemKind::Impl(_, _, _, ref generics, ..) => {\n                     index += generics.params.len() as u32;\n                 }\n                 _ => {}\n@@ -1609,7 +1609,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 let fn_id = self.tcx.hir.body_owner(body_id);\n                 match self.tcx.hir.get(fn_id) {\n                     hir::map::NodeItem(&hir::Item {\n-                        node: hir::ItemFn(..),\n+                        node: hir::ItemKind::Fn(..),\n                         ..\n                     })\n                     | hir::map::NodeTraitItem(&hir::TraitItem {\n@@ -1834,7 +1834,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let body = match self.tcx.hir.get(parent) {\n             // `fn` definitions and methods.\n             hir::map::NodeItem(&hir::Item {\n-                node: hir::ItemFn(.., body),\n+                node: hir::ItemKind::Fn(.., body),\n                 ..\n             }) => Some(body),\n \n@@ -1847,7 +1847,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n-                    hir::ItemTrait(.., ref trait_items) => {\n+                    hir::ItemKind::Trait(.., ref trait_items) => {\n                         assoc_item_kind = trait_items\n                             .iter()\n                             .find(|ti| ti.id.node_id == parent)\n@@ -1870,7 +1870,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     .expect_item(self.tcx.hir.get_parent(parent))\n                     .node\n                 {\n-                    hir::ItemImpl(.., ref self_ty, ref impl_items) => {\n+                    hir::ItemKind::Impl(.., ref self_ty, ref impl_items) => {\n                         impl_self = Some(self_ty);\n                         assoc_item_kind = impl_items\n                             .iter()"}, {"sha": "fdcae38fc6a7cfd6e1ad082390ac273b80c70c75", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -263,14 +263,14 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemImpl(.., None, _, _) | hir::ItemForeignMod(..) => {\n+            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {\n                 self.in_trait_impl = false;\n                 kind = AnnotationKind::Container;\n             }\n-            hir::ItemImpl(.., Some(_), _, _) => {\n+            hir::ItemKind::Impl(.., Some(_), _, _) => {\n                 self.in_trait_impl = true;\n             }\n-            hir::ItemStruct(ref sd, _) => {\n+            hir::ItemKind::Struct(ref sd, _) => {\n                 if !sd.is_struct() {\n                     self.annotate(sd.id(), &i.attrs, i.span, AnnotationKind::Required, |_| {})\n                 }\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n             // they don't have their own stability. They still can be annotated as unstable\n             // and propagate this unstability to children, but this annotation is completely\n             // optional. They inherit stability from their parents when unannotated.\n-            hir::ItemImpl(.., None, _, _) | hir::ItemForeignMod(..) => {}\n+            hir::ItemKind::Impl(.., None, _, _) | hir::ItemKind::ForeignMod(..) => {}\n \n             _ => self.check_missing_stability(i.id, i.span)\n         }\n@@ -723,7 +723,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemExternCrate(_) => {\n+            hir::ItemKind::ExternCrate(_) => {\n                 // compiler-generated `extern crate` items have a dummy span.\n                 if item.span.is_dummy() { return }\n \n@@ -739,7 +739,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             // For implementations of traits, check the stability of each item\n             // individually as it's possible to have a stable trait with unstable\n             // items.\n-            hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., Some(ref t), _, ref impl_item_refs) => {\n                 if let Def::Trait(trait_did) = t.path.def {\n                     for impl_item_ref in impl_item_refs {\n                         let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n             // There's no good place to insert stability check for non-Copy unions,\n             // so semi-randomly perform it here in stability.rs\n-            hir::ItemUnion(..) if !self.tcx.features().untagged_unions => {\n+            hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);"}, {"sha": "df26ac670601c529f7d635dd51c62e80bc149acd", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -955,7 +955,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             hir::map::NodeItem(&hir::Item {\n                 span,\n-                node: hir::ItemFn(ref decl, ..),\n+                node: hir::ItemKind::Fn(ref decl, ..),\n                 ..\n             }) |\n             hir::map::NodeImplItem(&hir::ImplItem {"}, {"sha": "875c7199f6d11830e1179b19ad5b7afc0db0dced", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -534,7 +534,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.hir.as_local_node_id(node_item_def_id) {\n             Some(node_id) => {\n                 let item = self.hir.expect_item(node_id);\n-                if let hir::ItemImpl(_, _, defaultness, ..) = item.node {\n+                if let hir::ItemKind::Impl(_, _, defaultness, ..) = item.node {\n                     defaultness.is_default()\n                 } else {\n                     false"}, {"sha": "5aa6542a027da1996539e32fb9ba87dbe76e6e49", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -2757,7 +2757,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n     let parent_def_id = tcx.hir.local_def_id(parent_id);\n     let parent_item = tcx.hir.expect_item(parent_id);\n     match parent_item.node {\n-        hir::ItemImpl(.., ref impl_item_refs) => {\n+        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             if let Some(impl_item_ref) = impl_item_refs.iter().find(|i| i.id.node_id == id) {\n                 let assoc_item = tcx.associated_item_from_impl_item_ref(parent_def_id,\n                                                                         impl_item_ref);\n@@ -2766,7 +2766,7 @@ fn associated_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n             }\n         }\n \n-        hir::ItemTrait(.., ref trait_item_refs) => {\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.node_id == id) {\n                 let assoc_item = tcx.associated_item_from_trait_item_ref(parent_def_id,\n                                                                          &parent_item.vis,\n@@ -2815,19 +2815,19 @@ fn associated_item_def_ids<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n     let item = tcx.hir.expect_item(id);\n     let vec: Vec<_> = match item.node {\n-        hir::ItemTrait(.., ref trait_item_refs) => {\n+        hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             trait_item_refs.iter()\n                            .map(|trait_item_ref| trait_item_ref.id)\n                            .map(|id| tcx.hir.local_def_id(id.node_id))\n                            .collect()\n         }\n-        hir::ItemImpl(.., ref impl_item_refs) => {\n+        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n             impl_item_refs.iter()\n                           .map(|impl_item_ref| impl_item_ref.id)\n                           .map(|id| tcx.hir.local_def_id(id.node_id))\n                           .collect()\n         }\n-        hir::ItemTraitAlias(..) => vec![],\n+        hir::ItemKind::TraitAlias(..) => vec![],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\")\n     };\n     Lrc::new(vec)"}, {"sha": "d5425aff6ba69c09664fefc20c9b6ccde9e16340", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -605,7 +605,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(node) = self.hir.get_if_local(def_id) {\n             match node {\n                 Node::NodeItem(&hir::Item {\n-                    node: hir::ItemStatic(_, mutbl, _), ..\n+                    node: hir::ItemKind::Static(_, mutbl, _), ..\n                 }) => Some(mutbl),\n                 Node::NodeForeignItem(&hir::ForeignItem {\n                     node: hir::ForeignItemKind::Static(_, is_mutbl), .."}, {"sha": "94357f348497d96c3edd11f480f165475d95659c", "filename": "src/librustc_codegen_llvm/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -105,11 +105,11 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n                 // Only consider nodes that actually have exported symbols.\n                 hir::map::NodeItem(&hir::Item {\n-                    node: hir::ItemStatic(..),\n+                    node: hir::ItemKind::Static(..),\n                     ..\n                 }) |\n                 hir::map::NodeItem(&hir::Item {\n-                    node: hir::ItemFn(..), ..\n+                    node: hir::ItemKind::Fn(..), ..\n                 }) |\n                 hir::map::NodeImplItem(&hir::ImplItem {\n                     node: hir::ImplItemKind::Method(..),"}, {"sha": "6e3096d4cd5ba75ff74494cb6fc65786284d72f5", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -125,7 +125,7 @@ pub fn get_static(cx: &CodegenCx, def_id: DefId) -> ValueRef {\n         let llty = cx.layout_of(ty).llvm_type(cx);\n         let (g, attrs) = match cx.tcx.hir.get(id) {\n             hir_map::NodeItem(&hir::Item {\n-                ref attrs, span, node: hir::ItemStatic(..), ..\n+                ref attrs, span, node: hir::ItemKind::Static(..), ..\n             }) => {\n                 if declare::get_declared_value(cx, &sym[..]).is_some() {\n                     span_bug!(span, \"Conflicting symbol names for static?\");"}, {"sha": "b512a6f1bb4b0faec4afc0ced337dc734d72905f", "filename": "src/librustc_codegen_llvm/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_codegen_llvm%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmono_item.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -60,7 +60,7 @@ pub trait MonoItemExt<'a, 'tcx>: fmt::Debug + BaseMonoItemExt<'a, 'tcx> {\n             }\n             MonoItem::GlobalAsm(node_id) => {\n                 let item = cx.tcx.hir.expect_item(node_id);\n-                if let hir::ItemGlobalAsm(ref ga) = item.node {\n+                if let hir::ItemKind::GlobalAsm(ref ga) = item.node {\n                     asm::codegen_global_asm(cx, ga);\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and MonoItem type\")"}, {"sha": "f082d03234ac7fd71596865a8c65ff39c8c92013", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -249,24 +249,24 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n             }\n \n             return match it.node {\n-                hir::ItemUse(..) |\n-                hir::ItemExternCrate(..) |\n-                hir::ItemConst(..) |\n-                hir::ItemStatic(..) |\n-                hir::ItemFn(..) |\n-                hir::ItemForeignMod(..) |\n-                hir::ItemGlobalAsm(..) |\n-                hir::ItemExistential(..) |\n-                hir::ItemTy(..) => None,\n-\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemTrait(..) |\n-                hir::ItemTraitAlias(..) |\n-                hir::ItemImpl(..) => None,\n-\n-                hir::ItemMod(ref m) => search_mod(this, m, idx, names),\n+                hir::ItemKind::Use(..) |\n+                hir::ItemKind::ExternCrate(..) |\n+                hir::ItemKind::Const(..) |\n+                hir::ItemKind::Static(..) |\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::ForeignMod(..) |\n+                hir::ItemKind::GlobalAsm(..) |\n+                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::Ty(..) => None,\n+\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Trait(..) |\n+                hir::ItemKind::TraitAlias(..) |\n+                hir::ItemKind::Impl(..) => None,\n+\n+                hir::ItemKind::Mod(ref m) => search_mod(this, m, idx, names),\n             };\n         }\n     }"}, {"sha": "51409a0d28352c5261bec7f7779959d3793e5cdc", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -29,7 +29,7 @@ use std::iter::FromIterator;\n use std::vec::Vec;\n use rustc::dep_graph::{DepNode, label_strs};\n use rustc::hir;\n-use rustc::hir::{Item_ as HirItem, ImplItemKind, TraitItemKind};\n+use rustc::hir::{ItemKind as HirItem, ImplItemKind, TraitItemKind};\n use rustc::hir::map::Node as HirNode;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -342,40 +342,40 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     // FIXME(michaelwoerister): do commented out ones\n \n                     // // An `extern crate` item, with optional original crate name,\n-                    // HirItem::ItemExternCrate(..),  // intentionally no assertions\n+                    // HirItem::ExternCrate(..),  // intentionally no assertions\n \n                     // // `use foo::bar::*;` or `use foo::bar::baz as quux;`\n-                    // HirItem::ItemUse(..),  // intentionally no assertions\n+                    // HirItem::Use(..),  // intentionally no assertions\n \n                     // A `static` item\n-                    HirItem::ItemStatic(..) => (\"ItemStatic\", LABELS_CONST),\n+                    HirItem::Static(..) => (\"ItemStatic\", LABELS_CONST),\n \n                     // A `const` item\n-                    HirItem::ItemConst(..) => (\"ItemConst\", LABELS_CONST),\n+                    HirItem::Const(..) => (\"ItemConst\", LABELS_CONST),\n \n                     // A function declaration\n-                    HirItem::ItemFn(..) => (\"ItemFn\", LABELS_FN),\n+                    HirItem::Fn(..) => (\"ItemFn\", LABELS_FN),\n \n                     // // A module\n-                    HirItem::ItemMod(..) =>(\"ItemMod\", LABELS_HIR_ONLY),\n+                    HirItem::Mod(..) =>(\"ItemMod\", LABELS_HIR_ONLY),\n \n                     // // An external module\n-                    HirItem::ItemForeignMod(..) => (\"ItemForeignMod\", LABELS_HIR_ONLY),\n+                    HirItem::ForeignMod(..) => (\"ItemForeignMod\", LABELS_HIR_ONLY),\n \n                     // Module-level inline assembly (from global_asm!)\n-                    HirItem::ItemGlobalAsm(..) => (\"ItemGlobalAsm\", LABELS_HIR_ONLY),\n+                    HirItem::GlobalAsm(..) => (\"ItemGlobalAsm\", LABELS_HIR_ONLY),\n \n                     // A type alias, e.g. `type Foo = Bar<u8>`\n-                    HirItem::ItemTy(..) => (\"ItemTy\", LABELS_HIR_ONLY),\n+                    HirItem::Ty(..) => (\"ItemTy\", LABELS_HIR_ONLY),\n \n                     // An enum definition, e.g. `enum Foo<A, B> {C<A>, D<B>}`\n-                    HirItem::ItemEnum(..) => (\"ItemEnum\", LABELS_ADT),\n+                    HirItem::Enum(..) => (\"ItemEnum\", LABELS_ADT),\n \n                     // A struct definition, e.g. `struct Foo<A> {x: A}`\n-                    HirItem::ItemStruct(..) => (\"ItemStruct\", LABELS_ADT),\n+                    HirItem::Struct(..) => (\"ItemStruct\", LABELS_ADT),\n \n                     // A union definition, e.g. `union Foo<A, B> {x: A, y: B}`\n-                    HirItem::ItemUnion(..) => (\"ItemUnion\", LABELS_ADT),\n+                    HirItem::Union(..) => (\"ItemUnion\", LABELS_ADT),\n \n                     // Represents a Trait Declaration\n                     // FIXME(michaelwoerister): trait declaration is buggy because sometimes some of\n@@ -391,10 +391,10 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     // However, this did not seem to work effectively and more bugs were hit.\n                     // Nebie @vitiral gave up :)\n                     //\n-                    //HirItem::ItemTrait(..) => (\"ItemTrait\", LABELS_TRAIT),\n+                    //HirItem::Trait(..) => (\"ItemTrait\", LABELS_TRAIT),\n \n                     // An implementation, eg `impl<A> Trait for Foo { .. }`\n-                    HirItem::ItemImpl(..) => (\"ItemImpl\", LABELS_IMPL),\n+                    HirItem::Impl(..) => (\"ItemImpl\", LABELS_IMPL),\n \n                     _ => self.tcx.sess.span_fatal(\n                         attr.span,"}, {"sha": "fd5a152311ded98e505b6e7980e9747250563251", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -133,11 +133,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n         }\n \n         match it.node {\n-            hir::ItemTy(..) |\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => self.check_case(cx, \"type\", it.name, it.span),\n-            hir::ItemTrait(..) => self.check_case(cx, \"trait\", it.name, it.span),\n+            hir::ItemKind::Ty(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) => self.check_case(cx, \"type\", it.name, it.span),\n+            hir::ItemKind::Trait(..) => self.check_case(cx, \"trait\", it.name, it.span),\n             _ => (),\n         }\n     }\n@@ -296,7 +296,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        if let hir::ItemMod(_) = it.node {\n+        if let hir::ItemKind::Mod(_) = it.node {\n             self.check_snake_case(cx, \"module\", &it.name.as_str(), Some(it.span));\n         }\n     }\n@@ -369,13 +369,13 @@ impl LintPass for NonUpperCaseGlobals {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemStatic(..) => {\n+            hir::ItemKind::Static(..) => {\n                 if attr::find_by_name(&it.attrs, \"no_mangle\").is_some() {\n                     return;\n                 }\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", it.name, it.span);\n             }\n-            hir::ItemConst(..) => {\n+            hir::ItemKind::Const(..) => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"constant\", it.name, it.span);\n             }\n             _ => {}"}, {"sha": "8a674449880b83b5b8b70e41e3bc38175a81e2c4", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -120,11 +120,11 @@ impl LintPass for BoxPointers {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemFn(..) |\n-            hir::ItemTy(..) |\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => {\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::Ty(..) |\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) => {\n                 let def_id = cx.tcx.hir.local_def_id(it.id);\n                 self.check_heap_type(cx, it.span, cx.tcx.type_of(def_id))\n             }\n@@ -133,8 +133,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n \n         // If it's a struct, we also have to check the fields' types\n         match it.node {\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 for struct_field in struct_def.fields() {\n                     let def_id = cx.tcx.hir.local_def_id(struct_field.id);\n                     self.check_heap_type(cx, struct_field.span,\n@@ -236,11 +236,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemTrait(_, hir::Unsafety::Unsafe, ..) => {\n+            hir::ItemKind::Trait(_, hir::Unsafety::Unsafe, ..) => {\n                 self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n             }\n \n-            hir::ItemImpl(hir::Unsafety::Unsafe, ..) => {\n+            hir::ItemKind::Impl(hir::Unsafety::Unsafe, ..) => {\n                 self.report_unsafe(cx, it.span, \"implementation of an `unsafe` trait\")\n             }\n \n@@ -390,12 +390,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let desc = match it.node {\n-            hir::ItemFn(..) => \"a function\",\n-            hir::ItemMod(..) => \"a module\",\n-            hir::ItemEnum(..) => \"an enum\",\n-            hir::ItemStruct(..) => \"a struct\",\n-            hir::ItemUnion(..) => \"a union\",\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Fn(..) => \"a function\",\n+            hir::ItemKind::Mod(..) => \"a module\",\n+            hir::ItemKind::Enum(..) => \"an enum\",\n+            hir::ItemKind::Struct(..) => \"a struct\",\n+            hir::ItemKind::Union(..) => \"a union\",\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n                     self.private_traits.insert(it.id);\n@@ -406,8 +406,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 }\n                 \"a trait\"\n             }\n-            hir::ItemTy(..) => \"a type alias\",\n-            hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n+            hir::ItemKind::Ty(..) => \"a type alias\",\n+            hir::ItemKind::Impl(.., Some(ref trait_ref), _, ref impl_item_refs) => {\n                 // If the trait is private, add the impl items to private_traits so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.def.def_id();\n@@ -425,8 +425,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 }\n                 return;\n             }\n-            hir::ItemConst(..) => \"a constant\",\n-            hir::ItemStatic(..) => \"a static\",\n+            hir::ItemKind::Const(..) => \"a constant\",\n+            hir::ItemKind::Static(..) => \"a static\",\n             _ => return,\n         };\n \n@@ -509,21 +509,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n             return;\n         }\n         let (def, ty) = match item.node {\n-            hir::ItemStruct(_, ref ast_generics) => {\n+            hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n-            hir::ItemUnion(_, ref ast_generics) => {\n+            hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n                 let def = cx.tcx.adt_def(cx.tcx.hir.local_def_id(item.id));\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n-            hir::ItemEnum(_, ref ast_generics) => {\n+            hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n@@ -577,9 +577,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         }\n \n         match item.node {\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) |\n-            hir::ItemEnum(..) => {}\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Enum(..) => {}\n             _ => return,\n         }\n \n@@ -1121,7 +1121,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n         }\n \n         match it.node {\n-            hir::ItemExternCrate(..) => (),\n+            hir::ItemKind::ExternCrate(..) => (),\n             _ => return,\n         };\n \n@@ -1203,7 +1203,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n         };\n \n         match it.node {\n-            hir::ItemFn(.., ref generics, _) => {\n+            hir::ItemKind::Fn(.., ref generics, _) => {\n                 if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, \"no_mangle\") {\n                     if attr::contains_name(&it.attrs, \"linkage\") {\n                         return;\n@@ -1232,7 +1232,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                     }\n                 }\n             }\n-            hir::ItemStatic(..) => {\n+            hir::ItemKind::Static(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n                     !cx.access_levels.is_reachable(it.id) {\n                         let msg = \"static is marked #[no_mangle], but not exported\";\n@@ -1241,7 +1241,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         err.emit();\n                     }\n             }\n-            hir::ItemConst(..) => {\n+            hir::ItemKind::Const(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n@@ -1369,7 +1369,7 @@ impl LintPass for UnionsWithDropFields {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n-        if let hir::ItemUnion(ref vdata, _) = item.node {\n+        if let hir::ItemKind::Union(ref vdata, _) = item.node {\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.type_of(ctx.tcx.hir.local_def_id(field.id));\n                 if field_ty.needs_drop(ctx.tcx, ctx.param_env) {\n@@ -1523,7 +1523,7 @@ impl TypeAliasBounds {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         let (ty, type_alias_generics) = match item.node {\n-            hir::ItemTy(ref ty, ref generics) => (&*ty, generics),\n+            hir::ItemKind::Ty(ref ty, ref generics) => (&*ty, generics),\n             _ => return,\n         };\n         let mut suggested_changing_assoc_types = false;\n@@ -1605,10 +1605,10 @@ impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for UnusedBrokenConstVisitor<'a,\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedBrokenConst {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemConst(_, body_id) => {\n+            hir::ItemKind::Const(_, body_id) => {\n                 check_const(cx, body_id, \"constant\");\n             },\n-            hir::ItemTy(ref ty, _) => hir::intravisit::walk_ty(\n+            hir::ItemKind::Ty(ref ty, _) => hir::intravisit::walk_ty(\n                 &mut UnusedBrokenConstVisitor(cx),\n                 ty\n             ),\n@@ -1761,12 +1761,12 @@ impl LintPass for UnnameableTestFunctions {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestFunctions {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Fn(..) => {\n                 for attr in &it.attrs {\n                     if attr.name() == \"test\" {\n                         let parent = cx.tcx.hir.get_parent(it.id);\n                         match cx.tcx.hir.find(parent) {\n-                            Some(hir_map::NodeItem(hir::Item {node: hir::ItemMod(_), ..})) |\n+                            Some(hir_map::NodeItem(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n                             None => {}\n                             _ => {\n                                 cx.struct_span_lint("}, {"sha": "fd9378271a205b5497c7fbd2df279ff375b7b5e5", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -782,7 +782,7 @@ impl LintPass for ImproperCTypes {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         let mut vis = ImproperCTypesVisitor { cx: cx };\n-        if let hir::ItemForeignMod(ref nmod) = it.node {\n+        if let hir::ItemKind::ForeignMod(ref nmod) = it.node {\n             if nmod.abi != Abi::RustIntrinsic && nmod.abi != Abi::PlatformIntrinsic {\n                 for ni in &nmod.items {\n                     match ni.node {\n@@ -810,7 +810,7 @@ impl LintPass for VariantSizeDifferences {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        if let hir::ItemEnum(ref enum_definition, _) = it.node {\n+        if let hir::ItemKind::Enum(ref enum_definition, _) = it.node {\n             let item_def_id = cx.tcx.hir.local_def_id(it.id);\n             let generics = cx.tcx.generics_of(item_def_id);\n             for param in &generics.params {"}, {"sha": "b9cb97ed7d0c53cb559063ba9212d45110f32560", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -1039,16 +1039,16 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         debug!(\"IsolatedEncoder::encode_info_for_item({:?})\", def_id);\n \n         let kind = match item.node {\n-            hir::ItemStatic(_, hir::MutMutable, _) => EntryKind::MutStatic,\n-            hir::ItemStatic(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n-            hir::ItemConst(_, body_id) => {\n+            hir::ItemKind::Static(_, hir::MutMutable, _) => EntryKind::MutStatic,\n+            hir::ItemKind::Static(_, hir::MutImmutable, _) => EntryKind::ImmStatic,\n+            hir::ItemKind::Const(_, body_id) => {\n                 let mir = tcx.at(item.span).mir_const_qualif(def_id).0;\n                 EntryKind::Const(\n                     self.const_qualif(mir, body_id),\n                     self.encode_rendered_const_for_body(body_id)\n                 )\n             }\n-            hir::ItemFn(_, header, .., body) => {\n+            hir::ItemKind::Fn(_, header, .., body) => {\n                 let data = FnData {\n                     constness: header.constness,\n                     arg_names: self.encode_fn_arg_names_for_body(body),\n@@ -1057,15 +1057,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 EntryKind::Fn(self.lazy(&data))\n             }\n-            hir::ItemMod(ref m) => {\n+            hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, &item.vis)));\n             }\n-            hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n-            hir::ItemGlobalAsm(..) => EntryKind::GlobalAsm,\n-            hir::ItemTy(..) => EntryKind::Type,\n-            hir::ItemExistential(..) => EntryKind::Existential,\n-            hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n-            hir::ItemStruct(ref struct_def, _) => {\n+            hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n+            hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n+            hir::ItemKind::Ty(..) => EntryKind::Type,\n+            hir::ItemKind::Existential(..) => EntryKind::Existential,\n+            hir::ItemKind::Enum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n+            hir::ItemKind::Struct(ref struct_def, _) => {\n                 let variant = tcx.adt_def(def_id).non_enum_variant();\n \n                 // Encode def_ids for each field and method\n@@ -1086,7 +1086,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n-            hir::ItemUnion(..) => {\n+            hir::ItemKind::Union(..) => {\n                 let variant = tcx.adt_def(def_id).non_enum_variant();\n                 let repr_options = get_repr_options(&tcx, def_id);\n \n@@ -1097,7 +1097,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                     ctor_sig: None,\n                 }), repr_options)\n             }\n-            hir::ItemImpl(_, polarity, defaultness, ..) => {\n+            hir::ItemKind::Impl(_, polarity, defaultness, ..) => {\n                 let trait_ref = tcx.impl_trait_ref(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = tcx.trait_def(trait_ref.def_id);\n@@ -1132,7 +1132,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 EntryKind::Impl(self.lazy(&data))\n             }\n-            hir::ItemTrait(..) => {\n+            hir::ItemKind::Trait(..) => {\n                 let trait_def = tcx.trait_def(def_id);\n                 let data = TraitData {\n                     unsafety: trait_def.unsafety,\n@@ -1143,9 +1143,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n                 EntryKind::Trait(self.lazy(&data))\n             }\n-            hir::ItemExternCrate(_) |\n-            hir::ItemTraitAlias(..) |\n-            hir::ItemUse(..) => bug!(\"cannot encode info for item {:?}\", item),\n+            hir::ItemKind::ExternCrate(_) |\n+            hir::ItemKind::TraitAlias(..) |\n+            hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         };\n \n         Entry {\n@@ -1154,28 +1154,28 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             span: self.lazy(&item.span),\n             attributes: self.encode_attributes(&item.attrs),\n             children: match item.node {\n-                hir::ItemForeignMod(ref fm) => {\n+                hir::ItemKind::ForeignMod(ref fm) => {\n                     self.lazy_seq(fm.items\n                         .iter()\n                         .map(|foreign_item| tcx.hir.local_def_id(foreign_item.id).index))\n                 }\n-                hir::ItemEnum(..) => {\n+                hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n                     self.lazy_seq(def.variants.iter().map(|v| {\n                         assert!(v.did.is_local());\n                         v.did.index\n                     }))\n                 }\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) => {\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) => {\n                     let def = self.tcx.adt_def(def_id);\n                     self.lazy_seq(def.non_enum_variant().fields.iter().map(|f| {\n                         assert!(f.did.is_local());\n                         f.did.index\n                     }))\n                 }\n-                hir::ItemImpl(..) |\n-                hir::ItemTrait(..) => {\n+                hir::ItemKind::Impl(..) |\n+                hir::ItemKind::Trait(..) => {\n                     self.lazy_seq(tcx.associated_item_def_ids(def_id).iter().map(|&def_id| {\n                         assert!(def_id.is_local());\n                         def_id.index\n@@ -1187,49 +1187,49 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             deprecation: self.encode_deprecation(def_id),\n \n             ty: match item.node {\n-                hir::ItemStatic(..) |\n-                hir::ItemConst(..) |\n-                hir::ItemFn(..) |\n-                hir::ItemTy(..) |\n-                hir::ItemExistential(..) |\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemImpl(..) => Some(self.encode_item_type(def_id)),\n+                hir::ItemKind::Static(..) |\n+                hir::ItemKind::Const(..) |\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::Ty(..) |\n+                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Impl(..) => Some(self.encode_item_type(def_id)),\n                 _ => None,\n             },\n             inherent_impls: self.encode_inherent_implementations(def_id),\n             variances: match item.node {\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemFn(..) => self.encode_variances_of(def_id),\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Fn(..) => self.encode_variances_of(def_id),\n                 _ => LazySeq::empty(),\n             },\n             generics: match item.node {\n-                hir::ItemStatic(..) |\n-                hir::ItemConst(..) |\n-                hir::ItemFn(..) |\n-                hir::ItemTy(..) |\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemImpl(..) |\n-                hir::ItemExistential(..) |\n-                hir::ItemTrait(..) => Some(self.encode_generics(def_id)),\n+                hir::ItemKind::Static(..) |\n+                hir::ItemKind::Const(..) |\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::Ty(..) |\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Impl(..) |\n+                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::Trait(..) => Some(self.encode_generics(def_id)),\n                 _ => None,\n             },\n             predicates: match item.node {\n-                hir::ItemStatic(..) |\n-                hir::ItemConst(..) |\n-                hir::ItemFn(..) |\n-                hir::ItemTy(..) |\n-                hir::ItemEnum(..) |\n-                hir::ItemStruct(..) |\n-                hir::ItemUnion(..) |\n-                hir::ItemImpl(..) |\n-                hir::ItemExistential(..) |\n-                hir::ItemTrait(..) => Some(self.encode_predicates(def_id)),\n+                hir::ItemKind::Static(..) |\n+                hir::ItemKind::Const(..) |\n+                hir::ItemKind::Fn(..) |\n+                hir::ItemKind::Ty(..) |\n+                hir::ItemKind::Enum(..) |\n+                hir::ItemKind::Struct(..) |\n+                hir::ItemKind::Union(..) |\n+                hir::ItemKind::Impl(..) |\n+                hir::ItemKind::Existential(..) |\n+                hir::ItemKind::Trait(..) => Some(self.encode_predicates(def_id)),\n                 _ => None,\n             },\n \n@@ -1239,16 +1239,16 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             // hack. (No reason not to expand it in the future if\n             // necessary.)\n             predicates_defined_on: match item.node {\n-                hir::ItemTrait(..) => Some(self.encode_predicates_defined_on(def_id)),\n+                hir::ItemKind::Trait(..) => Some(self.encode_predicates_defined_on(def_id)),\n                 _ => None, // not *wrong* for other kinds of items, but not needed\n             },\n \n             mir: match item.node {\n-                hir::ItemStatic(..) => {\n+                hir::ItemKind::Static(..) => {\n                     self.encode_optimized_mir(def_id)\n                 }\n-                hir::ItemConst(..) => self.encode_optimized_mir(def_id),\n-                hir::ItemFn(_, header, ..) => {\n+                hir::ItemKind::Const(..) => self.encode_optimized_mir(def_id),\n+                hir::ItemKind::Fn(_, header, ..) => {\n                     let generics = tcx.generics_of(def_id);\n                     let has_types = generics.params.iter().any(|param| match param.kind {\n                         ty::GenericParamDefKind::Type { .. } => true,\n@@ -1614,8 +1614,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'tcx> {\n         intravisit::walk_item(self, item);\n         let def_id = self.index.tcx.hir.local_def_id(item.id);\n         match item.node {\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) => (), // ignore these\n+            hir::ItemKind::ExternCrate(_) |\n+            hir::ItemKind::Use(..) => (), // ignore these\n             _ => self.index.record(def_id, IsolatedEncoder::encode_info_for_item, (def_id, item)),\n         }\n         self.index.encode_addl_info_for_item(item);\n@@ -1703,20 +1703,20 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n     fn encode_addl_info_for_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir.local_def_id(item.id);\n         match item.node {\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemExternCrate(..) |\n-            hir::ItemUse(..) |\n-            hir::ItemTy(..) |\n-            hir::ItemExistential(..) |\n-            hir::ItemTraitAlias(..) => {\n+            hir::ItemKind::Static(..) |\n+            hir::ItemKind::Const(..) |\n+            hir::ItemKind::Fn(..) |\n+            hir::ItemKind::Mod(..) |\n+            hir::ItemKind::ForeignMod(..) |\n+            hir::ItemKind::GlobalAsm(..) |\n+            hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::Use(..) |\n+            hir::ItemKind::Ty(..) |\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n                 // no sub-item recording needed in these cases\n             }\n-            hir::ItemEnum(..) => {\n+            hir::ItemKind::Enum(..) => {\n                 self.encode_fields(def_id);\n \n                 let def = self.tcx.adt_def(def_id);\n@@ -1726,7 +1726,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                                 (def_id, Untracked(i)));\n                 }\n             }\n-            hir::ItemStruct(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) => {\n                 self.encode_fields(def_id);\n \n                 // If the struct has a constructor, encode it.\n@@ -1737,17 +1737,17 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n                                 (def_id, ctor_def_id));\n                 }\n             }\n-            hir::ItemUnion(..) => {\n+            hir::ItemKind::Union(..) => {\n                 self.encode_fields(def_id);\n             }\n-            hir::ItemImpl(..) => {\n+            hir::ItemKind::Impl(..) => {\n                 for &trait_item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(trait_item_def_id,\n                                 IsolatedEncoder::encode_info_for_impl_item,\n                                 trait_item_def_id);\n                 }\n             }\n-            hir::ItemTrait(..) => {\n+            hir::ItemKind::Trait(..) => {\n                 for &item_def_id in self.tcx.associated_item_def_ids(def_id).iter() {\n                     self.record(item_def_id,\n                                 IsolatedEncoder::encode_info_for_trait_item,\n@@ -1765,7 +1765,7 @@ struct ImplVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemImpl(..) = item.node {\n+        if let hir::ItemKind::Impl(..) = item.node {\n             let impl_id = self.tcx.hir.local_def_id(item.id);\n             if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_id) {\n                 self.impls"}, {"sha": "e96d56fb3889351f9336403be121af06048282fb", "filename": "src/librustc_metadata/foreign_modules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_metadata%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_metadata%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fforeign_modules.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -30,7 +30,7 @@ struct Collector<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n-            hir::ItemForeignMod(ref fm) => fm,\n+            hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };\n "}, {"sha": "008e1e363ff53881cc7eefd261aa04e37cadd856", "filename": "src/librustc_metadata/link_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_metadata%2Flink_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_metadata%2Flink_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flink_args.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -37,7 +37,7 @@ struct Collector {\n impl<'tcx> ItemLikeVisitor<'tcx> for Collector {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n-            hir::ItemForeignMod(ref fm) => fm,\n+            hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };\n         if fm.abi == Abi::Rust ||"}, {"sha": "327b2abc4d318b8829d4dff13d322576205e380a", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -45,7 +45,7 @@ struct Collector<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         let fm = match it.node {\n-            hir::ItemForeignMod(ref fm) => fm,\n+            hir::ItemKind::ForeignMod(ref fm) => fm,\n             _ => return,\n         };\n "}, {"sha": "a2d620db9243fe2a58ab4f7b1e470367b4c89686", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -945,28 +945,28 @@ struct RootCollector<'b, 'a: 'b, 'tcx: 'a + 'b> {\n impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemExternCrate(..) |\n-            hir::ItemUse(..)         |\n-            hir::ItemForeignMod(..)  |\n-            hir::ItemTy(..)          |\n-            hir::ItemTrait(..)       |\n-            hir::ItemTraitAlias(..)  |\n-            hir::ItemExistential(..) |\n-            hir::ItemMod(..)         => {\n+            hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::Use(..)         |\n+            hir::ItemKind::ForeignMod(..)  |\n+            hir::ItemKind::Ty(..)          |\n+            hir::ItemKind::Trait(..)       |\n+            hir::ItemKind::TraitAlias(..)  |\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::Mod(..)         => {\n                 // Nothing to do, just keep recursing...\n             }\n \n-            hir::ItemImpl(..) => {\n+            hir::ItemKind::Impl(..) => {\n                 if self.mode == MonoItemCollectionMode::Eager {\n                     create_mono_items_for_default_impls(self.tcx,\n                                                         item,\n                                                         self.output);\n                 }\n             }\n \n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemStruct(_, ref generics) |\n-            hir::ItemUnion(_, ref generics) => {\n+            hir::ItemKind::Enum(_, ref generics) |\n+            hir::ItemKind::Struct(_, ref generics) |\n+            hir::ItemKind::Union(_, ref generics) => {\n                 if generics.params.is_empty() {\n                     if self.mode == MonoItemCollectionMode::Eager {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -978,19 +978,19 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                     }\n                 }\n             }\n-            hir::ItemGlobalAsm(..) => {\n-                debug!(\"RootCollector: ItemGlobalAsm({})\",\n+            hir::ItemKind::GlobalAsm(..) => {\n+                debug!(\"RootCollector: ItemKind::GlobalAsm({})\",\n                        def_id_to_string(self.tcx,\n                                         self.tcx.hir.local_def_id(item.id)));\n                 self.output.push(MonoItem::GlobalAsm(item.id));\n             }\n-            hir::ItemStatic(..) => {\n+            hir::ItemKind::Static(..) => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n-                debug!(\"RootCollector: ItemStatic({})\",\n+                debug!(\"RootCollector: ItemKind::Static({})\",\n                        def_id_to_string(self.tcx, def_id));\n                 self.output.push(MonoItem::Static(def_id));\n             }\n-            hir::ItemConst(..) => {\n+            hir::ItemKind::Const(..) => {\n                 // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n \n@@ -1001,7 +1001,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                     self.output.push(MonoItem::CustomSection(def_id));\n                 }\n             }\n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Fn(..) => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 self.push_if_root(def_id);\n             }\n@@ -1102,7 +1102,7 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                  item: &'tcx hir::Item,\n                                                  output: &mut Vec<MonoItem<'tcx>>) {\n     match item.node {\n-        hir::ItemImpl(_, _, _, ref generics, .., ref impl_item_refs) => {\n+        hir::ItemKind::Impl(_, _, _, ref generics, .., ref impl_item_refs) => {\n             for param in &generics.params {\n                 match param.kind {\n                     hir::GenericParamKind::Lifetime { .. } => {}"}, {"sha": "b4f0a7cd6c4b5e5a9366c3f4ac6126ffecf7c4d0", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -405,7 +405,7 @@ fn is_enclosed(tcx: TyCtxt,\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n         } else if let Some(hir::map::NodeItem(&hir::Item {\n-            node: hir::ItemFn(_, header, _, _),\n+            node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n         })) = tcx.hir.find(parent_id) {\n             match header.unsafety {"}, {"sha": "f2728593db4d9aa1aa551063ec657532aeaf85ad", "filename": "src/librustc_plugin/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_plugin%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_plugin%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fbuild.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -24,7 +24,7 @@ struct RegistrarFinder {\n \n impl<'v> ItemLikeVisitor<'v> for RegistrarFinder {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemFn(..) = item.node {\n+        if let hir::ItemKind::Fn(..) = item.node {\n             if attr::contains_name(&item.attrs,\n                                    \"plugin_registrar\") {\n                 self.registrars.push((item.id, item.span));"}, {"sha": "826577ff6ba7293a4d8758e0a2360c62cf3943b0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -149,21 +149,21 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n             // Impls inherit level from their types and traits\n-            hir::ItemImpl(..) => {\n+            hir::ItemKind::Impl(..) => {\n                 let def_id = self.tcx.hir.local_def_id(item.id);\n                 cmp::min(self.item_ty_level(def_id), self.impl_trait_level(def_id))\n             }\n             // Foreign mods inherit level from parents\n-            hir::ItemForeignMod(..) => {\n+            hir::ItemKind::ForeignMod(..) => {\n                 self.prev_level\n             }\n             // Other `pub` items inherit levels from parents\n-            hir::ItemConst(..) | hir::ItemEnum(..) | hir::ItemExternCrate(..) |\n-            hir::ItemGlobalAsm(..) | hir::ItemFn(..) | hir::ItemMod(..) |\n-            hir::ItemStatic(..) | hir::ItemStruct(..) |\n-            hir::ItemTrait(..) | hir::ItemTraitAlias(..) |\n-            hir::ItemExistential(..) |\n-            hir::ItemTy(..) | hir::ItemUnion(..) | hir::ItemUse(..) => {\n+            hir::ItemKind::Const(..) | hir::ItemKind::Enum(..) | hir::ItemKind::ExternCrate(..) |\n+            hir::ItemKind::GlobalAsm(..) | hir::ItemKind::Fn(..) | hir::ItemKind::Mod(..) |\n+            hir::ItemKind::Static(..) | hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..) |\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::Ty(..) | hir::ItemKind::Union(..) | hir::ItemKind::Use(..) => {\n                 if item.vis.node.is_pub() { self.prev_level } else { None }\n             }\n         };\n@@ -173,32 +173,32 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n         // Update levels of nested things\n         match item.node {\n-            hir::ItemEnum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n                     let variant_level = self.update(variant.node.data.id(), item_level);\n                     for field in variant.node.data.fields() {\n                         self.update(field.id, variant_level);\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., None, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     if impl_item_ref.vis.node.is_pub() {\n                         self.update(impl_item_ref.id.node_id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., Some(_), _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n                     self.update(impl_item_ref.id.node_id, item_level);\n                 }\n             }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n                     self.update(trait_item_ref.id.node_id, item_level);\n                 }\n             }\n-            hir::ItemStruct(ref def, _) | hir::ItemUnion(ref def, _) => {\n+            hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n                 if !def.is_struct() {\n                     self.update(def.id(), item_level);\n                 }\n@@ -208,43 +208,43 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if foreign_item.vis.node.is_pub() {\n                         self.update(foreign_item.id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemExistential(..) |\n-            hir::ItemUse(..) | hir::ItemStatic(..) | hir::ItemConst(..) |\n-            hir::ItemGlobalAsm(..) | hir::ItemTy(..) | hir::ItemMod(..) | hir::ItemTraitAlias(..) |\n-            hir::ItemFn(..) | hir::ItemExternCrate(..) => {}\n+            hir::ItemKind::Existential(..) |\n+            hir::ItemKind::Use(..) | hir::ItemKind::Static(..) | hir::ItemKind::Const(..) |\n+            hir::ItemKind::GlobalAsm(..) | hir::ItemKind::Ty(..) | hir::ItemKind::Mod(..) | hir::ItemKind::TraitAlias(..) |\n+            hir::ItemKind::Fn(..) | hir::ItemKind::ExternCrate(..) => {}\n         }\n \n         // Mark all items in interfaces of reachable items as reachable\n         match item.node {\n             // The interface is empty\n-            hir::ItemExternCrate(..) => {}\n+            hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by visit_item\n-            hir::ItemMod(..) => {}\n+            hir::ItemKind::Mod(..) => {}\n             // Re-exports are handled in visit_mod\n-            hir::ItemUse(..) => {}\n+            hir::ItemKind::Use(..) => {}\n             // The interface is empty\n-            hir::ItemGlobalAsm(..) => {}\n-            hir::ItemExistential(..) => {\n+            hir::ItemKind::GlobalAsm(..) => {}\n+            hir::ItemKind::Existential(..) => {\n                 if item_level.is_some() {\n                     // Reach the (potentially private) type and the API being exposed\n                     self.reach(item.id).ty().predicates();\n                 }\n             }\n             // Visit everything\n-            hir::ItemConst(..) | hir::ItemStatic(..) |\n-            hir::ItemFn(..) | hir::ItemTy(..) => {\n+            hir::ItemKind::Const(..) | hir::ItemKind::Static(..) |\n+            hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates().ty();\n                 }\n             }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n \n@@ -261,13 +261,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemTraitAlias(..) => {\n+            hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items\n-            hir::ItemImpl(.., ref trait_ref, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates().impl_trait_ref();\n \n@@ -281,7 +281,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n \n             // Visit everything, but enum variants have their own levels\n-            hir::ItemEnum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n                 }\n@@ -297,16 +297,16 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n             // Visit everything, but foreign items have their own levels\n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if self.get(foreign_item.id).is_some() {\n                         self.reach(foreign_item.id).generics().predicates().ty();\n                     }\n                 }\n             }\n             // Visit everything except for private fields\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n                     self.reach(item.id).generics().predicates();\n                     for field in struct_def.fields() {\n@@ -373,7 +373,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n         loop {\n             let module = if module_id == ast::CRATE_NODE_ID {\n                 &self.tcx.hir.krate().module\n-            } else if let hir::ItemMod(ref module) = self.tcx.hir.expect_item(module_id).node {\n+            } else if let hir::ItemKind::Mod(ref module) = self.tcx.hir.expect_item(module_id).node {\n                 module\n             } else {\n                 unreachable!()\n@@ -1084,13 +1084,13 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         match item.node {\n             // contents of a private mod can be re-exported, so we need\n             // to check internals.\n-            hir::ItemMod(_) => {}\n+            hir::ItemKind::Mod(_) => {}\n \n             // An `extern {}` doesn't introduce a new privacy\n             // namespace (the contents have their own privacies).\n-            hir::ItemForeignMod(_) => {}\n+            hir::ItemKind::ForeignMod(_) => {}\n \n-            hir::ItemTrait(.., ref bounds, _) => {\n+            hir::ItemKind::Trait(.., ref bounds, _) => {\n                 if !self.trait_is_public(item.id) {\n                     return\n                 }\n@@ -1105,7 +1105,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // (i.e. we could just return here to not check them at\n             // all, or some worse estimation of whether an impl is\n             // publicly visible).\n-            hir::ItemImpl(.., ref g, ref trait_ref, ref self_, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref g, ref trait_ref, ref self_, ref impl_item_refs) => {\n                 // `impl [... for] Private` is never visible.\n                 let self_contains_private;\n                 // impl [... for] Public<...>, but not `impl [... for]\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n \n             // `type ... = ...;` can contain private types, because\n             // we're introducing a new name.\n-            hir::ItemTy(..) => return,\n+            hir::ItemKind::Ty(..) => return,\n \n             // not at all public, so we don't care\n             _ if !self.item_is_public(&item.id, &item.vis) => {\n@@ -1552,14 +1552,14 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n         match item.node {\n             // Crates are always public\n-            hir::ItemExternCrate(..) => {}\n+            hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by visit_item\n-            hir::ItemMod(..) => {}\n+            hir::ItemKind::Mod(..) => {}\n             // Checked in resolve\n-            hir::ItemUse(..) => {}\n+            hir::ItemKind::Use(..) => {}\n             // No subitems\n-            hir::ItemGlobalAsm(..) => {}\n-            hir::ItemExistential(..) => {\n+            hir::ItemKind::GlobalAsm(..) => {}\n+            hir::ItemKind::Existential(..) => {\n                 // Check the traits being exposed, as they're separate,\n                 // e.g. `impl Iterator<Item=T>` has two predicates,\n                 // `X: Iterator` and `<X as Iterator>::Item == T`,\n@@ -1569,15 +1569,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.id, item_visibility).predicates();\n             }\n             // Subitems of these items have inherited publicity\n-            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n-            hir::ItemTy(..) => {\n+            hir::ItemKind::Const(..) | hir::ItemKind::Static(..) | hir::ItemKind::Fn(..) |\n+            hir::ItemKind::Ty(..) => {\n                 self.check(item.id, item_visibility).generics().predicates().ty();\n \n                 // Recurse for e.g. `impl Trait` (see `visit_ty`).\n                 self.inner_visibility = item_visibility;\n                 intravisit::walk_item(self, item);\n             }\n-            hir::ItemTrait(.., ref trait_item_refs) => {\n+            hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n \n                 for trait_item_ref in trait_item_refs {\n@@ -1593,10 +1593,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                     }\n                 }\n             }\n-            hir::ItemTraitAlias(..) => {\n+            hir::ItemKind::TraitAlias(..) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n             }\n-            hir::ItemEnum(ref def, _) => {\n+            hir::ItemKind::Enum(ref def, _) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n \n                 for variant in &def.variants {\n@@ -1606,15 +1606,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 }\n             }\n             // Subitems of foreign modules have their own publicity\n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     let vis = ty::Visibility::from_hir(&foreign_item.vis, item.id, tcx);\n                     self.check(foreign_item.id, vis).generics().predicates().ty();\n                 }\n             }\n             // Subitems of structs and unions have their own publicity\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n@@ -1624,7 +1624,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             }\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n-            hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., None, _, ref impl_item_refs) => {\n                 let ty_vis =\n                     self.check(item.id, ty::Visibility::Invisible).ty().min_visibility;\n                 self.check(item.id, ty_vis).generics().predicates();\n@@ -1643,7 +1643,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n-            hir::ItemImpl(.., Some(_), _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., Some(_), _, ref impl_item_refs) => {\n                 let vis = self.check(item.id, ty::Visibility::Invisible)\n                               .ty().impl_trait_ref().min_visibility;\n                 self.check(item.id, vis).generics().predicates();"}, {"sha": "f2620c04754b8ab2fd05fd30a64c3cfc11f4dbc0", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -420,7 +420,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             match self.tcx.impl_of_method(self.tcx.hir.local_def_id(id)) {\n                 Some(impl_id) => match self.tcx.hir.get_if_local(impl_id) {\n                     Some(Node::NodeItem(item)) => match item.node {\n-                        hir::ItemImpl(.., ref ty, _) => {\n+                        hir::ItemKind::Impl(.., ref ty, _) => {\n                             let mut qualname = String::from(\"<\");\n                             qualname.push_str(&self.tcx.hir.node_to_pretty_string(ty.id));\n \n@@ -630,7 +630,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::NodeTraitRef(tr) => tr.path.def,\n \n             Node::NodeItem(&hir::Item {\n-                node: hir::ItemUse(ref path, _),\n+                node: hir::ItemKind::Use(ref path, _),\n                 ..\n             }) |\n             Node::NodeVisibility(&Spanned {"}, {"sha": "fca35dec067fe8c2398b8d401ee2ff017101d6a8", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -18,7 +18,7 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::map::{NodeItem, NodeExpr};\n-use rustc::hir::{Item, ItemConst, print};\n+use rustc::hir::{Item, ItemKind, print};\n use rustc::ty::{self, Ty, AssociatedItem};\n use rustc::ty::adjustment::AllowTwoPhase;\n use errors::{DiagnosticBuilder, CodeMapper};\n@@ -376,7 +376,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.tcx.hir.find(parent_id) {\n             Some(parent) => {\n                 // Shouldn't suggest `.into()` on `const`s.\n-                if let NodeItem(Item { node: ItemConst(_, _), .. }) = parent {\n+                if let NodeItem(Item { node: ItemKind::Const(_, _), .. }) = parent {\n                     // FIXME(estebank): modify once we decide to suggest `as` casts\n                     return false;\n                 }"}, {"sha": "c2c56edfc0929510f463802e471bb99e29f49d6f", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -709,7 +709,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n         impl<'v, 'a, 'tcx> itemlikevisit::ItemLikeVisitor<'v> for Visitor<'a, 'tcx> {\n             fn visit_item(&mut self, i: &'v hir::Item) {\n                 match i.node {\n-                    hir::ItemTrait(..) => {\n+                    hir::ItemKind::Trait(..) => {\n                         let def_id = self.map.local_def_id(i.id);\n                         self.traits.push(def_id);\n                     }\n@@ -810,7 +810,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n         for item_id in &module.item_ids {\n             let item = self.tcx.hir.expect_item(item_id.id);\n             match item.node {\n-                hir::ItemUse(..) => {\n+                hir::ItemKind::Use(..) => {\n                     // don't suggest placing a use before the prelude\n                     // import or other generated ones\n                     if item.span.ctxt().outer().expn_info().is_none() {\n@@ -820,7 +820,7 @@ impl<'a, 'tcx, 'gcx> hir::intravisit::Visitor<'tcx> for UsePlacementFinder<'a, '\n                     }\n                 },\n                 // don't place use before extern crate\n-                hir::ItemExternCrate(_) => {}\n+                hir::ItemKind::ExternCrate(_) => {}\n                 // but place them before the first other item\n                 _ => if self.span.map_or(true, |span| item.span < span ) {\n                     if item.span.ctxt().outer().expn_info().is_none() {"}, {"sha": "9f83f8a00b1f5143386fcc01b36a223f7edf4f43", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -132,7 +132,7 @@ use syntax_pos::{self, BytePos, Span, MultiSpan};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::map::Node;\n-use rustc::hir::{self, PatKind, Item_};\n+use rustc::hir::{self, PatKind, ItemKind};\n use rustc::middle::lang_items;\n \n mod autoderef;\n@@ -759,10 +759,10 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match tcx.hir.get(id) {\n         hir::map::NodeItem(item) => {\n             match item.node {\n-                hir::ItemConst(_, body) |\n-                hir::ItemStatic(_, _, body) =>\n+                hir::ItemKind::Const(_, body) |\n+                hir::ItemKind::Static(_, _, body) =>\n                     Some((body, None)),\n-                hir::ItemFn(ref decl, .., body) =>\n+                hir::ItemKind::Fn(ref decl, .., body) =>\n                     Some((body, Some(decl))),\n                 _ =>\n                     None,\n@@ -1165,7 +1165,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                     }\n \n                     if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n-                        if let Item_::ItemFn(_, _, ref generics, _) = item.node {\n+                        if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,\n@@ -1213,7 +1213,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                     }\n \n                     if let Node::NodeItem(item) = fcx.tcx.hir.get(fn_id) {\n-                        if let Item_::ItemFn(_, _, ref generics, _) = item.node {\n+                        if let ItemKind::Fn(_, _, ref generics, _) = item.node {\n                             if !generics.params.is_empty() {\n                                 fcx.tcx.sess.span_err(\n                                     span,\n@@ -1269,25 +1269,25 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n     let _indenter = indenter();\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n-      hir::ItemStatic(..) => {\n+      hir::ItemKind::Static(..) => {\n         tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n       }\n-      hir::ItemConst(..) => {\n+      hir::ItemKind::Const(..) => {\n         tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n         if it.attrs.iter().any(|a| a.check_name(\"wasm_custom_section\")) {\n             let def_id = tcx.hir.local_def_id(it.id);\n             check_const_is_u8_array(tcx, def_id, it.span);\n         }\n       }\n-      hir::ItemEnum(ref enum_definition, _) => {\n+      hir::ItemKind::Enum(ref enum_definition, _) => {\n         check_enum(tcx,\n                    it.span,\n                    &enum_definition.variants,\n                    it.id);\n       }\n-      hir::ItemFn(..) => {} // entirely within check_item_body\n-      hir::ItemImpl(.., ref impl_item_refs) => {\n-          debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n+      hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n+      hir::ItemKind::Impl(.., ref impl_item_refs) => {\n+          debug!(\"ItemKind::Impl {} with id {}\", it.name, it.id);\n           let impl_def_id = tcx.hir.local_def_id(it.id);\n           if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n               check_impl_items_against_trait(tcx,\n@@ -1299,23 +1299,23 @@ pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item\n               check_on_unimplemented(tcx, trait_def_id, it);\n           }\n       }\n-      hir::ItemTrait(..) => {\n+      hir::ItemKind::Trait(..) => {\n         let def_id = tcx.hir.local_def_id(it.id);\n         check_on_unimplemented(tcx, def_id, it);\n       }\n-      hir::ItemStruct(..) => {\n+      hir::ItemKind::Struct(..) => {\n         check_struct(tcx, it.id, it.span);\n       }\n-      hir::ItemUnion(..) => {\n+      hir::ItemKind::Union(..) => {\n         check_union(tcx, it.id, it.span);\n       }\n-      hir::ItemTy(..) => {\n+      hir::ItemKind::Ty(..) => {\n         let def_id = tcx.hir.local_def_id(it.id);\n         let pty_ty = tcx.type_of(def_id);\n         let generics = tcx.generics_of(def_id);\n         check_bounds_are_used(tcx, &generics, pty_ty);\n       }\n-      hir::ItemForeignMod(ref m) => {\n+      hir::ItemKind::ForeignMod(ref m) => {\n         check_abi(tcx, it.span, m.abi);\n \n         if m.abi == Abi::RustIntrinsic {\n@@ -4548,7 +4548,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let parent = self.tcx.hir.get(fn_id);\n \n             if let Node::NodeItem(&hir::Item {\n-                name, node: hir::ItemFn(ref decl, ..), ..\n+                name, node: hir::ItemKind::Fn(ref decl, ..), ..\n             }) = parent {\n                 decl.clone().and_then(|decl| {\n                     // This is less than ideal, it will not suggest a return type span on any"}, {"sha": "d876f41ce13078ce37891c40ebe38e892dd49784", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -97,7 +97,7 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n         //\n         // won't be allowed unless there's an *explicit* implementation of `Send`\n         // for `T`\n-        hir::ItemImpl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n+        hir::ItemKind::Impl(_, polarity, defaultness, _, ref trait_ref, ref self_ty, _) => {\n             let is_auto = tcx.impl_trait_ref(tcx.hir.local_def_id(item.id))\n                                 .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (defaultness, is_auto) {\n@@ -114,37 +114,37 @@ pub fn check_item_well_formed<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: Def\n                 }\n             }\n         }\n-        hir::ItemFn(..) => {\n+        hir::ItemKind::Fn(..) => {\n             check_item_fn(tcx, item);\n         }\n-        hir::ItemStatic(..) => {\n+        hir::ItemKind::Static(..) => {\n             check_item_type(tcx, item);\n         }\n-        hir::ItemConst(..) => {\n+        hir::ItemKind::Const(..) => {\n             check_item_type(tcx, item);\n         }\n-        hir::ItemStruct(ref struct_def, ref ast_generics) => {\n+        hir::ItemKind::Struct(ref struct_def, ref ast_generics) => {\n             check_type_defn(tcx, item, false, |fcx| {\n                 vec![fcx.non_enum_variant(struct_def)]\n             });\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemUnion(ref struct_def, ref ast_generics) => {\n+        hir::ItemKind::Union(ref struct_def, ref ast_generics) => {\n             check_type_defn(tcx, item, true, |fcx| {\n                 vec![fcx.non_enum_variant(struct_def)]\n             });\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemEnum(ref enum_def, ref ast_generics) => {\n+        hir::ItemKind::Enum(ref enum_def, ref ast_generics) => {\n             check_type_defn(tcx, item, true, |fcx| {\n                 fcx.enum_variants(enum_def)\n             });\n \n             check_variances_for_type_defn(tcx, item, ast_generics);\n         }\n-        hir::ItemTrait(..) => {\n+        hir::ItemKind::Trait(..) => {\n             check_trait(tcx, item);\n         }\n         _ => {}"}, {"sha": "1a57dfd745e3ac23c6342d74224d84567ece1e46", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n         if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n         }\n-        if let hir::ItemUse(ref path, _) = item.node {\n+        if let hir::ItemKind::Use(ref path, _) = item.node {\n             self.check_import(item.id, path.span);\n         }\n     }\n@@ -196,7 +196,7 @@ struct ExternCrateToLint {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if let hir::ItemExternCrate(orig_name) = item.node {\n+        if let hir::ItemKind::ExternCrate(orig_name) = item.node {\n             let extern_crate_def_id = self.tcx.hir.local_def_id(item.id);\n             self.crates_to_lint.push(\n                 ExternCrateToLint {"}, {"sha": "4d9a4a03a6b50326bdc92c48f9dfdc8a3657dba3", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -24,7 +24,7 @@ use rustc::infer;\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n-use rustc::hir::{self, ItemImpl};\n+use rustc::hir::{self, ItemKind};\n \n pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n@@ -64,7 +64,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 match tcx.hir.find(impl_node_id) {\n                     Some(hir_map::NodeItem(item)) => {\n                         let span = match item.node {\n-                            ItemImpl(.., ref ty, _) => ty.span,\n+                            ItemKind::Impl(.., ref ty, _) => ty.span,\n                             _ => item.span,\n                         };\n                         struct_span_err!(tcx.sess,\n@@ -115,7 +115,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         Ok(()) => {}\n         Err(CopyImplementationError::InfrigingFields(fields)) => {\n             let item = tcx.hir.expect_item(impl_node_id);\n-            let span = if let ItemImpl(.., Some(ref tr), _, _) = item.node {\n+            let span = if let ItemKind::Impl(.., Some(ref tr), _, _) = item.node {\n                 tr.path.span\n             } else {\n                 span\n@@ -132,7 +132,7 @@ fn visit_implementation_of_copy<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         Err(CopyImplementationError::NotAnAdt) => {\n             let item = tcx.hir.expect_item(impl_node_id);\n-            let span = if let ItemImpl(.., ref ty, _) = item.node {\n+            let span = if let ItemKind::Impl(.., ref ty, _) = item.node {\n                 ty.span\n             } else {\n                 span\n@@ -336,7 +336,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                     return err_info;\n                 } else if diff_fields.len() > 1 {\n                     let item = gcx.hir.expect_item(impl_node_id);\n-                    let span = if let ItemImpl(.., Some(ref t), _, _) = item.node {\n+                    let span = if let ItemKind::Impl(.., Some(ref t), _, _) = item.node {\n                         t.path.span\n                     } else {\n                         gcx.hir.span(impl_node_id)"}, {"sha": "02a18fa47dff16fce4f66e35d574381b64a6a9e2", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -94,7 +94,7 @@ struct InherentCollect<'a, 'tcx: 'a> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let ty = match item.node {\n-            hir::ItemImpl(.., None, ref ty, _) => ty,\n+            hir::ItemKind::Impl(.., None, ref ty, _) => ty,\n             _ => return\n         };\n "}, {"sha": "c0260d6714d0538695c1851b6b45c3c4059e9dd1", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -122,10 +122,10 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemTrait(..) |\n-            hir::ItemUnion(..) => {\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::Union(..) => {\n                 let type_def_id = self.tcx.hir.local_def_id(item.id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n             }"}, {"sha": "9be509b358807878b3a99dd6c8f15ac37a2b64ae", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -34,7 +34,7 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         let def_id = self.tcx.hir.local_def_id(item.id);\n         match item.node {\n-            hir::ItemImpl(.., Some(_), _, _) => {\n+            hir::ItemKind::Impl(.., Some(_), _, _) => {\n                 // \"Trait\" impl\n                 debug!(\"coherence2::orphan check: trait impl {}\",\n                        self.tcx.hir.node_to_string(item.id));"}, {"sha": "9e19854a571fcba1dab34f98f7ed5e60b550fe24", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -84,7 +84,7 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemImpl(unsafety, polarity, _, ref generics, ..) => {\n+            hir::ItemKind::Impl(unsafety, polarity, _, ref generics, ..) => {\n                 self.check_unsafety_coherence(item, Some(generics), unsafety, polarity);\n             }\n             _ => {}"}, {"sha": "7fcfea0cead0963c9cdcdc06b4d6b20717abf3c1", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -266,13 +266,13 @@ fn type_param_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(.., ref generics, _) |\n-                ItemImpl(_, _, _, ref generics, ..) |\n-                ItemTy(_, ref generics) |\n-                ItemEnum(_, ref generics) |\n-                ItemStruct(_, ref generics) |\n-                ItemUnion(_, ref generics) => generics,\n-                ItemTrait(_, _, ref generics, ..) => {\n+                ItemKind::Fn(.., ref generics, _) |\n+                ItemKind::Impl(_, _, _, ref generics, ..) |\n+                ItemKind::Ty(_, ref generics) |\n+                ItemKind::Enum(_, ref generics) |\n+                ItemKind::Struct(_, ref generics) |\n+                ItemKind::Union(_, ref generics) => generics,\n+                ItemKind::Trait(_, _, ref generics, ..) => {\n                     // Implied `Self: Trait` and supertrait bounds.\n                     if param_id == item_node_id {\n                         result.predicates.push(\n@@ -365,11 +365,11 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n     let def_id = tcx.hir.local_def_id(item_id);\n     match it.node {\n         // These don't define types.\n-        hir::ItemExternCrate(_) |\n-        hir::ItemUse(..) |\n-        hir::ItemMod(_) |\n-        hir::ItemGlobalAsm(_) => {}\n-        hir::ItemForeignMod(ref foreign_mod) => {\n+        hir::ItemKind::ExternCrate(_) |\n+        hir::ItemKind::Use(..) |\n+        hir::ItemKind::Mod(_) |\n+        hir::ItemKind::GlobalAsm(_) => {}\n+        hir::ItemKind::ForeignMod(ref foreign_mod) => {\n             for item in &foreign_mod.items {\n                 let def_id = tcx.hir.local_def_id(item.id);\n                 tcx.generics_of(def_id);\n@@ -380,30 +380,30 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n                 }\n             }\n         }\n-        hir::ItemEnum(ref enum_definition, _) => {\n+        hir::ItemKind::Enum(ref enum_definition, _) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n             convert_enum_variant_types(tcx, def_id, &enum_definition.variants);\n         },\n-        hir::ItemImpl(..) => {\n+        hir::ItemKind::Impl(..) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.impl_trait_ref(def_id);\n             tcx.predicates_of(def_id);\n         },\n-        hir::ItemTrait(..) => {\n+        hir::ItemKind::Trait(..) => {\n             tcx.generics_of(def_id);\n             tcx.trait_def(def_id);\n             tcx.at(it.span).super_predicates_of(def_id);\n             tcx.predicates_of(def_id);\n         },\n-        hir::ItemTraitAlias(..) => {\n+        hir::ItemKind::TraitAlias(..) => {\n             span_err!(tcx.sess, it.span, E0645,\n                       \"trait aliases are not yet implemented (see issue #41517)\");\n         },\n-        hir::ItemStruct(ref struct_def, _) |\n-        hir::ItemUnion(ref struct_def, _) => {\n+        hir::ItemKind::Struct(ref struct_def, _) |\n+        hir::ItemKind::Union(ref struct_def, _) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n@@ -419,12 +419,12 @@ fn convert_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_id: ast::NodeId) {\n                 convert_variant_ctor(tcx, struct_def.id());\n             }\n         },\n-        hir::ItemExistential(..) => {}\n-        hir::ItemTy(..) | hir::ItemStatic(..) | hir::ItemConst(..) | hir::ItemFn(..) => {\n+        hir::ItemKind::Existential(..) => {}\n+        hir::ItemKind::Ty(..) | hir::ItemKind::Static(..) | hir::ItemKind::Const(..) | hir::ItemKind::Fn(..) => {\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n             tcx.predicates_of(def_id);\n-            if let hir::ItemFn(..) = it.node {\n+            if let hir::ItemKind::Fn(..) = it.node {\n                 tcx.fn_sig(def_id);\n             }\n         }\n@@ -561,7 +561,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let repr = ReprOptions::new(tcx, def_id);\n     let (kind, variants) = match item.node {\n-        ItemEnum(ref def, _) => {\n+        ItemKind::Enum(ref def, _) => {\n             let mut distance_from_explicit = 0;\n             (AdtKind::Enum, def.variants.iter().map(|v| {\n                 let did = tcx.hir.local_def_id(v.node.data.id());\n@@ -576,7 +576,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 convert_struct_variant(tcx, did, v.node.name, discr, &v.node.data)\n             }).collect())\n         }\n-        ItemStruct(ref def, _) => {\n+        ItemKind::Struct(ref def, _) => {\n             // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n             let ctor_id = if !def.is_struct() {\n                 Some(tcx.hir.local_def_id(def.id()))\n@@ -588,7 +588,7 @@ fn adt_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        ty::VariantDiscr::Relative(0), def)\n             ])\n         }\n-        ItemUnion(ref def, _) => {\n+        ItemKind::Union(ref def, _) => {\n             (AdtKind::Union, vec![\n                 convert_struct_variant(tcx, def_id, item.name,\n                                        ty::VariantDiscr::Relative(0), def)\n@@ -614,8 +614,8 @@ fn super_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n \n     let (generics, bounds) = match item.node {\n-        hir::ItemTrait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-        hir::ItemTraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+        hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n+        hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n         _ => span_bug!(item.span,\n                        \"super_predicates invoked on non-trait\"),\n     };\n@@ -658,8 +658,8 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let item = tcx.hir.expect_item(node_id);\n \n     let (is_auto, unsafety) = match item.node {\n-        hir::ItemTrait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n-        hir::ItemTraitAlias(..) => (false, hir::Unsafety::Normal),\n+        hir::ItemKind::Trait(is_auto, unsafety, ..) => (is_auto == hir::IsAuto::Yes, unsafety),\n+        hir::ItemKind::TraitAlias(..) => (false, hir::Unsafety::Normal),\n         _ => span_bug!(item.span, \"trait_def_of_item invoked on non-trait\"),\n     };\n \n@@ -779,7 +779,7 @@ fn has_late_bound_regions<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             _ => None,\n         },\n         hir_map::NodeItem(item) => match item.node {\n-            hir::ItemFn(ref fn_decl, .., ref generics, _) =>\n+            hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) =>\n                 has_late_bound_regions(tcx, generics, fn_decl),\n             _ => None,\n         },\n@@ -810,7 +810,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         NodeItem(item) => {\n             match item.node {\n-                ItemExistential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n+                ItemKind::Existential(hir::ExistTy { impl_trait_fn, .. }) => impl_trait_fn,\n                 _ => None,\n             }\n         },\n@@ -828,19 +828,19 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemFn(.., ref generics, _) |\n-                ItemImpl(_, _, _, ref generics, ..) => generics,\n-\n-                ItemTy(_, ref generics) |\n-                ItemEnum(_, ref generics) |\n-                ItemStruct(_, ref generics) |\n-                ItemExistential(hir::ExistTy { ref generics, .. }) |\n-                ItemUnion(_, ref generics) => {\n+                ItemKind::Fn(.., ref generics, _) |\n+                ItemKind::Impl(_, _, _, ref generics, ..) => generics,\n+\n+                ItemKind::Ty(_, ref generics) |\n+                ItemKind::Enum(_, ref generics) |\n+                ItemKind::Struct(_, ref generics) |\n+                ItemKind::Existential(hir::ExistTy { ref generics, .. }) |\n+                ItemKind::Union(_, ref generics) => {\n                     allow_defaults = true;\n                     generics\n                 }\n \n-                ItemTrait(_, _, ref generics, ..) | ItemTraitAlias(ref generics, ..) => {\n+                ItemKind::Trait(_, _, ref generics, ..) | ItemKind::TraitAlias(ref generics, ..) => {\n                     // Add in the self type parameter.\n                     //\n                     // Something of a hack: use the node id for the trait, also as\n@@ -1043,33 +1043,33 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemStatic(ref t, ..) | ItemConst(ref t, _) |\n-                ItemTy(ref t, _) | ItemImpl(.., ref t, _) => {\n+                ItemKind::Static(ref t, ..) | ItemKind::Const(ref t, _) |\n+                ItemKind::Ty(ref t, _) | ItemKind::Impl(.., ref t, _) => {\n                     icx.to_ty(t)\n                 }\n-                ItemFn(..) => {\n+                ItemKind::Fn(..) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_fn_def(def_id, substs)\n                 }\n-                ItemEnum(..) |\n-                ItemStruct(..) |\n-                ItemUnion(..) => {\n+                ItemKind::Enum(..) |\n+                ItemKind::Struct(..) |\n+                ItemKind::Union(..) => {\n                     let def = tcx.adt_def(def_id);\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     tcx.mk_adt(def, substs)\n                 }\n                 // this is only reachable once we have named existential types\n-                ItemExistential(hir::ExistTy { impl_trait_fn: None, .. }) => unimplemented!(),\n+                ItemKind::Existential(hir::ExistTy { impl_trait_fn: None, .. }) => unimplemented!(),\n                 // existential types desugared from impl Trait\n-                ItemExistential(hir::ExistTy { impl_trait_fn: Some(owner), .. }) => {\n+                ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(owner), .. }) => {\n                     tcx.typeck_tables_of(owner).concrete_existential_types[&def_id]\n                 },\n-                ItemTrait(..) | ItemTraitAlias(..) |\n-                ItemMod(..) |\n-                ItemForeignMod(..) |\n-                ItemGlobalAsm(..) |\n-                ItemExternCrate(..) |\n-                ItemUse(..) => {\n+                ItemKind::Trait(..) | ItemKind::TraitAlias(..) |\n+                ItemKind::Mod(..) |\n+                ItemKind::ForeignMod(..) |\n+                ItemKind::GlobalAsm(..) |\n+                ItemKind::ExternCrate(..) |\n+                ItemKind::Use(..) => {\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n@@ -1165,7 +1165,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             AstConv::ty_of_fn(&icx, sig.header.unsafety, sig.header.abi, &sig.decl)\n         }\n \n-        NodeItem(hir::Item { node: ItemFn(decl, header, _, _), .. }) => {\n+        NodeItem(hir::Item { node: ItemKind::Fn(decl, header, _, _), .. }) => {\n             AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl)\n         }\n \n@@ -1223,7 +1223,7 @@ fn impl_trait_ref<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     match tcx.hir.expect_item(node_id).node {\n-        hir::ItemImpl(.., ref opt_trait_ref, _, _) => {\n+        hir::ItemKind::Impl(.., ref opt_trait_ref, _, _) => {\n             opt_trait_ref.as_ref().map(|ast_trait_ref| {\n                 let selfty = tcx.type_of(def_id);\n                 AstConv::instantiate_mono_trait_ref(&icx, ast_trait_ref, selfty)\n@@ -1238,7 +1238,7 @@ fn impl_polarity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                            -> hir::ImplPolarity {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n     match tcx.hir.expect_item(node_id).node {\n-        hir::ItemImpl(_, polarity, ..) => polarity,\n+        hir::ItemKind::Impl(_, polarity, ..) => polarity,\n         ref item => bug!(\"impl_polarity: {:?} not an impl\", item)\n     }\n }\n@@ -1371,23 +1371,23 @@ fn explicit_predicates_of<'a, 'tcx>(\n \n         NodeItem(item) => {\n             match item.node {\n-                ItemImpl(_, _, defaultness, ref generics, ..) => {\n+                ItemKind::Impl(_, _, defaultness, ref generics, ..) => {\n                     if defaultness.is_default() {\n                         is_default_impl_trait = tcx.impl_trait_ref(def_id);\n                     }\n                     generics\n                 }\n-                ItemFn(.., ref generics, _) |\n-                ItemTy(_, ref generics) |\n-                ItemEnum(_, ref generics) |\n-                ItemStruct(_, ref generics) |\n-                ItemUnion(_, ref generics) => generics,\n+                ItemKind::Fn(.., ref generics, _) |\n+                ItemKind::Ty(_, ref generics) |\n+                ItemKind::Enum(_, ref generics) |\n+                ItemKind::Struct(_, ref generics) |\n+                ItemKind::Union(_, ref generics) => generics,\n \n-                ItemTrait(_, _, ref generics, .., ref items) => {\n+                ItemKind::Trait(_, _, ref generics, .., ref items) => {\n                     is_trait = Some((ty::TraitRef::identity(tcx, def_id), items));\n                     generics\n                 }\n-                ItemExistential(ref exist_ty) => {\n+                ItemKind::Existential(ref exist_ty) => {\n                     let substs = Substs::identity_for_item(tcx, def_id);\n                     let anon_ty = tcx.mk_anon(def_id, substs);\n \n@@ -1578,7 +1578,7 @@ fn explicit_predicates_of<'a, 'tcx>(\n     // before uses of `U`.  This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n-    if let NodeItem(&Item { node: ItemImpl(..), .. }) = node {\n+    if let NodeItem(&Item { node: ItemKind::Impl(..), .. }) = node {\n         let self_ty = tcx.type_of(def_id);\n         let trait_ref = tcx.impl_trait_ref(def_id);\n         ctp::setup_constraining_predicates(tcx,"}, {"sha": "b7921301957ce294fbd1faeb51805c3877fd672e", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -72,7 +72,7 @@ struct ImplWfCheck<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for ImplWfCheck<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n-            hir::ItemImpl(.., ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref impl_item_refs) => {\n                 let impl_def_id = self.tcx.hir.local_def_id(item.id);\n                 enforce_impl_params_are_constrained(self.tcx,\n                                                     impl_def_id,"}, {"sha": "e343fb1a57b1f294b0f3f512b4ccd41761ee8d4b", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -189,7 +189,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             match tcx.hir.find(main_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n-                        hir::ItemFn(.., ref generics, _) => {\n+                        hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;\n                             if !generics.params.is_empty() {\n                                 let msg = format!(\"`main` function is not allowed to have generic \\\n@@ -261,7 +261,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             match tcx.hir.find(start_id) {\n                 Some(hir_map::NodeItem(it)) => {\n                     match it.node {\n-                        hir::ItemFn(.., ref generics, _) => {\n+                        hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;\n                             if !generics.params.is_empty() {\n                                 struct_span_err!(tcx.sess, generics.span, E0132,"}, {"sha": "e378f1a2dce36e0a8b7dd12fc1273bdfe297f162", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -77,7 +77,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n \n         let mut item_required_predicates = RequiredPredicates::default();\n         match item.node {\n-            hir::ItemUnion(..) | hir::ItemEnum(..) | hir::ItemStruct(..) => {\n+            hir::ItemKind::Union(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Struct(..) => {\n                 let adt_def = self.tcx.adt_def(item_did);\n \n                 // Iterate over all fields in item_did"}, {"sha": "5801a6ada3f2f4e4c1f2d55bc150f06139812367", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -41,7 +41,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n \n     match tcx.hir.get(id) {\n         hir_map::NodeItem(item) => match item.node {\n-            hir::ItemStruct(..) | hir::ItemEnum(..) | hir::ItemUnion(..) => {\n+            hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n \n                 let predicates = crate_map"}, {"sha": "9fecf5e73e761ac1cdffaa5ef31f3e757b79bcd0", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -80,16 +80,16 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         match item.node {\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 self.visit_node_helper(item.id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n                     self.visit_node_helper(struct_def.id());\n                 }\n             }\n \n-            hir::ItemEnum(ref enum_def, _) => {\n+            hir::ItemKind::Enum(ref enum_def, _) => {\n                 self.visit_node_helper(item.id);\n \n                 for variant in &enum_def.variants {\n@@ -99,11 +99,11 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Fn(..) => {\n                 self.visit_node_helper(item.id);\n             }\n \n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n                         self.visit_node_helper(foreign_item.id);"}, {"sha": "3d70550c1dfb20603f7aa3aaf5c14220c8549ab5", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -62,10 +62,10 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n     };\n     match tcx.hir.get(id) {\n         hir::map::NodeItem(item) => match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) |\n-            hir::ItemFn(..) => {}\n+            hir::ItemKind::Enum(..) |\n+            hir::ItemKind::Struct(..) |\n+            hir::ItemKind::Union(..) |\n+            hir::ItemKind::Fn(..) => {}\n \n             _ => unsupported()\n         },"}, {"sha": "0aec31609b060dbd88d4d6de291c25853dbfbec6", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -142,16 +142,16 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                self.tcx.hir.node_to_string(item.id));\n \n         match item.node {\n-            hir::ItemStruct(ref struct_def, _) |\n-            hir::ItemUnion(ref struct_def, _) => {\n+            hir::ItemKind::Struct(ref struct_def, _) |\n+            hir::ItemKind::Union(ref struct_def, _) => {\n                 self.add_inferreds_for_item(item.id);\n \n                 if let hir::VariantData::Tuple(..) = *struct_def {\n                     self.add_inferreds_for_item(struct_def.id());\n                 }\n             }\n \n-            hir::ItemEnum(ref enum_def, _) => {\n+            hir::ItemKind::Enum(ref enum_def, _) => {\n                 self.add_inferreds_for_item(item.id);\n \n                 for variant in &enum_def.variants {\n@@ -161,11 +161,11 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ItemFn(..) => {\n+            hir::ItemKind::Fn(..) => {\n                 self.add_inferreds_for_item(item.id);\n             }\n \n-            hir::ItemForeignMod(ref foreign_mod) => {\n+            hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n                     if let hir::ForeignItemKind::Fn(..) = foreign_item.node {\n                         self.add_inferreds_for_item(foreign_item.id);"}, {"sha": "0cdab1348159d9da919f5b7fb16912dc94ac8e88", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -10,6 +10,7 @@\n \n use rustc::traits::auto_trait as auto;\n use rustc::ty::TypeFoldable;\n+use rustc::hir;\n use std::fmt::Debug;\n \n use super::*;\n@@ -65,9 +66,9 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         let did = self.cx.tcx.hir.local_def_id(id);\n \n         let def_ctor = match *item {\n-            hir::ItemStruct(_, _) => Def::Struct,\n-            hir::ItemUnion(_, _) => Def::Union,\n-            hir::ItemEnum(_, _) => Def::Enum,\n+            hir::ItemKind::Struct(_, _) => Def::Struct,\n+            hir::ItemKind::Union(_, _) => Def::Union,\n+            hir::ItemKind::Enum(_, _) => Def::Enum,\n             _ => panic!(\"Unexpected type {:?} {:?}\", item, id),\n         };\n \n@@ -216,7 +217,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n             let ty = hir::Ty {\n                 id: ast::DUMMY_NODE_ID,\n-                node: hir::TyKind::TyPath(hir::QPath::Resolved(None, P(new_path))),\n+                node: hir::TyKind::Path(hir::QPath::Resolved(None, P(new_path))),\n                 span: DUMMY_SP,\n                 hir_id: hir::DUMMY_HIR_ID,\n             };\n@@ -279,7 +280,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         debug!(\"ty_param_to_ty({:?}) {:?}\", param, param.def_id);\n         hir::Ty {\n             id: ast::DUMMY_NODE_ID,\n-            node: hir::TyKind::TyPath(hir::QPath::Resolved(\n+            node: hir::TyKind::Path(hir::QPath::Resolved(\n                 None,\n                 P(hir::Path {\n                     span: DUMMY_SP,"}, {"sha": "2bf1f6e553f3ddab6acc186990d9a5cf18594a1a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -283,10 +283,10 @@ impl Clean<ExternalCrate> for CrateNum {\n             cx.tcx.hir.krate().module.item_ids.iter().filter_map(|&id| {\n                 let item = cx.tcx.hir.expect_item(id.id);\n                 match item.node {\n-                    hir::ItemMod(_) => {\n+                    hir::ItemKind::Mod(_) => {\n                         as_primitive(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n                     }\n-                    hir::ItemUse(ref path, hir::UseKind::Single)\n+                    hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_primitive(path.def).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n@@ -325,10 +325,10 @@ impl Clean<ExternalCrate> for CrateNum {\n             cx.tcx.hir.krate().module.item_ids.iter().filter_map(|&id| {\n                 let item = cx.tcx.hir.expect_item(id.id);\n                 match item.node {\n-                    hir::ItemMod(_) => {\n+                    hir::ItemKind::Mod(_) => {\n                         as_keyword(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n                     }\n-                    hir::ItemUse(ref path, hir::UseKind::Single)\n+                    hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n                         as_keyword(path.def).map(|(_, prim, attrs)| {\n                             (cx.tcx.hir.local_def_id(id.id), prim, attrs)\n@@ -2852,9 +2852,9 @@ impl Clean<Type> for hir::Ty {\n     fn clean(&self, cx: &DocContext) -> Type {\n         use rustc::hir::*;\n         match self.node {\n-            TyNever => Never,\n-            TyPtr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n-            TyRptr(ref l, ref m) => {\n+            TyKind::Never => Never,\n+            TyKind::Ptr(ref m) => RawPointer(m.mutbl.clean(cx), box m.ty.clean(cx)),\n+            TyKind::Rptr(ref l, ref m) => {\n                 let lifetime = if l.is_elided() {\n                     None\n                 } else {\n@@ -2863,8 +2863,8 @@ impl Clean<Type> for hir::Ty {\n                 BorrowedRef {lifetime: lifetime, mutability: m.mutbl.clean(cx),\n                              type_: box m.ty.clean(cx)}\n             }\n-            TySlice(ref ty) => Slice(box ty.clean(cx)),\n-            TyArray(ref ty, ref length) => {\n+            TyKind::Slice(ref ty) => Slice(box ty.clean(cx)),\n+            TyKind::Array(ref ty, ref length) => {\n                 let def_id = cx.tcx.hir.local_def_id(length.id);\n                 let param_env = cx.tcx.param_env(def_id);\n                 let substs = Substs::identity_for_item(cx.tcx, def_id);\n@@ -2878,8 +2878,8 @@ impl Clean<Type> for hir::Ty {\n                 let length = print_const(cx, length);\n                 Array(box ty.clean(cx), length)\n             },\n-            TyTup(ref tys) => Tuple(tys.clean(cx)),\n-            TyPath(hir::QPath::Resolved(None, ref path)) => {\n+            TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n+            TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                 if let Some(new_ty) = cx.ty_substs.borrow().get(&path.def).cloned() {\n                     return new_ty;\n                 }\n@@ -2900,7 +2900,7 @@ impl Clean<Type> for hir::Ty {\n                     }\n                 };\n \n-                if let Some(&hir::ItemTy(ref ty, ref generics)) = alias {\n+                if let Some(&hir::ItemKind::Ty(ref ty, ref generics)) = alias {\n                     let provided_params = &path.segments.last().unwrap();\n                     let mut ty_substs = FxHashMap();\n                     let mut lt_substs = FxHashMap();\n@@ -2965,7 +2965,7 @@ impl Clean<Type> for hir::Ty {\n                 }\n                 resolve_type(cx, path.clean(cx), self.id)\n             }\n-            TyPath(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n+            TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n                 let mut segments: Vec<_> = p.segments.clone().into();\n                 segments.pop();\n                 let trait_path = hir::Path {\n@@ -2979,7 +2979,7 @@ impl Clean<Type> for hir::Ty {\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n-            TyPath(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n+            TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 let mut def = Def::Err;\n                 let ty = hir_ty_to_ty(cx.tcx, self);\n                 if let ty::TyProjection(proj) = ty.sty {\n@@ -2996,7 +2996,7 @@ impl Clean<Type> for hir::Ty {\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n             }\n-            TyTraitObject(ref bounds, ref lifetime) => {\n+            TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 match bounds[0].clean(cx).trait_ {\n                     ResolvedPath { path, typarams: None, did, is_generic } => {\n                         let mut bounds: Vec<self::GenericBound> = bounds[1..].iter().map(|bound| {\n@@ -3011,9 +3011,9 @@ impl Clean<Type> for hir::Ty {\n                     _ => Infer // shouldn't happen\n                 }\n             }\n-            TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyInfer | TyErr => Infer,\n-            TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n+            TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n+            TyKind::Infer | TyKind::Err => Infer,\n+            TyKind::Typeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }\n     }\n }\n@@ -4370,7 +4370,7 @@ pub fn path_to_def_local(tcx: &TyCtxt, path: &[&str]) -> Option<DefId> {\n                 }\n \n                 items = match &item.node {\n-                    &hir::ItemMod(ref m) => m.item_ids.clone(),\n+                    &hir::ItemKind::Mod(ref m) => m.item_ids.clone(),\n                     _ => panic!(\"Unexpected item {:?} in path {:?} path\")\n                 };\n                 break;"}, {"sha": "bd35cc0acda901de793133d5a7aa42bd95dbd792", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -706,7 +706,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n-        let name = if let hir::ItemImpl(.., ref ty, _) = item.node {\n+        let name = if let hir::ItemKind::Impl(.., ref ty, _) = item.node {\n             self.map.node_to_pretty_string(ty.id)\n         } else {\n             item.name.to_string()"}, {"sha": "875ba111ec002ebae6aaae2f7a33ffdbf537ee82", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b0cf56f3212d0ec5f6daa083b6738e39209b07c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=5b0cf56f3212d0ec5f6daa083b6738e39209b07c", "patch": "@@ -297,7 +297,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         if !self.view_item_stack.insert(def_node_id) { return false }\n \n         let ret = match tcx.hir.get(def_node_id) {\n-            hir_map::NodeItem(&hir::Item { node: hir::ItemMod(ref m), .. }) if glob => {\n+            hir_map::NodeItem(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n                     let i = self.cx.tcx.hir.expect_item(i.id);\n@@ -340,7 +340,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         }\n \n         match item.node {\n-            hir::ItemForeignMod(ref fm) => {\n+            hir::ItemKind::ForeignMod(ref fm) => {\n                 // If inlining we only want to include public functions.\n                 om.foreigns.push(if self.inlining {\n                     hir::ForeignMod {\n@@ -353,8 +353,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n             }\n             // If we're inlining, skip private items.\n             _ if self.inlining && !item.vis.node.is_pub() => {}\n-            hir::ItemGlobalAsm(..) => {}\n-            hir::ItemExternCrate(orig_name) => {\n+            hir::ItemKind::GlobalAsm(..) => {}\n+            hir::ItemKind::ExternCrate(orig_name) => {\n                 let def_id = self.cx.tcx.hir.local_def_id(item.id);\n                 om.extern_crates.push(ExternCrate {\n                     cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id)\n@@ -366,8 +366,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     whence: item.span,\n                 })\n             }\n-            hir::ItemUse(_, hir::UseKind::ListStem) => {}\n-            hir::ItemUse(ref path, kind) => {\n+            hir::ItemKind::Use(_, hir::UseKind::ListStem) => {}\n+            hir::ItemKind::Use(ref path, kind) => {\n                 let is_glob = kind == hir::UseKind::Glob;\n \n                 // struct and variant constructors always show up alongside their definitions, we've\n@@ -409,23 +409,23 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     whence: item.span,\n                 });\n             }\n-            hir::ItemMod(ref m) => {\n+            hir::ItemKind::Mod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n                                                      item.attrs.clone(),\n                                                      item.vis.clone(),\n                                                      item.id,\n                                                      m,\n                                                      Some(name)));\n             },\n-            hir::ItemEnum(ref ed, ref gen) =>\n+            hir::ItemKind::Enum(ref ed, ref gen) =>\n                 om.enums.push(self.visit_enum_def(item, name, ed, gen)),\n-            hir::ItemStruct(ref sd, ref gen) =>\n+            hir::ItemKind::Struct(ref sd, ref gen) =>\n                 om.structs.push(self.visit_variant_data(item, name, sd, gen)),\n-            hir::ItemUnion(ref sd, ref gen) =>\n+            hir::ItemKind::Union(ref sd, ref gen) =>\n                 om.unions.push(self.visit_union_data(item, name, sd, gen)),\n-            hir::ItemFn(ref fd, header, ref gen, body) =>\n+            hir::ItemKind::Fn(ref fd, header, ref gen, body) =>\n                 om.fns.push(self.visit_fn(item, name, &**fd, header, gen, body)),\n-            hir::ItemTy(ref ty, ref gen) => {\n+            hir::ItemKind::Ty(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),\n                     gen: gen.clone(),\n@@ -439,7 +439,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 };\n                 om.typedefs.push(t);\n             },\n-            hir::ItemStatic(ref ty, ref mut_, ref exp) => {\n+            hir::ItemKind::Static(ref ty, ref mut_, ref exp) => {\n                 let s = Static {\n                     type_: ty.clone(),\n                     mutability: mut_.clone(),\n@@ -454,7 +454,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 };\n                 om.statics.push(s);\n             },\n-            hir::ItemConst(ref ty, ref exp) => {\n+            hir::ItemKind::Const(ref ty, ref exp) => {\n                 let s = Constant {\n                     type_: ty.clone(),\n                     expr: exp.clone(),\n@@ -468,7 +468,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 };\n                 om.constants.push(s);\n             },\n-            hir::ItemTrait(is_auto, unsafety, ref gen, ref b, ref item_ids) => {\n+            hir::ItemKind::Trait(is_auto, unsafety, ref gen, ref b, ref item_ids) => {\n                 let items = item_ids.iter()\n                                     .map(|ti| self.cx.tcx.hir.trait_item(ti.id).clone())\n                                     .collect();\n@@ -488,11 +488,11 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 };\n                 om.traits.push(t);\n             },\n-            hir::ItemTraitAlias(..) => {\n+            hir::ItemKind::TraitAlias(..) => {\n                 unimplemented!(\"trait objects are not yet implemented\")\n             },\n \n-            hir::ItemImpl(unsafety,\n+            hir::ItemKind::Impl(unsafety,\n                           polarity,\n                           defaultness,\n                           ref gen,\n@@ -523,7 +523,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                     om.impls.push(i);\n                 }\n             },\n-            hir::ItemExistential(_) => {\n+            hir::ItemKind::Existential(_) => {\n                 // FIXME(oli-obk): actually generate docs for real existential items\n             }\n         }"}]}