{"sha": "003382e4150984cb476047b3925edf8d75df2d59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMzM4MmU0MTUwOTg0Y2I0NzYwNDdiMzkyNWVkZjhkNzVkZjJkNTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-29T08:14:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-29T08:14:41Z"}, "message": "Auto merge of #59513 - Centril:rollup, r=Centril\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #58019 (Combine all builtin late lints and make lint checking parallel)\n - #59358 (Use `track_errors` instead of hand rolling)\n - #59394 (warn -> deny duplicate match bindings)\n - #59401 (bootstrap: build crates under libtest with -Z emit-stack-sizes)\n - #59423 (Visit path in `walk_mac`)\n - #59468 (musl: build toolchain libs with -fPIC)\n - #59476 (Use `SmallVec` in `TokenStreamBuilder`.)\n - #59496 (Remove unnecessary with_globals calls)\n - #59498 (Use 'write_all' instead of 'write' in example code)\n - #59503 (Stablize {f32,f64}::copysign().)\n - #59511 (Fix missed fn rename in #59284)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2d72c3517e7bb92371f2e7c01b379da97d185975", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d72c3517e7bb92371f2e7c01b379da97d185975"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/003382e4150984cb476047b3925edf8d75df2d59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/003382e4150984cb476047b3925edf8d75df2d59", "html_url": "https://github.com/rust-lang/rust/commit/003382e4150984cb476047b3925edf8d75df2d59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/003382e4150984cb476047b3925edf8d75df2d59/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fec737f9aad565ef0351c38f147b78394b7a8ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fec737f9aad565ef0351c38f147b78394b7a8ac", "html_url": "https://github.com/rust-lang/rust/commit/4fec737f9aad565ef0351c38f147b78394b7a8ac"}, {"sha": "456fa39031f908490a112356373afa3535878a38", "url": "https://api.github.com/repos/rust-lang/rust/commits/456fa39031f908490a112356373afa3535878a38", "html_url": "https://github.com/rust-lang/rust/commit/456fa39031f908490a112356373afa3535878a38"}], "stats": {"total": 789, "additions": 472, "deletions": 317}, "files": [{"sha": "28c8a75a13ab4a5a94f7e379330b33d79ec736d6", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -181,6 +181,33 @@ fn main() {\n             cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));\n         }\n \n+        // Build all crates in the `std` facade with `-Z emit-stack-sizes` to add stack usage\n+        // information.\n+        //\n+        // When you use this `-Z` flag with Cargo you get stack usage information on all crates\n+        // compiled from source, and when you are using LTO you also get information on pre-compiled\n+        // crates like `core` and `std`, even if they were not compiled with `-Z emit-stack-sizes`.\n+        // However, there's an exception: `compiler_builtins`. This crate is special and doesn't\n+        // participate in LTO because it's always linked as a separate object file. For this reason\n+        // it's impossible to get stack usage information about `compiler-builtins` using\n+        // `RUSTFLAGS` + Cargo, or `cargo rustc`.\n+        //\n+        // To make the stack usage information of all crates under the `std` facade available to\n+        // Cargo based stack usage analysis tools, in both LTO and non-LTO mode, we compile them\n+        // with the `-Z emit-stack-sizes` flag. The `RUSTC_EMIT_STACK_SIZES` var helps us apply this\n+        // flag only to the crates in the `std` facade. The `-Z` flag is known to currently work\n+        // with targets that produce ELF files so we limit its use flag to those targets.\n+        //\n+        // NOTE(japaric) if this ever causes problem with an LLVM upgrade or any PR feel free to\n+        // remove it or comment it out\n+        if env::var_os(\"RUSTC_EMIT_STACK_SIZES\").is_some()\n+            && (target.contains(\"-linux-\")\n+                || target.contains(\"-none-eabi\")\n+                || target.ends_with(\"-none-elf\"))\n+        {\n+            cmd.arg(\"-Zemit-stack-sizes\");\n+        }\n+\n         if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n             cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n         }"}, {"sha": "0d51d7c5ef3b8543952bea083da98cd457cbbdbd", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -97,6 +97,8 @@ impl Step for Std {\n         let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n         builder.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n+        // compile with `-Z emit-stack-sizes`; see bootstrap/src/rustc.rs for more details\n+        cargo.env(\"RUSTC_EMIT_STACK_SIZES\", \"1\");\n         run_cargo(builder,\n                   &mut cargo,\n                   &libstd_stamp(builder, compiler, target),\n@@ -382,6 +384,8 @@ impl Step for Test {\n         let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n+        // compile with `-Z emit-stack-sizes`; see bootstrap/src/rustc.rs for more details\n+        cargo.env(\"RUSTC_EMIT_STACK_SIZES\", \"1\");\n         run_cargo(builder,\n                   &mut cargo,\n                   &libtest_stamp(builder, compiler, target),"}, {"sha": "3caf2852ede4214ed1883deae0800efea60c9126", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -29,6 +29,10 @@ TARGET=$ARCH-linux-musl\n OUTPUT=/usr/local\n shift\n \n+# Ancient binutils versions don't understand debug symbols produced by more recent tools.\n+# Apparently applying `-fPIC` everywhere allows them to link successfully.\n+export CFLAGS=\"-fPIC $CFLAGS\"\n+\n git clone https://github.com/richfelker/musl-cross-make -b v0.9.7\n cd musl-cross-make\n "}, {"sha": "10a5c1479fa6a725f3da74e115f0809a41d2b2dd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -354,7 +354,7 @@ declare_lint! {\n \n declare_lint! {\n     pub DUPLICATE_MATCHER_BINDING_NAME,\n-    Warn,\n+    Deny,\n     \"duplicate macro matcher binding name\"\n }\n \n@@ -464,6 +464,7 @@ impl LintPass for HardwiredLints {\n             DEPRECATED_IN_FUTURE,\n             AMBIGUOUS_ASSOCIATED_ITEMS,\n             NESTED_IMPL_TRAIT,\n+            DUPLICATE_MATCHER_BINDING_NAME,\n         )\n     }\n }"}, {"sha": "e5eafd768bb0b5d5abdffa7a11512eaa3a0e70a6", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 255, "deletions": 194, "changes": 449, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -17,8 +17,8 @@\n use self::TargetLint::*;\n \n use std::slice;\n-use rustc_data_structures::sync::ReadGuard;\n-use crate::lint::{EarlyLintPass, EarlyLintPassObject, LateLintPassObject};\n+use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use crate::lint::{EarlyLintPass, LateLintPass, EarlyLintPassObject, LateLintPassObject};\n use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n@@ -27,7 +27,6 @@ use crate::rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use crate::session::{config, early_error, Session};\n use crate::ty::{self, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n-use crate::ty::query::Providers;\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n \n@@ -56,8 +55,8 @@ pub struct LintStore {\n     /// This is only `None` while performing a lint pass.\n     pre_expansion_passes: Option<Vec<EarlyLintPassObject>>,\n     early_passes: Option<Vec<EarlyLintPassObject>>,\n-    late_passes: Option<Vec<LateLintPassObject>>,\n-    late_module_passes: Option<Vec<LateLintPassObject>>,\n+    late_passes: Lock<Option<Vec<LateLintPassObject>>>,\n+    late_module_passes: Vec<LateLintPassObject>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n@@ -70,14 +69,6 @@ pub struct LintStore {\n     future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n }\n \n-pub struct LintSession<'a, PassObject> {\n-    /// Reference to the store of registered lints.\n-    lints: ReadGuard<'a, LintStore>,\n-\n-    /// Trait objects for each lint pass.\n-    passes: Option<Vec<PassObject>>,\n-}\n-\n /// Lints that are buffered up early on in the `Session` before the\n /// `LintLevels` is calculated\n #[derive(PartialEq, RustcEncodable, RustcDecodable, Debug)]\n@@ -152,8 +143,8 @@ impl LintStore {\n             lints: vec![],\n             pre_expansion_passes: Some(vec![]),\n             early_passes: Some(vec![]),\n-            late_passes: Some(vec![]),\n-            late_module_passes: Some(vec![]),\n+            late_passes: Lock::new(Some(vec![])),\n+            late_module_passes: vec![],\n             by_name: Default::default(),\n             future_incompatible: Default::default(),\n             lint_groups: Default::default(),\n@@ -203,13 +194,16 @@ impl LintStore {\n     pub fn register_late_pass(&mut self,\n                               sess: Option<&Session>,\n                               from_plugin: bool,\n+                              register_only: bool,\n                               per_module: bool,\n                               pass: LateLintPassObject) {\n         self.push_pass(sess, from_plugin, &pass);\n-        if per_module {\n-            self.late_module_passes.as_mut().unwrap().push(pass);\n-        } else {\n-            self.late_passes.as_mut().unwrap().push(pass);\n+        if !register_only {\n+            if per_module {\n+                self.late_module_passes.push(pass);\n+            } else {\n+                self.late_passes.lock().as_mut().unwrap().push(pass);\n+            }\n         }\n     }\n \n@@ -527,7 +521,7 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     pub access_levels: &'a AccessLevels,\n \n     /// The store of registered lints and the lint levels.\n-    lint_sess: LintSession<'tcx, LateLintPassObject>,\n+    lint_store: ReadGuard<'a, LintStore>,\n \n     last_node_with_lint_attrs: hir::HirId,\n \n@@ -538,6 +532,11 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     only_module: bool,\n }\n \n+pub struct LateContextAndPass<'a, 'tcx: 'a, T: LateLintPass<'a, 'tcx>> {\n+    context: LateContext<'a, 'tcx>,\n+    pass: T,\n+}\n+\n /// Context for lint checking of the AST, after expansion, before lowering to\n /// HIR.\n pub struct EarlyContext<'a> {\n@@ -550,7 +549,7 @@ pub struct EarlyContext<'a> {\n     builder: LintLevelsBuilder<'a>,\n \n     /// The store of registered lints and the lint levels.\n-    lint_sess: LintSession<'a, EarlyLintPassObject>,\n+    lint_store: ReadGuard<'a, LintStore>,\n \n     buffered: LintBuffer,\n }\n@@ -560,17 +559,6 @@ pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n     pass: T,\n }\n \n-/// Convenience macro for calling a `LintPass` method on every pass in the context.\n-macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    // Move the vector of passes out of `$cx` so that we can\n-    // iterate over it mutably while passing `$cx` to the methods.\n-    let mut passes = $cx.lint_sess_mut().passes.take().unwrap();\n-    for obj in &mut passes {\n-        obj.$f($cx, $($args),*);\n-    }\n-    $cx.lint_sess_mut().passes = Some(passes);\n-}) }\n-\n pub trait LintPassObject: Sized {}\n \n impl LintPassObject for EarlyLintPassObject {}\n@@ -582,8 +570,6 @@ pub trait LintContext<'tcx>: Sized {\n \n     fn sess(&self) -> &Session;\n     fn lints(&self) -> &LintStore;\n-    fn lint_sess(&self) -> &LintSession<'tcx, Self::PassObject>;\n-    fn lint_sess_mut(&mut self) -> &mut LintSession<'tcx, Self::PassObject>;\n \n     fn lookup_and_emit<S: Into<MultiSpan>>(&self,\n                                            lint: &'static Lint,\n@@ -658,16 +644,17 @@ impl<'a> EarlyContext<'a> {\n         EarlyContext {\n             sess,\n             krate,\n-            lint_sess: LintSession {\n-                lints: sess.lint_store.borrow(),\n-                passes: None,\n-            },\n+            lint_store: sess.lint_store.borrow(),\n             builder: LintLevelSets::builder(sess),\n             buffered,\n         }\n     }\n }\n \n+macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    $cx.pass.$f(&$cx.context, $($args),*);\n+}) }\n+\n macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     $cx.pass.$f(&$cx.context, $($args),*);\n }) }\n@@ -721,15 +708,7 @@ impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn lints(&self) -> &LintStore {\n-        &*self.lint_sess.lints\n-    }\n-\n-    fn lint_sess(&self) -> &LintSession<'tcx, Self::PassObject> {\n-        &self.lint_sess\n-    }\n-\n-    fn lint_sess_mut(&mut self) -> &mut LintSession<'tcx, Self::PassObject> {\n-        &mut self.lint_sess\n+        &*self.lint_store\n     }\n \n     fn lookup<S: Into<MultiSpan>>(&self,\n@@ -757,15 +736,7 @@ impl<'a> LintContext<'a> for EarlyContext<'a> {\n     }\n \n     fn lints(&self) -> &LintStore {\n-        &*self.lint_sess.lints\n-    }\n-\n-    fn lint_sess(&self) -> &LintSession<'a, Self::PassObject> {\n-        &self.lint_sess\n-    }\n-\n-    fn lint_sess_mut(&mut self) -> &mut LintSession<'a, Self::PassObject> {\n-        &mut self.lint_sess\n+        &*self.lint_store\n     }\n \n     fn lookup<S: Into<MultiSpan>>(&self,\n@@ -778,6 +749,21 @@ impl<'a> LintContext<'a> for EarlyContext<'a> {\n }\n \n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n+    pub fn current_lint_root(&self) -> hir::HirId {\n+        self.last_node_with_lint_attrs\n+    }\n+}\n+\n+impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n+    type Ty = Ty<'tcx>;\n+    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+\n+    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.tcx.layout_of(self.param_env.and(ty))\n+    }\n+}\n+\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n     /// Merge the lints specified by any lint attributes into the\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n@@ -787,107 +773,98 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                           f: F)\n         where F: FnOnce(&mut Self)\n     {\n-        let prev = self.last_node_with_lint_attrs;\n-        self.last_node_with_lint_attrs = id;\n+        let prev = self.context.last_node_with_lint_attrs;\n+        self.context.last_node_with_lint_attrs = id;\n         self.enter_attrs(attrs);\n         f(self);\n         self.exit_attrs(attrs);\n-        self.last_node_with_lint_attrs = prev;\n-    }\n-\n-    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: enter_attrs({:?})\", attrs);\n-        run_lints!(self, enter_lint_attrs, attrs);\n-    }\n-\n-    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: exit_attrs({:?})\", attrs);\n-        run_lints!(self, exit_lint_attrs, attrs);\n+        self.context.last_node_with_lint_attrs = prev;\n     }\n \n     fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n         where F: FnOnce(&mut Self),\n     {\n-        let old_param_env = self.param_env;\n-        self.param_env = self.tcx.param_env(self.tcx.hir().local_def_id_from_hir_id(id));\n+        let old_param_env = self.context.param_env;\n+        self.context.param_env = self.context.tcx.param_env(\n+            self.context.tcx.hir().local_def_id_from_hir_id(id)\n+        );\n         f(self);\n-        self.param_env = old_param_env;\n-    }\n-    pub fn current_lint_root(&self) -> hir::HirId {\n-        self.last_node_with_lint_attrs\n+        self.context.param_env = old_param_env;\n     }\n \n     fn process_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n-        run_lints!(self, check_mod, m, s, n);\n+        lint_callback!(self, check_mod, m, s, n);\n         hir_visit::walk_mod(self, m, n);\n-        run_lints!(self, check_mod_post, m, s, n);\n+        lint_callback!(self, check_mod_post, m, s, n);\n     }\n-}\n \n-impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n-    type Ty = Ty<'tcx>;\n-    type TyLayout = Result<TyLayout<'tcx>, LayoutError<'tcx>>;\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: enter_attrs({:?})\", attrs);\n+        lint_callback!(self, enter_lint_attrs, attrs);\n+    }\n \n-    fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n-        self.tcx.layout_of(self.param_env.and(ty))\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: exit_attrs({:?})\", attrs);\n+        lint_callback!(self, exit_lint_attrs, attrs);\n     }\n }\n \n-impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n+for LateContextAndPass<'a, 'tcx, T> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n     fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n-        hir_visit::NestedVisitorMap::All(&self.tcx.hir())\n+        hir_visit::NestedVisitorMap::All(&self.context.tcx.hir())\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body);\n-        let body = self.tcx.hir().body(body);\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body);\n+        let body = self.context.tcx.hir().body(body);\n         self.visit_body(body);\n-        self.tables = old_tables;\n+        self.context.tables = old_tables;\n     }\n \n     fn visit_body(&mut self, body: &'tcx hir::Body) {\n-        run_lints!(self, check_body, body);\n+        lint_callback!(self, check_body, body);\n         hir_visit::walk_body(self, body);\n-        run_lints!(self, check_body_post, body);\n+        lint_callback!(self, check_body_post, body);\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n-        let generics = self.generics.take();\n-        self.generics = it.node.generics();\n+        let generics = self.context.generics.take();\n+        self.context.generics = it.node.generics();\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n-                run_lints!(cx, check_item, it);\n+                lint_callback!(cx, check_item, it);\n                 hir_visit::walk_item(cx, it);\n-                run_lints!(cx, check_item_post, it);\n+                lint_callback!(cx, check_item_post, it);\n             });\n         });\n-        self.generics = generics;\n+        self.context.generics = generics;\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n             cx.with_param_env(it.hir_id, |cx| {\n-                run_lints!(cx, check_foreign_item, it);\n+                lint_callback!(cx, check_foreign_item, it);\n                 hir_visit::walk_foreign_item(cx, it);\n-                run_lints!(cx, check_foreign_item_post, it);\n+                lint_callback!(cx, check_foreign_item_post, it);\n             });\n         })\n     }\n \n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n-        run_lints!(self, check_pat, p);\n+        lint_callback!(self, check_pat, p);\n         hir_visit::walk_pat(self, p);\n     }\n \n     fn visit_expr(&mut self, e: &'tcx hir::Expr) {\n         self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n-            run_lints!(cx, check_expr, e);\n+            lint_callback!(cx, check_expr, e);\n             hir_visit::walk_expr(cx, e);\n-            run_lints!(cx, check_expr_post, e);\n+            lint_callback!(cx, check_expr_post, e);\n         })\n     }\n \n@@ -897,21 +874,21 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         // - local\n         // - expression\n         // so we keep track of lint levels there\n-        run_lints!(self, check_stmt, s);\n+        lint_callback!(self, check_stmt, s);\n         hir_visit::walk_stmt(self, s);\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n                 body_id: hir::BodyId, span: Span, id: hir::HirId) {\n         // Wrap in tables here, not just in visit_nested_body,\n         // in order for `check_fn` to be able to use them.\n-        let old_tables = self.tables;\n-        self.tables = self.tcx.body_tables(body_id);\n-        let body = self.tcx.hir().body(body_id);\n-        run_lints!(self, check_fn, fk, decl, body, span, id);\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body_id);\n+        let body = self.context.tcx.hir().body(body_id);\n+        lint_callback!(self, check_fn, fk, decl, body, span, id);\n         hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n-        run_lints!(self, check_fn_post, fk, decl, body, span, id);\n-        self.tables = old_tables;\n+        lint_callback!(self, check_fn_post, fk, decl, body, span, id);\n+        self.context.tables = old_tables;\n     }\n \n     fn visit_variant_data(&mut self,\n@@ -920,14 +897,14 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                         g: &'tcx hir::Generics,\n                         item_id: hir::HirId,\n                         _: Span) {\n-        run_lints!(self, check_struct_def, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def, s, name, g, item_id);\n         hir_visit::walk_struct_def(self, s);\n-        run_lints!(self, check_struct_def_post, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def_post, s, name, g, item_id);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n         self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n-            run_lints!(cx, check_struct_field, s);\n+            lint_callback!(cx, check_struct_field, s);\n             hir_visit::walk_struct_field(cx, s);\n         })\n     }\n@@ -937,104 +914,104 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         self.with_lint_attrs(v.node.id, &v.node.attrs, |cx| {\n-            run_lints!(cx, check_variant, v, g);\n+            lint_callback!(cx, check_variant, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n-            run_lints!(cx, check_variant_post, v, g);\n+            lint_callback!(cx, check_variant_post, v, g);\n         })\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n-        run_lints!(self, check_ty, t);\n+        lint_callback!(self, check_ty, t);\n         hir_visit::walk_ty(self, t);\n     }\n \n     fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        run_lints!(self, check_name, sp, name);\n+        lint_callback!(self, check_name, sp, name);\n     }\n \n     fn visit_mod(&mut self, m: &'tcx hir::Mod, s: Span, n: hir::HirId) {\n-        if !self.only_module {\n+        if !self.context.only_module {\n             self.process_mod(m, s, n);\n         }\n     }\n \n     fn visit_local(&mut self, l: &'tcx hir::Local) {\n         self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n-            run_lints!(cx, check_local, l);\n+            lint_callback!(cx, check_local, l);\n             hir_visit::walk_local(cx, l);\n         })\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block) {\n-        run_lints!(self, check_block, b);\n+        lint_callback!(self, check_block, b);\n         hir_visit::walk_block(self, b);\n-        run_lints!(self, check_block_post, b);\n+        lint_callback!(self, check_block_post, b);\n     }\n \n     fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n-        run_lints!(self, check_arm, a);\n+        lint_callback!(self, check_arm, a);\n         hir_visit::walk_arm(self, a);\n     }\n \n     fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam) {\n-        run_lints!(self, check_generic_param, p);\n+        lint_callback!(self, check_generic_param, p);\n         hir_visit::walk_generic_param(self, p);\n     }\n \n     fn visit_generics(&mut self, g: &'tcx hir::Generics) {\n-        run_lints!(self, check_generics, g);\n+        lint_callback!(self, check_generics, g);\n         hir_visit::walk_generics(self, g);\n     }\n \n     fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate) {\n-        run_lints!(self, check_where_predicate, p);\n+        lint_callback!(self, check_where_predicate, p);\n         hir_visit::walk_where_predicate(self, p);\n     }\n \n     fn visit_poly_trait_ref(&mut self, t: &'tcx hir::PolyTraitRef,\n                             m: hir::TraitBoundModifier) {\n-        run_lints!(self, check_poly_trait_ref, t, m);\n+        lint_callback!(self, check_poly_trait_ref, t, m);\n         hir_visit::walk_poly_trait_ref(self, t, m);\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        let generics = self.generics.take();\n-        self.generics = Some(&trait_item.generics);\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&trait_item.generics);\n         self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n             cx.with_param_env(trait_item.hir_id, |cx| {\n-                run_lints!(cx, check_trait_item, trait_item);\n+                lint_callback!(cx, check_trait_item, trait_item);\n                 hir_visit::walk_trait_item(cx, trait_item);\n-                run_lints!(cx, check_trait_item_post, trait_item);\n+                lint_callback!(cx, check_trait_item_post, trait_item);\n             });\n         });\n-        self.generics = generics;\n+        self.context.generics = generics;\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n-        let generics = self.generics.take();\n-        self.generics = Some(&impl_item.generics);\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&impl_item.generics);\n         self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n             cx.with_param_env(impl_item.hir_id, |cx| {\n-                run_lints!(cx, check_impl_item, impl_item);\n+                lint_callback!(cx, check_impl_item, impl_item);\n                 hir_visit::walk_impl_item(cx, impl_item);\n-                run_lints!(cx, check_impl_item_post, impl_item);\n+                lint_callback!(cx, check_impl_item_post, impl_item);\n             });\n         });\n-        self.generics = generics;\n+        self.context.generics = generics;\n     }\n \n     fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n-        run_lints!(self, check_lifetime, lt);\n+        lint_callback!(self, check_lifetime, lt);\n         hir_visit::walk_lifetime(self, lt);\n     }\n \n     fn visit_path(&mut self, p: &'tcx hir::Path, id: hir::HirId) {\n-        run_lints!(self, check_path, p, id);\n+        lint_callback!(self, check_path, p, id);\n         hir_visit::walk_path(self, p);\n     }\n \n     fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n-        run_lints!(self, check_attribute, attr);\n+        lint_callback!(self, check_attribute, attr);\n     }\n }\n \n@@ -1222,94 +1199,179 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n }\n \n-pub fn lint_mod<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n-    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n+struct LateLintPassObjects<'a> {\n+    lints: &'a mut [LateLintPassObject],\n+}\n \n-    let store = &tcx.sess.lint_store;\n-    let passes = store.borrow_mut().late_module_passes.take();\n+impl LintPass for LateLintPassObjects<'_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n \n-    let mut cx = LateContext {\n+    fn get_lints(&self) -> LintArray {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! expand_late_lint_pass_impl_methods {\n+    ([$a:tt, $hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &LateContext<$a, $hir>, $($param: $arg),*) {\n+            for obj in self.lints.iter_mut() {\n+                obj.$name(context, $($param),*);\n+            }\n+        })*\n+    )\n+}\n+\n+macro_rules! late_lint_pass_impl {\n+    ([], [$hir:tt], $methods:tt) => (\n+        impl LateLintPass<'a, $hir> for LateLintPassObjects<'_> {\n+            expand_late_lint_pass_impl_methods!(['a, $hir], $methods);\n+        }\n+    )\n+}\n+\n+late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n+\n+fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    module_def_id: DefId,\n+    pass: T,\n+) {\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n+\n+    let context = LateContext {\n         tcx,\n         tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n-        lint_sess: LintSession {\n-            lints: store.borrow(),\n-            passes,\n-        },\n+        lint_store: tcx.sess.lint_store.borrow(),\n         last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n         generics: None,\n         only_module: true,\n     };\n \n+    let mut cx = LateContextAndPass {\n+        context,\n+        pass\n+    };\n+\n     let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n     cx.process_mod(module, span, hir_id);\n \n     // Visit the crate attributes\n     if hir_id == hir::CRATE_HIR_ID {\n-        walk_list!(cx, visit_attribute, cx.tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID));\n+        walk_list!(cx, visit_attribute, tcx.hir().attrs_by_hir_id(hir::CRATE_HIR_ID));\n     }\n-\n-    // Put the lint store levels and passes back in the session.\n-    let passes = cx.lint_sess.passes;\n-    drop(cx.lint_sess.lints);\n-    store.borrow_mut().late_module_passes = passes;\n }\n \n-pub(crate) fn provide(providers: &mut Providers<'_>) {\n-    *providers = Providers {\n-        lint_mod,\n-        ..*providers\n-    };\n+pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    module_def_id: DefId,\n+    builtin_lints: T,\n+) {\n+    if tcx.sess.opts.debugging_opts.no_interleave_lints {\n+        // These passes runs in late_lint_crate with -Z no_interleave_lints\n+        return;\n+    }\n+\n+    late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n+\n+    let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n+                                .iter().map(|pass| pass.fresh_late_pass()).collect();\n+\n+    if !passes.is_empty() {\n+        late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n+    }\n }\n \n-fn lint_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    pass: T\n+) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n     let krate = tcx.hir().krate();\n-    let passes = tcx.sess.lint_store.borrow_mut().late_passes.take();\n-\n-    let passes = {\n-        let mut cx = LateContext {\n-            tcx,\n-            tables: &ty::TypeckTables::empty(None),\n-            param_env: ty::ParamEnv::empty(),\n-            access_levels,\n-            lint_sess: LintSession {\n-                passes,\n-                lints: tcx.sess.lint_store.borrow(),\n-            },\n-            last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n-            generics: None,\n-            only_module: false,\n-        };\n-\n-        // Visit the whole crate.\n-        cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n-            // since the root module isn't visited as an item (because it isn't an\n-            // item), warn for it here.\n-            run_lints!(cx, check_crate, krate);\n \n-            hir_visit::walk_crate(cx, krate);\n+    let context = LateContext {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        param_env: ty::ParamEnv::empty(),\n+        access_levels,\n+        lint_store: tcx.sess.lint_store.borrow(),\n+        last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n+        generics: None,\n+        only_module: false,\n+    };\n \n-            run_lints!(cx, check_crate_post, krate);\n-        });\n-        cx.lint_sess.passes\n+    let mut cx = LateContextAndPass {\n+        context,\n+        pass\n     };\n \n-    // Put the lint store levels and passes back in the session.\n-    tcx.sess.lint_store.borrow_mut().late_passes = passes;\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        lint_callback!(cx, check_crate, krate);\n+\n+        hir_visit::walk_crate(cx, krate);\n+\n+        lint_callback!(cx, check_crate_post, krate);\n+    })\n }\n \n-/// Performs lint checking on a crate.\n-pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    // Run per-module lints\n-    for &module in tcx.hir().krate().modules.keys() {\n-        tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    builtin_lints: T\n+) {\n+    let mut passes = tcx.sess.lint_store.borrow().late_passes.lock().take().unwrap();\n+\n+    if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n+        if !passes.is_empty() {\n+            late_lint_pass_crate(tcx, LateLintPassObjects { lints: &mut passes[..] });\n+        }\n+\n+        late_lint_pass_crate(tcx, builtin_lints);\n+    } else {\n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n+\n+        let mut passes: Vec<_> = tcx.sess.lint_store.borrow().late_module_passes\n+                                    .iter().map(|pass| pass.fresh_late_pass()).collect();\n+\n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n     }\n \n-    // Run whole crate non-incremental lints\n-    lint_crate(tcx);\n+    // Put the passes back in the session.\n+    *tcx.sess.lint_store.borrow().late_passes.lock() = Some(passes);\n+}\n+\n+/// Performs lint checking on a crate.\n+pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    builtin_lints: impl FnOnce() -> T + Send,\n+) {\n+    join(|| {\n+        time(tcx.sess, \"crate lints\", || {\n+            // Run whole crate non-incremental lints\n+            late_lint_crate(tcx, builtin_lints());\n+        });\n+    }, || {\n+        time(tcx.sess, \"module lints\", || {\n+            // Run per-module lints\n+            par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n+                tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+            });\n+        });\n+    });\n }\n \n struct EarlyLintPassObjects<'a> {\n@@ -1346,7 +1408,6 @@ macro_rules! early_lint_pass_impl {\n \n early_lint_methods!(early_lint_pass_impl, []);\n \n-\n fn early_lint_crate<T: EarlyLintPass>(\n     sess: &Session,\n     krate: &ast::Crate,"}, {"sha": "a5506bb8f59f4b442e479a3dc85856e5f39a3a28", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -42,8 +42,8 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub use crate::lint::context::{LateContext, EarlyContext, LintContext, LintStore,\n-                        check_crate, check_ast_crate, CheckLintNameResult,\n-                        FutureIncompatibleInfo, BufferedEarlyLint};\n+                        check_crate, check_ast_crate, late_lint_mod, CheckLintNameResult,\n+                        FutureIncompatibleInfo, BufferedEarlyLint,};\n \n /// Specification of a single lint.\n #[derive(Copy, Clone, Debug)]\n@@ -273,6 +273,9 @@ macro_rules! expand_lint_pass_methods {\n macro_rules! declare_late_lint_pass {\n     ([], [$hir:tt], [$($methods:tt)*]) => (\n         pub trait LateLintPass<'a, $hir>: LintPass {\n+            fn fresh_late_pass(&self) -> LateLintPassObject {\n+                panic!()\n+            }\n             expand_lint_pass_methods!(&LateContext<'a, $hir>, [$($methods)*]);\n         }\n     )\n@@ -298,14 +301,14 @@ macro_rules! expand_combined_late_lint_pass_methods {\n \n #[macro_export]\n macro_rules! declare_combined_late_lint_pass {\n-    ([$name:ident, [$($passes:ident: $constructor:expr,)*]], [$hir:tt], $methods:tt) => (\n+    ([$v:vis $name:ident, [$($passes:ident: $constructor:expr,)*]], [$hir:tt], $methods:tt) => (\n         #[allow(non_snake_case)]\n-        struct $name {\n+        $v struct $name {\n             $($passes: $passes,)*\n         }\n \n         impl $name {\n-            fn new() -> Self {\n+            $v fn new() -> Self {\n                 Self {\n                     $($passes: $constructor,)*\n                 }\n@@ -824,7 +827,6 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'a, 'tcx> {\n \n pub fn provide(providers: &mut Providers<'_>) {\n     providers.lint_levels = lint_levels;\n-    context::provide(providers);\n }\n \n /// Returns whether `span` originates in a foreign crate's external macro."}, {"sha": "245a2bf92d530f22415937942bc277ea6fcdcd09", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -136,14 +136,12 @@ where\n     F: FnOnce(&Compiler) -> R + Send,\n     R: Send,\n {\n-    syntax::with_globals(move || {\n-        let stderr = config.stderr.take();\n-        util::spawn_thread_pool(\n-            config.opts.debugging_opts.threads,\n-            &stderr,\n-            || run_compiler_in_existing_thread_pool(config, f),\n-        )\n-    })\n+    let stderr = config.stderr.take();\n+    util::spawn_thread_pool(\n+        config.opts.debugging_opts.threads,\n+        &stderr,\n+        || run_compiler_in_existing_thread_pool(config, f),\n+    )\n }\n \n pub fn default_thread_pool<F, R>(f: F) -> R"}, {"sha": "1547e15fd48c579733e8d0ed9828100496a5c312", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -330,7 +330,7 @@ pub fn register_plugins<'a>(\n         ls.register_early_pass(Some(sess), true, false, pass);\n     }\n     for pass in late_lint_passes {\n-        ls.register_late_pass(Some(sess), true, false, pass);\n+        ls.register_late_pass(Some(sess), true, false, false, pass);\n     }\n \n     for (name, (to, deprecated_name)) in lint_groups {\n@@ -783,6 +783,7 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     middle::entry::provide(providers);\n     cstore::provide(providers);\n     lint::provide(providers);\n+    rustc_lint::provide(providers);\n }\n \n pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n@@ -988,7 +989,9 @@ fn analysis<'tcx>(\n                     stability::check_unused_or_stable_features(tcx)\n                 });\n             }, {\n-                time(sess, \"lint checking\", || lint::check_crate(tcx));\n+                time(sess, \"lint checking\", || {\n+                    lint::check_crate(tcx, || rustc_lint::BuiltinCombinedLateLintPass::new());\n+                });\n             });\n         }, {\n             time(sess, \"privacy checking modules\", || {"}, {"sha": "c9301a32d83c4f747978ddff1e189a94ef382da8", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 114, "deletions": 71, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -45,6 +45,9 @@ use rustc::lint::builtin::{\n };\n use rustc::session;\n use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n \n use syntax::ast;\n use syntax::edition::Edition;\n@@ -62,6 +65,17 @@ use unused::*;\n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n \n+pub fn provide(providers: &mut Providers<'_>) {\n+    *providers = Providers {\n+        lint_mod,\n+        ..*providers\n+    };\n+}\n+\n+fn lint_mod<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>, module_def_id: DefId) {\n+    lint::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n+}\n+\n macro_rules! pre_expansion_lint_passes {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n@@ -94,6 +108,88 @@ macro_rules! declare_combined_early_pass {\n pre_expansion_lint_passes!(declare_combined_early_pass, [BuiltinCombinedPreExpansionLintPass]);\n early_lint_passes!(declare_combined_early_pass, [BuiltinCombinedEarlyLintPass]);\n \n+macro_rules! late_lint_passes {\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            // FIXME: Look into regression when this is used as a module lint\n+            // May Depend on constants elsewhere\n+            UnusedBrokenConst: UnusedBrokenConst,\n+\n+            // Uses attr::is_used which is untracked, can't be an incremental module pass.\n+            UnusedAttributes: UnusedAttributes,\n+\n+            // Needs to run after UnusedAttributes as it marks all `feature` attributes as used.\n+            UnstableFeatures: UnstableFeatures,\n+\n+            // Tracks state across modules\n+            UnnameableTestItems: UnnameableTestItems::new(),\n+\n+            // Tracks attributes of parents\n+            MissingDoc: MissingDoc::new(),\n+\n+            // Depends on access levels\n+            // FIXME: Turn the computation of types which implement Debug into a query\n+            // and change this to a module lint pass\n+            MissingDebugImplementations: MissingDebugImplementations::new(),\n+        ]);\n+    )\n+}\n+\n+macro_rules! late_lint_mod_passes {\n+    ($macro:path, $args:tt) => (\n+        $macro!($args, [\n+            HardwiredLints: HardwiredLints,\n+            WhileTrue: WhileTrue,\n+            ImproperCTypes: ImproperCTypes,\n+            VariantSizeDifferences: VariantSizeDifferences,\n+            BoxPointers: BoxPointers,\n+            PathStatements: PathStatements,\n+\n+            // Depends on referenced function signatures in expressions\n+            UnusedResults: UnusedResults,\n+\n+            NonUpperCaseGlobals: NonUpperCaseGlobals,\n+            NonShorthandFieldPatterns: NonShorthandFieldPatterns,\n+            UnusedAllocation: UnusedAllocation,\n+\n+            // Depends on types used in type definitions\n+            MissingCopyImplementations: MissingCopyImplementations,\n+\n+            PluginAsLibrary: PluginAsLibrary,\n+\n+            // Depends on referenced function signatures in expressions\n+            MutableTransmutes: MutableTransmutes,\n+\n+            // Depends on types of fields, checks if they implement Drop\n+            UnionsWithDropFields: UnionsWithDropFields,\n+\n+            TypeAliasBounds: TypeAliasBounds,\n+\n+            TrivialConstraints: TrivialConstraints,\n+            TypeLimits: TypeLimits::new(),\n+\n+            NonSnakeCase: NonSnakeCase,\n+            InvalidNoMangleItems: InvalidNoMangleItems,\n+\n+            // Depends on access levels\n+            UnreachablePub: UnreachablePub,\n+\n+            ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n+        ]);\n+    )\n+}\n+\n+macro_rules! declare_combined_late_pass {\n+    ([$v:vis $name:ident], $passes:tt) => (\n+        late_lint_methods!(declare_combined_late_lint_pass, [$v $name, $passes], ['tcx]);\n+    )\n+}\n+\n+// FIXME: Make a separate lint type which do not require typeck tables\n+late_lint_passes!(declare_combined_late_pass, [pub BuiltinCombinedLateLintPass]);\n+\n+late_lint_mod_passes!(declare_combined_late_pass, [BuiltinCombinedModuleLateLintPass]);\n+\n /// Tell the `LintStore` about all the built-in lints (the ones\n /// defined in this crate and the ones defined in\n /// `rustc::lint::builtin`).\n@@ -104,17 +200,25 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         )\n     }\n \n+    macro_rules! register_pass {\n+        ($method:ident, $constructor:expr, [$($args:expr),*]) => (\n+            store.$method(sess, false, false, $($args,)* box $constructor);\n+        )\n+    }\n+\n     macro_rules! register_passes {\n-        ([$method:ident], [$($passes:ident: $constructor:expr,)*]) => (\n+        ([$method:ident, $args:tt], [$($passes:ident: $constructor:expr,)*]) => (\n             $(\n-                store.$method(sess, false, false, box $constructor);\n+                register_pass!($method, $constructor, $args);\n             )*\n         )\n     }\n \n     if sess.map(|sess| sess.opts.debugging_opts.no_interleave_lints).unwrap_or(false) {\n-        pre_expansion_lint_passes!(register_passes, [register_pre_expansion_pass]);\n-        early_lint_passes!(register_passes, [register_early_pass]);\n+        pre_expansion_lint_passes!(register_passes, [register_pre_expansion_pass, []]);\n+        early_lint_passes!(register_passes, [register_early_pass, []]);\n+        late_lint_passes!(register_passes, [register_late_pass, [false]]);\n+        late_lint_mod_passes!(register_passes, [register_late_pass, [true]]);\n     } else {\n         store.register_pre_expansion_pass(\n             sess,\n@@ -123,75 +227,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             box BuiltinCombinedPreExpansionLintPass::new()\n         );\n         store.register_early_pass(sess, false, true, box BuiltinCombinedEarlyLintPass::new());\n+        store.register_late_pass(\n+            sess, false, true, true, box BuiltinCombinedModuleLateLintPass::new()\n+        );\n+        store.register_late_pass(\n+            sess, false, true, false, box BuiltinCombinedLateLintPass::new()\n+        );\n     }\n \n-    late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedModuleLateLintPass, [\n-        HardwiredLints: HardwiredLints,\n-        WhileTrue: WhileTrue,\n-        ImproperCTypes: ImproperCTypes,\n-        VariantSizeDifferences: VariantSizeDifferences,\n-        BoxPointers: BoxPointers,\n-        PathStatements: PathStatements,\n-\n-        // Depends on referenced function signatures in expressions\n-        UnusedResults: UnusedResults,\n-\n-        NonUpperCaseGlobals: NonUpperCaseGlobals,\n-        NonShorthandFieldPatterns: NonShorthandFieldPatterns,\n-        UnusedAllocation: UnusedAllocation,\n-\n-        // Depends on types used in type definitions\n-        MissingCopyImplementations: MissingCopyImplementations,\n-\n-        PluginAsLibrary: PluginAsLibrary,\n-\n-        // Depends on referenced function signatures in expressions\n-        MutableTransmutes: MutableTransmutes,\n-\n-        // Depends on types of fields, checks if they implement Drop\n-        UnionsWithDropFields: UnionsWithDropFields,\n-\n-        TypeAliasBounds: TypeAliasBounds,\n-\n-        TrivialConstraints: TrivialConstraints,\n-        TypeLimits: TypeLimits::new(),\n-\n-        NonSnakeCase: NonSnakeCase,\n-        InvalidNoMangleItems: InvalidNoMangleItems,\n-\n-        // Depends on access levels\n-        UnreachablePub: UnreachablePub,\n-\n-        ExplicitOutlivesRequirements: ExplicitOutlivesRequirements,\n-    ]], ['tcx]);\n-\n-    store.register_late_pass(sess, false, true, box BuiltinCombinedModuleLateLintPass::new());\n-\n-    late_lint_methods!(declare_combined_late_lint_pass, [BuiltinCombinedLateLintPass, [\n-        // FIXME: Look into regression when this is used as a module lint\n-        // May Depend on constants elsewhere\n-        UnusedBrokenConst: UnusedBrokenConst,\n-\n-        // Uses attr::is_used which is untracked, can't be an incremental module pass.\n-        UnusedAttributes: UnusedAttributes,\n-\n-        // Needs to run after UnusedAttributes as it marks all `feature` attributes as used.\n-        UnstableFeatures: UnstableFeatures,\n-\n-        // Tracks state across modules\n-        UnnameableTestItems: UnnameableTestItems::new(),\n-\n-        // Tracks attributes of parents\n-        MissingDoc: MissingDoc::new(),\n-\n-        // Depends on access levels\n-        // FIXME: Turn the computation of types which implement Debug into a query\n-        // and change this to a module lint pass\n-        MissingDebugImplementations: MissingDebugImplementations::new(),\n-    ]], ['tcx]);\n-\n-    store.register_late_pass(sess, false, false, box BuiltinCombinedLateLintPass::new());\n-\n     add_lint_group!(sess,\n                     \"nonstandard_style\",\n                     NON_CAMEL_CASE_TYPES,"}, {"sha": "2268568c5f82d1431a12b3c1bbb3ede351cf295a", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -14,6 +14,7 @@ use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n+use rustc::util::common::ErrorReported;\n use rustc_data_structures::fx::FxHashMap;\n \n use syntax::ast::Mutability;\n@@ -641,16 +642,21 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n         let err = error_to_const_error(&ecx, error);\n         // errors in statics are always emitted as fatal errors\n         if tcx.is_static(def_id).is_some() {\n-            let reported_err = err.report_as_error(ecx.tcx,\n-                                                   \"could not evaluate static initializer\");\n             // Ensure that if the above error was either `TooGeneric` or `Reported`\n             // an error must be reported.\n-            if tcx.sess.err_count() == 0 {\n-                tcx.sess.delay_span_bug(err.span,\n+            let reported_err = tcx.sess.track_errors(|| {\n+                err.report_as_error(ecx.tcx,\n+                                    \"could not evaluate static initializer\")\n+            });\n+            match reported_err {\n+                Ok(v) => {\n+                    tcx.sess.delay_span_bug(err.span,\n                                         &format!(\"static eval failure did not emit an error: {:#?}\",\n-                                                 reported_err));\n+                                        v));\n+                    v\n+                },\n+                Err(ErrorReported) => ErrorHandled::Reported,\n             }\n-            reported_err\n         } else if def_id.is_local() {\n             // constant defined in this crate, we can figure out a lint level!\n             match tcx.describe_def(def_id) {"}, {"sha": "2ebb465d53dbe6cfee84e0700bbef08b2a61a49f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -443,7 +443,7 @@ where R: 'static + Send,\n \n     let (tx, rx) = channel();\n \n-    let result = rustc_driver::report_ices_to_stderr_if_any(move || syntax::with_globals(move || {\n+    let result = rustc_driver::report_ices_to_stderr_if_any(move || {\n         let crate_name = options.crate_name.clone();\n         let crate_version = options.crate_version.clone();\n         let (mut krate, renderinfo, renderopts, passes) = core::run_core(options);\n@@ -462,7 +462,7 @@ where R: 'static + Send,\n             renderopts,\n             passes: passes\n         })).unwrap();\n-    }));\n+    });\n \n     match result {\n         Ok(()) => rx.recv().unwrap(),"}, {"sha": "2952c6aea0023bbb3ba306da6893d87d3d34b13c", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -202,7 +202,6 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(copysign)]\n     /// use std::f32;\n     ///\n     /// let f = 3.5_f32;\n@@ -216,7 +215,7 @@ impl f32 {\n     /// ```\n     #[inline]\n     #[must_use]\n-    #[unstable(feature=\"copysign\", issue=\"55169\")]\n+    #[stable(feature = \"copysign\", since = \"1.35.0\")]\n     pub fn copysign(self, y: f32) -> f32 {\n         unsafe { intrinsics::copysignf32(self, y) }\n     }"}, {"sha": "3c3a35573adaa106ac36249dd98a38801d27cb1e", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -180,7 +180,6 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(copysign)]\n     /// use std::f64;\n     ///\n     /// let f = 3.5_f64;\n@@ -194,7 +193,7 @@ impl f64 {\n     /// ```\n     #[inline]\n     #[must_use]\n-    #[unstable(feature=\"copysign\", issue=\"55169\")]\n+    #[stable(feature = \"copysign\", since = \"1.35.0\")]\n     pub fn copysign(self, y: f64) -> f64 {\n         unsafe { intrinsics::copysignf64(self, y) }\n     }"}, {"sha": "14c850b6b054740426ad3fe1dcd233e35ef97470", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -1151,7 +1151,7 @@ pub trait Write {\n     /// fn main() -> std::io::Result<()> {\n     ///     let mut buffer = BufWriter::new(File::create(\"foo.txt\")?);\n     ///\n-    ///     buffer.write(b\"some bytes\")?;\n+    ///     buffer.write_all(b\"some bytes\")?;\n     ///     buffer.flush()?;\n     ///     Ok(())\n     /// }"}, {"sha": "7e151041a9ea857853ef444480cbb599b4063d87", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -405,7 +405,7 @@ pub struct StdoutLock<'a> {\n /// use std::io::{self, Write};\n ///\n /// fn main() -> io::Result<()> {\n-///     io::stdout().write(b\"hello world\")?;\n+///     io::stdout().write_all(b\"hello world\")?;\n ///\n ///     Ok(())\n /// }\n@@ -420,7 +420,7 @@ pub struct StdoutLock<'a> {\n ///     let stdout = io::stdout();\n ///     let mut handle = stdout.lock();\n ///\n-///     handle.write(b\"hello world\")?;\n+///     handle.write_all(b\"hello world\")?;\n ///\n ///     Ok(())\n /// }\n@@ -460,7 +460,7 @@ impl Stdout {\n     ///     let stdout = io::stdout();\n     ///     let mut handle = stdout.lock();\n     ///\n-    ///     handle.write(b\"hello world\")?;\n+    ///     handle.write_all(b\"hello world\")?;\n     ///\n     ///     Ok(())\n     /// }\n@@ -558,7 +558,7 @@ pub struct StderrLock<'a> {\n /// use std::io::{self, Write};\n ///\n /// fn main() -> io::Result<()> {\n-///     io::stderr().write(b\"hello world\")?;\n+///     io::stderr().write_all(b\"hello world\")?;\n ///\n ///     Ok(())\n /// }\n@@ -573,7 +573,7 @@ pub struct StderrLock<'a> {\n ///     let stderr = io::stderr();\n ///     let mut handle = stderr.lock();\n ///\n-///     handle.write(b\"hello world\")?;\n+///     handle.write_all(b\"hello world\")?;\n ///\n ///     Ok(())\n /// }\n@@ -613,7 +613,7 @@ impl Stderr {\n     ///     let stderr = io::stderr();\n     ///     let mut handle = stderr.lock();\n     ///\n-    ///     handle.write(b\"hello world\")?;\n+    ///     handle.write_all(b\"hello world\")?;\n     ///\n     ///     Ok(())\n     /// }"}, {"sha": "784303f3a65e8d4f3f630e5c16588a309cf614d2", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -268,7 +268,7 @@ mod tests {\n \n         #[inline(never)]\n         unsafe fn rwlock_new(init: &mut MaybeUninit<RWLock>) {\n-            init.set(RWLock::new());\n+            init.write(RWLock::new());\n         }\n \n         unsafe {"}, {"sha": "e99a86e807f7f6294e79356f1e777e65d6f7d728", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -6,6 +6,7 @@ use crate::parse::parser::{Parser, TokenType, PathStyle};\n use crate::tokenstream::{TokenStream, TokenTree};\n \n use log::debug;\n+use smallvec::smallvec;\n \n #[derive(Debug)]\n enum InnerAttributeParsePolicy<'a> {\n@@ -171,7 +172,7 @@ impl<'a> Parser<'a> {\n                 } else {\n                     self.parse_unsuffixed_lit()?.tokens()\n                 };\n-                TokenStream::from_streams(vec![eq.into(), tokens])\n+                TokenStream::from_streams(smallvec![eq.into(), tokens])\n             } else {\n                 TokenStream::empty()\n             };"}, {"sha": "2d47b982ebdd9b7140d1760d0206cc6cd3a1278b", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -24,6 +24,7 @@ use syntax_pos::{BytePos, Mark, Span, DUMMY_SP};\n use rustc_data_structures::static_assert;\n use rustc_data_structures::sync::Lrc;\n use serialize::{Decoder, Decodable, Encoder, Encodable};\n+use smallvec::{SmallVec, smallvec};\n \n use std::borrow::Cow;\n use std::{fmt, iter, mem};\n@@ -224,7 +225,7 @@ impl From<Token> for TokenStream {\n \n impl<T: Into<TokenStream>> iter::FromIterator<T> for TokenStream {\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Self {\n-        TokenStream::from_streams(iter.into_iter().map(Into::into).collect::<Vec<_>>())\n+        TokenStream::from_streams(iter.into_iter().map(Into::into).collect::<SmallVec<_>>())\n     }\n }\n \n@@ -256,7 +257,7 @@ impl TokenStream {\n         }\n     }\n \n-    pub(crate) fn from_streams(mut streams: Vec<TokenStream>) -> TokenStream {\n+    pub(crate) fn from_streams(mut streams: SmallVec<[TokenStream; 2]>) -> TokenStream {\n         match streams.len() {\n             0 => TokenStream::empty(),\n             1 => streams.pop().unwrap(),\n@@ -393,12 +394,13 @@ impl TokenStream {\n     }\n }\n \n+// 99.5%+ of the time we have 1 or 2 elements in this vector.\n #[derive(Clone)]\n-pub struct TokenStreamBuilder(Vec<TokenStream>);\n+pub struct TokenStreamBuilder(SmallVec<[TokenStream; 2]>);\n \n impl TokenStreamBuilder {\n     pub fn new() -> TokenStreamBuilder {\n-        TokenStreamBuilder(Vec::new())\n+        TokenStreamBuilder(SmallVec::new())\n     }\n \n     pub fn push<T: Into<TokenStream>>(&mut self, stream: T) {\n@@ -485,7 +487,7 @@ impl Cursor {\n         }\n         let index = self.index;\n         let stream = mem::replace(&mut self.stream, TokenStream(None));\n-        *self = TokenStream::from_streams(vec![stream, new_stream]).into_trees();\n+        *self = TokenStream::from_streams(smallvec![stream, new_stream]).into_trees();\n         self.index = index;\n     }\n \n@@ -572,7 +574,7 @@ mod tests {\n             let test_res = string_to_ts(\"foo::bar::baz\");\n             let test_fst = string_to_ts(\"foo::bar\");\n             let test_snd = string_to_ts(\"::baz\");\n-            let eq_res = TokenStream::from_streams(vec![test_fst, test_snd]);\n+            let eq_res = TokenStream::from_streams(smallvec![test_fst, test_snd]);\n             assert_eq!(test_res.trees().count(), 5);\n             assert_eq!(eq_res.trees().count(), 5);\n             assert_eq!(test_res.eq_unspanned(&eq_res), true);"}, {"sha": "fbd6641f7c20eed383435c313dc5602c74cdbd18", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -647,8 +647,8 @@ pub fn walk_stmt<'a, V: Visitor<'a>>(visitor: &mut V, statement: &'a Stmt) {\n     }\n }\n \n-pub fn walk_mac<'a, V: Visitor<'a>>(_: &mut V, _: &Mac) {\n-    // Empty!\n+pub fn walk_mac<'a, V: Visitor<'a>>(visitor: &mut V, mac: &'a Mac) {\n+    visitor.visit_path(&mac.node.path, DUMMY_NODE_ID);\n }\n \n pub fn walk_anon_const<'a, V: Visitor<'a>>(visitor: &mut V, constant: &'a AnonConst) {"}, {"sha": "22fee902aea262546694649e6edb2532858cc31b", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -317,7 +317,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n         self.in_root = prev_in_root;\n     }\n \n-    fn visit_mac(&mut self, mac: &ast::Mac) {\n+    fn visit_mac(&mut self, mac: &'a ast::Mac) {\n         visit::walk_mac(self, mac)\n     }\n }"}, {"sha": "23d566780c8554b4f4dbe7060b5822374854d45c", "filename": "src/test/ui/macros/macro-multiple-matcher-bindings.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Ftest%2Fui%2Fmacros%2Fmacro-multiple-matcher-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Ftest%2Fui%2Fmacros%2Fmacro-multiple-matcher-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-multiple-matcher-bindings.rs?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -6,6 +6,7 @@\n // compile-pass\n \n #![allow(unused_macros)]\n+#![warn(duplicate_matcher_binding_name)]\n \n macro_rules! foo1 {\n     ($a:ident, $a:ident) => {}; //~WARNING duplicate matcher binding"}, {"sha": "f7970dbd2eb22aa43ac1a99ab71e762b67b76045", "filename": "src/test/ui/macros/macro-multiple-matcher-bindings.stderr", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/003382e4150984cb476047b3925edf8d75df2d59/src%2Ftest%2Fui%2Fmacros%2Fmacro-multiple-matcher-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/003382e4150984cb476047b3925edf8d75df2d59/src%2Ftest%2Fui%2Fmacros%2Fmacro-multiple-matcher-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-multiple-matcher-bindings.stderr?ref=003382e4150984cb476047b3925edf8d75df2d59", "patch": "@@ -1,15 +1,19 @@\n warning: duplicate matcher binding\n-  --> $DIR/macro-multiple-matcher-bindings.rs:11:6\n+  --> $DIR/macro-multiple-matcher-bindings.rs:12:6\n    |\n LL |     ($a:ident, $a:ident) => {};\n    |      ^^^^^^^^  ^^^^^^^^\n    |\n-   = note: #[warn(duplicate_matcher_binding_name)] on by default\n+note: lint level defined here\n+  --> $DIR/macro-multiple-matcher-bindings.rs:9:9\n+   |\n+LL | #![warn(duplicate_matcher_binding_name)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #57593 <https://github.com/rust-lang/rust/issues/57593>\n \n warning: duplicate matcher binding\n-  --> $DIR/macro-multiple-matcher-bindings.rs:12:6\n+  --> $DIR/macro-multiple-matcher-bindings.rs:13:6\n    |\n LL |     ($a:ident, $a:path) => {};\n    |      ^^^^^^^^  ^^^^^^^\n@@ -18,7 +22,7 @@ LL |     ($a:ident, $a:path) => {};\n    = note: for more information, see issue #57593 <https://github.com/rust-lang/rust/issues/57593>\n \n warning: duplicate matcher binding\n-  --> $DIR/macro-multiple-matcher-bindings.rs:21:6\n+  --> $DIR/macro-multiple-matcher-bindings.rs:22:6\n    |\n LL |     ($a:ident, $($a:ident),*) => {};\n    |      ^^^^^^^^    ^^^^^^^^\n@@ -27,7 +31,7 @@ LL |     ($a:ident, $($a:ident),*) => {};\n    = note: for more information, see issue #57593 <https://github.com/rust-lang/rust/issues/57593>\n \n warning: duplicate matcher binding\n-  --> $DIR/macro-multiple-matcher-bindings.rs:22:8\n+  --> $DIR/macro-multiple-matcher-bindings.rs:23:8\n    |\n LL |     ($($a:ident)+ # $($($a:path),+);*) => {};\n    |        ^^^^^^^^         ^^^^^^^"}]}