{"sha": "c989287a34b8b27fa4880d27e698bd880631a794", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ODkyODdhMzRiOGIyN2ZhNDg4MGQyN2U2OThiZDg4MDYzMWE3OTQ=", "commit": {"author": {"name": "Brandon", "email": "brandondong604@hotmail.com", "date": "2021-04-07T05:09:26Z"}, "committer": {"name": "Brandon", "email": "brandondong604@hotmail.com", "date": "2021-04-09T03:58:29Z"}, "message": "Fix extract function's mutability of variables outliving the body", "tree": {"sha": "7f0744ca549d35986d1c01808028320ce02aac02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f0744ca549d35986d1c01808028320ce02aac02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c989287a34b8b27fa4880d27e698bd880631a794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c989287a34b8b27fa4880d27e698bd880631a794", "html_url": "https://github.com/rust-lang/rust/commit/c989287a34b8b27fa4880d27e698bd880631a794", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c989287a34b8b27fa4880d27e698bd880631a794/comments", "author": {"login": "brandondong", "id": 13722457, "node_id": "MDQ6VXNlcjEzNzIyNDU3", "avatar_url": "https://avatars.githubusercontent.com/u/13722457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brandondong", "html_url": "https://github.com/brandondong", "followers_url": "https://api.github.com/users/brandondong/followers", "following_url": "https://api.github.com/users/brandondong/following{/other_user}", "gists_url": "https://api.github.com/users/brandondong/gists{/gist_id}", "starred_url": "https://api.github.com/users/brandondong/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brandondong/subscriptions", "organizations_url": "https://api.github.com/users/brandondong/orgs", "repos_url": "https://api.github.com/users/brandondong/repos", "events_url": "https://api.github.com/users/brandondong/events{/privacy}", "received_events_url": "https://api.github.com/users/brandondong/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brandondong", "id": 13722457, "node_id": "MDQ6VXNlcjEzNzIyNDU3", "avatar_url": "https://avatars.githubusercontent.com/u/13722457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brandondong", "html_url": "https://github.com/brandondong", "followers_url": "https://api.github.com/users/brandondong/followers", "following_url": "https://api.github.com/users/brandondong/following{/other_user}", "gists_url": "https://api.github.com/users/brandondong/gists{/gist_id}", "starred_url": "https://api.github.com/users/brandondong/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brandondong/subscriptions", "organizations_url": "https://api.github.com/users/brandondong/orgs", "repos_url": "https://api.github.com/users/brandondong/repos", "events_url": "https://api.github.com/users/brandondong/events{/privacy}", "received_events_url": "https://api.github.com/users/brandondong/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72781085bba92756d11f9fcc3d879b60108d230f", "url": "https://api.github.com/repos/rust-lang/rust/commits/72781085bba92756d11f9fcc3d879b60108d230f", "html_url": "https://github.com/rust-lang/rust/commit/72781085bba92756d11f9fcc3d879b60108d230f"}], "stats": {"total": 128, "additions": 109, "deletions": 19}, "files": [{"sha": "af95437666ebacbf2b6265405ff8e904b3af6a59", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 109, "deletions": 19, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/c989287a34b8b27fa4880d27e698bd880631a794/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c989287a34b8b27fa4880d27e698bd880631a794/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=c989287a34b8b27fa4880d27e698bd880631a794", "patch": "@@ -75,7 +75,8 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n     let insert_after = scope_for_fn_insertion(&body, anchor)?;\n     let module = ctx.sema.scope(&insert_after).module()?;\n \n-    let vars_defined_in_body_and_outlive = vars_defined_in_body_and_outlive(ctx, &body);\n+    let vars_defined_in_body_and_outlive =\n+        vars_defined_in_body_and_outlive(ctx, &body, &node.parent().as_ref().unwrap_or(&node));\n     let ret_ty = body_return_ty(ctx, &body)?;\n \n     // FIXME: we compute variables that outlive here just to check `never!` condition\n@@ -257,7 +258,7 @@ struct Function {\n     control_flow: ControlFlow,\n     ret_ty: RetType,\n     body: FunctionBody,\n-    vars_defined_in_body_and_outlive: Vec<Local>,\n+    vars_defined_in_body_and_outlive: Vec<OutlivedLocal>,\n }\n \n #[derive(Debug)]\n@@ -296,9 +297,9 @@ impl Function {\n             RetType::Expr(ty) => FunType::Single(ty.clone()),\n             RetType::Stmt => match self.vars_defined_in_body_and_outlive.as_slice() {\n                 [] => FunType::Unit,\n-                [var] => FunType::Single(var.ty(ctx.db())),\n+                [var] => FunType::Single(var.local.ty(ctx.db())),\n                 vars => {\n-                    let types = vars.iter().map(|v| v.ty(ctx.db())).collect();\n+                    let types = vars.iter().map(|v| v.local.ty(ctx.db())).collect();\n                     FunType::Tuple(types)\n                 }\n             },\n@@ -562,6 +563,12 @@ impl HasTokenAtOffset for FunctionBody {\n     }\n }\n \n+#[derive(Debug)]\n+struct OutlivedLocal {\n+    local: Local,\n+    mut_usage_outside_body: bool,\n+}\n+\n /// Try to guess what user wants to extract\n ///\n /// We have basically have two cases:\n@@ -707,10 +714,10 @@ fn has_exclusive_usages(ctx: &AssistContext, usages: &LocalUsages, body: &Functi\n         .any(|reference| reference_is_exclusive(reference, body, ctx))\n }\n \n-/// checks if this reference requires `&mut` access inside body\n+/// checks if this reference requires `&mut` access inside node\n fn reference_is_exclusive(\n     reference: &FileReference,\n-    body: &FunctionBody,\n+    node: &dyn HasTokenAtOffset,\n     ctx: &AssistContext,\n ) -> bool {\n     // we directly modify variable with set: `n = 0`, `n += 1`\n@@ -719,7 +726,7 @@ fn reference_is_exclusive(\n     }\n \n     // we take `&mut` reference to variable: `&mut v`\n-    let path = match path_element_of_reference(body, reference) {\n+    let path = match path_element_of_reference(node, reference) {\n         Some(path) => path,\n         None => return false,\n     };\n@@ -820,10 +827,16 @@ fn vars_defined_in_body(body: &FunctionBody, ctx: &AssistContext) -> Vec<Local>\n }\n \n /// list local variables defined inside `body` that should be returned from extracted function\n-fn vars_defined_in_body_and_outlive(ctx: &AssistContext, body: &FunctionBody) -> Vec<Local> {\n-    let mut vars_defined_in_body = vars_defined_in_body(&body, ctx);\n-    vars_defined_in_body.retain(|var| var_outlives_body(ctx, body, var));\n+fn vars_defined_in_body_and_outlive(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    parent: &SyntaxNode,\n+) -> Vec<OutlivedLocal> {\n+    let vars_defined_in_body = vars_defined_in_body(&body, ctx);\n     vars_defined_in_body\n+        .into_iter()\n+        .filter_map(|var| var_outlives_body(ctx, body, var, parent))\n+        .collect()\n }\n \n /// checks if the relevant local was defined before(outside of) body\n@@ -843,11 +856,23 @@ fn either_syntax(value: &Either<ast::IdentPat, ast::SelfParam>) -> &SyntaxNode {\n     }\n }\n \n-/// checks if local variable is used after(outside of) body\n-fn var_outlives_body(ctx: &AssistContext, body: &FunctionBody, var: &Local) -> bool {\n-    let usages = LocalUsages::find(ctx, *var);\n+/// returns usage details if local variable is used after(outside of) body\n+fn var_outlives_body(\n+    ctx: &AssistContext,\n+    body: &FunctionBody,\n+    var: Local,\n+    parent: &SyntaxNode,\n+) -> Option<OutlivedLocal> {\n+    let usages = LocalUsages::find(ctx, var);\n     let has_usages = usages.iter().any(|reference| body.preceedes_range(reference.range));\n-    has_usages\n+    if !has_usages {\n+        return None;\n+    }\n+    let has_mut_usages = usages\n+        .iter()\n+        .filter(|reference| body.preceedes_range(reference.range))\n+        .any(|reference| reference_is_exclusive(reference, parent, ctx));\n+    Some(OutlivedLocal { local: var, mut_usage_outside_body: has_mut_usages })\n }\n \n fn body_return_ty(ctx: &AssistContext, body: &FunctionBody) -> Option<RetType> {\n@@ -927,16 +952,25 @@ fn format_replacement(ctx: &AssistContext, fun: &Function, indent: IndentLevel)\n     let mut buf = String::new();\n     match fun.vars_defined_in_body_and_outlive.as_slice() {\n         [] => {}\n-        [var] => format_to!(buf, \"let {} = \", var.name(ctx.db()).unwrap()),\n+        [var] => {\n+            format_to!(buf, \"let {}{} = \", mut_modifier(var), var.local.name(ctx.db()).unwrap())\n+        }\n         [v0, vs @ ..] => {\n             buf.push_str(\"let (\");\n-            format_to!(buf, \"{}\", v0.name(ctx.db()).unwrap());\n+            format_to!(buf, \"{}{}\", mut_modifier(v0), v0.local.name(ctx.db()).unwrap());\n             for var in vs {\n-                format_to!(buf, \", {}\", var.name(ctx.db()).unwrap());\n+                format_to!(buf, \", {}{}\", mut_modifier(var), var.local.name(ctx.db()).unwrap());\n             }\n             buf.push_str(\") = \");\n         }\n     }\n+    fn mut_modifier(var: &OutlivedLocal) -> &'static str {\n+        if var.mut_usage_outside_body {\n+            \"mut \"\n+        } else {\n+            \"\"\n+        }\n+    }\n     format_to!(buf, \"{}\", expr);\n     if fun.ret_ty.is_unit()\n         && (!fun.vars_defined_in_body_and_outlive.is_empty() || !expr.is_block_like())\n@@ -1199,10 +1233,10 @@ fn make_body(\n                 match fun.vars_defined_in_body_and_outlive.as_slice() {\n                     [] => {}\n                     [var] => {\n-                        tail_expr = Some(path_expr_from_local(ctx, *var));\n+                        tail_expr = Some(path_expr_from_local(ctx, var.local));\n                     }\n                     vars => {\n-                        let exprs = vars.iter().map(|var| path_expr_from_local(ctx, *var));\n+                        let exprs = vars.iter().map(|var| path_expr_from_local(ctx, var.local));\n                         let expr = make::expr_tuple(exprs);\n                         tail_expr = Some(expr);\n                     }\n@@ -2110,6 +2144,30 @@ fn $0fun_name(n: i32) -> i32 {\n         );\n     }\n \n+    #[test]\n+    fn variable_defined_inside_and_used_after_mutably_no_ret() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    $0let mut k = n * n;$0\n+    k += 1;\n+}\",\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    let mut k = fun_name(n);\n+    k += 1;\n+}\n+\n+fn $0fun_name(n: i32) -> i32 {\n+    let mut k = n * n;\n+    k\n+}\",\n+        );\n+    }\n+\n     #[test]\n     fn two_variables_defined_inside_and_used_after_no_ret() {\n         check_assist(\n@@ -2136,6 +2194,38 @@ fn $0fun_name(n: i32) -> (i32, i32) {\n         );\n     }\n \n+    #[test]\n+    fn multi_variables_defined_inside_and_used_after_mutably_no_ret() {\n+        check_assist(\n+            extract_function,\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    $0let mut k = n * n;\n+    let mut m = k + 2;\n+    let mut o = m + 3;\n+    o += 1;$0\n+    k += o;\n+    m = 1;\n+}\",\n+            r\"\n+fn foo() {\n+    let n = 1;\n+    let (mut k, mut m, o) = fun_name(n);\n+    k += o;\n+    m = 1;\n+}\n+\n+fn $0fun_name(n: i32) -> (i32, i32, i32) {\n+    let mut k = n * n;\n+    let mut m = k + 2;\n+    let mut o = m + 3;\n+    o += 1;\n+    (k, m, o)\n+}\",\n+        );\n+    }\n+\n     #[test]\n     fn nontrivial_patterns_define_variables() {\n         check_assist("}]}