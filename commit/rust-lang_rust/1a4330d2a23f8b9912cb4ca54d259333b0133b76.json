{"sha": "1a4330d2a23f8b9912cb4ca54d259333b0133b76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNDMzMGQyYTIzZjhiOTkxMmNiNGNhNTRkMjU5MzMzYjAxMzNiNzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-08-27T19:25:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-08-27T20:51:14Z"}, "message": "rustc: Handle modules in \"fat\" LTO more robustly\n\nWhen performing a \"fat\" LTO the compiler has a whole mess of codegen\nunits that it links together. To do this it needs to select one module\nas a \"base\" module and then link everything else into this module.\nPreviously LTO passes assume that there's at least one module in-memory\nto link into, but nowadays that's not always true! With incremental\ncompilation modules may actually largely be cached and it may be\npossible that there's no in-memory modules to work with.\n\nThis commit updates the logic of the LTO backend to handle modules a bit\nmore uniformly during a fat LTO. This commit immediately splits them\ninto two lists, one serialized and one in-memory. The in-memory list is\nthen searched for the largest module and failing that we simply\ndeserialize the first serialized module and link into that. This\nrefactoring avoids juggling three lists, two of which are serialized\nmodules and one of which is half serialized and half in-memory.\n\nCloses #63349", "tree": {"sha": "3ac71bea8b96a3e5ebd91339df0c709cdcafc4d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ac71bea8b96a3e5ebd91339df0c709cdcafc4d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a4330d2a23f8b9912cb4ca54d259333b0133b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a4330d2a23f8b9912cb4ca54d259333b0133b76", "html_url": "https://github.com/rust-lang/rust/commit/1a4330d2a23f8b9912cb4ca54d259333b0133b76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a4330d2a23f8b9912cb4ca54d259333b0133b76/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0396aace27eea97c3603e9683e921807dff2a314", "url": "https://api.github.com/repos/rust-lang/rust/commits/0396aace27eea97c3603e9683e921807dff2a314", "html_url": "https://github.com/rust-lang/rust/commit/0396aace27eea97c3603e9683e921807dff2a314"}], "stats": {"total": 108, "additions": 59, "deletions": 49}, "files": [{"sha": "a43fbb68dbaed76d7d5d3d858c8c591fee5f50f7", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=1a4330d2a23f8b9912cb4ca54d259333b0133b76", "patch": "@@ -183,14 +183,40 @@ pub(crate) fn prepare_thin(\n \n fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            diag_handler: &Handler,\n-           mut modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n+           modules: Vec<FatLTOInput<LlvmCodegenBackend>>,\n            cached_modules: Vec<(SerializedModule<ModuleBuffer>, WorkProduct)>,\n            mut serialized_modules: Vec<(SerializedModule<ModuleBuffer>, CString)>,\n            symbol_white_list: &[*const libc::c_char])\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n     info!(\"going for a fat lto\");\n \n+    // Sort out all our lists of incoming modules into two lists.\n+    //\n+    // * `serialized_modules` (also and argument to this function) contains all\n+    //   modules that are serialized in-memory.\n+    // * `in_memory` contains modules which are already parsed and in-memory,\n+    //   such as from multi-CGU builds.\n+    //\n+    // All of `cached_modules` (cached from previous incremental builds) can\n+    // immediately go onto the `serialized_modules` modules list and then we can\n+    // split the `modules` array into these two lists.\n+    let mut in_memory = Vec::new();\n+    serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n+        info!(\"pushing cached module {:?}\", wp.cgu_name);\n+        (buffer, CString::new(wp.cgu_name).unwrap())\n+    }));\n+    for module in modules {\n+        match module {\n+            FatLTOInput::InMemory(m) => in_memory.push(m),\n+            FatLTOInput::Serialized { name, buffer } => {\n+                info!(\"pushing serialized module {:?}\", name);\n+                let buffer = SerializedModule::Local(buffer);\n+                serialized_modules.push((buffer, CString::new(name).unwrap()));\n+            }\n+        }\n+    }\n+\n     // Find the \"costliest\" module and merge everything into that codegen unit.\n     // All the other modules will be serialized and reparsed into the new\n     // context, so this hopefully avoids serializing and parsing the largest\n@@ -200,14 +226,8 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // file copy operations in the backend work correctly. The only other kind\n     // of module here should be an allocator one, and if your crate is smaller\n     // than the allocator module then the size doesn't really matter anyway.\n-    let costliest_module = modules.iter()\n+    let costliest_module = in_memory.iter()\n         .enumerate()\n-        .filter_map(|(i, module)| {\n-            match module {\n-                FatLTOInput::InMemory(m) => Some((i, m)),\n-                FatLTOInput::Serialized { .. } => None,\n-            }\n-        })\n         .filter(|&(_, module)| module.kind == ModuleKind::Regular)\n         .map(|(i, module)| {\n             let cost = unsafe {\n@@ -223,26 +243,14 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     // re-executing the LTO passes. If that's the case deserialize the first\n     // module and create a linker with it.\n     let module: ModuleCodegen<ModuleLlvm> = match costliest_module {\n-        Some((_cost, i)) => {\n-            match modules.remove(i) {\n-                FatLTOInput::InMemory(m) => m,\n-                FatLTOInput::Serialized { .. } => unreachable!(),\n-            }\n-        }\n+        Some((_cost, i)) => in_memory.remove(i),\n         None => {\n-            let pos = modules.iter().position(|m| {\n-                match m {\n-                    FatLTOInput::InMemory(_) => false,\n-                    FatLTOInput::Serialized { .. } => true,\n-                }\n-            }).expect(\"must have at least one serialized module\");\n-            let (name, buffer) = match modules.remove(pos) {\n-                FatLTOInput::Serialized { name, buffer } => (name, buffer),\n-                FatLTOInput::InMemory(_) => unreachable!(),\n-            };\n+            assert!(serialized_modules.len() > 0, \"must have at least one serialized module\");\n+            let (buffer, name) = serialized_modules.remove(0);\n+            info!(\"no in-memory regular modules to choose from, parsing {:?}\", name);\n             ModuleCodegen {\n-                module_llvm: ModuleLlvm::parse(cgcx, &name, &buffer, diag_handler)?,\n-                name,\n+                module_llvm: ModuleLlvm::parse(cgcx, &name, buffer.data(), diag_handler)?,\n+                name: name.into_string().unwrap(),\n                 kind: ModuleKind::Regular,\n             }\n         }\n@@ -265,25 +273,13 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // and we want to move everything to the same LLVM context. Currently the\n         // way we know of to do that is to serialize them to a string and them parse\n         // them later. Not great but hey, that's why it's \"fat\" LTO, right?\n-        let mut new_modules = modules.into_iter().map(|module| {\n-            match module {\n-                FatLTOInput::InMemory(module) => {\n-                    let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n-                    let llmod_id = CString::new(&module.name[..]).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-                FatLTOInput::Serialized { name, buffer } => {\n-                    let llmod_id = CString::new(name).unwrap();\n-                    (SerializedModule::Local(buffer), llmod_id)\n-                }\n-            }\n-        }).collect::<Vec<_>>();\n+        for module in in_memory {\n+            let buffer = ModuleBuffer::new(module.module_llvm.llmod());\n+            let llmod_id = CString::new(&module.name[..]).unwrap();\n+            serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n+        }\n         // Sort the modules to ensure we produce deterministic results.\n-        new_modules.sort_by(|module1, module2| module1.1.partial_cmp(&module2.1).unwrap());\n-        serialized_modules.extend(new_modules);\n-        serialized_modules.extend(cached_modules.into_iter().map(|(buffer, wp)| {\n-            (buffer, CString::new(wp.cgu_name).unwrap())\n-        }));\n+        serialized_modules.sort_by(|module1, module2| module1.1.cmp(&module2.1));\n \n         // For all serialized bitcode files we parse them and link them in as we did\n         // above, this is all mostly handled in C++. Like above, though, we don't\n@@ -850,7 +846,7 @@ fn module_name_to_str(c_str: &CStr) -> &str {\n         bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\", c_str.to_string_lossy(), e))\n }\n \n-fn parse_module<'a>(\n+pub fn parse_module<'a>(\n     cx: &'a llvm::Context,\n     name: &CStr,\n     data: &[u8],"}, {"sha": "2fd78885bd01e8106b8ffb22d2cd468075dcad8d", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=1a4330d2a23f8b9912cb4ca54d259333b0133b76", "patch": "@@ -54,6 +54,7 @@ use syntax_pos::symbol::InternedString;\n pub use llvm_util::target_features;\n use std::any::Any;\n use std::sync::{mpsc, Arc};\n+use std::ffi::CStr;\n \n use rustc::dep_graph::DepGraph;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n@@ -386,13 +387,13 @@ impl ModuleLlvm {\n \n     fn parse(\n         cgcx: &CodegenContext<LlvmCodegenBackend>,\n-        name: &str,\n-        buffer: &back::lto::ModuleBuffer,\n+        name: &CStr,\n+        buffer: &[u8],\n         handler: &Handler,\n     ) -> Result<Self, FatalError> {\n         unsafe {\n             let llcx = llvm::LLVMRustContextCreate(cgcx.fewer_names);\n-            let llmod_raw = buffer.parse(name, llcx, handler)?;\n+            let llmod_raw = back::lto::parse_module(llcx, name, buffer, handler)?;\n             let tm = match (cgcx.tm_factory.0)() {\n                 Ok(m) => m,\n                 Err(e) => {"}, {"sha": "345d10bc4b9ea59d3c4216b4055b564d9b8a1265", "filename": "src/test/run-make-fulldeps/lto-empty/Makefile", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2FMakefile?ref=1a4330d2a23f8b9912cb4ca54d259333b0133b76", "patch": "@@ -0,0 +1,12 @@\n+-include ../tools.mk\n+\n+all: cdylib-fat cdylib-thin\n+\n+cdylib-fat:\n+\t$(RUSTC) lib.rs -C lto=fat -C opt-level=3 -C incremental=$(TMPDIR)/inc-fat\n+\t$(RUSTC) lib.rs -C lto=fat -C opt-level=3 -C incremental=$(TMPDIR)/inc-fat\n+\n+cdylib-thin:\n+\t$(RUSTC) lib.rs -C lto=thin -C opt-level=3 -C incremental=$(TMPDIR)/inc-thin\n+\t$(RUSTC) lib.rs -C lto=thin -C opt-level=3 -C incremental=$(TMPDIR)/inc-thin\n+"}, {"sha": "e3663c79078f4f0823ebbb7baf5fc65a1512c15a", "filename": "src/test/run-make-fulldeps/lto-empty/lib.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flto-empty%2Flib.rs?ref=1a4330d2a23f8b9912cb4ca54d259333b0133b76", "patch": "@@ -0,0 +1 @@\n+#![crate_type = \"cdylib\"]"}, {"sha": "b7a930b61cc96aed4b73d9adc82ce62250d63d61", "filename": "src/test/ui/lto-duplicate-symbols.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1a4330d2a23f8b9912cb4ca54d259333b0133b76/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flto-duplicate-symbols.stderr?ref=1a4330d2a23f8b9912cb4ca54d259333b0133b76", "patch": "@@ -1,6 +1,6 @@\n warning: Linking globals named 'foo': symbol multiply defined!\n \n-error: failed to load bc of \"lto_duplicate_symbols1.3a1fbbbh-cgu.0\": \n+error: failed to load bc of \"lto_duplicate_symbols2.3a1fbbbh-cgu.0\": \n \n error: aborting due to previous error\n "}]}