{"sha": "e71bffb0080e53a11078e6279f0bb1e470c452e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3MWJmZmIwMDgwZTUzYTExMDc4ZTYyNzlmMGJiMWU0NzBjNDUyZTA=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-06-08T09:47:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-06-08T09:47:18Z"}, "message": "Format modules defined inside cfg_if macro calls (#3600)", "tree": {"sha": "98237efaa110a633f80c5bbc9ef0ac4f692aab5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98237efaa110a633f80c5bbc9ef0ac4f692aab5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e71bffb0080e53a11078e6279f0bb1e470c452e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc+4QmCRBK7hj4Ov3rIwAAdHIIADG6KFhS+qFOgIVEOOKDKZsx\nuK5Nnj9Jp9eH4REyjzkRmDUMLMt+lJ5tIpRyKan77D9hOwt3bEx0kSAS5Tb7e7IZ\nlNV6s1keg7Qaib4Kgg+SESlPeEINedfPgQEcRdLgg7m5kj1kFHsDh00EP+xM9E+1\nIPBL/lOSyiWBYQ7f8fCJUzj4cuAvutUBodV958RJ4uUezFClOskDisB3aSAARDhh\njcQSMPj928876wzS5StmIC1osFGmiXbVBSCZSmFSDy4OpD+xG/pxhnDvzK4D40YJ\nBlP08OZ0WAWbkVMM3s/rzbOUiuYwHBIPe8RE2U5fMxvTtGRAnPmEyAetq4TJIlM=\n=bP4T\n-----END PGP SIGNATURE-----\n", "payload": "tree 98237efaa110a633f80c5bbc9ef0ac4f692aab5f\nparent 87565c42ce255d60ce76d8e5d8a0af5435a2aad6\nauthor Seiichi Uchida <seuchida@gmail.com> 1559987238 +0900\ncommitter GitHub <noreply@github.com> 1559987238 +0900\n\nFormat modules defined inside cfg_if macro calls (#3600)\n\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e71bffb0080e53a11078e6279f0bb1e470c452e0", "html_url": "https://github.com/rust-lang/rust/commit/e71bffb0080e53a11078e6279f0bb1e470c452e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e71bffb0080e53a11078e6279f0bb1e470c452e0/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87565c42ce255d60ce76d8e5d8a0af5435a2aad6", "url": "https://api.github.com/repos/rust-lang/rust/commits/87565c42ce255d60ce76d8e5d8a0af5435a2aad6", "html_url": "https://github.com/rust-lang/rust/commit/87565c42ce255d60ce76d8e5d8a0af5435a2aad6"}], "stats": {"total": 5639, "additions": 5589, "deletions": 50}, "files": [{"sha": "0e98bca9896c5161ff841f97ba2ed8d7e6c9744c", "filename": "src/formatting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -99,8 +99,8 @@ fn format_project<T: FormatHandler>(\n \n     let mut context = FormatContext::new(&krate, report, parse_session, config, handler);\n     let files = modules::ModResolver::new(\n-        context.parse_session.source_map(),\n-        directory_ownership.unwrap_or(parse::DirectoryOwnership::UnownedViaMod(false)),\n+        &context.parse_session,\n+        directory_ownership.unwrap_or(parse::DirectoryOwnership::UnownedViaMod(true)),\n         !(input_is_stdin || config.skip_children()),\n     )\n     .visit_crate(&krate)\n@@ -112,7 +112,7 @@ fn format_project<T: FormatHandler>(\n         }\n         should_emit_verbose(input_is_stdin, config, || println!(\"Formatting {}\", path));\n         let is_root = path == main_file;\n-        context.format_file(path, module, is_root)?;\n+        context.format_file(path, &module, is_root)?;\n     }\n     timer = timer.done_formatting();\n "}, {"sha": "e54bdb87570521362587b61887682160403f3df8", "filename": "src/modules.rs", "status": "modified", "additions": 142, "deletions": 46, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -1,23 +1,27 @@\n+use std::borrow::Cow;\n use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n \n use syntax::ast;\n-use syntax::parse::{parser, DirectoryOwnership};\n+use syntax::parse::{parser, DirectoryOwnership, ParseSess};\n use syntax::source_map;\n use syntax::symbol::sym;\n+use syntax::visit::Visitor;\n use syntax_pos::symbol::Symbol;\n \n use crate::config::FileName;\n use crate::items::is_mod_decl;\n use crate::utils::contains_skip;\n \n-type FileModMap<'a> = BTreeMap<FileName, (&'a ast::Mod, String)>;\n+mod visitor;\n+\n+type FileModMap<'ast> = BTreeMap<FileName, (Cow<'ast, ast::Mod>, String)>;\n \n /// Maps each module to the corresponding file.\n-pub(crate) struct ModResolver<'a, 'b> {\n-    source_map: &'b source_map::SourceMap,\n+pub(crate) struct ModResolver<'ast, 'sess> {\n+    parse_sess: &'sess ParseSess,\n     directory: Directory,\n-    file_map: FileModMap<'a>,\n+    file_map: FileModMap<'ast>,\n     recursive: bool,\n }\n \n@@ -27,10 +31,28 @@ struct Directory {\n     ownership: DirectoryOwnership,\n }\n \n-impl<'a, 'b> ModResolver<'a, 'b> {\n+impl<'a> Directory {\n+    fn to_syntax_directory(&'a self) -> syntax::parse::Directory<'a> {\n+        syntax::parse::Directory {\n+            path: Cow::Borrowed(&self.path),\n+            ownership: self.ownership.clone(),\n+        }\n+    }\n+}\n+\n+enum SubModKind {\n+    /// `mod foo;`\n+    External(PathBuf, DirectoryOwnership),\n+    /// `#[path = \"...\"] mod foo {}`\n+    InternalWithPath(PathBuf),\n+    /// `mod foo {}`\n+    Internal,\n+}\n+\n+impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n     /// Creates a new `ModResolver`.\n     pub(crate) fn new(\n-        source_map: &'b source_map::SourceMap,\n+        parse_sess: &'sess ParseSess,\n         directory_ownership: DirectoryOwnership,\n         recursive: bool,\n     ) -> Self {\n@@ -40,14 +62,17 @@ impl<'a, 'b> ModResolver<'a, 'b> {\n                 ownership: directory_ownership,\n             },\n             file_map: BTreeMap::new(),\n-            source_map,\n+            parse_sess,\n             recursive,\n         }\n     }\n \n     /// Creates a map that maps a file name to the module in AST.\n-    pub(crate) fn visit_crate(mut self, krate: &'a ast::Crate) -> Result<FileModMap<'a>, String> {\n-        let root_filename = self.source_map.span_to_filename(krate.span);\n+    pub(crate) fn visit_crate(\n+        mut self,\n+        krate: &'ast ast::Crate,\n+    ) -> Result<FileModMap<'ast>, String> {\n+        let root_filename = self.parse_sess.source_map().span_to_filename(krate.span);\n         self.directory.path = match root_filename {\n             source_map::FileName::Real(ref path) => path\n                 .parent()\n@@ -58,54 +83,125 @@ impl<'a, 'b> ModResolver<'a, 'b> {\n \n         // Skip visiting sub modules when the input is from stdin.\n         if self.recursive {\n-            self.visit_mod(&krate.module)?;\n+            self.visit_mod_from_ast(&krate.module)?;\n         }\n \n-        self.file_map\n-            .insert(root_filename.into(), (&krate.module, String::new()));\n+        self.file_map.insert(\n+            root_filename.into(),\n+            (Cow::Borrowed(&krate.module), String::new()),\n+        );\n         Ok(self.file_map)\n     }\n \n-    fn visit_mod(&mut self, module: &'a ast::Mod) -> Result<(), String> {\n+    /// Visit macro calls and look for module declarations. Currently only supports `cfg_if` macro.\n+    fn visit_mac(&mut self, item: Cow<'ast, ast::Item>) -> Result<(), String> {\n+        let mut visitor =\n+            visitor::CfgIfVisitor::new(self.parse_sess, self.directory.to_syntax_directory());\n+        visitor.visit_item(&item);\n+        for module_item in visitor.mods() {\n+            if let ast::ItemKind::Mod(ref sub_mod) = module_item.item.node {\n+                self.visit_mod_from_mac_inner(&item, Cow::Owned(sub_mod.clone()))?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Visit modules defined inside macro calls.\n+    fn visit_mod_from_macro(&mut self, module: Cow<'ast, ast::Mod>) -> Result<(), String> {\n         for item in &module.items {\n+            if let ast::ItemKind::Mac(..) = item.node {\n+                self.visit_mac(Cow::Owned(item.clone().into_inner()))?;\n+            }\n+\n             if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n-                if contains_skip(&item.attrs) {\n-                    continue;\n-                }\n+                self.visit_mod_from_mac_inner(item, Cow::Owned(sub_mod.clone()))?;\n+            }\n+        }\n+        Ok(())\n+    }\n \n-                let old_direcotry = self.directory.clone();\n-                if is_mod_decl(item) {\n-                    // mod foo;\n-                    // Look for an extern file.\n-                    let (mod_path, directory_ownership) =\n-                        self.find_external_module(item.ident, &item.attrs)?;\n-                    self.file_map.insert(\n-                        FileName::Real(mod_path.clone()),\n-                        (sub_mod, item.ident.as_str().get().to_owned()),\n-                    );\n-                    self.directory = Directory {\n-                        path: mod_path.parent().unwrap().to_path_buf(),\n-                        ownership: directory_ownership,\n-                    }\n-                } else {\n-                    // An internal module (`mod foo { /* ... */ }`);\n-                    if let Some(path) = find_path_value(&item.attrs) {\n-                        // All `#[path]` files are treated as though they are a `mod.rs` file.\n-                        self.directory = Directory {\n-                            path: Path::new(&path.as_str()).to_path_buf(),\n-                            ownership: DirectoryOwnership::Owned { relative: None },\n-                        };\n-                    } else {\n-                        self.push_inline_mod_directory(item.ident, &item.attrs);\n-                    }\n-                }\n-                self.visit_mod(sub_mod)?;\n-                self.directory = old_direcotry;\n+    fn visit_mod_from_mac_inner(\n+        &mut self,\n+        item: &'c ast::Item,\n+        sub_mod: Cow<'ast, ast::Mod>,\n+    ) -> Result<(), String> {\n+        let old_directory = self.directory.clone();\n+        self.visit_sub_mod(item, &sub_mod)?;\n+        self.visit_mod_from_macro(sub_mod)?;\n+        self.directory = old_directory;\n+        Ok(())\n+    }\n+\n+    /// Visit modules from AST.\n+    fn visit_mod_from_ast(&mut self, module: &'ast ast::Mod) -> Result<(), String> {\n+        for item in &module.items {\n+            if let ast::ItemKind::Mac(..) = item.node {\n+                self.visit_mac(Cow::Borrowed(item))?;\n+            }\n+\n+            if let ast::ItemKind::Mod(ref sub_mod) = item.node {\n+                let old_directory = self.directory.clone();\n+                self.visit_sub_mod(item, &Cow::Borrowed(sub_mod))?;\n+                self.visit_mod_from_ast(sub_mod)?;\n+                self.directory = old_directory;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn visit_sub_mod(\n+        &mut self,\n+        item: &'c ast::Item,\n+        sub_mod: &Cow<'ast, ast::Mod>,\n+    ) -> Result<(), String> {\n+        match self.peek_sub_mod(item)? {\n+            Some(SubModKind::External(mod_path, directory_ownership)) => {\n+                self.file_map.insert(\n+                    FileName::Real(mod_path.clone()),\n+                    (sub_mod.clone(), item.ident.name.as_str().get().to_owned()),\n+                );\n+                self.directory = Directory {\n+                    path: mod_path.parent().unwrap().to_path_buf(),\n+                    ownership: directory_ownership,\n+                };\n+            }\n+            Some(SubModKind::InternalWithPath(mod_path)) => {\n+                // All `#[path]` files are treated as though they are a `mod.rs` file.\n+                self.directory = Directory {\n+                    path: mod_path,\n+                    ownership: DirectoryOwnership::Owned { relative: None },\n+                };\n             }\n+            Some(SubModKind::Internal) => self.push_inline_mod_directory(item.ident, &item.attrs),\n+            None => (), // rustfmt::skip\n         }\n         Ok(())\n     }\n \n+    /// Inspect the given sub-module which we are about to visit and returns its kind.\n+    fn peek_sub_mod(&self, item: &'c ast::Item) -> Result<Option<SubModKind>, String> {\n+        if contains_skip(&item.attrs) {\n+            return Ok(None);\n+        }\n+\n+        if is_mod_decl(item) {\n+            // mod foo;\n+            // Look for an extern file.\n+            let (mod_path, directory_ownership) =\n+                self.find_external_module(item.ident, &item.attrs)?;\n+            Ok(Some(SubModKind::External(mod_path, directory_ownership)))\n+        } else {\n+            // An internal module (`mod foo { /* ... */ }`);\n+            if let Some(path) = find_path_value(&item.attrs) {\n+                let path = Path::new(&path.as_str()).to_path_buf();\n+                Ok(Some(SubModKind::InternalWithPath(path)))\n+            } else {\n+                Ok(Some(SubModKind::Internal))\n+            }\n+        }\n+    }\n+\n+    /// Find a file path in the filesystem which corresponds to the given module.\n     fn find_external_module(\n         &self,\n         mod_name: ast::Ident,\n@@ -123,7 +219,7 @@ impl<'a, 'b> ModResolver<'a, 'b> {\n             mod_name,\n             relative,\n             &self.directory.path,\n-            self.source_map,\n+            self.parse_sess.source_map(),\n         )\n         .result\n         {"}, {"sha": "1086a1a026cecbeb9f857463a841d107f9428635", "filename": "src/modules/visitor.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/src%2Fmodules%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/src%2Fmodules%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules%2Fvisitor.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,105 @@\n+use syntax::ast;\n+use syntax::parse::token::{DelimToken, Token};\n+use syntax::parse::{stream_to_parser_with_base_dir, Directory, ParseSess};\n+use syntax::symbol::kw;\n+use syntax::visit::Visitor;\n+use syntax_pos::Symbol;\n+\n+pub(crate) struct ModItem {\n+    pub(crate) item: ast::Item,\n+}\n+\n+/// Traverse `cfg_if!` macro and fetch modules.\n+pub(crate) struct CfgIfVisitor<'a> {\n+    parse_sess: &'a ParseSess,\n+    mods: Vec<ModItem>,\n+    base_dir: Directory<'a>,\n+}\n+\n+impl<'a> CfgIfVisitor<'a> {\n+    pub(crate) fn new(parse_sess: &'a ParseSess, base_dir: Directory<'a>) -> CfgIfVisitor<'a> {\n+        CfgIfVisitor {\n+            mods: vec![],\n+            parse_sess,\n+            base_dir,\n+        }\n+    }\n+\n+    pub(crate) fn mods(self) -> Vec<ModItem> {\n+        self.mods\n+    }\n+}\n+\n+impl<'a, 'ast: 'a> Visitor<'ast> for CfgIfVisitor<'a> {\n+    fn visit_mac(&mut self, mac: &'ast ast::Mac) {\n+        match self.visit_mac_inner(mac) {\n+            Ok(()) => (),\n+            Err(e) => debug!(\"{}\", e),\n+        }\n+    }\n+}\n+\n+impl<'a, 'ast: 'a> CfgIfVisitor<'a> {\n+    fn visit_mac_inner(&mut self, mac: &'ast ast::Mac) -> Result<(), &'static str> {\n+        if mac.node.path != Symbol::intern(\"cfg_if\") {\n+            return Err(\"Expected cfg_if\");\n+        }\n+\n+        let mut parser = stream_to_parser_with_base_dir(\n+            self.parse_sess,\n+            mac.node.tts.clone(),\n+            self.base_dir.clone(),\n+        );\n+        parser.cfg_mods = false;\n+        let mut process_if_cfg = true;\n+\n+        while parser.token != Token::Eof {\n+            if process_if_cfg {\n+                if !parser.eat_keyword(kw::If) {\n+                    return Err(\"Expected `if`\");\n+                }\n+                parser\n+                    .parse_attribute(false)\n+                    .map_err(|_| \"Failed to parse attributes\")?;\n+            }\n+\n+            if !parser.eat(&Token::OpenDelim(DelimToken::Brace)) {\n+                return Err(\"Expected an opening brace\");\n+            }\n+\n+            while parser.token != Token::CloseDelim(DelimToken::Brace) && parser.token != Token::Eof\n+            {\n+                let item = match parser.parse_item() {\n+                    Ok(Some(item_ptr)) => item_ptr.into_inner(),\n+                    Ok(None) => continue,\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        parser.sess.span_diagnostic.reset_err_count();\n+                        return Err(\n+                            \"Expected item inside cfg_if block, but failed to parse it as an item\",\n+                        );\n+                    }\n+                };\n+                if let ast::ItemKind::Mod(..) = item.node {\n+                    self.mods.push(ModItem { item });\n+                }\n+            }\n+\n+            if !parser.eat(&Token::CloseDelim(DelimToken::Brace)) {\n+                return Err(\"Expected a closing brace\");\n+            }\n+\n+            if parser.eat(&Token::Eof) {\n+                break;\n+            }\n+\n+            if !parser.eat_keyword(kw::Else) {\n+                return Err(\"Expected `else`\");\n+            }\n+\n+            process_if_cfg = parser.token.is_keyword(kw::If);\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "c68b33b844f8e3d5a763bbe28190a78d42c8e8c6", "filename": "src/test/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -25,6 +25,9 @@ const SKIP_FILE_WHITE_LIST: &[&str] = &[\n     // so we do not want to test this file directly.\n     \"configs/skip_children/foo/mod.rs\",\n     \"issue-3434/no_entry.rs\",\n+    // These files and directory are a part of modules defined inside `cfg_if!`.\n+    \"cfg_if/mod.rs\",\n+    \"cfg_if/detect\",\n ];\n \n struct TestSetting {\n@@ -53,10 +56,19 @@ where\n         .expect(\"Failed to join a test thread\")\n }\n \n+fn is_subpath<P>(path: &Path, subpath: &P) -> bool\n+where\n+    P: AsRef<Path>,\n+{\n+    (0..path.components().count())\n+        .map(|i| path.components().take(i))\n+        .any(|c| c.zip(subpath.as_ref().components()).all(|(a, b)| a == b))\n+}\n+\n fn is_file_skip(path: &Path) -> bool {\n     SKIP_FILE_WHITE_LIST\n         .iter()\n-        .any(|file_path| path.ends_with(file_path))\n+        .any(|file_path| is_subpath(path, file_path))\n }\n \n // Returns a `Vec` containing `PathBuf`s of files with an  `rs` extension in the"}, {"sha": "ebae2bd28540806c6d9645b08964a654919c4604", "filename": "tests/source/cfg_if/detect/arch/aarch64.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Faarch64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,106 @@\n+//! Aarch64 run-time features.\n+\n+/// Checks if `aarch64` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal,stdsimd)]\n+macro_rules! is_aarch64_feature_detected {\n+    (\"neon\") => {\n+        // FIXME: this should be removed once we rename Aarch64 neon to asimd\n+        cfg!(target_feature = \"neon\") ||\n+            $crate::detect::check_for($crate::detect::Feature::asimd)\n+    };\n+    (\"asimd\") => {\n+        cfg!(target_feature = \"neon\") ||\n+            $crate::detect::check_for($crate::detect::Feature::asimd)\n+    };\n+    (\"pmull\") => {\n+        cfg!(target_feature = \"pmull\") ||\n+            $crate::detect::check_for($crate::detect::Feature::pmull)\n+    };\n+    (\"fp\") => {\n+        cfg!(target_feature = \"fp\") ||\n+            $crate::detect::check_for($crate::detect::Feature::fp)\n+    };\n+    (\"fp16\") => {\n+        cfg!(target_feature = \"fp16\") ||\n+            $crate::detect::check_for($crate::detect::Feature::fp16)\n+    };\n+    (\"sve\") => {\n+        cfg!(target_feature = \"sve\") ||\n+            $crate::detect::check_for($crate::detect::Feature::sve)\n+    };\n+    (\"crc\") => {\n+        cfg!(target_feature = \"crc\") ||\n+            $crate::detect::check_for($crate::detect::Feature::crc)\n+    };\n+    (\"crypto\") => {\n+        cfg!(target_feature = \"crypto\") ||\n+            $crate::detect::check_for($crate::detect::Feature::crypto)\n+    };\n+    (\"lse\") => {\n+        cfg!(target_feature = \"lse\") ||\n+            $crate::detect::check_for($crate::detect::Feature::lse)\n+    };\n+    (\"rdm\") => {\n+        cfg!(target_feature = \"rdm\") ||\n+            $crate::detect::check_for($crate::detect::Feature::rdm)\n+    };\n+    (\"rcpc\") => {\n+        cfg!(target_feature = \"rcpc\") ||\n+            $crate::detect::check_for($crate::detect::Feature::rcpc)\n+    };\n+    (\"dotprod\") => {\n+        cfg!(target_feature = \"dotprod\") ||\n+            $crate::detect::check_for($crate::detect::Feature::dotprod)\n+    };\n+    (\"ras\") => {\n+        compile_error!(\"\\\"ras\\\" feature cannot be detected at run-time\")\n+    };\n+    (\"v8.1a\") => {\n+        compile_error!(\"\\\"v8.1a\\\" feature cannot be detected at run-time\")\n+    };\n+    (\"v8.2a\") => {\n+        compile_error!(\"\\\"v8.2a\\\" feature cannot be detected at run-time\")\n+    };\n+    (\"v8.3a\") => {\n+        compile_error!(\"\\\"v8.3a\\\" feature cannot be detected at run-time\")\n+    };\n+    ($t:tt,) => {\n+        is_aarch64_feature_detected!($t);\n+    };\n+    ($t:tt) => { compile_error!(concat!(\"unknown aarch64 target feature: \", $t)) };\n+}\n+\n+/// ARM Aarch64 CPU Feature enum. Each variant denotes a position in a bitset\n+/// for a particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// ARM Advanced SIMD (ASIMD)\n+    asimd,\n+    /// Polynomial Multiply\n+    pmull,\n+    /// Floating point support\n+    fp,\n+    /// Half-float support.\n+    fp16,\n+    /// Scalable Vector Extension (SVE)\n+    sve,\n+    /// CRC32 (Cyclic Redundancy Check)\n+    crc,\n+    /// Crypto: AES + PMULL + SHA1 + SHA2\n+    crypto,\n+    /// Atomics (Large System Extension)\n+    lse,\n+    /// Rounding Double Multiply (ASIMDRDM)\n+    rdm,\n+    /// Release consistent Processor consistent (RcPc)\n+    rcpc,\n+    /// Vector Dot-Product (ASIMDDP)\n+    dotprod,\n+}"}, {"sha": "b2626bf2923b6660cbf5fde8d502fabd71ac14be", "filename": "tests/source/cfg_if/detect/arch/arm.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Farm.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,39 @@\n+//! Run-time feature detection on ARM Aarch32.\n+\n+/// Checks if `arm` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal,stdsimd)]\n+macro_rules! is_arm_feature_detected {\n+    (\"neon\") => {\n+        cfg!(target_feature = \"neon\") ||\n+            $crate::detect::check_for($crate::detect::Feature::neon)\n+    };\n+    (\"pmull\") => {\n+        cfg!(target_feature = \"pmull\") ||\n+            $crate::detect::check_for($crate::detect::Feature::pmull)\n+    };\n+    (\"v7\") => { compile_error!(\"\\\"v7\\\" feature cannot be detected at run-time\") };\n+    (\"vfp2\") => { compile_error!(\"\\\"vfp2\\\" feature cannot be detected at run-time\") };\n+    (\"vfp3\") => { compile_error!(\"\\\"vfp3\\\" feature cannot be detected at run-time\") };\n+    (\"vfp4\") => { compile_error!(\"\\\"vfp4\\\" feature cannot be detected at run-time\") };\n+    ($t:tt,) => {\n+        is_arm_feature_detected!($t);\n+    };\n+    ($t:tt) => { compile_error!(concat!(\"unknown arm target feature: \", $t)) };\n+}\n+\n+/// ARM CPU Feature enum. Each variant denotes a position in a bitset for a\n+/// particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// ARM Advanced SIMD (NEON) - Aarch32\n+    neon,\n+    /// Polynomial Multiply\n+    pmull,\n+}"}, {"sha": "f4381b811cdf2462f11e3934cdf27a534bf61d70", "filename": "tests/source/cfg_if/detect/arch/mips.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,29 @@\n+//! Run-time feature detection on MIPS.\n+\n+/// Checks if `mips` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal,stdsimd)]\n+macro_rules! is_mips_feature_detected {\n+    (\"msa\") => {\n+        cfg!(target_feature = \"msa\") ||\n+            $crate::detect::check_for($crate::detect::Feature::msa)\n+    };\n+    ($t:tt,) => {\n+        is_mips_feature_detected!($t);\n+    };\n+    ($t:tt) => { compile_error!(concat!(\"unknown mips target feature: \", $t)) };\n+}\n+\n+/// MIPS CPU Feature enum. Each variant denotes a position in a bitset for a\n+/// particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// MIPS SIMD Architecture (MSA)\n+    msa,\n+}"}, {"sha": "2663bc68ba980cd4a8ec71ad3f69a3f5c7f32a4b", "filename": "tests/source/cfg_if/detect/arch/mips64.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fmips64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,29 @@\n+//! Run-time feature detection on MIPS64.\n+\n+/// Checks if `mips64` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal,stdsimd)]\n+macro_rules! is_mips64_feature_detected {\n+    (\"msa\") => {\n+        cfg!(target_feature = \"msa\") ||\n+            $crate::detect::check_for($crate::detect::Feature::msa)\n+    };\n+    ($t:tt,) => {\n+        is_mips64_feature_detected!($t);\n+    };\n+    ($t:tt) => { compile_error!(concat!(\"unknown mips64 target feature: \", $t)) };\n+}\n+\n+/// MIPS64 CPU Feature enum. Each variant denotes a position in a bitset\n+/// for a particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// MIPS SIMD Architecture (MSA)\n+    msa,\n+}"}, {"sha": "a342dc1aacc0ccb2fa03a0812b38615d6846750f", "filename": "tests/source/cfg_if/detect/arch/powerpc.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,42 @@\n+//! Run-time feature detection on PowerPC.\n+\n+/// Checks if `powerpc` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal,stdsimd)]\n+macro_rules! is_powerpc_feature_detected {\n+    (\"altivec\") => {\n+        cfg!(target_feature = \"altivec\") ||\n+            $crate::detect::check_for($crate::detect::Feature::altivec)\n+    };\n+    (\"vsx\") => {\n+        cfg!(target_feature = \"vsx\") ||\n+            $crate::detect::check_for($crate::detect::Feature::vsx)\n+    };\n+    (\"power8\") => {\n+        cfg!(target_feature = \"power8\") ||\n+            $crate::detect::check_for($crate::detect::Feature::power8)\n+    };\n+    ($t:tt,) => {\n+        is_powerpc_feature_detected!($t);\n+    };\n+    ($t:tt) => { compile_error!(concat!(\"unknown powerpc target feature: \", $t)) };\n+}\n+\n+\n+/// PowerPC CPU Feature enum. Each variant denotes a position in a bitset\n+/// for a particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// Altivec\n+    altivec,\n+    /// VSX\n+    vsx,\n+    /// Power8\n+    power8,\n+}"}, {"sha": "2e82c569252ac9608f48475ec92346ff53c6fd5d", "filename": "tests/source/cfg_if/detect/arch/powerpc64.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,42 @@\n+//! Run-time feature detection on PowerPC64.\n+\n+/// Checks if `powerpc64` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal,stdsimd)]\n+macro_rules! is_powerpc64_feature_detected {\n+    (\"altivec\") => {\n+        cfg!(target_feature = \"altivec\") ||\n+            $crate::detect::check_for($crate::detect::Feature::altivec)\n+    };\n+    (\"vsx\") => {\n+        cfg!(target_feature = \"vsx\") ||\n+            $crate::detect::check_for($crate::detect::Feature::vsx)\n+    };\n+    (\"power8\") => {\n+        cfg!(target_feature = \"power8\") ||\n+            $crate::detect::check_for($crate::detect::Feature::power8)\n+    };\n+    ($t:tt,) => {\n+        is_powerpc64_feature_detected!($t);\n+    };\n+    ($t:tt) => { compile_error!(concat!(\"unknown powerpc64 target feature: \", $t)) };\n+}\n+\n+\n+/// PowerPC64 CPU Feature enum. Each variant denotes a position in a bitset\n+/// for a particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// Altivec\n+    altivec,\n+    /// VSX\n+    vsx,\n+    /// Power8\n+    power8,\n+}"}, {"sha": "50d5cfa87c4c8c2a892271bd17045edadc5a391c", "filename": "tests/source/cfg_if/detect/arch/x86.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,348 @@\n+//! This module implements minimal run-time feature detection for x86.\n+//!\n+//! The features are detected using the `detect_features` function below.\n+//! This function uses the CPUID instruction to read the feature flags from the\n+//! CPU and encodes them in an `usize` where each bit position represents\n+//! whether a feature is available (bit is set) or unavaiable (bit is cleared).\n+//!\n+//! The enum `Feature` is used to map bit positions to feature names, and the\n+//! the `__crate::detect::check_for!` macro is used to map string literals (e.g.,\n+//! \"avx\") to these bit positions (e.g., `Feature::avx`).\n+//!\n+//! The run-time feature detection is performed by the\n+//! `__crate::detect::check_for(Feature) -> bool` function. On its first call,\n+//! this functions queries the CPU for the available features and stores them\n+//! in a global `AtomicUsize` variable. The query is performed by just checking\n+//! whether the feature bit in this global variable is set or cleared.\n+\n+/// A macro to test at *runtime* whether a CPU feature is available on\n+/// x86/x86-64 platforms.\n+///\n+/// This macro is provided in the standard library and will detect at runtime\n+/// whether the specified CPU feature is detected. This does **not** resolve at\n+/// compile time unless the specified feature is already enabled for the entire\n+/// crate. Runtime detection currently relies mostly on the `cpuid` instruction.\n+///\n+/// This macro only takes one argument which is a string literal of the feature\n+/// being tested for. The feature names supported are the lowercase versions of\n+/// the ones defined by Intel in [their documentation][docs].\n+///\n+/// ## Supported arguments\n+///\n+/// This macro supports the same names that `#[target_feature]` supports. Unlike\n+/// `#[target_feature]`, however, this macro does not support names separated\n+/// with a comma. Instead testing for multiple features must be done through\n+/// separate macro invocations for now.\n+///\n+/// Supported arguments are:\n+///\n+/// * `\"aes\"`\n+/// * `\"pclmulqdq\"`\n+/// * `\"rdrand\"`\n+/// * `\"rdseed\"`\n+/// * `\"tsc\"`\n+/// * `\"mmx\"`\n+/// * `\"sse\"`\n+/// * `\"sse2\"`\n+/// * `\"sse3\"`\n+/// * `\"ssse3\"`\n+/// * `\"sse4.1\"`\n+/// * `\"sse4.2\"`\n+/// * `\"sse4a\"`\n+/// * `\"sha\"`\n+/// * `\"avx\"`\n+/// * `\"avx2\"`\n+/// * `\"avx512f\"`\n+/// * `\"avx512cd\"`\n+/// * `\"avx512er\"`\n+/// * `\"avx512pf\"`\n+/// * `\"avx512bw\"`\n+/// * `\"avx512dq\"`\n+/// * `\"avx512vl\"`\n+/// * `\"avx512ifma\"`\n+/// * `\"avx512vbmi\"`\n+/// * `\"avx512vpopcntdq\"`\n+/// * `\"f16c\"`\n+/// * `\"fma\"`\n+/// * `\"bmi1\"`\n+/// * `\"bmi2\"`\n+/// * `\"abm\"`\n+/// * `\"lzcnt\"`\n+/// * `\"tbm\"`\n+/// * `\"popcnt\"`\n+/// * `\"fxsr\"`\n+/// * `\"xsave\"`\n+/// * `\"xsaveopt\"`\n+/// * `\"xsaves\"`\n+/// * `\"xsavec\"`\n+/// * `\"adx\"`\n+/// * `\"rtm\"`\n+///\n+/// [docs]: https://software.intel.com/sites/landingpage/IntrinsicsGuide\n+#[macro_export]\n+#[stable(feature = \"simd_x86\", since = \"1.27.0\")]\n+#[allow_internal_unstable(stdsimd_internal,stdsimd)]\n+macro_rules! is_x86_feature_detected {\n+    (\"aes\") => {\n+        cfg!(target_feature = \"aes\") || $crate::detect::check_for(\n+            $crate::detect::Feature::aes)  };\n+    (\"pclmulqdq\") => {\n+        cfg!(target_feature = \"pclmulqdq\") || $crate::detect::check_for(\n+            $crate::detect::Feature::pclmulqdq)  };\n+    (\"rdrand\") => {\n+        cfg!(target_feature = \"rdrand\") || $crate::detect::check_for(\n+            $crate::detect::Feature::rdrand)  };\n+    (\"rdseed\") => {\n+        cfg!(target_feature = \"rdseed\") || $crate::detect::check_for(\n+            $crate::detect::Feature::rdseed)  };\n+    (\"tsc\") => {\n+        cfg!(target_feature = \"tsc\") || $crate::detect::check_for(\n+            $crate::detect::Feature::tsc)  };\n+    (\"mmx\") => {\n+        cfg!(target_feature = \"mmx\") || $crate::detect::check_for(\n+            $crate::detect::Feature::mmx)  };\n+    (\"sse\") => {\n+        cfg!(target_feature = \"sse\") || $crate::detect::check_for(\n+            $crate::detect::Feature::sse)  };\n+    (\"sse2\") => {\n+        cfg!(target_feature = \"sse2\") || $crate::detect::check_for(\n+            $crate::detect::Feature::sse2)\n+    };\n+    (\"sse3\") => {\n+        cfg!(target_feature = \"sse3\") || $crate::detect::check_for(\n+            $crate::detect::Feature::sse3)\n+    };\n+    (\"ssse3\") => {\n+        cfg!(target_feature = \"ssse3\") || $crate::detect::check_for(\n+            $crate::detect::Feature::ssse3)\n+    };\n+    (\"sse4.1\") => {\n+        cfg!(target_feature = \"sse4.1\") || $crate::detect::check_for(\n+            $crate::detect::Feature::sse4_1)\n+    };\n+    (\"sse4.2\") => {\n+        cfg!(target_feature = \"sse4.2\") || $crate::detect::check_for(\n+            $crate::detect::Feature::sse4_2)\n+    };\n+    (\"sse4a\") => {\n+        cfg!(target_feature = \"sse4a\") || $crate::detect::check_for(\n+            $crate::detect::Feature::sse4a)\n+    };\n+    (\"sha\") => {\n+        cfg!(target_feature = \"sha\") || $crate::detect::check_for(\n+            $crate::detect::Feature::sha)\n+    };\n+    (\"avx\") => {\n+        cfg!(target_feature = \"avx\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx)\n+    };\n+    (\"avx2\") => {\n+        cfg!(target_feature = \"avx2\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx2)\n+    };\n+    (\"avx512f\") => {\n+        cfg!(target_feature = \"avx512f\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512f)\n+    };\n+    (\"avx512cd\") => {\n+        cfg!(target_feature = \"avx512cd\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512cd)\n+    };\n+    (\"avx512er\") => {\n+        cfg!(target_feature = \"avx512er\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512er)\n+    };\n+    (\"avx512pf\") => {\n+        cfg!(target_feature = \"avx512pf\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512pf)\n+    };\n+    (\"avx512bw\") => {\n+        cfg!(target_feature = \"avx512bw\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512bw)\n+    };\n+    (\"avx512dq\") => {\n+        cfg!(target_feature = \"avx512dq\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512dq)\n+    };\n+    (\"avx512vl\") => {\n+        cfg!(target_Feature = \"avx512vl\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512vl)\n+    };\n+    (\"avx512ifma\") => {\n+        cfg!(target_feature = \"avx512ifma\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512_ifma)\n+    };\n+    (\"avx512vbmi\") => {\n+        cfg!(target_feature = \"avx512vbmi\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512_vbmi)\n+    };\n+    (\"avx512vpopcntdq\") => {\n+        cfg!(target_feature = \"avx512vpopcntdq\") || $crate::detect::check_for(\n+            $crate::detect::Feature::avx512_vpopcntdq)\n+    };\n+    (\"f16c\") => {\n+        cfg!(target_feature = \"f16c\") || $crate::detect::check_for(\n+            $crate::detect::Feature::f16c)\n+    };\n+    (\"fma\") => {\n+        cfg!(target_feature = \"fma\") || $crate::detect::check_for(\n+            $crate::detect::Feature::fma)\n+    };\n+    (\"bmi1\") => {\n+        cfg!(target_feature = \"bmi1\") || $crate::detect::check_for(\n+            $crate::detect::Feature::bmi)\n+    };\n+    (\"bmi2\") => {\n+        cfg!(target_feature = \"bmi2\") || $crate::detect::check_for(\n+            $crate::detect::Feature::bmi2)\n+    };\n+    (\"abm\") => {\n+        cfg!(target_feature = \"abm\") || $crate::detect::check_for(\n+            $crate::detect::Feature::abm)\n+    };\n+    (\"lzcnt\") => {\n+        cfg!(target_feature = \"lzcnt\") || $crate::detect::check_for(\n+            $crate::detect::Feature::abm)\n+    };\n+    (\"tbm\") => {\n+        cfg!(target_feature = \"tbm\") || $crate::detect::check_for(\n+            $crate::detect::Feature::tbm)\n+    };\n+    (\"popcnt\") => {\n+        cfg!(target_feature = \"popcnt\") || $crate::detect::check_for(\n+            $crate::detect::Feature::popcnt)\n+    };\n+    (\"fxsr\") => {\n+        cfg!(target_feature = \"fxsr\") || $crate::detect::check_for(\n+            $crate::detect::Feature::fxsr)\n+    };\n+    (\"xsave\") => {\n+        cfg!(target_feature = \"xsave\") || $crate::detect::check_for(\n+            $crate::detect::Feature::xsave)\n+    };\n+    (\"xsaveopt\") => {\n+        cfg!(target_feature = \"xsaveopt\") || $crate::detect::check_for(\n+            $crate::detect::Feature::xsaveopt)\n+    };\n+    (\"xsaves\") => {\n+        cfg!(target_feature = \"xsaves\") || $crate::detect::check_for(\n+            $crate::detect::Feature::xsaves)\n+    };\n+    (\"xsavec\") => {\n+        cfg!(target_feature = \"xsavec\") || $crate::detect::check_for(\n+            $crate::detect::Feature::xsavec)\n+    };\n+    (\"cmpxchg16b\") => {\n+        cfg!(target_feature = \"cmpxchg16b\") || $crate::detect::check_for(\n+            $crate::detect::Feature::cmpxchg16b)\n+    };\n+    (\"adx\") => {\n+        cfg!(target_feature = \"adx\") || $crate::detect::check_for(\n+            $crate::detect::Feature::adx)\n+    };\n+    (\"rtm\") => {\n+        cfg!(target_feature = \"rtm\") || $crate::detect::check_for(\n+            $crate::detect::Feature::rtm)\n+    };\n+    ($t:tt,) => {\n+        is_x86_feature_detected!($t);\n+    };\n+    ($t:tt) => {\n+        compile_error!(concat!(\"unknown target feature: \", $t))\n+    };\n+}\n+\n+/// X86 CPU Feature enum. Each variant denotes a position in a bitset for a\n+/// particular feature.\n+///\n+/// This is an unstable implementation detail subject to change.\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[doc(hidden)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// AES (Advanced Encryption Standard New Instructions AES-NI)\n+    aes,\n+    /// CLMUL (Carry-less Multiplication)\n+    pclmulqdq,\n+    /// RDRAND\n+    rdrand,\n+    /// RDSEED\n+    rdseed,\n+    /// TSC (Time Stamp Counter)\n+    tsc,\n+    /// MMX\n+    mmx,\n+    /// SSE (Streaming SIMD Extensions)\n+    sse,\n+    /// SSE2 (Streaming SIMD Extensions 2)\n+    sse2,\n+    /// SSE3 (Streaming SIMD Extensions 3)\n+    sse3,\n+    /// SSSE3 (Supplemental Streaming SIMD Extensions 3)\n+    ssse3,\n+    /// SSE4.1 (Streaming SIMD Extensions 4.1)\n+    sse4_1,\n+    /// SSE4.2 (Streaming SIMD Extensions 4.2)\n+    sse4_2,\n+    /// SSE4a (Streaming SIMD Extensions 4a)\n+    sse4a,\n+    /// SHA\n+    sha,\n+    /// AVX (Advanced Vector Extensions)\n+    avx,\n+    /// AVX2 (Advanced Vector Extensions 2)\n+    avx2,\n+    /// AVX-512 F (Foundation)\n+    avx512f,\n+    /// AVX-512 CD (Conflict Detection Instructions)\n+    avx512cd,\n+    /// AVX-512 ER (Exponential and Reciprocal Instructions)\n+    avx512er,\n+    /// AVX-512 PF (Prefetch Instructions)\n+    avx512pf,\n+    /// AVX-512 BW (Byte and Word Instructions)\n+    avx512bw,\n+    /// AVX-512 DQ (Doubleword and Quadword)\n+    avx512dq,\n+    /// AVX-512 VL (Vector Length Extensions)\n+    avx512vl,\n+    /// AVX-512 IFMA (Integer Fused Multiply Add)\n+    avx512_ifma,\n+    /// AVX-512 VBMI (Vector Byte Manipulation Instructions)\n+    avx512_vbmi,\n+    /// AVX-512 VPOPCNTDQ (Vector Population Count Doubleword and\n+    /// Quadword)\n+    avx512_vpopcntdq,\n+    /// F16C (Conversions between IEEE-754 `binary16` and `binary32` formats)\n+    f16c,\n+    /// FMA (Fused Multiply Add)\n+    fma,\n+    /// BMI1 (Bit Manipulation Instructions 1)\n+    bmi,\n+    /// BMI1 (Bit Manipulation Instructions 2)\n+    bmi2,\n+    /// ABM (Advanced Bit Manipulation) on AMD / LZCNT (Leading Zero\n+    /// Count) on Intel\n+    abm,\n+    /// TBM (Trailing Bit Manipulation)\n+    tbm,\n+    /// POPCNT (Population Count)\n+    popcnt,\n+    /// FXSR (Floating-point context fast save and restor)\n+    fxsr,\n+    /// XSAVE (Save Processor Extended States)\n+    xsave,\n+    /// XSAVEOPT (Save Processor Extended States Optimized)\n+    xsaveopt,\n+    /// XSAVES (Save Processor Extended States Supervisor)\n+    xsaves,\n+    /// XSAVEC (Save Processor Extended States Compacted)\n+    xsavec,\n+    /// CMPXCH16B, a 16-byte compare-and-swap instruction\n+    cmpxchg16b,\n+    /// ADX, Intel ADX (Multi-Precision Add-Carry Instruction Extensions)\n+    adx,\n+    /// RTM, Intel (Restricted Transactional Memory)\n+    rtm,\n+}"}, {"sha": "578f0b16b742ae5eb16ffc1b99f41c6b88dcf2cc", "filename": "tests/source/cfg_if/detect/bit.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fbit.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,9 @@\n+//! Bit manipulation utilities.\n+\n+/// Tests the `bit` of `x`.\n+#[allow(dead_code)]\n+#[inline]\n+pub(crate) fn test(x: usize, bit: u32) -> bool {\n+    debug_assert!(bit < 32, \"bit index out-of-bounds\");\n+    x & (1 << bit) != 0\n+}"}, {"sha": "92bc4b58d167771726e22e5c2418a1eebbccc602", "filename": "tests/source/cfg_if/detect/cache.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fcache.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,164 @@\n+//! Caches run-time feature detection so that it only needs to be computed\n+//! once.\n+\n+#![allow(dead_code)] // not used on all platforms\n+\n+use crate::sync::atomic::Ordering;\n+\n+#[cfg(target_pointer_width = \"64\")]\n+use crate::sync::atomic::AtomicU64;\n+\n+#[cfg(target_pointer_width = \"32\")]\n+use crate::sync::atomic::AtomicU32;\n+\n+/// Sets the `bit` of `x`.\n+#[inline]\n+const fn set_bit(x: u64, bit: u32) -> u64 {\n+    x | 1 << bit\n+}\n+\n+/// Tests the `bit` of `x`.\n+#[inline]\n+const fn test_bit(x: u64, bit: u32) -> bool {\n+    x & (1 << bit) != 0\n+}\n+\n+/// Maximum number of features that can be cached.\n+const CACHE_CAPACITY: u32 = 63;\n+\n+/// This type is used to initialize the cache\n+#[derive(Copy, Clone)]\n+pub(crate) struct Initializer(u64);\n+\n+#[allow(clippy::use_self)]\n+impl Default for Initializer {\n+    fn default() -> Self {\n+        Initializer(0)\n+    }\n+}\n+\n+impl Initializer {\n+    /// Tests the `bit` of the cache.\n+    #[allow(dead_code)]\n+    #[inline]\n+    pub(crate) fn test(self, bit: u32) -> bool {\n+        // FIXME: this way of making sure that the cache is large enough is\n+        // brittle.\n+        debug_assert!(\n+            bit < CACHE_CAPACITY,\n+            \"too many features, time to increase the cache size!\"\n+        );\n+        test_bit(self.0, bit)\n+    }\n+\n+    /// Sets the `bit` of the cache.\n+    #[inline]\n+    pub(crate) fn set(&mut self, bit: u32) {\n+        // FIXME: this way of making sure that the cache is large enough is\n+        // brittle.\n+        debug_assert!(\n+            bit < CACHE_CAPACITY,\n+            \"too many features, time to increase the cache size!\"\n+        );\n+        let v = self.0;\n+        self.0 = set_bit(v, bit);\n+    }\n+}\n+\n+/// This global variable is a cache of the features supported by the CPU.\n+static CACHE: Cache = Cache::uninitialized();\n+\n+/// Feature cache with capacity for `CACHE_CAPACITY` features.\n+///\n+/// Note: the last feature bit is used to represent an\n+/// uninitialized cache.\n+#[cfg(target_pointer_width = \"64\")]\n+struct Cache(AtomicU64);\n+\n+#[cfg(target_pointer_width = \"64\")]\n+#[allow(clippy::use_self)]\n+impl Cache {\n+    /// Creates an uninitialized cache.\n+    #[allow(clippy::declare_interior_mutable_const)]\n+    const fn uninitialized() -> Self {\n+        Cache(AtomicU64::new(u64::max_value()))\n+    }\n+    /// Is the cache uninitialized?\n+    #[inline]\n+    pub(crate) fn is_uninitialized(&self) -> bool {\n+        self.0.load(Ordering::Relaxed) == u64::max_value()\n+    }\n+\n+    /// Is the `bit` in the cache set?\n+    #[inline]\n+    pub(crate) fn test(&self, bit: u32) -> bool {\n+        test_bit(CACHE.0.load(Ordering::Relaxed), bit)\n+    }\n+\n+    /// Initializes the cache.\n+    #[inline]\n+    pub(crate) fn initialize(&self, value: Initializer) {\n+        self.0.store(value.0, Ordering::Relaxed);\n+    }\n+}\n+\n+/// Feature cache with capacity for `CACHE_CAPACITY` features.\n+///\n+/// Note: the last feature bit is used to represent an\n+/// uninitialized cache.\n+#[cfg(target_pointer_width = \"32\")]\n+struct Cache(AtomicU32, AtomicU32);\n+\n+#[cfg(target_pointer_width = \"32\")]\n+impl Cache {\n+    /// Creates an uninitialized cache.\n+    const fn uninitialized() -> Self {\n+        Cache(\n+            AtomicU32::new(u32::max_value()),\n+            AtomicU32::new(u32::max_value()),\n+        )\n+    }\n+    /// Is the cache uninitialized?\n+    #[inline]\n+    pub(crate) fn is_uninitialized(&self) -> bool {\n+        self.1.load(Ordering::Relaxed) == u32::max_value()\n+    }\n+\n+    /// Is the `bit` in the cache set?\n+    #[inline]\n+    pub(crate) fn test(&self, bit: u32) -> bool {\n+        if bit < 32 {\n+            test_bit(CACHE.0.load(Ordering::Relaxed) as u64, bit)\n+        } else {\n+            test_bit(CACHE.1.load(Ordering::Relaxed) as u64, bit - 32)\n+        }\n+    }\n+\n+    /// Initializes the cache.\n+    #[inline]\n+    pub(crate) fn initialize(&self, value: Initializer) {\n+        let lo: u32 = value.0 as u32;\n+        let hi: u32 = (value.0 >> 32) as u32;\n+        self.0.store(lo, Ordering::Relaxed);\n+        self.1.store(hi, Ordering::Relaxed);\n+    }\n+}\n+\n+/// Tests the `bit` of the storage. If the storage has not been initialized,\n+/// initializes it with the result of `f()`.\n+///\n+/// On its first invocation, it detects the CPU features and caches them in the\n+/// `CACHE` global variable as an `AtomicU64`.\n+///\n+/// It uses the `Feature` variant to index into this variable as a bitset. If\n+/// the bit is set, the feature is enabled, and otherwise it is disabled.\n+#[inline]\n+pub(crate) fn test<F>(bit: u32, f: F) -> bool\n+where\n+    F: FnOnce() -> Initializer,\n+{\n+    if CACHE.is_uninitialized() {\n+        CACHE.initialize(f());\n+    }\n+    CACHE.test(bit)\n+}"}, {"sha": "6769757ed93319f76e44aa726c24cf1c2b40d4f6", "filename": "tests/source/cfg_if/detect/error_macros.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Ferror_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Ferror_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Ferror_macros.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,150 @@\n+//! The `is_{target_arch}_feature_detected!` macro are only available on their\n+//! architecture. These macros provide a better error messages when the user\n+//! attempts to call them in a different architecture.\n+\n+/// Prevents compilation if `is_x86_feature_detected` is used somewhere\n+/// else than `x86` and `x86_64` targets.\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_x86_feature_detected {\n+    ($t: tt) => {\n+        compile_error!(\n+            r#\"\n+        is_x86_feature_detected can only be used on x86 and x86_64 targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n+                if is_x86_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_arm_feature_detected` is used somewhere else\n+/// than `ARM` targets.\n+#[cfg(not(target_arch = \"arm\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_arm_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+        is_arm_feature_detected can only be used on ARM targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(target_arch = \"arm\")] {\n+                if is_arm_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_aarch64_feature_detected` is used somewhere else\n+/// than `aarch64` targets.\n+#[cfg(not(target_arch = \"aarch64\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_aarch64_feature_detected {\n+    ($t: tt) => {\n+        compile_error!(\n+            r#\"\n+        is_aarch64_feature_detected can only be used on AArch64 targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(target_arch = \"aarch64\")] {\n+                if is_aarch64_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_powerpc_feature_detected` is used somewhere else\n+/// than `PowerPC` targets.\n+#[cfg(not(target_arch = \"powerpc\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_powerpc_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+is_powerpc_feature_detected can only be used on PowerPC targets.\n+You can prevent it from being used in other architectures by\n+guarding it behind a cfg(target_arch) as follows:\n+\n+    #[cfg(target_arch = \"powerpc\")] {\n+        if is_powerpc_feature_detected(...) { ... }\n+    }\n+\"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_powerpc64_feature_detected` is used somewhere\n+/// else than `PowerPC64` targets.\n+#[cfg(not(target_arch = \"powerpc64\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_powerpc64_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+is_powerpc64_feature_detected can only be used on PowerPC64 targets.\n+You can prevent it from being used in other architectures by\n+guarding it behind a cfg(target_arch) as follows:\n+\n+    #[cfg(target_arch = \"powerpc64\")] {\n+        if is_powerpc64_feature_detected(...) { ... }\n+    }\n+\"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_mips_feature_detected` is used somewhere else\n+/// than `MIPS` targets.\n+#[cfg(not(target_arch = \"mips\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_mips_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+        is_mips_feature_detected can only be used on MIPS targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(target_arch = \"mips\")] {\n+                if is_mips_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_mips64_feature_detected` is used somewhere else\n+/// than `MIPS64` targets.\n+#[cfg(not(target_arch = \"mips64\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_mips64_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+        is_mips64_feature_detected can only be used on MIPS64 targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(target_arch = \"mips64\")] {\n+                if is_mips64_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}"}, {"sha": "f446e88eedc8ca1174cd80919e8dd22cee5771b3", "filename": "tests/source/cfg_if/detect/mod.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fmod.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,85 @@\n+//! This module implements run-time feature detection.\n+//!\n+//! The `is_{arch}_feature_detected!(\"feature-name\")` macros take the name of a\n+//! feature as a string-literal, and return a boolean indicating whether the\n+//! feature is enabled at run-time or not.\n+//!\n+//! These macros do two things:\n+//! * map the string-literal into an integer stored as a `Feature` enum,\n+//! * call a `os::check_for(x: Feature)` function that returns `true` if the\n+//! feature is enabled.\n+//!\n+//! The `Feature` enums are also implemented in the `arch/{target_arch}.rs`\n+//! modules.\n+//!\n+//! The `check_for` functions are, in general, Operating System dependent. Most\n+//! architectures do not allow user-space programs to query the feature bits\n+//! due to security concerns (x86 is the big exception). These functions are\n+//! implemented in the `os/{target_os}.rs` modules.\n+\n+#[macro_use]\n+mod error_macros;\n+\n+cfg_if! {\n+    if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n+        #[path = \"arch/x86.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"arm\")] {\n+        #[path = \"arch/arm.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"aarch64\")] {\n+        #[path = \"arch/aarch64.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"powerpc\")] {\n+        #[path = \"arch/powerpc.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"powerpc64\")] {\n+        #[path = \"arch/powerpc64.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"mips\")] {\n+        #[path = \"arch/mips.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"mips64\")] {\n+        #[path = \"arch/mips64.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else {\n+        // Unimplemented architecture:\n+        mod arch {\n+            pub enum Feature {\n+                Null\n+            }\n+        }\n+    }\n+}\n+pub use self::arch::Feature;\n+\n+mod bit;\n+mod cache;\n+\n+cfg_if! {\n+    if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n+        // On x86/x86_64 no OS specific functionality is required.\n+        #[path = \"os/x86.rs\"]\n+        mod os;\n+    } else if #[cfg(all(target_os = \"linux\", feature = \"use_std\"))] {\n+        #[path = \"os/linux/mod.rs\"]\n+        mod os;\n+    } else if #[cfg(target_os = \"freebsd\")] {\n+        #[cfg(target_arch = \"aarch64\")]\n+        #[path = \"os/aarch64.rs\"]\n+        mod aarch64;\n+        #[path = \"os/freebsd/mod.rs\"]\n+        mod os;\n+    } else {\n+        #[path = \"os/other.rs\"]\n+        mod os;\n+    }\n+}\n+pub use self::os::check_for;"}, {"sha": "dfb8c87707f08c17194088baeae82ec73c145019", "filename": "tests/source/cfg_if/detect/os/aarch64.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Faarch64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,79 @@\n+//! Run-time feature detection for Aarch64 on any OS that emulates the mrs instruction.\n+//!\n+//! On FreeBSD >= 12.0, Linux >= 4.11 and other operating systems, it is possible to use\n+//! privileged system registers from userspace to check CPU feature support.\n+//!\n+//! AArch64 system registers ID_AA64ISAR0_EL1, ID_AA64PFR0_EL1, ID_AA64ISAR1_EL1\n+//! have bits dedicated to features like AdvSIMD, CRC32, AES, atomics (LSE), etc.\n+//! Each part of the register indicates the level of support for a certain feature, e.g.\n+//! when ID_AA64ISAR0_EL1\\[7:4\\] is >= 1, AES is supported; when it's >= 2, PMULL is supported.\n+//!\n+//! For proper support of [SoCs where different cores have different capabilities](https://medium.com/@jadr2ddude/a-big-little-problem-a-tale-of-big-little-gone-wrong-e7778ce744bb),\n+//! the OS has to always report only the features supported by all cores, like [FreeBSD does](https://reviews.freebsd.org/D17137#393947).\n+//!\n+//! References:\n+//!\n+//! - [Zircon implementation](https://fuchsia.googlesource.com/zircon/+/master/kernel/arch/arm64/feature.cpp)\n+//! - [Linux documentation](https://www.kernel.org/doc/Documentation/arm64/cpu-feature-registers.txt)\n+\n+use crate::detect::{Feature, cache};\n+\n+/// Try to read the features from the system registers.\n+///\n+/// This will cause SIGILL if the current OS is not trapping the mrs instruction.\n+pub(crate) fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+\n+    {\n+        let mut enable_feature = |f, enable| {\n+            if enable {\n+                value.set(f as u32);\n+            }\n+        };\n+\n+        // ID_AA64ISAR0_EL1 - Instruction Set Attribute Register 0\n+        let aa64isar0: u64;\n+        unsafe { asm!(\"mrs $0, ID_AA64ISAR0_EL1\" : \"=r\"(aa64isar0)); }\n+\n+        let aes = bits_shift(aa64isar0, 7, 4) >= 1;\n+        let pmull = bits_shift(aa64isar0, 7, 4) >= 2;\n+        let sha1 = bits_shift(aa64isar0, 11, 8) >= 1;\n+        let sha2 = bits_shift(aa64isar0, 15, 12) >= 1;\n+        enable_feature(Feature::pmull, pmull);\n+        // Crypto is specified as AES + PMULL + SHA1 + SHA2 per LLVM/hosts.cpp\n+        enable_feature(Feature::crypto, aes && pmull && sha1 && sha2);\n+        enable_feature(Feature::lse, bits_shift(aa64isar0, 23, 20) >= 1);\n+        enable_feature(Feature::crc, bits_shift(aa64isar0, 19, 16) >= 1);\n+\n+        // ID_AA64PFR0_EL1 - Processor Feature Register 0\n+        let aa64pfr0: u64;\n+        unsafe { asm!(\"mrs $0, ID_AA64PFR0_EL1\" : \"=r\"(aa64pfr0)); }\n+\n+        let fp = bits_shift(aa64pfr0, 19, 16) < 0xF;\n+        let fphp = bits_shift(aa64pfr0, 19, 16) >= 1;\n+        let asimd = bits_shift(aa64pfr0, 23, 20) < 0xF;\n+        let asimdhp = bits_shift(aa64pfr0, 23, 20) >= 1;\n+        enable_feature(Feature::fp, fp);\n+        enable_feature(Feature::fp16, fphp);\n+        // SIMD support requires float support - if half-floats are\n+        // supported, it also requires half-float support:\n+        enable_feature(Feature::asimd, fp && asimd && (!fphp | asimdhp));\n+        // SIMD extensions require SIMD support:\n+        enable_feature(Feature::rdm, asimd && bits_shift(aa64isar0, 31, 28) >= 1);\n+        enable_feature(Feature::dotprod, asimd && bits_shift(aa64isar0, 47, 44) >= 1);\n+        enable_feature(Feature::sve, asimd && bits_shift(aa64pfr0, 35, 32) >= 1);\n+\n+        // ID_AA64ISAR1_EL1 - Instruction Set Attribute Register 1\n+        let aa64isar1: u64;\n+        unsafe { asm!(\"mrs $0, ID_AA64ISAR1_EL1\" : \"=r\"(aa64isar1)); }\n+\n+        enable_feature(Feature::rcpc, bits_shift(aa64isar1, 23, 20) >= 1);\n+    }\n+\n+    value\n+}\n+\n+#[inline]\n+fn bits_shift(x: u64, high: usize, low: usize) -> u64 {\n+    (x >> low) & ((1 << (high - low + 1)) - 1)\n+}"}, {"sha": "910d2f33b390469372271dd00acf449aff2a8c9a", "filename": "tests/source/cfg_if/detect/os/freebsd/aarch64.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Faarch64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,28 @@\n+//! Run-time feature detection for Aarch64 on FreeBSD.\n+\n+use crate::detect::{Feature, cache};\n+use super::super::aarch64::detect_features;\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn dump() {\n+        println!(\"asimd: {:?}\", is_aarch64_feature_detected!(\"asimd\"));\n+        println!(\"pmull: {:?}\", is_aarch64_feature_detected!(\"pmull\"));\n+        println!(\"fp: {:?}\", is_aarch64_feature_detected!(\"fp\"));\n+        println!(\"fp16: {:?}\", is_aarch64_feature_detected!(\"fp16\"));\n+        println!(\"sve: {:?}\", is_aarch64_feature_detected!(\"sve\"));\n+        println!(\"crc: {:?}\", is_aarch64_feature_detected!(\"crc\"));\n+        println!(\"crypto: {:?}\", is_aarch64_feature_detected!(\"crypto\"));\n+        println!(\"lse: {:?}\", is_aarch64_feature_detected!(\"lse\"));\n+        println!(\"rdm: {:?}\", is_aarch64_feature_detected!(\"rdm\"));\n+        println!(\"rcpc: {:?}\", is_aarch64_feature_detected!(\"rcpc\"));\n+        println!(\"dotprod: {:?}\", is_aarch64_feature_detected!(\"dotprod\"));\n+    }\n+}"}, {"sha": "e13847dcbd8951039cd279842388a64a99c78af2", "filename": "tests/source/cfg_if/detect/os/freebsd/arm.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Farm.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,27 @@\n+//! Run-time feature detection for ARM on FreeBSD\n+\n+use crate::detect::{Feature, cache};\n+use super::{auxvec};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    if let Ok(auxv) = auxvec::auxv() {\n+        enable_feature(&mut value, Feature::neon, auxv.hwcap & 0x00001000 != 0);\n+        enable_feature(&mut value, Feature::pmull, auxv.hwcap2 & 0x00000002 != 0);\n+        return value;\n+    }\n+    value\n+}"}, {"sha": "a2bac7676014d94a92f2284858e75ac4db8bd834", "filename": "tests/source/cfg_if/detect/os/freebsd/auxvec.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fauxvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fauxvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fauxvec.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,86 @@\n+//! Parses ELF auxiliary vectors.\n+#![cfg_attr(any(target_arch = \"arm\", target_arch = \"powerpc64\"), allow(dead_code))]\n+\n+/// Key to access the CPU Hardware capabilities bitfield.\n+pub(crate) const AT_HWCAP: usize = 25;\n+/// Key to access the CPU Hardware capabilities 2 bitfield.\n+pub(crate) const AT_HWCAP2: usize = 26;\n+\n+/// Cache HWCAP bitfields of the ELF Auxiliary Vector.\n+///\n+/// If an entry cannot be read all the bits in the bitfield are set to zero.\n+/// This should be interpreted as all the features being disabled.\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) struct AuxVec {\n+    pub hwcap: usize,\n+    pub hwcap2: usize,\n+}\n+\n+/// ELF Auxiliary Vector\n+///\n+/// The auxiliary vector is a memory region in a running ELF program's stack\n+/// composed of (key: usize, value: usize) pairs.\n+///\n+/// The keys used in the aux vector are platform dependent. For FreeBSD, they are\n+/// defined in [sys/elf_common.h][elf_common_h]. The hardware capabilities of a given\n+/// CPU can be queried with the  `AT_HWCAP` and `AT_HWCAP2` keys.\n+///\n+/// Note that run-time feature detection is not invoked for features that can\n+/// be detected at compile-time.\n+///\n+/// [elf_common.h]: https://svnweb.freebsd.org/base/release/12.0.0/sys/sys/elf_common.h?revision=341707\n+pub(crate) fn auxv() -> Result<AuxVec, ()> {\n+    if let Ok(hwcap) = archauxv(AT_HWCAP) {\n+        if let Ok(hwcap2) = archauxv(AT_HWCAP2) {\n+            if hwcap != 0 && hwcap2 != 0 {\n+                return Ok(AuxVec { hwcap, hwcap2 });\n+            }\n+        }\n+    }\n+    Err(())\n+}\n+\n+/// Tries to read the `key` from the auxiliary vector.\n+fn archauxv(key: usize) -> Result<usize, ()> {\n+    use crate::mem;\n+\n+    #[derive (Copy, Clone)]\n+    #[repr(C)]\n+    pub struct Elf_Auxinfo {\n+        pub a_type: usize,\n+        pub a_un: unnamed,\n+    }\n+    #[derive (Copy, Clone)]\n+    #[repr(C)]\n+    pub union unnamed {\n+        pub a_val: libc::c_long,\n+        pub a_ptr: *mut libc::c_void,\n+        pub a_fcn: Option<unsafe extern \"C\" fn() -> ()>,\n+    }\n+\n+    let mut auxv: [Elf_Auxinfo; 27] =\n+        [Elf_Auxinfo{a_type: 0, a_un: unnamed{a_val: 0,},}; 27];\n+\n+    let mut len: libc::c_uint = mem::size_of_val(&auxv) as libc::c_uint;\n+\n+    unsafe {\n+        let mut mib = [libc::CTL_KERN, libc::KERN_PROC, libc::KERN_PROC_AUXV, libc::getpid()];\n+    \n+        let ret = libc::sysctl(mib.as_mut_ptr(),\n+                       mib.len() as u32,\n+                       &mut auxv as *mut _ as *mut _,\n+                       &mut len as *mut _ as *mut _,\n+                       0 as *mut libc::c_void,\n+                       0,\n+                );\n+    \n+        if ret != -1 {\n+            for i in 0..auxv.len() {\n+                if auxv[i].a_type == key {\n+                    return Ok(auxv[i].a_un.a_val as usize);\n+                }\n+            }\n+        }\n+    }\n+    return Ok(0);\n+}"}, {"sha": "1a5338a3555958c559a1dc247b7b64ea85f47be5", "filename": "tests/source/cfg_if/detect/os/freebsd/mod.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fmod.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,22 @@\n+//! Run-time feature detection on FreeBSD\n+\n+mod auxvec;\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"aarch64\")] {\n+        mod aarch64;\n+        pub use self::aarch64::check_for;\n+    } else if #[cfg(target_arch = \"arm\")] {\n+        mod arm;\n+        pub use self::arm::check_for;\n+    } else if #[cfg(target_arch = \"powerpc64\")] {\n+        mod powerpc;\n+        pub use self::powerpc::check_for;\n+    } else {\n+        use crate::arch::detect::Feature;\n+        /// Performs run-time feature detection.\n+        pub fn check_for(_x: Feature) -> bool {\n+            false\n+        }\n+    }\n+}"}, {"sha": "c7f761d4d60585a41a3fdfbc667d0cbbfd4c0c99", "filename": "tests/source/cfg_if/detect/os/freebsd/powerpc.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fpowerpc.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,27 @@\n+//! Run-time feature detection for PowerPC on FreeBSD.\n+\n+use crate::detect::{Feature, cache};\n+use super::{auxvec};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    if let Ok(auxv) = auxvec::auxv() {\n+        enable_feature(&mut value, Feature::altivec, auxv.hwcap & 0x10000000 != 0);\n+        enable_feature(&mut value, Feature::vsx, auxv.hwcap & 0x00000080 != 0);\n+        enable_feature(&mut value, Feature::power8, auxv.hwcap2 & 0x80000000 != 0);\n+        return value;\n+    }\n+    value\n+}"}, {"sha": "f7dc0f0222e5941cd9a88b240aaabba940573e7e", "filename": "tests/source/cfg_if/detect/os/linux/aarch64.rs", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Faarch64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,157 @@\n+//! Run-time feature detection for Aarch64 on Linux.\n+\n+use crate::detect::{Feature, cache, bit};\n+use super::{auxvec, cpuinfo};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector, and if that fails, try\n+/// to read them from /proc/cpuinfo.\n+fn detect_features() -> cache::Initializer {\n+    if let Ok(auxv) = auxvec::auxv() {\n+        let hwcap: AtHwcap = auxv.into();\n+        return hwcap.cache();\n+    }\n+    if let Ok(c) = cpuinfo::CpuInfo::new() {\n+        let hwcap: AtHwcap = c.into();\n+        return hwcap.cache();\n+    }\n+    cache::Initializer::default()\n+}\n+\n+/// These values are part of the platform-specific [asm/hwcap.h][hwcap] .\n+///\n+/// [hwcap]: https://github.com/torvalds/linux/blob/master/arch/arm64/include/uapi/asm/hwcap.h\n+struct AtHwcap {\n+    fp: bool, // 0\n+    asimd: bool, // 1\n+    // evtstrm: bool, // 2\n+    aes: bool, // 3\n+    pmull: bool, // 4\n+    sha1: bool, // 5\n+    sha2: bool, // 6\n+    crc32: bool, // 7\n+    atomics: bool, // 8\n+    fphp: bool, // 9\n+    asimdhp: bool, // 10\n+    // cpuid: bool, // 11\n+    asimdrdm: bool, // 12\n+    // jscvt: bool, // 13\n+    // fcma: bool, // 14\n+    lrcpc: bool, // 15\n+    // dcpop: bool, // 16\n+    // sha3: bool, // 17\n+    // sm3: bool, // 18\n+    // sm4: bool, // 19\n+    asimddp: bool, // 20\n+    // sha512: bool, // 21\n+    sve: bool, // 22\n+}\n+\n+impl From<auxvec::AuxVec> for AtHwcap {\n+    /// Reads AtHwcap from the auxiliary vector.\n+    fn from(auxv: auxvec::AuxVec) -> Self {\n+        AtHwcap {\n+            fp: bit::test(auxv.hwcap, 0),\n+            asimd: bit::test(auxv.hwcap, 1),\n+            // evtstrm: bit::test(auxv.hwcap, 2),\n+            aes: bit::test(auxv.hwcap, 3),\n+            pmull: bit::test(auxv.hwcap, 4),\n+            sha1: bit::test(auxv.hwcap, 5),\n+            sha2: bit::test(auxv.hwcap, 6),\n+            crc32: bit::test(auxv.hwcap, 7),\n+            atomics: bit::test(auxv.hwcap, 8),\n+            fphp: bit::test(auxv.hwcap, 9),\n+            asimdhp: bit::test(auxv.hwcap, 10),\n+            // cpuid: bit::test(auxv.hwcap, 11),\n+            asimdrdm: bit::test(auxv.hwcap, 12),\n+            // jscvt: bit::test(auxv.hwcap, 13),\n+            // fcma: bit::test(auxv.hwcap, 14),\n+            lrcpc: bit::test(auxv.hwcap, 15),\n+            // dcpop: bit::test(auxv.hwcap, 16),\n+            // sha3: bit::test(auxv.hwcap, 17),\n+            // sm3: bit::test(auxv.hwcap, 18),\n+            // sm4: bit::test(auxv.hwcap, 19),\n+            asimddp: bit::test(auxv.hwcap, 20),\n+            // sha512: bit::test(auxv.hwcap, 21),\n+            sve: bit::test(auxv.hwcap, 22),\n+        }\n+    }\n+}\n+\n+impl From<cpuinfo::CpuInfo> for AtHwcap {\n+    /// Reads AtHwcap from /proc/cpuinfo .\n+    fn from(c: cpuinfo::CpuInfo) -> Self {\n+        let f = &c.field(\"Features\");\n+        AtHwcap {\n+            // 64-bit names. FIXME: In 32-bit compatibility mode /proc/cpuinfo will\n+            // map some of the 64-bit names to some 32-bit feature names. This does not\n+            // cover that yet.\n+            fp: f.has(\"fp\"),\n+            asimd: f.has(\"asimd\"),\n+            // evtstrm: f.has(\"evtstrm\"),\n+            aes: f.has(\"aes\"),\n+            pmull: f.has(\"pmull\"),\n+            sha1: f.has(\"sha1\"),\n+            sha2: f.has(\"sha2\"),\n+            crc32: f.has(\"crc32\"),\n+            atomics: f.has(\"atomics\"),\n+            fphp: f.has(\"fphp\"),\n+            asimdhp: f.has(\"asimdhp\"),\n+            // cpuid: f.has(\"cpuid\"),\n+            asimdrdm: f.has(\"asimdrdm\"),\n+            // jscvt: f.has(\"jscvt\"),\n+            // fcma: f.has(\"fcma\"),\n+            lrcpc: f.has(\"lrcpc\"),\n+            // dcpop: f.has(\"dcpop\"),\n+            // sha3: f.has(\"sha3\"),\n+            // sm3: f.has(\"sm3\"),\n+            // sm4: f.has(\"sm4\"),\n+            asimddp: f.has(\"asimddp\"),\n+            // sha512: f.has(\"sha512\"),\n+            sve: f.has(\"sve\"),\n+        }\n+    }\n+}\n+\n+impl AtHwcap {\n+    /// Initializes the cache from the feature -bits.\n+    ///\n+    /// The features are enabled approximately like in LLVM host feature detection:\n+    /// https://github.com/llvm-mirror/llvm/blob/master/lib/Support/Host.cpp#L1273\n+    fn cache(self) -> cache::Initializer {\n+        let mut value = cache::Initializer::default();\n+        {\n+            let mut enable_feature = |f, enable| {\n+                if enable {\n+                    value.set(f as u32);\n+                }\n+            };\n+\n+            enable_feature(Feature::fp, self.fp);\n+            // Half-float support requires float support\n+            enable_feature(Feature::fp16, self.fp && self.fphp);\n+            enable_feature(Feature::pmull, self.pmull);\n+            enable_feature(Feature::crc, self.crc32);\n+            enable_feature(Feature::lse, self.atomics);\n+            enable_feature(Feature::rcpc, self.lrcpc);\n+\n+            // SIMD support requires float support - if half-floats are\n+            // supported, it also requires half-float support:\n+            let asimd = self.fp && self.asimd && (!self.fphp | self.asimdhp);\n+            enable_feature(Feature::asimd, asimd);\n+            // SIMD extensions require SIMD support:\n+            enable_feature(Feature::rdm, self.asimdrdm && asimd);\n+            enable_feature(Feature::dotprod, self.asimddp && asimd);\n+            enable_feature(Feature::sve, self.sve && asimd);\n+\n+            // Crypto is specified as AES + PMULL + SHA1 + SHA2 per LLVM/hosts.cpp\n+            enable_feature(Feature::crypto, self.aes && self.pmull && self.sha1 && self.sha2);\n+        }\n+        value\n+    }\n+}"}, {"sha": "0d58a847cd626e1c4778e78b1f8a7599f650fe6a", "filename": "tests/source/cfg_if/detect/os/linux/arm.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Farm.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,49 @@\n+//! Run-time feature detection for ARM on Linux.\n+\n+use crate::detect::{Feature, cache, bit};\n+use super::{auxvec, cpuinfo};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector, and if that fails, try\n+/// to read them from /proc/cpuinfo.\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    // The values are part of the platform-specific [asm/hwcap.h][hwcap]\n+    //\n+    // [hwcap]: https://github.com/torvalds/linux/blob/master/arch/arm64/include/uapi/asm/hwcap.h\n+    if let Ok(auxv) = auxvec::auxv() {\n+        enable_feature(&mut value, Feature::neon, bit::test(auxv.hwcap, 12));\n+        enable_feature(&mut value, Feature::pmull, bit::test(auxv.hwcap2, 1));\n+        return value;\n+    }\n+\n+    if let Ok(c) = cpuinfo::CpuInfo::new() {\n+        enable_feature(&mut value, Feature::neon, c.field(\"Features\").has(\"neon\") &&\n+            !has_broken_neon(&c));\n+        enable_feature(&mut value, Feature::pmull, c.field(\"Features\").has(\"pmull\"));\n+        return value;\n+    }\n+    value\n+}\n+\n+/// Is the CPU known to have a broken NEON unit?\n+///\n+/// See https://crbug.com/341598.\n+fn has_broken_neon(cpuinfo: &cpuinfo::CpuInfo) -> bool {\n+    cpuinfo.field(\"CPU implementer\") == \"0x51\"\n+        && cpuinfo.field(\"CPU architecture\") == \"7\"\n+        && cpuinfo.field(\"CPU variant\") == \"0x1\"\n+        && cpuinfo.field(\"CPU part\") == \"0x04d\"\n+        && cpuinfo.field(\"CPU revision\") == \"0\"\n+}"}, {"sha": "07b6432eafd9871668057dbc4753163b3d627cae", "filename": "tests/source/cfg_if/detect/os/linux/auxvec.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fauxvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fauxvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fauxvec.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,307 @@\n+//! Parses ELF auxiliary vectors.\n+#![cfg_attr(not(target_arch = \"aarch64\"), allow(dead_code))]\n+\n+#[cfg(feature = \"std_detect_file_io\")]\n+use crate::{fs::File, io::Read};\n+\n+/// Key to access the CPU Hardware capabilities bitfield.\n+pub(crate) const AT_HWCAP: usize = 16;\n+/// Key to access the CPU Hardware capabilities 2 bitfield.\n+#[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+pub(crate) const AT_HWCAP2: usize = 26;\n+\n+/// Cache HWCAP bitfields of the ELF Auxiliary Vector.\n+///\n+/// If an entry cannot be read all the bits in the bitfield are set to zero.\n+/// This should be interpreted as all the features being disabled.\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) struct AuxVec {\n+    pub hwcap: usize,\n+    #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+    pub hwcap2: usize,\n+}\n+\n+/// ELF Auxiliary Vector\n+///\n+/// The auxiliary vector is a memory region in a running ELF program's stack\n+/// composed of (key: usize, value: usize) pairs.\n+///\n+/// The keys used in the aux vector are platform dependent. For Linux, they are\n+/// defined in [linux/auxvec.h][auxvec_h]. The hardware capabilities of a given\n+/// CPU can be queried with the  `AT_HWCAP` and `AT_HWCAP2` keys.\n+///\n+/// There is no perfect way of reading the auxiliary vector.\n+///\n+/// - If the `std_detect_dlsym_getauxval` cargo feature is enabled, this will use\n+/// `getauxval` if its linked to the binary, and otherwise proceed to a fallback implementation.\n+/// When `std_detect_dlsym_getauxval` is disabled, this will assume that `getauxval` is\n+/// linked to the binary - if that is not the case the behavior is undefined.\n+/// - Otherwise, if the `std_detect_file_io` cargo feature is enabled, it will\n+///   try to read `/proc/self/auxv`.\n+/// - If that fails, this function returns an error.\n+///\n+/// Note that run-time feature detection is not invoked for features that can\n+/// be detected at compile-time. Also note that if this function returns an\n+/// error, cpuinfo still can (and will) be used to try to perform run-time\n+/// feature detecton on some platforms.\n+///\n+/// For more information about when `getauxval` is available check the great\n+/// [`auxv` crate documentation][auxv_docs].\n+///\n+/// [auxvec_h]: https://github.com/torvalds/linux/blob/master/include/uapi/linux/auxvec.h\n+/// [auxv_docs]: https://docs.rs/auxv/0.3.3/auxv/\n+pub(crate) fn auxv() -> Result<AuxVec, ()> {\n+    #[cfg(feature = \"std_detect_dlsym_getauxval\")] {\n+        // Try to call a dynamically-linked getauxval function.\n+        if let Ok(hwcap) = getauxval(AT_HWCAP) {\n+            // Targets with only AT_HWCAP:\n+            #[cfg(any(target_arch = \"aarch64\", target_arch = \"mips\",\n+                      target_arch = \"mips64\"))]\n+            {\n+                if hwcap != 0 {\n+                    return Ok(AuxVec { hwcap });\n+                }\n+            }\n+\n+            // Targets with AT_HWCAP and AT_HWCAP2:\n+            #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+            {\n+                if let Ok(hwcap2) = getauxval(AT_HWCAP2) {\n+                    if hwcap != 0 && hwcap2 != 0 {\n+                        return Ok(AuxVec { hwcap, hwcap2 });\n+                    }\n+                }\n+            }\n+            drop(hwcap);\n+        }\n+        #[cfg(feature = \"std_detect_file_io\")] {\n+            // If calling getauxval fails, try to read the auxiliary vector from\n+            // its file:\n+            auxv_from_file(\"/proc/self/auxv\")\n+        }\n+        #[cfg(not(feature = \"std_detect_file_io\"))] {\n+            Err(())\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"std_detect_dlsym_getauxval\"))] {\n+        let hwcap = unsafe { ffi_getauxval(AT_HWCAP) };\n+\n+        // Targets with only AT_HWCAP:\n+        #[cfg(any(target_arch = \"aarch64\", target_arch = \"mips\",\n+                  target_arch = \"mips64\"))]\n+        {\n+            if hwcap != 0 {\n+                return Ok(AuxVec { hwcap });\n+            }\n+        }\n+\n+        // Targets with AT_HWCAP and AT_HWCAP2:\n+        #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+        {\n+            let hwcap2 = unsafe { ffi_getauxval(AT_HWCAP2) };\n+            if hwcap != 0 && hwcap2 != 0 {\n+                return Ok(AuxVec { hwcap, hwcap2 });\n+            }\n+        }\n+    }\n+}\n+\n+/// Tries to read the `key` from the auxiliary vector by calling the\n+/// dynamically-linked `getauxval` function. If the function is not linked,\n+/// this function return `Err`.\n+#[cfg(feature = \"std_detect_dlsym_getauxval\")]\n+fn getauxval(key: usize) -> Result<usize, ()> {\n+    use libc;\n+    pub type F = unsafe extern \"C\" fn(usize) -> usize;\n+    unsafe {\n+        let ptr = libc::dlsym(\n+            libc::RTLD_DEFAULT,\n+            \"getauxval\\0\".as_ptr() as *const _,\n+        );\n+        if ptr.is_null() {\n+            return Err(());\n+        }\n+\n+        let ffi_getauxval: F = mem::transmute(ptr);\n+        Ok(ffi_getauxval(key))\n+    }\n+}\n+\n+/// Tries to read the auxiliary vector from the `file`. If this fails, this\n+/// function returns `Err`.\n+#[cfg(feature = \"std_detect_file_io\")]\n+fn auxv_from_file(file: &str) -> Result<AuxVec, ()> {\n+    let mut file = File::open(file).map_err(|_| ())?;\n+\n+    // See <https://github.com/torvalds/linux/blob/v3.19/include/uapi/linux/auxvec.h>.\n+    //\n+    // The auxiliary vector contains at most 32 (key,value) fields: from\n+    // `AT_EXECFN = 31` to `AT_NULL = 0`. That is, a buffer of\n+    // 2*32 `usize` elements is enough to read the whole vector.\n+    let mut buf = [0_usize; 64];\n+    {\n+        let raw: &mut [u8; 64 * mem::size_of::<usize>()] =\n+            unsafe { mem::transmute(&mut buf) };\n+        file.read(raw).map_err(|_| ())?;\n+    }\n+    auxv_from_buf(&buf)\n+}\n+\n+/// Tries to interpret the `buffer` as an auxiliary vector. If that fails, this\n+/// function returns `Err`.\n+#[cfg(feature = \"std_detect_file_io\")]\n+fn auxv_from_buf(buf: &[usize; 64]) -> Result<AuxVec, ()> {\n+    // Targets with only AT_HWCAP:\n+    #[cfg(any(target_arch = \"aarch64\", target_arch = \"mips\",\n+              target_arch = \"mips64\"))]\n+    {\n+        for el in buf.chunks(2) {\n+            match el[0] {\n+                AT_HWCAP => return Ok(AuxVec { hwcap: el[1] }),\n+                _ => (),\n+            }\n+        }\n+    }\n+    // Targets with AT_HWCAP and AT_HWCAP2:\n+    #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+    {\n+        let mut hwcap = None;\n+        let mut hwcap2 = None;\n+        for el in buf.chunks(2) {\n+            match el[0] {\n+                AT_HWCAP => hwcap = Some(el[1]),\n+                AT_HWCAP2 => hwcap2 = Some(el[1]),\n+                _ => (),\n+            }\n+        }\n+\n+        if let (Some(hwcap), Some(hwcap2)) = (hwcap, hwcap2) {\n+            return Ok(AuxVec { hwcap, hwcap2 });\n+        }\n+    }\n+    drop(buf);\n+    Err(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    extern crate auxv as auxv_crate;\n+    use super::*;\n+\n+    // Reads the Auxiliary Vector key from /proc/self/auxv\n+    // using the auxv crate.\n+    #[cfg(feature = \"std_detect_file_io\")]\n+    fn auxv_crate_getprocfs(key: usize) -> Option<usize> {\n+        use self::auxv_crate::AuxvType;\n+        use self::auxv_crate::procfs::search_procfs_auxv;\n+        let k = key as AuxvType;\n+        match search_procfs_auxv(&[k]) {\n+            Ok(v) => Some(v[&k] as usize),\n+            Err(_) => None,\n+        }\n+    }\n+\n+    // Reads the Auxiliary Vector key from getauxval()\n+    // using the auxv crate.\n+    #[cfg(not(any(target_arch = \"mips\", target_arch = \"mips64\")))]\n+    fn auxv_crate_getauxval(key: usize) -> Option<usize> {\n+        use self::auxv_crate::AuxvType;\n+        use self::auxv_crate::getauxval::Getauxval;\n+        let q = auxv_crate::getauxval::NativeGetauxval {};\n+        match q.getauxval(key as AuxvType) {\n+            Ok(v) => Some(v as usize),\n+            Err(_) => None,\n+        }\n+    }\n+\n+    // FIXME: on mips/mips64 getauxval returns 0, and /proc/self/auxv\n+    // does not always contain the AT_HWCAP key under qemu.\n+    #[cfg(not(any(target_arch = \"mips\", target_arch = \"mips64\", target_arch = \"powerpc\")))]\n+    #[test]\n+    fn auxv_crate() {\n+        let v = auxv();\n+        if let Some(hwcap) = auxv_crate_getauxval(AT_HWCAP) {\n+            let rt_hwcap = v.expect(\"failed to find hwcap key\").hwcap;\n+            assert_eq!(rt_hwcap, hwcap);\n+        }\n+\n+        // Targets with AT_HWCAP and AT_HWCAP2:\n+        #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+        {\n+            if let Some(hwcap2) = auxv_crate_getauxval(AT_HWCAP2) {\n+                let rt_hwcap2 = v.expect(\"failed to find hwcap2 key\").hwcap2;\n+                assert_eq!(rt_hwcap2, hwcap2);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn auxv_dump() {\n+        if let Ok(auxvec) = auxv() {\n+            println!(\"{:?}\", auxvec);\n+        } else {\n+            println!(\"both getauxval() and reading /proc/self/auxv failed!\");\n+        }\n+    }\n+\n+    #[cfg(feature = \"std_detect_file_io\")]\n+    cfg_if! {\n+        if #[cfg(target_arch = \"arm\")] {\n+            #[test]\n+            fn linux_rpi3() {\n+                let file = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/detect/test_data/linux-rpi3.auxv\");\n+                println!(\"file: {}\", file);\n+                let v = auxv_from_file(file).unwrap();\n+                assert_eq!(v.hwcap, 4174038);\n+                assert_eq!(v.hwcap2, 16);\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn linux_macos_vb() {\n+                let file = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/detect/test_data/macos-virtualbox-linux-x86-4850HQ.auxv\");\n+                println!(\"file: {}\", file);\n+                let v = auxv_from_file(file).unwrap();\n+                // this file is incomplete (contains hwcap but not hwcap2), we\n+                // want to fall back to /proc/cpuinfo in this case, so\n+                // reading should fail. assert_eq!(v.hwcap, 126614527);\n+                // assert_eq!(v.hwcap2, 0);\n+            }\n+        } else if #[cfg(target_arch = \"aarch64\")] {\n+            #[test]\n+            fn linux_x64() {\n+                let file = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/detect/test_data/linux-x64-i7-6850k.auxv\");\n+                println!(\"file: {}\", file);\n+                let v = auxv_from_file(file).unwrap();\n+                assert_eq!(v.hwcap, 3219913727);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    #[cfg(feature = \"std_detect_file_io\")]\n+    fn auxv_dump_procfs() {\n+        if let Ok(auxvec) = auxv_from_file(\"/proc/self/auxv\") {\n+            println!(\"{:?}\", auxvec);\n+        } else {\n+            println!(\"reading /proc/self/auxv failed!\");\n+        }\n+    }\n+\n+    #[test]\n+    fn auxv_crate_procfs() {\n+        let v = auxv();\n+        if let Some(hwcap) = auxv_crate_getprocfs(AT_HWCAP) {\n+            assert_eq!(v.unwrap().hwcap, hwcap);\n+        }\n+\n+        // Targets with AT_HWCAP and AT_HWCAP2:\n+        #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+        {\n+            if let Some(hwcap2) = auxv_crate_getprocfs(AT_HWCAP2) {\n+                assert_eq!(v.unwrap().hwcap2, hwcap2);\n+            }\n+        }\n+    }\n+}"}, {"sha": "b3168578537fc1ba08c8e55fc7ca2b06085e8248", "filename": "tests/source/cfg_if/detect/os/linux/cpuinfo.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fcpuinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fcpuinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fcpuinfo.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,301 @@\n+//! Parses /proc/cpuinfo\n+#![cfg_attr(not(target_arch = \"arm\"), allow(dead_code))]\n+\n+extern crate std;\n+use self::std::{prelude::v1::*, fs::File, io, io::Read};\n+\n+/// cpuinfo\n+pub(crate) struct CpuInfo {\n+    raw: String,\n+}\n+\n+impl CpuInfo {\n+    /// Reads /proc/cpuinfo into CpuInfo.\n+    pub(crate) fn new() -> Result<Self, io::Error> {\n+        let mut file = File::open(\"/proc/cpuinfo\")?;\n+        let mut cpui = Self { raw: String::new() };\n+        file.read_to_string(&mut cpui.raw)?;\n+        Ok(cpui)\n+    }\n+    /// Returns the value of the cpuinfo `field`.\n+    pub(crate) fn field(&self, field: &str) -> CpuInfoField {\n+        for l in self.raw.lines() {\n+            if l.trim().starts_with(field) {\n+                return CpuInfoField::new(l.split(\": \").nth(1));\n+            }\n+        }\n+        CpuInfoField(None)\n+    }\n+\n+    /// Returns the `raw` contents of `/proc/cpuinfo`\n+    #[cfg(test)]\n+    fn raw(&self) -> &String {\n+        &self.raw\n+    }\n+\n+    #[cfg(test)]\n+    fn from_str(other: &str) -> Result<Self, ::std::io::Error> {\n+        Ok(Self {\n+            raw: String::from(other),\n+        })\n+    }\n+}\n+\n+/// Field of cpuinfo\n+#[derive(Debug)]\n+pub(crate) struct CpuInfoField<'a>(Option<&'a str>);\n+\n+impl<'a> PartialEq<&'a str> for CpuInfoField<'a> {\n+    fn eq(&self, other: &&'a str) -> bool {\n+        match self.0 {\n+            None => other.is_empty(),\n+            Some(f) => f == other.trim(),\n+        }\n+    }\n+}\n+\n+impl<'a> CpuInfoField<'a> {\n+    pub(crate) fn new<'b>(v: Option<&'b str>) -> CpuInfoField<'b> {\n+        match v {\n+            None => CpuInfoField::<'b>(None),\n+            Some(f) => CpuInfoField::<'b>(Some(f.trim())),\n+        }\n+    }\n+    /// Does the field exist?\n+    #[cfg(test)]\n+    pub(crate) fn exists(&self) -> bool {\n+        self.0.is_some()\n+    }\n+    /// Does the field contain `other`?\n+    pub(crate) fn has(&self, other: &str) -> bool {\n+        match self.0 {\n+            None => other.is_empty(),\n+            Some(f) => {\n+                let other = other.trim();\n+                for v in f.split(' ') {\n+                    if v == other {\n+                        return true;\n+                    }\n+                }\n+                false\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn raw_dump() {\n+        let cpuinfo = CpuInfo::new().unwrap();\n+        if cpuinfo.field(\"vendor_id\") == \"GenuineIntel\" {\n+            assert!(cpuinfo.field(\"flags\").exists());\n+            assert!(!cpuinfo.field(\"vendor33_id\").exists());\n+            assert!(cpuinfo.field(\"flags\").has(\"sse\"));\n+            assert!(!cpuinfo.field(\"flags\").has(\"avx314\"));\n+        }\n+        println!(\"{}\", cpuinfo.raw());\n+    }\n+\n+    const CORE_DUO_T6500: &str = r\"processor       : 0\n+vendor_id       : GenuineIntel\n+cpu family      : 6\n+model           : 23\n+model name      : Intel(R) Core(TM)2 Duo CPU     T6500  @ 2.10GHz\n+stepping        : 10\n+microcode       : 0xa0b\n+cpu MHz         : 1600.000\n+cache size      : 2048 KB\n+physical id     : 0\n+siblings        : 2\n+core id         : 0\n+cpu cores       : 2\n+apicid          : 0\n+initial apicid  : 0\n+fdiv_bug        : no\n+hlt_bug         : no\n+f00f_bug        : no\n+coma_bug        : no\n+fpu             : yes\n+fpu_exception   : yes\n+cpuid level     : 13\n+wp              : yes\n+flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe nx lm constant_tsc arch_perfmon pebs bts aperfmperf pni dtes64 monitor ds_cpl est tm2 ssse3 cx16 xtpr pdcm sse4_1 xsave lahf_lm dtherm\n+bogomips        : 4190.43\n+clflush size    : 64\n+cache_alignment : 64\n+address sizes   : 36 bits physical, 48 bits virtual\n+power management:\n+\";\n+\n+    #[test]\n+    fn core_duo_t6500() {\n+        let cpuinfo = CpuInfo::from_str(CORE_DUO_T6500).unwrap();\n+        assert_eq!(cpuinfo.field(\"vendor_id\"), \"GenuineIntel\");\n+        assert_eq!(cpuinfo.field(\"cpu family\"), \"6\");\n+        assert_eq!(cpuinfo.field(\"model\"), \"23\");\n+        assert_eq!(\n+            cpuinfo.field(\"model name\"),\n+            \"Intel(R) Core(TM)2 Duo CPU     T6500  @ 2.10GHz\"\n+        );\n+        assert_eq!(\n+            cpuinfo.field(\"flags\"),\n+            \"fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe nx lm constant_tsc arch_perfmon pebs bts aperfmperf pni dtes64 monitor ds_cpl est tm2 ssse3 cx16 xtpr pdcm sse4_1 xsave lahf_lm dtherm\"\n+        );\n+        assert!(cpuinfo.field(\"flags\").has(\"fpu\"));\n+        assert!(cpuinfo.field(\"flags\").has(\"dtherm\"));\n+        assert!(cpuinfo.field(\"flags\").has(\"sse2\"));\n+        assert!(!cpuinfo.field(\"flags\").has(\"avx\"));\n+    }\n+\n+    const ARM_CORTEX_A53: &str =\n+        r\"Processor   : AArch64 Processor rev 3 (aarch64)\n+        processor   : 0\n+        processor   : 1\n+        processor   : 2\n+        processor   : 3\n+        processor   : 4\n+        processor   : 5\n+        processor   : 6\n+        processor   : 7\n+        Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32\n+        CPU implementer : 0x41\n+        CPU architecture: AArch64\n+        CPU variant : 0x0\n+        CPU part    : 0xd03\n+        CPU revision    : 3\n+\n+        Hardware    : HiKey Development Board\n+        \";\n+\n+    #[test]\n+    fn arm_cortex_a53() {\n+        let cpuinfo = CpuInfo::from_str(ARM_CORTEX_A53).unwrap();\n+        assert_eq!(\n+            cpuinfo.field(\"Processor\"),\n+            \"AArch64 Processor rev 3 (aarch64)\"\n+        );\n+        assert_eq!(\n+            cpuinfo.field(\"Features\"),\n+            \"fp asimd evtstrm aes pmull sha1 sha2 crc32\"\n+        );\n+        assert!(cpuinfo.field(\"Features\").has(\"pmull\"));\n+        assert!(!cpuinfo.field(\"Features\").has(\"neon\"));\n+        assert!(cpuinfo.field(\"Features\").has(\"asimd\"));\n+    }\n+\n+    const ARM_CORTEX_A57: &str = r\"Processor\t: Cortex A57 Processor rev 1 (aarch64)\n+processor\t: 0\n+processor\t: 1\n+processor\t: 2\n+processor\t: 3\n+Features\t: fp asimd aes pmull sha1 sha2 crc32 wp half thumb fastmult vfp edsp neon vfpv3 tlsi vfpv4 idiva idivt\n+CPU implementer\t: 0x41\n+CPU architecture: 8\n+CPU variant\t: 0x1\n+CPU part\t: 0xd07\n+CPU revision\t: 1\";\n+\n+    #[test]\n+    fn arm_cortex_a57() {\n+        let cpuinfo = CpuInfo::from_str(ARM_CORTEX_A57).unwrap();\n+        assert_eq!(\n+            cpuinfo.field(\"Processor\"),\n+            \"Cortex A57 Processor rev 1 (aarch64)\"\n+        );\n+        assert_eq!(\n+            cpuinfo.field(\"Features\"),\n+            \"fp asimd aes pmull sha1 sha2 crc32 wp half thumb fastmult vfp edsp neon vfpv3 tlsi vfpv4 idiva idivt\"\n+        );\n+        assert!(cpuinfo.field(\"Features\").has(\"pmull\"));\n+        assert!(cpuinfo.field(\"Features\").has(\"neon\"));\n+        assert!(cpuinfo.field(\"Features\").has(\"asimd\"));\n+    }\n+\n+    const POWER8E_POWERKVM: &str = r\"processor       : 0\n+cpu             : POWER8E (raw), altivec supported\n+clock           : 3425.000000MHz\n+revision        : 2.1 (pvr 004b 0201)\n+\n+processor       : 1\n+cpu             : POWER8E (raw), altivec supported\n+clock           : 3425.000000MHz\n+revision        : 2.1 (pvr 004b 0201)\n+\n+processor       : 2\n+cpu             : POWER8E (raw), altivec supported\n+clock           : 3425.000000MHz\n+revision        : 2.1 (pvr 004b 0201)\n+\n+processor       : 3\n+cpu             : POWER8E (raw), altivec supported\n+clock           : 3425.000000MHz\n+revision        : 2.1 (pvr 004b 0201)\n+\n+timebase        : 512000000\n+platform        : pSeries\n+model           : IBM pSeries (emulated by qemu)\n+machine         : CHRP IBM pSeries (emulated by qemu)\";\n+\n+    #[test]\n+    fn power8_powerkvm() {\n+        let cpuinfo = CpuInfo::from_str(POWER8E_POWERKVM).unwrap();\n+        assert_eq!(cpuinfo.field(\"cpu\"), \"POWER8E (raw), altivec supported\");\n+\n+        assert!(cpuinfo.field(\"cpu\").has(\"altivec\"));\n+    }\n+\n+    const POWER5P: &str = r\"processor       : 0\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 1\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 2\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 3\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 4\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 5\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 6\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 7\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+timebase        : 237331000\n+platform        : pSeries\n+machine         : CHRP IBM,9133-55A\";\n+\n+    #[test]\n+    fn power5p() {\n+        let cpuinfo = CpuInfo::from_str(POWER5P).unwrap();\n+        assert_eq!(cpuinfo.field(\"cpu\"), \"POWER5+ (gs)\");\n+\n+        assert!(!cpuinfo.field(\"cpu\").has(\"altivec\"));\n+    }\n+}"}, {"sha": "c0a5fb2e5d887983e67609d9faf54669055acd65", "filename": "tests/source/cfg_if/detect/os/linux/mips.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmips.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,31 @@\n+//! Run-time feature detection for MIPS on Linux.\n+\n+use crate::detect::{Feature, cache, bit};\n+use super::auxvec;\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector, and if that fails, try\n+/// to read them from `/proc/cpuinfo`.\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    // The values are part of the platform-specific [asm/hwcap.h][hwcap]\n+    //\n+    // [hwcap]: https://github.com/torvalds/linux/blob/master/arch/arm64/include/uapi/asm/hwcap.h\n+    if let Ok(auxv) = auxvec::auxv() {\n+        enable_feature(&mut value, Feature::msa, bit::test(auxv.hwcap, 1));\n+        return value;\n+    }\n+    // TODO: fall back via `cpuinfo`.\n+    value\n+}"}, {"sha": "e02d5e6dcda7a54b15218032a4b1522e021139b4", "filename": "tests/source/cfg_if/detect/os/linux/mod.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmod.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,28 @@\n+//! Run-time feature detection on Linux\n+\n+mod auxvec;\n+\n+#[cfg(feature = \"std_detect_file_io\")]\n+mod cpuinfo;\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"aarch64\")] {\n+        mod aarch64;\n+        pub use self::aarch64::check_for;\n+    } else if #[cfg(target_arch = \"arm\")] {\n+        mod arm;\n+        pub use self::arm::check_for;\n+    } else  if #[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))] {\n+        mod mips;\n+        pub use self::mips::check_for;\n+    } else if #[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))] {\n+        mod powerpc;\n+        pub use self::powerpc::check_for;\n+    } else {\n+        use crate::detect::Feature;\n+        /// Performs run-time feature detection.\n+        pub fn check_for(_x: Feature) -> bool {\n+            false\n+        }\n+    }\n+}"}, {"sha": "1c08a58443db892362448cd1e6cbb6a9370a304e", "filename": "tests/source/cfg_if/detect/os/linux/powerpc.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fpowerpc.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,41 @@\n+//! Run-time feature detection for PowerPC on Linux.\n+\n+use crate::detect::{Feature, cache};\n+use super::{auxvec, cpuinfo};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector, and if that fails, try\n+/// to read them from /proc/cpuinfo.\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    // The values are part of the platform-specific [asm/cputable.h][cputable]\n+    //\n+    // [cputable]: https://github.com/torvalds/linux/blob/master/arch/powerpc/include/uapi/asm/cputable.h\n+    if let Ok(auxv) = auxvec::auxv() {\n+        // note: the PowerPC values are the mask to do the test (instead of the\n+        // index of the bit to test like in ARM and Aarch64)\n+        enable_feature(&mut value, Feature::altivec, auxv.hwcap & 0x10000000 != 0);\n+        enable_feature(&mut value, Feature::vsx, auxv.hwcap & 0x00000080 != 0);\n+        enable_feature(&mut value, Feature::power8, auxv.hwcap2 & 0x80000000 != 0);\n+        return value;\n+    }\n+\n+    // PowerPC's /proc/cpuinfo lacks a proper Feature field,\n+    // but `altivec` support is indicated in the `cpu` field.\n+    if let Ok(c) = cpuinfo::CpuInfo::new() {\n+        enable_feature(&mut value, Feature::altivec, c.field(\"cpu\").has(\"altivec\"));\n+        return value;\n+    }\n+    value\n+}"}, {"sha": "23e399ea790740b0ed97f2a9ccd2bd2693af00c1", "filename": "tests/source/cfg_if/detect/os/other.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fother.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fother.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fother.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,9 @@\n+//! Other operating systems\n+\n+use crate::detect::Feature;\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(_x: Feature) -> bool {\n+    false\n+}"}, {"sha": "9257b8a4be636fea96ef1c3eeb910081fd02136b", "filename": "tests/source/cfg_if/detect/os/x86.rs", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fdetect%2Fos%2Fx86.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,375 @@\n+//! x86 run-time feature detection is OS independent.\n+\n+#[cfg(target_arch = \"x86\")]\n+use crate::arch::x86::*;\n+#[cfg(target_arch = \"x86_64\")]\n+use crate::arch::x86_64::*;\n+\n+use crate::mem;\n+\n+use crate::detect::{Feature, cache, bit};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Run-time feature detection on x86 works by using the CPUID instruction.\n+///\n+/// The [CPUID Wikipedia page][wiki_cpuid] contains\n+/// all the information about which flags to set to query which values, and in\n+/// which registers these are reported.\n+///\n+/// The definitive references are:\n+/// - [Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2:\n+///   Instruction Set Reference, A-Z][intel64_ref].\n+/// - [AMD64 Architecture Programmer's Manual, Volume 3: General-Purpose and\n+///   System Instructions][amd64_ref].\n+///\n+/// [wiki_cpuid]: https://en.wikipedia.org/wiki/CPUID\n+/// [intel64_ref]: http://www.intel.de/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf\n+/// [amd64_ref]: http://support.amd.com/TechDocs/24594.pdf\n+#[allow(clippy::similar_names)]\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+\n+    // If the x86 CPU does not support the CPUID instruction then it is too\n+    // old to support any of the currently-detectable features.\n+    if !has_cpuid() {\n+        return value;\n+    }\n+\n+    // Calling `__cpuid`/`__cpuid_count` from here on is safe because the CPU\n+    // has `cpuid` support.\n+\n+    // 0. EAX = 0: Basic Information:\n+    // - EAX returns the \"Highest Function Parameter\", that is, the maximum\n+    // leaf value for subsequent calls of `cpuinfo` in range [0,\n+    // 0x8000_0000]. - The vendor ID is stored in 12 u8 ascii chars,\n+    // returned in EBX, EDX, and   ECX (in that order):\n+    let (max_basic_leaf, vendor_id) = unsafe {\n+        let CpuidResult {\n+            eax: max_basic_leaf,\n+            ebx,\n+            ecx,\n+            edx,\n+        } = __cpuid(0);\n+        let vendor_id: [[u8; 4]; 3] = [\n+            mem::transmute(ebx),\n+            mem::transmute(edx),\n+            mem::transmute(ecx),\n+        ];\n+        let vendor_id: [u8; 12] = mem::transmute(vendor_id);\n+        (max_basic_leaf, vendor_id)\n+    };\n+\n+    if max_basic_leaf < 1 {\n+        // Earlier Intel 486, CPUID not implemented\n+        return value;\n+    }\n+\n+    // EAX = 1, ECX = 0: Queries \"Processor Info and Feature Bits\";\n+    // Contains information about most x86 features.\n+    let CpuidResult {\n+        ecx: proc_info_ecx,\n+        edx: proc_info_edx,\n+        ..\n+    } = unsafe { __cpuid(0x0000_0001_u32) };\n+\n+    // EAX = 7, ECX = 0: Queries \"Extended Features\";\n+    // Contains information about bmi,bmi2, and avx2 support.\n+    let (extended_features_ebx, extended_features_ecx) = if max_basic_leaf >= 7\n+    {\n+        let CpuidResult { ebx, ecx, .. } = unsafe { __cpuid(0x0000_0007_u32) };\n+        (ebx, ecx)\n+    } else {\n+        (0, 0) // CPUID does not support \"Extended Features\"\n+    };\n+\n+    // EAX = 0x8000_0000, ECX = 0: Get Highest Extended Function Supported\n+    // - EAX returns the max leaf value for extended information, that is,\n+    // `cpuid` calls in range [0x8000_0000; u32::MAX]:\n+    let CpuidResult {\n+        eax: extended_max_basic_leaf,\n+        ..\n+    } = unsafe { __cpuid(0x8000_0000_u32) };\n+\n+    // EAX = 0x8000_0001, ECX=0: Queries \"Extended Processor Info and Feature\n+    // Bits\"\n+    let extended_proc_info_ecx = if extended_max_basic_leaf >= 1 {\n+        let CpuidResult { ecx, .. } = unsafe { __cpuid(0x8000_0001_u32) };\n+        ecx\n+    } else {\n+        0\n+    };\n+\n+    {\n+        // borrows value till the end of this scope:\n+        let mut enable = |r, rb, f| {\n+            if bit::test(r as usize, rb) {\n+                value.set(f as u32);\n+            }\n+        };\n+\n+        enable(proc_info_ecx, 0, Feature::sse3);\n+        enable(proc_info_ecx, 1, Feature::pclmulqdq);\n+        enable(proc_info_ecx, 9, Feature::ssse3);\n+        enable(proc_info_ecx, 13, Feature::cmpxchg16b);\n+        enable(proc_info_ecx, 19, Feature::sse4_1);\n+        enable(proc_info_ecx, 20, Feature::sse4_2);\n+        enable(proc_info_ecx, 23, Feature::popcnt);\n+        enable(proc_info_ecx, 25, Feature::aes);\n+        enable(proc_info_ecx, 29, Feature::f16c);\n+        enable(proc_info_ecx, 30, Feature::rdrand);\n+        enable(extended_features_ebx, 18, Feature::rdseed);\n+        enable(extended_features_ebx, 19, Feature::adx);\n+        enable(extended_features_ebx, 11, Feature::rtm);\n+        enable(proc_info_edx, 4, Feature::tsc);\n+        enable(proc_info_edx, 23, Feature::mmx);\n+        enable(proc_info_edx, 24, Feature::fxsr);\n+        enable(proc_info_edx, 25, Feature::sse);\n+        enable(proc_info_edx, 26, Feature::sse2);\n+        enable(extended_features_ebx, 29, Feature::sha);\n+\n+        enable(extended_features_ebx, 3, Feature::bmi);\n+        enable(extended_features_ebx, 8, Feature::bmi2);\n+\n+        // `XSAVE` and `AVX` support:\n+        let cpu_xsave = bit::test(proc_info_ecx as usize, 26);\n+        if cpu_xsave {\n+            // 0. Here the CPU supports `XSAVE`.\n+\n+            // 1. Detect `OSXSAVE`, that is, whether the OS is AVX enabled and\n+            // supports saving the state of the AVX/AVX2 vector registers on\n+            // context-switches, see:\n+            //\n+            // - [intel: is avx enabled?][is_avx_enabled],\n+            // - [mozilla: sse.cpp][mozilla_sse_cpp].\n+            //\n+            // [is_avx_enabled]: https://software.intel.com/en-us/blogs/2011/04/14/is-avx-enabled\n+            // [mozilla_sse_cpp]: https://hg.mozilla.org/mozilla-central/file/64bab5cbb9b6/mozglue/build/SSE.cpp#l190\n+            let cpu_osxsave = bit::test(proc_info_ecx as usize, 27);\n+\n+            if cpu_osxsave {\n+                // 2. The OS must have signaled the CPU that it supports saving and\n+                // restoring the:\n+                //\n+                // * SSE -> `XCR0.SSE[1]`\n+                // * AVX -> `XCR0.AVX[2]`\n+                // * AVX-512 -> `XCR0.AVX-512[7:5]`.\n+                //\n+                // by setting the corresponding bits of `XCR0` to `1`.\n+                //\n+                // This is safe because the CPU supports `xsave`\n+                // and the OS has set `osxsave`.\n+                let xcr0 = unsafe { _xgetbv(0) };\n+                // Test `XCR0.SSE[1]` and `XCR0.AVX[2]` with the mask `0b110 == 6`:\n+                let os_avx_support = xcr0 & 6 == 6;\n+                // Test `XCR0.AVX-512[7:5]` with the mask `0b1110_0000 == 224`:\n+                let os_avx512_support = xcr0 & 224 == 224;\n+\n+                // Only if the OS and the CPU support saving/restoring the AVX\n+                // registers we enable `xsave` support:\n+                if os_avx_support {\n+                    // See \"13.3 ENABLING THE XSAVE FEATURE SET AND XSAVE-ENABLED\n+                    // FEATURES\" in the \"Intel\u00ae 64 and IA-32 Architectures Software\n+                    // Developer\u2019s Manual, Volume 1: Basic Architecture\":\n+                    //\n+                    // \"Software enables the XSAVE feature set by setting\n+                    // CR4.OSXSAVE[bit 18] to 1 (e.g., with the MOV to CR4\n+                    // instruction). If this bit is 0, execution of any of XGETBV,\n+                    // XRSTOR, XRSTORS, XSAVE, XSAVEC, XSAVEOPT, XSAVES, and XSETBV\n+                    // causes an invalid-opcode exception (#UD)\"\n+                    //\n+                    enable(proc_info_ecx, 26, Feature::xsave);\n+\n+                    // For `xsaveopt`, `xsavec`, and `xsaves` we need to query:\n+                    // Processor Extended State Enumeration Sub-leaf (EAX = 0DH,\n+                    // ECX = 1):\n+                    if max_basic_leaf >= 0xd {\n+                        let CpuidResult {\n+                            eax: proc_extended_state1_eax,\n+                            ..\n+                        } = unsafe { __cpuid_count(0xd_u32, 1) };\n+                        enable(proc_extended_state1_eax, 0, Feature::xsaveopt);\n+                        enable(proc_extended_state1_eax, 1, Feature::xsavec);\n+                        enable(proc_extended_state1_eax, 3, Feature::xsaves);\n+                    }\n+\n+                    // FMA (uses 256-bit wide registers):\n+                    enable(proc_info_ecx, 12, Feature::fma);\n+\n+                    // And AVX/AVX2:\n+                    enable(proc_info_ecx, 28, Feature::avx);\n+                    enable(extended_features_ebx, 5, Feature::avx2);\n+\n+                    // For AVX-512 the OS also needs to support saving/restoring\n+                    // the extended state, only then we enable AVX-512 support:\n+                    if os_avx512_support {\n+                        enable(extended_features_ebx, 16, Feature::avx512f);\n+                        enable(extended_features_ebx, 17, Feature::avx512dq);\n+                        enable(extended_features_ebx, 21, Feature::avx512_ifma);\n+                        enable(extended_features_ebx, 26, Feature::avx512pf);\n+                        enable(extended_features_ebx, 27, Feature::avx512er);\n+                        enable(extended_features_ebx, 28, Feature::avx512cd);\n+                        enable(extended_features_ebx, 30, Feature::avx512bw);\n+                        enable(extended_features_ebx, 31, Feature::avx512vl);\n+                        enable(extended_features_ecx, 1, Feature::avx512_vbmi);\n+                        enable(\n+                            extended_features_ecx,\n+                            14,\n+                            Feature::avx512_vpopcntdq,\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        // This detects ABM on AMD CPUs and LZCNT on Intel CPUs.\n+        // On intel CPUs with popcnt, lzcnt implements the\n+        // \"missing part\" of ABM, so we map both to the same\n+        // internal feature.\n+        //\n+        // The `is_x86_feature_detected!(\"lzcnt\")` macro then\n+        // internally maps to Feature::abm.\n+        enable(extended_proc_info_ecx, 5, Feature::abm);\n+        // As Hygon Dhyana originates from AMD technology and shares most of the architecture with\n+        // AMD's family 17h, but with different CPU Vendor ID(\"HygonGenuine\")/Family series\n+        // number(Family 18h).\n+        //\n+        // For CPUID feature bits, Hygon Dhyana(family 18h) share the same definition with AMD\n+        // family 17h.\n+        //\n+        // Related AMD CPUID specification is https://www.amd.com/system/files/TechDocs/25481.pdf.\n+        // Related Hygon kernel patch can be found on\n+        // http://lkml.kernel.org/r/5ce86123a7b9dad925ac583d88d2f921040e859b.1538583282.git.puwen@hygon.cn\n+        if vendor_id == *b\"AuthenticAMD\" || vendor_id == *b\"HygonGenuine\" {\n+            // These features are available on AMD arch CPUs:\n+            enable(extended_proc_info_ecx, 6, Feature::sse4a);\n+            enable(extended_proc_info_ecx, 21, Feature::tbm);\n+        }\n+    }\n+\n+    value\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    extern crate cupid;\n+\n+    #[test]\n+    fn dump() {\n+        println!(\"aes: {:?}\", is_x86_feature_detected!(\"aes\"));\n+        println!(\"pclmulqdq: {:?}\", is_x86_feature_detected!(\"pclmulqdq\"));\n+        println!(\"rdrand: {:?}\", is_x86_feature_detected!(\"rdrand\"));\n+        println!(\"rdseed: {:?}\", is_x86_feature_detected!(\"rdseed\"));\n+        println!(\"tsc: {:?}\", is_x86_feature_detected!(\"tsc\"));\n+        println!(\"sse: {:?}\", is_x86_feature_detected!(\"sse\"));\n+        println!(\"sse2: {:?}\", is_x86_feature_detected!(\"sse2\"));\n+        println!(\"sse3: {:?}\", is_x86_feature_detected!(\"sse3\"));\n+        println!(\"ssse3: {:?}\", is_x86_feature_detected!(\"ssse3\"));\n+        println!(\"sse4.1: {:?}\", is_x86_feature_detected!(\"sse4.1\"));\n+        println!(\"sse4.2: {:?}\", is_x86_feature_detected!(\"sse4.2\"));\n+        println!(\"sse4a: {:?}\", is_x86_feature_detected!(\"sse4a\"));\n+        println!(\"sha: {:?}\", is_x86_feature_detected!(\"sha\"));\n+        println!(\"avx: {:?}\", is_x86_feature_detected!(\"avx\"));\n+        println!(\"avx2: {:?}\", is_x86_feature_detected!(\"avx2\"));\n+        println!(\"avx512f {:?}\", is_x86_feature_detected!(\"avx512f\"));\n+        println!(\"avx512cd {:?}\", is_x86_feature_detected!(\"avx512cd\"));\n+        println!(\"avx512er {:?}\", is_x86_feature_detected!(\"avx512er\"));\n+        println!(\"avx512pf {:?}\", is_x86_feature_detected!(\"avx512pf\"));\n+        println!(\"avx512bw {:?}\", is_x86_feature_detected!(\"avx512bw\"));\n+        println!(\"avx512dq {:?}\", is_x86_feature_detected!(\"avx512dq\"));\n+        println!(\"avx512vl {:?}\", is_x86_feature_detected!(\"avx512vl\"));\n+        println!(\"avx512_ifma {:?}\", is_x86_feature_detected!(\"avx512ifma\"));\n+        println!(\"avx512_vbmi {:?}\", is_x86_feature_detected!(\"avx512vbmi\"));\n+        println!(\n+            \"avx512_vpopcntdq {:?}\",\n+            is_x86_feature_detected!(\"avx512vpopcntdq\")\n+        );\n+        println!(\"fma: {:?}\", is_x86_feature_detected!(\"fma\"));\n+        println!(\"abm: {:?}\", is_x86_feature_detected!(\"abm\"));\n+        println!(\"bmi: {:?}\", is_x86_feature_detected!(\"bmi1\"));\n+        println!(\"bmi2: {:?}\", is_x86_feature_detected!(\"bmi2\"));\n+        println!(\"tbm: {:?}\", is_x86_feature_detected!(\"tbm\"));\n+        println!(\"popcnt: {:?}\", is_x86_feature_detected!(\"popcnt\"));\n+        println!(\"lzcnt: {:?}\", is_x86_feature_detected!(\"lzcnt\"));\n+        println!(\"fxsr: {:?}\", is_x86_feature_detected!(\"fxsr\"));\n+        println!(\"xsave: {:?}\", is_x86_feature_detected!(\"xsave\"));\n+        println!(\"xsaveopt: {:?}\", is_x86_feature_detected!(\"xsaveopt\"));\n+        println!(\"xsaves: {:?}\", is_x86_feature_detected!(\"xsaves\"));\n+        println!(\"xsavec: {:?}\", is_x86_feature_detected!(\"xsavec\"));\n+        println!(\"cmpxchg16b: {:?}\", is_x86_feature_detected!(\"cmpxchg16b\"));\n+        println!(\"adx: {:?}\", is_x86_feature_detected!(\"adx\"));\n+        println!(\"rtm: {:?}\", is_x86_feature_detected!(\"rtm\"));\n+    }\n+\n+    #[test]\n+    fn compare_with_cupid() {\n+        let information = cupid::master().unwrap();\n+        assert_eq!(is_x86_feature_detected!(\"aes\"), information.aesni());\n+        assert_eq!(is_x86_feature_detected!(\"pclmulqdq\"), information.pclmulqdq());\n+        assert_eq!(is_x86_feature_detected!(\"rdrand\"), information.rdrand());\n+        assert_eq!(is_x86_feature_detected!(\"rdseed\"), information.rdseed());\n+        assert_eq!(is_x86_feature_detected!(\"tsc\"), information.tsc());\n+        assert_eq!(is_x86_feature_detected!(\"sse\"), information.sse());\n+        assert_eq!(is_x86_feature_detected!(\"sse2\"), information.sse2());\n+        assert_eq!(is_x86_feature_detected!(\"sse3\"), information.sse3());\n+        assert_eq!(is_x86_feature_detected!(\"ssse3\"), information.ssse3());\n+        assert_eq!(is_x86_feature_detected!(\"sse4.1\"), information.sse4_1());\n+        assert_eq!(is_x86_feature_detected!(\"sse4.2\"), information.sse4_2());\n+        assert_eq!(is_x86_feature_detected!(\"sse4a\"), information.sse4a());\n+        assert_eq!(is_x86_feature_detected!(\"sha\"), information.sha());\n+        assert_eq!(is_x86_feature_detected!(\"avx\"), information.avx());\n+        assert_eq!(is_x86_feature_detected!(\"avx2\"), information.avx2());\n+        assert_eq!(is_x86_feature_detected!(\"avx512f\"), information.avx512f());\n+        assert_eq!(is_x86_feature_detected!(\"avx512cd\"), information.avx512cd());\n+        assert_eq!(is_x86_feature_detected!(\"avx512er\"), information.avx512er());\n+        assert_eq!(is_x86_feature_detected!(\"avx512pf\"), information.avx512pf());\n+        assert_eq!(is_x86_feature_detected!(\"avx512bw\"), information.avx512bw());\n+        assert_eq!(is_x86_feature_detected!(\"avx512dq\"), information.avx512dq());\n+        assert_eq!(is_x86_feature_detected!(\"avx512vl\"), information.avx512vl());\n+        assert_eq!(\n+            is_x86_feature_detected!(\"avx512ifma\"),\n+            information.avx512_ifma()\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"avx512vbmi\"),\n+            information.avx512_vbmi()\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"avx512vpopcntdq\"),\n+            information.avx512_vpopcntdq()\n+        );\n+        assert_eq!(is_x86_feature_detected!(\"fma\"), information.fma());\n+        assert_eq!(is_x86_feature_detected!(\"bmi1\"), information.bmi1());\n+        assert_eq!(is_x86_feature_detected!(\"bmi2\"), information.bmi2());\n+        assert_eq!(is_x86_feature_detected!(\"popcnt\"), information.popcnt());\n+        assert_eq!(is_x86_feature_detected!(\"abm\"), information.lzcnt());\n+        assert_eq!(is_x86_feature_detected!(\"tbm\"), information.tbm());\n+        assert_eq!(is_x86_feature_detected!(\"lzcnt\"), information.lzcnt());\n+        assert_eq!(is_x86_feature_detected!(\"xsave\"), information.xsave());\n+        assert_eq!(is_x86_feature_detected!(\"xsaveopt\"), information.xsaveopt());\n+        assert_eq!(\n+            is_x86_feature_detected!(\"xsavec\"),\n+            information.xsavec_and_xrstor()\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"xsaves\"),\n+            information.xsaves_xrstors_and_ia32_xss()\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"cmpxchg16b\"),\n+            information.cmpxchg16b(),\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"adx\"),\n+            information.adx(),\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"rtm\"),\n+            information.rtm(),\n+        );\n+    }\n+}"}, {"sha": "8b3bb304f1c83d3436dd1c325a952f8dbb86c4e2", "filename": "tests/source/cfg_if/lib.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Flib.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,49 @@\n+//! Run-time feature detection for the Rust standard library.\n+//!\n+//! To detect whether a feature is enabled in the system running the binary\n+//! use one of the appropriate macro for the target:\n+//!\n+//! * `x86` and `x86_64`: [`is_x86_feature_detected`]\n+//! * `arm`: [`is_arm_feature_detected`]\n+//! * `aarch64`: [`is_aarch64_feature_detected`]\n+//! * `mips`: [`is_mips_feature_detected`]\n+//! * `mips64`: [`is_mips64_feature_detected`]\n+//! * `powerpc`: [`is_powerpc_feature_detected`]\n+//! * `powerpc64`: [`is_powerpc64_feature_detected`]\n+\n+#![unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#![feature(const_fn, staged_api, stdsimd, doc_cfg, allow_internal_unstable)]\n+#![allow(clippy::shadow_reuse)]\n+#![deny(clippy::missing_inline_in_public_items)]\n+#![cfg_attr(target_os = \"linux\", feature(linkage))]\n+#![cfg_attr(all(target_os = \"freebsd\", target_arch = \"aarch64\"), feature(asm))]\n+#![cfg_attr(stdsimd_strict, deny(warnings))]\n+#![cfg_attr(test, allow(unused_imports))]\n+#![no_std]\n+\n+#[macro_use]\n+extern crate cfg_if;\n+\n+cfg_if! {\n+    if #[cfg(feature = \"std_detect_file_io\")] {\n+        #[cfg_attr(test, macro_use(println))]\n+        extern crate std;\n+\n+        #[allow(unused_imports)]\n+        use std::{arch, fs, io, mem, sync};\n+    } else {\n+        #[cfg(test)]\n+        #[macro_use(println)]\n+        extern crate std;\n+\n+        #[allow(unused_imports)]\n+        use core::{arch, mem, sync};\n+    }\n+}\n+\n+#[cfg(feature = \"std_detect_dlsym_getauxval\")]\n+extern crate libc;\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+pub mod detect;"}, {"sha": "b630e7ff383aa9867c447b86b2f7b0a5fb251613", "filename": "tests/source/cfg_if/mod.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Fsource%2Fcfg_if%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcfg_if%2Fmod.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,5 @@\n+//! `std_detect`\n+\n+#[doc(hidden)] // unstable implementation detail\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+pub mod detect;"}, {"sha": "91c51ed89e6ff4331ad35b049ad6ac95edc34664", "filename": "tests/target/cfg_if/detect/arch/aarch64.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Faarch64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,98 @@\n+//! Aarch64 run-time features.\n+\n+/// Checks if `aarch64` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal, stdsimd)]\n+macro_rules! is_aarch64_feature_detected {\n+    (\"neon\") => {\n+        // FIXME: this should be removed once we rename Aarch64 neon to asimd\n+        cfg!(target_feature = \"neon\") || $crate::detect::check_for($crate::detect::Feature::asimd)\n+    };\n+    (\"asimd\") => {\n+        cfg!(target_feature = \"neon\") || $crate::detect::check_for($crate::detect::Feature::asimd)\n+    };\n+    (\"pmull\") => {\n+        cfg!(target_feature = \"pmull\") || $crate::detect::check_for($crate::detect::Feature::pmull)\n+    };\n+    (\"fp\") => {\n+        cfg!(target_feature = \"fp\") || $crate::detect::check_for($crate::detect::Feature::fp)\n+    };\n+    (\"fp16\") => {\n+        cfg!(target_feature = \"fp16\") || $crate::detect::check_for($crate::detect::Feature::fp16)\n+    };\n+    (\"sve\") => {\n+        cfg!(target_feature = \"sve\") || $crate::detect::check_for($crate::detect::Feature::sve)\n+    };\n+    (\"crc\") => {\n+        cfg!(target_feature = \"crc\") || $crate::detect::check_for($crate::detect::Feature::crc)\n+    };\n+    (\"crypto\") => {\n+        cfg!(target_feature = \"crypto\")\n+            || $crate::detect::check_for($crate::detect::Feature::crypto)\n+    };\n+    (\"lse\") => {\n+        cfg!(target_feature = \"lse\") || $crate::detect::check_for($crate::detect::Feature::lse)\n+    };\n+    (\"rdm\") => {\n+        cfg!(target_feature = \"rdm\") || $crate::detect::check_for($crate::detect::Feature::rdm)\n+    };\n+    (\"rcpc\") => {\n+        cfg!(target_feature = \"rcpc\") || $crate::detect::check_for($crate::detect::Feature::rcpc)\n+    };\n+    (\"dotprod\") => {\n+        cfg!(target_feature = \"dotprod\")\n+            || $crate::detect::check_for($crate::detect::Feature::dotprod)\n+    };\n+    (\"ras\") => {\n+        compile_error!(\"\\\"ras\\\" feature cannot be detected at run-time\")\n+    };\n+    (\"v8.1a\") => {\n+        compile_error!(\"\\\"v8.1a\\\" feature cannot be detected at run-time\")\n+    };\n+    (\"v8.2a\") => {\n+        compile_error!(\"\\\"v8.2a\\\" feature cannot be detected at run-time\")\n+    };\n+    (\"v8.3a\") => {\n+        compile_error!(\"\\\"v8.3a\\\" feature cannot be detected at run-time\")\n+    };\n+    ($t:tt,) => {\n+        is_aarch64_feature_detected!($t);\n+    };\n+    ($t:tt) => {\n+        compile_error!(concat!(\"unknown aarch64 target feature: \", $t))\n+    };\n+}\n+\n+/// ARM Aarch64 CPU Feature enum. Each variant denotes a position in a bitset\n+/// for a particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// ARM Advanced SIMD (ASIMD)\n+    asimd,\n+    /// Polynomial Multiply\n+    pmull,\n+    /// Floating point support\n+    fp,\n+    /// Half-float support.\n+    fp16,\n+    /// Scalable Vector Extension (SVE)\n+    sve,\n+    /// CRC32 (Cyclic Redundancy Check)\n+    crc,\n+    /// Crypto: AES + PMULL + SHA1 + SHA2\n+    crypto,\n+    /// Atomics (Large System Extension)\n+    lse,\n+    /// Rounding Double Multiply (ASIMDRDM)\n+    rdm,\n+    /// Release consistent Processor consistent (RcPc)\n+    rcpc,\n+    /// Vector Dot-Product (ASIMDDP)\n+    dotprod,\n+}"}, {"sha": "90c61fed8acc7510778b3f94c502a9931cf783ee", "filename": "tests/target/cfg_if/detect/arch/arm.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Farm.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,47 @@\n+//! Run-time feature detection on ARM Aarch32.\n+\n+/// Checks if `arm` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal, stdsimd)]\n+macro_rules! is_arm_feature_detected {\n+    (\"neon\") => {\n+        cfg!(target_feature = \"neon\") || $crate::detect::check_for($crate::detect::Feature::neon)\n+    };\n+    (\"pmull\") => {\n+        cfg!(target_feature = \"pmull\") || $crate::detect::check_for($crate::detect::Feature::pmull)\n+    };\n+    (\"v7\") => {\n+        compile_error!(\"\\\"v7\\\" feature cannot be detected at run-time\")\n+    };\n+    (\"vfp2\") => {\n+        compile_error!(\"\\\"vfp2\\\" feature cannot be detected at run-time\")\n+    };\n+    (\"vfp3\") => {\n+        compile_error!(\"\\\"vfp3\\\" feature cannot be detected at run-time\")\n+    };\n+    (\"vfp4\") => {\n+        compile_error!(\"\\\"vfp4\\\" feature cannot be detected at run-time\")\n+    };\n+    ($t:tt,) => {\n+        is_arm_feature_detected!($t);\n+    };\n+    ($t:tt) => {\n+        compile_error!(concat!(\"unknown arm target feature: \", $t))\n+    };\n+}\n+\n+/// ARM CPU Feature enum. Each variant denotes a position in a bitset for a\n+/// particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// ARM Advanced SIMD (NEON) - Aarch32\n+    neon,\n+    /// Polynomial Multiply\n+    pmull,\n+}"}, {"sha": "2397a090602c17e24a3b966fe664fbd3618fa792", "filename": "tests/target/cfg_if/detect/arch/mips.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fmips.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,30 @@\n+//! Run-time feature detection on MIPS.\n+\n+/// Checks if `mips` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal, stdsimd)]\n+macro_rules! is_mips_feature_detected {\n+    (\"msa\") => {\n+        cfg!(target_feature = \"msa\") || $crate::detect::check_for($crate::detect::Feature::msa)\n+    };\n+    ($t:tt,) => {\n+        is_mips_feature_detected!($t);\n+    };\n+    ($t:tt) => {\n+        compile_error!(concat!(\"unknown mips target feature: \", $t))\n+    };\n+}\n+\n+/// MIPS CPU Feature enum. Each variant denotes a position in a bitset for a\n+/// particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// MIPS SIMD Architecture (MSA)\n+    msa,\n+}"}, {"sha": "d378defc5dfd1f606874813326c0ed51ad238b1c", "filename": "tests/target/cfg_if/detect/arch/mips64.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fmips64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,30 @@\n+//! Run-time feature detection on MIPS64.\n+\n+/// Checks if `mips64` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal, stdsimd)]\n+macro_rules! is_mips64_feature_detected {\n+    (\"msa\") => {\n+        cfg!(target_feature = \"msa\") || $crate::detect::check_for($crate::detect::Feature::msa)\n+    };\n+    ($t:tt,) => {\n+        is_mips64_feature_detected!($t);\n+    };\n+    ($t:tt) => {\n+        compile_error!(concat!(\"unknown mips64 target feature: \", $t))\n+    };\n+}\n+\n+/// MIPS64 CPU Feature enum. Each variant denotes a position in a bitset\n+/// for a particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// MIPS SIMD Architecture (MSA)\n+    msa,\n+}"}, {"sha": "e7a9daac68873bb7d31f71993d893719572e315b", "filename": "tests/target/cfg_if/detect/arch/powerpc.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,42 @@\n+//! Run-time feature detection on PowerPC.\n+\n+/// Checks if `powerpc` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal, stdsimd)]\n+macro_rules! is_powerpc_feature_detected {\n+    (\"altivec\") => {\n+        cfg!(target_feature = \"altivec\")\n+            || $crate::detect::check_for($crate::detect::Feature::altivec)\n+    };\n+    (\"vsx\") => {\n+        cfg!(target_feature = \"vsx\") || $crate::detect::check_for($crate::detect::Feature::vsx)\n+    };\n+    (\"power8\") => {\n+        cfg!(target_feature = \"power8\")\n+            || $crate::detect::check_for($crate::detect::Feature::power8)\n+    };\n+    ($t:tt,) => {\n+        is_powerpc_feature_detected!($t);\n+    };\n+    ($t:tt) => {\n+        compile_error!(concat!(\"unknown powerpc target feature: \", $t))\n+    };\n+}\n+\n+/// PowerPC CPU Feature enum. Each variant denotes a position in a bitset\n+/// for a particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// Altivec\n+    altivec,\n+    /// VSX\n+    vsx,\n+    /// Power8\n+    power8,\n+}"}, {"sha": "c102202695ec572397e2303d138aa3e502344e21", "filename": "tests/target/cfg_if/detect/arch/powerpc64.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fpowerpc64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,42 @@\n+//! Run-time feature detection on PowerPC64.\n+\n+/// Checks if `powerpc64` feature is enabled.\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#[allow_internal_unstable(stdsimd_internal, stdsimd)]\n+macro_rules! is_powerpc64_feature_detected {\n+    (\"altivec\") => {\n+        cfg!(target_feature = \"altivec\")\n+            || $crate::detect::check_for($crate::detect::Feature::altivec)\n+    };\n+    (\"vsx\") => {\n+        cfg!(target_feature = \"vsx\") || $crate::detect::check_for($crate::detect::Feature::vsx)\n+    };\n+    (\"power8\") => {\n+        cfg!(target_feature = \"power8\")\n+            || $crate::detect::check_for($crate::detect::Feature::power8)\n+    };\n+    ($t:tt,) => {\n+        is_powerpc64_feature_detected!($t);\n+    };\n+    ($t:tt) => {\n+        compile_error!(concat!(\"unknown powerpc64 target feature: \", $t))\n+    };\n+}\n+\n+/// PowerPC64 CPU Feature enum. Each variant denotes a position in a bitset\n+/// for a particular feature.\n+///\n+/// PLEASE: do not use this, it is an implementation detail subject to change.\n+#[doc(hidden)]\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// Altivec\n+    altivec,\n+    /// VSX\n+    vsx,\n+    /// Power8\n+    power8,\n+}"}, {"sha": "9219a4a577f9acd8cf3da5a86dfa3aa7153acbc0", "filename": "tests/target/cfg_if/detect/arch/x86.rs", "status": "added", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Farch%2Fx86.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,333 @@\n+//! This module implements minimal run-time feature detection for x86.\n+//!\n+//! The features are detected using the `detect_features` function below.\n+//! This function uses the CPUID instruction to read the feature flags from the\n+//! CPU and encodes them in an `usize` where each bit position represents\n+//! whether a feature is available (bit is set) or unavaiable (bit is cleared).\n+//!\n+//! The enum `Feature` is used to map bit positions to feature names, and the\n+//! the `__crate::detect::check_for!` macro is used to map string literals (e.g.,\n+//! \"avx\") to these bit positions (e.g., `Feature::avx`).\n+//!\n+//! The run-time feature detection is performed by the\n+//! `__crate::detect::check_for(Feature) -> bool` function. On its first call,\n+//! this functions queries the CPU for the available features and stores them\n+//! in a global `AtomicUsize` variable. The query is performed by just checking\n+//! whether the feature bit in this global variable is set or cleared.\n+\n+/// A macro to test at *runtime* whether a CPU feature is available on\n+/// x86/x86-64 platforms.\n+///\n+/// This macro is provided in the standard library and will detect at runtime\n+/// whether the specified CPU feature is detected. This does **not** resolve at\n+/// compile time unless the specified feature is already enabled for the entire\n+/// crate. Runtime detection currently relies mostly on the `cpuid` instruction.\n+///\n+/// This macro only takes one argument which is a string literal of the feature\n+/// being tested for. The feature names supported are the lowercase versions of\n+/// the ones defined by Intel in [their documentation][docs].\n+///\n+/// ## Supported arguments\n+///\n+/// This macro supports the same names that `#[target_feature]` supports. Unlike\n+/// `#[target_feature]`, however, this macro does not support names separated\n+/// with a comma. Instead testing for multiple features must be done through\n+/// separate macro invocations for now.\n+///\n+/// Supported arguments are:\n+///\n+/// * `\"aes\"`\n+/// * `\"pclmulqdq\"`\n+/// * `\"rdrand\"`\n+/// * `\"rdseed\"`\n+/// * `\"tsc\"`\n+/// * `\"mmx\"`\n+/// * `\"sse\"`\n+/// * `\"sse2\"`\n+/// * `\"sse3\"`\n+/// * `\"ssse3\"`\n+/// * `\"sse4.1\"`\n+/// * `\"sse4.2\"`\n+/// * `\"sse4a\"`\n+/// * `\"sha\"`\n+/// * `\"avx\"`\n+/// * `\"avx2\"`\n+/// * `\"avx512f\"`\n+/// * `\"avx512cd\"`\n+/// * `\"avx512er\"`\n+/// * `\"avx512pf\"`\n+/// * `\"avx512bw\"`\n+/// * `\"avx512dq\"`\n+/// * `\"avx512vl\"`\n+/// * `\"avx512ifma\"`\n+/// * `\"avx512vbmi\"`\n+/// * `\"avx512vpopcntdq\"`\n+/// * `\"f16c\"`\n+/// * `\"fma\"`\n+/// * `\"bmi1\"`\n+/// * `\"bmi2\"`\n+/// * `\"abm\"`\n+/// * `\"lzcnt\"`\n+/// * `\"tbm\"`\n+/// * `\"popcnt\"`\n+/// * `\"fxsr\"`\n+/// * `\"xsave\"`\n+/// * `\"xsaveopt\"`\n+/// * `\"xsaves\"`\n+/// * `\"xsavec\"`\n+/// * `\"adx\"`\n+/// * `\"rtm\"`\n+///\n+/// [docs]: https://software.intel.com/sites/landingpage/IntrinsicsGuide\n+#[macro_export]\n+#[stable(feature = \"simd_x86\", since = \"1.27.0\")]\n+#[allow_internal_unstable(stdsimd_internal, stdsimd)]\n+macro_rules! is_x86_feature_detected {\n+    (\"aes\") => {\n+        cfg!(target_feature = \"aes\") || $crate::detect::check_for($crate::detect::Feature::aes)\n+    };\n+    (\"pclmulqdq\") => {\n+        cfg!(target_feature = \"pclmulqdq\")\n+            || $crate::detect::check_for($crate::detect::Feature::pclmulqdq)\n+    };\n+    (\"rdrand\") => {\n+        cfg!(target_feature = \"rdrand\")\n+            || $crate::detect::check_for($crate::detect::Feature::rdrand)\n+    };\n+    (\"rdseed\") => {\n+        cfg!(target_feature = \"rdseed\")\n+            || $crate::detect::check_for($crate::detect::Feature::rdseed)\n+    };\n+    (\"tsc\") => {\n+        cfg!(target_feature = \"tsc\") || $crate::detect::check_for($crate::detect::Feature::tsc)\n+    };\n+    (\"mmx\") => {\n+        cfg!(target_feature = \"mmx\") || $crate::detect::check_for($crate::detect::Feature::mmx)\n+    };\n+    (\"sse\") => {\n+        cfg!(target_feature = \"sse\") || $crate::detect::check_for($crate::detect::Feature::sse)\n+    };\n+    (\"sse2\") => {\n+        cfg!(target_feature = \"sse2\") || $crate::detect::check_for($crate::detect::Feature::sse2)\n+    };\n+    (\"sse3\") => {\n+        cfg!(target_feature = \"sse3\") || $crate::detect::check_for($crate::detect::Feature::sse3)\n+    };\n+    (\"ssse3\") => {\n+        cfg!(target_feature = \"ssse3\") || $crate::detect::check_for($crate::detect::Feature::ssse3)\n+    };\n+    (\"sse4.1\") => {\n+        cfg!(target_feature = \"sse4.1\")\n+            || $crate::detect::check_for($crate::detect::Feature::sse4_1)\n+    };\n+    (\"sse4.2\") => {\n+        cfg!(target_feature = \"sse4.2\")\n+            || $crate::detect::check_for($crate::detect::Feature::sse4_2)\n+    };\n+    (\"sse4a\") => {\n+        cfg!(target_feature = \"sse4a\") || $crate::detect::check_for($crate::detect::Feature::sse4a)\n+    };\n+    (\"sha\") => {\n+        cfg!(target_feature = \"sha\") || $crate::detect::check_for($crate::detect::Feature::sha)\n+    };\n+    (\"avx\") => {\n+        cfg!(target_feature = \"avx\") || $crate::detect::check_for($crate::detect::Feature::avx)\n+    };\n+    (\"avx2\") => {\n+        cfg!(target_feature = \"avx2\") || $crate::detect::check_for($crate::detect::Feature::avx2)\n+    };\n+    (\"avx512f\") => {\n+        cfg!(target_feature = \"avx512f\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512f)\n+    };\n+    (\"avx512cd\") => {\n+        cfg!(target_feature = \"avx512cd\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512cd)\n+    };\n+    (\"avx512er\") => {\n+        cfg!(target_feature = \"avx512er\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512er)\n+    };\n+    (\"avx512pf\") => {\n+        cfg!(target_feature = \"avx512pf\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512pf)\n+    };\n+    (\"avx512bw\") => {\n+        cfg!(target_feature = \"avx512bw\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512bw)\n+    };\n+    (\"avx512dq\") => {\n+        cfg!(target_feature = \"avx512dq\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512dq)\n+    };\n+    (\"avx512vl\") => {\n+        cfg!(target_Feature = \"avx512vl\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512vl)\n+    };\n+    (\"avx512ifma\") => {\n+        cfg!(target_feature = \"avx512ifma\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512_ifma)\n+    };\n+    (\"avx512vbmi\") => {\n+        cfg!(target_feature = \"avx512vbmi\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512_vbmi)\n+    };\n+    (\"avx512vpopcntdq\") => {\n+        cfg!(target_feature = \"avx512vpopcntdq\")\n+            || $crate::detect::check_for($crate::detect::Feature::avx512_vpopcntdq)\n+    };\n+    (\"f16c\") => {\n+        cfg!(target_feature = \"f16c\") || $crate::detect::check_for($crate::detect::Feature::f16c)\n+    };\n+    (\"fma\") => {\n+        cfg!(target_feature = \"fma\") || $crate::detect::check_for($crate::detect::Feature::fma)\n+    };\n+    (\"bmi1\") => {\n+        cfg!(target_feature = \"bmi1\") || $crate::detect::check_for($crate::detect::Feature::bmi)\n+    };\n+    (\"bmi2\") => {\n+        cfg!(target_feature = \"bmi2\") || $crate::detect::check_for($crate::detect::Feature::bmi2)\n+    };\n+    (\"abm\") => {\n+        cfg!(target_feature = \"abm\") || $crate::detect::check_for($crate::detect::Feature::abm)\n+    };\n+    (\"lzcnt\") => {\n+        cfg!(target_feature = \"lzcnt\") || $crate::detect::check_for($crate::detect::Feature::abm)\n+    };\n+    (\"tbm\") => {\n+        cfg!(target_feature = \"tbm\") || $crate::detect::check_for($crate::detect::Feature::tbm)\n+    };\n+    (\"popcnt\") => {\n+        cfg!(target_feature = \"popcnt\")\n+            || $crate::detect::check_for($crate::detect::Feature::popcnt)\n+    };\n+    (\"fxsr\") => {\n+        cfg!(target_feature = \"fxsr\") || $crate::detect::check_for($crate::detect::Feature::fxsr)\n+    };\n+    (\"xsave\") => {\n+        cfg!(target_feature = \"xsave\") || $crate::detect::check_for($crate::detect::Feature::xsave)\n+    };\n+    (\"xsaveopt\") => {\n+        cfg!(target_feature = \"xsaveopt\")\n+            || $crate::detect::check_for($crate::detect::Feature::xsaveopt)\n+    };\n+    (\"xsaves\") => {\n+        cfg!(target_feature = \"xsaves\")\n+            || $crate::detect::check_for($crate::detect::Feature::xsaves)\n+    };\n+    (\"xsavec\") => {\n+        cfg!(target_feature = \"xsavec\")\n+            || $crate::detect::check_for($crate::detect::Feature::xsavec)\n+    };\n+    (\"cmpxchg16b\") => {\n+        cfg!(target_feature = \"cmpxchg16b\")\n+            || $crate::detect::check_for($crate::detect::Feature::cmpxchg16b)\n+    };\n+    (\"adx\") => {\n+        cfg!(target_feature = \"adx\") || $crate::detect::check_for($crate::detect::Feature::adx)\n+    };\n+    (\"rtm\") => {\n+        cfg!(target_feature = \"rtm\") || $crate::detect::check_for($crate::detect::Feature::rtm)\n+    };\n+    ($t:tt,) => {\n+        is_x86_feature_detected!($t);\n+    };\n+    ($t:tt) => {\n+        compile_error!(concat!(\"unknown target feature: \", $t))\n+    };\n+}\n+\n+/// X86 CPU Feature enum. Each variant denotes a position in a bitset for a\n+/// particular feature.\n+///\n+/// This is an unstable implementation detail subject to change.\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[doc(hidden)]\n+#[unstable(feature = \"stdsimd_internal\", issue = \"0\")]\n+pub enum Feature {\n+    /// AES (Advanced Encryption Standard New Instructions AES-NI)\n+    aes,\n+    /// CLMUL (Carry-less Multiplication)\n+    pclmulqdq,\n+    /// RDRAND\n+    rdrand,\n+    /// RDSEED\n+    rdseed,\n+    /// TSC (Time Stamp Counter)\n+    tsc,\n+    /// MMX\n+    mmx,\n+    /// SSE (Streaming SIMD Extensions)\n+    sse,\n+    /// SSE2 (Streaming SIMD Extensions 2)\n+    sse2,\n+    /// SSE3 (Streaming SIMD Extensions 3)\n+    sse3,\n+    /// SSSE3 (Supplemental Streaming SIMD Extensions 3)\n+    ssse3,\n+    /// SSE4.1 (Streaming SIMD Extensions 4.1)\n+    sse4_1,\n+    /// SSE4.2 (Streaming SIMD Extensions 4.2)\n+    sse4_2,\n+    /// SSE4a (Streaming SIMD Extensions 4a)\n+    sse4a,\n+    /// SHA\n+    sha,\n+    /// AVX (Advanced Vector Extensions)\n+    avx,\n+    /// AVX2 (Advanced Vector Extensions 2)\n+    avx2,\n+    /// AVX-512 F (Foundation)\n+    avx512f,\n+    /// AVX-512 CD (Conflict Detection Instructions)\n+    avx512cd,\n+    /// AVX-512 ER (Exponential and Reciprocal Instructions)\n+    avx512er,\n+    /// AVX-512 PF (Prefetch Instructions)\n+    avx512pf,\n+    /// AVX-512 BW (Byte and Word Instructions)\n+    avx512bw,\n+    /// AVX-512 DQ (Doubleword and Quadword)\n+    avx512dq,\n+    /// AVX-512 VL (Vector Length Extensions)\n+    avx512vl,\n+    /// AVX-512 IFMA (Integer Fused Multiply Add)\n+    avx512_ifma,\n+    /// AVX-512 VBMI (Vector Byte Manipulation Instructions)\n+    avx512_vbmi,\n+    /// AVX-512 VPOPCNTDQ (Vector Population Count Doubleword and\n+    /// Quadword)\n+    avx512_vpopcntdq,\n+    /// F16C (Conversions between IEEE-754 `binary16` and `binary32` formats)\n+    f16c,\n+    /// FMA (Fused Multiply Add)\n+    fma,\n+    /// BMI1 (Bit Manipulation Instructions 1)\n+    bmi,\n+    /// BMI1 (Bit Manipulation Instructions 2)\n+    bmi2,\n+    /// ABM (Advanced Bit Manipulation) on AMD / LZCNT (Leading Zero\n+    /// Count) on Intel\n+    abm,\n+    /// TBM (Trailing Bit Manipulation)\n+    tbm,\n+    /// POPCNT (Population Count)\n+    popcnt,\n+    /// FXSR (Floating-point context fast save and restor)\n+    fxsr,\n+    /// XSAVE (Save Processor Extended States)\n+    xsave,\n+    /// XSAVEOPT (Save Processor Extended States Optimized)\n+    xsaveopt,\n+    /// XSAVES (Save Processor Extended States Supervisor)\n+    xsaves,\n+    /// XSAVEC (Save Processor Extended States Compacted)\n+    xsavec,\n+    /// CMPXCH16B, a 16-byte compare-and-swap instruction\n+    cmpxchg16b,\n+    /// ADX, Intel ADX (Multi-Precision Add-Carry Instruction Extensions)\n+    adx,\n+    /// RTM, Intel (Restricted Transactional Memory)\n+    rtm,\n+}"}, {"sha": "578f0b16b742ae5eb16ffc1b99f41c6b88dcf2cc", "filename": "tests/target/cfg_if/detect/bit.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fbit.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,9 @@\n+//! Bit manipulation utilities.\n+\n+/// Tests the `bit` of `x`.\n+#[allow(dead_code)]\n+#[inline]\n+pub(crate) fn test(x: usize, bit: u32) -> bool {\n+    debug_assert!(bit < 32, \"bit index out-of-bounds\");\n+    x & (1 << bit) != 0\n+}"}, {"sha": "92bc4b58d167771726e22e5c2418a1eebbccc602", "filename": "tests/target/cfg_if/detect/cache.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fcache.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,164 @@\n+//! Caches run-time feature detection so that it only needs to be computed\n+//! once.\n+\n+#![allow(dead_code)] // not used on all platforms\n+\n+use crate::sync::atomic::Ordering;\n+\n+#[cfg(target_pointer_width = \"64\")]\n+use crate::sync::atomic::AtomicU64;\n+\n+#[cfg(target_pointer_width = \"32\")]\n+use crate::sync::atomic::AtomicU32;\n+\n+/// Sets the `bit` of `x`.\n+#[inline]\n+const fn set_bit(x: u64, bit: u32) -> u64 {\n+    x | 1 << bit\n+}\n+\n+/// Tests the `bit` of `x`.\n+#[inline]\n+const fn test_bit(x: u64, bit: u32) -> bool {\n+    x & (1 << bit) != 0\n+}\n+\n+/// Maximum number of features that can be cached.\n+const CACHE_CAPACITY: u32 = 63;\n+\n+/// This type is used to initialize the cache\n+#[derive(Copy, Clone)]\n+pub(crate) struct Initializer(u64);\n+\n+#[allow(clippy::use_self)]\n+impl Default for Initializer {\n+    fn default() -> Self {\n+        Initializer(0)\n+    }\n+}\n+\n+impl Initializer {\n+    /// Tests the `bit` of the cache.\n+    #[allow(dead_code)]\n+    #[inline]\n+    pub(crate) fn test(self, bit: u32) -> bool {\n+        // FIXME: this way of making sure that the cache is large enough is\n+        // brittle.\n+        debug_assert!(\n+            bit < CACHE_CAPACITY,\n+            \"too many features, time to increase the cache size!\"\n+        );\n+        test_bit(self.0, bit)\n+    }\n+\n+    /// Sets the `bit` of the cache.\n+    #[inline]\n+    pub(crate) fn set(&mut self, bit: u32) {\n+        // FIXME: this way of making sure that the cache is large enough is\n+        // brittle.\n+        debug_assert!(\n+            bit < CACHE_CAPACITY,\n+            \"too many features, time to increase the cache size!\"\n+        );\n+        let v = self.0;\n+        self.0 = set_bit(v, bit);\n+    }\n+}\n+\n+/// This global variable is a cache of the features supported by the CPU.\n+static CACHE: Cache = Cache::uninitialized();\n+\n+/// Feature cache with capacity for `CACHE_CAPACITY` features.\n+///\n+/// Note: the last feature bit is used to represent an\n+/// uninitialized cache.\n+#[cfg(target_pointer_width = \"64\")]\n+struct Cache(AtomicU64);\n+\n+#[cfg(target_pointer_width = \"64\")]\n+#[allow(clippy::use_self)]\n+impl Cache {\n+    /// Creates an uninitialized cache.\n+    #[allow(clippy::declare_interior_mutable_const)]\n+    const fn uninitialized() -> Self {\n+        Cache(AtomicU64::new(u64::max_value()))\n+    }\n+    /// Is the cache uninitialized?\n+    #[inline]\n+    pub(crate) fn is_uninitialized(&self) -> bool {\n+        self.0.load(Ordering::Relaxed) == u64::max_value()\n+    }\n+\n+    /// Is the `bit` in the cache set?\n+    #[inline]\n+    pub(crate) fn test(&self, bit: u32) -> bool {\n+        test_bit(CACHE.0.load(Ordering::Relaxed), bit)\n+    }\n+\n+    /// Initializes the cache.\n+    #[inline]\n+    pub(crate) fn initialize(&self, value: Initializer) {\n+        self.0.store(value.0, Ordering::Relaxed);\n+    }\n+}\n+\n+/// Feature cache with capacity for `CACHE_CAPACITY` features.\n+///\n+/// Note: the last feature bit is used to represent an\n+/// uninitialized cache.\n+#[cfg(target_pointer_width = \"32\")]\n+struct Cache(AtomicU32, AtomicU32);\n+\n+#[cfg(target_pointer_width = \"32\")]\n+impl Cache {\n+    /// Creates an uninitialized cache.\n+    const fn uninitialized() -> Self {\n+        Cache(\n+            AtomicU32::new(u32::max_value()),\n+            AtomicU32::new(u32::max_value()),\n+        )\n+    }\n+    /// Is the cache uninitialized?\n+    #[inline]\n+    pub(crate) fn is_uninitialized(&self) -> bool {\n+        self.1.load(Ordering::Relaxed) == u32::max_value()\n+    }\n+\n+    /// Is the `bit` in the cache set?\n+    #[inline]\n+    pub(crate) fn test(&self, bit: u32) -> bool {\n+        if bit < 32 {\n+            test_bit(CACHE.0.load(Ordering::Relaxed) as u64, bit)\n+        } else {\n+            test_bit(CACHE.1.load(Ordering::Relaxed) as u64, bit - 32)\n+        }\n+    }\n+\n+    /// Initializes the cache.\n+    #[inline]\n+    pub(crate) fn initialize(&self, value: Initializer) {\n+        let lo: u32 = value.0 as u32;\n+        let hi: u32 = (value.0 >> 32) as u32;\n+        self.0.store(lo, Ordering::Relaxed);\n+        self.1.store(hi, Ordering::Relaxed);\n+    }\n+}\n+\n+/// Tests the `bit` of the storage. If the storage has not been initialized,\n+/// initializes it with the result of `f()`.\n+///\n+/// On its first invocation, it detects the CPU features and caches them in the\n+/// `CACHE` global variable as an `AtomicU64`.\n+///\n+/// It uses the `Feature` variant to index into this variable as a bitset. If\n+/// the bit is set, the feature is enabled, and otherwise it is disabled.\n+#[inline]\n+pub(crate) fn test<F>(bit: u32, f: F) -> bool\n+where\n+    F: FnOnce() -> Initializer,\n+{\n+    if CACHE.is_uninitialized() {\n+        CACHE.initialize(f());\n+    }\n+    CACHE.test(bit)\n+}"}, {"sha": "6769757ed93319f76e44aa726c24cf1c2b40d4f6", "filename": "tests/target/cfg_if/detect/error_macros.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Ferror_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Ferror_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Ferror_macros.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,150 @@\n+//! The `is_{target_arch}_feature_detected!` macro are only available on their\n+//! architecture. These macros provide a better error messages when the user\n+//! attempts to call them in a different architecture.\n+\n+/// Prevents compilation if `is_x86_feature_detected` is used somewhere\n+/// else than `x86` and `x86_64` targets.\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_x86_feature_detected {\n+    ($t: tt) => {\n+        compile_error!(\n+            r#\"\n+        is_x86_feature_detected can only be used on x86 and x86_64 targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n+                if is_x86_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_arm_feature_detected` is used somewhere else\n+/// than `ARM` targets.\n+#[cfg(not(target_arch = \"arm\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_arm_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+        is_arm_feature_detected can only be used on ARM targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(target_arch = \"arm\")] {\n+                if is_arm_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_aarch64_feature_detected` is used somewhere else\n+/// than `aarch64` targets.\n+#[cfg(not(target_arch = \"aarch64\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_aarch64_feature_detected {\n+    ($t: tt) => {\n+        compile_error!(\n+            r#\"\n+        is_aarch64_feature_detected can only be used on AArch64 targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(target_arch = \"aarch64\")] {\n+                if is_aarch64_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_powerpc_feature_detected` is used somewhere else\n+/// than `PowerPC` targets.\n+#[cfg(not(target_arch = \"powerpc\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_powerpc_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+is_powerpc_feature_detected can only be used on PowerPC targets.\n+You can prevent it from being used in other architectures by\n+guarding it behind a cfg(target_arch) as follows:\n+\n+    #[cfg(target_arch = \"powerpc\")] {\n+        if is_powerpc_feature_detected(...) { ... }\n+    }\n+\"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_powerpc64_feature_detected` is used somewhere\n+/// else than `PowerPC64` targets.\n+#[cfg(not(target_arch = \"powerpc64\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_powerpc64_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+is_powerpc64_feature_detected can only be used on PowerPC64 targets.\n+You can prevent it from being used in other architectures by\n+guarding it behind a cfg(target_arch) as follows:\n+\n+    #[cfg(target_arch = \"powerpc64\")] {\n+        if is_powerpc64_feature_detected(...) { ... }\n+    }\n+\"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_mips_feature_detected` is used somewhere else\n+/// than `MIPS` targets.\n+#[cfg(not(target_arch = \"mips\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_mips_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+        is_mips_feature_detected can only be used on MIPS targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(target_arch = \"mips\")] {\n+                if is_mips_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}\n+\n+/// Prevents compilation if `is_mips64_feature_detected` is used somewhere else\n+/// than `MIPS64` targets.\n+#[cfg(not(target_arch = \"mips64\"))]\n+#[macro_export]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+macro_rules! is_mips64_feature_detected {\n+    ($t:tt) => {\n+        compile_error!(\n+            r#\"\n+        is_mips64_feature_detected can only be used on MIPS64 targets.\n+        You can prevent it from being used in other architectures by\n+        guarding it behind a cfg(target_arch) as follows:\n+\n+            #[cfg(target_arch = \"mips64\")] {\n+                if is_mips64_feature_detected(...) { ... }\n+            }\n+        \"#\n+        )\n+    };\n+}"}, {"sha": "f446e88eedc8ca1174cd80919e8dd22cee5771b3", "filename": "tests/target/cfg_if/detect/mod.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fmod.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,85 @@\n+//! This module implements run-time feature detection.\n+//!\n+//! The `is_{arch}_feature_detected!(\"feature-name\")` macros take the name of a\n+//! feature as a string-literal, and return a boolean indicating whether the\n+//! feature is enabled at run-time or not.\n+//!\n+//! These macros do two things:\n+//! * map the string-literal into an integer stored as a `Feature` enum,\n+//! * call a `os::check_for(x: Feature)` function that returns `true` if the\n+//! feature is enabled.\n+//!\n+//! The `Feature` enums are also implemented in the `arch/{target_arch}.rs`\n+//! modules.\n+//!\n+//! The `check_for` functions are, in general, Operating System dependent. Most\n+//! architectures do not allow user-space programs to query the feature bits\n+//! due to security concerns (x86 is the big exception). These functions are\n+//! implemented in the `os/{target_os}.rs` modules.\n+\n+#[macro_use]\n+mod error_macros;\n+\n+cfg_if! {\n+    if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n+        #[path = \"arch/x86.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"arm\")] {\n+        #[path = \"arch/arm.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"aarch64\")] {\n+        #[path = \"arch/aarch64.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"powerpc\")] {\n+        #[path = \"arch/powerpc.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"powerpc64\")] {\n+        #[path = \"arch/powerpc64.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"mips\")] {\n+        #[path = \"arch/mips.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else if #[cfg(target_arch = \"mips64\")] {\n+        #[path = \"arch/mips64.rs\"]\n+        #[macro_use]\n+        mod arch;\n+    } else {\n+        // Unimplemented architecture:\n+        mod arch {\n+            pub enum Feature {\n+                Null\n+            }\n+        }\n+    }\n+}\n+pub use self::arch::Feature;\n+\n+mod bit;\n+mod cache;\n+\n+cfg_if! {\n+    if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n+        // On x86/x86_64 no OS specific functionality is required.\n+        #[path = \"os/x86.rs\"]\n+        mod os;\n+    } else if #[cfg(all(target_os = \"linux\", feature = \"use_std\"))] {\n+        #[path = \"os/linux/mod.rs\"]\n+        mod os;\n+    } else if #[cfg(target_os = \"freebsd\")] {\n+        #[cfg(target_arch = \"aarch64\")]\n+        #[path = \"os/aarch64.rs\"]\n+        mod aarch64;\n+        #[path = \"os/freebsd/mod.rs\"]\n+        mod os;\n+    } else {\n+        #[path = \"os/other.rs\"]\n+        mod os;\n+    }\n+}\n+pub use self::os::check_for;"}, {"sha": "9adc938a26434f4fa629ca11b1d0a946b232026d", "filename": "tests/target/cfg_if/detect/os/aarch64.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Faarch64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,88 @@\n+//! Run-time feature detection for Aarch64 on any OS that emulates the mrs instruction.\n+//!\n+//! On FreeBSD >= 12.0, Linux >= 4.11 and other operating systems, it is possible to use\n+//! privileged system registers from userspace to check CPU feature support.\n+//!\n+//! AArch64 system registers ID_AA64ISAR0_EL1, ID_AA64PFR0_EL1, ID_AA64ISAR1_EL1\n+//! have bits dedicated to features like AdvSIMD, CRC32, AES, atomics (LSE), etc.\n+//! Each part of the register indicates the level of support for a certain feature, e.g.\n+//! when ID_AA64ISAR0_EL1\\[7:4\\] is >= 1, AES is supported; when it's >= 2, PMULL is supported.\n+//!\n+//! For proper support of [SoCs where different cores have different capabilities](https://medium.com/@jadr2ddude/a-big-little-problem-a-tale-of-big-little-gone-wrong-e7778ce744bb),\n+//! the OS has to always report only the features supported by all cores, like [FreeBSD does](https://reviews.freebsd.org/D17137#393947).\n+//!\n+//! References:\n+//!\n+//! - [Zircon implementation](https://fuchsia.googlesource.com/zircon/+/master/kernel/arch/arm64/feature.cpp)\n+//! - [Linux documentation](https://www.kernel.org/doc/Documentation/arm64/cpu-feature-registers.txt)\n+\n+use crate::detect::{cache, Feature};\n+\n+/// Try to read the features from the system registers.\n+///\n+/// This will cause SIGILL if the current OS is not trapping the mrs instruction.\n+pub(crate) fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+\n+    {\n+        let mut enable_feature = |f, enable| {\n+            if enable {\n+                value.set(f as u32);\n+            }\n+        };\n+\n+        // ID_AA64ISAR0_EL1 - Instruction Set Attribute Register 0\n+        let aa64isar0: u64;\n+        unsafe {\n+            asm!(\"mrs $0, ID_AA64ISAR0_EL1\" : \"=r\"(aa64isar0));\n+        }\n+\n+        let aes = bits_shift(aa64isar0, 7, 4) >= 1;\n+        let pmull = bits_shift(aa64isar0, 7, 4) >= 2;\n+        let sha1 = bits_shift(aa64isar0, 11, 8) >= 1;\n+        let sha2 = bits_shift(aa64isar0, 15, 12) >= 1;\n+        enable_feature(Feature::pmull, pmull);\n+        // Crypto is specified as AES + PMULL + SHA1 + SHA2 per LLVM/hosts.cpp\n+        enable_feature(Feature::crypto, aes && pmull && sha1 && sha2);\n+        enable_feature(Feature::lse, bits_shift(aa64isar0, 23, 20) >= 1);\n+        enable_feature(Feature::crc, bits_shift(aa64isar0, 19, 16) >= 1);\n+\n+        // ID_AA64PFR0_EL1 - Processor Feature Register 0\n+        let aa64pfr0: u64;\n+        unsafe {\n+            asm!(\"mrs $0, ID_AA64PFR0_EL1\" : \"=r\"(aa64pfr0));\n+        }\n+\n+        let fp = bits_shift(aa64pfr0, 19, 16) < 0xF;\n+        let fphp = bits_shift(aa64pfr0, 19, 16) >= 1;\n+        let asimd = bits_shift(aa64pfr0, 23, 20) < 0xF;\n+        let asimdhp = bits_shift(aa64pfr0, 23, 20) >= 1;\n+        enable_feature(Feature::fp, fp);\n+        enable_feature(Feature::fp16, fphp);\n+        // SIMD support requires float support - if half-floats are\n+        // supported, it also requires half-float support:\n+        enable_feature(Feature::asimd, fp && asimd && (!fphp | asimdhp));\n+        // SIMD extensions require SIMD support:\n+        enable_feature(Feature::rdm, asimd && bits_shift(aa64isar0, 31, 28) >= 1);\n+        enable_feature(\n+            Feature::dotprod,\n+            asimd && bits_shift(aa64isar0, 47, 44) >= 1,\n+        );\n+        enable_feature(Feature::sve, asimd && bits_shift(aa64pfr0, 35, 32) >= 1);\n+\n+        // ID_AA64ISAR1_EL1 - Instruction Set Attribute Register 1\n+        let aa64isar1: u64;\n+        unsafe {\n+            asm!(\"mrs $0, ID_AA64ISAR1_EL1\" : \"=r\"(aa64isar1));\n+        }\n+\n+        enable_feature(Feature::rcpc, bits_shift(aa64isar1, 23, 20) >= 1);\n+    }\n+\n+    value\n+}\n+\n+#[inline]\n+fn bits_shift(x: u64, high: usize, low: usize) -> u64 {\n+    (x >> low) & ((1 << (high - low + 1)) - 1)\n+}"}, {"sha": "97fe40f80a46ca292e67b5931ee1d221723561fa", "filename": "tests/target/cfg_if/detect/os/freebsd/aarch64.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Faarch64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,28 @@\n+//! Run-time feature detection for Aarch64 on FreeBSD.\n+\n+use super::super::aarch64::detect_features;\n+use crate::detect::{cache, Feature};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn dump() {\n+        println!(\"asimd: {:?}\", is_aarch64_feature_detected!(\"asimd\"));\n+        println!(\"pmull: {:?}\", is_aarch64_feature_detected!(\"pmull\"));\n+        println!(\"fp: {:?}\", is_aarch64_feature_detected!(\"fp\"));\n+        println!(\"fp16: {:?}\", is_aarch64_feature_detected!(\"fp16\"));\n+        println!(\"sve: {:?}\", is_aarch64_feature_detected!(\"sve\"));\n+        println!(\"crc: {:?}\", is_aarch64_feature_detected!(\"crc\"));\n+        println!(\"crypto: {:?}\", is_aarch64_feature_detected!(\"crypto\"));\n+        println!(\"lse: {:?}\", is_aarch64_feature_detected!(\"lse\"));\n+        println!(\"rdm: {:?}\", is_aarch64_feature_detected!(\"rdm\"));\n+        println!(\"rcpc: {:?}\", is_aarch64_feature_detected!(\"rcpc\"));\n+        println!(\"dotprod: {:?}\", is_aarch64_feature_detected!(\"dotprod\"));\n+    }\n+}"}, {"sha": "7aa040075e04ab8ba999bfdf79fe0d3a0beefc8d", "filename": "tests/target/cfg_if/detect/os/freebsd/arm.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Farm.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,27 @@\n+//! Run-time feature detection for ARM on FreeBSD\n+\n+use super::auxvec;\n+use crate::detect::{cache, Feature};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    if let Ok(auxv) = auxvec::auxv() {\n+        enable_feature(&mut value, Feature::neon, auxv.hwcap & 0x00001000 != 0);\n+        enable_feature(&mut value, Feature::pmull, auxv.hwcap2 & 0x00000002 != 0);\n+        return value;\n+    }\n+    value\n+}"}, {"sha": "c595ec459b5d21e3df298588e8c163a4654a8c1c", "filename": "tests/target/cfg_if/detect/os/freebsd/auxvec.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fauxvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fauxvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fauxvec.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,94 @@\n+//! Parses ELF auxiliary vectors.\n+#![cfg_attr(any(target_arch = \"arm\", target_arch = \"powerpc64\"), allow(dead_code))]\n+\n+/// Key to access the CPU Hardware capabilities bitfield.\n+pub(crate) const AT_HWCAP: usize = 25;\n+/// Key to access the CPU Hardware capabilities 2 bitfield.\n+pub(crate) const AT_HWCAP2: usize = 26;\n+\n+/// Cache HWCAP bitfields of the ELF Auxiliary Vector.\n+///\n+/// If an entry cannot be read all the bits in the bitfield are set to zero.\n+/// This should be interpreted as all the features being disabled.\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) struct AuxVec {\n+    pub hwcap: usize,\n+    pub hwcap2: usize,\n+}\n+\n+/// ELF Auxiliary Vector\n+///\n+/// The auxiliary vector is a memory region in a running ELF program's stack\n+/// composed of (key: usize, value: usize) pairs.\n+///\n+/// The keys used in the aux vector are platform dependent. For FreeBSD, they are\n+/// defined in [sys/elf_common.h][elf_common_h]. The hardware capabilities of a given\n+/// CPU can be queried with the  `AT_HWCAP` and `AT_HWCAP2` keys.\n+///\n+/// Note that run-time feature detection is not invoked for features that can\n+/// be detected at compile-time.\n+///\n+/// [elf_common.h]: https://svnweb.freebsd.org/base/release/12.0.0/sys/sys/elf_common.h?revision=341707\n+pub(crate) fn auxv() -> Result<AuxVec, ()> {\n+    if let Ok(hwcap) = archauxv(AT_HWCAP) {\n+        if let Ok(hwcap2) = archauxv(AT_HWCAP2) {\n+            if hwcap != 0 && hwcap2 != 0 {\n+                return Ok(AuxVec { hwcap, hwcap2 });\n+            }\n+        }\n+    }\n+    Err(())\n+}\n+\n+/// Tries to read the `key` from the auxiliary vector.\n+fn archauxv(key: usize) -> Result<usize, ()> {\n+    use crate::mem;\n+\n+    #[derive(Copy, Clone)]\n+    #[repr(C)]\n+    pub struct Elf_Auxinfo {\n+        pub a_type: usize,\n+        pub a_un: unnamed,\n+    }\n+    #[derive(Copy, Clone)]\n+    #[repr(C)]\n+    pub union unnamed {\n+        pub a_val: libc::c_long,\n+        pub a_ptr: *mut libc::c_void,\n+        pub a_fcn: Option<unsafe extern \"C\" fn() -> ()>,\n+    }\n+\n+    let mut auxv: [Elf_Auxinfo; 27] = [Elf_Auxinfo {\n+        a_type: 0,\n+        a_un: unnamed { a_val: 0 },\n+    }; 27];\n+\n+    let mut len: libc::c_uint = mem::size_of_val(&auxv) as libc::c_uint;\n+\n+    unsafe {\n+        let mut mib = [\n+            libc::CTL_KERN,\n+            libc::KERN_PROC,\n+            libc::KERN_PROC_AUXV,\n+            libc::getpid(),\n+        ];\n+\n+        let ret = libc::sysctl(\n+            mib.as_mut_ptr(),\n+            mib.len() as u32,\n+            &mut auxv as *mut _ as *mut _,\n+            &mut len as *mut _ as *mut _,\n+            0 as *mut libc::c_void,\n+            0,\n+        );\n+\n+        if ret != -1 {\n+            for i in 0..auxv.len() {\n+                if auxv[i].a_type == key {\n+                    return Ok(auxv[i].a_un.a_val as usize);\n+                }\n+            }\n+        }\n+    }\n+    return Ok(0);\n+}"}, {"sha": "1a5338a3555958c559a1dc247b7b64ea85f47be5", "filename": "tests/target/cfg_if/detect/os/freebsd/mod.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fmod.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,22 @@\n+//! Run-time feature detection on FreeBSD\n+\n+mod auxvec;\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"aarch64\")] {\n+        mod aarch64;\n+        pub use self::aarch64::check_for;\n+    } else if #[cfg(target_arch = \"arm\")] {\n+        mod arm;\n+        pub use self::arm::check_for;\n+    } else if #[cfg(target_arch = \"powerpc64\")] {\n+        mod powerpc;\n+        pub use self::powerpc::check_for;\n+    } else {\n+        use crate::arch::detect::Feature;\n+        /// Performs run-time feature detection.\n+        pub fn check_for(_x: Feature) -> bool {\n+            false\n+        }\n+    }\n+}"}, {"sha": "203e5cd7f2506551ee4e5067b6ad574384f3f421", "filename": "tests/target/cfg_if/detect/os/freebsd/powerpc.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Ffreebsd%2Fpowerpc.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,27 @@\n+//! Run-time feature detection for PowerPC on FreeBSD.\n+\n+use super::auxvec;\n+use crate::detect::{cache, Feature};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    if let Ok(auxv) = auxvec::auxv() {\n+        enable_feature(&mut value, Feature::altivec, auxv.hwcap & 0x10000000 != 0);\n+        enable_feature(&mut value, Feature::vsx, auxv.hwcap & 0x00000080 != 0);\n+        enable_feature(&mut value, Feature::power8, auxv.hwcap2 & 0x80000000 != 0);\n+        return value;\n+    }\n+    value\n+}"}, {"sha": "8d874f2280fc107bdd042e8c6dcbb00157ed97c1", "filename": "tests/target/cfg_if/detect/os/linux/aarch64.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Faarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Faarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Faarch64.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,160 @@\n+//! Run-time feature detection for Aarch64 on Linux.\n+\n+use super::{auxvec, cpuinfo};\n+use crate::detect::{bit, cache, Feature};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector, and if that fails, try\n+/// to read them from /proc/cpuinfo.\n+fn detect_features() -> cache::Initializer {\n+    if let Ok(auxv) = auxvec::auxv() {\n+        let hwcap: AtHwcap = auxv.into();\n+        return hwcap.cache();\n+    }\n+    if let Ok(c) = cpuinfo::CpuInfo::new() {\n+        let hwcap: AtHwcap = c.into();\n+        return hwcap.cache();\n+    }\n+    cache::Initializer::default()\n+}\n+\n+/// These values are part of the platform-specific [asm/hwcap.h][hwcap] .\n+///\n+/// [hwcap]: https://github.com/torvalds/linux/blob/master/arch/arm64/include/uapi/asm/hwcap.h\n+struct AtHwcap {\n+    fp: bool,    // 0\n+    asimd: bool, // 1\n+    // evtstrm: bool, // 2\n+    aes: bool,     // 3\n+    pmull: bool,   // 4\n+    sha1: bool,    // 5\n+    sha2: bool,    // 6\n+    crc32: bool,   // 7\n+    atomics: bool, // 8\n+    fphp: bool,    // 9\n+    asimdhp: bool, // 10\n+    // cpuid: bool, // 11\n+    asimdrdm: bool, // 12\n+    // jscvt: bool, // 13\n+    // fcma: bool, // 14\n+    lrcpc: bool, // 15\n+    // dcpop: bool, // 16\n+    // sha3: bool, // 17\n+    // sm3: bool, // 18\n+    // sm4: bool, // 19\n+    asimddp: bool, // 20\n+    // sha512: bool, // 21\n+    sve: bool, // 22\n+}\n+\n+impl From<auxvec::AuxVec> for AtHwcap {\n+    /// Reads AtHwcap from the auxiliary vector.\n+    fn from(auxv: auxvec::AuxVec) -> Self {\n+        AtHwcap {\n+            fp: bit::test(auxv.hwcap, 0),\n+            asimd: bit::test(auxv.hwcap, 1),\n+            // evtstrm: bit::test(auxv.hwcap, 2),\n+            aes: bit::test(auxv.hwcap, 3),\n+            pmull: bit::test(auxv.hwcap, 4),\n+            sha1: bit::test(auxv.hwcap, 5),\n+            sha2: bit::test(auxv.hwcap, 6),\n+            crc32: bit::test(auxv.hwcap, 7),\n+            atomics: bit::test(auxv.hwcap, 8),\n+            fphp: bit::test(auxv.hwcap, 9),\n+            asimdhp: bit::test(auxv.hwcap, 10),\n+            // cpuid: bit::test(auxv.hwcap, 11),\n+            asimdrdm: bit::test(auxv.hwcap, 12),\n+            // jscvt: bit::test(auxv.hwcap, 13),\n+            // fcma: bit::test(auxv.hwcap, 14),\n+            lrcpc: bit::test(auxv.hwcap, 15),\n+            // dcpop: bit::test(auxv.hwcap, 16),\n+            // sha3: bit::test(auxv.hwcap, 17),\n+            // sm3: bit::test(auxv.hwcap, 18),\n+            // sm4: bit::test(auxv.hwcap, 19),\n+            asimddp: bit::test(auxv.hwcap, 20),\n+            // sha512: bit::test(auxv.hwcap, 21),\n+            sve: bit::test(auxv.hwcap, 22),\n+        }\n+    }\n+}\n+\n+impl From<cpuinfo::CpuInfo> for AtHwcap {\n+    /// Reads AtHwcap from /proc/cpuinfo .\n+    fn from(c: cpuinfo::CpuInfo) -> Self {\n+        let f = &c.field(\"Features\");\n+        AtHwcap {\n+            // 64-bit names. FIXME: In 32-bit compatibility mode /proc/cpuinfo will\n+            // map some of the 64-bit names to some 32-bit feature names. This does not\n+            // cover that yet.\n+            fp: f.has(\"fp\"),\n+            asimd: f.has(\"asimd\"),\n+            // evtstrm: f.has(\"evtstrm\"),\n+            aes: f.has(\"aes\"),\n+            pmull: f.has(\"pmull\"),\n+            sha1: f.has(\"sha1\"),\n+            sha2: f.has(\"sha2\"),\n+            crc32: f.has(\"crc32\"),\n+            atomics: f.has(\"atomics\"),\n+            fphp: f.has(\"fphp\"),\n+            asimdhp: f.has(\"asimdhp\"),\n+            // cpuid: f.has(\"cpuid\"),\n+            asimdrdm: f.has(\"asimdrdm\"),\n+            // jscvt: f.has(\"jscvt\"),\n+            // fcma: f.has(\"fcma\"),\n+            lrcpc: f.has(\"lrcpc\"),\n+            // dcpop: f.has(\"dcpop\"),\n+            // sha3: f.has(\"sha3\"),\n+            // sm3: f.has(\"sm3\"),\n+            // sm4: f.has(\"sm4\"),\n+            asimddp: f.has(\"asimddp\"),\n+            // sha512: f.has(\"sha512\"),\n+            sve: f.has(\"sve\"),\n+        }\n+    }\n+}\n+\n+impl AtHwcap {\n+    /// Initializes the cache from the feature -bits.\n+    ///\n+    /// The features are enabled approximately like in LLVM host feature detection:\n+    /// https://github.com/llvm-mirror/llvm/blob/master/lib/Support/Host.cpp#L1273\n+    fn cache(self) -> cache::Initializer {\n+        let mut value = cache::Initializer::default();\n+        {\n+            let mut enable_feature = |f, enable| {\n+                if enable {\n+                    value.set(f as u32);\n+                }\n+            };\n+\n+            enable_feature(Feature::fp, self.fp);\n+            // Half-float support requires float support\n+            enable_feature(Feature::fp16, self.fp && self.fphp);\n+            enable_feature(Feature::pmull, self.pmull);\n+            enable_feature(Feature::crc, self.crc32);\n+            enable_feature(Feature::lse, self.atomics);\n+            enable_feature(Feature::rcpc, self.lrcpc);\n+\n+            // SIMD support requires float support - if half-floats are\n+            // supported, it also requires half-float support:\n+            let asimd = self.fp && self.asimd && (!self.fphp | self.asimdhp);\n+            enable_feature(Feature::asimd, asimd);\n+            // SIMD extensions require SIMD support:\n+            enable_feature(Feature::rdm, self.asimdrdm && asimd);\n+            enable_feature(Feature::dotprod, self.asimddp && asimd);\n+            enable_feature(Feature::sve, self.sve && asimd);\n+\n+            // Crypto is specified as AES + PMULL + SHA1 + SHA2 per LLVM/hosts.cpp\n+            enable_feature(\n+                Feature::crypto,\n+                self.aes && self.pmull && self.sha1 && self.sha2,\n+            );\n+        }\n+        value\n+    }\n+}"}, {"sha": "9c89500cc1000ce0622886e76314693f4fa0a142", "filename": "tests/target/cfg_if/detect/os/linux/arm.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Farm.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,52 @@\n+//! Run-time feature detection for ARM on Linux.\n+\n+use super::{auxvec, cpuinfo};\n+use crate::detect::{bit, cache, Feature};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector, and if that fails, try\n+/// to read them from /proc/cpuinfo.\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    // The values are part of the platform-specific [asm/hwcap.h][hwcap]\n+    //\n+    // [hwcap]: https://github.com/torvalds/linux/blob/master/arch/arm64/include/uapi/asm/hwcap.h\n+    if let Ok(auxv) = auxvec::auxv() {\n+        enable_feature(&mut value, Feature::neon, bit::test(auxv.hwcap, 12));\n+        enable_feature(&mut value, Feature::pmull, bit::test(auxv.hwcap2, 1));\n+        return value;\n+    }\n+\n+    if let Ok(c) = cpuinfo::CpuInfo::new() {\n+        enable_feature(\n+            &mut value,\n+            Feature::neon,\n+            c.field(\"Features\").has(\"neon\") && !has_broken_neon(&c),\n+        );\n+        enable_feature(&mut value, Feature::pmull, c.field(\"Features\").has(\"pmull\"));\n+        return value;\n+    }\n+    value\n+}\n+\n+/// Is the CPU known to have a broken NEON unit?\n+///\n+/// See https://crbug.com/341598.\n+fn has_broken_neon(cpuinfo: &cpuinfo::CpuInfo) -> bool {\n+    cpuinfo.field(\"CPU implementer\") == \"0x51\"\n+        && cpuinfo.field(\"CPU architecture\") == \"7\"\n+        && cpuinfo.field(\"CPU variant\") == \"0x1\"\n+        && cpuinfo.field(\"CPU part\") == \"0x04d\"\n+        && cpuinfo.field(\"CPU revision\") == \"0\"\n+}"}, {"sha": "6ebae67fbf873e8421fe1b017806e5ba48134db5", "filename": "tests/target/cfg_if/detect/os/linux/auxvec.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fauxvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fauxvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fauxvec.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,304 @@\n+//! Parses ELF auxiliary vectors.\n+#![cfg_attr(not(target_arch = \"aarch64\"), allow(dead_code))]\n+\n+#[cfg(feature = \"std_detect_file_io\")]\n+use crate::{fs::File, io::Read};\n+\n+/// Key to access the CPU Hardware capabilities bitfield.\n+pub(crate) const AT_HWCAP: usize = 16;\n+/// Key to access the CPU Hardware capabilities 2 bitfield.\n+#[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+pub(crate) const AT_HWCAP2: usize = 26;\n+\n+/// Cache HWCAP bitfields of the ELF Auxiliary Vector.\n+///\n+/// If an entry cannot be read all the bits in the bitfield are set to zero.\n+/// This should be interpreted as all the features being disabled.\n+#[derive(Debug, Copy, Clone)]\n+pub(crate) struct AuxVec {\n+    pub hwcap: usize,\n+    #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+    pub hwcap2: usize,\n+}\n+\n+/// ELF Auxiliary Vector\n+///\n+/// The auxiliary vector is a memory region in a running ELF program's stack\n+/// composed of (key: usize, value: usize) pairs.\n+///\n+/// The keys used in the aux vector are platform dependent. For Linux, they are\n+/// defined in [linux/auxvec.h][auxvec_h]. The hardware capabilities of a given\n+/// CPU can be queried with the  `AT_HWCAP` and `AT_HWCAP2` keys.\n+///\n+/// There is no perfect way of reading the auxiliary vector.\n+///\n+/// - If the `std_detect_dlsym_getauxval` cargo feature is enabled, this will use\n+/// `getauxval` if its linked to the binary, and otherwise proceed to a fallback implementation.\n+/// When `std_detect_dlsym_getauxval` is disabled, this will assume that `getauxval` is\n+/// linked to the binary - if that is not the case the behavior is undefined.\n+/// - Otherwise, if the `std_detect_file_io` cargo feature is enabled, it will\n+///   try to read `/proc/self/auxv`.\n+/// - If that fails, this function returns an error.\n+///\n+/// Note that run-time feature detection is not invoked for features that can\n+/// be detected at compile-time. Also note that if this function returns an\n+/// error, cpuinfo still can (and will) be used to try to perform run-time\n+/// feature detecton on some platforms.\n+///\n+/// For more information about when `getauxval` is available check the great\n+/// [`auxv` crate documentation][auxv_docs].\n+///\n+/// [auxvec_h]: https://github.com/torvalds/linux/blob/master/include/uapi/linux/auxvec.h\n+/// [auxv_docs]: https://docs.rs/auxv/0.3.3/auxv/\n+pub(crate) fn auxv() -> Result<AuxVec, ()> {\n+    #[cfg(feature = \"std_detect_dlsym_getauxval\")]\n+    {\n+        // Try to call a dynamically-linked getauxval function.\n+        if let Ok(hwcap) = getauxval(AT_HWCAP) {\n+            // Targets with only AT_HWCAP:\n+            #[cfg(any(target_arch = \"aarch64\", target_arch = \"mips\", target_arch = \"mips64\"))]\n+            {\n+                if hwcap != 0 {\n+                    return Ok(AuxVec { hwcap });\n+                }\n+            }\n+\n+            // Targets with AT_HWCAP and AT_HWCAP2:\n+            #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+            {\n+                if let Ok(hwcap2) = getauxval(AT_HWCAP2) {\n+                    if hwcap != 0 && hwcap2 != 0 {\n+                        return Ok(AuxVec { hwcap, hwcap2 });\n+                    }\n+                }\n+            }\n+            drop(hwcap);\n+        }\n+        #[cfg(feature = \"std_detect_file_io\")]\n+        {\n+            // If calling getauxval fails, try to read the auxiliary vector from\n+            // its file:\n+            auxv_from_file(\"/proc/self/auxv\")\n+        }\n+        #[cfg(not(feature = \"std_detect_file_io\"))]\n+        {\n+            Err(())\n+        }\n+    }\n+\n+    #[cfg(not(feature = \"std_detect_dlsym_getauxval\"))]\n+    {\n+        let hwcap = unsafe { ffi_getauxval(AT_HWCAP) };\n+\n+        // Targets with only AT_HWCAP:\n+        #[cfg(any(target_arch = \"aarch64\", target_arch = \"mips\", target_arch = \"mips64\"))]\n+        {\n+            if hwcap != 0 {\n+                return Ok(AuxVec { hwcap });\n+            }\n+        }\n+\n+        // Targets with AT_HWCAP and AT_HWCAP2:\n+        #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+        {\n+            let hwcap2 = unsafe { ffi_getauxval(AT_HWCAP2) };\n+            if hwcap != 0 && hwcap2 != 0 {\n+                return Ok(AuxVec { hwcap, hwcap2 });\n+            }\n+        }\n+    }\n+}\n+\n+/// Tries to read the `key` from the auxiliary vector by calling the\n+/// dynamically-linked `getauxval` function. If the function is not linked,\n+/// this function return `Err`.\n+#[cfg(feature = \"std_detect_dlsym_getauxval\")]\n+fn getauxval(key: usize) -> Result<usize, ()> {\n+    use libc;\n+    pub type F = unsafe extern \"C\" fn(usize) -> usize;\n+    unsafe {\n+        let ptr = libc::dlsym(libc::RTLD_DEFAULT, \"getauxval\\0\".as_ptr() as *const _);\n+        if ptr.is_null() {\n+            return Err(());\n+        }\n+\n+        let ffi_getauxval: F = mem::transmute(ptr);\n+        Ok(ffi_getauxval(key))\n+    }\n+}\n+\n+/// Tries to read the auxiliary vector from the `file`. If this fails, this\n+/// function returns `Err`.\n+#[cfg(feature = \"std_detect_file_io\")]\n+fn auxv_from_file(file: &str) -> Result<AuxVec, ()> {\n+    let mut file = File::open(file).map_err(|_| ())?;\n+\n+    // See <https://github.com/torvalds/linux/blob/v3.19/include/uapi/linux/auxvec.h>.\n+    //\n+    // The auxiliary vector contains at most 32 (key,value) fields: from\n+    // `AT_EXECFN = 31` to `AT_NULL = 0`. That is, a buffer of\n+    // 2*32 `usize` elements is enough to read the whole vector.\n+    let mut buf = [0_usize; 64];\n+    {\n+        let raw: &mut [u8; 64 * mem::size_of::<usize>()] = unsafe { mem::transmute(&mut buf) };\n+        file.read(raw).map_err(|_| ())?;\n+    }\n+    auxv_from_buf(&buf)\n+}\n+\n+/// Tries to interpret the `buffer` as an auxiliary vector. If that fails, this\n+/// function returns `Err`.\n+#[cfg(feature = \"std_detect_file_io\")]\n+fn auxv_from_buf(buf: &[usize; 64]) -> Result<AuxVec, ()> {\n+    // Targets with only AT_HWCAP:\n+    #[cfg(any(target_arch = \"aarch64\", target_arch = \"mips\", target_arch = \"mips64\"))]\n+    {\n+        for el in buf.chunks(2) {\n+            match el[0] {\n+                AT_HWCAP => return Ok(AuxVec { hwcap: el[1] }),\n+                _ => (),\n+            }\n+        }\n+    }\n+    // Targets with AT_HWCAP and AT_HWCAP2:\n+    #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+    {\n+        let mut hwcap = None;\n+        let mut hwcap2 = None;\n+        for el in buf.chunks(2) {\n+            match el[0] {\n+                AT_HWCAP => hwcap = Some(el[1]),\n+                AT_HWCAP2 => hwcap2 = Some(el[1]),\n+                _ => (),\n+            }\n+        }\n+\n+        if let (Some(hwcap), Some(hwcap2)) = (hwcap, hwcap2) {\n+            return Ok(AuxVec { hwcap, hwcap2 });\n+        }\n+    }\n+    drop(buf);\n+    Err(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    extern crate auxv as auxv_crate;\n+    use super::*;\n+\n+    // Reads the Auxiliary Vector key from /proc/self/auxv\n+    // using the auxv crate.\n+    #[cfg(feature = \"std_detect_file_io\")]\n+    fn auxv_crate_getprocfs(key: usize) -> Option<usize> {\n+        use self::auxv_crate::procfs::search_procfs_auxv;\n+        use self::auxv_crate::AuxvType;\n+        let k = key as AuxvType;\n+        match search_procfs_auxv(&[k]) {\n+            Ok(v) => Some(v[&k] as usize),\n+            Err(_) => None,\n+        }\n+    }\n+\n+    // Reads the Auxiliary Vector key from getauxval()\n+    // using the auxv crate.\n+    #[cfg(not(any(target_arch = \"mips\", target_arch = \"mips64\")))]\n+    fn auxv_crate_getauxval(key: usize) -> Option<usize> {\n+        use self::auxv_crate::getauxval::Getauxval;\n+        use self::auxv_crate::AuxvType;\n+        let q = auxv_crate::getauxval::NativeGetauxval {};\n+        match q.getauxval(key as AuxvType) {\n+            Ok(v) => Some(v as usize),\n+            Err(_) => None,\n+        }\n+    }\n+\n+    // FIXME: on mips/mips64 getauxval returns 0, and /proc/self/auxv\n+    // does not always contain the AT_HWCAP key under qemu.\n+    #[cfg(not(any(target_arch = \"mips\", target_arch = \"mips64\", target_arch = \"powerpc\")))]\n+    #[test]\n+    fn auxv_crate() {\n+        let v = auxv();\n+        if let Some(hwcap) = auxv_crate_getauxval(AT_HWCAP) {\n+            let rt_hwcap = v.expect(\"failed to find hwcap key\").hwcap;\n+            assert_eq!(rt_hwcap, hwcap);\n+        }\n+\n+        // Targets with AT_HWCAP and AT_HWCAP2:\n+        #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+        {\n+            if let Some(hwcap2) = auxv_crate_getauxval(AT_HWCAP2) {\n+                let rt_hwcap2 = v.expect(\"failed to find hwcap2 key\").hwcap2;\n+                assert_eq!(rt_hwcap2, hwcap2);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn auxv_dump() {\n+        if let Ok(auxvec) = auxv() {\n+            println!(\"{:?}\", auxvec);\n+        } else {\n+            println!(\"both getauxval() and reading /proc/self/auxv failed!\");\n+        }\n+    }\n+\n+    #[cfg(feature = \"std_detect_file_io\")]\n+    cfg_if! {\n+        if #[cfg(target_arch = \"arm\")] {\n+            #[test]\n+            fn linux_rpi3() {\n+                let file = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/detect/test_data/linux-rpi3.auxv\");\n+                println!(\"file: {}\", file);\n+                let v = auxv_from_file(file).unwrap();\n+                assert_eq!(v.hwcap, 4174038);\n+                assert_eq!(v.hwcap2, 16);\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn linux_macos_vb() {\n+                let file = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/detect/test_data/macos-virtualbox-linux-x86-4850HQ.auxv\");\n+                println!(\"file: {}\", file);\n+                let v = auxv_from_file(file).unwrap();\n+                // this file is incomplete (contains hwcap but not hwcap2), we\n+                // want to fall back to /proc/cpuinfo in this case, so\n+                // reading should fail. assert_eq!(v.hwcap, 126614527);\n+                // assert_eq!(v.hwcap2, 0);\n+            }\n+        } else if #[cfg(target_arch = \"aarch64\")] {\n+            #[test]\n+            fn linux_x64() {\n+                let file = concat!(env!(\"CARGO_MANIFEST_DIR\"), \"/src/detect/test_data/linux-x64-i7-6850k.auxv\");\n+                println!(\"file: {}\", file);\n+                let v = auxv_from_file(file).unwrap();\n+                assert_eq!(v.hwcap, 3219913727);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    #[cfg(feature = \"std_detect_file_io\")]\n+    fn auxv_dump_procfs() {\n+        if let Ok(auxvec) = auxv_from_file(\"/proc/self/auxv\") {\n+            println!(\"{:?}\", auxvec);\n+        } else {\n+            println!(\"reading /proc/self/auxv failed!\");\n+        }\n+    }\n+\n+    #[test]\n+    fn auxv_crate_procfs() {\n+        let v = auxv();\n+        if let Some(hwcap) = auxv_crate_getprocfs(AT_HWCAP) {\n+            assert_eq!(v.unwrap().hwcap, hwcap);\n+        }\n+\n+        // Targets with AT_HWCAP and AT_HWCAP2:\n+        #[cfg(any(target_arch = \"arm\", target_arch = \"powerpc64\"))]\n+        {\n+            if let Some(hwcap2) = auxv_crate_getprocfs(AT_HWCAP2) {\n+                assert_eq!(v.unwrap().hwcap2, hwcap2);\n+            }\n+        }\n+    }\n+}"}, {"sha": "f76c48a4b16b0bb3a20327e116fd7f2090013dec", "filename": "tests/target/cfg_if/detect/os/linux/cpuinfo.rs", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fcpuinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fcpuinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fcpuinfo.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,300 @@\n+//! Parses /proc/cpuinfo\n+#![cfg_attr(not(target_arch = \"arm\"), allow(dead_code))]\n+\n+extern crate std;\n+use self::std::{fs::File, io, io::Read, prelude::v1::*};\n+\n+/// cpuinfo\n+pub(crate) struct CpuInfo {\n+    raw: String,\n+}\n+\n+impl CpuInfo {\n+    /// Reads /proc/cpuinfo into CpuInfo.\n+    pub(crate) fn new() -> Result<Self, io::Error> {\n+        let mut file = File::open(\"/proc/cpuinfo\")?;\n+        let mut cpui = Self { raw: String::new() };\n+        file.read_to_string(&mut cpui.raw)?;\n+        Ok(cpui)\n+    }\n+    /// Returns the value of the cpuinfo `field`.\n+    pub(crate) fn field(&self, field: &str) -> CpuInfoField {\n+        for l in self.raw.lines() {\n+            if l.trim().starts_with(field) {\n+                return CpuInfoField::new(l.split(\": \").nth(1));\n+            }\n+        }\n+        CpuInfoField(None)\n+    }\n+\n+    /// Returns the `raw` contents of `/proc/cpuinfo`\n+    #[cfg(test)]\n+    fn raw(&self) -> &String {\n+        &self.raw\n+    }\n+\n+    #[cfg(test)]\n+    fn from_str(other: &str) -> Result<Self, ::std::io::Error> {\n+        Ok(Self {\n+            raw: String::from(other),\n+        })\n+    }\n+}\n+\n+/// Field of cpuinfo\n+#[derive(Debug)]\n+pub(crate) struct CpuInfoField<'a>(Option<&'a str>);\n+\n+impl<'a> PartialEq<&'a str> for CpuInfoField<'a> {\n+    fn eq(&self, other: &&'a str) -> bool {\n+        match self.0 {\n+            None => other.is_empty(),\n+            Some(f) => f == other.trim(),\n+        }\n+    }\n+}\n+\n+impl<'a> CpuInfoField<'a> {\n+    pub(crate) fn new<'b>(v: Option<&'b str>) -> CpuInfoField<'b> {\n+        match v {\n+            None => CpuInfoField::<'b>(None),\n+            Some(f) => CpuInfoField::<'b>(Some(f.trim())),\n+        }\n+    }\n+    /// Does the field exist?\n+    #[cfg(test)]\n+    pub(crate) fn exists(&self) -> bool {\n+        self.0.is_some()\n+    }\n+    /// Does the field contain `other`?\n+    pub(crate) fn has(&self, other: &str) -> bool {\n+        match self.0 {\n+            None => other.is_empty(),\n+            Some(f) => {\n+                let other = other.trim();\n+                for v in f.split(' ') {\n+                    if v == other {\n+                        return true;\n+                    }\n+                }\n+                false\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn raw_dump() {\n+        let cpuinfo = CpuInfo::new().unwrap();\n+        if cpuinfo.field(\"vendor_id\") == \"GenuineIntel\" {\n+            assert!(cpuinfo.field(\"flags\").exists());\n+            assert!(!cpuinfo.field(\"vendor33_id\").exists());\n+            assert!(cpuinfo.field(\"flags\").has(\"sse\"));\n+            assert!(!cpuinfo.field(\"flags\").has(\"avx314\"));\n+        }\n+        println!(\"{}\", cpuinfo.raw());\n+    }\n+\n+    const CORE_DUO_T6500: &str = r\"processor       : 0\n+vendor_id       : GenuineIntel\n+cpu family      : 6\n+model           : 23\n+model name      : Intel(R) Core(TM)2 Duo CPU     T6500  @ 2.10GHz\n+stepping        : 10\n+microcode       : 0xa0b\n+cpu MHz         : 1600.000\n+cache size      : 2048 KB\n+physical id     : 0\n+siblings        : 2\n+core id         : 0\n+cpu cores       : 2\n+apicid          : 0\n+initial apicid  : 0\n+fdiv_bug        : no\n+hlt_bug         : no\n+f00f_bug        : no\n+coma_bug        : no\n+fpu             : yes\n+fpu_exception   : yes\n+cpuid level     : 13\n+wp              : yes\n+flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe nx lm constant_tsc arch_perfmon pebs bts aperfmperf pni dtes64 monitor ds_cpl est tm2 ssse3 cx16 xtpr pdcm sse4_1 xsave lahf_lm dtherm\n+bogomips        : 4190.43\n+clflush size    : 64\n+cache_alignment : 64\n+address sizes   : 36 bits physical, 48 bits virtual\n+power management:\n+\";\n+\n+    #[test]\n+    fn core_duo_t6500() {\n+        let cpuinfo = CpuInfo::from_str(CORE_DUO_T6500).unwrap();\n+        assert_eq!(cpuinfo.field(\"vendor_id\"), \"GenuineIntel\");\n+        assert_eq!(cpuinfo.field(\"cpu family\"), \"6\");\n+        assert_eq!(cpuinfo.field(\"model\"), \"23\");\n+        assert_eq!(\n+            cpuinfo.field(\"model name\"),\n+            \"Intel(R) Core(TM)2 Duo CPU     T6500  @ 2.10GHz\"\n+        );\n+        assert_eq!(\n+            cpuinfo.field(\"flags\"),\n+            \"fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe nx lm constant_tsc arch_perfmon pebs bts aperfmperf pni dtes64 monitor ds_cpl est tm2 ssse3 cx16 xtpr pdcm sse4_1 xsave lahf_lm dtherm\"\n+        );\n+        assert!(cpuinfo.field(\"flags\").has(\"fpu\"));\n+        assert!(cpuinfo.field(\"flags\").has(\"dtherm\"));\n+        assert!(cpuinfo.field(\"flags\").has(\"sse2\"));\n+        assert!(!cpuinfo.field(\"flags\").has(\"avx\"));\n+    }\n+\n+    const ARM_CORTEX_A53: &str = r\"Processor   : AArch64 Processor rev 3 (aarch64)\n+        processor   : 0\n+        processor   : 1\n+        processor   : 2\n+        processor   : 3\n+        processor   : 4\n+        processor   : 5\n+        processor   : 6\n+        processor   : 7\n+        Features    : fp asimd evtstrm aes pmull sha1 sha2 crc32\n+        CPU implementer : 0x41\n+        CPU architecture: AArch64\n+        CPU variant : 0x0\n+        CPU part    : 0xd03\n+        CPU revision    : 3\n+\n+        Hardware    : HiKey Development Board\n+        \";\n+\n+    #[test]\n+    fn arm_cortex_a53() {\n+        let cpuinfo = CpuInfo::from_str(ARM_CORTEX_A53).unwrap();\n+        assert_eq!(\n+            cpuinfo.field(\"Processor\"),\n+            \"AArch64 Processor rev 3 (aarch64)\"\n+        );\n+        assert_eq!(\n+            cpuinfo.field(\"Features\"),\n+            \"fp asimd evtstrm aes pmull sha1 sha2 crc32\"\n+        );\n+        assert!(cpuinfo.field(\"Features\").has(\"pmull\"));\n+        assert!(!cpuinfo.field(\"Features\").has(\"neon\"));\n+        assert!(cpuinfo.field(\"Features\").has(\"asimd\"));\n+    }\n+\n+    const ARM_CORTEX_A57: &str = r\"Processor\t: Cortex A57 Processor rev 1 (aarch64)\n+processor\t: 0\n+processor\t: 1\n+processor\t: 2\n+processor\t: 3\n+Features\t: fp asimd aes pmull sha1 sha2 crc32 wp half thumb fastmult vfp edsp neon vfpv3 tlsi vfpv4 idiva idivt\n+CPU implementer\t: 0x41\n+CPU architecture: 8\n+CPU variant\t: 0x1\n+CPU part\t: 0xd07\n+CPU revision\t: 1\";\n+\n+    #[test]\n+    fn arm_cortex_a57() {\n+        let cpuinfo = CpuInfo::from_str(ARM_CORTEX_A57).unwrap();\n+        assert_eq!(\n+            cpuinfo.field(\"Processor\"),\n+            \"Cortex A57 Processor rev 1 (aarch64)\"\n+        );\n+        assert_eq!(\n+            cpuinfo.field(\"Features\"),\n+            \"fp asimd aes pmull sha1 sha2 crc32 wp half thumb fastmult vfp edsp neon vfpv3 tlsi vfpv4 idiva idivt\"\n+        );\n+        assert!(cpuinfo.field(\"Features\").has(\"pmull\"));\n+        assert!(cpuinfo.field(\"Features\").has(\"neon\"));\n+        assert!(cpuinfo.field(\"Features\").has(\"asimd\"));\n+    }\n+\n+    const POWER8E_POWERKVM: &str = r\"processor       : 0\n+cpu             : POWER8E (raw), altivec supported\n+clock           : 3425.000000MHz\n+revision        : 2.1 (pvr 004b 0201)\n+\n+processor       : 1\n+cpu             : POWER8E (raw), altivec supported\n+clock           : 3425.000000MHz\n+revision        : 2.1 (pvr 004b 0201)\n+\n+processor       : 2\n+cpu             : POWER8E (raw), altivec supported\n+clock           : 3425.000000MHz\n+revision        : 2.1 (pvr 004b 0201)\n+\n+processor       : 3\n+cpu             : POWER8E (raw), altivec supported\n+clock           : 3425.000000MHz\n+revision        : 2.1 (pvr 004b 0201)\n+\n+timebase        : 512000000\n+platform        : pSeries\n+model           : IBM pSeries (emulated by qemu)\n+machine         : CHRP IBM pSeries (emulated by qemu)\";\n+\n+    #[test]\n+    fn power8_powerkvm() {\n+        let cpuinfo = CpuInfo::from_str(POWER8E_POWERKVM).unwrap();\n+        assert_eq!(cpuinfo.field(\"cpu\"), \"POWER8E (raw), altivec supported\");\n+\n+        assert!(cpuinfo.field(\"cpu\").has(\"altivec\"));\n+    }\n+\n+    const POWER5P: &str = r\"processor       : 0\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 1\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 2\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 3\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 4\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 5\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 6\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+processor       : 7\n+cpu             : POWER5+ (gs)\n+clock           : 1900.098000MHz\n+revision        : 2.1 (pvr 003b 0201)\n+\n+timebase        : 237331000\n+platform        : pSeries\n+machine         : CHRP IBM,9133-55A\";\n+\n+    #[test]\n+    fn power5p() {\n+        let cpuinfo = CpuInfo::from_str(POWER5P).unwrap();\n+        assert_eq!(cpuinfo.field(\"cpu\"), \"POWER5+ (gs)\");\n+\n+        assert!(!cpuinfo.field(\"cpu\").has(\"altivec\"));\n+    }\n+}"}, {"sha": "46a47fb7b78e98f4b20fa96aeffb9677694349f3", "filename": "tests/target/cfg_if/detect/os/linux/mips.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmips.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,31 @@\n+//! Run-time feature detection for MIPS on Linux.\n+\n+use super::auxvec;\n+use crate::detect::{bit, cache, Feature};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector, and if that fails, try\n+/// to read them from `/proc/cpuinfo`.\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    // The values are part of the platform-specific [asm/hwcap.h][hwcap]\n+    //\n+    // [hwcap]: https://github.com/torvalds/linux/blob/master/arch/arm64/include/uapi/asm/hwcap.h\n+    if let Ok(auxv) = auxvec::auxv() {\n+        enable_feature(&mut value, Feature::msa, bit::test(auxv.hwcap, 1));\n+        return value;\n+    }\n+    // TODO: fall back via `cpuinfo`.\n+    value\n+}"}, {"sha": "e02d5e6dcda7a54b15218032a4b1522e021139b4", "filename": "tests/target/cfg_if/detect/os/linux/mod.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fmod.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,28 @@\n+//! Run-time feature detection on Linux\n+\n+mod auxvec;\n+\n+#[cfg(feature = \"std_detect_file_io\")]\n+mod cpuinfo;\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"aarch64\")] {\n+        mod aarch64;\n+        pub use self::aarch64::check_for;\n+    } else if #[cfg(target_arch = \"arm\")] {\n+        mod arm;\n+        pub use self::arm::check_for;\n+    } else  if #[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))] {\n+        mod mips;\n+        pub use self::mips::check_for;\n+    } else if #[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))] {\n+        mod powerpc;\n+        pub use self::powerpc::check_for;\n+    } else {\n+        use crate::detect::Feature;\n+        /// Performs run-time feature detection.\n+        pub fn check_for(_x: Feature) -> bool {\n+            false\n+        }\n+    }\n+}"}, {"sha": "dc19bc8eda539d00efb6ef85cc0be417d697e8d1", "filename": "tests/target/cfg_if/detect/os/linux/powerpc.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Flinux%2Fpowerpc.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,41 @@\n+//! Run-time feature detection for PowerPC on Linux.\n+\n+use super::{auxvec, cpuinfo};\n+use crate::detect::{cache, Feature};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Try to read the features from the auxiliary vector, and if that fails, try\n+/// to read them from /proc/cpuinfo.\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+    let enable_feature = |value: &mut cache::Initializer, f, enable| {\n+        if enable {\n+            value.set(f as u32);\n+        }\n+    };\n+\n+    // The values are part of the platform-specific [asm/cputable.h][cputable]\n+    //\n+    // [cputable]: https://github.com/torvalds/linux/blob/master/arch/powerpc/include/uapi/asm/cputable.h\n+    if let Ok(auxv) = auxvec::auxv() {\n+        // note: the PowerPC values are the mask to do the test (instead of the\n+        // index of the bit to test like in ARM and Aarch64)\n+        enable_feature(&mut value, Feature::altivec, auxv.hwcap & 0x10000000 != 0);\n+        enable_feature(&mut value, Feature::vsx, auxv.hwcap & 0x00000080 != 0);\n+        enable_feature(&mut value, Feature::power8, auxv.hwcap2 & 0x80000000 != 0);\n+        return value;\n+    }\n+\n+    // PowerPC's /proc/cpuinfo lacks a proper Feature field,\n+    // but `altivec` support is indicated in the `cpu` field.\n+    if let Ok(c) = cpuinfo::CpuInfo::new() {\n+        enable_feature(&mut value, Feature::altivec, c.field(\"cpu\").has(\"altivec\"));\n+        return value;\n+    }\n+    value\n+}"}, {"sha": "23e399ea790740b0ed97f2a9ccd2bd2693af00c1", "filename": "tests/target/cfg_if/detect/os/other.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Fother.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Fother.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Fother.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,9 @@\n+//! Other operating systems\n+\n+use crate::detect::Feature;\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(_x: Feature) -> bool {\n+    false\n+}"}, {"sha": "2e228aa37452794be10d09611c9e12daa13852f1", "filename": "tests/target/cfg_if/detect/os/x86.rs", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fdetect%2Fos%2Fx86.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,367 @@\n+//! x86 run-time feature detection is OS independent.\n+\n+#[cfg(target_arch = \"x86\")]\n+use crate::arch::x86::*;\n+#[cfg(target_arch = \"x86_64\")]\n+use crate::arch::x86_64::*;\n+\n+use crate::mem;\n+\n+use crate::detect::{bit, cache, Feature};\n+\n+/// Performs run-time feature detection.\n+#[inline]\n+pub fn check_for(x: Feature) -> bool {\n+    cache::test(x as u32, detect_features)\n+}\n+\n+/// Run-time feature detection on x86 works by using the CPUID instruction.\n+///\n+/// The [CPUID Wikipedia page][wiki_cpuid] contains\n+/// all the information about which flags to set to query which values, and in\n+/// which registers these are reported.\n+///\n+/// The definitive references are:\n+/// - [Intel 64 and IA-32 Architectures Software Developer's Manual Volume 2:\n+///   Instruction Set Reference, A-Z][intel64_ref].\n+/// - [AMD64 Architecture Programmer's Manual, Volume 3: General-Purpose and\n+///   System Instructions][amd64_ref].\n+///\n+/// [wiki_cpuid]: https://en.wikipedia.org/wiki/CPUID\n+/// [intel64_ref]: http://www.intel.de/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf\n+/// [amd64_ref]: http://support.amd.com/TechDocs/24594.pdf\n+#[allow(clippy::similar_names)]\n+fn detect_features() -> cache::Initializer {\n+    let mut value = cache::Initializer::default();\n+\n+    // If the x86 CPU does not support the CPUID instruction then it is too\n+    // old to support any of the currently-detectable features.\n+    if !has_cpuid() {\n+        return value;\n+    }\n+\n+    // Calling `__cpuid`/`__cpuid_count` from here on is safe because the CPU\n+    // has `cpuid` support.\n+\n+    // 0. EAX = 0: Basic Information:\n+    // - EAX returns the \"Highest Function Parameter\", that is, the maximum\n+    // leaf value for subsequent calls of `cpuinfo` in range [0,\n+    // 0x8000_0000]. - The vendor ID is stored in 12 u8 ascii chars,\n+    // returned in EBX, EDX, and   ECX (in that order):\n+    let (max_basic_leaf, vendor_id) = unsafe {\n+        let CpuidResult {\n+            eax: max_basic_leaf,\n+            ebx,\n+            ecx,\n+            edx,\n+        } = __cpuid(0);\n+        let vendor_id: [[u8; 4]; 3] = [\n+            mem::transmute(ebx),\n+            mem::transmute(edx),\n+            mem::transmute(ecx),\n+        ];\n+        let vendor_id: [u8; 12] = mem::transmute(vendor_id);\n+        (max_basic_leaf, vendor_id)\n+    };\n+\n+    if max_basic_leaf < 1 {\n+        // Earlier Intel 486, CPUID not implemented\n+        return value;\n+    }\n+\n+    // EAX = 1, ECX = 0: Queries \"Processor Info and Feature Bits\";\n+    // Contains information about most x86 features.\n+    let CpuidResult {\n+        ecx: proc_info_ecx,\n+        edx: proc_info_edx,\n+        ..\n+    } = unsafe { __cpuid(0x0000_0001_u32) };\n+\n+    // EAX = 7, ECX = 0: Queries \"Extended Features\";\n+    // Contains information about bmi,bmi2, and avx2 support.\n+    let (extended_features_ebx, extended_features_ecx) = if max_basic_leaf >= 7 {\n+        let CpuidResult { ebx, ecx, .. } = unsafe { __cpuid(0x0000_0007_u32) };\n+        (ebx, ecx)\n+    } else {\n+        (0, 0) // CPUID does not support \"Extended Features\"\n+    };\n+\n+    // EAX = 0x8000_0000, ECX = 0: Get Highest Extended Function Supported\n+    // - EAX returns the max leaf value for extended information, that is,\n+    // `cpuid` calls in range [0x8000_0000; u32::MAX]:\n+    let CpuidResult {\n+        eax: extended_max_basic_leaf,\n+        ..\n+    } = unsafe { __cpuid(0x8000_0000_u32) };\n+\n+    // EAX = 0x8000_0001, ECX=0: Queries \"Extended Processor Info and Feature\n+    // Bits\"\n+    let extended_proc_info_ecx = if extended_max_basic_leaf >= 1 {\n+        let CpuidResult { ecx, .. } = unsafe { __cpuid(0x8000_0001_u32) };\n+        ecx\n+    } else {\n+        0\n+    };\n+\n+    {\n+        // borrows value till the end of this scope:\n+        let mut enable = |r, rb, f| {\n+            if bit::test(r as usize, rb) {\n+                value.set(f as u32);\n+            }\n+        };\n+\n+        enable(proc_info_ecx, 0, Feature::sse3);\n+        enable(proc_info_ecx, 1, Feature::pclmulqdq);\n+        enable(proc_info_ecx, 9, Feature::ssse3);\n+        enable(proc_info_ecx, 13, Feature::cmpxchg16b);\n+        enable(proc_info_ecx, 19, Feature::sse4_1);\n+        enable(proc_info_ecx, 20, Feature::sse4_2);\n+        enable(proc_info_ecx, 23, Feature::popcnt);\n+        enable(proc_info_ecx, 25, Feature::aes);\n+        enable(proc_info_ecx, 29, Feature::f16c);\n+        enable(proc_info_ecx, 30, Feature::rdrand);\n+        enable(extended_features_ebx, 18, Feature::rdseed);\n+        enable(extended_features_ebx, 19, Feature::adx);\n+        enable(extended_features_ebx, 11, Feature::rtm);\n+        enable(proc_info_edx, 4, Feature::tsc);\n+        enable(proc_info_edx, 23, Feature::mmx);\n+        enable(proc_info_edx, 24, Feature::fxsr);\n+        enable(proc_info_edx, 25, Feature::sse);\n+        enable(proc_info_edx, 26, Feature::sse2);\n+        enable(extended_features_ebx, 29, Feature::sha);\n+\n+        enable(extended_features_ebx, 3, Feature::bmi);\n+        enable(extended_features_ebx, 8, Feature::bmi2);\n+\n+        // `XSAVE` and `AVX` support:\n+        let cpu_xsave = bit::test(proc_info_ecx as usize, 26);\n+        if cpu_xsave {\n+            // 0. Here the CPU supports `XSAVE`.\n+\n+            // 1. Detect `OSXSAVE`, that is, whether the OS is AVX enabled and\n+            // supports saving the state of the AVX/AVX2 vector registers on\n+            // context-switches, see:\n+            //\n+            // - [intel: is avx enabled?][is_avx_enabled],\n+            // - [mozilla: sse.cpp][mozilla_sse_cpp].\n+            //\n+            // [is_avx_enabled]: https://software.intel.com/en-us/blogs/2011/04/14/is-avx-enabled\n+            // [mozilla_sse_cpp]: https://hg.mozilla.org/mozilla-central/file/64bab5cbb9b6/mozglue/build/SSE.cpp#l190\n+            let cpu_osxsave = bit::test(proc_info_ecx as usize, 27);\n+\n+            if cpu_osxsave {\n+                // 2. The OS must have signaled the CPU that it supports saving and\n+                // restoring the:\n+                //\n+                // * SSE -> `XCR0.SSE[1]`\n+                // * AVX -> `XCR0.AVX[2]`\n+                // * AVX-512 -> `XCR0.AVX-512[7:5]`.\n+                //\n+                // by setting the corresponding bits of `XCR0` to `1`.\n+                //\n+                // This is safe because the CPU supports `xsave`\n+                // and the OS has set `osxsave`.\n+                let xcr0 = unsafe { _xgetbv(0) };\n+                // Test `XCR0.SSE[1]` and `XCR0.AVX[2]` with the mask `0b110 == 6`:\n+                let os_avx_support = xcr0 & 6 == 6;\n+                // Test `XCR0.AVX-512[7:5]` with the mask `0b1110_0000 == 224`:\n+                let os_avx512_support = xcr0 & 224 == 224;\n+\n+                // Only if the OS and the CPU support saving/restoring the AVX\n+                // registers we enable `xsave` support:\n+                if os_avx_support {\n+                    // See \"13.3 ENABLING THE XSAVE FEATURE SET AND XSAVE-ENABLED\n+                    // FEATURES\" in the \"Intel\u00ae 64 and IA-32 Architectures Software\n+                    // Developer\u2019s Manual, Volume 1: Basic Architecture\":\n+                    //\n+                    // \"Software enables the XSAVE feature set by setting\n+                    // CR4.OSXSAVE[bit 18] to 1 (e.g., with the MOV to CR4\n+                    // instruction). If this bit is 0, execution of any of XGETBV,\n+                    // XRSTOR, XRSTORS, XSAVE, XSAVEC, XSAVEOPT, XSAVES, and XSETBV\n+                    // causes an invalid-opcode exception (#UD)\"\n+                    //\n+                    enable(proc_info_ecx, 26, Feature::xsave);\n+\n+                    // For `xsaveopt`, `xsavec`, and `xsaves` we need to query:\n+                    // Processor Extended State Enumeration Sub-leaf (EAX = 0DH,\n+                    // ECX = 1):\n+                    if max_basic_leaf >= 0xd {\n+                        let CpuidResult {\n+                            eax: proc_extended_state1_eax,\n+                            ..\n+                        } = unsafe { __cpuid_count(0xd_u32, 1) };\n+                        enable(proc_extended_state1_eax, 0, Feature::xsaveopt);\n+                        enable(proc_extended_state1_eax, 1, Feature::xsavec);\n+                        enable(proc_extended_state1_eax, 3, Feature::xsaves);\n+                    }\n+\n+                    // FMA (uses 256-bit wide registers):\n+                    enable(proc_info_ecx, 12, Feature::fma);\n+\n+                    // And AVX/AVX2:\n+                    enable(proc_info_ecx, 28, Feature::avx);\n+                    enable(extended_features_ebx, 5, Feature::avx2);\n+\n+                    // For AVX-512 the OS also needs to support saving/restoring\n+                    // the extended state, only then we enable AVX-512 support:\n+                    if os_avx512_support {\n+                        enable(extended_features_ebx, 16, Feature::avx512f);\n+                        enable(extended_features_ebx, 17, Feature::avx512dq);\n+                        enable(extended_features_ebx, 21, Feature::avx512_ifma);\n+                        enable(extended_features_ebx, 26, Feature::avx512pf);\n+                        enable(extended_features_ebx, 27, Feature::avx512er);\n+                        enable(extended_features_ebx, 28, Feature::avx512cd);\n+                        enable(extended_features_ebx, 30, Feature::avx512bw);\n+                        enable(extended_features_ebx, 31, Feature::avx512vl);\n+                        enable(extended_features_ecx, 1, Feature::avx512_vbmi);\n+                        enable(extended_features_ecx, 14, Feature::avx512_vpopcntdq);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // This detects ABM on AMD CPUs and LZCNT on Intel CPUs.\n+        // On intel CPUs with popcnt, lzcnt implements the\n+        // \"missing part\" of ABM, so we map both to the same\n+        // internal feature.\n+        //\n+        // The `is_x86_feature_detected!(\"lzcnt\")` macro then\n+        // internally maps to Feature::abm.\n+        enable(extended_proc_info_ecx, 5, Feature::abm);\n+        // As Hygon Dhyana originates from AMD technology and shares most of the architecture with\n+        // AMD's family 17h, but with different CPU Vendor ID(\"HygonGenuine\")/Family series\n+        // number(Family 18h).\n+        //\n+        // For CPUID feature bits, Hygon Dhyana(family 18h) share the same definition with AMD\n+        // family 17h.\n+        //\n+        // Related AMD CPUID specification is https://www.amd.com/system/files/TechDocs/25481.pdf.\n+        // Related Hygon kernel patch can be found on\n+        // http://lkml.kernel.org/r/5ce86123a7b9dad925ac583d88d2f921040e859b.1538583282.git.puwen@hygon.cn\n+        if vendor_id == *b\"AuthenticAMD\" || vendor_id == *b\"HygonGenuine\" {\n+            // These features are available on AMD arch CPUs:\n+            enable(extended_proc_info_ecx, 6, Feature::sse4a);\n+            enable(extended_proc_info_ecx, 21, Feature::tbm);\n+        }\n+    }\n+\n+    value\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    extern crate cupid;\n+\n+    #[test]\n+    fn dump() {\n+        println!(\"aes: {:?}\", is_x86_feature_detected!(\"aes\"));\n+        println!(\"pclmulqdq: {:?}\", is_x86_feature_detected!(\"pclmulqdq\"));\n+        println!(\"rdrand: {:?}\", is_x86_feature_detected!(\"rdrand\"));\n+        println!(\"rdseed: {:?}\", is_x86_feature_detected!(\"rdseed\"));\n+        println!(\"tsc: {:?}\", is_x86_feature_detected!(\"tsc\"));\n+        println!(\"sse: {:?}\", is_x86_feature_detected!(\"sse\"));\n+        println!(\"sse2: {:?}\", is_x86_feature_detected!(\"sse2\"));\n+        println!(\"sse3: {:?}\", is_x86_feature_detected!(\"sse3\"));\n+        println!(\"ssse3: {:?}\", is_x86_feature_detected!(\"ssse3\"));\n+        println!(\"sse4.1: {:?}\", is_x86_feature_detected!(\"sse4.1\"));\n+        println!(\"sse4.2: {:?}\", is_x86_feature_detected!(\"sse4.2\"));\n+        println!(\"sse4a: {:?}\", is_x86_feature_detected!(\"sse4a\"));\n+        println!(\"sha: {:?}\", is_x86_feature_detected!(\"sha\"));\n+        println!(\"avx: {:?}\", is_x86_feature_detected!(\"avx\"));\n+        println!(\"avx2: {:?}\", is_x86_feature_detected!(\"avx2\"));\n+        println!(\"avx512f {:?}\", is_x86_feature_detected!(\"avx512f\"));\n+        println!(\"avx512cd {:?}\", is_x86_feature_detected!(\"avx512cd\"));\n+        println!(\"avx512er {:?}\", is_x86_feature_detected!(\"avx512er\"));\n+        println!(\"avx512pf {:?}\", is_x86_feature_detected!(\"avx512pf\"));\n+        println!(\"avx512bw {:?}\", is_x86_feature_detected!(\"avx512bw\"));\n+        println!(\"avx512dq {:?}\", is_x86_feature_detected!(\"avx512dq\"));\n+        println!(\"avx512vl {:?}\", is_x86_feature_detected!(\"avx512vl\"));\n+        println!(\"avx512_ifma {:?}\", is_x86_feature_detected!(\"avx512ifma\"));\n+        println!(\"avx512_vbmi {:?}\", is_x86_feature_detected!(\"avx512vbmi\"));\n+        println!(\n+            \"avx512_vpopcntdq {:?}\",\n+            is_x86_feature_detected!(\"avx512vpopcntdq\")\n+        );\n+        println!(\"fma: {:?}\", is_x86_feature_detected!(\"fma\"));\n+        println!(\"abm: {:?}\", is_x86_feature_detected!(\"abm\"));\n+        println!(\"bmi: {:?}\", is_x86_feature_detected!(\"bmi1\"));\n+        println!(\"bmi2: {:?}\", is_x86_feature_detected!(\"bmi2\"));\n+        println!(\"tbm: {:?}\", is_x86_feature_detected!(\"tbm\"));\n+        println!(\"popcnt: {:?}\", is_x86_feature_detected!(\"popcnt\"));\n+        println!(\"lzcnt: {:?}\", is_x86_feature_detected!(\"lzcnt\"));\n+        println!(\"fxsr: {:?}\", is_x86_feature_detected!(\"fxsr\"));\n+        println!(\"xsave: {:?}\", is_x86_feature_detected!(\"xsave\"));\n+        println!(\"xsaveopt: {:?}\", is_x86_feature_detected!(\"xsaveopt\"));\n+        println!(\"xsaves: {:?}\", is_x86_feature_detected!(\"xsaves\"));\n+        println!(\"xsavec: {:?}\", is_x86_feature_detected!(\"xsavec\"));\n+        println!(\"cmpxchg16b: {:?}\", is_x86_feature_detected!(\"cmpxchg16b\"));\n+        println!(\"adx: {:?}\", is_x86_feature_detected!(\"adx\"));\n+        println!(\"rtm: {:?}\", is_x86_feature_detected!(\"rtm\"));\n+    }\n+\n+    #[test]\n+    fn compare_with_cupid() {\n+        let information = cupid::master().unwrap();\n+        assert_eq!(is_x86_feature_detected!(\"aes\"), information.aesni());\n+        assert_eq!(\n+            is_x86_feature_detected!(\"pclmulqdq\"),\n+            information.pclmulqdq()\n+        );\n+        assert_eq!(is_x86_feature_detected!(\"rdrand\"), information.rdrand());\n+        assert_eq!(is_x86_feature_detected!(\"rdseed\"), information.rdseed());\n+        assert_eq!(is_x86_feature_detected!(\"tsc\"), information.tsc());\n+        assert_eq!(is_x86_feature_detected!(\"sse\"), information.sse());\n+        assert_eq!(is_x86_feature_detected!(\"sse2\"), information.sse2());\n+        assert_eq!(is_x86_feature_detected!(\"sse3\"), information.sse3());\n+        assert_eq!(is_x86_feature_detected!(\"ssse3\"), information.ssse3());\n+        assert_eq!(is_x86_feature_detected!(\"sse4.1\"), information.sse4_1());\n+        assert_eq!(is_x86_feature_detected!(\"sse4.2\"), information.sse4_2());\n+        assert_eq!(is_x86_feature_detected!(\"sse4a\"), information.sse4a());\n+        assert_eq!(is_x86_feature_detected!(\"sha\"), information.sha());\n+        assert_eq!(is_x86_feature_detected!(\"avx\"), information.avx());\n+        assert_eq!(is_x86_feature_detected!(\"avx2\"), information.avx2());\n+        assert_eq!(is_x86_feature_detected!(\"avx512f\"), information.avx512f());\n+        assert_eq!(is_x86_feature_detected!(\"avx512cd\"), information.avx512cd());\n+        assert_eq!(is_x86_feature_detected!(\"avx512er\"), information.avx512er());\n+        assert_eq!(is_x86_feature_detected!(\"avx512pf\"), information.avx512pf());\n+        assert_eq!(is_x86_feature_detected!(\"avx512bw\"), information.avx512bw());\n+        assert_eq!(is_x86_feature_detected!(\"avx512dq\"), information.avx512dq());\n+        assert_eq!(is_x86_feature_detected!(\"avx512vl\"), information.avx512vl());\n+        assert_eq!(\n+            is_x86_feature_detected!(\"avx512ifma\"),\n+            information.avx512_ifma()\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"avx512vbmi\"),\n+            information.avx512_vbmi()\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"avx512vpopcntdq\"),\n+            information.avx512_vpopcntdq()\n+        );\n+        assert_eq!(is_x86_feature_detected!(\"fma\"), information.fma());\n+        assert_eq!(is_x86_feature_detected!(\"bmi1\"), information.bmi1());\n+        assert_eq!(is_x86_feature_detected!(\"bmi2\"), information.bmi2());\n+        assert_eq!(is_x86_feature_detected!(\"popcnt\"), information.popcnt());\n+        assert_eq!(is_x86_feature_detected!(\"abm\"), information.lzcnt());\n+        assert_eq!(is_x86_feature_detected!(\"tbm\"), information.tbm());\n+        assert_eq!(is_x86_feature_detected!(\"lzcnt\"), information.lzcnt());\n+        assert_eq!(is_x86_feature_detected!(\"xsave\"), information.xsave());\n+        assert_eq!(is_x86_feature_detected!(\"xsaveopt\"), information.xsaveopt());\n+        assert_eq!(\n+            is_x86_feature_detected!(\"xsavec\"),\n+            information.xsavec_and_xrstor()\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"xsaves\"),\n+            information.xsaves_xrstors_and_ia32_xss()\n+        );\n+        assert_eq!(\n+            is_x86_feature_detected!(\"cmpxchg16b\"),\n+            information.cmpxchg16b(),\n+        );\n+        assert_eq!(is_x86_feature_detected!(\"adx\"), information.adx(),);\n+        assert_eq!(is_x86_feature_detected!(\"rtm\"), information.rtm(),);\n+    }\n+}"}, {"sha": "8b3bb304f1c83d3436dd1c325a952f8dbb86c4e2", "filename": "tests/target/cfg_if/lib.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Flib.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,49 @@\n+//! Run-time feature detection for the Rust standard library.\n+//!\n+//! To detect whether a feature is enabled in the system running the binary\n+//! use one of the appropriate macro for the target:\n+//!\n+//! * `x86` and `x86_64`: [`is_x86_feature_detected`]\n+//! * `arm`: [`is_arm_feature_detected`]\n+//! * `aarch64`: [`is_aarch64_feature_detected`]\n+//! * `mips`: [`is_mips_feature_detected`]\n+//! * `mips64`: [`is_mips64_feature_detected`]\n+//! * `powerpc`: [`is_powerpc_feature_detected`]\n+//! * `powerpc64`: [`is_powerpc64_feature_detected`]\n+\n+#![unstable(feature = \"stdsimd\", issue = \"27731\")]\n+#![feature(const_fn, staged_api, stdsimd, doc_cfg, allow_internal_unstable)]\n+#![allow(clippy::shadow_reuse)]\n+#![deny(clippy::missing_inline_in_public_items)]\n+#![cfg_attr(target_os = \"linux\", feature(linkage))]\n+#![cfg_attr(all(target_os = \"freebsd\", target_arch = \"aarch64\"), feature(asm))]\n+#![cfg_attr(stdsimd_strict, deny(warnings))]\n+#![cfg_attr(test, allow(unused_imports))]\n+#![no_std]\n+\n+#[macro_use]\n+extern crate cfg_if;\n+\n+cfg_if! {\n+    if #[cfg(feature = \"std_detect_file_io\")] {\n+        #[cfg_attr(test, macro_use(println))]\n+        extern crate std;\n+\n+        #[allow(unused_imports)]\n+        use std::{arch, fs, io, mem, sync};\n+    } else {\n+        #[cfg(test)]\n+        #[macro_use(println)]\n+        extern crate std;\n+\n+        #[allow(unused_imports)]\n+        use core::{arch, mem, sync};\n+    }\n+}\n+\n+#[cfg(feature = \"std_detect_dlsym_getauxval\")]\n+extern crate libc;\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+pub mod detect;"}, {"sha": "b630e7ff383aa9867c447b86b2f7b0a5fb251613", "filename": "tests/target/cfg_if/mod.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e71bffb0080e53a11078e6279f0bb1e470c452e0/tests%2Ftarget%2Fcfg_if%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcfg_if%2Fmod.rs?ref=e71bffb0080e53a11078e6279f0bb1e470c452e0", "patch": "@@ -0,0 +1,5 @@\n+//! `std_detect`\n+\n+#[doc(hidden)] // unstable implementation detail\n+#[unstable(feature = \"stdsimd\", issue = \"27731\")]\n+pub mod detect;"}]}