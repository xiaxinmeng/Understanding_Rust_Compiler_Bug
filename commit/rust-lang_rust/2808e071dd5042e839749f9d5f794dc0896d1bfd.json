{"sha": "2808e071dd5042e839749f9d5f794dc0896d1bfd", "node_id": "C_kwDOAAsO6NoAKDI4MDhlMDcxZGQ1MDQyZTgzOTc0OWY5ZDVmNzk0ZGMwODk2ZDFiZmQ", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-08-08T13:41:32Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-08-08T13:41:32Z"}, "message": "Simplify format_args builtin macro implementation.\n\nInstead of a FxHashMap<Symbol, (usize, Span)> for the named arguments,\nthis now includes the name and span in the elements of the\nVec<FormatArg> directly. The FxHashMap still exists to look up the\nindex, but no longer contains the span. Looking up the name or span of\nan argument is now trivial and does not need the map anymore.", "tree": {"sha": "63ec3754437751990b4c6e2f103432a3f394ebbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63ec3754437751990b4c6e2f103432a3f394ebbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2808e071dd5042e839749f9d5f794dc0896d1bfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2808e071dd5042e839749f9d5f794dc0896d1bfd", "html_url": "https://github.com/rust-lang/rust/commit/2808e071dd5042e839749f9d5f794dc0896d1bfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2808e071dd5042e839749f9d5f794dc0896d1bfd/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bbbf60b0442f1d56fc39f30274be77acc79164c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bbbf60b0442f1d56fc39f30274be77acc79164c", "html_url": "https://github.com/rust-lang/rust/commit/9bbbf60b0442f1d56fc39f30274be77acc79164c"}], "stats": {"total": 150, "additions": 64, "deletions": 86}, "files": [{"sha": "d96f24c7bc7152e0f8522b157f0527e1aacef100", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 64, "deletions": 86, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/2808e071dd5042e839749f9d5f794dc0896d1bfd/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2808e071dd5042e839749f9d5f794dc0896d1bfd/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=2808e071dd5042e839749f9d5f794dc0896d1bfd", "patch": "@@ -130,64 +130,46 @@ impl PositionalNamedArgsLint {\n     /// CountIsParam, which contains an index into the arguments.\n     fn maybe_add_positional_named_arg(\n         &mut self,\n-        current_positional_arg: usize,\n-        total_args_length: usize,\n-        format_argument_index: usize,\n+        arg: Option<&FormatArg>,\n         ty: PositionalNamedArgType,\n         cur_piece: usize,\n         inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-        names: &FxHashMap<Symbol, (usize, Span)>,\n         has_formatting: bool,\n     ) {\n-        let start_of_named_args = total_args_length - names.len();\n-        if current_positional_arg >= start_of_named_args {\n-            self.maybe_push(\n-                format_argument_index,\n-                ty,\n-                cur_piece,\n-                inner_span_to_replace,\n-                names,\n-                has_formatting,\n-            )\n+        if let Some(arg) = arg {\n+            if let Some(name) = arg.name {\n+                self.push(name, ty, cur_piece, inner_span_to_replace, has_formatting)\n+            }\n         }\n     }\n \n-    /// Try constructing a PositionalNamedArg struct and pushing it into the vec of positional\n-    /// named arguments. If a named arg associated with `format_argument_index` cannot be found,\n-    /// a new item will not be added as the lint cannot be emitted in this case.\n-    fn maybe_push(\n+    /// Construct a PositionalNamedArg struct and push it into the vec of positional\n+    /// named arguments.\n+    fn push(\n         &mut self,\n-        format_argument_index: usize,\n+        arg_name: Ident,\n         ty: PositionalNamedArgType,\n         cur_piece: usize,\n         inner_span_to_replace: Option<rustc_parse_format::InnerSpan>,\n-        names: &FxHashMap<Symbol, (usize, Span)>,\n         has_formatting: bool,\n     ) {\n-        let named_arg = names\n-            .iter()\n-            .find(|&(_, &(index, _))| index == format_argument_index)\n-            .map(|found| found.clone());\n-\n-        if let Some((&replacement, &(_, positional_named_arg_span))) = named_arg {\n-            // In FormatSpec, `precision_span` starts at the leading `.`, which we want to keep in\n-            // the lint suggestion, so increment `start` by 1 when `PositionalArgumentType` is\n-            // `Precision`.\n-            let inner_span_to_replace = if ty == PositionalNamedArgType::Precision {\n-                inner_span_to_replace\n-                    .map(|is| rustc_parse_format::InnerSpan { start: is.start + 1, end: is.end })\n-            } else {\n-                inner_span_to_replace\n-            };\n-            self.positional_named_args.push(PositionalNamedArg {\n-                ty,\n-                cur_piece,\n-                inner_span_to_replace,\n-                replacement,\n-                positional_named_arg_span,\n-                has_formatting,\n-            });\n-        }\n+        // In FormatSpec, `precision_span` starts at the leading `.`, which we want to keep in\n+        // the lint suggestion, so increment `start` by 1 when `PositionalArgumentType` is\n+        // `Precision`.\n+        let inner_span_to_replace = if ty == PositionalNamedArgType::Precision {\n+            inner_span_to_replace\n+                .map(|is| rustc_parse_format::InnerSpan { start: is.start + 1, end: is.end })\n+        } else {\n+            inner_span_to_replace\n+        };\n+        self.positional_named_args.push(PositionalNamedArg {\n+            ty,\n+            cur_piece,\n+            inner_span_to_replace,\n+            replacement: arg_name.name,\n+            positional_named_arg_span: arg_name.span,\n+            has_formatting,\n+        });\n     }\n }\n \n@@ -211,15 +193,15 @@ struct Context<'a, 'b> {\n     /// * `arg_types` (in JSON): `[[0, 1, 0], [0, 1, 1], [0, 1]]`\n     /// * `arg_unique_types` (in simplified JSON): `[[\"o\", \"x\"], [\"o\", \"x\"], [\"o\", \"x\"]]`\n     /// * `names` (in JSON): `{\"foo\": 2}`\n-    args: Vec<P<ast::Expr>>,\n+    args: Vec<FormatArg>,\n     /// The number of arguments that were added by implicit capturing.\n     num_captured_args: usize,\n     /// Placeholder slot numbers indexed by argument.\n     arg_types: Vec<Vec<usize>>,\n     /// Unique format specs seen for each argument.\n     arg_unique_types: Vec<Vec<ArgumentType>>,\n     /// Map from named arguments to their resolved indices.\n-    names: FxHashMap<Symbol, (usize, Span)>,\n+    names: FxHashMap<Symbol, usize>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -282,7 +264,7 @@ struct Context<'a, 'b> {\n \n pub struct FormatArg {\n     expr: P<ast::Expr>,\n-    named: bool,\n+    name: Option<Ident>,\n }\n \n /// Parses the arguments from the given list of tokens, returning the diagnostic\n@@ -298,9 +280,9 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: TokenStream,\n-) -> PResult<'a, (P<ast::Expr>, Vec<FormatArg>, FxHashMap<Symbol, (usize, Span)>)> {\n+) -> PResult<'a, (P<ast::Expr>, Vec<FormatArg>, FxHashMap<Symbol, usize>)> {\n     let mut args = Vec::<FormatArg>::new();\n-    let mut names = FxHashMap::<Symbol, (usize, Span)>::default();\n+    let mut names = FxHashMap::<Symbol, usize>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -365,9 +347,9 @@ fn parse_args<'a>(\n                 p.bump();\n                 p.expect(&token::Eq)?;\n                 let e = p.parse_expr()?;\n-                if let Some((prev, _)) = names.get(&ident.name) {\n+                if let Some(&prev) = names.get(&ident.name) {\n                     ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", ident))\n-                        .span_label(args[*prev].expr.span, \"previously here\")\n+                        .span_label(args[prev].expr.span, \"previously here\")\n                         .span_label(e.span, \"duplicate argument\")\n                         .emit();\n                     continue;\n@@ -378,8 +360,8 @@ fn parse_args<'a>(\n                 // if the input is valid, we can simply append to the positional\n                 // args. And remember the names.\n                 let slot = args.len();\n-                names.insert(ident.name, (slot, ident.span));\n-                args.push(FormatArg { expr: e, named: true });\n+                names.insert(ident.name, slot);\n+                args.push(FormatArg { expr: e, name: Some(ident) });\n             }\n             _ => {\n                 let e = p.parse_expr()?;\n@@ -389,12 +371,12 @@ fn parse_args<'a>(\n                         \"positional arguments cannot follow named arguments\",\n                     );\n                     err.span_label(e.span, \"positional arguments must be before named arguments\");\n-                    for pos in names.values() {\n-                        err.span_label(args[pos.0].expr.span, \"named argument\");\n+                    for &pos in names.values() {\n+                        err.span_label(args[pos].expr.span, \"named argument\");\n                     }\n                     err.emit();\n                 }\n-                args.push(FormatArg { expr: e, named: false });\n+                args.push(FormatArg { expr: e, name: None });\n             }\n         }\n     }\n@@ -410,8 +392,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn resolve_name_inplace(&mut self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup =\n-            |s: &str| self.names.get(&Symbol::intern(s)).unwrap_or(&(0, Span::default())).0;\n+        let lookup = |s: &str| self.names.get(&Symbol::intern(s)).copied().unwrap_or(0);\n \n         match *p {\n             parse::String(_) => {}\n@@ -457,27 +438,21 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let pos = match arg.position {\n                     parse::ArgumentIs(i) => {\n                         self.unused_names_lint.maybe_add_positional_named_arg(\n-                            i,\n-                            self.args.len(),\n-                            i,\n+                            self.args.get(i),\n                             PositionalNamedArgType::Arg,\n                             self.curpiece,\n                             Some(arg.position_span),\n-                            &self.names,\n                             has_precision || has_width,\n                         );\n \n                         Exact(i)\n                     }\n                     parse::ArgumentImplicitlyIs(i) => {\n                         self.unused_names_lint.maybe_add_positional_named_arg(\n-                            i,\n-                            self.args.len(),\n-                            i,\n+                            self.args.get(i),\n                             PositionalNamedArgType::Arg,\n                             self.curpiece,\n                             None,\n-                            &self.names,\n                             has_precision || has_width,\n                         );\n                         Exact(i)\n@@ -563,13 +538,10 @@ impl<'a, 'b> Context<'a, 'b> {\n             parse::CountImplied | parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n                 self.unused_names_lint.maybe_add_positional_named_arg(\n-                    i,\n-                    self.args.len(),\n-                    i,\n+                    self.args.get(i),\n                     named_arg_type,\n                     self.curpiece,\n                     *inner_span,\n-                    &self.names,\n                     true,\n                 );\n                 self.verify_arg_type(Exact(i), Count);\n@@ -622,7 +594,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             );\n             for arg in &self.args {\n                 // Point at the arguments that will be formatted.\n-                e.span_label(arg.span, \"\");\n+                e.span_label(arg.expr.span, \"\");\n             }\n         } else {\n             let (mut refs, spans): (Vec<_>, Vec<_>) = refs.unzip();\n@@ -692,7 +664,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                         );\n                         if let Some(arg) = self.args.get(pos) {\n                             e.span_label(\n-                                arg.span,\n+                                arg.expr.span,\n                                 \"this parameter corresponds to the precision flag\",\n                             );\n                         }\n@@ -771,7 +743,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 match self.names.get(&name) {\n                     Some(&idx) => {\n                         // Treat as positional arg.\n-                        self.verify_arg_type(Capture(idx.0), ty)\n+                        self.verify_arg_type(Capture(idx), ty)\n                     }\n                     None => {\n                         // For the moment capturing variables from format strings expanded from macros is\n@@ -787,8 +759,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                                 self.fmtsp\n                             };\n                             self.num_captured_args += 1;\n-                            self.args.push(self.ecx.expr_ident(span, Ident::new(name, span)));\n-                            self.names.insert(name, (idx, span));\n+                            self.args.push(FormatArg {\n+                                expr: self.ecx.expr_ident(span, Ident::new(name, span)),\n+                                name: Some(Ident::new(name, span)),\n+                            });\n+                            self.names.insert(name, idx);\n                             self.verify_arg_type(Capture(idx), ty)\n                         } else {\n                             let msg = format!(\"there is no argument named `{}`\", name);\n@@ -1054,11 +1029,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         // evaluated a single time each, in the order written by the programmer,\n         // and that the surrounding future/generator (if any) is Send whenever\n         // possible.\n-        let no_need_for_match =\n-            nicely_ordered && !original_args.iter().skip(1).any(|e| may_contain_yield_point(e));\n+        let no_need_for_match = nicely_ordered\n+            && !original_args.iter().skip(1).any(|arg| may_contain_yield_point(&arg.expr));\n \n         for (arg_index, arg_ty) in fmt_arg_index_and_ty {\n-            let e = &mut original_args[arg_index];\n+            let e = &mut original_args[arg_index].expr;\n             let span = e.span;\n             let arg = if no_need_for_match {\n                 let expansion_span = e.span.with_ctxt(self.macsp.ctxt());\n@@ -1087,7 +1062,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // span is otherwise unavailable in the MIR used by borrowck).\n                 let heads = original_args\n                     .into_iter()\n-                    .map(|e| self.ecx.expr_addr_of(e.span.with_ctxt(self.macsp.ctxt()), e))\n+                    .map(|arg| {\n+                        self.ecx.expr_addr_of(arg.expr.span.with_ctxt(self.macsp.ctxt()), arg.expr)\n+                    })\n                     .collect();\n \n                 let pat = self.ecx.pat_ident(self.macsp, Ident::new(sym::args, self.macsp));\n@@ -1220,7 +1197,7 @@ pub fn expand_preparsed_format_args(\n     sp: Span,\n     efmt: P<ast::Expr>,\n     args: Vec<FormatArg>,\n-    names: FxHashMap<Symbol, (usize, Span)>,\n+    names: FxHashMap<Symbol, usize>,\n     append_newline: bool,\n ) -> P<ast::Expr> {\n     // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because\n@@ -1312,16 +1289,17 @@ pub fn expand_preparsed_format_args(\n         if err.should_be_replaced_with_positional_argument {\n             let captured_arg_span =\n                 fmt_span.from_inner(InnerSpan::new(err.span.start, err.span.end));\n-            let positional_args = args.iter().filter(|arg| !arg.named).collect::<Vec<_>>();\n+            let n_positional_args =\n+                args.iter().rposition(|arg| arg.name.is_none()).map_or(0, |i| i + 1);\n             if let Ok(arg) = ecx.source_map().span_to_snippet(captured_arg_span) {\n-                let span = match positional_args.last() {\n+                let span = match args[..n_positional_args].last() {\n                     Some(arg) => arg.expr.span,\n                     None => fmt_sp,\n                 };\n                 e.multipart_suggestion_verbose(\n                     \"consider using a positional formatting argument instead\",\n                     vec![\n-                        (captured_arg_span, positional_args.len().to_string()),\n+                        (captured_arg_span, n_positional_args.to_string()),\n                         (span.shrink_to_hi(), format!(\", {}\", arg)),\n                     ],\n                     Applicability::MachineApplicable,\n@@ -1338,11 +1316,11 @@ pub fn expand_preparsed_format_args(\n         .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n         .collect();\n \n-    let named_pos: FxHashSet<usize> = names.values().cloned().map(|(i, _)| i).collect();\n+    let named_pos: FxHashSet<usize> = names.values().cloned().collect();\n \n     let mut cx = Context {\n         ecx,\n-        args: args.into_iter().map(|arg| arg.expr).collect(),\n+        args,\n         num_captured_args: 0,\n         arg_types,\n         arg_unique_types,\n@@ -1417,7 +1395,7 @@ pub fn expand_preparsed_format_args(\n                 // positional argument\n                 \"argument never used\"\n             };\n-            (cx.args[i].span, msg)\n+            (cx.args[i].expr.span, msg)\n         })\n         .collect::<Vec<_>>();\n "}]}