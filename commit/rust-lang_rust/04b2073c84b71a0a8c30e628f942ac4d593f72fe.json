{"sha": "04b2073c84b71a0a8c30e628f942ac4d593f72fe", "node_id": "C_kwDOAAsO6NoAKDA0YjIwNzNjODRiNzFhMGE4YzMwZTYyOGY5NDJhYzRkNTkzZjcyZmU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-18T03:42:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-18T03:42:06Z"}, "message": "Rollup merge of #92923 - dtolnay:ringbuffer, r=petrochenkov\n\nAbstract the pretty printer's ringbuffer to be infinitely sized\n\nThis PR backports https://github.com/dtolnay/prettyplease/commit/8e5e83c3ff7faaa272115a81b76f07a1d4a91969 from the `prettyplease` crate into `rustc_ast_pretty`.\n\nUsing a dedicated RingBuffer type with non-wrapping indices, instead of manually `%`-ing indices into a capped sized buffer, unlocks a number of simplifications to the pretty printing algorithm implementation in followup commits such as https://github.com/dtolnay/prettyplease/commit/fcb5968b1e1357497c7d7e205d22bb4e8c1dbd38 and https://github.com/dtolnay/prettyplease/commit/4427cedcb80294e89b823f923fdb16544c737bd9.\n\nThis change also greatly reduces memory overhead of the pretty printer. The old implementation always grows its buffer to 205920 bytes even for files without deeply nested code, because it only wraps its indices when they hit the maximum tolerable size of the ring buffer (the size after which the pretty printer will crash if there are that many tokens buffered). In contrast, the new implementation uses memory proportional to the peak number of simultaneously buffered tokens only, not the number of tokens that have ever been in the buffer.\n\nSpeaking of crashing the pretty printer and \"maximum tolerable size\", the constant used for that in the old implementation is a lie:\n\nhttps://github.com/rust-lang/rust/blob/de9b573eedaaa6d6e7c00c986cccbee802f9287b/compiler/rustc_ast_pretty/src/pp.rs#L227-L228\n\nIt was raised from 3 to 55 in https://github.com/rust-lang/rust/pull/33934 because that was empirically the size that avoided crashing on one particular test crate, but according to https://github.com/rust-lang/rust/pull/33934#issuecomment-226700470 other syntax trees still crash at that size. There is no reason to believe that any particular size is good enough for arbitrary code, and using a large number like 55 adds overhead to inputs that never need close to that much of a buffer. The new implementation eliminates this tradeoff.", "tree": {"sha": "69c7babc48f7f47756b94fcaf99549c4519ef065", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69c7babc48f7f47756b94fcaf99549c4519ef065"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04b2073c84b71a0a8c30e628f942ac4d593f72fe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh5jcOCRBK7hj4Ov3rIwAAbhUIAJvP6RfnmbwZFJ6EaW3L5sAm\nDezuRrHaO9iDySbI4Si00vWxK/8f+6/quwyMXquf59xXoXsPddh27Xm+BhOjjmBE\nMgHAnWNz1tV5URNLb2O49FTzBnu7GwhF336mM6zyXCUamGZX1xpn4x2okvoRabpE\notXKmpBPiQMAeVjQAMYjW6P6CyQAQGWJ7mNsoZSgQ9JsKFh3E+j/9YD125SkTXdm\njd2TcznDlwDUIXUZx9Ia9G5pD544v40TtwpUyuD5Ed/0BHO/qscLPrYSMcfawFwo\n4Zr3G0fa7Tg4T27KAjJgLHd1zOgjkf4SCbTnDLSH7IoHUk+pf5v/FasiFumGd/M=\n=3i+K\n-----END PGP SIGNATURE-----\n", "payload": "tree 69c7babc48f7f47756b94fcaf99549c4519ef065\nparent be3d25bd7800b67bb7675a3d74445de305fcff3d\nparent 7b5b3cf82cd406e0fa2e95c2c3e762d85decb40d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642477326 +0100\ncommitter GitHub <noreply@github.com> 1642477326 +0100\n\nRollup merge of #92923 - dtolnay:ringbuffer, r=petrochenkov\n\nAbstract the pretty printer's ringbuffer to be infinitely sized\n\nThis PR backports https://github.com/dtolnay/prettyplease/commit/8e5e83c3ff7faaa272115a81b76f07a1d4a91969 from the `prettyplease` crate into `rustc_ast_pretty`.\n\nUsing a dedicated RingBuffer type with non-wrapping indices, instead of manually `%`-ing indices into a capped sized buffer, unlocks a number of simplifications to the pretty printing algorithm implementation in followup commits such as https://github.com/dtolnay/prettyplease/commit/fcb5968b1e1357497c7d7e205d22bb4e8c1dbd38 and https://github.com/dtolnay/prettyplease/commit/4427cedcb80294e89b823f923fdb16544c737bd9.\n\nThis change also greatly reduces memory overhead of the pretty printer. The old implementation always grows its buffer to 205920 bytes even for files without deeply nested code, because it only wraps its indices when they hit the maximum tolerable size of the ring buffer (the size after which the pretty printer will crash if there are that many tokens buffered). In contrast, the new implementation uses memory proportional to the peak number of simultaneously buffered tokens only, not the number of tokens that have ever been in the buffer.\n\nSpeaking of crashing the pretty printer and \"maximum tolerable size\", the constant used for that in the old implementation is a lie:\n\nhttps://github.com/rust-lang/rust/blob/de9b573eedaaa6d6e7c00c986cccbee802f9287b/compiler/rustc_ast_pretty/src/pp.rs#L227-L228\n\nIt was raised from 3 to 55 in https://github.com/rust-lang/rust/pull/33934 because that was empirically the size that avoided crashing on one particular test crate, but according to https://github.com/rust-lang/rust/pull/33934#issuecomment-226700470 other syntax trees still crash at that size. There is no reason to believe that any particular size is good enough for arbitrary code, and using a large number like 55 adds overhead to inputs that never need close to that much of a buffer. The new implementation eliminates this tradeoff.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04b2073c84b71a0a8c30e628f942ac4d593f72fe", "html_url": "https://github.com/rust-lang/rust/commit/04b2073c84b71a0a8c30e628f942ac4d593f72fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04b2073c84b71a0a8c30e628f942ac4d593f72fe/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be3d25bd7800b67bb7675a3d74445de305fcff3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/be3d25bd7800b67bb7675a3d74445de305fcff3d", "html_url": "https://github.com/rust-lang/rust/commit/be3d25bd7800b67bb7675a3d74445de305fcff3d"}, {"sha": "7b5b3cf82cd406e0fa2e95c2c3e762d85decb40d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b5b3cf82cd406e0fa2e95c2c3e762d85decb40d", "html_url": "https://github.com/rust-lang/rust/commit/7b5b3cf82cd406e0fa2e95c2c3e762d85decb40d"}], "stats": {"total": 89, "additions": 67, "deletions": 22}, "files": [{"sha": "ad9d15f1ce345811735a8c6944b5bf0121db95cd", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/04b2073c84b71a0a8c30e628f942ac4d593f72fe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b2073c84b71a0a8c30e628f942ac4d593f72fe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=04b2073c84b71a0a8c30e628f942ac4d593f72fe", "patch": "@@ -132,6 +132,9 @@\n //! methods called `Printer::scan_*`, and the 'PRINT' process is the\n //! method called `Printer::print`.\n \n+mod ring;\n+\n+use ring::RingBuffer;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n use std::fmt;\n@@ -190,8 +193,7 @@ impl fmt::Display for Token {\n     }\n }\n \n-fn buf_str(buf: &[BufEntry], left: usize, right: usize, lim: usize) -> String {\n-    let n = buf.len();\n+fn buf_str(buf: &RingBuffer<BufEntry>, left: usize, right: usize, lim: usize) -> String {\n     let mut i = left;\n     let mut l = lim;\n     let mut s = String::from(\"[\");\n@@ -202,7 +204,6 @@ fn buf_str(buf: &[BufEntry], left: usize, right: usize, lim: usize) -> String {\n         }\n         s.push_str(&format!(\"{}={}\", buf[i].size, &buf[i].token));\n         i += 1;\n-        i %= n;\n     }\n     s.push(']');\n     s\n@@ -224,7 +225,6 @@ const SIZE_INFINITY: isize = 0xffff;\n \n pub struct Printer {\n     out: String,\n-    buf_max_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,\n     /// Number of spaces left on line\n@@ -234,7 +234,7 @@ pub struct Printer {\n     /// Index of right side of input stream\n     right: usize,\n     /// Ring-buffer of tokens and calculated sizes\n-    buf: Vec<BufEntry>,\n+    buf: RingBuffer<BufEntry>,\n     /// Running size of stream \"...left\"\n     left_total: isize,\n     /// Running size of stream \"...right\"\n@@ -267,19 +267,16 @@ impl Default for BufEntry {\n impl Printer {\n     pub fn new() -> Self {\n         let linewidth = 78;\n-        // Yes 55, it makes the ring buffers big enough to never fall behind.\n-        let n: usize = 55 * linewidth;\n         debug!(\"Printer::new {}\", linewidth);\n+        let mut buf = RingBuffer::new();\n+        buf.advance_right();\n         Printer {\n             out: String::new(),\n-            buf_max_len: n,\n             margin: linewidth as isize,\n             space: linewidth as isize,\n             left: 0,\n             right: 0,\n-            // Initialize a single entry; advance_right() will extend it on demand\n-            // up to `buf_max_len` elements.\n-            buf: vec![BufEntry::default()],\n+            buf,\n             left_total: 0,\n             right_total: 0,\n             scan_stack: VecDeque::new(),\n@@ -308,8 +305,8 @@ impl Printer {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n-            self.left = 0;\n-            self.right = 0;\n+            self.right = self.left;\n+            self.buf.truncate(1);\n         } else {\n             self.advance_right();\n         }\n@@ -332,8 +329,8 @@ impl Printer {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n-            self.left = 0;\n-            self.right = 0;\n+            self.right = self.left;\n+            self.buf.truncate(1);\n         } else {\n             self.advance_right();\n         }\n@@ -400,12 +397,7 @@ impl Printer {\n \n     fn advance_right(&mut self) {\n         self.right += 1;\n-        self.right %= self.buf_max_len;\n-        // Extend the buf if necessary.\n-        if self.right == self.buf.len() {\n-            self.buf.push(BufEntry::default());\n-        }\n-        assert_ne!(self.right, self.left);\n+        self.buf.advance_right();\n     }\n \n     fn advance_left(&mut self) {\n@@ -437,8 +429,8 @@ impl Printer {\n                 break;\n             }\n \n+            self.buf.advance_left();\n             self.left += 1;\n-            self.left %= self.buf_max_len;\n \n             left_size = self.buf[self.left].size;\n         }"}, {"sha": "7e4e353ef1f8c1e3eb89ac5d3bf75deb70a7b761", "filename": "compiler/rustc_ast_pretty/src/pp/ring.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/04b2073c84b71a0a8c30e628f942ac4d593f72fe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04b2073c84b71a0a8c30e628f942ac4d593f72fe/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs?ref=04b2073c84b71a0a8c30e628f942ac4d593f72fe", "patch": "@@ -0,0 +1,53 @@\n+use std::collections::VecDeque;\n+use std::ops::{Index, IndexMut};\n+\n+/// A view onto a finite range of an infinitely long sequence of T.\n+///\n+/// The Ts are indexed 0..infinity. A RingBuffer begins as a view of elements\n+/// 0..0 (i.e. nothing). The user of the RingBuffer advances its left and right\n+/// position independently, although only in the positive direction, and only\n+/// with left <= right at all times.\n+///\n+/// Holding a RingBuffer whose view is elements left..right gives the ability to\n+/// use Index and IndexMut to access elements i in the infinitely long queue for\n+/// which left <= i < right.\n+pub struct RingBuffer<T> {\n+    data: VecDeque<T>,\n+    // Abstract index of data[0] in the infinitely sized queue.\n+    offset: usize,\n+}\n+\n+impl<T> RingBuffer<T> {\n+    pub fn new() -> Self {\n+        RingBuffer { data: VecDeque::new(), offset: 0 }\n+    }\n+\n+    pub fn advance_right(&mut self)\n+    where\n+        T: Default,\n+    {\n+        self.data.push_back(T::default());\n+    }\n+\n+    pub fn advance_left(&mut self) {\n+        self.data.pop_front().unwrap();\n+        self.offset += 1;\n+    }\n+\n+    pub fn truncate(&mut self, len: usize) {\n+        self.data.truncate(len);\n+    }\n+}\n+\n+impl<T> Index<usize> for RingBuffer<T> {\n+    type Output = T;\n+    fn index(&self, index: usize) -> &Self::Output {\n+        &self.data[index.checked_sub(self.offset).unwrap()]\n+    }\n+}\n+\n+impl<T> IndexMut<usize> for RingBuffer<T> {\n+    fn index_mut(&mut self, index: usize) -> &mut Self::Output {\n+        &mut self.data[index.checked_sub(self.offset).unwrap()]\n+    }\n+}"}]}