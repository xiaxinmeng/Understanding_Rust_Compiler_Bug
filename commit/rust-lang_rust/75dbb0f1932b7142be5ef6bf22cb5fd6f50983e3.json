{"sha": "75dbb0f1932b7142be5ef6bf22cb5fd6f50983e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZGJiMGYxOTMyYjcxNDJiZTVlZjZiZjIyY2I1ZmQ2ZjUwOTgzZTM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-17T04:00:46Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-17T05:12:36Z"}, "message": "rustdoc: Use attr API in attr_parser", "tree": {"sha": "ec247aea585cf3dfb47eb4bc503ba3a4d5dd09b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec247aea585cf3dfb47eb4bc503ba3a4d5dd09b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75dbb0f1932b7142be5ef6bf22cb5fd6f50983e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75dbb0f1932b7142be5ef6bf22cb5fd6f50983e3", "html_url": "https://github.com/rust-lang/rust/commit/75dbb0f1932b7142be5ef6bf22cb5fd6f50983e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75dbb0f1932b7142be5ef6bf22cb5fd6f50983e3/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29409afe1a9723e5b0afcbe5e9d2fe1282b003af", "url": "https://api.github.com/repos/rust-lang/rust/commits/29409afe1a9723e5b0afcbe5e9d2fe1282b003af", "html_url": "https://github.com/rust-lang/rust/commit/29409afe1a9723e5b0afcbe5e9d2fe1282b003af"}], "stats": {"total": 179, "additions": 119, "deletions": 60}, "files": [{"sha": "e2cac87b9dd6084ead21804aa6687ead4b49a5fc", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 119, "deletions": 60, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/75dbb0f1932b7142be5ef6bf22cb5fd6f50983e3/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75dbb0f1932b7142be5ef6bf22cb5fd6f50983e3/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=75dbb0f1932b7142be5ef6bf22cb5fd6f50983e3", "patch": "@@ -1,4 +1,5 @@\n import rustc::syntax::ast;\n+import rustc::front::attr;\n \n export fn_attrs, arg_attrs;\n export parse_fn;\n@@ -15,86 +16,143 @@ type arg_attrs = {\n     desc: str\n };\n \n+fn doc_meta(\n+    attrs: [ast::attribute]\n+) -> option<@ast::meta_item> {\n+    let doc_attrs = attr::find_attrs_by_name(attrs, \"doc\");\n+    let doc_metas = attr::attr_metas(doc_attrs);\n+    if vec::is_not_empty(doc_metas) {\n+        if vec::len(doc_metas) != 1u {\n+            #warn(\"ignoring %u doc attributes\", vec::len(doc_metas) - 1u);\n+        }\n+        some(doc_metas[0])\n+    } else {\n+        none\n+    }\n+}\n+\n fn parse_fn(\n     attrs: [ast::attribute]\n ) -> fn_attrs {\n \n-    for attr in attrs {\n-        alt attr.node.value.node {\n-          ast::meta_name_value(\n-              \"doc\", {node: ast::lit_str(value), span: _}) {\n-            ret {\n+    let no_attrs = {\n+        brief: none,\n+        desc: none,\n+        args: [],\n+        return: none\n+    };\n+\n+    ret alt doc_meta(attrs) {\n+      some(meta) {\n+        alt attr::get_meta_item_value_str(meta) {\n+          some(desc) {\n+            {\n                 brief: none,\n-                desc: some(value),\n+                desc: some(desc),\n                 args: [],\n                 return: none\n-            };\n+            }\n           }\n-          ast::meta_list(\"doc\", docs) {\n-            ret parse_fn_(docs);\n+          none. {\n+            alt attr::get_meta_item_list(meta) {\n+              some(list) {\n+                parse_fn_(list)\n+              }\n+              none. {\n+                no_attrs\n+              }\n+            }\n           }\n-          _ { }\n         }\n+      }\n+      none. {\n+        no_attrs\n+      }\n+    };\n+}\n+\n+fn meta_item_from_list(\n+    items: [@ast::meta_item],\n+    name: str\n+) -> option<@ast::meta_item> {\n+    let items = attr::find_meta_items_by_name(items, name);\n+    vec::last(items)\n+}\n+\n+fn meta_item_value_from_list(\n+    items: [@ast::meta_item],\n+    name: str\n+) -> option<str> {\n+    alt meta_item_from_list(items, name) {\n+      some(item) {\n+        alt attr::get_meta_item_value_str(item) {\n+          some(value) { some(value) }\n+          none. { none }\n+        }\n+      }\n+      none. { none }\n     }\n+}\n \n-    {\n-        brief: none,\n-        desc: none,\n-        args: [],\n-        return: none\n+fn meta_item_list_from_list(\n+    items: [@ast::meta_item],\n+    name: str\n+) -> option<[@ast::meta_item]> {\n+    alt meta_item_from_list(items, name) {\n+      some(item) {\n+        attr::get_meta_item_list(item)\n+      }\n+      none. { none }\n+    }\n+}\n+\n+fn name_value_str_pair(\n+    item: @ast::meta_item\n+) -> option<(str, str)> {\n+    alt attr::get_meta_item_value_str(item) {\n+      some(value) {\n+        let name = attr::get_meta_item_name(item);\n+        some((name, value))\n+      }\n+      none. { none }\n     }\n }\n \n+fn fst<T, U>(+pair: (T, U)) -> T {\n+    let (t, _) = pair;\n+    ret t;\n+}\n+\n+fn snd<T, U>(+pair: (T, U)) -> U {\n+    let (_, u) = pair;\n+    ret u;\n+}\n+\n fn parse_fn_(\n     items: [@ast::meta_item]\n ) -> fn_attrs {\n-    let brief = none;\n-    let desc = none;\n-    let return = none;\n-    let argdocs = [];\n-    let argdocsfound = none;\n-    for item: @ast::meta_item in items {\n-        alt item.node {\n-            ast::meta_name_value(\"brief\", {node: ast::lit_str(value),\n-                                           span: _}) {\n-                brief = some(value);\n-            }\n-            ast::meta_name_value(\"desc\", {node: ast::lit_str(value),\n-                                              span: _}) {\n-                desc = some(value);\n-            }\n-            ast::meta_name_value(\"return\", {node: ast::lit_str(value),\n-                                            span: _}) {\n-                return = some(value);\n-            }\n-            ast::meta_list(\"args\", args) {\n-                argdocsfound = some(args);\n-            }\n-            _ { }\n-        }\n-    }\n-\n-    alt argdocsfound {\n-        none. { }\n-        some(ds) {\n-            for d: @ast::meta_item in ds {\n-                alt d.node {\n-                  ast::meta_name_value(key, {node: ast::lit_str(value),\n-                                             span: _}) {\n-                    argdocs += [{\n-                        name: key,\n-                        desc: value\n-                    }];\n-                  }\n+    let brief = meta_item_value_from_list(items, \"brief\");\n+    let desc = meta_item_value_from_list(items, \"desc\");\n+    let return = meta_item_value_from_list(items, \"return\");\n+\n+    let args = alt meta_item_list_from_list(items, \"args\") {\n+      some(items) {\n+        vec::filter_map(items) {|item|\n+            option::map(name_value_str_pair(item)) { |pair|\n+                {\n+                    name: fst(pair),\n+                    desc: snd(pair)\n                 }\n             }\n         }\n-    }\n+      }\n+      none. { [] }\n+    };\n \n     {\n         brief: brief,\n         desc: desc,\n-        args: argdocs,\n+        args: args,\n         return: return\n     }\n }\n@@ -103,11 +161,12 @@ fn parse_fn_(\n mod tests {\n \n     fn parse_attributes(source: str) -> [ast::attribute] {\n-        import rustc::driver::diagnostic;\n-        import rustc::syntax::codemap;\n         import rustc::syntax::parse::parser;\n+        // FIXME: Uncommenting this results in rustc bugs\n+        //import rustc::syntax::codemap;\n+        import rustc::driver::diagnostic;\n \n-        let cm = codemap::new_codemap();\n+        let cm = rustc::syntax::codemap::new_codemap();\n         let parse_sess = @{\n             cm: cm,\n             mutable next_id: 0,\n@@ -130,12 +189,12 @@ mod tests {\n         assert vec::len(attrs.args) == 0u;\n     }\n \n-    #[tes]\n+    #[test]\n     fn parse_fn_should_parse_simple_doc_attributes() {\n         let source = \"#[doc = \\\"basic\\\"]\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_fn(attrs);\n-        assert attrs.brief == some(\"basic\");\n+        assert attrs.desc == some(\"basic\");\n     }\n \n     #[test]"}]}