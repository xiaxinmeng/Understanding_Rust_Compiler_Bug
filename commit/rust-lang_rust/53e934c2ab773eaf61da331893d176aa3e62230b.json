{"sha": "53e934c2ab773eaf61da331893d176aa3e62230b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzZTkzNGMyYWI3NzNlYWY2MWRhMzMxODkzZDE3NmFhM2U2MjIzMGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-16T21:37:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-16T21:37:34Z"}, "message": "auto merge of #7684 : pnkfelix/rust/fsk-invert-range-rev-halfclosedness-issue5270-2ndpr, r=cmr\n\nChanges int/uint range_rev to iterate over range `(hi,lo]` instead of `[hi,lo)`.\r\n\r\nFix #5270.\r\n\r\nAlso:\r\n* Adds unit tests for int/uint range functions\r\n* Updates the uses of `range_rev` to account for the new semantics.  (Note that pretty much all of the updates there were strict improvements to the code in question; yay!)\r\n* Exposes new function, `range_step_inclusive`, which does the range `[hi,lo]`, (at least when `hi-lo` is a multiple of the `step` parameter).\r\n* Special-cases when `|step| == 1` removing unnecessary bounds-check.  (I did not check whether LLVM was already performing this optimization; I figure it would be a net win to not leave that analysis to the compiler.  If reviewer objects, I can easily remove that from the refactored code.)\r\n\r\n(This pull request is a rebased version of PR #7524, which went stale due to recent unrelated changes to num libraries.)", "tree": {"sha": "e10d9c36f5f1eed33171e2a75381769076fa4857", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e10d9c36f5f1eed33171e2a75381769076fa4857"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53e934c2ab773eaf61da331893d176aa3e62230b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53e934c2ab773eaf61da331893d176aa3e62230b", "html_url": "https://github.com/rust-lang/rust/commit/53e934c2ab773eaf61da331893d176aa3e62230b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53e934c2ab773eaf61da331893d176aa3e62230b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9db190305f7562f15b5282fed508aef81cfc9689", "url": "https://api.github.com/repos/rust-lang/rust/commits/9db190305f7562f15b5282fed508aef81cfc9689", "html_url": "https://github.com/rust-lang/rust/commit/9db190305f7562f15b5282fed508aef81cfc9689"}, {"sha": "3896d46c0a6b99ef166bdc29220ef6c85ad8bc8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3896d46c0a6b99ef166bdc29220ef6c85ad8bc8d", "html_url": "https://github.com/rust-lang/rust/commit/3896d46c0a6b99ef166bdc29220ef6c85ad8bc8d"}], "stats": {"total": 440, "additions": 395, "deletions": 45}, "files": [{"sha": "200e824209450ab11a6a631e821faefc39409577", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=53e934c2ab773eaf61da331893d176aa3e62230b", "patch": "@@ -161,8 +161,8 @@ impl<V> SmallIntMap<V> {\n     /// Visit all key-value pairs in reverse order\n     pub fn each_reverse<'a>(&'a self, it: &fn(uint, &'a V) -> bool) -> bool {\n         for uint::range_rev(self.v.len(), 0) |i| {\n-            match self.v[i - 1] {\n-              Some(ref elt) => if !it(i - 1, elt) { return false; },\n+            match self.v[i] {\n+              Some(ref elt) => if !it(i, elt) { return false; },\n               None => ()\n             }\n         }"}, {"sha": "cef32b5c7e4456fc5115397034881a141f3a54ca", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=53e934c2ab773eaf61da331893d176aa3e62230b", "patch": "@@ -29,28 +29,38 @@ pub static bytes : uint = ($bits / 8);\n pub static min_value: $T = (-1 as $T) << (bits - 1);\n pub static max_value: $T = min_value - 1 as $T;\n \n+enum Range { Closed, HalfOpen }\n+\n+#[inline]\n ///\n-/// Iterate over the range [`lo`..`hi`)\n+/// Iterate through a range with a given step value.\n ///\n-/// # Arguments\n+/// Let `term` denote the closed interval `[stop-step,stop]` if `r` is Closed;\n+/// otherwise `term` denotes the half-open interval `[stop-step,stop)`.\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// `x_j == start + step*j`, and `x_n` lies in the interval `term`.\n ///\n-/// * `lo` - lower bound, inclusive\n-/// * `hi` - higher bound, exclusive\n-///\n-/// # Examples\n-/// ~~~\n-/// let mut sum = 0;\n-/// for int::range(1, 5) |i| {\n-///     sum += i;\n-/// }\n-/// assert!(sum == 10);\n-/// ~~~\n+/// If no such nonnegative integer `n` exists, then the iteration range\n+/// is empty.\n ///\n-#[inline]\n-pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n+fn range_step_core(start: $T, stop: $T, step: $T, r: Range, it: &fn($T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n         fail!(~\"range_step called with step == 0\");\n+    } else if step == (1 as $T) { // elide bounds check to tighten loop\n+        while i < stop {\n+            if !it(i) { return false; }\n+            // no need for overflow check;\n+            // cannot have i + 1 > max_value because i < stop <= max_value\n+            i += (1 as $T);\n+        }\n+    } else if step == (-1 as $T) { // elide bounds check to tighten loop\n+        while i > stop {\n+            if !it(i) { return false; }\n+            // no need for underflow check;\n+            // cannot have i - 1 < min_value because i > stop >= min_value\n+            i -= (1 as $T);\n+        }\n     } else if step > 0 { // ascending\n         while i < stop {\n             if !it(i) { return false; }\n@@ -66,19 +76,66 @@ pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n             i += step;\n         }\n     }\n-    return true;\n+    match r {\n+        HalfOpen => return true,\n+        Closed => return (i != stop || it(i))\n+    }\n+}\n+\n+#[inline]\n+///\n+/// Iterate through the range [`start`..`stop`) with a given step value.\n+///\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// * `x_i == start + step*i`, and\n+/// * `n` is the greatest nonnegative integer such that `x_n < stop`\n+///\n+/// (If no such `n` exists, then the iteration range is empty.)\n+///\n+/// # Arguments\n+///\n+/// * `start` - lower bound, inclusive\n+/// * `stop` - higher bound, exclusive\n+///\n+/// # Examples\n+/// ~~~\n+/// let mut sum = 0;\n+/// for int::range(1, 5) |i| {\n+///     sum += i;\n+/// }\n+/// assert!(sum == 10);\n+/// ~~~\n+///\n+pub fn range_step(start: $T, stop: $T, step: $T, it: &fn($T) -> bool) -> bool {\n+    range_step_core(start, stop, step, HalfOpen, it)\n+}\n+\n+#[inline]\n+///\n+/// Iterate through a range with a given step value.\n+///\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// `x_i == start + step*i` and `x_n <= last < step + x_n`.\n+///\n+/// (If no such nonnegative integer `n` exists, then the iteration\n+///  range is empty.)\n+///\n+pub fn range_step_inclusive(start: $T, last: $T, step: $T, it: &fn($T) -> bool) -> bool {\n+    range_step_core(start, last, step, Closed, it)\n }\n \n+\n #[inline]\n /// Iterate over the range [`lo`..`hi`)\n pub fn range(lo: $T, hi: $T, it: &fn($T) -> bool) -> bool {\n     range_step(lo, hi, 1 as $T, it)\n }\n \n #[inline]\n-/// Iterate over the range [`hi`..`lo`)\n+/// Iterate over the range (`hi`..`lo`]\n pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n-    range_step(hi, lo, -1 as $T, it)\n+    if hi == min_value { return true; }\n+    range_step_inclusive(hi-1, lo, -1 as $T, it)\n }\n \n impl Num for $T {}\n@@ -841,7 +898,7 @@ mod tests {\n         for range(0,3) |i| {\n             l.push(i);\n         }\n-        for range_rev(13,10) |i| {\n+        for range_rev(14,11) |i| {\n             l.push(i);\n         }\n         for range_step(20,26,2) |i| {"}, {"sha": "54c1327fa9303798921d15ce735df9c64f59936f", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 80, "deletions": 20, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=53e934c2ab773eaf61da331893d176aa3e62230b", "patch": "@@ -30,40 +30,99 @@ pub static bytes : uint = ($bits / 8);\n pub static min_value: $T = 0 as $T;\n pub static max_value: $T = 0 as $T - 1 as $T;\n \n+enum Range { Closed, HalfOpen }\n+\n #[inline]\n-/**\n- * Iterate through a range with a given step value.\n- *\n- * # Examples\n- * ~~~ {.rust}\n- * let nums = [1,2,3,4,5,6,7];\n- *\n- * for uint::range_step(0, nums.len() - 1, 2) |i| {\n- *     println(fmt!(\"%d & %d\", nums[i], nums[i+1]));\n- * }\n- * ~~~\n- */\n-pub fn range_step(start: $T, stop: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n+///\n+/// Iterate through a range with a given step value.\n+///\n+/// Let `term` denote the closed interval `[stop-step,stop]` if `r` is Closed;\n+/// otherwise `term` denotes the half-open interval `[stop-step,stop)`.\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// `x_j == start + step*j`, and `x_n` lies in the interval `term`.\n+///\n+/// If no such nonnegative integer `n` exists, then the iteration range\n+/// is empty.\n+///\n+fn range_step_core(start: $T, stop: $T, step: $T_SIGNED, r: Range, it: &fn($T) -> bool) -> bool {\n     let mut i = start;\n     if step == 0 {\n         fail!(\"range_step called with step == 0\");\n-    }\n-    if step >= 0 {\n+    } else if step == (1 as $T_SIGNED) { // elide bounds check to tighten loop\n+        while i < stop {\n+            if !it(i) { return false; }\n+            // no need for overflow check;\n+            // cannot have i + 1 > max_value because i < stop <= max_value\n+            i += (1 as $T);\n+        }\n+    } else if step == (-1 as $T_SIGNED) { // elide bounds check to tighten loop\n+        while i > stop {\n+            if !it(i) { return false; }\n+            // no need for underflow check;\n+            // cannot have i - 1 < min_value because i > stop >= min_value\n+            i -= (1 as $T);\n+        }\n+    } else if step > 0 { // ascending\n         while i < stop {\n             if !it(i) { return false; }\n             // avoiding overflow. break if i + step > max_value\n             if i > max_value - (step as $T) { return true; }\n             i += step as $T;\n         }\n-    } else {\n+    } else { // descending\n         while i > stop {\n             if !it(i) { return false; }\n             // avoiding underflow. break if i + step < min_value\n             if i < min_value + ((-step) as $T) { return true; }\n             i -= -step as $T;\n         }\n     }\n-    return true;\n+    match r {\n+        HalfOpen => return true,\n+        Closed => return (i != stop || it(i))\n+    }\n+}\n+\n+#[inline]\n+///\n+/// Iterate through the range [`start`..`stop`) with a given step value.\n+///\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// - `x_i == start + step*i`, and\n+/// - `n` is the greatest nonnegative integer such that `x_n < stop`\n+///\n+/// (If no such `n` exists, then the iteration range is empty.)\n+///\n+/// # Arguments\n+///\n+/// * `start` - lower bound, inclusive\n+/// * `stop` - higher bound, exclusive\n+///\n+/// # Examples\n+/// ~~~ {.rust}\n+/// let nums = [1,2,3,4,5,6,7];\n+///\n+/// for uint::range_step(0, nums.len() - 1, 2) |i| {\n+///     println(fmt!(\"%d & %d\", nums[i], nums[i+1]));\n+/// }\n+/// ~~~\n+///\n+pub fn range_step(start: $T, stop: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n+    range_step_core(start, stop, step, HalfOpen, it)\n+}\n+\n+#[inline]\n+///\n+/// Iterate through a range with a given step value.\n+///\n+/// Iterates through the range `[x_0, x_1, ..., x_n]` where\n+/// `x_i == start + step*i` and `x_n <= last < step + x_n`.\n+///\n+/// (If no such nonnegative integer `n` exists, then the iteration\n+///  range is empty.)\n+///\n+pub fn range_step_inclusive(start: $T, last: $T, step: $T_SIGNED, it: &fn($T) -> bool) -> bool {\n+    range_step_core(start, last, step, Closed, it)\n }\n \n #[inline]\n@@ -73,9 +132,10 @@ pub fn range(lo: $T, hi: $T, it: &fn($T) -> bool) -> bool {\n }\n \n #[inline]\n-/// Iterate over the range [`hi`..`lo`)\n+/// Iterate over the range (`hi`..`lo`]\n pub fn range_rev(hi: $T, lo: $T, it: &fn($T) -> bool) -> bool {\n-    range_step(hi, lo, -1 as $T_SIGNED, it)\n+    if hi == min_value { return true; }\n+    range_step_inclusive(hi-1, lo, -1 as $T_SIGNED, it)\n }\n \n impl Num for $T {}\n@@ -603,7 +663,7 @@ mod tests {\n         for range(0,3) |i| {\n             l.push(i);\n         }\n-        for range_rev(13,10) |i| {\n+        for range_rev(14,11) |i| {\n             l.push(i);\n         }\n         for range_step(20,26,2) |i| {"}, {"sha": "883870db1e67361e59095c78a1056f276cfa5b56", "filename": "src/libstd/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=53e934c2ab773eaf61da331893d176aa3e62230b", "patch": "@@ -669,7 +669,7 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             fail!(\"failure in dup3(err_fd, 2): %s\", os::last_os_error());\n         }\n         // close all other fds\n-        for int::range_rev(getdtablesize() as int - 1, 2) |fd| {\n+        for int::range_rev(getdtablesize() as int, 3) |fd| {\n             close(fd as c_int);\n         }\n "}, {"sha": "396fdaf2e6a5592ae5fc598bf89561a46d6534b5", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=53e934c2ab773eaf61da331893d176aa3e62230b", "patch": "@@ -287,7 +287,7 @@ impl<T> TrieNode<T> {\n \n     fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n-            match self.children[idx - 1] {\n+            match self.children[idx] {\n                 Internal(ref x) => if !x.each_reverse(|i,t| f(i,t)) { return false },\n                 External(k, ref v) => if !f(&k, v) { return false },\n                 Nothing => ()\n@@ -488,7 +488,7 @@ mod test_map {\n             m.insert(x, x / 2);\n         }\n \n-        let mut n = uint::max_value - 9999;\n+        let mut n = uint::max_value - 10000;\n         for m.each |k, v| {\n             if n == uint::max_value - 5000 { break }\n             assert!(n < uint::max_value - 5000);\n@@ -525,7 +525,7 @@ mod test_map {\n             m.insert(x, x / 2);\n         }\n \n-        let mut n = uint::max_value;\n+        let mut n = uint::max_value - 1;\n         for m.each_reverse |k, v| {\n             if n == uint::max_value - 5000 { break }\n             assert!(n > uint::max_value - 5000);"}, {"sha": "7262339e431d9c293b7e7f36438ce85fdde4f70f", "filename": "src/test/run-pass/num-range-rev.rs", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range-rev.rs?ref=53e934c2ab773eaf61da331893d176aa3e62230b", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::int;\n+use std::uint;\n+\n+fn uint_range(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n+    uint::range(lo, hi, it)\n+}\n+\n+fn int_range(lo: int,  hi: int, it: &fn(int) -> bool) -> bool {\n+    int::range(lo, hi, it)\n+}\n+\n+fn uint_range_rev(hi: uint, lo: uint, it: &fn(uint) -> bool) -> bool {\n+    uint::range_rev(hi, lo, it)\n+}\n+\n+fn int_range_rev(hi: int,  lo: int, it: &fn(int) -> bool) -> bool {\n+    int::range_rev(hi, lo, it)\n+}\n+\n+fn int_range_step(a: int, b: int, step: int, it: &fn(int) -> bool) -> bool {\n+    int::range_step(a, b, step, it)\n+}\n+\n+fn uint_range_step(a: uint, b: uint, step: int, it: &fn(uint) -> bool) -> bool {\n+    uint::range_step(a, b, step, it)\n+}\n+\n+\n+pub fn main() {\n+    // int and uint have same result for\n+    //   Sum{100 > i >= 2} == (Sum{1 <= i <= 99} - 1) == n*(n+1)/2 - 1 for n=99\n+    let mut sum = 0u;\n+    for uint_range_rev(100, 2) |i| {\n+        sum += i;\n+    }\n+    assert_eq!(sum, 4949);\n+\n+    let mut sum = 0i;\n+    for int_range_rev(100, 2) |i| {\n+        sum += i;\n+    }\n+    assert_eq!(sum, 4949);\n+\n+\n+    // elements are visited in correct order\n+    let primes = [2,3,5,7,11];\n+    let mut prod = 1i;\n+    for uint_range_rev(5, 0) |i| {\n+        println(fmt!(\"uint 4 downto 0: %u\", i));\n+        prod *= int::pow(primes[i], i);\n+    }\n+    assert_eq!(prod, 11*11*11*11*7*7*7*5*5*3*1);\n+    let mut prod = 1i;\n+    for int_range_rev(5, 0) |i| {\n+        println(fmt!(\"int 4 downto 0: %d\", i));\n+        prod *= int::pow(primes[i], i as uint);\n+    }\n+    assert_eq!(prod, 11*11*11*11*7*7*7*5*5*3*1);\n+\n+\n+    // range and range_rev are symmetric.\n+    let mut sum_up = 0u;\n+    for uint_range(10, 30) |i| {\n+        sum_up += i;\n+    }\n+    let mut sum_down = 0u;\n+    for uint_range_rev(30, 10) |i| {\n+        sum_down += i;\n+    }\n+    assert_eq!(sum_up, sum_down);\n+\n+    let mut sum_up = 0;\n+    for int_range(-20, 10) |i| {\n+        sum_up += i;\n+    }\n+    let mut sum_down = 0;\n+    for int_range_rev(10, -20) |i| {\n+        sum_down += i;\n+    }\n+    assert_eq!(sum_up, sum_down);\n+\n+\n+    // empty ranges\n+    for int_range_rev(10, 10) |_| {\n+        fail!(\"range should be empty when start == stop\");\n+    }\n+\n+    for uint_range_rev(0, 1) |_| {\n+        fail!(\"range should be empty when start-1 underflows\");\n+    }\n+\n+    // range iterations do not wrap/underflow\n+    let mut uflo_loop_visited = ~[];\n+    for int_range_step(int::min_value+15, int::min_value, -4) |x| {\n+        uflo_loop_visited.push(x - int::min_value);\n+    }\n+    assert_eq!(uflo_loop_visited, ~[15, 11, 7, 3]);\n+\n+    let mut uflo_loop_visited = ~[];\n+    for uint_range_step(uint::min_value+15, uint::min_value, -4) |x| {\n+        uflo_loop_visited.push(x - uint::min_value);\n+    }\n+    assert_eq!(uflo_loop_visited, ~[15, 11, 7, 3]);\n+}"}, {"sha": "7c1f905a049b6f4db40964ad810ecdc7a40f940e", "filename": "src/test/run-pass/num-range.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Ftest%2Frun-pass%2Fnum-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53e934c2ab773eaf61da331893d176aa3e62230b/src%2Ftest%2Frun-pass%2Fnum-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnum-range.rs?ref=53e934c2ab773eaf61da331893d176aa3e62230b", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::int;\n+use std::uint;\n+\n+fn uint_range(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n+    uint::range(lo, hi, it)\n+}\n+\n+fn int_range(lo: int, hi: int, it: &fn(int) -> bool) -> bool {\n+    int::range(lo, hi, it)\n+}\n+\n+fn int_range_step(a: int, b: int, step: int, it: &fn(int) -> bool) -> bool {\n+    int::range_step(a, b, step, it)\n+}\n+\n+fn uint_range_step(a: uint, b: uint, s: int, it: &fn(uint) -> bool) -> bool {\n+    uint::range_step(a, b, s, it)\n+}\n+\n+pub fn main() {\n+    println(fmt!(\"num-range start\"));\n+    // int and uint have same result for\n+    //   Sum{2 <= i < 100} == (Sum{1 <= i <= 99} - 1) == n*(n+1)/2 - 1 for n=99\n+    let mut sum = 0u;\n+    for uint_range(2, 100) |i| {\n+        sum += i;\n+    }\n+    assert_eq!(sum, 4949);\n+\n+    let mut sum = 0i;\n+    for int_range(2, 100) |i| {\n+        sum += i;\n+    }\n+    assert_eq!(sum, 4949);\n+\n+\n+    // elements are visited in correct order\n+    let primes = [2,3,5,7];\n+    let mut prod = 1i;\n+    for uint_range(0, 4) |i| {\n+        prod *= int::pow(primes[i], i);\n+    }\n+    assert_eq!(prod, 1*3*5*5*7*7*7);\n+    let mut prod = 1i;\n+    for int_range(0, 4) |i| {\n+        prod *= int::pow(primes[i], i as uint);\n+    }\n+    assert_eq!(prod, 1*3*5*5*7*7*7);\n+\n+\n+    // empty ranges\n+    for int_range(10, 10) |_| {\n+        fail!(\"range should be empty when start == stop\");\n+    }\n+\n+    for uint_range(10, 10) |_| {\n+        fail!(\"range should be empty when start == stop\");\n+    }\n+\n+\n+    // range iterations do not wrap/overflow\n+    let mut oflo_loop_visited = ~[];\n+    for uint_range_step(uint::max_value-15, uint::max_value, 4) |x| {\n+        oflo_loop_visited.push(uint::max_value - x);\n+    }\n+    assert_eq!(oflo_loop_visited, ~[15, 11, 7, 3]);\n+\n+    let mut oflo_loop_visited = ~[];\n+    for int_range_step(int::max_value-15, int::max_value, 4) |x| {\n+        oflo_loop_visited.push(int::max_value - x);\n+    }\n+    assert_eq!(oflo_loop_visited, ~[15, 11, 7, 3]);\n+\n+\n+    // range_step never passes nor visits the stop element\n+    for int_range_step(0, 21, 3) |x| {\n+        assert!(x < 21);\n+    }\n+\n+    // range_step_inclusive will never pass stop element, and may skip it.\n+    let mut saw21 = false;\n+    for uint::range_step_inclusive(0, 21, 4) |x| {\n+        assert!(x <= 21);\n+        if x == 21 { saw21 = true; }\n+    }\n+    assert!(!saw21);\n+    let mut saw21 = false;\n+    for int::range_step_inclusive(0, 21, 4) |x| {\n+        assert!(x <= 21);\n+        if x == 21 { saw21 = true; }\n+    }\n+    assert!(!saw21);\n+\n+    // range_step_inclusive will never pass stop element, but may visit it.\n+    let mut saw21 = false;\n+    for uint::range_step_inclusive(0, 21, 3) |x| {\n+        assert!(x <= 21);\n+        println(fmt!(\"saw: %u\", x));\n+        if x == 21 { saw21 = true; }\n+    }\n+    assert!(saw21);\n+    let mut saw21 = false;\n+    for int::range_step_inclusive(0, 21, 3) |x| {\n+        assert!(x <= 21);\n+        if x == 21 { saw21 = true; }\n+    }\n+    assert!(saw21);\n+\n+}"}]}