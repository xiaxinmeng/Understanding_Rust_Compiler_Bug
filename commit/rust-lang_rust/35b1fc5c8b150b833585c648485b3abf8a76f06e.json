{"sha": "35b1fc5c8b150b833585c648485b3abf8a76f06e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YjFmYzVjOGIxNTBiODMzNTg1YzY0ODQ4NWIzYWJmOGE3NmYwNmU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-13T11:37:54Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2013-08-15T02:10:21Z"}, "message": "Port freevars.rs from oldvisit to <V:Visitor> trait.", "tree": {"sha": "afe1898d48cdd4624bd003745240e888a85b0950", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afe1898d48cdd4624bd003745240e888a85b0950"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35b1fc5c8b150b833585c648485b3abf8a76f06e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35b1fc5c8b150b833585c648485b3abf8a76f06e", "html_url": "https://github.com/rust-lang/rust/commit/35b1fc5c8b150b833585c648485b3abf8a76f06e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35b1fc5c8b150b833585c648485b3abf8a76f06e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6986361776ea2734886f161496281c692c283450", "url": "https://api.github.com/repos/rust-lang/rust/commits/6986361776ea2734886f161496281c692c283450", "html_url": "https://github.com/rust-lang/rust/commit/6986361776ea2734886f161496281c692c283450"}], "stats": {"total": 98, "additions": 61, "deletions": 37}, "files": [{"sha": "c6446955cc891bd69af8df802f4c5da14a334b90", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/35b1fc5c8b150b833585c648485b3abf8a76f06e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35b1fc5c8b150b833585c648485b3abf8a76f06e/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=35b1fc5c8b150b833585c648485b3abf8a76f06e", "patch": "@@ -17,7 +17,10 @@ use middle::ty;\n \n use std::hashmap::HashMap;\n use syntax::codemap::span;\n-use syntax::{ast, ast_util, oldvisit};\n+use syntax::{ast, ast_util};\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+use syntax::ast::{item};\n \n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n@@ -29,27 +32,27 @@ pub struct freevar_entry {\n pub type freevar_info = @~[@freevar_entry];\n pub type freevar_map = @mut HashMap<ast::NodeId, freevar_info>;\n \n-// Searches through part of the AST for all references to locals or\n-// upvars in this frame and returns the list of definition IDs thus found.\n-// Since we want to be able to collect upvars in some arbitrary piece\n-// of the AST, we take a walker function that we invoke with a visitor\n-// in order to start the search.\n-fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block)\n-    -> freevar_info {\n-    let seen = @mut HashMap::new();\n-    let refs = @mut ~[];\n+struct CollectFreevarsVisitor {\n+    seen: @mut HashMap<ast::NodeId, ()>,\n+    refs: @mut ~[@freevar_entry],\n+    def_map: resolve::DefMap,\n+}\n+\n+impl Visitor<int> for CollectFreevarsVisitor {\n \n-    fn ignore_item(_i: @ast::item, (_depth, _v): (int, oldvisit::vt<int>)) { }\n+    fn visit_item(&mut self, _:@item, _:int) {\n+        // ignore_item\n+    }\n+\n+    fn visit_expr(&mut self, expr:@ast::expr, depth:int) {\n \n-    let walk_expr: @fn(expr: @ast::expr, (int, oldvisit::vt<int>)) =\n-        |expr, (depth, v)| {\n             match expr.node {\n               ast::expr_fn_block(*) => {\n-                oldvisit::visit_expr(expr, (depth + 1, v))\n+                visit::walk_expr(self, expr, depth + 1)\n               }\n               ast::expr_path(*) | ast::expr_self => {\n                   let mut i = 0;\n-                  match def_map.find(&expr.id) {\n+                  match self.def_map.find(&expr.id) {\n                     None => fail!(\"path not found\"),\n                     Some(&df) => {\n                       let mut def = df;\n@@ -62,28 +65,58 @@ fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block)\n                       }\n                       if i == depth { // Made it to end of loop\n                         let dnum = ast_util::def_id_of_def(def).node;\n-                        if !seen.contains_key(&dnum) {\n-                            refs.push(@freevar_entry {\n+                        if !self.seen.contains_key(&dnum) {\n+                            self.refs.push(@freevar_entry {\n                                 def: def,\n                                 span: expr.span,\n                             });\n-                            seen.insert(dnum, ());\n+                            self.seen.insert(dnum, ());\n                         }\n                       }\n                     }\n                   }\n               }\n-              _ => oldvisit::visit_expr(expr, (depth, v))\n+              _ => visit::walk_expr(self, expr, depth)\n             }\n-        };\n+    }\n \n-    let v = oldvisit::mk_vt(@oldvisit::Visitor {visit_item: ignore_item,\n-                                          visit_expr: walk_expr,\n-                                          .. *oldvisit::default_visitor()});\n-    (v.visit_block)(blk, (1, v));\n+\n+}\n+\n+// Searches through part of the AST for all references to locals or\n+// upvars in this frame and returns the list of definition IDs thus found.\n+// Since we want to be able to collect upvars in some arbitrary piece\n+// of the AST, we take a walker function that we invoke with a visitor\n+// in order to start the search.\n+fn collect_freevars(def_map: resolve::DefMap, blk: &ast::Block)\n+    -> freevar_info {\n+    let seen = @mut HashMap::new();\n+    let refs = @mut ~[];\n+\n+    let mut v = CollectFreevarsVisitor {\n+        seen: seen,\n+        refs: refs,\n+        def_map: def_map,\n+    };\n+\n+    v.visit_block(blk, 1);\n     return @(*refs).clone();\n }\n \n+struct AnnotateFreevarsVisitor {\n+    def_map: resolve::DefMap,\n+    freevars: freevar_map,\n+}\n+\n+impl Visitor<()> for AnnotateFreevarsVisitor {\n+    fn visit_fn(&mut self, fk:&visit::fn_kind, fd:&ast::fn_decl,\n+                blk:&ast::Block, s:span, nid:ast::NodeId, _:()) {\n+        let vars = collect_freevars(self.def_map, blk);\n+        self.freevars.insert(nid, vars);\n+        visit::walk_fn(self, fk, fd, blk, s, nid, ());\n+    }\n+}\n+\n // Build a map from every function and for-each body to a set of the\n // freevars contained in it. The implementation is not particularly\n // efficient as it fully recomputes the free variables at every\n@@ -93,20 +126,11 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: &ast::Crate) ->\n    freevar_map {\n     let freevars = @mut HashMap::new();\n \n-    let walk_fn: @fn(&oldvisit::fn_kind,\n-                     &ast::fn_decl,\n-                     &ast::Block,\n-                     span,\n-                     ast::NodeId) = |_, _, blk, _, nid| {\n-        let vars = collect_freevars(def_map, blk);\n-        freevars.insert(nid, vars);\n+    let mut visitor = AnnotateFreevarsVisitor {\n+        def_map: def_map,\n+        freevars: freevars,\n     };\n-\n-    let visitor =\n-        oldvisit::mk_simple_visitor(@oldvisit::SimpleVisitor {\n-            visit_fn: walk_fn,\n-            .. *oldvisit::default_simple_visitor()});\n-    oldvisit::visit_crate(crate, ((), visitor));\n+    visit::walk_crate(&mut visitor, crate, ());\n \n     return freevars;\n }"}]}