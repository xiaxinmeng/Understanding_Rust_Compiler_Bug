{"sha": "e9080ec39d9a44eb0773d648b348575b19f655e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MDgwZWMzOWQ5YTQ0ZWIwNzczZDY0OGIzNDg1NzViMTlmNjU1ZTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-16T15:33:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-16T15:33:54Z"}, "message": "Auto merge of #24181 - jgallagher:aarch64-hfa, r=pnkfelix\n\nI doubt this PR is ready to merge as-is, for a couple reasons:\r\n\r\n* There are no tests for this change. I'm not sure how to add tests for this change, as it modifies the C ABI for a cross-compilation target. Anecdotally, I have an iOS library I've been working on, and before this change, it crashes running on an arm64 device due to bad calling conventions (a simplified example is in #24154), and after this change, it runs correctly.\r\n* This is my first foray into LLVM. I did my best to reimplement what Clang does for AArch64 codegen (https://github.com/llvm-mirror/clang/blob/master/lib/CodeGen/TargetInfo.cpp), particularly in `ABIInfo::isHomogeneousAggregate`, `AArch64ABIInfo::isHomogeneousAggregateBaseType`, and `AArch64ABIInfo::isHomogeneousAggregateSmallEnough`, but I'm not confident I got a complete translation, particularly because Clang includes a lot of checks that I don't believe are necessary for rustc.\r\n\r\nFixes #24154.", "tree": {"sha": "375b9773a2e88588107514bbf3bae3de313ba2f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/375b9773a2e88588107514bbf3bae3de313ba2f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9080ec39d9a44eb0773d648b348575b19f655e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9080ec39d9a44eb0773d648b348575b19f655e5", "html_url": "https://github.com/rust-lang/rust/commit/e9080ec39d9a44eb0773d648b348575b19f655e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9080ec39d9a44eb0773d648b348575b19f655e5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5576b0558c7f46faa5331be72113238c677979b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5576b0558c7f46faa5331be72113238c677979b6", "html_url": "https://github.com/rust-lang/rust/commit/5576b0558c7f46faa5331be72113238c677979b6"}, {"sha": "1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4", "html_url": "https://github.com/rust-lang/rust/commit/1a44b3875d1c552f3a0a6bd324bc1053f6ce87a4"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "57dd22233882867a4b32f54aae8c2ee8da8be398", "filename": "src/librustc_trans/trans/cabi_aarch64.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e9080ec39d9a44eb0773d648b348575b19f655e5/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9080ec39d9a44eb0773d648b348575b19f655e5/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_aarch64.rs?ref=e9080ec39d9a44eb0773d648b348575b19f655e5", "patch": "@@ -86,11 +86,91 @@ fn ty_size(ty: Type) -> usize {\n     }\n }\n \n+fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n+    fn check_array(ty: Type) -> Option<(Type, u64)> {\n+        let len = ty.array_length() as u64;\n+        if len == 0 {\n+            return None\n+        }\n+        let elt = ty.element_type();\n+\n+        // if our element is an HFA/HVA, so are we; multiply members by our len\n+        is_homogenous_aggregate_ty(elt).map(|(base_ty, members)| (base_ty, len * members))\n+    }\n+\n+    fn check_struct(ty: Type) -> Option<(Type, u64)> {\n+        let str_tys = ty.field_types();\n+        if str_tys.len() == 0 {\n+            return None\n+        }\n+\n+        let mut prev_base_ty = None;\n+        let mut members = 0;\n+        for opt_homog_agg in str_tys.iter().map(|t| is_homogenous_aggregate_ty(*t)) {\n+            match (prev_base_ty, opt_homog_agg) {\n+                // field isn't itself an HFA, so we aren't either\n+                (_, None) => return None,\n+\n+                // first field - store its type and number of members\n+                (None, Some((field_ty, field_members))) => {\n+                    prev_base_ty = Some(field_ty);\n+                    members = field_members;\n+                },\n+\n+                // 2nd or later field - give up if it's a different type; otherwise incr. members\n+                (Some(prev_ty), Some((field_ty, field_members))) => {\n+                    if prev_ty != field_ty {\n+                        return None;\n+                    }\n+                    members += field_members;\n+                }\n+            }\n+        }\n+\n+        // Because of previous checks, we know prev_base_ty is Some(...) because\n+        //   1. str_tys has at least one element; and\n+        //   2. prev_base_ty was filled in (or we would've returned early)\n+        let (base_ty, members) = (prev_base_ty.unwrap(), members);\n+\n+        // Ensure there is no padding.\n+        if ty_size(ty) == ty_size(base_ty) * (members as usize) {\n+            Some((base_ty, members))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    let homog_agg = match ty.kind() {\n+        Float  => Some((ty, 1)),\n+        Double => Some((ty, 1)),\n+        Array  => check_array(ty),\n+        Struct => check_struct(ty),\n+        Vector => match ty_size(ty) {\n+            4|8 => Some((ty, 1)),\n+            _   => None\n+        },\n+        _ => None\n+    };\n+\n+    // Ensure we have at most four uniquely addressable members\n+    homog_agg.and_then(|(base_ty, members)| {\n+        if members > 0 && members <= 4 {\n+            Some((base_ty, members))\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n fn classify_ret_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n     if is_reg_ty(ty) {\n         let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n+        let llty = Type::array(&base_ty, members);\n+        return ArgType::direct(ty, Some(llty), None, None);\n+    }\n     let size = ty_size(ty);\n     if size <= 16 {\n         let llty = if size <= 1 {\n@@ -114,6 +194,10 @@ fn classify_arg_ty(ccx: &CrateContext, ty: Type) -> ArgType {\n         let attr = if ty == Type::i1(ccx) { Some(ZExtAttribute) } else { None };\n         return ArgType::direct(ty, None, None, attr);\n     }\n+    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ty) {\n+        let llty = Type::array(&base_ty, members);\n+        return ArgType::direct(ty, Some(llty), None, None);\n+    }\n     let size = ty_size(ty);\n     if size <= 16 {\n         let llty = if size == 0 {"}]}