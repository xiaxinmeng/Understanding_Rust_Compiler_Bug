{"sha": "218189536d95c12d7abbe01af3725c84a628bc51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxODE4OTUzNmQ5NWMxMmQ3YWJiZTAxYWYzNzI1Yzg0YTYyOGJjNTE=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2018-09-08T06:52:03Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-09-25T02:05:55Z"}, "message": "Handle impl trait in MIR type checked for assignments.", "tree": {"sha": "d952116d63f517204987df8dcb7e20029c5a20f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d952116d63f517204987df8dcb7e20029c5a20f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/218189536d95c12d7abbe01af3725c84a628bc51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/218189536d95c12d7abbe01af3725c84a628bc51", "html_url": "https://github.com/rust-lang/rust/commit/218189536d95c12d7abbe01af3725c84a628bc51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/218189536d95c12d7abbe01af3725c84a628bc51/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf915849f0f9467e67823a9d7eb1128828a9f334", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf915849f0f9467e67823a9d7eb1128828a9f334", "html_url": "https://github.com/rust-lang/rust/commit/cf915849f0f9467e67823a9d7eb1128828a9f334"}], "stats": {"total": 603, "additions": 368, "deletions": 235}, "files": [{"sha": "84afdd53cf48c17e9cb2d913cf1e881a09f78f66", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -1739,7 +1739,7 @@ specified exit code, use `std::process::exit`.\n \n E0562: r##\"\n Abstract return types (written `impl Trait` for some trait `Trait`) are only\n-allowed as function and inherent impl return types or binding types.\n+allowed as function and inherent impl return types.\n \n Erroneous code example:\n \n@@ -1754,8 +1754,7 @@ fn main() {\n }\n ```\n \n-Make sure `impl Trait` only appears in return-type position or as the type of a\n-binding.\n+Make sure `impl Trait` only appears in return-type position.\n \n ```\n fn count_to_n(n: usize) -> impl Iterator<Item=usize> {"}, {"sha": "f25a17304f9ed0eae1bc81e7a46099f6d3738387", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -1284,12 +1284,18 @@ impl<'a> LoweringContext<'a> {\n                         ))\n                     }\n                     ImplTraitContext::Disallowed => {\n+                        let allowed_in = if self.sess.features_untracked()\n+                                                .impl_trait_in_bindings {\n+                            \"bindings or function and inherent method return types\"\n+                        } else {\n+                            \"function and inherent method return types\"\n+                        };\n                         span_err!(\n                             self.sess,\n                             t.span,\n                             E0562,\n-                            \"`impl Trait` not allowed outside of function \\\n-                             and inherent method return types or bindings\"\n+                            \"`impl Trait` not allowed outside of {}\",\n+                            allowed_in,\n                         );\n                         hir::TyKind::Err\n                     }\n@@ -2206,8 +2212,10 @@ impl<'a> LoweringContext<'a> {\n         let impl_trait_ty = self.lower_existential_impl_trait(\n             span, Some(fn_def_id), return_impl_trait_id, |this| {\n             let output_ty = match output {\n-                FunctionRetTy::Ty(ty) =>\n-                    this.lower_ty(ty, ImplTraitContext::Existential(Some(fn_def_id))),\n+                FunctionRetTy::Ty(ty) => {\n+                    let impl_trait_owner_id = *this.current_impl_trait_owner.last().unwrap();\n+                    this.lower_ty(ty, ImplTraitContext::Existential(Some(impl_trait_owner_id)))\n+                }\n                 FunctionRetTy::Default(span) => {\n                     let LoweredNodeId { node_id, hir_id } = this.next_id();\n                     P(hir::Ty {\n@@ -2702,14 +2710,31 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::Static(ref t, m, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n                 hir::ItemKind::Static(\n-                    self.lower_ty(t, ImplTraitContext::Disallowed),\n+                    self.lower_ty(\n+                        t,\n+                        if self.sess.features_untracked().impl_trait_in_bindings {\n+                            ImplTraitContext::Existential(None)\n+                        } else {\n+                            ImplTraitContext::Disallowed\n+                        }\n+                    ),\n                     self.lower_mutability(m),\n                     value,\n                 )\n             }\n             ItemKind::Const(ref t, ref e) => {\n                 let value = self.lower_body(None, |this| this.lower_expr(e));\n-                hir::ItemKind::Const(self.lower_ty(t, ImplTraitContext::Disallowed), value)\n+                hir::ItemKind::Const(\n+                    self.lower_ty(\n+                        t,\n+                        if self.sess.features_untracked().impl_trait_in_bindings {\n+                            ImplTraitContext::Existential(None)\n+                        } else {\n+                            ImplTraitContext::Disallowed\n+                        }\n+                    ),\n+                    value\n+                )\n             }\n             ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n@@ -3258,6 +3283,22 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ids\n             },\n+            ItemKind::Static(ref ty, ..) => {\n+                let mut ids = smallvec![hir::ItemId { id: i.id }];\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                    visitor.visit_ty(ty);\n+                }\n+                ids\n+            },\n+            ItemKind::Const(ref ty, ..) => {\n+                let mut ids = smallvec![hir::ItemId { id: i.id }];\n+                if self.sess.features_untracked().impl_trait_in_bindings {\n+                    let mut visitor = ImplTraitTypeIdVisitor { ids: &mut ids };\n+                    visitor.visit_ty(ty);\n+                }\n+                ids\n+            },\n             _ => smallvec![hir::ItemId { id: i.id }],\n         }\n     }\n@@ -3817,8 +3858,8 @@ impl<'a> LoweringContext<'a> {\n             }\n             ExprKind::Block(ref blk, opt_label) => {\n                 hir::ExprKind::Block(self.lower_block(blk,\n-                                                opt_label.is_some()),\n-                                                self.lower_label(opt_label))\n+                                                      opt_label.is_some()),\n+                                                      self.lower_label(opt_label))\n             }\n             ExprKind::Assign(ref el, ref er) => {\n                 hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)))"}, {"sha": "98042e18d32d9bd0913a4913aa6b59caf52bb84b", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -361,7 +361,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     let tcx = relation.tcx();\n     let a_sty = &a.sty;\n     let b_sty = &b.sty;\n-    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n+    debug!(\"super_relate_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n     match (a_sty, b_sty) {\n         (&ty::Infer(_), _) |\n         (_, &ty::Infer(_)) =>"}, {"sha": "acde4587d77dcad5a75cf0f79a1455850eaf96f4", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 15, "deletions": 132, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -17,15 +17,8 @@\n //! `RETURN_PLACE` the MIR arguments) are always fully normalized (and\n //! contain revealed `impl Trait` values).\n \n-use borrow_check::nll::renumber;\n-use borrow_check::nll::type_check::free_region_relations::UniversalRegionRelations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use rustc::hir::def_id::DefId;\n-use rustc::infer::InferOk;\n use rustc::mir::*;\n-use rustc::traits::query::type_op::custom::CustomTypeOp;\n-use rustc::traits::{ObligationCause, PredicateObligations};\n-use rustc::ty::subst::Subst;\n use rustc::ty::Ty;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -37,16 +30,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n         &mut self,\n         mir: &Mir<'tcx>,\n-        mir_def_id: DefId,\n         universal_regions: &UniversalRegions<'tcx>,\n-        universal_region_relations: &UniversalRegionRelations<'tcx>,\n         normalized_inputs_and_output: &[Ty<'tcx>],\n     ) {\n-        let tcx = self.infcx.tcx;\n-\n         let (&normalized_output_ty, normalized_input_tys) =\n             normalized_inputs_and_output.split_last().unwrap();\n-        let infcx = self.infcx;\n \n         // Equate expected input tys with those in the MIR.\n         let argument_locals = (1..).map(Local::new);\n@@ -77,111 +65,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n         // types.\n-        let param_env = self.param_env;\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n         let output_span = mir.local_decls[RETURN_PLACE].source_info.span;\n-        let opaque_type_map =\n-            self.fully_perform_op(\n-                Locations::All(output_span),\n-                ConstraintCategory::BoringNoLocation,\n-                CustomTypeOp::new(\n-                    |infcx| {\n-                        let mut obligations = ObligationAccumulator::default();\n-\n-                        let dummy_body_id = ObligationCause::dummy().body_id;\n-                        let (output_ty, opaque_type_map) =\n-                            obligations.add(infcx.instantiate_opaque_types(\n-                                mir_def_id,\n-                                dummy_body_id,\n-                                param_env,\n-                                &normalized_output_ty,\n-                            ));\n-                        debug!(\n-                            \"equate_inputs_and_outputs: instantiated output_ty={:?}\",\n-                            output_ty\n-                        );\n-                        debug!(\n-                            \"equate_inputs_and_outputs: opaque_type_map={:#?}\",\n-                            opaque_type_map\n-                        );\n-\n-                        debug!(\n-                            \"equate_inputs_and_outputs: mir_output_ty={:?}\",\n-                            mir_output_ty\n-                        );\n-                        obligations.add(\n-                            infcx\n-                                .at(&ObligationCause::dummy(), param_env)\n-                                .eq(output_ty, mir_output_ty)?,\n-                        );\n-\n-                        for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n-                            let opaque_defn_ty = tcx.type_of(opaque_def_id);\n-                            let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n-                            let opaque_defn_ty = renumber::renumber_regions(\n-                                infcx,\n-                                &opaque_defn_ty,\n-                            );\n-                            debug!(\n-                                \"equate_inputs_and_outputs: concrete_ty={:?}\",\n-                                opaque_decl.concrete_ty\n-                            );\n-                            debug!(\"equate_inputs_and_outputs: opaque_defn_ty={:?}\",\n-                                   opaque_defn_ty);\n-                            obligations.add(\n-                                infcx\n-                                    .at(&ObligationCause::dummy(), param_env)\n-                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n-                            );\n-                        }\n-\n-                        debug!(\"equate_inputs_and_outputs: equated\");\n-\n-                        Ok(InferOk {\n-                            value: Some(opaque_type_map),\n-                            obligations: obligations.into_vec(),\n-                        })\n-                    },\n-                    || \"input_output\".to_string(),\n-                ),\n-            ).unwrap_or_else(|terr| {\n-                span_mirbug!(\n-                    self,\n-                    Location::START,\n-                    \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n-                    normalized_output_ty,\n-                    mir_output_ty,\n-                    terr\n-                );\n-                None\n-            });\n-\n-        // Finally, if we instantiated the opaque types successfully, we\n-        // have to solve any bounds (e.g., `-> impl Iterator` needs to\n-        // prove that `T: Iterator` where `T` is the type we\n-        // instantiated it with).\n-        if let Some(opaque_type_map) = opaque_type_map {\n-            for (opaque_def_id, opaque_decl) in opaque_type_map {\n-                self.fully_perform_op(\n-                    Locations::All(infcx.tcx.def_span(opaque_def_id)),\n-                    ConstraintCategory::OpaqueType,\n-                    CustomTypeOp::new(\n-                        |_cx| {\n-                            infcx.constrain_opaque_type(\n-                                opaque_def_id,\n-                                &opaque_decl,\n-                                universal_region_relations\n-                            );\n-                            Ok(InferOk {\n-                                value: (),\n-                                obligations: vec![],\n-                            })\n-                        },\n-                        || \"opaque_type_map\".to_string(),\n-                    ),\n-                ).unwrap();\n-            }\n-        }\n+        if let Err(terr) = self.eq_opaque_type_and_type(\n+            mir_output_ty,\n+            normalized_output_ty,\n+            Locations::All(output_span),\n+            ConstraintCategory::BoringNoLocation,\n+        ) {\n+            span_mirbug!(\n+                self,\n+                Location::START,\n+                \"equate_inputs_and_outputs: `{:?}=={:?}` failed with `{:?}`\",\n+                normalized_output_ty,\n+                mir_output_ty,\n+                terr\n+            );\n+        };\n     }\n \n     fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, span: Span) {\n@@ -204,20 +104,3 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n }\n-\n-#[derive(Debug, Default)]\n-struct ObligationAccumulator<'tcx> {\n-    obligations: PredicateObligations<'tcx>,\n-}\n-\n-impl<'tcx> ObligationAccumulator<'tcx> {\n-    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n-        let InferOk { value, obligations } = value;\n-        self.obligations.extend(obligations);\n-        value\n-    }\n-\n-    fn into_vec(self) -> PredicateObligations<'tcx> {\n-        self.obligations\n-    }\n-}"}, {"sha": "8d260e0970add6b939803ae952d7d4accfb67156", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 154, "deletions": 5, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -22,22 +22,26 @@ use borrow_check::nll::type_check::free_region_relations::{\n };\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n+use borrow_check::nll::renumber;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n use dataflow::MaybeInitializedPlaces;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::region_constraints::GenericKind;\n-use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n+use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use rustc::mir::interpret::EvalErrorKind::BoundsCheck;\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::*;\n+use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::traits::query::type_op;\n+use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n+use rustc::ty::subst::Subst;\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -155,12 +159,11 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n             &region_bound_pairs,\n             Some(implicit_region_bound),\n             Some(&mut borrowck_context),\n+            Some(&universal_region_relations),\n             |cx| {\n                 cx.equate_inputs_and_outputs(\n                     mir,\n-                    mir_def_id,\n                     universal_regions,\n-                    &universal_region_relations,\n                     &normalized_inputs_and_output,\n                 );\n                 liveness::generate(cx, mir, elements, flow_inits, move_data);\n@@ -182,6 +185,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n+    universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n     mut extra: impl FnMut(&mut TypeChecker<'a, 'gcx, 'tcx>) -> R,\n ) -> R where {\n     let mut checker = TypeChecker::new(\n@@ -192,6 +196,7 @@ fn type_check_internal<'a, 'gcx, 'tcx, R>(\n         region_bound_pairs,\n         implicit_region_bound,\n         borrowck_context,\n+        universal_region_relations,\n     );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, mir);\n@@ -692,6 +697,7 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n+    universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -799,6 +805,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n+        universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n     ) -> Self {\n         TypeChecker {\n             infcx,\n@@ -810,6 +817,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             implicit_region_bound,\n             borrowck_context,\n             reported_errors: FxHashSet(),\n+            universal_region_relations,\n         }\n     }\n \n@@ -883,6 +891,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         )\n     }\n \n+    fn sub_types_or_anon(\n+        &mut self,\n+        sub: Ty<'tcx>,\n+        sup: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n+        if let Err(terr) = self.sub_types(sub, sup, locations) {\n+            if let TyKind::Opaque(..) = sup.sty {\n+                return self.eq_opaque_type_and_type(sub, sup, locations, category);\n+            } else {\n+                return Err(terr);\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn eq_types(\n         &mut self,\n         a: Ty<'tcx>,\n@@ -919,6 +944,111 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         )\n     }\n \n+    fn eq_opaque_type_and_type(\n+        &mut self,\n+        revealed_ty: Ty<'tcx>,\n+        anon_ty: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n+        let infcx = self.infcx;\n+        let tcx = infcx.tcx;\n+        let param_env = self.param_env;\n+        let mir_def_id = self.mir_def_id;\n+        let opaque_type_map =\n+            self.fully_perform_op(\n+                locations,\n+                CustomTypeOp::new(\n+                    |infcx| {\n+                        let mut obligations = ObligationAccumulator::default();\n+\n+                        let dummy_body_id = ObligationCause::dummy().body_id;\n+                        let (output_ty, opaque_type_map) =\n+                            obligations.add(infcx.instantiate_opaque_types(\n+                                mir_def_id,\n+                                dummy_body_id,\n+                                param_env,\n+                                &anon_ty,\n+                            ));\n+                        debug!(\n+                            \"eq_opaque_type_and_type: \\\n+                             instantiated output_ty={:?} \\\n+                             opaque_type_map={:#?} \\\n+                             revealed_ty={:?}\",\n+                            output_ty,\n+                            opaque_type_map,\n+                            revealed_ty\n+                        );\n+                        obligations.add(\n+                            infcx\n+                                .at(&ObligationCause::dummy(), param_env)\n+                                .eq(output_ty, revealed_ty)?,\n+                        );\n+\n+                        for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n+                            let opaque_defn_ty = tcx.type_of(opaque_def_id);\n+                            let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n+                            let opaque_defn_ty = renumber::renumber_regions(\n+                                infcx,\n+                                &opaque_defn_ty,\n+                            );\n+                            debug!(\n+                                \"eq_opaque_type_and_type: concrete_ty={:?} opaque_defn_ty={:?}\",\n+                                opaque_decl.concrete_ty,\n+                                opaque_defn_ty\n+                            );\n+                            obligations.add(\n+                                infcx\n+                                    .at(&ObligationCause::dummy(), param_env)\n+                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n+                            );\n+                        }\n+\n+                        debug!(\"eq_opaque_type_and_type: equated\");\n+\n+                        Ok(InferOk {\n+                            value: Some(opaque_type_map),\n+                            obligations: obligations.into_vec(),\n+                        })\n+                    },\n+                    || \"input_output\".to_string(),\n+                ),\n+            )?;\n+\n+        let universal_region_relations = match self.universal_region_relations {\n+            Some(rel) => rel,\n+            None => return Ok(()),\n+        };\n+\n+        // Finally, if we instantiated the anon types successfully, we\n+        // have to solve any bounds (e.g., `-> impl Iterator` needs to\n+        // prove that `T: Iterator` where `T` is the type we\n+        // instantiated it with).\n+        if let Some(opaque_type_map) = opaque_type_map {\n+            for (opaque_def_id, opaque_decl) in opaque_type_map {\n+                self.fully_perform_op(\n+                    locations,\n+                    category,\n+                    CustomTypeOp::new(\n+                        |_cx| {\n+                            infcx.constrain_opaque_type(\n+                                opaque_def_id,\n+                                &opaque_decl,\n+                                universal_region_relations\n+                            );\n+                            Ok(InferOk {\n+                                value: (),\n+                                obligations: vec![],\n+                            })\n+                        },\n+                        || \"opaque_type_map\".to_string(),\n+                    ),\n+                )?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n         self.infcx.tcx\n     }\n@@ -942,7 +1072,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(\n+                if let Err(terr) = self.sub_types_or_anon(\n                     rv_ty,\n                     place_ty,\n                     location.to_locations(),\n@@ -1235,7 +1365,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 let locations = term_location.to_locations();\n \n-                if let Err(terr) = self.sub_types(\n+                if let Err(terr) = self.sub_types_or_anon(\n                     sig.output(),\n                     dest_ty,\n                     locations,\n@@ -2104,6 +2234,7 @@ impl MirPass for TypeckMir {\n                 &[],\n                 None,\n                 None,\n+                None,\n                 |_| (),\n             );\n \n@@ -2128,3 +2259,21 @@ impl NormalizeLocation for Location {\n         Locations::Single(self)\n     }\n }\n+\n+#[derive(Debug, Default)]\n+struct ObligationAccumulator<'tcx> {\n+    obligations: PredicateObligations<'tcx>,\n+}\n+\n+impl<'tcx> ObligationAccumulator<'tcx> {\n+    fn add<T>(&mut self, value: InferOk<'tcx, T>) -> T {\n+        let InferOk { value, obligations } = value;\n+        self.obligations.extend(obligations);\n+        value\n+    }\n+\n+    fn into_vec(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+}\n+"}, {"sha": "7265d82935b5e555a1cf6ea4a36a05c41b677a82", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 103, "deletions": 83, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -65,7 +65,7 @@ nodes within the function.\n The types of top-level items, which never contain unbound type\n variables, are stored directly into the `tcx` tables.\n \n-n.b.: A type variable is not the same thing as a type parameter.  A\n+N.B.: A type variable is not the same thing as a type parameter.  A\n type variable is rather an \"instance\" of a type parameter: that is,\n given a generic function `fn foo<T>(t: T)`: while checking the\n function `foo`, the type `ty_param(0)` refers to the type `T`, which\n@@ -852,7 +852,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             check_abi(tcx, span, fn_sig.abi());\n \n-            // Compute the fty from point of view of inside fn.\n+            // Compute the fty from point of view of inside the fn.\n             let fn_sig =\n                 tcx.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n@@ -869,10 +869,20 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n+            let revealed_ty = if tcx.features().impl_trait_in_bindings {\n+                fcx.require_type_is_sized(expected_type, body.value.span, traits::SizedReturnType);\n+                fcx.instantiate_opaque_types_from_value(\n+                    id,\n+                    &expected_type\n+                )\n+            } else {\n+                expected_type\n+            };\n+\n             // Gather locals in statics (because of block expressions).\n             GatherLocalsVisitor { fcx: &fcx, parent_id: id, }.visit_body(body);\n \n-            fcx.check_expr_coercable_to_type(&body.value, expected_type);\n+            fcx.check_expr_coercable_to_type(&body.value, revealed_ty);\n \n             fcx\n         };\n@@ -957,9 +967,14 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n                 let o_ty = self.fcx.to_ty(&ty);\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} c_ty={:?}\", ty.hir_id, o_ty, 1);\n \n-                let revealed_ty = self.fcx.instantiate_opaque_types_from_value(\n-                    self.parent_id,\n-                    &o_ty);\n+                let revealed_ty = if self.fcx.tcx.features().impl_trait_in_bindings {\n+                    self.fcx.instantiate_opaque_types_from_value(\n+                        self.parent_id,\n+                        &o_ty\n+                    )\n+                } else {\n+                    o_ty\n+                };\n \n                 let c_ty = self.fcx.inh.infcx.canonicalize_response(&revealed_ty);\n                 self.fcx.tables.borrow_mut().user_provided_tys_mut().insert(ty.hir_id, c_ty);\n@@ -1288,90 +1303,96 @@ fn check_union<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     check_packed(tcx, span, def_id);\n }\n \n-pub fn check_item_type<'a,'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n-    debug!(\"check_item_type(it.id={}, it.name={})\",\n-           it.id,\n-           tcx.item_path_str(tcx.hir.local_def_id(it.id)));\n+pub fn check_item_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, it: &'tcx hir::Item) {\n+    debug!(\n+        \"check_item_type(it.id={}, it.name={})\",\n+        it.id,\n+        tcx.item_path_str(tcx.hir.local_def_id(it.id))\n+    );\n     let _indenter = indenter();\n     match it.node {\n-      // Consts can play a role in type-checking, so they are included here.\n-      hir::ItemKind::Static(..) => {\n-        let def_id = tcx.hir.local_def_id(it.id);\n-        tcx.typeck_tables_of(def_id);\n-        maybe_check_static_with_link_section(tcx, def_id, it.span);\n-      }\n-      hir::ItemKind::Const(..) => {\n-        tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n-      }\n-      hir::ItemKind::Enum(ref enum_definition, _) => {\n-        check_enum(tcx,\n-                   it.span,\n-                   &enum_definition.variants,\n-                   it.id);\n-      }\n-      hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n-      hir::ItemKind::Impl(.., ref impl_item_refs) => {\n-          debug!(\"ItemKind::Impl {} with id {}\", it.name, it.id);\n-          let impl_def_id = tcx.hir.local_def_id(it.id);\n-          if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n-              check_impl_items_against_trait(tcx,\n-                                             it.span,\n-                                             impl_def_id,\n-                                             impl_trait_ref,\n-                                             impl_item_refs);\n-              let trait_def_id = impl_trait_ref.def_id;\n-              check_on_unimplemented(tcx, trait_def_id, it);\n-          }\n-      }\n-      hir::ItemKind::Trait(..) => {\n-        let def_id = tcx.hir.local_def_id(it.id);\n-        check_on_unimplemented(tcx, def_id, it);\n-      }\n-      hir::ItemKind::Struct(..) => {\n-        check_struct(tcx, it.id, it.span);\n-      }\n-      hir::ItemKind::Union(..) => {\n-        check_union(tcx, it.id, it.span);\n-      }\n-      hir::ItemKind::Existential(..) |\n-      hir::ItemKind::Ty(..) => {\n-        let def_id = tcx.hir.local_def_id(it.id);\n-        let pty_ty = tcx.type_of(def_id);\n-        let generics = tcx.generics_of(def_id);\n-        check_bounds_are_used(tcx, &generics, pty_ty);\n-      }\n-      hir::ItemKind::ForeignMod(ref m) => {\n-        check_abi(tcx, it.span, m.abi);\n-\n-        if m.abi == Abi::RustIntrinsic {\n-            for item in &m.items {\n-                intrinsic::check_intrinsic_type(tcx, item);\n-            }\n-        } else if m.abi == Abi::PlatformIntrinsic {\n-            for item in &m.items {\n-                intrinsic::check_platform_intrinsic_type(tcx, item);\n+        // Consts can play a role in type-checking, so they are included here.\n+        hir::ItemKind::Static(..) => {\n+            let def_id = tcx.hir.local_def_id(it.id);\n+            tcx.typeck_tables_of(def_id);\n+            maybe_check_static_with_link_section(tcx, def_id, it.span);\n+        }\n+        hir::ItemKind::Const(..) => {\n+            tcx.typeck_tables_of(tcx.hir.local_def_id(it.id));\n+        }\n+        hir::ItemKind::Enum(ref enum_definition, _) => {\n+            check_enum(tcx, it.span, &enum_definition.variants, it.id);\n+        }\n+        hir::ItemKind::Fn(..) => {} // entirely within check_item_body\n+        hir::ItemKind::Impl(.., ref impl_item_refs) => {\n+            debug!(\"ItemKind::Impl {} with id {}\", it.name, it.id);\n+            let impl_def_id = tcx.hir.local_def_id(it.id);\n+            if let Some(impl_trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n+                check_impl_items_against_trait(\n+                    tcx,\n+                    it.span,\n+                    impl_def_id,\n+                    impl_trait_ref,\n+                    impl_item_refs,\n+                );\n+                let trait_def_id = impl_trait_ref.def_id;\n+                check_on_unimplemented(tcx, trait_def_id, it);\n             }\n-        } else {\n-            for item in &m.items {\n-                let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n-                if generics.params.len() - generics.own_counts().lifetimes != 0 {\n-                    let mut err = struct_span_err!(tcx.sess, item.span, E0044,\n-                        \"foreign items may not have type parameters\");\n-                    err.span_label(item.span, \"can't have type parameters\");\n-                    // FIXME: once we start storing spans for type arguments, turn this into a\n-                    // suggestion.\n-                    err.help(\"use specialization instead of type parameters by replacing them \\\n-                              with concrete types like `u32`\");\n-                    err.emit();\n+        }\n+        hir::ItemKind::Trait(..) => {\n+            let def_id = tcx.hir.local_def_id(it.id);\n+            check_on_unimplemented(tcx, def_id, it);\n+        }\n+        hir::ItemKind::Struct(..) => {\n+            check_struct(tcx, it.id, it.span);\n+        }\n+        hir::ItemKind::Union(..) => {\n+            check_union(tcx, it.id, it.span);\n+        }\n+        hir::ItemKind::Existential(..) | hir::ItemKind::Ty(..) => {\n+            let def_id = tcx.hir.local_def_id(it.id);\n+            let pty_ty = tcx.type_of(def_id);\n+            let generics = tcx.generics_of(def_id);\n+            check_bounds_are_used(tcx, &generics, pty_ty);\n+        }\n+        hir::ItemKind::ForeignMod(ref m) => {\n+            check_abi(tcx, it.span, m.abi);\n+\n+            if m.abi == Abi::RustIntrinsic {\n+                for item in &m.items {\n+                    intrinsic::check_intrinsic_type(tcx, item);\n+                }\n+            } else if m.abi == Abi::PlatformIntrinsic {\n+                for item in &m.items {\n+                    intrinsic::check_platform_intrinsic_type(tcx, item);\n                 }\n+            } else {\n+                for item in &m.items {\n+                    let generics = tcx.generics_of(tcx.hir.local_def_id(item.id));\n+                    if generics.params.len() - generics.own_counts().lifetimes != 0 {\n+                        let mut err = struct_span_err!(\n+                            tcx.sess,\n+                            item.span,\n+                            E0044,\n+                            \"foreign items may not have type parameters\"\n+                        );\n+                        err.span_label(item.span, \"can't have type parameters\");\n+                        // FIXME: once we start storing spans for type arguments, turn this into a\n+                        // suggestion.\n+                        err.help(\n+                            \"use specialization instead of type parameters by replacing them \\\n+                             with concrete types like `u32`\",\n+                        );\n+                        err.emit();\n+                    }\n \n-                if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.node {\n-                    require_c_abi_if_variadic(tcx, fn_decl, m.abi, item.span);\n+                    if let hir::ForeignItemKind::Fn(ref fn_decl, _, _) = item.node {\n+                        require_c_abi_if_variadic(tcx, fn_decl, m.abi, item.span);\n+                    }\n                 }\n             }\n         }\n-      }\n-      _ => {/* nothing to do */ }\n+        _ => { /* nothing to do */ }\n     }\n }\n \n@@ -3936,7 +3957,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n             hir::ExprKind::Path(ref qpath) => {\n                 let (def, opt_ty, segs) = self.resolve_ty_and_def_ufcs(qpath, expr.id, expr.span);\n-                debug!(\"path_foo: {:?} {:?}\", def, opt_ty);\n                 let ty = if def != Def::Err {\n                     self.instantiate_value_path(segs, opt_ty, def, expr.span, id).0\n                 } else {"}, {"sha": "eb40ea016303b2f7edb301b5e7c6a166f51ca97f", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -494,7 +494,7 @@ declare_features! (\n     // Allows `Self` in type definitions\n     (active, self_in_typedefs, \"1.30.0\", Some(49303), None),\n \n-    // unsized rvalues at arguments and parameters\n+    // Allows unsized rvalues at arguments and parameters\n     (active, unsized_locals, \"1.30.0\", Some(48055), None),\n \n     // #![test_runner]\n@@ -505,13 +505,16 @@ declare_features! (\n     (active, custom_inner_attributes, \"1.30.0\", Some(38356), None),\n \n     // Self struct constructor  (RFC 2302)\n-    (active, self_struct_ctor, \"1.31.0\", Some(51994), None),\n+    (active, self_struct_ctor, \"1.30.0\", Some(51994), None),\n \n     // allow mixing of bind-by-move in patterns and references to\n     // those identifiers in guards, *if* we are using MIR-borrowck\n     // (aka NLL). Essentially this means you need to be on\n     // edition:2018 or later.\n     (active, bind_by_move_pattern_guards, \"1.30.0\", Some(15287), None),\n+\n+    // Allows `impl Trait` in bindings (`let`, `const`, `static`)\n+    (active, impl_trait_in_bindings, \"1.30.0\", Some(34511), None),\n );\n \n declare_features! ("}, {"sha": "9c76719e26cf20fc6af6818464b590b26c88b14e", "filename": "src/test/ui/feature-gates/feature-gate-impl_trait_in_bindings.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.rs?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const FOO: impl Copy = 42;\n+\n+static BAR: impl Copy = 42;\n+\n+fn main() {\n+    let foo = impl Copy = 42;\n+}"}, {"sha": "52c99a7b159e381e8369aaa3630d8f9145124b1b", "filename": "src/test/ui/feature-gates/feature-gate-impl_trait_in_bindings.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-impl_trait_in_bindings.stderr?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -0,0 +1,21 @@\n+error: expected expression, found keyword `impl`\n+  --> $DIR/feature-gate-impl_trait_in_bindings.rs:16:15\n+   |\n+LL |     let foo = impl Copy = 42;\n+   |               ^^^^ expected expression\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-impl_trait_in_bindings.rs:11:12\n+   |\n+LL | const FOO: impl Copy = 42;\n+   |            ^^^^^^^^^\n+\n+error[E0562]: `impl Trait` not allowed outside of function and inherent method return types\n+  --> $DIR/feature-gate-impl_trait_in_bindings.rs:13:13\n+   |\n+LL | static BAR: impl Copy = 42;\n+   |             ^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0562`."}, {"sha": "4b476a0a645b1541900a37d9536985c75ceb5e98", "filename": "src/test/ui/feature-gates/feature-gate-self_in_typedefs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.rs?ref=218189536d95c12d7abbe01af3725c84a628bc51", "previous_filename": "src/test/ui/feature-gates/feature-gate-self-in-typedefs.rs"}, {"sha": "22ca92bbe1391b50c999faf0f5de838f19316c15", "filename": "src/test/ui/feature-gates/feature-gate-self_in_typedefs.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/218189536d95c12d7abbe01af3725c84a628bc51/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/218189536d95c12d7abbe01af3725c84a628bc51/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-self_in_typedefs.stderr?ref=218189536d95c12d7abbe01af3725c84a628bc51", "patch": "@@ -1,5 +1,5 @@\n error[E0411]: cannot find type `Self` in this scope\n-  --> $DIR/feature-gate-self-in-typedefs.rs:13:17\n+  --> $DIR/feature-gate-self_in_typedefs.rs:13:17\n    |\n LL |     Cons(T, &'a Self)\n    |                 ^^^^ `Self` is only available in traits and impls", "previous_filename": "src/test/ui/feature-gates/feature-gate-self-in-typedefs.stderr"}]}