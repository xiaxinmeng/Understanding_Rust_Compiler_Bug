{"sha": "3899f8da6b3da631a110041384a088403468d225", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4OTlmOGRhNmIzZGE2MzFhMTEwMDQxMzg0YTA4ODQwMzQ2OGQyMjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-02T18:01:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-02T18:01:16Z"}, "message": "auto merge of #10217 : alexcrichton/rust/less-reachable, r=pcwalton\n\nPreviously, all functions called by a reachable function were considered\r\nreachable, but this is only the case if the original function was possibly\r\ninlineable (if it's type generic or #[inline]-flagged).", "tree": {"sha": "9e23b48daab566da8e770c770fdd22b1f69cb847", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e23b48daab566da8e770c770fdd22b1f69cb847"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3899f8da6b3da631a110041384a088403468d225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3899f8da6b3da631a110041384a088403468d225", "html_url": "https://github.com/rust-lang/rust/commit/3899f8da6b3da631a110041384a088403468d225", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3899f8da6b3da631a110041384a088403468d225/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22dfdc927b65d2e6eb5f9a594615ac2e6a8425a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/22dfdc927b65d2e6eb5f9a594615ac2e6a8425a8", "html_url": "https://github.com/rust-lang/rust/commit/22dfdc927b65d2e6eb5f9a594615ac2e6a8425a8"}, {"sha": "681fda016979786da5d60a5c6d7fcf5c6c649c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/681fda016979786da5d60a5c6d7fcf5c6c649c86", "html_url": "https://github.com/rust-lang/rust/commit/681fda016979786da5d60a5c6d7fcf5c6c649c86"}], "stats": {"total": 184, "additions": 130, "deletions": 54}, "files": [{"sha": "840e3081656c097d637aa7b5e8270c5513cc0270", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 68, "deletions": 50, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/3899f8da6b3da631a110041384a088403468d225/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3899f8da6b3da631a110041384a088403468d225/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3899f8da6b3da631a110041384a088403468d225", "patch": "@@ -50,6 +50,7 @@ fn item_might_be_inlined(item: @ast::item) -> bool {\n     }\n \n     match item.node {\n+        ast::item_impl(ref generics, _, _, _) |\n         ast::item_fn(_, _, _, ref generics, _) => {\n             generics_require_inlining(generics)\n         }\n@@ -64,6 +65,25 @@ fn ty_method_might_be_inlined(ty_method: &ast::TypeMethod) -> bool {\n         generics_require_inlining(&ty_method.generics)\n }\n \n+fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::method,\n+                           impl_src: ast::DefId) -> bool {\n+    if attributes_specify_inlining(method.attrs) ||\n+        generics_require_inlining(&method.generics) {\n+        return true\n+    }\n+    if is_local(impl_src) {\n+        match tcx.items.find(&impl_src.node) {\n+            Some(&ast_map::node_item(item, _)) => item_might_be_inlined(item),\n+            Some(*) | None => {\n+                tcx.sess.span_bug(method.span, \"impl did is not an item\")\n+            }\n+        }\n+    } else {\n+        tcx.sess.span_bug(method.span, \"found a foreign impl as a parent of a \\\n+                                        local method\")\n+    }\n+}\n+\n // Returns true if the given trait method must be inlined because it may be\n // monomorphized or it was marked with `#[inline]`.\n fn trait_method_might_be_inlined(trait_method: &ast::trait_method) -> bool {\n@@ -100,50 +120,54 @@ impl Visitor<()> for MarkSymbolVisitor {\n \n     fn visit_expr(&mut self, expr:@ast::Expr, _:()) {\n \n-                match expr.node {\n-                    ast::ExprPath(_) => {\n-                        let def = match self.tcx.def_map.find(&expr.id) {\n-                            Some(&def) => def,\n-                            None => {\n-                                self.tcx.sess.span_bug(expr.span,\n-                                                  \"def ID not in def map?!\")\n-                            }\n-                        };\n+        match expr.node {\n+            ast::ExprPath(_) => {\n+                let def = match self.tcx.def_map.find(&expr.id) {\n+                    Some(&def) => def,\n+                    None => {\n+                        self.tcx.sess.span_bug(expr.span,\n+                                               \"def ID not in def map?!\")\n+                    }\n+                };\n \n-                        let def_id = def_id_of_def(def);\n+                let def_id = def_id_of_def(def);\n+                if ReachableContext::\n+                    def_id_represents_local_inlined_item(self.tcx, def_id) {\n+                        self.worklist.push(def_id.node)\n+                    }\n+                self.reachable_symbols.insert(def_id.node);\n+            }\n+            ast::ExprMethodCall(*) => {\n+                match self.method_map.find(&expr.id) {\n+                    Some(&typeck::method_map_entry {\n+                        origin: typeck::method_static(def_id),\n+                        _\n+                    }) => {\n                         if ReachableContext::\n-                                def_id_represents_local_inlined_item(self.tcx,\n-                                                                     def_id) {\n-                            self.worklist.push(def_id.node)\n-                        }\n+                            def_id_represents_local_inlined_item(\n+                                self.tcx,\n+                                def_id) {\n+                                self.worklist.push(def_id.node)\n+                            }\n                         self.reachable_symbols.insert(def_id.node);\n                     }\n-                    ast::ExprMethodCall(*) => {\n-                        match self.method_map.find(&expr.id) {\n-                            Some(&typeck::method_map_entry {\n-                                origin: typeck::method_static(def_id),\n-                                _\n-                            }) => {\n-                                if ReachableContext::\n-                                    def_id_represents_local_inlined_item(\n-                                        self.tcx,\n-                                        def_id) {\n-                                    self.worklist.push(def_id.node)\n-                                }\n-                                self.reachable_symbols.insert(def_id.node);\n-                            }\n-                            Some(_) => {}\n-                            None => {\n-                                self.tcx.sess.span_bug(expr.span,\n-                                                  \"method call expression \\\n+                    Some(_) => {}\n+                    None => {\n+                        self.tcx.sess.span_bug(expr.span,\n+                        \"method call expression \\\n                                                    not in method map?!\")\n-                            }\n-                        }\n                     }\n-                    _ => {}\n                 }\n+            }\n+            _ => {}\n+        }\n \n-                visit::walk_expr(self, expr, ())\n+        visit::walk_expr(self, expr, ())\n+    }\n+\n+    fn visit_item(&mut self, _item: @ast::item, _: ()) {\n+        // Do not recurse into items. These items will be added to the worklist\n+        // and recursed into manually if necessary.\n     }\n }\n \n@@ -263,8 +287,11 @@ impl ReachableContext {\n                 Some(&ast_map::node_item(item, _)) => {\n                     match item.node {\n                         ast::item_fn(_, _, _, _, ref search_block) => {\n-                            visit::walk_block(&mut visitor, search_block, ())\n+                            if item_might_be_inlined(item) {\n+                                visit::walk_block(&mut visitor, search_block, ())\n+                            }\n                         }\n+\n                         // Our recursion into modules involves looking up their\n                         // public reexports and the destinations of those\n                         // exports. Privacy will put them in the worklist, but\n@@ -331,8 +358,10 @@ impl ReachableContext {\n                         }\n                     }\n                 }\n-                Some(&ast_map::node_method(ref method, _, _)) => {\n-                    visit::walk_block(&mut visitor, &method.body, ())\n+                Some(&ast_map::node_method(method, did, _)) => {\n+                    if method_might_be_inlined(self.tcx, method, did) {\n+                        visit::walk_block(&mut visitor, &method.body, ())\n+                    }\n                 }\n                 // Nothing to recurse on for these\n                 Some(&ast_map::node_foreign_item(*)) |\n@@ -378,17 +407,6 @@ pub fn find_reachable(tcx: ty::ctxt,\n                       exp_map2: resolve::ExportMap2,\n                       exported_items: &privacy::ExportedItems)\n                       -> @mut HashSet<ast::NodeId> {\n-    // XXX(pcwalton): We only need to mark symbols that are exported. But this\n-    // is more complicated than just looking at whether the symbol is `pub`,\n-    // because it might be the target of a `pub use` somewhere. For now, I\n-    // think we are fine, because you can't `pub use` something that wasn't\n-    // exported due to the bug whereby `use` only looks through public\n-    // modules even if you're inside the module the `use` appears in. When\n-    // this bug is fixed, however, this code will need to be updated. Probably\n-    // the easiest way to fix this (although a conservative overapproximation)\n-    // is to have the name resolution pass mark all targets of a `pub use` as\n-    // \"must be reachable\".\n-\n     let reachable_context = ReachableContext::new(tcx, method_map, exp_map2);\n \n     // Step 1: Seed the worklist with all nodes which were found to be public as"}, {"sha": "b00e1fe383a829162d36f94b1c65d2b11764b340", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3899f8da6b3da631a110041384a088403468d225/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3899f8da6b3da631a110041384a088403468d225/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=3899f8da6b3da631a110041384a088403468d225", "patch": "@@ -2471,7 +2471,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n     match val {\n         Some(v) => v,\n         None => {\n-            let mut exprt = false;\n+            let mut foreign = false;\n             let item = ccx.tcx.items.get_copy(&id);\n             let val = match item {\n                 ast_map::node_item(i, pth) => {\n@@ -2584,7 +2584,6 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                                          get_item_val()\");\n                         }\n                         ast::provided(m) => {\n-                            exprt = true;\n                             register_method(ccx, id, pth, m)\n                         }\n                     }\n@@ -2596,7 +2595,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n \n                 ast_map::node_foreign_item(ni, abis, _, pth) => {\n                     let ty = ty::node_id_to_type(ccx.tcx, ni.id);\n-                    exprt = true;\n+                    foreign = true;\n \n                     match ni.node {\n                         ast::foreign_item_fn(*) => {\n@@ -2690,7 +2689,10 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                 }\n             };\n \n-            if !exprt && !ccx.reachable.contains(&id) {\n+            // foreign items (extern fns and extern statics) don't have internal\n+            // linkage b/c that doesn't quite make sense. Otherwise items can\n+            // have internal linkage if they're not reachable.\n+            if !foreign && !ccx.reachable.contains(&id) {\n                 lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n             }\n "}, {"sha": "ab3539ebf6f54773e6f7fd04cbf5e9b75b0dd59b", "filename": "src/test/auxiliary/linkage-visibility.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3899f8da6b3da631a110041384a088403468d225/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3899f8da6b3da631a110041384a088403468d225/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flinkage-visibility.rs?ref=3899f8da6b3da631a110041384a088403468d225", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::unstable::dynamic_lib::DynamicLibrary;\n+\n+#[no_mangle]\n+pub fn foo() { bar(); }\n+\n+pub fn foo2<T>() {\n+    fn bar2() {\n+        bar();\n+    }\n+    bar2();\n+}\n+\n+#[no_mangle]\n+fn bar() { }\n+\n+#[no_mangle]\n+fn baz() { }\n+\n+pub fn test() {\n+    let lib = DynamicLibrary::open(None).unwrap();\n+    unsafe {\n+        assert!(lib.symbol::<int>(\"foo\").is_ok());\n+        assert!(lib.symbol::<int>(\"baz\").is_err());\n+        assert!(lib.symbol::<int>(\"bar\").is_err());\n+    }\n+}"}, {"sha": "dff45a2ffad946a932f4dafcc02c268b62e7211c", "filename": "src/test/run-pass/linkage-visibility.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3899f8da6b3da631a110041384a088403468d225/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3899f8da6b3da631a110041384a088403468d225/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinkage-visibility.rs?ref=3899f8da6b3da631a110041384a088403468d225", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:linkage-visibility.rs\n+// xfail-fast windows doesn't like aux-build\n+\n+extern mod foo(name = \"linkage-visibility\");\n+\n+fn main() {\n+    foo::test();\n+    foo::foo2::<int>();\n+    foo::foo();\n+}"}]}