{"sha": "edd6d9ea37f55cce3298deb6ef271cb7d03a824a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZDZkOWVhMzdmNTVjY2UzMjk4ZGViNmVmMjcxY2I3ZDAzYTgyNGE=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-27T01:14:39Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-27T01:17:36Z"}, "message": "convert std::sync types to camelcase", "tree": {"sha": "b75cb0deead05c6b9b75003cd261367bc182dd2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b75cb0deead05c6b9b75003cd261367bc182dd2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edd6d9ea37f55cce3298deb6ef271cb7d03a824a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edd6d9ea37f55cce3298deb6ef271cb7d03a824a", "html_url": "https://github.com/rust-lang/rust/commit/edd6d9ea37f55cce3298deb6ef271cb7d03a824a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edd6d9ea37f55cce3298deb6ef271cb7d03a824a/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf1d2a7fef9a1962d9883eead2c67bfa391d8aae", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf1d2a7fef9a1962d9883eead2c67bfa391d8aae", "html_url": "https://github.com/rust-lang/rust/commit/cf1d2a7fef9a1962d9883eead2c67bfa391d8aae"}], "stats": {"total": 272, "additions": 137, "deletions": 135}, "files": [{"sha": "2349a0eec7f046ea5098345b473d7a6f9e0bd567", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/edd6d9ea37f55cce3298deb6ef271cb7d03a824a/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd6d9ea37f55cce3298deb6ef271cb7d03a824a/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=edd6d9ea37f55cce3298deb6ef271cb7d03a824a", "patch": "@@ -10,15 +10,16 @@ import unsafe::{SharedMutableState, shared_mutable_state,\n                 clone_shared_mutable_state, unwrap_shared_mutable_state,\n                 get_shared_mutable_state, get_shared_immutable_state};\n import sync;\n-import sync::{mutex, mutex_with_condvars, rwlock, rwlock_with_condvars};\n+import sync::{Mutex,  mutex,  mutex_with_condvars,\n+              RWlock, rwlock, rwlock_with_condvars};\n \n export arc, clone, get;\n export condvar, mutex_arc, mutex_arc_with_condvars, unwrap_mutex_arc;\n export rw_arc, rw_arc_with_condvars, rw_write_mode, rw_read_mode;\n export unwrap_rw_arc;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signalling.\n-struct condvar { is_mutex: bool; failed: &mut bool; cond: &sync::condvar; }\n+struct condvar { is_mutex: bool; failed: &mut bool; cond: &sync::Condvar; }\n \n impl &condvar {\n     /// Atomically exit the associated ARC and block until a signal is sent.\n@@ -113,7 +114,7 @@ fn unwrap<T: const send>(+rc: arc<T>) -> T {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct mutex_arc_inner<T: send> { lock: mutex; failed: bool; data: T; }\n+struct mutex_arc_inner<T: send> { lock: Mutex; failed: bool; data: T; }\n /// An ARC with mutable data protected by a blocking mutex.\n struct mutex_arc<T: send> { x: SharedMutableState<mutex_arc_inner<T>>; }\n \n@@ -234,7 +235,7 @@ struct poison_on_fail {\n  ****************************************************************************/\n \n #[doc(hidden)]\n-struct rw_arc_inner<T: const send> { lock: rwlock; failed: bool; data: T; }\n+struct rw_arc_inner<T: const send> { lock: RWlock; failed: bool; data: T; }\n /**\n  * A dual-mode ARC protected by a reader-writer lock. The data can be accessed\n  * mutably or immutably, and immutably-accessing tasks may run concurrently.\n@@ -383,17 +384,17 @@ fn unwrap_rw_arc<T: const send>(+arc: rw_arc<T>) -> T {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T: const send>(state: &r/mut rw_arc_inner<T>) -> &r/rwlock {\n+fn borrow_rwlock<T: const send>(state: &r/mut rw_arc_inner<T>) -> &r/RWlock {\n     unsafe { unsafe::transmute_immut(&mut state.lock) }\n }\n \n // FIXME (#3154) ice with struct/&<T> prevents these from being structs.\n \n /// The \"write permission\" token used for rw_arc.write_downgrade().\n enum rw_write_mode<T: const send> =\n-    (&mut T, sync::rwlock_write_mode, poison_on_fail);\n+    (&mut T, sync::RWlockWriteMode, poison_on_fail);\n /// The \"read permission\" token used for rw_arc.write_downgrade().\n-enum rw_read_mode<T:const send> = (&T, sync::rwlock_read_mode);\n+enum rw_read_mode<T:const send> = (&T, sync::RWlockReadMode);\n \n impl<T: const send> &rw_write_mode<T> {\n     /// Access the pre-downgrade rw_arc in write mode."}, {"sha": "03d7e30e89804d7febebddbde0fcbbd2770ec40e", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/edd6d9ea37f55cce3298deb6ef271cb7d03a824a/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/edd6d9ea37f55cce3298deb6ef271cb7d03a824a/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=edd6d9ea37f55cce3298deb6ef271cb7d03a824a", "patch": "@@ -50,6 +50,7 @@ mod cell;\n \n // Concurrency\n \n+#[warn(non_camel_case_types)]\n mod sync;\n mod arc;\n mod comm;"}, {"sha": "01bb89556c8b4390cc0779b1278d74ede2e8d0e4", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 128, "deletions": 128, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/edd6d9ea37f55cce3298deb6ef271cb7d03a824a/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edd6d9ea37f55cce3298deb6ef271cb7d03a824a/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=edd6d9ea37f55cce3298deb6ef271cb7d03a824a", "patch": "@@ -8,8 +8,8 @@\n  * in std.\n  */\n \n-export condvar, semaphore, mutex, mutex_with_condvars;\n-export rwlock, rwlock_with_condvars, rwlock_write_mode, rwlock_read_mode;\n+export Condvar, Semaphore, Mutex, mutex, mutex_with_condvars;\n+export RWlock, rwlock, rwlock_with_condvars, RWlockReadMode, RWlockWriteMode;\n \n import unsafe::{Exclusive, exclusive};\n \n@@ -19,22 +19,22 @@ import unsafe::{Exclusive, exclusive};\n \n // Each waiting task receives on one of these.\n #[doc(hidden)]\n-type wait_end = pipes::port_one<()>;\n+type WaitEnd = pipes::port_one<()>;\n #[doc(hidden)]\n-type signal_end = pipes::chan_one<()>;\n+type SignalEnd = pipes::chan_one<()>;\n // A doubly-ended queue of waiting tasks.\n #[doc(hidden)]\n-struct waitqueue { head: pipes::port<signal_end>;\n-                   tail: pipes::chan<signal_end>; }\n+struct Waitqueue { head: pipes::port<SignalEnd>;\n+                   tail: pipes::chan<SignalEnd>; }\n \n-fn new_waitqueue() -> waitqueue {\n+fn new_waitqueue() -> Waitqueue {\n     let (block_tail, block_head) = pipes::stream();\n-    waitqueue { head: block_head, tail: block_tail }\n+    Waitqueue { head: block_head, tail: block_tail }\n }\n \n // Signals one live task from the queue.\n #[doc(hidden)]\n-fn signal_waitqueue(q: &waitqueue) -> bool {\n+fn signal_waitqueue(q: &Waitqueue) -> bool {\n     // The peek is mandatory to make sure recv doesn't block.\n     if q.head.peek() {\n         // Pop and send a wakeup signal. If the waiter was killed, its port\n@@ -50,7 +50,7 @@ fn signal_waitqueue(q: &waitqueue) -> bool {\n }\n \n #[doc(hidden)]\n-fn broadcast_waitqueue(q: &waitqueue) -> uint {\n+fn broadcast_waitqueue(q: &Waitqueue) -> uint {\n     let mut count = 0;\n     while q.head.peek() {\n         if pipes::try_send_one(q.head.recv(), ()) {\n@@ -62,24 +62,24 @@ fn broadcast_waitqueue(q: &waitqueue) -> uint {\n \n // The building-block used to make semaphores, mutexes, and rwlocks.\n #[doc(hidden)]\n-struct sem_inner<Q> {\n+struct SemInner<Q> {\n     mut count: int;\n-    waiters:   waitqueue;\n+    waiters:   Waitqueue;\n     // Can be either unit or another waitqueue. Some sems shouldn't come with\n     // a condition variable attached, others should.\n     blocked:   Q;\n }\n #[doc(hidden)]\n-enum sem<Q: send> = Exclusive<sem_inner<Q>>;\n+enum Sem<Q: send> = Exclusive<SemInner<Q>>;\n \n #[doc(hidden)]\n-fn new_sem<Q: send>(count: int, +q: Q) -> sem<Q> {\n-    sem(exclusive(sem_inner {\n+fn new_sem<Q: send>(count: int, +q: Q) -> Sem<Q> {\n+    Sem(exclusive(SemInner {\n         mut count: count, waiters: new_waitqueue(), blocked: q }))\n }\n #[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint)\n-        -> sem<~[mut waitqueue]> {\n+        -> Sem<~[mut Waitqueue]> {\n     let mut queues = ~[mut];\n     for num_condvars.times {\n         vec::push(queues, new_waitqueue());\n@@ -88,7 +88,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-impl<Q: send> &sem<Q> {\n+impl<Q: send> &Sem<Q> {\n     fn acquire() {\n         let mut waiter_nobe = None;\n         unsafe {\n@@ -122,28 +122,28 @@ impl<Q: send> &sem<Q> {\n         }\n     }\n }\n-// FIXME(#3154) move both copies of this into sem<Q>, and unify the 2 structs\n+// FIXME(#3154) move both copies of this into Sem<Q>, and unify the 2 structs\n #[doc(hidden)]\n-impl &sem<()> {\n+impl &Sem<()> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 self.acquire();\n-                release = Some(sem_release(self));\n+                release = Some(SemRelease(self));\n             }\n         }\n         blk()\n     }\n }\n #[doc(hidden)]\n-impl &sem<~[mut waitqueue]> {\n+impl &Sem<~[mut Waitqueue]> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n                 self.acquire();\n-                release = Some(sem_and_signal_release(self));\n+                release = Some(SemAndSignalRelease(self));\n             }\n         }\n         blk()\n@@ -152,22 +152,22 @@ impl &sem<~[mut waitqueue]> {\n \n // FIXME(#3136) should go inside of access()\n #[doc(hidden)]\n-struct sem_release {\n-    sem: &sem<()>;\n-    new(sem: &sem<()>) { self.sem = sem; }\n+struct SemRelease {\n+    sem: &Sem<()>;\n+    new(sem: &Sem<()>) { self.sem = sem; }\n     drop { self.sem.release(); }\n }\n #[doc(hidden)]\n-struct sem_and_signal_release {\n-    sem: &sem<~[mut waitqueue]>;\n-    new(sem: &sem<~[mut waitqueue]>) { self.sem = sem; }\n+struct SemAndSignalRelease {\n+    sem: &Sem<~[mut Waitqueue]>;\n+    new(sem: &Sem<~[mut Waitqueue]>) { self.sem = sem; }\n     drop { self.sem.release(); }\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-struct condvar { priv sem: &sem<~[mut waitqueue]>; drop { } }\n+struct Condvar { priv sem: &Sem<~[mut Waitqueue]>; drop { } }\n \n-impl &condvar {\n+impl &Condvar {\n     /**\n      * Atomically drop the associated lock, and block until a signal is sent.\n      *\n@@ -218,7 +218,7 @@ impl &condvar {\n                 // unkillably reacquire the lock needs to happen atomically\n                 // wrt enqueuing.\n                 if out_of_bounds.is_none() {\n-                    reacquire = Some(sem_and_signal_reacquire(self.sem));\n+                    reacquire = Some(SemAndSignalReacquire(self.sem));\n                 }\n             }\n         }\n@@ -232,9 +232,9 @@ impl &condvar {\n         // This is needed for a failing condition variable to reacquire the\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n-        struct sem_and_signal_reacquire {\n-            sem: &sem<~[mut waitqueue]>;\n-            new(sem: &sem<~[mut waitqueue]>) { self.sem = sem; }\n+        struct SemAndSignalReacquire {\n+            sem: &Sem<~[mut Waitqueue]>;\n+            new(sem: &Sem<~[mut Waitqueue]>) { self.sem = sem; }\n             drop unsafe {\n                 // Needs to succeed, instead of itself dying.\n                 do task::unkillable {\n@@ -308,10 +308,10 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n }\n \n #[doc(hidden)]\n-impl &sem<~[mut waitqueue]> {\n+impl &Sem<~[mut Waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n-    fn access_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n-        do self.access { blk(&condvar { sem: self }) }\n+    fn access_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n+        do self.access { blk(&Condvar { sem: self }) }\n     }\n }\n \n@@ -320,16 +320,16 @@ impl &sem<~[mut waitqueue]> {\n  ****************************************************************************/\n \n /// A counting, blocking, bounded-waiting semaphore.\n-struct semaphore { priv sem: sem<()>; }\n+struct Semaphore { priv sem: Sem<()>; }\n \n /// Create a new semaphore with the specified count.\n-fn semaphore(count: int) -> semaphore {\n-    semaphore { sem: new_sem(count, ()) }\n+fn semaphore(count: int) -> Semaphore {\n+    Semaphore { sem: new_sem(count, ()) }\n }\n \n-impl &semaphore {\n+impl &Semaphore {\n     /// Create a new handle to the semaphore.\n-    fn clone() -> semaphore { semaphore { sem: sem((*self.sem).clone()) } }\n+    fn clone() -> Semaphore { Semaphore { sem: Sem((*self.sem).clone()) } }\n \n     /**\n      * Acquire a resource represented by the semaphore. Blocks if necessary\n@@ -359,29 +359,29 @@ impl &semaphore {\n  * A task which fails while holding a mutex will unlock the mutex as it\n  * unwinds.\n  */\n-struct mutex { priv sem: sem<~[mut waitqueue]>; }\n+struct Mutex { priv sem: Sem<~[mut Waitqueue]>; }\n \n /// Create a new mutex, with one associated condvar.\n-fn mutex() -> mutex { mutex_with_condvars(1) }\n+fn mutex() -> Mutex { mutex_with_condvars(1) }\n /**\n  * Create a new mutex, with a specified number of associated condvars. This\n  * will allow calling wait_on/signal_on/broadcast_on with condvar IDs between\n  * 0 and num_condvars-1. (If num_condvars is 0, lock_cond will be allowed but\n  * any operations on the condvar will fail.)\n  */\n-fn mutex_with_condvars(num_condvars: uint) -> mutex {\n-    mutex { sem: new_sem_and_signal(1, num_condvars) }\n+fn mutex_with_condvars(num_condvars: uint) -> Mutex {\n+    Mutex { sem: new_sem_and_signal(1, num_condvars) }\n }\n \n-impl &mutex {\n+impl &Mutex {\n     /// Create a new handle to the mutex.\n-    fn clone() -> mutex { mutex { sem: sem((*self.sem).clone()) } }\n+    fn clone() -> Mutex { Mutex { sem: Sem((*self.sem).clone()) } }\n \n     /// Run a function with ownership of the mutex.\n     fn lock<U>(blk: fn() -> U) -> U { (&self.sem).access(blk) }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n-    fn lock_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n+    fn lock_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n         (&self.sem).access_cond(blk)\n     }\n }\n@@ -393,7 +393,7 @@ impl &mutex {\n // NB: Wikipedia - Readers-writers_problem#The_third_readers-writers_problem\n \n #[doc(hidden)]\n-struct rwlock_inner {\n+struct RWlockInner {\n     read_mode:  bool;\n     read_count: uint;\n }\n@@ -405,31 +405,31 @@ struct rwlock_inner {\n  * A task which fails while holding an rwlock will unlock the rwlock as it\n  * unwinds.\n  */\n-struct rwlock {\n-    /* priv */ order_lock:  semaphore;\n-    /* priv */ access_lock: sem<~[mut waitqueue]>;\n-    /* priv */ state:       Exclusive<rwlock_inner>;\n+struct RWlock {\n+    /* priv */ order_lock:  Semaphore;\n+    /* priv */ access_lock: Sem<~[mut Waitqueue]>;\n+    /* priv */ state:       Exclusive<RWlockInner>;\n }\n \n /// Create a new rwlock, with one associated condvar.\n-fn rwlock() -> rwlock { rwlock_with_condvars(1) }\n+fn rwlock() -> RWlock { rwlock_with_condvars(1) }\n \n /**\n  * Create a new rwlock, with a specified number of associated condvars.\n  * Similar to mutex_with_condvars.\n  */\n-fn rwlock_with_condvars(num_condvars: uint) -> rwlock {\n-    rwlock { order_lock: semaphore(1),\n+fn rwlock_with_condvars(num_condvars: uint) -> RWlock {\n+    RWlock { order_lock: semaphore(1),\n              access_lock: new_sem_and_signal(1, num_condvars),\n-             state: exclusive(rwlock_inner { read_mode:  false,\n+             state: exclusive(RWlockInner { read_mode:  false,\n                                              read_count: 0 }) }\n }\n \n-impl &rwlock {\n+impl &RWlock {\n     /// Create a new handle to the rwlock.\n-    fn clone() -> rwlock {\n-        rwlock { order_lock:  (&(self.order_lock)).clone(),\n-                 access_lock: sem((*self.access_lock).clone()),\n+    fn clone() -> RWlock {\n+        RWlock { order_lock:  (&(self.order_lock)).clone(),\n+                 access_lock: Sem((*self.access_lock).clone()),\n                  state:       self.state.clone() }\n     }\n \n@@ -458,7 +458,7 @@ impl &rwlock {\n                         }\n                     }\n                 }\n-                release = Some(rwlock_release_read(self));\n+                release = Some(RWlockReleaseRead(self));\n             }\n         }\n         blk()\n@@ -486,7 +486,7 @@ impl &rwlock {\n      * the waiting task is signalled. (Note: a writer that waited and then\n      * was signalled might reacquire the lock before other waiting writers.)\n      */\n-    fn write_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n+    fn write_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n         // NB: You might think I should thread the order_lock into the cond\n         // wait call, so that it gets waited on before access_lock gets\n         // reacquired upon being woken up. However, (a) this would be not\n@@ -521,7 +521,7 @@ impl &rwlock {\n      * }\n      * ~~~\n      */\n-    fn write_downgrade<U>(blk: fn(+rwlock_write_mode) -> U) -> U {\n+    fn write_downgrade<U>(blk: fn(+RWlockWriteMode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above.\n         // The exit path is conditional on whether the caller downgrades.\n         let mut _release = None;\n@@ -531,13 +531,13 @@ impl &rwlock {\n                 (&self.access_lock).acquire();\n                 (&self.order_lock).release();\n             }\n-            _release = Some(rwlock_release_downgrade(self));\n+            _release = Some(RWlockReleaseDowngrade(self));\n         }\n-        blk(rwlock_write_mode { lock: self })\n+        blk(RWlockWriteMode { lock: self })\n     }\n \n     /// To be called inside of the write_downgrade block.\n-    fn downgrade(+token: rwlock_write_mode/&a) -> rwlock_read_mode/&a {\n+    fn downgrade(+token: RWlockWriteMode/&a) -> RWlockReadMode/&a {\n         if !ptr::ref_eq(self, token.lock) {\n             fail ~\"Can't downgrade() with a different rwlock's write_mode!\";\n         }\n@@ -559,15 +559,15 @@ impl &rwlock {\n                 }\n             }\n         }\n-        rwlock_read_mode { lock: token.lock }\n+        RWlockReadMode { lock: token.lock }\n     }\n }\n \n // FIXME(#3136) should go inside of read()\n #[doc(hidden)]\n-struct rwlock_release_read {\n-    lock: &rwlock;\n-    new(lock: &rwlock) { self.lock = lock; }\n+struct RWlockReleaseRead {\n+    lock: &RWlock;\n+    new(lock: &RWlock) { self.lock = lock; }\n     drop unsafe {\n         do task::unkillable {\n             let mut last_reader = false;\n@@ -589,9 +589,9 @@ struct rwlock_release_read {\n \n // FIXME(#3136) should go inside of downgrade()\n #[doc(hidden)]\n-struct rwlock_release_downgrade {\n-    lock: &rwlock;\n-    new(lock: &rwlock) { self.lock = lock; }\n+struct RWlockReleaseDowngrade {\n+    lock: &RWlock;\n+    new(lock: &RWlock) { self.lock = lock; }\n     drop unsafe {\n         do task::unkillable {\n             let mut writer_or_last_reader = false;\n@@ -619,19 +619,19 @@ struct rwlock_release_downgrade {\n }\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n-struct rwlock_write_mode { /* priv */ lock: &rwlock; drop { } }\n+struct RWlockWriteMode { /* priv */ lock: &RWlock; drop { } }\n /// The \"read permission\" token used for rwlock.write_downgrade().\n-struct rwlock_read_mode  { priv lock: &rwlock; drop { } }\n+struct RWlockReadMode  { priv lock: &RWlock; drop { } }\n \n-impl &rwlock_write_mode {\n+impl &RWlockWriteMode {\n     /// Access the pre-downgrade rwlock in write mode.\n     fn write<U>(blk: fn() -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n-    fn write_cond<U>(blk: fn(c: &condvar) -> U) -> U {\n-        blk(&condvar { sem: &self.lock.access_lock })\n+    fn write_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n+        blk(&Condvar { sem: &self.lock.access_lock })\n     }\n }\n-impl &rwlock_read_mode {\n+impl &RWlockReadMode {\n     /// Access the post-downgrade rwlock in read mode.\n     fn read<U>(blk: fn() -> U) -> U { blk() }\n }\n@@ -761,7 +761,7 @@ mod tests {\n \n         assert *sharedstate == 20;\n \n-        fn access_shared(sharedstate: &mut int, m: &mutex, n: uint) {\n+        fn access_shared(sharedstate: &mut int, m: &Mutex, n: uint) {\n             for n.times {\n                 do m.lock {\n                     let oldval = *sharedstate;\n@@ -908,7 +908,7 @@ mod tests {\n                     do mi.lock_cond |cond| {\n                         let c = option::swap_unwrap(c);\n                         c.send(()); // tell sibling to go ahead\n-                        let _z = send_on_failure(c);\n+                        let _z = SendOnFailure(c);\n                         cond.wait(); // block forever\n                     }\n                 }\n@@ -927,7 +927,7 @@ mod tests {\n             let woken = cond.broadcast();\n             assert woken == 0;\n         }\n-        struct send_on_failure {\n+        struct SendOnFailure {\n             c: pipes::chan<()>;\n             new(+c: pipes::chan<()>) { self.c = c; }\n             drop { self.c.send(()); }\n@@ -990,26 +990,26 @@ mod tests {\n      * Reader/writer lock tests\n      ************************************************************************/\n     #[cfg(test)]\n-    enum rwlock_mode { read, write, downgrade, downgrade_read }\n+    enum RWlockMode { Read, Write, Downgrade, DowngradeRead }\n     #[cfg(test)]\n-    fn lock_rwlock_in_mode(x: &rwlock, mode: rwlock_mode, blk: fn()) {\n+    fn lock_rwlock_in_mode(x: &RWlock, mode: RWlockMode, blk: fn()) {\n         match mode {\n-            read => x.read(blk),\n-            write => x.write(blk),\n-            downgrade =>\n+            Read => x.read(blk),\n+            Write => x.write(blk),\n+            Downgrade =>\n                 do x.write_downgrade |mode| {\n                     (&mode).write(blk);\n                 },\n-            downgrade_read =>\n+            DowngradeRead =>\n                 do x.write_downgrade |mode| {\n                     let mode = x.downgrade(mode);\n                     (&mode).read(blk);\n                 },\n         }\n     }\n     #[cfg(test)]\n-    fn test_rwlock_exclusion(+x: ~rwlock, mode1: rwlock_mode,\n-                             mode2: rwlock_mode) {\n+    fn test_rwlock_exclusion(+x: ~RWlock, mode1: RWlockMode,\n+                             mode2: RWlockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n         let (c,p) = pipes::stream();\n@@ -1027,7 +1027,7 @@ mod tests {\n \n         assert *sharedstate == 20;\n \n-        fn access_shared(sharedstate: &mut int, x: &rwlock, mode: rwlock_mode,\n+        fn access_shared(sharedstate: &mut int, x: &RWlock, mode: RWlockMode,\n                          n: uint) {\n             for n.times {\n                 do lock_rwlock_in_mode(x, mode) {\n@@ -1040,21 +1040,21 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_wont_modify_the_data() {\n-        test_rwlock_exclusion(~rwlock(), read, write);\n-        test_rwlock_exclusion(~rwlock(), write, read);\n-        test_rwlock_exclusion(~rwlock(), read, downgrade);\n-        test_rwlock_exclusion(~rwlock(), downgrade, read);\n+        test_rwlock_exclusion(~rwlock(), Read, Write);\n+        test_rwlock_exclusion(~rwlock(), Write, Read);\n+        test_rwlock_exclusion(~rwlock(), Read, Downgrade);\n+        test_rwlock_exclusion(~rwlock(), Downgrade, Read);\n     }\n     #[test]\n     fn test_rwlock_writers_and_writers() {\n-        test_rwlock_exclusion(~rwlock(), write, write);\n-        test_rwlock_exclusion(~rwlock(), write, downgrade);\n-        test_rwlock_exclusion(~rwlock(), downgrade, write);\n-        test_rwlock_exclusion(~rwlock(), downgrade, downgrade);\n+        test_rwlock_exclusion(~rwlock(), Write, Write);\n+        test_rwlock_exclusion(~rwlock(), Write, Downgrade);\n+        test_rwlock_exclusion(~rwlock(), Downgrade, Write);\n+        test_rwlock_exclusion(~rwlock(), Downgrade, Downgrade);\n     }\n     #[cfg(test)]\n-    fn test_rwlock_handshake(+x: ~rwlock, mode1: rwlock_mode,\n-                             mode2: rwlock_mode, make_mode2_go_first: bool) {\n+    fn test_rwlock_handshake(+x: ~RWlock, mode1: RWlockMode,\n+                             mode2: RWlockMode, make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = ~x.clone();\n         let (c1,p1) = pipes::stream();\n@@ -1084,22 +1084,22 @@ mod tests {\n     }\n     #[test]\n     fn test_rwlock_readers_and_readers() {\n-        test_rwlock_handshake(~rwlock(), read, read, false);\n+        test_rwlock_handshake(~rwlock(), Read, Read, false);\n         // The downgrader needs to get in before the reader gets in, otherwise\n         // they cannot end up reading at the same time.\n-        test_rwlock_handshake(~rwlock(), downgrade_read, read, false);\n-        test_rwlock_handshake(~rwlock(), read, downgrade_read, true);\n+        test_rwlock_handshake(~rwlock(), DowngradeRead, Read, false);\n+        test_rwlock_handshake(~rwlock(), Read, DowngradeRead, true);\n         // Two downgrade_reads can never both end up reading at the same time.\n     }\n     #[test]\n     fn test_rwlock_downgrade_unlock() {\n         // Tests that downgrade can unlock the lock in both modes\n         let x = ~rwlock();\n-        do lock_rwlock_in_mode(x, downgrade) { }\n-        test_rwlock_handshake(x, read, read, false);\n+        do lock_rwlock_in_mode(x, Downgrade) { }\n+        test_rwlock_handshake(x, Read, Read, false);\n         let y = ~rwlock();\n-        do lock_rwlock_in_mode(y, downgrade_read) { }\n-        test_rwlock_exclusion(y, write, write);\n+        do lock_rwlock_in_mode(y, DowngradeRead) { }\n+        test_rwlock_exclusion(y, Write, Write);\n     }\n     #[test]\n     fn test_rwlock_read_recursive() {\n@@ -1145,7 +1145,7 @@ mod tests {\n     fn test_rwlock_cond_broadcast_helper(num_waiters: uint, dg1: bool,\n                                          dg2: bool) {\n         // Much like the mutex broadcast test. Downgrade-enabled.\n-        fn lock_cond(x: &rwlock, downgrade: bool, blk: fn(c: &condvar)) {\n+        fn lock_cond(x: &RWlock, downgrade: bool, blk: fn(c: &Condvar)) {\n             if downgrade {\n                 do x.write_downgrade |mode| {\n                     (&mode).write_cond(blk)\n@@ -1191,7 +1191,7 @@ mod tests {\n         test_rwlock_cond_broadcast_helper(12, false, false);\n     }\n     #[cfg(test)] #[ignore(cfg(windows))]\n-    fn rwlock_kill_helper(mode1: rwlock_mode, mode2: rwlock_mode) {\n+    fn rwlock_kill_helper(mode1: RWlockMode, mode2: RWlockMode) {\n         // Mutex must get automatically unlocked if failed/killed within.\n         let x = ~rwlock();\n         let x2 = ~x.clone();\n@@ -1206,27 +1206,27 @@ mod tests {\n         do lock_rwlock_in_mode(x, mode2) { }\n     }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_reader_killed_writer() { rwlock_kill_helper(read, write); }\n+    fn test_rwlock_reader_killed_writer() { rwlock_kill_helper(Read, Write); }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_writer_killed_reader() { rwlock_kill_helper(write,read ); }\n+    fn test_rwlock_writer_killed_reader() { rwlock_kill_helper(Write,Read ); }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_reader_killed_reader() { rwlock_kill_helper(read, read ); }\n+    fn test_rwlock_reader_killed_reader() { rwlock_kill_helper(Read, Read ); }\n     #[test] #[ignore(cfg(windows))]\n-    fn test_rwlock_writer_killed_writer() { rwlock_kill_helper(write,write); }\n+    fn test_rwlock_writer_killed_writer() { rwlock_kill_helper(Write,Write); }\n     #[test] #[ignore(cfg(windows))]\n     fn test_rwlock_kill_downgrader() {\n-        rwlock_kill_helper(downgrade, read);\n-        rwlock_kill_helper(read, downgrade);\n-        rwlock_kill_helper(downgrade, write);\n-        rwlock_kill_helper(write, downgrade);\n-        rwlock_kill_helper(downgrade_read, read);\n-        rwlock_kill_helper(read, downgrade_read);\n-        rwlock_kill_helper(downgrade_read, write);\n-        rwlock_kill_helper(write, downgrade_read);\n-        rwlock_kill_helper(downgrade_read, downgrade);\n-        rwlock_kill_helper(downgrade_read, downgrade);\n-        rwlock_kill_helper(downgrade, downgrade_read);\n-        rwlock_kill_helper(downgrade, downgrade_read);\n+        rwlock_kill_helper(Downgrade, Read);\n+        rwlock_kill_helper(Read, Downgrade);\n+        rwlock_kill_helper(Downgrade, Write);\n+        rwlock_kill_helper(Write, Downgrade);\n+        rwlock_kill_helper(DowngradeRead, Read);\n+        rwlock_kill_helper(Read, DowngradeRead);\n+        rwlock_kill_helper(DowngradeRead, Write);\n+        rwlock_kill_helper(Write, DowngradeRead);\n+        rwlock_kill_helper(DowngradeRead, Downgrade);\n+        rwlock_kill_helper(DowngradeRead, Downgrade);\n+        rwlock_kill_helper(Downgrade, DowngradeRead);\n+        rwlock_kill_helper(Downgrade, DowngradeRead);\n     }\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     fn test_rwlock_downgrade_cant_swap() {"}]}