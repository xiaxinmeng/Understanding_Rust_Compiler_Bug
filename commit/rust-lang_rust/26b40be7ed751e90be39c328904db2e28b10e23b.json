{"sha": "26b40be7ed751e90be39c328904db2e28b10e23b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YjQwYmU3ZWQ3NTFlOTBiZTM5YzMyODkwNGRiMmUyOGIxMGUyM2I=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-08-29T10:00:39Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-08-29T12:44:04Z"}, "message": "doc: Runnable examples logging.\n\nAlso use //! Instead of /*! in liblog.", "tree": {"sha": "efb1cb056da462685fa2e3bc707ce1afd61645e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efb1cb056da462685fa2e3bc707ce1afd61645e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26b40be7ed751e90be39c328904db2e28b10e23b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26b40be7ed751e90be39c328904db2e28b10e23b", "html_url": "https://github.com/rust-lang/rust/commit/26b40be7ed751e90be39c328904db2e28b10e23b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26b40be7ed751e90be39c328904db2e28b10e23b/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dee8423531bf88752e14ebfbdc2c1d1ade8a8fa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/dee8423531bf88752e14ebfbdc2c1d1ade8a8fa7", "html_url": "https://github.com/rust-lang/rust/commit/dee8423531bf88752e14ebfbdc2c1d1ade8a8fa7"}], "stats": {"total": 377, "additions": 236, "deletions": 141}, "files": [{"sha": "32222fb16ce61a9eb6ee1d8f2e7ea920ae1452dd", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 148, "deletions": 114, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/26b40be7ed751e90be39c328904db2e28b10e23b/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b40be7ed751e90be39c328904db2e28b10e23b/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=26b40be7ed751e90be39c328904db2e28b10e23b", "patch": "@@ -8,120 +8,154 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Utilities for program-wide and customizable logging\n-\n-## Example\n-\n-```\n-#![feature(phase)]\n-#[phase(plugin, link)] extern crate log;\n-\n-fn main() {\n-    debug!(\"this is a debug {}\", \"message\");\n-    error!(\"this is printed by default\");\n-\n-    if log_enabled!(log::INFO) {\n-        let x = 3i * 4i; // expensive computation\n-        info!(\"the answer was: {}\", x);\n-    }\n-}\n-```\n-\n-## Logging Macros\n-\n-There are five macros that the logging subsystem uses:\n-\n-* `log!(level, ...)` - the generic logging macro, takes a level as a u32 and any\n-                       related `format!` arguments\n-* `debug!(...)` - a macro hard-wired to the log level of `DEBUG`\n-* `info!(...)` - a macro hard-wired to the log level of `INFO`\n-* `warn!(...)` - a macro hard-wired to the log level of `WARN`\n-* `error!(...)` - a macro hard-wired to the log level of `ERROR`\n-\n-All of these macros use the same style of syntax as the `format!` syntax\n-extension. Details about the syntax can be found in the documentation of\n-`std::fmt` along with the Rust tutorial/manual.\n-\n-If you want to check at runtime if a given logging level is enabled (e.g. if the\n-information you would want to log is expensive to produce), you can use the\n-following macro:\n-\n-* `log_enabled!(level)` - returns true if logging of the given level is enabled\n-\n-## Enabling logging\n-\n-Log levels are controlled on a per-module basis, and by default all logging is\n-disabled except for `error!` (a log level of 1). Logging is controlled via the\n-`RUST_LOG` environment variable. The value of this environment variable is a\n-comma-separated list of logging directives. A logging directive is of the form:\n-\n-```text\n-path::to::module=log_level\n-```\n-\n-The path to the module is rooted in the name of the crate it was compiled for,\n-so if your program is contained in a file `hello.rs`, for example, to turn on\n-logging for this file you would use a value of `RUST_LOG=hello`.\n-Furthermore, this path is a prefix-search, so all modules nested in the\n-specified module will also have logging enabled.\n-\n-The actual `log_level` is optional to specify. If omitted, all logging will be\n-enabled. If specified, the it must be either a numeric in the range of 1-255, or\n-it must be one of the strings `debug`, `error`, `info`, or `warn`. If a numeric\n-is specified, then all logging less than or equal to that numeral is enabled.\n-For example, if logging level 3 is active, error, warn, and info logs will be\n-printed, but debug will be omitted.\n-\n-As the log level for a module is optional, the module to enable logging for is\n-also optional. If only a `log_level` is provided, then the global log level for\n-all modules is set to this value.\n-\n-Some examples of valid values of `RUST_LOG` are:\n-\n-* `hello` turns on all logging for the 'hello' module\n-* `info` turns on all info logging\n-* `hello=debug` turns on debug logging for 'hello'\n-* `hello=3` turns on info logging for 'hello'\n-* `hello,std::option` turns on hello, and std's option logging\n-* `error,hello=warn` turn on global error logging and also warn for hello\n-\n-## Filtering results\n-\n-A RUST_LOG directive may include a regex filter. The syntax is to append `/`\n-followed by a regex. Each message is checked against the regex, and is only\n-logged if it matches. Note that the matching is done after formatting the log\n-string but before adding any logging meta-data. There is a single filter for all\n-modules.\n-\n-Some examples:\n-\n-* `hello/foo` turns on all logging for the 'hello' module where the log message\n-includes 'foo'.\n-* `info/f.o` turns on all info logging where the log message includes 'foo',\n-'f1o', 'fao', etc.\n-* `hello=debug/foo*foo` turns on debug logging for 'hello' where the the log\n-message includes 'foofoo' or 'fofoo' or 'fooooooofoo', etc.\n-* `error,hello=warn/[0-9] scopes` turn on global error logging and also warn for\n- hello. In both cases the log message must include a single digit number\n- followed by 'scopes'\n-\n-## Performance and Side Effects\n-\n-Each of these macros will expand to code similar to:\n-\n-```rust,ignore\n-if log_level <= my_module_log_level() {\n-    ::log::log(log_level, format!(...));\n-}\n-```\n-\n-What this means is that each of these macros are very cheap at runtime if\n-they're turned off (just a load and an integer comparison). This also means that\n-if logging is disabled, none of the components of the log will be executed.\n-\n-*/\n+//! Utilities for program-wide and customizable logging\n+//!\n+//! ## Example\n+//!\n+//! ```\n+//! #![feature(phase)]\n+//! #[phase(plugin, link)] extern crate log;\n+//!\n+//! fn main() {\n+//!     debug!(\"this is a debug {}\", \"message\");\n+//!     error!(\"this is printed by default\");\n+//!\n+//!     if log_enabled!(log::INFO) {\n+//!         let x = 3i * 4i; // expensive computation\n+//!         info!(\"the answer was: {}\", x);\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! Assumes the binary is `main`:\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=error ./main\n+//! ERROR:main: this is printed by default\n+//! ```\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=info ./main\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=debug ./main\n+//! DEBUG:main: this is a debug message\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! You can also set the log level on a per module basis:\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=main=info ./main\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//! And enable all logging:\n+//!\n+//! ```{.bash}\n+//! $ RUST_LOG=main ./main\n+//! DEBUG:main: this is a debug message\n+//! ERROR:main: this is printed by default\n+//! INFO:main: the answer was: 12\n+//! ```\n+//!\n+//!\n+//! ## Logging Macros\n+//!\n+//! There are five macros that the logging subsystem uses:\n+//!\n+//! * `log!(level, ...)` - the generic logging macro, takes a level as a u32 and any\n+//!                        related `format!` arguments\n+//! * `debug!(...)` - a macro hard-wired to the log level of `DEBUG`\n+//! * `info!(...)` - a macro hard-wired to the log level of `INFO`\n+//! * `warn!(...)` - a macro hard-wired to the log level of `WARN`\n+//! * `error!(...)` - a macro hard-wired to the log level of `ERROR`\n+//!\n+//! All of these macros use the same style of syntax as the `format!` syntax\n+//! extension. Details about the syntax can be found in the documentation of\n+//! `std::fmt` along with the Rust tutorial/manual.\n+//!\n+//! If you want to check at runtime if a given logging level is enabled (e.g. if the\n+//! information you would want to log is expensive to produce), you can use the\n+//! following macro:\n+//!\n+//! * `log_enabled!(level)` - returns true if logging of the given level is enabled\n+//!\n+//! ## Enabling logging\n+//!\n+//! Log levels are controlled on a per-module basis, and by default all logging is\n+//! disabled except for `error!` (a log level of 1). Logging is controlled via the\n+//! `RUST_LOG` environment variable. The value of this environment variable is a\n+//! comma-separated list of logging directives. A logging directive is of the form:\n+//!\n+//! ```text\n+//! path::to::module=log_level\n+//! ```\n+//!\n+//! The path to the module is rooted in the name of the crate it was compiled for,\n+//! so if your program is contained in a file `hello.rs`, for example, to turn on\n+//! logging for this file you would use a value of `RUST_LOG=hello`.\n+//! Furthermore, this path is a prefix-search, so all modules nested in the\n+//! specified module will also have logging enabled.\n+//!\n+//! The actual `log_level` is optional to specify. If omitted, all logging will be\n+//! enabled. If specified, the it must be either a numeric in the range of 1-255, or\n+//! it must be one of the strings `debug`, `error`, `info`, or `warn`. If a numeric\n+//! is specified, then all logging less than or equal to that numeral is enabled.\n+//! For example, if logging level 3 is active, error, warn, and info logs will be\n+//! printed, but debug will be omitted.\n+//!\n+//! As the log level for a module is optional, the module to enable logging for is\n+//! also optional. If only a `log_level` is provided, then the global log level for\n+//! all modules is set to this value.\n+//!\n+//! Some examples of valid values of `RUST_LOG` are:\n+//!\n+//! * `hello` turns on all logging for the 'hello' module\n+//! * `info` turns on all info logging\n+//! * `hello=debug` turns on debug logging for 'hello'\n+//! * `hello=3` turns on info logging for 'hello'\n+//! * `hello,std::option` turns on hello, and std's option logging\n+//! * `error,hello=warn` turn on global error logging and also warn for hello\n+//!\n+//! ## Filtering results\n+//!\n+//! A RUST_LOG directive may include a regex filter. The syntax is to append `/`\n+//! followed by a regex. Each message is checked against the regex, and is only\n+//! logged if it matches. Note that the matching is done after formatting the log\n+//! string but before adding any logging meta-data. There is a single filter for all\n+//! modules.\n+//!\n+//! Some examples:\n+//!\n+//! * `hello/foo` turns on all logging for the 'hello' module where the log message\n+//! includes 'foo'.\n+//! * `info/f.o` turns on all info logging where the log message includes 'foo',\n+//! 'f1o', 'fao', etc.\n+//! * `hello=debug/foo*foo` turns on debug logging for 'hello' where the the log\n+//! message includes 'foofoo' or 'fofoo' or 'fooooooofoo', etc.\n+//! * `error,hello=warn/[0-9] scopes` turn on global error logging and also warn for\n+//!  hello. In both cases the log message must include a single digit number\n+//!  followed by 'scopes'\n+//!\n+//! ## Performance and Side Effects\n+//!\n+//! Each of these macros will expand to code similar to:\n+//!\n+//! ```rust,ignore\n+//! if log_level <= my_module_log_level() {\n+//!     ::log::log(log_level, format!(...));\n+//! }\n+//! ```\n+//!\n+//! What this means is that each of these macros are very cheap at runtime if\n+//! they're turned off (just a load and an integer comparison). This also means that\n+//! if logging is disabled, none of the components of the log will be executed.\n \n #![crate_name = \"log\"]\n #![experimental]"}, {"sha": "4f8837083ae57d5c00443cbf571e82573195fe92", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 88, "deletions": 27, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/26b40be7ed751e90be39c328904db2e28b10e23b/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b40be7ed751e90be39c328904db2e28b10e23b/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=26b40be7ed751e90be39c328904db2e28b10e23b", "patch": "@@ -24,11 +24,31 @@\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// log!(log::DEBUG, \"this is a debug message\");\n-/// log!(log::WARN, \"this is a warning {}\", \"message\");\n-/// log!(6, \"this is a custom logging level: {level}\", level=6u);\n-/// # }\n+/// fn main() {\n+///     log!(log::WARN, \"this is a warning {}\", \"message\");\n+///     log!(log::DEBUG, \"this is a debug message\");\n+///     log!(6, \"this is a custom logging level: {level}\", level=6u);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=warn ./main\n+/// WARN:main: this is a warning message\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=debug ./main\n+/// DEBUG:main: this is a debug message\n+/// WARN:main: this is a warning message\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=6 ./main\n+/// DEBUG:main: this is a debug message\n+/// WARN:main: this is a warning message\n+/// 6:main: this is a custom logging level: 6\n /// ```\n #[macro_export]\n macro_rules! log(\n@@ -53,11 +73,19 @@ macro_rules! log(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// # let error = 3u;\n-/// error!(\"the build has failed with error code: {}\", error);\n-/// # }\n+/// fn main() {\n+///     let error = 3u;\n+///     error!(\"the build has failed with error code: {}\", error);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=error ./main\n+/// ERROR:main: the build has failed with error code: 3\n /// ```\n+///\n #[macro_export]\n macro_rules! error(\n     ($($arg:tt)*) => (log!(::log::ERROR, $($arg)*))\n@@ -71,10 +99,17 @@ macro_rules! error(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// # let code = 3u;\n-/// warn!(\"you may like to know that a process exited with: {}\", code);\n-/// # }\n+/// fn main() {\n+///     let code = 3u;\n+///     warn!(\"you may like to know that a process exited with: {}\", code);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=warn ./main\n+/// WARN:main: you may like to know that a process exited with: 3\n /// ```\n #[macro_export]\n macro_rules! warn(\n@@ -89,10 +124,17 @@ macro_rules! warn(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// # let ret = 3i;\n-/// info!(\"this function is about to return: {}\", ret);\n-/// # }\n+/// fn main() {\n+///     let ret = 3i;\n+///     info!(\"this function is about to return: {}\", ret);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=info ./main\n+/// INFO:main: this function is about to return: 3\n /// ```\n #[macro_export]\n macro_rules! info(\n@@ -109,9 +151,16 @@ macro_rules! info(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// debug!(\"x = {x}, y = {y}\", x=10i, y=20i);\n-/// # }\n+/// fn main() {\n+///     debug!(\"x = {x}, y = {y}\", x=10i, y=20i);\n+/// }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=debug ./main\n+/// DEBUG:main: x = 10, y = 20\n /// ```\n #[macro_export]\n macro_rules! debug(\n@@ -126,14 +175,26 @@ macro_rules! debug(\n /// #![feature(phase)]\n /// #[phase(plugin, link)] extern crate log;\n ///\n-/// # fn main() {\n-/// # struct Point { x: int, y: int }\n-/// # fn some_expensive_computation() -> Point { Point { x: 1, y: 2 } }\n-/// if log_enabled!(log::DEBUG) {\n-///     let x = some_expensive_computation();\n-///     debug!(\"x.x = {}, x.y = {}\", x.x, x.y);\n+/// struct Point { x: int, y: int }\n+/// fn some_expensive_computation() -> Point { Point { x: 1, y: 2 } }\n+///\n+/// fn main() {\n+///     if log_enabled!(log::DEBUG) {\n+///         let x = some_expensive_computation();\n+///         debug!(\"x.x = {}, x.y = {}\", x.x, x.y);\n+///     }\n /// }\n-/// # }\n+/// ```\n+///\n+/// Assumes the binary is `main`:\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=error ./main\n+/// ```\n+///\n+/// ```{.bash}\n+/// $ RUST_LOG=debug ./main\n+/// DEBUG:main: x.x = 1, x.y = 2\n /// ```\n #[macro_export]\n macro_rules! log_enabled("}]}