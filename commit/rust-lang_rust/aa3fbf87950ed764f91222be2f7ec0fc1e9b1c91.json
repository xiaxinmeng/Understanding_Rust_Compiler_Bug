{"sha": "aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91", "node_id": "C_kwDOAAsO6NoAKGFhM2ZiZjg3OTUwZWQ3NjRmOTEyMjJiZTJmN2VjMGZjMWU5YjFjOTE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-29T14:29:36Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-09-29T14:29:36Z"}, "message": "Split out the error reporting logic into a separate function", "tree": {"sha": "a95bc8218f05a336ab234ec5da7357815b971a4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a95bc8218f05a336ab234ec5da7357815b971a4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91", "html_url": "https://github.com/rust-lang/rust/commit/aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5bbf36a31796b6b7b3add65ba20805b6659392c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5bbf36a31796b6b7b3add65ba20805b6659392c", "html_url": "https://github.com/rust-lang/rust/commit/c5bbf36a31796b6b7b3add65ba20805b6659392c"}], "stats": {"total": 274, "additions": 140, "deletions": 134}, "files": [{"sha": "080771844a44c4bf40424ef95372a015f7f81d47", "filename": "compiler/rustc_hir_analysis/src/check/callee.rs", "status": "modified", "additions": 140, "deletions": 134, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs?ref=aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91", "patch": "@@ -394,140 +394,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::FnPtr(sig) => (sig, None),\n             _ => {\n-                let mut unit_variant = None;\n-                if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n-                    && let Res::Def(def::DefKind::Ctor(kind, def::CtorKind::Const), _)\n-                        = self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n-                    // Only suggest removing parens if there are no arguments\n-                    && arg_exprs.is_empty()\n-                {\n-                    let descr = match kind {\n-                        def::CtorOf::Struct => \"struct\",\n-                        def::CtorOf::Variant => \"enum variant\",\n-                    };\n-                    let removal_span =\n-                        callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n-                    unit_variant =\n-                        Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n-                }\n-\n-                let callee_ty = self.resolve_vars_if_possible(callee_ty);\n-                let mut err = type_error_struct!(\n-                    self.tcx.sess,\n-                    callee_expr.span,\n-                    callee_ty,\n-                    E0618,\n-                    \"expected function, found {}\",\n-                    match &unit_variant {\n-                        Some((_, kind, path)) => format!(\"{kind} `{path}`\"),\n-                        None => format!(\"`{callee_ty}`\"),\n-                    }\n-                );\n-\n-                self.identify_bad_closure_def_and_call(\n-                    &mut err,\n-                    call_expr.hir_id,\n-                    &callee_expr.kind,\n-                    callee_expr.span,\n-                );\n-\n-                if let Some((removal_span, kind, path)) = &unit_variant {\n-                    err.span_suggestion_verbose(\n-                        *removal_span,\n-                        &format!(\n-                            \"`{path}` is a unit {kind}, and does not take parentheses to be constructed\",\n-                        ),\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-\n-                let mut inner_callee_path = None;\n-                let def = match callee_expr.kind {\n-                    hir::ExprKind::Path(ref qpath) => {\n-                        self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n-                    }\n-                    hir::ExprKind::Call(ref inner_callee, _) => {\n-                        // If the call spans more than one line and the callee kind is\n-                        // itself another `ExprCall`, that's a clue that we might just be\n-                        // missing a semicolon (Issue #51055)\n-                        let call_is_multiline =\n-                            self.tcx.sess.source_map().is_multiline(call_expr.span);\n-                        if call_is_multiline {\n-                            err.span_suggestion(\n-                                callee_expr.span.shrink_to_hi(),\n-                                \"consider using a semicolon here\",\n-                                \";\",\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n-                            inner_callee_path = Some(inner_qpath);\n-                            self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n-                        } else {\n-                            Res::Err\n-                        }\n-                    }\n-                    _ => Res::Err,\n-                };\n-\n-                if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n-                    if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_expr, callee_ty)\n-                        && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n-                    {\n-                        let descr = match maybe_def {\n-                            DefIdOrName::DefId(def_id) => self.tcx.def_kind(def_id).descr(def_id),\n-                            DefIdOrName::Name(name) => name,\n-                        };\n-                        err.span_label(\n-                            callee_expr.span,\n-                            format!(\"this {descr} returns an unsized value `{output_ty}`, so it cannot be called\")\n-                        );\n-                        if let DefIdOrName::DefId(def_id) = maybe_def\n-                            && let Some(def_span) = self.tcx.hir().span_if_local(def_id)\n-                        {\n-                            err.span_label(def_span, \"the callable type is defined here\");\n-                        }\n-                    } else {\n-                        err.span_label(call_expr.span, \"call expression requires function\");\n-                    }\n-                }\n-\n-                if let Some(span) = self.tcx.hir().res_span(def) {\n-                    let callee_ty = callee_ty.to_string();\n-                    let label = match (unit_variant, inner_callee_path) {\n-                        (Some((_, kind, path)), _) => Some(format!(\"{kind} `{path}` defined here\")),\n-                        (_, Some(hir::QPath::Resolved(_, path))) => self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(path.span)\n-                            .ok()\n-                            .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n-                        _ => {\n-                            match def {\n-                                // Emit a different diagnostic for local variables, as they are not\n-                                // type definitions themselves, but rather variables *of* that type.\n-                                Res::Local(hir_id) => Some(format!(\n-                                    \"`{}` has type `{}`\",\n-                                    self.tcx.hir().name(hir_id),\n-                                    callee_ty\n-                                )),\n-                                Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n-                                    Some(format!(\n-                                        \"`{}` defined here\",\n-                                        self.tcx.def_path_str(def_id),\n-                                    ))\n-                                }\n-                                _ => Some(format!(\"`{callee_ty}` defined here\")),\n-                            }\n-                        }\n-                    };\n-                    if let Some(label) = label {\n-                        err.span_label(span, label);\n-                    }\n-                }\n-                err.emit();\n+                self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n \n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n@@ -574,6 +441,145 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fn_sig.output()\n     }\n \n+    fn report_invalid_callee(\n+        &self,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n+        callee_ty: Ty<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n+    ) {\n+        let mut unit_variant = None;\n+        if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n+            && let Res::Def(def::DefKind::Ctor(kind, def::CtorKind::Const), _)\n+                = self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+            // Only suggest removing parens if there are no arguments\n+            && arg_exprs.is_empty()\n+        {\n+            let descr = match kind {\n+                def::CtorOf::Struct => \"struct\",\n+                def::CtorOf::Variant => \"enum variant\",\n+            };\n+            let removal_span =\n+                callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n+            unit_variant =\n+                Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n+        }\n+\n+        let callee_ty = self.resolve_vars_if_possible(callee_ty);\n+        let mut err = type_error_struct!(\n+            self.tcx.sess,\n+            callee_expr.span,\n+            callee_ty,\n+            E0618,\n+            \"expected function, found {}\",\n+            match &unit_variant {\n+                Some((_, kind, path)) => format!(\"{kind} `{path}`\"),\n+                None => format!(\"`{callee_ty}`\"),\n+            }\n+        );\n+\n+        self.identify_bad_closure_def_and_call(\n+            &mut err,\n+            call_expr.hir_id,\n+            &callee_expr.kind,\n+            callee_expr.span,\n+        );\n+\n+        if let Some((removal_span, kind, path)) = &unit_variant {\n+            err.span_suggestion_verbose(\n+                *removal_span,\n+                &format!(\n+                    \"`{path}` is a unit {kind}, and does not take parentheses to be constructed\",\n+                ),\n+                \"\",\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+\n+        let mut inner_callee_path = None;\n+        let def = match callee_expr.kind {\n+            hir::ExprKind::Path(ref qpath) => {\n+                self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+            }\n+            hir::ExprKind::Call(ref inner_callee, _) => {\n+                // If the call spans more than one line and the callee kind is\n+                // itself another `ExprCall`, that's a clue that we might just be\n+                // missing a semicolon (Issue #51055)\n+                let call_is_multiline = self.tcx.sess.source_map().is_multiline(call_expr.span);\n+                if call_is_multiline {\n+                    err.span_suggestion(\n+                        callee_expr.span.shrink_to_hi(),\n+                        \"consider using a semicolon here\",\n+                        \";\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n+                    inner_callee_path = Some(inner_qpath);\n+                    self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n+                } else {\n+                    Res::Err\n+                }\n+            }\n+            _ => Res::Err,\n+        };\n+\n+        if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n+            if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_expr, callee_ty)\n+                && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n+            {\n+                let descr = match maybe_def {\n+                    DefIdOrName::DefId(def_id) => self.tcx.def_kind(def_id).descr(def_id),\n+                    DefIdOrName::Name(name) => name,\n+                };\n+                err.span_label(\n+                    callee_expr.span,\n+                    format!(\"this {descr} returns an unsized value `{output_ty}`, so it cannot be called\")\n+                );\n+                if let DefIdOrName::DefId(def_id) = maybe_def\n+                    && let Some(def_span) = self.tcx.hir().span_if_local(def_id)\n+                {\n+                    err.span_label(def_span, \"the callable type is defined here\");\n+                }\n+            } else {\n+                err.span_label(call_expr.span, \"call expression requires function\");\n+            }\n+        }\n+\n+        if let Some(span) = self.tcx.hir().res_span(def) {\n+            let callee_ty = callee_ty.to_string();\n+            let label = match (unit_variant, inner_callee_path) {\n+                (Some((_, kind, path)), _) => Some(format!(\"{kind} `{path}` defined here\")),\n+                (_, Some(hir::QPath::Resolved(_, path))) => self\n+                    .tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(path.span)\n+                    .ok()\n+                    .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n+                _ => {\n+                    match def {\n+                        // Emit a different diagnostic for local variables, as they are not\n+                        // type definitions themselves, but rather variables *of* that type.\n+                        Res::Local(hir_id) => Some(format!(\n+                            \"`{}` has type `{}`\",\n+                            self.tcx.hir().name(hir_id),\n+                            callee_ty\n+                        )),\n+                        Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n+                            Some(format!(\"`{}` defined here\", self.tcx.def_path_str(def_id),))\n+                        }\n+                        _ => Some(format!(\"`{callee_ty}` defined here\")),\n+                    }\n+                }\n+            };\n+            if let Some(label) = label {\n+                err.span_label(span, label);\n+            }\n+        }\n+        err.emit();\n+    }\n+\n     fn confirm_deferred_closure_call(\n         &self,\n         call_expr: &'tcx hir::Expr<'tcx>,"}]}