{"sha": "5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "node_id": "C_kwDOAAsO6NoAKDVhN2UxMWY1ZmJjNmNkZjdhZjc5YWZlNzBhOTRjNzhiNzllMzY2ZDI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-03T15:01:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-03T15:01:08Z"}, "message": "Merge #11397\n\n11397: internal: Refactor completion module split r=Veykril a=Veykril\n\nCurrently our completion infra is split into several modules, each trying to do completions for something specific. This \"something\" is rather unstructured as it stands now, we have a module for `flyimporting path` completions, `unqualified` and `qualified path` completions, modules for `pattern position` completions that only try to complete extra things for patterns that aren't done in the path modules, `attribute` completions that again only try to add builtin attribute completions without adding the normal path completions and a bunch of other special \"entity\" completions like lifetimes, method call/field access, function param cloning, ... which serve a more specific purpose than the previous listed ones.\r\n\r\nAs is evident, the former mentioned ones have some decent overlap which requires extra filtering in them so that they don't collide with each other duplicating a bunch of completions(which we had happen in the past at times).\r\n\r\nNow this overlap mostly happens with path completions(and keyword completions as well in some sense) which gives me the feeling that having `qualified` and `unqualified` path completions be separate from the rest gives us more troubles than benefits in the long run.\r\nSo this is an attempt at changing this structure to instead still go by rough entity for special cases, but when it comes to paths we instead do the module split on the \"path kinds\"/\"locations\"(think pattern, type, expr position etc) that exist. This goes hand in hand with the test refactoring I have done that moved tests to \"location oriented\" modules as well as the `CompletionContext` refactoring that actually already started splitting the context up for path kinds.\r\n\r\nThis PR moves some path completions out of the `qualified` and `unqualified` path modules namely attribute, visibility, use and pattern paths.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "a3b1c4408dab97c5fc188b14b046560cc4503818", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3b1c4408dab97c5fc188b14b046560cc4503818"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh++40CRBK7hj4Ov3rIwAA2lcIACY3l58YP3DOtSD7K8bCTnhw\nXTUw190cxHwSLXAocEf9Pdb/nfMKu0ni9NqGH/qTY2YtfAuDcGa+Vb5W3qhYVR6X\nz0ehZQr/9jjkUjCp4In/z8WfWp7NsHi8cBab2O8r9k3kCvCpl/eB6mglMRMztqU/\nQBncL7ZSgfgopSISNONVZPPswtjXzKbwh5emT+YVzV7jhrWFll7lOaw9CugwqXWz\nT/Ir6QbHptUiho03PlBfS7OnZwCb7B4Y2WTkaryz2rF0dN6kmjuaftD/gqCN8fC7\n1ME+zMOtZyGqaCT8JAsolwZcSLKBZpKgTnubZzoY6wzUNGEOvd03kV4lR1ZCwFE=\n=oksz\n-----END PGP SIGNATURE-----\n", "payload": "tree a3b1c4408dab97c5fc188b14b046560cc4503818\nparent 46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5\nparent 7619c2afeaac09ced8a55b6f2db21550b80fba5e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1643900468 +0000\ncommitter GitHub <noreply@github.com> 1643900468 +0000\n\nMerge #11397\n\n11397: internal: Refactor completion module split r=Veykril a=Veykril\n\nCurrently our completion infra is split into several modules, each trying to do completions for something specific. This \"something\" is rather unstructured as it stands now, we have a module for `flyimporting path` completions, `unqualified` and `qualified path` completions, modules for `pattern position` completions that only try to complete extra things for patterns that aren't done in the path modules, `attribute` completions that again only try to add builtin attribute completions without adding the normal path completions and a bunch of other special \"entity\" completions like lifetimes, method call/field access, function param cloning, ... which serve a more specific purpose than the previous listed ones.\r\n\r\nAs is evident, the former mentioned ones have some decent overlap which requires extra filtering in them so that they don't collide with each other duplicating a bunch of completions(which we had happen in the past at times).\r\n\r\nNow this overlap mostly happens with path completions(and keyword completions as well in some sense) which gives me the feeling that having `qualified` and `unqualified` path completions be separate from the rest gives us more troubles than benefits in the long run.\r\nSo this is an attempt at changing this structure to instead still go by rough entity for special cases, but when it comes to paths we instead do the module split on the \"path kinds\"/\"locations\"(think pattern, type, expr position etc) that exist. This goes hand in hand with the test refactoring I have done that moved tests to \"location oriented\" modules as well as the `CompletionContext` refactoring that actually already started splitting the context up for path kinds.\r\n\r\nThis PR moves some path completions out of the `qualified` and `unqualified` path modules namely attribute, visibility, use and pattern paths.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "html_url": "https://github.com/rust-lang/rust/commit/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "html_url": "https://github.com/rust-lang/rust/commit/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5"}, {"sha": "7619c2afeaac09ced8a55b6f2db21550b80fba5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/7619c2afeaac09ced8a55b6f2db21550b80fba5e", "html_url": "https://github.com/rust-lang/rust/commit/7619c2afeaac09ced8a55b6f2db21550b80fba5e"}], "stats": {"total": 1056, "additions": 700, "deletions": 356}, "files": [{"sha": "1e949771ea01ffb8a69adb4c2c89280a41ab9cf9", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -481,7 +481,7 @@ impl HirDisplay for Module {\n         // FIXME: Module doesn't have visibility saved in data.\n         match self.name(f.db) {\n             Some(name) => write!(f, \"mod {}\", name),\n-            None if self.crate_root(f.db) == *self => match self.krate().display_name(f.db) {\n+            None if self.is_crate_root(f.db) => match self.krate().display_name(f.db) {\n                 Some(name) => write!(f, \"extern crate {}\", name),\n                 None => write!(f, \"extern crate {{unknown}}\"),\n             },"}, {"sha": "032da5f50af6d1e9f12efdfcd504ef84b6b38402", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -452,6 +452,11 @@ impl Module {\n         Module { id: def_map.module_id(def_map.root()) }\n     }\n \n+    pub fn is_crate_root(self, db: &dyn HirDatabase) -> bool {\n+        let def_map = db.crate_def_map(self.id.krate());\n+        def_map.root() == self.id.local_id\n+    }\n+\n     /// Iterates over all child modules.\n     pub fn children(self, db: &dyn HirDatabase) -> impl Iterator<Item = Module> {\n         let def_map = self.id.def_map(db.upcast());"}, {"sha": "243ba63b8a0a8b52a583f0d8f14b6b4a35288b6e", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -949,12 +949,15 @@ impl<'db> SemanticsImpl<'db> {\n         })?;\n \n         match res {\n-            Either::Left(path) => resolve_hir_path(\n-                self.db,\n-                &self.scope(derive.syntax()).resolver,\n-                &Path::from_known_path(path, []),\n-            )\n-            .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_)))),\n+            Either::Left(path) => {\n+                let len = path.len();\n+                resolve_hir_path(\n+                    self.db,\n+                    &self.scope(derive.syntax()).resolver,\n+                    &Path::from_known_path(path, vec![None; len]),\n+                )\n+                .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_))))\n+            }\n             Either::Right(derive) => derive\n                 .map(|call| MacroDef { id: self.db.lookup_intern_macro_call(call).def })\n                 .map(PathResolution::Macro),"}, {"sha": "a6141174c8379b3c458bbde9b1205e1e87b64f74", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -92,7 +92,9 @@ impl Path {\n         path: ModPath,\n         generic_args: impl Into<Box<[Option<Interned<GenericArgs>>]>>,\n     ) -> Path {\n-        Path { type_anchor: None, mod_path: Interned::new(path), generic_args: generic_args.into() }\n+        let generic_args = generic_args.into();\n+        assert_eq!(path.len(), generic_args.len());\n+        Path { type_anchor: None, mod_path: Interned::new(path), generic_args }\n     }\n \n     pub fn kind(&self) -> &PathKind {"}, {"sha": "173380654e0cda706659b790ef0ccce3c7cbaeab", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -253,6 +253,7 @@ pub enum PointerCast {\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n+    #[allow(dead_code)]\n     /// Go from `*const [T; N]` to `*const T`\n     ArrayToPointer,\n "}, {"sha": "9c65efdb102291f1d4ba8d56320d664fae88e857", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -4,6 +4,7 @@ pub(crate) mod attribute;\n pub(crate) mod dot;\n pub(crate) mod flyimport;\n pub(crate) mod fn_param;\n+pub(crate) mod format_string;\n pub(crate) mod keyword;\n pub(crate) mod lifetime;\n pub(crate) mod mod_;\n@@ -14,7 +15,8 @@ pub(crate) mod record;\n pub(crate) mod snippet;\n pub(crate) mod trait_impl;\n pub(crate) mod unqualified_path;\n-pub(crate) mod format_string;\n+pub(crate) mod use_;\n+pub(crate) mod vis;\n \n use std::iter;\n \n@@ -97,6 +99,19 @@ impl Completions {\n         item.add_to(self);\n     }\n \n+    pub(crate) fn add_nameref_keywords(&mut self, ctx: &CompletionContext) {\n+        [\"self::\", \"super::\", \"crate::\"].into_iter().for_each(|kw| self.add_keyword(ctx, kw));\n+    }\n+\n+    pub(crate) fn add_crate_roots(&mut self, ctx: &CompletionContext) {\n+        ctx.process_all_names(&mut |name, res| match res {\n+            ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n+                self.add_resolution(ctx, name, res);\n+            }\n+            _ => (),\n+        });\n+    }\n+\n     pub(crate) fn add_resolution(\n         &mut self,\n         ctx: &CompletionContext,"}, {"sha": "cb45d9de03fc78e96cb828a89fd81bc0743d583d", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 85, "deletions": 42, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -1,8 +1,6 @@\n-//! Completion for attributes\n+//! Completion for (built-in) attributes, derives and lints.\n //!\n-//! This module uses a bit of static metadata to provide completions\n-//! for built-in attributes.\n-//! Non-built-in attribute (excluding derives attributes) completions are done in [`super::unqualified_path`].\n+//! This module uses a bit of static metadata to provide completions for builtin-in attributes and lints.\n \n use ide_db::{\n     helpers::{\n@@ -16,62 +14,107 @@ use ide_db::{\n use itertools::Itertools;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n-use syntax::{algo::non_trivia_sibling, ast, AstNode, Direction, SyntaxKind, T};\n+use syntax::{\n+    ast::{self, AttrKind},\n+    AstNode, SyntaxKind, T,\n+};\n \n-use crate::{context::CompletionContext, item::CompletionItem, Completions};\n+use crate::{\n+    completions::module_or_attr,\n+    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n+    item::CompletionItem,\n+    Completions,\n+};\n \n mod cfg;\n mod derive;\n mod lint;\n mod repr;\n \n-pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+/// Complete inputs to known builtin attributes as well as derive attributes\n+pub(crate) fn complete_known_attribute_input(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+) -> Option<()> {\n     let attribute = ctx.fake_attribute_under_caret.as_ref()?;\n     let name_ref = match attribute.path() {\n         Some(p) => Some(p.as_single_name_ref()?),\n         None => None,\n     };\n-    match (name_ref, attribute.token_tree()) {\n-        (Some(path), Some(tt)) if tt.l_paren_token().is_some() => match path.text().as_str() {\n-            \"repr\" => repr::complete_repr(acc, ctx, tt),\n-            \"derive\" => derive::complete_derive(acc, ctx, ctx.attr.as_ref()?),\n-            \"feature\" => lint::complete_lint(acc, ctx, &parse_tt_as_comma_sep_paths(tt)?, FEATURES),\n-            \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                let existing_lints = parse_tt_as_comma_sep_paths(tt)?;\n+    let (path, tt) = name_ref.zip(attribute.token_tree())?;\n+    if tt.l_paren_token().is_none() {\n+        return None;\n+    }\n \n-                let lints: Vec<Lint> = CLIPPY_LINT_GROUPS\n-                    .iter()\n-                    .map(|g| &g.lint)\n-                    .chain(DEFAULT_LINTS.iter())\n-                    .chain(CLIPPY_LINTS.iter())\n-                    .chain(RUSTDOC_LINTS)\n-                    .cloned()\n-                    .collect();\n+    match path.text().as_str() {\n+        \"repr\" => repr::complete_repr(acc, ctx, tt),\n+        \"derive\" => derive::complete_derive(acc, ctx, ctx.attr.as_ref()?),\n+        \"feature\" => lint::complete_lint(acc, ctx, &parse_tt_as_comma_sep_paths(tt)?, FEATURES),\n+        \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+            let existing_lints = parse_tt_as_comma_sep_paths(tt)?;\n \n-                lint::complete_lint(acc, ctx, &existing_lints, &lints);\n-            }\n-            \"cfg\" => {\n-                cfg::complete_cfg(acc, ctx);\n-            }\n-            _ => (),\n-        },\n-        (_, Some(_)) => (),\n-        (_, None) if attribute.expr().is_some() => (),\n-        (_, None) => complete_new_attribute(acc, ctx, attribute),\n+            let lints: Vec<Lint> = CLIPPY_LINT_GROUPS\n+                .iter()\n+                .map(|g| &g.lint)\n+                .chain(DEFAULT_LINTS)\n+                .chain(CLIPPY_LINTS)\n+                .chain(RUSTDOC_LINTS)\n+                .cloned()\n+                .collect();\n+\n+            lint::complete_lint(acc, ctx, &existing_lints, &lints);\n+        }\n+        \"cfg\" => {\n+            cfg::complete_cfg(acc, ctx);\n+        }\n+        _ => (),\n     }\n     Some(())\n }\n \n-// FIXME?: Move this functionality to (un)qualified_path, make this module work solely for builtin/known attributes for their inputs?\n-fn complete_new_attribute(acc: &mut Completions, ctx: &CompletionContext, attribute: &ast::Attr) {\n-    let is_inner = attribute.kind() == ast::AttrKind::Inner;\n-    let attribute_annotated_item_kind =\n-        attribute.syntax().parent().map(|it| it.kind()).filter(|_| {\n-            is_inner\n-            // If we got nothing coming after the attribute it could be anything so filter it the kind out\n-                || non_trivia_sibling(attribute.syntax().clone().into(), Direction::Next).is_some()\n-        });\n-    let attributes = attribute_annotated_item_kind.and_then(|kind| {\n+pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) {\n+    let (is_absolute_path, qualifier, is_inner, annotated_item_kind) = match ctx.path_context {\n+        Some(PathCompletionCtx {\n+            kind: Some(PathKind::Attr { kind, annotated_item_kind }),\n+            is_absolute_path,\n+            ref qualifier,\n+            ..\n+        }) => (is_absolute_path, qualifier, kind == AttrKind::Inner, annotated_item_kind),\n+        _ => return,\n+    };\n+\n+    match qualifier {\n+        Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+            if *is_super_chain {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n+\n+            let module = match resolution {\n+                Some(hir::PathResolution::Def(hir::ModuleDef::Module(it))) => it,\n+                _ => return,\n+            };\n+\n+            for (name, def) in module.scope(ctx.db, ctx.module) {\n+                if let Some(def) = module_or_attr(def) {\n+                    acc.add_resolution(ctx, name, def);\n+                }\n+            }\n+            return;\n+        }\n+        // fresh use tree with leading colon2, only show crate roots\n+        None if is_absolute_path => acc.add_crate_roots(ctx),\n+        // only show modules in a fresh UseTree\n+        None => {\n+            ctx.process_all_names(&mut |name, def| {\n+                if let Some(def) = module_or_attr(def) {\n+                    acc.add_resolution(ctx, name, def);\n+                }\n+            });\n+            acc.add_nameref_keywords(ctx);\n+        }\n+    }\n+\n+    let attributes = annotated_item_kind.and_then(|kind| {\n         if ast::Expr::can_cast(kind) {\n             Some(EXPR_ATTRIBUTES)\n         } else {"}, {"sha": "4a34b0f7e5625046edba6e7f00ced6068523231f", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -32,7 +32,7 @@ fn complete_undotted_self(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.config.enable_self_on_the_fly {\n         return;\n     }\n-    if !ctx.is_trivial_path() || ctx.is_path_disallowed() || !ctx.expects_expression() {\n+    if ctx.is_non_trivial_path() || ctx.is_path_disallowed() || !ctx.expects_expression() {\n         return;\n     }\n     if let Some(func) = ctx.function_def.as_ref().and_then(|fn_| ctx.sema.to_def(fn_)) {"}, {"sha": "723abd62aef576e922842312137bacd5fcc30c49", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -171,8 +171,8 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n             (PathKind::Type, ItemInNs::Types(_)) => true,\n             (PathKind::Type, ItemInNs::Values(_)) => false,\n \n-            (PathKind::Attr, ItemInNs::Macros(mac)) => mac.is_attr(),\n-            (PathKind::Attr, _) => false,\n+            (PathKind::Attr { .. }, ItemInNs::Macros(mac)) => mac.is_attr(),\n+            (PathKind::Attr { .. }, _) => false,\n         }\n     };\n "}, {"sha": "4704e842e6a36d360d632b00a3b8a6244f73ccda", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -5,7 +5,7 @@\n use syntax::{SyntaxKind, T};\n \n use crate::{\n-    context::{PathCompletionContext, PathKind},\n+    context::{PathCompletionCtx, PathKind},\n     patterns::ImmediateLocation,\n     CompletionContext, CompletionItem, CompletionItemKind, Completions,\n };\n@@ -27,18 +27,17 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         cov_mark::hit!(no_keyword_completion_in_non_trivial_path);\n         return;\n     }\n+    if ctx.pattern_ctx.is_some() {\n+        return;\n+    }\n \n     let mut add_keyword = |kw, snippet| add_keyword(acc, ctx, kw, snippet);\n \n     let expects_assoc_item = ctx.expects_assoc_item();\n     let has_block_expr_parent = ctx.has_block_expr_parent();\n     let expects_item = ctx.expects_item();\n \n-    if let Some(PathKind::Vis { has_in_token }) = ctx.path_kind() {\n-        if !has_in_token {\n-            cov_mark::hit!(kw_completion_in);\n-            add_keyword(\"in\", \"in\");\n-        }\n+    if let Some(PathKind::Vis { .. }) = ctx.path_kind() {\n         return;\n     }\n     if ctx.has_impl_or_trait_prev_sibling() {\n@@ -121,14 +120,14 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n     }\n \n-    if ctx.expects_ident_pat_or_ref_expr() {\n+    if ctx.expects_ident_ref_expr() {\n         add_keyword(\"mut\", \"mut \");\n     }\n \n     let (can_be_stmt, in_loop_body) = match ctx.path_context {\n-        Some(PathCompletionContext {\n-            is_trivial_path: true, can_be_stmt, in_loop_body, ..\n-        }) => (can_be_stmt, in_loop_body),\n+        Some(PathCompletionCtx { is_absolute_path: false, can_be_stmt, in_loop_body, .. }) => {\n+            (can_be_stmt, in_loop_body)\n+        }\n         _ => return,\n     };\n "}, {"sha": "f1b4fa720591d98cc39240bf5734a462f61c4c3e", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 127, "deletions": 6, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -1,20 +1,52 @@\n //! Completes constants and paths in unqualified patterns.\n \n-use hir::db::DefDatabase;\n+use hir::{db::DefDatabase, AssocItem, ScopeDef};\n+use rustc_hash::FxHashSet;\n+use syntax::ast::Pat;\n \n use crate::{\n-    context::{PatternContext, PatternRefutability},\n+    context::{PathCompletionCtx, PathQualifierCtx, PatternRefutability},\n     CompletionContext, Completions,\n };\n \n /// Completes constants and paths in unqualified patterns.\n pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n-    let refutable = match ctx.pattern_ctx {\n-        Some(PatternContext { refutability, .. }) if ctx.path_context.is_none() => {\n-            refutability == PatternRefutability::Refutable\n-        }\n+    let patctx = match &ctx.pattern_ctx {\n+        Some(ctx) => ctx,\n         _ => return,\n     };\n+    let refutable = patctx.refutability == PatternRefutability::Refutable;\n+\n+    if let Some(path_ctx) = &ctx.path_context {\n+        pattern_path_completion(acc, ctx, path_ctx);\n+        return;\n+    }\n+\n+    match patctx.parent_pat.as_ref() {\n+        Some(Pat::RangePat(_) | Pat::BoxPat(_)) => (),\n+        Some(Pat::RefPat(r)) => {\n+            if r.mut_token().is_none() {\n+                acc.add_keyword(ctx, \"mut\");\n+            }\n+        }\n+        _ => {\n+            let tok = ctx.token.text_range().start();\n+            match (patctx.ref_token.as_ref(), patctx.mut_token.as_ref()) {\n+                (None, None) => {\n+                    acc.add_keyword(ctx, \"ref\");\n+                    acc.add_keyword(ctx, \"mut\");\n+                }\n+                (None, Some(m)) if tok < m.text_range().start() => {\n+                    acc.add_keyword(ctx, \"ref\");\n+                }\n+                (Some(r), None) if tok > r.text_range().end() => {\n+                    acc.add_keyword(ctx, \"mut\");\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+\n     let single_variant_enum = |enum_: hir::Enum| ctx.db.enum_data(enum_.into()).variants.len() == 1;\n \n     if let Some(hir::Adt::Enum(e)) =\n@@ -63,3 +95,92 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n     });\n }\n+\n+fn pattern_path_completion(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    PathCompletionCtx { qualifier, is_absolute_path, .. }: &PathCompletionCtx,\n+) {\n+    match qualifier {\n+        Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+            if *is_super_chain {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n+\n+            let resolution = match resolution {\n+                Some(it) => it,\n+                None => return,\n+            };\n+\n+            match resolution {\n+                hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n+                    let module_scope = module.scope(ctx.db, ctx.module);\n+                    for (name, def) in module_scope {\n+                        let add_resolution = match def {\n+                            ScopeDef::MacroDef(m) if m.is_fn_like() => true,\n+                            ScopeDef::ModuleDef(_) => true,\n+                            _ => false,\n+                        };\n+\n+                        if add_resolution {\n+                            acc.add_resolution(ctx, name, def);\n+                        }\n+                    }\n+                }\n+                hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(e))) => {\n+                    cov_mark::hit!(enum_plain_qualified_use_tree);\n+                    e.variants(ctx.db)\n+                        .into_iter()\n+                        .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+                }\n+                res @ (hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_)) => {\n+                    if let Some(krate) = ctx.krate {\n+                        let ty = match res {\n+                            hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n+                            hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n+                            _ => return,\n+                        };\n+\n+                        if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                            e.variants(ctx.db)\n+                                .into_iter()\n+                                .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+                        }\n+\n+                        let traits_in_scope = ctx.scope.visible_traits();\n+                        let mut seen = FxHashSet::default();\n+                        ty.iterate_path_candidates(\n+                            ctx.db,\n+                            krate,\n+                            &traits_in_scope,\n+                            ctx.module,\n+                            None,\n+                            |_ty, item| {\n+                                // Note associated consts cannot be referenced in patterns\n+                                if let AssocItem::TypeAlias(ta) = item {\n+                                    // We might iterate candidates of a trait multiple times here, so deduplicate them.\n+                                    if seen.insert(item) {\n+                                        acc.add_type_alias(ctx, ta);\n+                                    }\n+                                }\n+                                None::<()>\n+                            },\n+                        );\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        // qualifier can only be none here if we are in a TuplePat or RecordPat in which case special characters have to follow the path\n+        None if *is_absolute_path => acc.add_crate_roots(ctx),\n+        None => {\n+            cov_mark::hit!(unqualified_path_only_modules_in_import);\n+            ctx.process_all_names(&mut |name, res| {\n+                if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n+                    acc.add_resolution(ctx, name, res);\n+                }\n+            });\n+            acc.add_nameref_keywords(ctx);\n+        }\n+    }\n+}"}, {"sha": "cf78f7c1adf47d4b8027914d86f5277846242a3b", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 21, "deletions": 95, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -1,14 +1,12 @@\n //! Completion of paths, i.e. `some::prefix::$0`.\n \n-use std::iter;\n-\n use hir::{ScopeDef, Trait};\n use rustc_hash::FxHashSet;\n-use syntax::{ast, AstNode};\n+use syntax::ast;\n \n use crate::{\n-    completions::{module_or_attr, module_or_fn_macro},\n-    context::{PathCompletionContext, PathKind},\n+    completions::module_or_fn_macro,\n+    context::{PathCompletionCtx, PathKind},\n     patterns::ImmediateLocation,\n     CompletionContext, Completions,\n };\n@@ -17,21 +15,19 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     if ctx.is_path_disallowed() || ctx.has_impl_or_trait_prev_sibling() {\n         return;\n     }\n-    let (path, use_tree_parent, kind) = match ctx.path_context {\n+    if ctx.pattern_ctx.is_some() {\n+        return;\n+    }\n+    let (qualifier, kind) = match ctx.path_context {\n         // let ... else, syntax would come in really handy here right now\n-        Some(PathCompletionContext {\n-            qualifier: Some(ref qualifier),\n-            use_tree_parent,\n-            kind,\n-            ..\n-        }) => (qualifier, use_tree_parent, kind),\n+        Some(PathCompletionCtx { qualifier: Some(ref qualifier), kind, .. }) => (qualifier, kind),\n         _ => return,\n     };\n \n     // special case `<_>::$0` as this doesn't resolve to anything.\n-    if path.qualifier().is_none() {\n+    if qualifier.path.qualifier().is_none() {\n         if matches!(\n-            path.segment().and_then(|it| it.kind()),\n+            qualifier.path.segment().and_then(|it| it.kind()),\n             Some(ast::PathSegmentKind::Type {\n                 type_ref: Some(ast::Type::InferType(_)),\n                 trait_ref: None,\n@@ -47,17 +43,15 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n         }\n     }\n \n-    let resolution = match ctx.sema.resolve_path(path) {\n+    let resolution = match &qualifier.resolution {\n         Some(res) => res,\n         None => return,\n     };\n \n-    let context_module = ctx.module;\n-\n     match ctx.completion_location {\n         Some(ImmediateLocation::ItemList | ImmediateLocation::Trait | ImmediateLocation::Impl) => {\n             if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n-                for (name, def) in module.scope(ctx.db, context_module) {\n+                for (name, def) in module.scope(ctx.db, ctx.module) {\n                     if let Some(def) = module_or_fn_macro(def) {\n                         acc.add_resolution(ctx, name, def);\n                     }\n@@ -69,78 +63,22 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     }\n \n     match kind {\n-        // Complete next child module that comes after the qualified module which is still our parent\n-        Some(PathKind::Vis { .. }) => {\n-            if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n-                if let Some(current_module) = ctx.module {\n-                    let next_towards_current = current_module\n-                        .path_to_root(ctx.db)\n-                        .into_iter()\n-                        .take_while(|&it| it != module)\n-                        .next();\n-                    if let Some(next) = next_towards_current {\n-                        if let Some(name) = next.name(ctx.db) {\n-                            cov_mark::hit!(visibility_qualified);\n-                            acc.add_resolution(ctx, name, ScopeDef::ModuleDef(next.into()));\n-                        }\n-                    }\n-                }\n-            }\n-            return;\n-        }\n-        Some(PathKind::Attr) => {\n-            if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n-                for (name, def) in module.scope(ctx.db, context_module) {\n-                    if let Some(def) = module_or_attr(def) {\n-                        acc.add_resolution(ctx, name, def);\n-                    }\n-                }\n-            }\n+        Some(PathKind::Pat | PathKind::Attr { .. } | PathKind::Vis { .. } | PathKind::Use) => {\n             return;\n         }\n-        Some(PathKind::Use) => {\n-            if iter::successors(Some(path.clone()), |p| p.qualifier())\n-                .all(|p| p.segment().and_then(|s| s.super_token()).is_some())\n-            {\n-                acc.add_keyword(ctx, \"super::\");\n-            }\n-            // only show `self` in a new use-tree when the qualifier doesn't end in self\n-            if use_tree_parent\n-                && !matches!(\n-                    path.segment().and_then(|it| it.kind()),\n-                    Some(ast::PathSegmentKind::SelfKw)\n-                )\n-            {\n-                acc.add_keyword(ctx, \"self\");\n-            }\n+        _ => {\n+            // Add associated types on type parameters and `Self`.\n+            ctx.scope.assoc_type_shorthand_candidates(&resolution, |_, alias| {\n+                acc.add_type_alias(ctx, alias);\n+                None::<()>\n+            });\n         }\n-        _ => (),\n-    }\n-\n-    if !matches!(kind, Some(PathKind::Pat)) {\n-        // Add associated types on type parameters and `Self`.\n-        ctx.scope.assoc_type_shorthand_candidates(&resolution, |_, alias| {\n-            acc.add_type_alias(ctx, alias);\n-            None::<()>\n-        });\n     }\n \n     match resolution {\n         hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n-            let module_scope = module.scope(ctx.db, context_module);\n+            let module_scope = module.scope(ctx.db, ctx.module);\n             for (name, def) in module_scope {\n-                if let Some(PathKind::Use) = kind {\n-                    if let ScopeDef::Unknown = def {\n-                        if let Some(ast::NameLike::NameRef(name_ref)) = ctx.name_syntax.as_ref() {\n-                            if name_ref.syntax().text() == name.to_smol_str().as_str() {\n-                                // for `use self::foo$0`, don't suggest `foo` as a completion\n-                                cov_mark::hit!(dont_complete_current_use);\n-                                continue;\n-                            }\n-                        }\n-                    }\n-                }\n-\n                 let add_resolution = match def {\n                     // Don't suggest attribute macros and derives.\n                     ScopeDef::MacroDef(mac) => mac.is_fn_like(),\n@@ -168,7 +106,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             | hir::ModuleDef::TypeAlias(_)\n             | hir::ModuleDef::BuiltinType(_)),\n         ) => {\n-            if let hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n+            if let &hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n                 add_enum_variants(acc, ctx, e);\n             }\n             let ty = match def {\n@@ -622,18 +560,6 @@ fn foo() {\n         );\n     }\n \n-    #[test]\n-    fn dont_complete_attr() {\n-        check(\n-            r#\"\n-mod foo { pub struct Foo; }\n-#[foo::$0]\n-fn f() {}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_variant_through_self() {\n         check("}, {"sha": "9a2b9c2fa4081475104b43224d2f6350169e826a", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -5,7 +5,7 @@ use ide_db::helpers::{insert_use::ImportScope, SnippetCap};\n use syntax::T;\n \n use crate::{\n-    context::PathCompletionContext, item::Builder, CompletionContext, CompletionItem,\n+    context::PathCompletionCtx, item::Builder, CompletionContext, CompletionItem,\n     CompletionItemKind, Completions, SnippetScope,\n };\n \n@@ -21,7 +21,9 @@ pub(crate) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionConte\n     }\n \n     let can_be_stmt = match ctx.path_context {\n-        Some(PathCompletionContext { is_trivial_path: true, can_be_stmt, .. }) => can_be_stmt,\n+        Some(PathCompletionCtx {\n+            is_absolute_path: false, qualifier: None, can_be_stmt, ..\n+        }) => can_be_stmt,\n         _ => return,\n     };\n "}, {"sha": "cca2785e2dd43c056141eff1680c5f17503c3c3a", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -4,8 +4,8 @@ use hir::ScopeDef;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    completions::{module_or_attr, module_or_fn_macro},\n-    context::{PathCompletionContext, PathKind},\n+    completions::module_or_fn_macro,\n+    context::{PathCompletionCtx, PathKind},\n     patterns::ImmediateLocation,\n     CompletionContext, Completions,\n };\n@@ -15,37 +15,22 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     if ctx.is_path_disallowed() || ctx.has_impl_or_trait_prev_sibling() {\n         return;\n     }\n-    let kind = match ctx.path_context {\n-        Some(PathCompletionContext { is_trivial_path: true, kind, .. }) => kind,\n+    match ctx.path_context {\n+        Some(PathCompletionCtx {\n+            kind:\n+                Some(\n+                    PathKind::Vis { .. }\n+                    | PathKind::Attr { .. }\n+                    | PathKind::Use { .. }\n+                    | PathKind::Pat,\n+                ),\n+            ..\n+        }) => return,\n+        Some(PathCompletionCtx { is_absolute_path: false, qualifier: None, .. }) => (),\n         _ => return,\n-    };\n-\n-    if let Some(PathKind::Use) = kind {\n-        // only show modules in a fresh UseTree\n-        cov_mark::hit!(unqualified_path_only_modules_in_import);\n-        ctx.process_all_names(&mut |name, res| {\n-            if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n-                acc.add_resolution(ctx, name, res);\n-            }\n-        });\n-\n-        [\"self::\", \"super::\", \"crate::\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n-        return;\n     }\n-    [\"self\", \"super\", \"crate\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n \n-    match kind {\n-        Some(PathKind::Vis { .. }) => return,\n-        Some(PathKind::Attr) => {\n-            ctx.process_all_names(&mut |name, def| {\n-                if let Some(def) = module_or_attr(def) {\n-                    acc.add_resolution(ctx, name, def);\n-                }\n-            });\n-            return;\n-        }\n-        _ => (),\n-    }\n+    [\"self\", \"super\", \"crate\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n \n     match &ctx.completion_location {\n         Some(ImmediateLocation::ItemList | ImmediateLocation::Trait | ImmediateLocation::Impl) => {"}, {"sha": "6f980845c7db52c8d78983a0c9eb8815a5296d8b", "filename": "crates/ide_completion/src/completions/use_.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -0,0 +1,95 @@\n+//! Completion for use trees\n+\n+use hir::ScopeDef;\n+use syntax::{ast, AstNode};\n+\n+use crate::{\n+    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n+    Completions,\n+};\n+\n+pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext) {\n+    let (is_absolute_path, qualifier) = match ctx.path_context {\n+        Some(PathCompletionCtx {\n+            kind: Some(PathKind::Use),\n+            is_absolute_path,\n+            ref qualifier,\n+            ..\n+        }) => (is_absolute_path, qualifier),\n+        _ => return,\n+    };\n+\n+    match qualifier {\n+        Some(PathQualifierCtx { path, resolution, is_super_chain, use_tree_parent }) => {\n+            if *is_super_chain {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n+            // only show `self` in a new use-tree when the qualifier doesn't end in self\n+            let not_preceded_by_self = *use_tree_parent\n+                && !matches!(\n+                    path.segment().and_then(|it| it.kind()),\n+                    Some(ast::PathSegmentKind::SelfKw)\n+                );\n+            if not_preceded_by_self {\n+                acc.add_keyword(ctx, \"self\");\n+            }\n+\n+            let resolution = match resolution {\n+                Some(it) => it,\n+                None => return,\n+            };\n+\n+            match resolution {\n+                hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n+                    let module_scope = module.scope(ctx.db, ctx.module);\n+                    let unknown_is_current = |name: &hir::Name| {\n+                        matches!(\n+                            ctx.name_syntax.as_ref(),\n+                            Some(ast::NameLike::NameRef(name_ref))\n+                                if name_ref.syntax().text() == name.to_smol_str().as_str()\n+                        )\n+                    };\n+                    for (name, def) in module_scope {\n+                        let add_resolution = match def {\n+                            ScopeDef::Unknown if unknown_is_current(&name) => {\n+                                // for `use self::foo$0`, don't suggest `foo` as a completion\n+                                cov_mark::hit!(dont_complete_current_use);\n+                                continue;\n+                            }\n+                            ScopeDef::ModuleDef(_) | ScopeDef::MacroDef(_) | ScopeDef::Unknown => {\n+                                true\n+                            }\n+                            _ => false,\n+                        };\n+\n+                        if add_resolution {\n+                            acc.add_resolution(ctx, name, def);\n+                        }\n+                    }\n+                }\n+                hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(e))) => {\n+                    cov_mark::hit!(enum_plain_qualified_use_tree);\n+                    e.variants(ctx.db)\n+                        .into_iter()\n+                        .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+                }\n+                _ => {}\n+            }\n+        }\n+        // fresh use tree with leading colon2, only show crate roots\n+        None if is_absolute_path => {\n+            cov_mark::hit!(use_tree_crate_roots_only);\n+            acc.add_crate_roots(ctx);\n+        }\n+        // only show modules in a fresh UseTree\n+        None => {\n+            cov_mark::hit!(unqualified_path_only_modules_in_import);\n+            ctx.process_all_names(&mut |name, res| {\n+                if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n+                    acc.add_resolution(ctx, name, res);\n+                }\n+            });\n+            acc.add_nameref_keywords(ctx);\n+        }\n+    }\n+}"}, {"sha": "9cf96326588ce0cab490686772ab8d928360a843", "filename": "crates/ide_completion/src/completions/vis.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -0,0 +1,52 @@\n+//! Completion for visibility specifiers.\n+\n+use hir::ScopeDef;\n+\n+use crate::{\n+    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx},\n+    Completions,\n+};\n+\n+pub(crate) fn complete_vis(acc: &mut Completions, ctx: &CompletionContext) {\n+    let (is_absolute_path, qualifier, has_in_token) = match ctx.path_context {\n+        Some(PathCompletionCtx {\n+            kind: Some(PathKind::Vis { has_in_token }),\n+            is_absolute_path,\n+            ref qualifier,\n+            ..\n+        }) => (is_absolute_path, qualifier, has_in_token),\n+        _ => return,\n+    };\n+\n+    match qualifier {\n+        Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+            if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) = resolution {\n+                if let Some(current_module) = ctx.module {\n+                    let next_towards_current = current_module\n+                        .path_to_root(ctx.db)\n+                        .into_iter()\n+                        .take_while(|it| it != module)\n+                        .next();\n+                    if let Some(next) = next_towards_current {\n+                        if let Some(name) = next.name(ctx.db) {\n+                            cov_mark::hit!(visibility_qualified);\n+                            acc.add_resolution(ctx, name, ScopeDef::ModuleDef(next.into()));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if *is_super_chain {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n+        }\n+        None if !is_absolute_path => {\n+            if !has_in_token {\n+                cov_mark::hit!(kw_completion_in);\n+                acc.add_keyword(ctx, \"in\");\n+            }\n+            [\"self\", \"super\", \"crate\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n+        }\n+        _ => {}\n+    }\n+}"}, {"sha": "d711215491c1dcc3ae4ec2ef7f3c3466325c196e", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 91, "deletions": 49, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -3,16 +3,18 @@\n use std::iter;\n \n use base_db::SourceDatabaseExt;\n-use hir::{HasAttrs, Local, Name, ScopeDef, Semantics, SemanticsScope, Type, TypeInfo};\n+use hir::{\n+    HasAttrs, Local, Name, PathResolution, ScopeDef, Semantics, SemanticsScope, Type, TypeInfo,\n+};\n use ide_db::{\n     active_parameter::ActiveParameter,\n     base_db::{FilePosition, SourceDatabase},\n     helpers::FamousDefs,\n     RootDatabase,\n };\n use syntax::{\n-    algo::find_node_at_offset,\n-    ast::{self, HasName, NameOrNameRef},\n+    algo::{find_node_at_offset, non_trivia_sibling},\n+    ast::{self, AttrKind, HasName, NameOrNameRef},\n     match_ast, AstNode, NodeOrToken,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n@@ -34,6 +36,7 @@ pub(crate) enum PatternRefutability {\n     Refutable,\n     Irrefutable,\n }\n+\n pub(crate) enum Visible {\n     Yes,\n     Editable,\n@@ -44,26 +47,21 @@ pub(crate) enum Visible {\n pub(super) enum PathKind {\n     Expr,\n     Type,\n-    Attr,\n+    Attr { kind: AttrKind, annotated_item_kind: Option<SyntaxKind> },\n     Mac,\n     Pat,\n     Vis { has_in_token: bool },\n     Use,\n }\n \n #[derive(Debug)]\n-pub(crate) struct PathCompletionContext {\n+pub(crate) struct PathCompletionCtx {\n     /// If this is a call with () already there\n     has_call_parens: bool,\n-    /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n-    pub(super) is_trivial_path: bool,\n-    /// If not a trivial path, the prefix (qualifier).\n-    pub(super) qualifier: Option<ast::Path>,\n-    #[allow(dead_code)]\n-    /// If not a trivial path, the suffix (parent).\n-    pub(super) parent: Option<ast::Path>,\n-    /// Whether the qualifier comes from a use tree parent or not\n-    pub(super) use_tree_parent: bool,\n+    /// Whether this path stars with a `::`.\n+    pub(super) is_absolute_path: bool,\n+    /// The qualifier of the current path if it exists.\n+    pub(super) qualifier: Option<PathQualifierCtx>,\n     pub(super) kind: Option<PathKind>,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,\n@@ -72,11 +70,24 @@ pub(crate) struct PathCompletionContext {\n     pub(super) in_loop_body: bool,\n }\n \n+#[derive(Debug)]\n+pub(crate) struct PathQualifierCtx {\n+    pub(crate) path: ast::Path,\n+    pub(crate) resolution: Option<PathResolution>,\n+    /// Whether this path consists solely of `super` segments\n+    pub(crate) is_super_chain: bool,\n+    /// Whether the qualifier comes from a use tree parent or not\n+    pub(crate) use_tree_parent: bool,\n+}\n+\n #[derive(Debug)]\n pub(super) struct PatternContext {\n     pub(super) refutability: PatternRefutability,\n     pub(super) param_ctx: Option<(ast::ParamList, ast::Param, ParamKind)>,\n     pub(super) has_type_ascription: bool,\n+    pub(super) parent_pat: Option<ast::Pat>,\n+    pub(super) ref_token: Option<SyntaxToken>,\n+    pub(super) mut_token: Option<SyntaxToken>,\n }\n \n #[derive(Debug)]\n@@ -129,7 +140,7 @@ pub(crate) struct CompletionContext<'a> {\n \n     pub(super) lifetime_ctx: Option<LifetimeContext>,\n     pub(super) pattern_ctx: Option<PatternContext>,\n-    pub(super) path_context: Option<PathCompletionContext>,\n+    pub(super) path_context: Option<PathCompletionCtx>,\n \n     pub(super) locals: Vec<(Name, Local)>,\n \n@@ -211,11 +222,8 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.completion_location, Some(ImmediateLocation::StmtList))\n     }\n \n-    pub(crate) fn expects_ident_pat_or_ref_expr(&self) -> bool {\n-        matches!(\n-            self.completion_location,\n-            Some(ImmediateLocation::IdentPat | ImmediateLocation::RefExpr)\n-        )\n+    pub(crate) fn expects_ident_ref_expr(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::RefExpr))\n     }\n \n     pub(crate) fn expect_field(&self) -> bool {\n@@ -262,27 +270,29 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     pub(crate) fn expects_expression(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionContext { kind: Some(PathKind::Expr), .. }))\n+        matches!(self.path_context, Some(PathCompletionCtx { kind: Some(PathKind::Expr), .. }))\n     }\n \n     pub(crate) fn expects_type(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionContext { kind: Some(PathKind::Type), .. }))\n+        matches!(self.path_context, Some(PathCompletionCtx { kind: Some(PathKind::Type), .. }))\n     }\n \n     pub(crate) fn path_is_call(&self) -> bool {\n         self.path_context.as_ref().map_or(false, |it| it.has_call_parens)\n     }\n \n-    pub(crate) fn is_trivial_path(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionContext { is_trivial_path: true, .. }))\n-    }\n-\n     pub(crate) fn is_non_trivial_path(&self) -> bool {\n-        matches!(self.path_context, Some(PathCompletionContext { is_trivial_path: false, .. }))\n+        matches!(\n+            self.path_context,\n+            Some(\n+                PathCompletionCtx { is_absolute_path: true, .. }\n+                    | PathCompletionCtx { qualifier: Some(_), .. }\n+            )\n+        )\n     }\n \n     pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n-        self.path_context.as_ref().and_then(|it| it.qualifier.as_ref())\n+        self.path_context.as_ref().and_then(|it| it.qualifier.as_ref().map(|it| &it.path))\n     }\n \n     pub(crate) fn path_kind(&self) -> Option<PathKind> {\n@@ -779,37 +789,33 @@ impl<'a> CompletionContext<'a> {\n         if is_name_in_field_pat {\n             return None;\n         }\n-        if !bind_pat.is_simple_ident() {\n-            return None;\n-        }\n         Some(pattern_context_for(original_file, bind_pat.into()))\n     }\n \n     fn classify_name_ref(\n-        _sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<RootDatabase>,\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n-    ) -> Option<(PathCompletionContext, Option<PatternContext>)> {\n+    ) -> Option<(PathCompletionCtx, Option<PatternContext>)> {\n         let parent = name_ref.syntax().parent()?;\n         let segment = ast::PathSegment::cast(parent)?;\n         let path = segment.parent_path();\n \n-        let mut path_ctx = PathCompletionContext {\n+        let mut path_ctx = PathCompletionCtx {\n             has_call_parens: false,\n-            is_trivial_path: false,\n+            is_absolute_path: false,\n             qualifier: None,\n-            parent: None,\n             has_type_args: false,\n             can_be_stmt: false,\n             in_loop_body: false,\n-            use_tree_parent: false,\n             kind: None,\n         };\n         let mut pat_ctx = None;\n         path_ctx.in_loop_body = is_in_loop_body(name_ref.syntax());\n \n-        path_ctx.kind  = path.syntax().ancestors().find_map(|it| {\n-            match_ast! {\n+        path_ctx.kind = path.syntax().ancestors().find_map(|it| {\n+            // using Option<Option<PathKind>> as extra controlflow\n+            let kind = match_ast! {\n                 match it {\n                     ast::PathType(_) => Some(PathKind::Type),\n                     ast::PathExpr(it) => {\n@@ -830,32 +836,57 @@ impl<'a> CompletionContext<'a> {\n                         Some(PathKind::Pat)\n                     },\n                     ast::MacroCall(it) => it.excl_token().and(Some(PathKind::Mac)),\n-                    ast::Meta(_) => Some(PathKind::Attr),\n+                    ast::Meta(meta) => (|| {\n+                        let attr = meta.parent_attr()?;\n+                        let kind = attr.kind();\n+                        let attached = attr.syntax().parent()?;\n+                        let is_trailing_outer_attr = kind != AttrKind::Inner\n+                            && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next).is_none();\n+                        let annotated_item_kind = if is_trailing_outer_attr {\n+                            None\n+                        } else {\n+                            Some(attached.kind())\n+                        };\n+                        Some(PathKind::Attr {\n+                            kind,\n+                            annotated_item_kind,\n+                        })\n+                    })(),\n                     ast::Visibility(it) => Some(PathKind::Vis { has_in_token: it.in_token().is_some() }),\n                     ast::UseTree(_) => Some(PathKind::Use),\n-                    _ => None,\n+                    _ => return None,\n                 }\n-            }\n-        });\n+            };\n+            Some(kind)\n+        }).flatten();\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n         if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n-            path_ctx.use_tree_parent = use_tree_parent;\n-            path_ctx.qualifier = path\n+            if !use_tree_parent {\n+                path_ctx.is_absolute_path =\n+                    path.top_path().segment().map_or(false, |it| it.coloncolon_token().is_some());\n+            }\n+\n+            let path = path\n                 .segment()\n                 .and_then(|it| find_node_in_file(original_file, &it))\n                 .map(|it| it.parent_path());\n+            path_ctx.qualifier = path.map(|path| {\n+                let res = sema.resolve_path(&path);\n+                let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n+                    .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n+                PathQualifierCtx { path, resolution: res, is_super_chain, use_tree_parent }\n+            });\n             return Some((path_ctx, pat_ctx));\n         }\n \n         if let Some(segment) = path.segment() {\n             if segment.coloncolon_token().is_some() {\n+                path_ctx.is_absolute_path = true;\n                 return Some((path_ctx, pat_ctx));\n             }\n         }\n \n-        path_ctx.is_trivial_path = true;\n-\n         // Find either enclosing expr statement (thing with `;`) or a\n         // block. If block, check that we are the last expr.\n         path_ctx.can_be_stmt = name_ref\n@@ -915,7 +946,18 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n             };\n             (refutability, false)\n         });\n-    PatternContext { refutability, param_ctx: is_param, has_type_ascription }\n+    let (ref_token, mut_token) = match &pat {\n+        ast::Pat::IdentPat(it) => (it.ref_token(), it.mut_token()),\n+        _ => (None, None),\n+    };\n+    PatternContext {\n+        refutability,\n+        param_ctx: is_param,\n+        has_type_ascription,\n+        parent_pat: pat.syntax().parent().and_then(ast::Pat::cast),\n+        mut_token,\n+        ref_token,\n+    }\n }\n \n fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {\n@@ -946,7 +988,7 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     }\n     let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n     let use_tree = use_tree_list.syntax().parent().and_then(ast::UseTree::cast)?;\n-    use_tree.path().zip(Some(true))\n+    Some((use_tree.path()?, true))\n }\n \n fn has_ref(token: &SyntaxToken) -> bool {"}, {"sha": "f0cd125973a2fbdef71042e331c9209cd13d235d", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -151,7 +151,10 @@ pub fn completions(\n     }\n \n     let mut acc = Completions::default();\n+    completions::attribute::complete_known_attribute_input(&mut acc, &ctx);\n     completions::attribute::complete_attribute(&mut acc, &ctx);\n+    completions::use_::complete_use_tree(&mut acc, &ctx);\n+    completions::vis::complete_vis(&mut acc, &ctx);\n     completions::fn_param::complete_fn_param(&mut acc, &ctx);\n     completions::keyword::complete_expr_keyword(&mut acc, &ctx);\n     completions::snippet::complete_expr_snippet(&mut acc, &ctx);"}, {"sha": "027fb5352715156351ef6e699ac956d329d01e15", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -19,7 +19,7 @@ use ide_db::{\n use syntax::{SmolStr, SyntaxKind, TextRange};\n \n use crate::{\n-    context::{PathCompletionContext, PathKind},\n+    context::{PathCompletionCtx, PathKind},\n     item::{CompletionRelevanceTypeMatch, ImportEdit},\n     render::{enum_variant::render_variant, function::render_fn, macro_::render_macro},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionRelevance,\n@@ -234,7 +234,7 @@ fn render_resolution_(\n     // Add `<>` for generic types\n     let type_path_no_ty_args = matches!(\n         ctx.completion.path_context,\n-        Some(PathCompletionContext { kind: Some(PathKind::Type), has_type_args: false, .. })\n+        Some(PathCompletionCtx { kind: Some(PathKind::Type), has_type_args: false, .. })\n     ) && ctx.completion.config.add_call_parenthesis;\n     if type_path_no_ty_args {\n         if let Some(cap) = ctx.snippet_cap() {"}, {"sha": "5a9c48a3278ced514a0c356480fa7d609d551958", "filename": "crates/ide_completion/src/tests/attribute.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -17,6 +17,10 @@ fn proc_macros() {\n struct Foo;\n \"#,\n         expect![[r#\"\n+            md proc_macros\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -32,10 +36,6 @@ struct Foo;\n             at derive(\u2026)\n             at repr(\u2026)\n             at non_exhaustive\n-            kw self\n-            kw super\n-            kw crate\n-            md proc_macros\n         \"#]],\n     )\n }\n@@ -78,15 +78,15 @@ fn with_existing_attr() {\n     check(\n         r#\"#[no_mangle] #[$0] mcall!();\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n             at deny(\u2026)\n             at forbid(\u2026)\n             at warn(\u2026)\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     )\n }\n@@ -96,6 +96,9 @@ fn attr_on_source_file() {\n     check(\n         r#\"#![$0]\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -116,9 +119,6 @@ fn attr_on_source_file() {\n             at recursion_limit = \"\u2026\"\n             at type_length_limit = \u2026\n             at windows_subsystem = \"\u2026\"\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -128,6 +128,9 @@ fn attr_on_module() {\n     check(\n         r#\"#[$0] mod foo;\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -142,14 +145,14 @@ fn attr_on_module() {\n             at no_mangle\n             at macro_use\n             at path = \"\u2026\"\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n     check(\n         r#\"mod foo {#![$0]}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -163,9 +166,6 @@ fn attr_on_module() {\n             at must_use\n             at no_mangle\n             at no_implicit_prelude\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -175,6 +175,9 @@ fn attr_on_macro_rules() {\n     check(\n         r#\"#[$0] macro_rules! foo {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -189,9 +192,6 @@ fn attr_on_macro_rules() {\n             at no_mangle\n             at macro_export\n             at macro_use\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -201,6 +201,9 @@ fn attr_on_macro_def() {\n     check(\n         r#\"#[$0] macro foo {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -213,9 +216,6 @@ fn attr_on_macro_def() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -225,6 +225,9 @@ fn attr_on_extern_crate() {\n     check(\n         r#\"#[$0] extern crate foo;\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -238,9 +241,6 @@ fn attr_on_extern_crate() {\n             at must_use\n             at no_mangle\n             at macro_use\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -250,6 +250,9 @@ fn attr_on_use() {\n     check(\n         r#\"#[$0] use foo;\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -262,9 +265,6 @@ fn attr_on_use() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -274,6 +274,9 @@ fn attr_on_type_alias() {\n     check(\n         r#\"#[$0] type foo = ();\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -286,9 +289,6 @@ fn attr_on_type_alias() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -302,6 +302,11 @@ fn attr_on_struct() {\n struct Foo;\n \"#,\n         expect![[r#\"\n+            md core\n+            at derive           pub macro derive\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -317,11 +322,6 @@ struct Foo;\n             at derive(\u2026)\n             at repr(\u2026)\n             at non_exhaustive\n-            kw self\n-            kw super\n-            kw crate\n-            md core\n-            at derive           pub macro derive\n         \"#]],\n     );\n }\n@@ -331,6 +331,9 @@ fn attr_on_enum() {\n     check(\n         r#\"#[$0] enum Foo {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -346,9 +349,6 @@ fn attr_on_enum() {\n             at derive(\u2026)\n             at repr(\u2026)\n             at non_exhaustive\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -358,6 +358,9 @@ fn attr_on_const() {\n     check(\n         r#\"#[$0] const FOO: () = ();\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -370,9 +373,6 @@ fn attr_on_const() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -382,6 +382,9 @@ fn attr_on_static() {\n     check(\n         r#\"#[$0] static FOO: () = ()\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -399,9 +402,6 @@ fn attr_on_static() {\n             at link_section = \"\u2026\"\n             at global_allocator\n             at used\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -411,6 +411,9 @@ fn attr_on_trait() {\n     check(\n         r#\"#[$0] trait Foo {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -424,9 +427,6 @@ fn attr_on_trait() {\n             at must_use\n             at no_mangle\n             at must_use\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -436,6 +436,9 @@ fn attr_on_impl() {\n     check(\n         r#\"#[$0] impl () {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -449,14 +452,14 @@ fn attr_on_impl() {\n             at must_use\n             at no_mangle\n             at automatically_derived\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n     check(\n         r#\"impl () {#![$0]}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -469,9 +472,6 @@ fn attr_on_impl() {\n             at doc(alias = \"\u2026\")\n             at must_use\n             at no_mangle\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -481,6 +481,9 @@ fn attr_on_extern_block() {\n     check(\n         r#\"#[$0] extern {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -494,14 +497,14 @@ fn attr_on_extern_block() {\n             at must_use\n             at no_mangle\n             at link\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n     check(\n         r#\"extern {#![$0]}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -515,9 +518,6 @@ fn attr_on_extern_block() {\n             at must_use\n             at no_mangle\n             at link\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -527,16 +527,16 @@ fn attr_on_variant() {\n     check(\n         r#\"enum Foo { #[$0] Bar }\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n             at deny(\u2026)\n             at forbid(\u2026)\n             at warn(\u2026)\n             at non_exhaustive\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -546,6 +546,9 @@ fn attr_on_fn() {\n     check(\n         r#\"#[$0] fn main() {}\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -573,9 +576,6 @@ fn attr_on_fn() {\n             at target_feature = \"\u2026\"\n             at test\n             at track_caller\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -586,15 +586,15 @@ fn attr_on_expr() {\n     check(\n         r#\"fn main() { #[$0] foo() }\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n             at deny(\u2026)\n             at forbid(\u2026)\n             at warn(\u2026)\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }\n@@ -604,6 +604,9 @@ fn attr_in_source_file_end() {\n     check(\n         r#\"#[$0]\"#,\n         expect![[r#\"\n+            kw self::\n+            kw super::\n+            kw crate::\n             at allow(\u2026)\n             at automatically_derived\n             at cfg(\u2026)\n@@ -640,9 +643,6 @@ fn attr_in_source_file_end() {\n             at track_caller\n             at used\n             at warn(\u2026)\n-            kw self\n-            kw super\n-            kw crate\n         \"#]],\n     );\n }"}, {"sha": "779ec0c3a7661ea44b1e4ce1548cdfb7dd3de84e", "filename": "crates/ide_completion/src/tests/fn_param.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -17,6 +17,7 @@ fn baz(file$0) {}\n \"#,\n         expect![[r#\"\n             bn file_id: usize\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -32,6 +33,7 @@ fn baz(foo: (), file$0) {}\n \"#,\n         expect![[r#\"\n             bn file_id: usize\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -47,6 +49,7 @@ fn baz(file$0 id: u32) {}\n \"#,\n         expect![[r#\"\n             bn file_id: usize,\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -60,6 +63,7 @@ fn foo(file_id: usize) {}\n fn bar(file_id: u32, $0) {}\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -76,6 +80,7 @@ pub(crate) trait SourceRoot {\n \"#,\n         expect![[r#\"\n             bn file_id: usize\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -91,6 +96,7 @@ fn outer(text: &str) {\n \"#,\n         expect![[r#\"\n             bn text: &str\n+            kw ref\n             kw mut\n         \"#]],\n     )\n@@ -106,6 +112,7 @@ fn foo2($0) {}\n \"#,\n         expect![[r#\"\n             bn Bar { bar }: Bar\n+            kw ref\n             kw mut\n             bn Bar              Bar { bar$1 }: Bar$0\n             st Bar\n@@ -130,6 +137,7 @@ impl A {\n             bn mut self\n             bn &mut self\n             bn file_id: usize\n+            kw ref\n             kw mut\n             sp Self\n             st A\n@@ -150,6 +158,7 @@ impl A {\n \"#,\n         expect![[r#\"\n             bn file_id: usize\n+            kw ref\n             kw mut\n             sp Self\n             st A\n@@ -178,6 +187,7 @@ fn outer() {\n             bn foo: i32\n             bn baz: i32\n             bn bar: i32\n+            kw ref\n             kw mut\n         \"#]],\n     )\n@@ -202,6 +212,22 @@ fn outer() {\n             bn baz: i32\n             bn bar: i32\n             bn foo: i32\n+            kw ref\n+            kw mut\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_fully_equal() {\n+    check(\n+        r#\"\n+fn foo(bar: u32) {}\n+fn bar(bar$0) {}\n+\"#,\n+        expect![[r#\"\n+            bn bar: u32\n+            kw ref\n             kw mut\n         \"#]],\n     )"}, {"sha": "fe532576729dfdec594b155b88ace75fef293197", "filename": "crates/ide_completion/src/tests/pattern.rs", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -22,6 +22,7 @@ fn quux() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -53,26 +54,21 @@ fn quux() {\n \n #[test]\n fn ident_ref_mut_pat() {\n-    // FIXME mut is already here, don't complete it again\n     check_empty(\n         r#\"\n fn quux() {\n     let ref mut en$0\n }\n \"#,\n-        expect![[r#\"\n-            kw mut\n-        \"#]],\n+        expect![[r#\"\"#]],\n     );\n     check_empty(\n         r#\"\n fn quux() {\n     let ref mut en$0 @ x\n }\n \"#,\n-        expect![[r#\"\n-            kw mut\n-        \"#]],\n+        expect![[r#\"\"#]],\n     );\n }\n \n@@ -88,16 +84,13 @@ fn quux() {\n             kw mut\n         \"#]],\n     );\n-    // FIXME mut is already here, don't complete it again\n     check_empty(\n         r#\"\n fn quux() {\n     let &mut en$0\n }\n \"#,\n-        expect![[r#\"\n-            kw mut\n-        \"#]],\n+        expect![[r#\"\"#]],\n     );\n }\n \n@@ -110,6 +103,7 @@ fn foo() {\n }\n \"#,\n         expect![[r##\"\n+            kw ref\n             kw mut\n             en Enum\n             bn Record    Record { field$1 }$0\n@@ -139,6 +133,7 @@ fn foo() {\n }\n \"#,\n         expect![[r##\"\n+            kw ref\n             kw mut\n             bn Record            Record { field$1 }$0\n             st Record\n@@ -160,6 +155,7 @@ fn foo(a$0) {\n }\n \"#,\n         expect![[r##\"\n+            kw ref\n             kw mut\n             bn Record    Record { field$1 }: Record$0\n             st Record\n@@ -175,6 +171,7 @@ fn foo(a$0: Tuple) {\n }\n \"#,\n         expect![[r##\"\n+            kw ref\n             kw mut\n             bn Record    Record { field$1 }$0\n             st Record\n@@ -200,6 +197,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             ma m!(\u2026) macro_rules! m\n         \"#]],\n@@ -218,6 +216,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             ev E::X  ()\n             en E\n@@ -242,6 +241,7 @@ fn outer() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Record    Record { field$1, .. }$0\n             st Record\n@@ -267,6 +267,7 @@ impl Foo {\n }\n     \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Self Self($1)$0\n             sp Self\n@@ -278,7 +279,6 @@ impl Foo {\n \n #[test]\n fn enum_qualified() {\n-    // FIXME: Don't show functions, they aren't patterns\n     check(\n         r#\"\n impl Enum {\n@@ -291,12 +291,9 @@ fn func() {\n }\n \"#,\n         expect![[r#\"\n-            ev TupleV(\u2026)   (u32)\n-            ev RecordV     {field: u32}\n-            ev UnitV       ()\n-            ct ASSOC_CONST const ASSOC_CONST: ()\n-            fn assoc_fn()  fn()\n-            ta AssocType   type AssocType = ()\n+            ev TupleV(\u2026) (u32)\n+            ev RecordV   {field: u32}\n+            ev UnitV     ()\n         \"#]],\n     );\n }\n@@ -310,6 +307,7 @@ struct Bar(u32);\n fn outer(Foo { bar: $0 }: Foo) {}\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Foo Foo { bar$1 }$0\n             st Foo\n@@ -340,6 +338,7 @@ struct Bar(u32);\n fn foo($0) {}\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Foo Foo { bar$1 }: Foo$0\n             st Foo\n@@ -360,6 +359,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Foo Foo { bar$1 }$0\n             st Foo\n@@ -368,17 +368,3 @@ fn foo() {\n         \"#]],\n     )\n }\n-\n-#[test]\n-fn completes_fully_equal() {\n-    check_empty(\n-        r#\"\n-fn foo(bar: u32) {}\n-fn bar(bar$0) {}\n-\"#,\n-        expect![[r#\"\n-            bn bar: u32\n-            kw mut\n-        \"#]],\n-    )\n-}"}, {"sha": "73cb83957f6a6a4612d8f83ceea01f615ba3d958", "filename": "crates/ide_completion/src/tests/use_tree.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Ftests%2Fuse_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_completion%2Fsrc%2Ftests%2Fuse_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fuse_tree.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -31,6 +31,25 @@ mod foo {}\n     );\n }\n \n+#[test]\n+fn use_tree_start_abs() {\n+    cov_mark::check!(use_tree_crate_roots_only);\n+    check(\n+        r#\"\n+//- /lib.rs crate:main deps:other_crate\n+use ::f$0\n+\n+struct Foo;\n+mod foo {}\n+//- /other_crate/lib.rs crate:other_crate\n+// nothing here\n+\"#,\n+        expect![[r#\"\n+            md other_crate\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn dont_complete_current_use() {\n     cov_mark::check!(dont_complete_current_use);\n@@ -134,6 +153,25 @@ struct Bar;\n     );\n }\n \n+#[test]\n+fn enum_plain_qualified_use_tree() {\n+    cov_mark::check!(enum_plain_qualified_use_tree);\n+    check(\n+        r#\"\n+use Foo::$0\n+\n+enum Foo { Variant }\n+impl Foo {\n+    const CONST: () = ()\n+    fn func() {}\n+}\n+\"#,\n+        expect![[r#\"\n+            ev Variant ()\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn self_qualified_use_tree() {\n     check("}, {"sha": "7ea2bc63f25cad0df0f52d4b1909b003cd70411b", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -223,7 +223,7 @@ impl Definition {\n         // def is crate root\n         // FIXME: We don't do searches for crates currently, as a crate does not actually have a single name\n         if let &Definition::Module(module) = self {\n-            if module.crate_root(db) == module {\n+            if module.is_crate_root(db) {\n                 return SearchScope::reverse_dependencies(db, module.krate());\n             }\n         }\n@@ -378,7 +378,7 @@ impl<'a> FindUsages<'a> {\n \n         let name = match self.def {\n             // special case crate modules as these do not have a proper name\n-            Definition::Module(module) if module.crate_root(self.sema.db) == module => {\n+            Definition::Module(module) if module.is_crate_root(self.sema.db) => {\n                 // FIXME: This assumes the crate name is always equal to its display name when it really isn't\n                 module\n                     .krate()\n@@ -460,7 +460,7 @@ impl<'a> FindUsages<'a> {\n             Definition::Module(module) => {\n                 let scope = search_scope.intersection(&SearchScope::module(self.sema.db, module));\n \n-                let is_crate_root = module.crate_root(self.sema.db) == module;\n+                let is_crate_root = module.is_crate_root(self.sema.db);\n \n                 for (text, file_id, search_range) in scope_files(sema, &scope) {\n                     let tree = Lazy::new(move || sema.parse(file_id).syntax().clone());"}, {"sha": "067e13ee14dd8f22f08fb6b381ba5696ed8df310", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=5a7e11f5fbc6cdf7af79afe70a94c78b79e366d2", "patch": "@@ -119,7 +119,7 @@ impl From<ast::AssocItem> for ast::Item {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum AttrKind {\n     Inner,\n     Outer,"}]}