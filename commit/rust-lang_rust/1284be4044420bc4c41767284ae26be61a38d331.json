{"sha": "1284be4044420bc4c41767284ae26be61a38d331", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyODRiZTQwNDQ0MjBiYzRjNDE3NjcyODRhZTI2YmU2MWEzOGQzMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-18T00:48:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-18T00:48:34Z"}, "message": "Auto merge of #23985 - erickt:derive-cleanup, r=erickt\n\nThis extracts some of the minor cleanup patches from #23905.", "tree": {"sha": "e363960cdf71027e69a8a6c35b5c9150c2eefd22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e363960cdf71027e69a8a6c35b5c9150c2eefd22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1284be4044420bc4c41767284ae26be61a38d331", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1284be4044420bc4c41767284ae26be61a38d331", "html_url": "https://github.com/rust-lang/rust/commit/1284be4044420bc4c41767284ae26be61a38d331", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1284be4044420bc4c41767284ae26be61a38d331/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b08d6cf529a83caec2f408cd8b1287e493ec57ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/b08d6cf529a83caec2f408cd8b1287e493ec57ca", "html_url": "https://github.com/rust-lang/rust/commit/b08d6cf529a83caec2f408cd8b1287e493ec57ca"}, {"sha": "ed437cd8fcbb9ee89849a7eafff94ea97252189e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed437cd8fcbb9ee89849a7eafff94ea97252189e", "html_url": "https://github.com/rust-lang/rust/commit/ed437cd8fcbb9ee89849a7eafff94ea97252189e"}], "stats": {"total": 1019, "additions": 499, "deletions": 520}, "files": [{"sha": "eb3debeac99012945f3a4b2b32d8081116af132e", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -15,22 +15,20 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use ptr::P;\n \n-pub fn expand_deriving_unsafe_bound<F>(cx: &mut ExtCtxt,\n-                                       span: Span,\n-                                       _: &MetaItem,\n-                                       _: &Item,\n-                                       _: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt,\n+                                    span: Span,\n+                                    _: &MetaItem,\n+                                    _: &Item,\n+                                    _: &mut FnMut(P<Item>))\n {\n     cx.span_err(span, \"this unsafe trait should be implemented explicitly\");\n }\n \n-pub fn expand_deriving_copy<F>(cx: &mut ExtCtxt,\n-                               span: Span,\n-                               mitem: &MetaItem,\n-                               item: &Item,\n-                               push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_copy(cx: &mut ExtCtxt,\n+                            span: Span,\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: &mut FnMut(P<Item>))\n {\n     let path = Path::new(vec![\n         if cx.use_std { \"std\" } else { \"core\" },\n@@ -48,5 +46,5 @@ pub fn expand_deriving_copy<F>(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand(cx, mitem, item, push);\n }"}, {"sha": "97fc3f0bf56004308498f08c92dcd48435d97047", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -17,12 +17,11 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_clone<F>(cx: &mut ExtCtxt,\n-                                span: Span,\n-                                mitem: &MetaItem,\n-                                item: &Item,\n-                                push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n+                             span: Span,\n+                             mitem: &MetaItem,\n+                             item: &Item,\n+                             push: &mut FnMut(P<Item>))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));"}, {"sha": "ce8f0a7b32b904e6f68361c1f948808219212d3c", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 36, "deletions": 61, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{MetaItem, Item, Expr, self};\n+use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -17,77 +17,52 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_eq<F>(cx: &mut ExtCtxt,\n-                             span: Span,\n-                             mitem: &MetaItem,\n-                             item: &Item,\n-                             push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n+                          span: Span,\n+                          mitem: &MetaItem,\n+                          item: &Item,\n+                          push: &mut FnMut(P<Item>))\n {\n-    // structures are equal if all fields are equal, and non equal, if\n-    // any fields are not equal or if the enum variants are different\n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(\n-            true,  // use foldl\n-            |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n-                };\n-\n-                let eq = cx.expr_binary(span, ast::BiEq, self_f, other_f.clone());\n-\n-                cx.expr_binary(span, ast::BiAnd, subexpr, eq)\n-            },\n-            cx.expr_bool(span, true),\n-            Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n-            cx, span, substr)\n-    }\n-    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(\n-            true,  // use foldl\n-            |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n-                };\n-\n-                let eq = cx.expr_binary(span, ast::BiNe, self_f, other_f.clone());\n-\n-                cx.expr_binary(span, ast::BiOr, subexpr, eq)\n+    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+        cs_same_method(\n+            |cx, span, exprs| {\n+                // create `a.<method>(); b.<method>(); c.<method>(); ...`\n+                // (where method is `assert_receiver_is_total_eq`)\n+                let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n+                let block = cx.block(span, stmts, None);\n+                cx.expr_block(block)\n             },\n-            cx.expr_bool(span, false),\n-            Box::new(|cx, span, _, _| cx.expr_bool(span, true)),\n-            cx, span, substr)\n+            Box::new(|cx, sp, _, _| {\n+                cx.span_bug(sp, \"non matching enums in derive(Eq)?\") }),\n+            cx,\n+            span,\n+            substr\n+        )\n     }\n \n-    macro_rules! md {\n-        ($name:expr, $f:ident) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-            let attrs = vec!(cx.attribute(span, inline));\n+    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let hidden = cx.meta_word(span, InternedString::new(\"hidden\"));\n+    let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec!(hidden));\n+    let attrs = vec!(cx.attribute(span, inline),\n+                     cx.attribute(span, doc));\n+    let trait_def = TraitDef {\n+        span: span,\n+        attributes: Vec::new(),\n+        path: path_std!(cx, core::cmp::Eq),\n+        additional_bounds: Vec::new(),\n+        generics: LifetimeBounds::empty(),\n+        methods: vec!(\n             MethodDef {\n-                name: $name,\n+                name: \"assert_receiver_is_total_eq\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(borrowed_self()),\n-                ret_ty: Literal(path_local!(bool)),\n+                args: vec!(),\n+                ret_ty: nil_ty(),\n                 attributes: attrs,\n                 combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    $f(a, b, c)\n+                    cs_total_eq_assert(a, b, c)\n                 }))\n             }\n-        } }\n-    }\n-\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: path_std!(cx, core::cmp::PartialEq),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        methods: vec!(\n-            md!(\"eq\", cs_eq),\n-            md!(\"ne\", cs_ne)\n         ),\n         associated_types: Vec::new(),\n     };"}, {"sha": "b2a4ef1dafbc8ee7415e499e562122684b72cfd3", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 44, "deletions": 141, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use self::OrderingOp::*;\n-\n use ast;\n use ast::{MetaItem, Item, Expr};\n use codemap::Span;\n@@ -20,114 +18,71 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_ord<F>(cx: &mut ExtCtxt,\n-                              span: Span,\n-                              mitem: &MetaItem,\n-                              item: &Item,\n-                              push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n+                           span: Span,\n+                           mitem: &MetaItem,\n+                           item: &Item,\n+                           push: &mut FnMut(P<Item>))\n {\n-    macro_rules! md {\n-        ($name:expr, $op:expr, $equal:expr) => { {\n-            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-            let attrs = vec!(cx.attribute(span, inline));\n+    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let attrs = vec!(cx.attribute(span, inline));\n+    let trait_def = TraitDef {\n+        span: span,\n+        attributes: Vec::new(),\n+        path: path_std!(cx, core::cmp::Ord),\n+        additional_bounds: Vec::new(),\n+        generics: LifetimeBounds::empty(),\n+        methods: vec!(\n             MethodDef {\n-                name: $name,\n+                name: \"cmp\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: vec!(borrowed_self()),\n-                ret_ty: Literal(path_local!(bool)),\n+                ret_ty: Literal(path_std!(cx, core::cmp::Ordering)),\n                 attributes: attrs,\n-                combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n-                    cs_op($op, $equal, cx, span, substr)\n-                }))\n+                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                    cs_cmp(a, b, c)\n+                })),\n             }\n-        } }\n-    }\n-\n-    let ordering_ty = Literal(path_std!(cx, core::cmp::Ordering));\n-    let ret_ty = Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n-                                    None,\n-                                    vec![box ordering_ty],\n-                                    true));\n-\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n-\n-    let partial_cmp_def = MethodDef {\n-        name: \"partial_cmp\",\n-        generics: LifetimeBounds::empty(),\n-        explicit_self: borrowed_explicit_self(),\n-        args: vec![borrowed_self()],\n-        ret_ty: ret_ty,\n-        attributes: attrs,\n-        combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n-            cs_partial_cmp(cx, span, substr)\n-        }))\n-    };\n-\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: vec![],\n-        path: path_std!(cx, core::cmp::PartialOrd),\n-        additional_bounds: vec![],\n-        generics: LifetimeBounds::empty(),\n-        methods: vec![\n-            partial_cmp_def,\n-            md!(\"lt\", true, false),\n-            md!(\"le\", true, true),\n-            md!(\"gt\", false, false),\n-            md!(\"ge\", false, true)\n-        ],\n+        ),\n         associated_types: Vec::new(),\n     };\n+\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-#[derive(Copy, Clone)]\n-pub enum OrderingOp {\n-    PartialCmpOp, LtOp, LeOp, GtOp, GeOp,\n-}\n \n-pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n-                               span: Span,\n-                               op: OrderingOp,\n-                               self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n+pub fn ordering_collapsed(cx: &mut ExtCtxt,\n+                          span: Span,\n+                          self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    let op_str = match op {\n-        PartialCmpOp => \"partial_cmp\",\n-        LtOp => \"lt\", LeOp => \"le\",\n-        GtOp => \"gt\", GeOp => \"ge\",\n-    };\n-    cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n+    cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n }\n \n-pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n+pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> P<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n-    let ordering = cx.path_global(span,\n-                                  vec!(cx.ident_of_std(\"core\"),\n-                                       cx.ident_of(\"cmp\"),\n-                                       cx.ident_of(\"Ordering\"),\n-                                       cx.ident_of(\"Equal\")));\n-    let ordering = cx.expr_path(ordering);\n-    let equals_expr = cx.expr_some(span, ordering);\n+    let equals_path = cx.path_global(span,\n+                                     vec!(cx.ident_of_std(\"core\"),\n+                                          cx.ident_of(\"cmp\"),\n+                                          cx.ident_of(\"Ordering\"),\n+                                          cx.ident_of(\"Equal\")));\n \n-    let partial_cmp_path = vec![\n+    let cmp_path = vec![\n         cx.ident_of_std(\"core\"),\n         cx.ident_of(\"cmp\"),\n-        cx.ident_of(\"PartialOrd\"),\n-        cx.ident_of(\"partial_cmp\"),\n+        cx.ident_of(\"Ord\"),\n+        cx.ident_of(\"cmp\"),\n     ];\n \n     /*\n     Builds:\n \n-    let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1);\n-    if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n-        let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2);\n-        if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n+    let __test = ::std::cmp::Ord::cmp(&self_field1, &other_field1);\n+    if other == ::std::cmp::Ordering::Equal {\n+        let __test = ::std::cmp::Ord::cmp(&self_field2, &other_field2);\n+        if __test == ::std::cmp::Ordering::Equal {\n             ...\n         } else {\n             __test\n@@ -144,7 +99,7 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n         false,\n         |cx, span, old, self_f, other_fs| {\n             // let __test = new;\n-            // if __test == Some(::std::cmp::Ordering::Equal) {\n+            // if __test == ::std::cmp::Ordering::Equal {\n             //    old\n             // } else {\n             //    __test\n@@ -161,77 +116,25 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n                     cx.expr_addr_of(span, other_f.clone()),\n                 ];\n \n-                cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+                cx.expr_call_global(span, cmp_path.clone(), args)\n             };\n \n             let assign = cx.stmt_let(span, false, test_id, new);\n \n             let cond = cx.expr_binary(span, ast::BiEq,\n                                       cx.expr_ident(span, test_id),\n-                                      equals_expr.clone());\n+                                      cx.expr_path(equals_path.clone()));\n             let if_ = cx.expr_if(span,\n                                  cond,\n                                  old, Some(cx.expr_ident(span, test_id)));\n             cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n         },\n-        equals_expr.clone(),\n+        cx.expr_path(equals_path.clone()),\n         Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n             if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+                cx.span_bug(span, \"not exactly 2 arguments in `derives(Ord)`\")\n             } else {\n-                some_ordering_collapsed(cx, span, PartialCmpOp, tag_tuple)\n-            }\n-        }),\n-        cx, span, substr)\n-}\n-\n-/// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n-         span: Span, substr: &Substructure) -> P<Expr> {\n-    let op = if less {ast::BiLt} else {ast::BiGt};\n-    cs_fold(\n-        false, // need foldr,\n-        |cx, span, subexpr, self_f, other_fs| {\n-            /*\n-            build up a series of chain ||'s and &&'s from the inside\n-            out (hence foldr) to get lexical ordering, i.e. for op ==\n-            `ast::lt`\n-\n-            ```\n-            self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n-                (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n-                    (false)\n-                ))\n-            )\n-            ```\n-\n-            The optimiser should remove the redundancy. We explicitly\n-            get use the binops to avoid auto-deref dereferencing too many\n-            layers of pointers, if the type includes pointers.\n-            */\n-            let other_f = match other_fs {\n-                [ref o_f] => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            };\n-\n-            let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n-\n-            let not_cmp = cx.expr_unary(span, ast::UnNot,\n-                                        cx.expr_binary(span, op, other_f.clone(), self_f));\n-\n-            let and = cx.expr_binary(span, ast::BiAnd, not_cmp, subexpr);\n-            cx.expr_binary(span, ast::BiOr, cmp, and)\n-        },\n-        cx.expr_bool(span, equal),\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            } else {\n-                let op = match (less, equal) {\n-                    (true,  true) => LeOp, (true,  false) => LtOp,\n-                    (false, true) => GeOp, (false, false) => GtOp,\n-                };\n-                some_ordering_collapsed(cx, span, op, tag_tuple)\n+                ordering_collapsed(cx, span, tag_tuple)\n             }\n         }),\n         cx, span, substr)"}, {"sha": "f02e5ee14126d57c77ff5eff8e83920a07d7d97d", "filename": "src/libsyntax/ext/deriving/cmp/partial_eq.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast::{MetaItem, Item, Expr, self};\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+use ext::deriving::generic::ty::*;\n+use parse::token::InternedString;\n+use ptr::P;\n+\n+pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n+                                  span: Span,\n+                                  mitem: &MetaItem,\n+                                  item: &Item,\n+                                  push: &mut FnMut(P<Item>))\n+{\n+    // structures are equal if all fields are equal, and non equal, if\n+    // any fields are not equal or if the enum variants are different\n+    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+        cs_fold(\n+            true,  // use foldl\n+            |cx, span, subexpr, self_f, other_fs| {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n+                };\n+\n+                let eq = cx.expr_binary(span, ast::BiEq, self_f, other_f.clone());\n+\n+                cx.expr_binary(span, ast::BiAnd, subexpr, eq)\n+            },\n+            cx.expr_bool(span, true),\n+            Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n+            cx, span, substr)\n+    }\n+    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+        cs_fold(\n+            true,  // use foldl\n+            |cx, span, subexpr, self_f, other_fs| {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n+                };\n+\n+                let eq = cx.expr_binary(span, ast::BiNe, self_f, other_f.clone());\n+\n+                cx.expr_binary(span, ast::BiOr, subexpr, eq)\n+            },\n+            cx.expr_bool(span, false),\n+            Box::new(|cx, span, _, _| cx.expr_bool(span, true)),\n+            cx, span, substr)\n+    }\n+\n+    macro_rules! md {\n+        ($name:expr, $f:ident) => { {\n+            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let attrs = vec!(cx.attribute(span, inline));\n+            MethodDef {\n+                name: $name,\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(path_local!(bool)),\n+                attributes: attrs,\n+                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                    $f(a, b, c)\n+                }))\n+            }\n+        } }\n+    }\n+\n+    let trait_def = TraitDef {\n+        span: span,\n+        attributes: Vec::new(),\n+        path: path_std!(cx, core::cmp::PartialEq),\n+        additional_bounds: Vec::new(),\n+        generics: LifetimeBounds::empty(),\n+        methods: vec!(\n+            md!(\"eq\", cs_eq),\n+            md!(\"ne\", cs_ne)\n+        ),\n+        associated_types: Vec::new(),\n+    };\n+    trait_def.expand(cx, mitem, item, push)\n+}"}, {"sha": "9da2db25f7ea2d94e1741b88397848e39f221414", "filename": "src/libsyntax/ext/deriving/cmp/partial_ord.rs", "status": "added", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -0,0 +1,237 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::OrderingOp::*;\n+\n+use ast;\n+use ast::{MetaItem, Item, Expr};\n+use codemap::Span;\n+use ext::base::ExtCtxt;\n+use ext::build::AstBuilder;\n+use ext::deriving::generic::*;\n+use ext::deriving::generic::ty::*;\n+use parse::token::InternedString;\n+use ptr::P;\n+\n+pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n+                                   span: Span,\n+                                   mitem: &MetaItem,\n+                                   item: &Item,\n+                                   push: &mut FnMut(P<Item>))\n+{\n+    macro_rules! md {\n+        ($name:expr, $op:expr, $equal:expr) => { {\n+            let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+            let attrs = vec!(cx.attribute(span, inline));\n+            MethodDef {\n+                name: $name,\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: borrowed_explicit_self(),\n+                args: vec!(borrowed_self()),\n+                ret_ty: Literal(path_local!(bool)),\n+                attributes: attrs,\n+                combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n+                    cs_op($op, $equal, cx, span, substr)\n+                }))\n+            }\n+        } }\n+    }\n+\n+    let ordering_ty = Literal(path_std!(cx, core::cmp::Ordering));\n+    let ret_ty = Literal(Path::new_(pathvec_std!(cx, core::option::Option),\n+                                    None,\n+                                    vec![box ordering_ty],\n+                                    true));\n+\n+    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n+    let attrs = vec!(cx.attribute(span, inline));\n+\n+    let partial_cmp_def = MethodDef {\n+        name: \"partial_cmp\",\n+        generics: LifetimeBounds::empty(),\n+        explicit_self: borrowed_explicit_self(),\n+        args: vec![borrowed_self()],\n+        ret_ty: ret_ty,\n+        attributes: attrs,\n+        combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n+            cs_partial_cmp(cx, span, substr)\n+        }))\n+    };\n+\n+    let trait_def = TraitDef {\n+        span: span,\n+        attributes: vec![],\n+        path: path_std!(cx, core::cmp::PartialOrd),\n+        additional_bounds: vec![],\n+        generics: LifetimeBounds::empty(),\n+        methods: vec![\n+            partial_cmp_def,\n+            md!(\"lt\", true, false),\n+            md!(\"le\", true, true),\n+            md!(\"gt\", false, false),\n+            md!(\"ge\", false, true)\n+        ],\n+        associated_types: Vec::new(),\n+    };\n+    trait_def.expand(cx, mitem, item, push)\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum OrderingOp {\n+    PartialCmpOp, LtOp, LeOp, GtOp, GeOp,\n+}\n+\n+pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               op: OrderingOp,\n+                               self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n+    let lft = cx.expr_ident(span, self_arg_tags[0]);\n+    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n+    let op_str = match op {\n+        PartialCmpOp => \"partial_cmp\",\n+        LtOp => \"lt\", LeOp => \"le\",\n+        GtOp => \"gt\", GeOp => \"ge\",\n+    };\n+    cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n+}\n+\n+pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n+              substr: &Substructure) -> P<Expr> {\n+    let test_id = cx.ident_of(\"__test\");\n+    let ordering = cx.path_global(span,\n+                                  vec!(cx.ident_of_std(\"core\"),\n+                                       cx.ident_of(\"cmp\"),\n+                                       cx.ident_of(\"Ordering\"),\n+                                       cx.ident_of(\"Equal\")));\n+    let ordering = cx.expr_path(ordering);\n+    let equals_expr = cx.expr_some(span, ordering);\n+\n+    let partial_cmp_path = vec![\n+        cx.ident_of_std(\"core\"),\n+        cx.ident_of(\"cmp\"),\n+        cx.ident_of(\"PartialOrd\"),\n+        cx.ident_of(\"partial_cmp\"),\n+    ];\n+\n+    /*\n+    Builds:\n+\n+    let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1);\n+    if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n+        let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2);\n+        if __test == ::std::option::Option::Some(::std::cmp::Ordering::Equal) {\n+            ...\n+        } else {\n+            __test\n+        }\n+    } else {\n+        __test\n+    }\n+\n+    FIXME #6449: These `if`s could/should be `match`es.\n+    */\n+    cs_fold(\n+        // foldr nests the if-elses correctly, leaving the first field\n+        // as the outermost one, and the last as the innermost.\n+        false,\n+        |cx, span, old, self_f, other_fs| {\n+            // let __test = new;\n+            // if __test == Some(::std::cmp::Ordering::Equal) {\n+            //    old\n+            // } else {\n+            //    __test\n+            // }\n+\n+            let new = {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+                };\n+\n+                let args = vec![\n+                    cx.expr_addr_of(span, self_f),\n+                    cx.expr_addr_of(span, other_f.clone()),\n+                ];\n+\n+                cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+            };\n+\n+            let assign = cx.stmt_let(span, false, test_id, new);\n+\n+            let cond = cx.expr_binary(span, ast::BiEq,\n+                                      cx.expr_ident(span, test_id),\n+                                      equals_expr.clone());\n+            let if_ = cx.expr_if(span,\n+                                 cond,\n+                                 old, Some(cx.expr_ident(span, test_id)));\n+            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n+        },\n+        equals_expr.clone(),\n+        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+            } else {\n+                some_ordering_collapsed(cx, span, PartialCmpOp, tag_tuple)\n+            }\n+        }),\n+        cx, span, substr)\n+}\n+\n+/// Strict inequality.\n+fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n+         span: Span, substr: &Substructure) -> P<Expr> {\n+    let op = if less {ast::BiLt} else {ast::BiGt};\n+    cs_fold(\n+        false, // need foldr,\n+        |cx, span, subexpr, self_f, other_fs| {\n+            /*\n+            build up a series of chain ||'s and &&'s from the inside\n+            out (hence foldr) to get lexical ordering, i.e. for op ==\n+            `ast::lt`\n+\n+            ```\n+            self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n+                (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n+                    (false)\n+                ))\n+            )\n+            ```\n+\n+            The optimiser should remove the redundancy. We explicitly\n+            get use the binops to avoid auto-deref dereferencing too many\n+            layers of pointers, if the type includes pointers.\n+            */\n+            let other_f = match other_fs {\n+                [ref o_f] => o_f,\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+            };\n+\n+            let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n+\n+            let not_cmp = cx.expr_unary(span, ast::UnNot,\n+                                        cx.expr_binary(span, op, other_f.clone(), self_f));\n+\n+            let and = cx.expr_binary(span, ast::BiAnd, not_cmp, subexpr);\n+            cx.expr_binary(span, ast::BiOr, cmp, and)\n+        },\n+        cx.expr_bool(span, equal),\n+        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+            } else {\n+                let op = match (less, equal) {\n+                    (true,  true) => LeOp, (true,  false) => LtOp,\n+                    (false, true) => GeOp, (false, false) => GtOp,\n+                };\n+                some_ordering_collapsed(cx, span, op, tag_tuple)\n+            }\n+        }),\n+        cx, span, substr)\n+}"}, {"sha": "83164d242e8fbd730fdcc9784bc4a4bb104403f0", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b08d6cf529a83caec2f408cd8b1287e493ec57ca/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08d6cf529a83caec2f408cd8b1287e493ec57ca/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=b08d6cf529a83caec2f408cd8b1287e493ec57ca", "patch": "@@ -1,69 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast::{MetaItem, Item, Expr};\n-use codemap::Span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::deriving::generic::*;\n-use ext::deriving::generic::ty::*;\n-use parse::token::InternedString;\n-use ptr::P;\n-\n-pub fn expand_deriving_totaleq<F>(cx: &mut ExtCtxt,\n-                                  span: Span,\n-                                  mitem: &MetaItem,\n-                                  item: &Item,\n-                                  push: F) where\n-    F: FnOnce(P<Item>),\n-{\n-    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_same_method(|cx, span, exprs| {\n-            // create `a.<method>(); b.<method>(); c.<method>(); ...`\n-            // (where method is `assert_receiver_is_total_eq`)\n-            let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n-            let block = cx.block(span, stmts, None);\n-            cx.expr_block(block)\n-        },\n-                       Box::new(|cx, sp, _, _| {\n-                           cx.span_bug(sp, \"non matching enums in derive(Eq)?\") }),\n-                       cx,\n-                       span,\n-                       substr)\n-    }\n-\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let hidden = cx.meta_word(span, InternedString::new(\"hidden\"));\n-    let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec!(hidden));\n-    let attrs = vec!(cx.attribute(span, inline),\n-                     cx.attribute(span, doc));\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: path_std!(cx, core::cmp::Eq),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        methods: vec!(\n-            MethodDef {\n-                name: \"assert_receiver_is_total_eq\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec!(),\n-                ret_ty: nil_ty(),\n-                attributes: attrs,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    cs_total_eq_assert(a, b, c)\n-                }))\n-            }\n-        ),\n-        associated_types: Vec::new(),\n-    };\n-    trait_def.expand(cx, mitem, item, push)\n-}"}, {"sha": "1de955856e712c208d5375574ccf3e7de76096c4", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b08d6cf529a83caec2f408cd8b1287e493ec57ca/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b08d6cf529a83caec2f408cd8b1287e493ec57ca/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=b08d6cf529a83caec2f408cd8b1287e493ec57ca", "patch": "@@ -1,142 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ast;\n-use ast::{MetaItem, Item, Expr};\n-use codemap::Span;\n-use ext::base::ExtCtxt;\n-use ext::build::AstBuilder;\n-use ext::deriving::generic::*;\n-use ext::deriving::generic::ty::*;\n-use parse::token::InternedString;\n-use ptr::P;\n-\n-pub fn expand_deriving_totalord<F>(cx: &mut ExtCtxt,\n-                                   span: Span,\n-                                   mitem: &MetaItem,\n-                                   item: &Item,\n-                                   push: F) where\n-    F: FnOnce(P<Item>),\n-{\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n-    let trait_def = TraitDef {\n-        span: span,\n-        attributes: Vec::new(),\n-        path: path_std!(cx, core::cmp::Ord),\n-        additional_bounds: Vec::new(),\n-        generics: LifetimeBounds::empty(),\n-        methods: vec!(\n-            MethodDef {\n-                name: \"cmp\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec!(borrowed_self()),\n-                ret_ty: Literal(path_std!(cx, core::cmp::Ordering)),\n-                attributes: attrs,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    cs_cmp(a, b, c)\n-                })),\n-            }\n-        ),\n-        associated_types: Vec::new(),\n-    };\n-\n-    trait_def.expand(cx, mitem, item, push)\n-}\n-\n-\n-pub fn ordering_collapsed(cx: &mut ExtCtxt,\n-                          span: Span,\n-                          self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n-    let lft = cx.expr_ident(span, self_arg_tags[0]);\n-    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n-}\n-\n-pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> P<Expr> {\n-    let test_id = cx.ident_of(\"__test\");\n-    let equals_path = cx.path_global(span,\n-                                     vec!(cx.ident_of_std(\"core\"),\n-                                          cx.ident_of(\"cmp\"),\n-                                          cx.ident_of(\"Ordering\"),\n-                                          cx.ident_of(\"Equal\")));\n-\n-    let cmp_path = vec![\n-        cx.ident_of_std(\"core\"),\n-        cx.ident_of(\"cmp\"),\n-        cx.ident_of(\"Ord\"),\n-        cx.ident_of(\"cmp\"),\n-    ];\n-\n-    /*\n-    Builds:\n-\n-    let __test = ::std::cmp::Ord::cmp(&self_field1, &other_field1);\n-    if other == ::std::cmp::Ordering::Equal {\n-        let __test = ::std::cmp::Ord::cmp(&self_field2, &other_field2);\n-        if __test == ::std::cmp::Ordering::Equal {\n-            ...\n-        } else {\n-            __test\n-        }\n-    } else {\n-        __test\n-    }\n-\n-    FIXME #6449: These `if`s could/should be `match`es.\n-    */\n-    cs_fold(\n-        // foldr nests the if-elses correctly, leaving the first field\n-        // as the outermost one, and the last as the innermost.\n-        false,\n-        |cx, span, old, self_f, other_fs| {\n-            // let __test = new;\n-            // if __test == ::std::cmp::Ordering::Equal {\n-            //    old\n-            // } else {\n-            //    __test\n-            // }\n-\n-            let new = {\n-                let other_f = match other_fs {\n-                    [ref o_f] => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-                };\n-\n-                let args = vec![\n-                    cx.expr_addr_of(span, self_f),\n-                    cx.expr_addr_of(span, other_f.clone()),\n-                ];\n-\n-                cx.expr_call_global(span, cmp_path.clone(), args)\n-            };\n-\n-            let assign = cx.stmt_let(span, false, test_id, new);\n-\n-            let cond = cx.expr_binary(span, ast::BiEq,\n-                                      cx.expr_ident(span, test_id),\n-                                      cx.expr_path(equals_path.clone()));\n-            let if_ = cx.expr_if(span,\n-                                 cond,\n-                                 old, Some(cx.expr_ident(span, test_id)));\n-            cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n-        },\n-        cx.expr_path(equals_path.clone()),\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derives(Ord)`\")\n-            } else {\n-                ordering_collapsed(cx, span, tag_tuple)\n-            }\n-        }),\n-        cx, span, substr)\n-}"}, {"sha": "14f0004101c818cfd31cb420f357633284739271", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -21,33 +21,30 @@ use parse::token::InternedString;\n use parse::token;\n use ptr::P;\n \n-pub fn expand_deriving_rustc_decodable<F>(cx: &mut ExtCtxt,\n-                                          span: Span,\n-                                          mitem: &MetaItem,\n-                                          item: &Item,\n-                                          push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n+                                       span: Span,\n+                                       mitem: &MetaItem,\n+                                       item: &Item,\n+                                       push: &mut FnMut(P<Item>))\n {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n-pub fn expand_deriving_decodable<F>(cx: &mut ExtCtxt,\n-                                    span: Span,\n-                                    mitem: &MetaItem,\n-                                    item: &Item,\n-                                    push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n+                                 span: Span,\n+                                 mitem: &MetaItem,\n+                                 item: &Item,\n+                                 push: &mut FnMut(P<Item>))\n {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n-fn expand_deriving_decodable_imp<F>(cx: &mut ExtCtxt,\n-                                    span: Span,\n-                                    mitem: &MetaItem,\n-                                    item: &Item,\n-                                    push: F,\n-                                    krate: &'static str) where\n-    F: FnOnce(P<Item>),\n+fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n+                                 span: Span,\n+                                 mitem: &MetaItem,\n+                                 item: &Item,\n+                                 push: &mut FnMut(P<Item>),\n+                                 krate: &'static str)\n {\n     if !cx.use_std {\n         // FIXME(#21880): lift this requirement."}, {"sha": "f04eaa08dead14824df2f09531f65bc1feb61b75", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -17,12 +17,11 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_default<F>(cx: &mut ExtCtxt,\n-                                  span: Span,\n-                                  mitem: &MetaItem,\n-                                  item: &Item,\n-                                  push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_default(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               mitem: &MetaItem,\n+                               item: &Item,\n+                               push: &mut FnMut(P<Item>))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));"}, {"sha": "175f986f6dda89cc8d0e79a6814c6c5a92b58acd", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -97,33 +97,30 @@ use ext::deriving::generic::ty::*;\n use parse::token;\n use ptr::P;\n \n-pub fn expand_deriving_rustc_encodable<F>(cx: &mut ExtCtxt,\n-                                          span: Span,\n-                                          mitem: &MetaItem,\n-                                          item: &Item,\n-                                          push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n+                                       span: Span,\n+                                       mitem: &MetaItem,\n+                                       item: &Item,\n+                                       push: &mut FnMut(P<Item>))\n {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n-pub fn expand_deriving_encodable<F>(cx: &mut ExtCtxt,\n-                                    span: Span,\n-                                    mitem: &MetaItem,\n-                                    item: &Item,\n-                                    push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n+                                 span: Span,\n+                                 mitem: &MetaItem,\n+                                 item: &Item,\n+                                 push: &mut FnMut(P<Item>))\n {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n-fn expand_deriving_encodable_imp<F>(cx: &mut ExtCtxt,\n-                                    span: Span,\n-                                    mitem: &MetaItem,\n-                                    item: &Item,\n-                                    push: F,\n-                                    krate: &'static str) where\n-    F: FnOnce(P<Item>),\n+fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n+                                 span: Span,\n+                                 mitem: &MetaItem,\n+                                 item: &Item,\n+                                 push: &mut FnMut(P<Item>),\n+                                 krate: &'static str)\n {\n     if !cx.use_std {\n         // FIXME(#21880): lift this requirement."}, {"sha": "4685b4b295417f6f18111c253812e6df17334f56", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -375,12 +375,11 @@ fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name]) -> Vec<P<ast\n }\n \n impl<'a> TraitDef<'a> {\n-    pub fn expand<F>(&self,\n-                     cx: &mut ExtCtxt,\n-                     mitem: &ast::MetaItem,\n-                     item: &ast::Item,\n-                     push: F) where\n-        F: FnOnce(P<ast::Item>),\n+    pub fn expand(&self,\n+                  cx: &mut ExtCtxt,\n+                  mitem: &ast::MetaItem,\n+                  item: &ast::Item,\n+                  push: &mut FnMut(P<ast::Item>))\n     {\n         let newitem = match item.node {\n             ast::ItemStruct(ref struct_def, ref generics) => {"}, {"sha": "2f6734b1a1433d6bbe9a3a34e4e93cca566fc05e", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -16,12 +16,11 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use ptr::P;\n \n-pub fn expand_deriving_hash<F>(cx: &mut ExtCtxt,\n-                               span: Span,\n-                               mitem: &MetaItem,\n-                               item: &Item,\n-                               push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n+                            span: Span,\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: &mut FnMut(P<Item>))\n {\n \n     let path = Path::new_(pathvec_std!(cx, core::hash::Hash), None,"}, {"sha": "a37253558405f811581b975a2a98b0e714dfc605", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -65,14 +65,14 @@ pub mod show;\n pub mod default;\n pub mod primitive;\n \n+#[path=\"cmp/partial_eq.rs\"]\n+pub mod partial_eq;\n #[path=\"cmp/eq.rs\"]\n pub mod eq;\n-#[path=\"cmp/totaleq.rs\"]\n-pub mod totaleq;\n+#[path=\"cmp/partial_ord.rs\"]\n+pub mod partial_ord;\n #[path=\"cmp/ord.rs\"]\n pub mod ord;\n-#[path=\"cmp/totalord.rs\"]\n-pub mod totalord;\n \n \n pub mod generic;\n@@ -118,7 +118,7 @@ fn expand_derive(cx: &mut ExtCtxt,\n }\n \n macro_rules! derive_traits {\n-    ($( $name:expr => $func:path, )*) => {\n+    ($( $name:expr => $func:path, )+) => {\n         pub fn register_all(env: &mut SyntaxEnv) {\n             // Define the #[derive_*] extensions.\n             $({\n@@ -132,21 +132,21 @@ macro_rules! derive_traits {\n                               item: &Item,\n                               push: &mut FnMut(P<Item>)) {\n                         warn_if_deprecated(ecx, sp, $name);\n-                        $func(ecx, sp, mitem, item, |i| push(i));\n+                        $func(ecx, sp, mitem, item, push);\n                     }\n                 }\n \n                 env.insert(intern(concat!(\"derive_\", $name)),\n                            Decorator(Box::new(DeriveExtension)));\n-            })*\n+            })+\n \n             env.insert(intern(\"derive\"),\n                        Modifier(Box::new(expand_derive)));\n         }\n \n         fn is_builtin_trait(name: &str) -> bool {\n             match name {\n-                $( $name )|* => true,\n+                $( $name )|+ => true,\n                 _ => false,\n             }\n         }\n@@ -162,10 +162,10 @@ derive_traits! {\n \n     \"RustcDecodable\" => decodable::expand_deriving_rustc_decodable,\n \n-    \"PartialEq\" => eq::expand_deriving_eq,\n-    \"Eq\" => totaleq::expand_deriving_totaleq,\n-    \"PartialOrd\" => ord::expand_deriving_ord,\n-    \"Ord\" => totalord::expand_deriving_totalord,\n+    \"PartialEq\" => partial_eq::expand_deriving_partial_eq,\n+    \"Eq\" => eq::expand_deriving_eq,\n+    \"PartialOrd\" => partial_ord::expand_deriving_partial_ord,\n+    \"Ord\" => ord::expand_deriving_ord,\n \n     \"Debug\" => show::expand_deriving_show,\n "}, {"sha": "625f759fcedf8e12eed0a4bb5a79ec43bc11247c", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -18,12 +18,11 @@ use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n use ptr::P;\n \n-pub fn expand_deriving_from_primitive<F>(cx: &mut ExtCtxt,\n-                                         span: Span,\n-                                         mitem: &MetaItem,\n-                                         item: &Item,\n-                                         push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n+                                      span: Span,\n+                                      mitem: &MetaItem,\n+                                      item: &Item,\n+                                      push: &mut FnMut(P<Item>))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let attrs = vec!(cx.attribute(span, inline));"}, {"sha": "f3b0e8a768126fa7752180df7dd7b8e28a07b330", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -18,12 +18,11 @@ use ext::deriving::generic::ty::*;\n use parse::token;\n use ptr::P;\n \n-pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n-                               span: Span,\n-                               mitem: &MetaItem,\n-                               item: &Item,\n-                               push: F) where\n-    F: FnOnce(P<Item>),\n+pub fn expand_deriving_show(cx: &mut ExtCtxt,\n+                            span: Span,\n+                            mitem: &MetaItem,\n+                            item: &Item,\n+                            push: &mut FnMut(P<Item>))\n {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(box Literal(path_std!(cx, core::fmt::Formatter)),"}, {"sha": "5c967747104306c26a82886b30a907a9993b75a4", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -122,21 +122,16 @@ impl fmt::Display for TestName {\n #[derive(Clone, Copy)]\n enum NamePadding {\n     PadNone,\n-    PadOnLeft,\n     PadOnRight,\n }\n \n impl TestDesc {\n     fn padded_name(&self, column_count: usize, align: NamePadding) -> String {\n         let mut name = String::from_str(self.name.as_slice());\n         let fill = column_count.saturating_sub(name.len());\n-        let mut pad = repeat(\" \").take(fill).collect::<String>();\n+        let pad = repeat(\" \").take(fill).collect::<String>();\n         match align {\n             PadNone => name,\n-            PadOnLeft => {\n-                pad.push_str(&name);\n-                pad\n-            }\n             PadOnRight => {\n                 name.push_str(&pad);\n                 name\n@@ -690,7 +685,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn> ) -> io::Res\n     fn len_if_padded(t: &TestDescAndFn) -> usize {\n         match t.testfn.padding() {\n             PadNone => 0,\n-            PadOnLeft | PadOnRight => t.desc.name.as_slice().len(),\n+            PadOnRight => t.desc.name.as_slice().len(),\n         }\n     }\n     match tests.iter().max_by(|t|len_if_padded(*t)) {"}, {"sha": "17d3f6a46ef57162b10132a2810caec04f7a616b", "filename": "src/test/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1284be4044420bc4c41767284ae26be61a38d331/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1284be4044420bc4c41767284ae26be61a38d331/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=1284be4044420bc4c41767284ae26be61a38d331", "patch": "@@ -70,5 +70,5 @@ fn expand(cx: &mut ExtCtxt,\n         ],\n     };\n \n-    trait_def.expand(cx, mitem, item, |i| push(i))\n+    trait_def.expand(cx, mitem, item, push)\n }"}]}