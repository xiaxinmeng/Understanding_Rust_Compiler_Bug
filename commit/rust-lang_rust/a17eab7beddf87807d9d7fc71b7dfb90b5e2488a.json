{"sha": "a17eab7beddf87807d9d7fc71b7dfb90b5e2488a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExN2VhYjdiZWRkZjg3ODA3ZDlkN2ZjNzFiN2RmYjkwYjVlMjQ4OGE=", "commit": {"author": {"name": "Ian Jackson", "email": "ijackson@chiark.greenend.org.uk", "date": "2021-02-07T12:16:11Z"}, "committer": {"name": "Ian Jackson", "email": "ijackson@chiark.greenend.org.uk", "date": "2021-05-07T10:17:44Z"}, "message": "panic ui test: Provide comprehensive test for panic after fork\n\nThis tests that we can indeed safely panic after fork, both\na raw libc::fork and in a Command pre_exec hook.\n\nSigned-off-by: Ian Jackson <ijackson@chiark.greenend.org.uk>\nCo-authored-by: Mara Bos <m-ou.se@m-ou.se>", "tree": {"sha": "5364660b83bcd0a59b27feea9d53714e6449481d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5364660b83bcd0a59b27feea9d53714e6449481d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a", "html_url": "https://github.com/rust-lang/rust/commit/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a/comments", "author": {"login": "ijackson", "id": 2090772, "node_id": "MDQ6VXNlcjIwOTA3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2090772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ijackson", "html_url": "https://github.com/ijackson", "followers_url": "https://api.github.com/users/ijackson/followers", "following_url": "https://api.github.com/users/ijackson/following{/other_user}", "gists_url": "https://api.github.com/users/ijackson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ijackson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ijackson/subscriptions", "organizations_url": "https://api.github.com/users/ijackson/orgs", "repos_url": "https://api.github.com/users/ijackson/repos", "events_url": "https://api.github.com/users/ijackson/events{/privacy}", "received_events_url": "https://api.github.com/users/ijackson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ijackson", "id": 2090772, "node_id": "MDQ6VXNlcjIwOTA3NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/2090772?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ijackson", "html_url": "https://github.com/ijackson", "followers_url": "https://api.github.com/users/ijackson/followers", "following_url": "https://api.github.com/users/ijackson/following{/other_user}", "gists_url": "https://api.github.com/users/ijackson/gists{/gist_id}", "starred_url": "https://api.github.com/users/ijackson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ijackson/subscriptions", "organizations_url": "https://api.github.com/users/ijackson/orgs", "repos_url": "https://api.github.com/users/ijackson/repos", "events_url": "https://api.github.com/users/ijackson/events{/privacy}", "received_events_url": "https://api.github.com/users/ijackson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8015061c88ba35f7af09ff68a054ffe6c87990c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8015061c88ba35f7af09ff68a054ffe6c87990c", "html_url": "https://github.com/rust-lang/rust/commit/f8015061c88ba35f7af09ff68a054ffe6c87990c"}], "stats": {"total": 201, "additions": 179, "deletions": 22}, "files": [{"sha": "59953a2230fce4950372c48032dc1173814fd28f", "filename": "library/std/src/sys/unix/process/process_unix/tests.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix%2Ftests.rs?ref=a17eab7beddf87807d9d7fc71b7dfb90b5e2488a", "patch": "@@ -2,6 +2,9 @@ use crate::os::unix::process::{CommandExt, ExitStatusExt};\n use crate::panic::catch_unwind;\n use crate::process::Command;\n \n+// Many of the other aspects of this situation, including heap alloc concurrency\n+// safety etc., are tested in src/test/ui/process/process-panic-after-fork.rs\n+\n #[test]\n fn exitstatus_display_tests() {\n     // In practice this is the same on every Unix."}, {"sha": "3ef6d5d187440b3734ea7b711574473d7ecd878b", "filename": "src/test/ui/panics/abort-on-panic.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Fabort-on-panic.rs?ref=a17eab7beddf87807d9d7fc71b7dfb90b5e2488a", "patch": "@@ -23,41 +23,45 @@ extern \"Rust\" fn panic_in_rust_abi() {\n     panic!(\"TestRust\");\n }\n \n-fn test() {\n-    let _ = panic::catch_unwind(|| { panic_in_ffi(); });\n-    // The process should have aborted by now.\n+fn should_have_aborted() {\n     io::stdout().write(b\"This should never be printed.\\n\");\n     let _ = io::stdout().flush();\n }\n \n+fn test() {\n+    let _ = panic::catch_unwind(|| { panic_in_ffi(); });\n+    should_have_aborted();\n+}\n+\n fn testrust() {\n     let _ = panic::catch_unwind(|| { panic_in_rust_abi(); });\n-    // The process should have aborted by now.\n-    io::stdout().write(b\"This should never be printed.\\n\");\n-    let _ = io::stdout().flush();\n+    should_have_aborted();\n }\n \n fn main() {\n+    let tests: &[(_, fn())] = &[\n+        (\"test\", test),\n+        (\"testrust\", testrust),\n+    ];\n+\n     let args: Vec<String> = env::args().collect();\n     if args.len() > 1 {\n         // This is inside the self-executed command.\n-        match &*args[1] {\n-            \"test\" => return test(),\n-            \"testrust\" => return testrust(),\n-            _ => panic!(\"bad test\"),\n+        for (a,f) in tests {\n+            if &args[1] == a { return f() }\n         }\n+        panic!(\"bad test\");\n     }\n \n-    // These end up calling the self-execution branches above.\n-    let mut p = Command::new(&args[0])\n-                        .stdout(Stdio::piped())\n-                        .stdin(Stdio::piped())\n-                        .arg(\"test\").spawn().unwrap();\n-    assert!(!p.wait().unwrap().success());\n-\n-    let mut p = Command::new(&args[0])\n-                        .stdout(Stdio::piped())\n-                        .stdin(Stdio::piped())\n-                        .arg(\"testrust\").spawn().unwrap();\n-    assert!(!p.wait().unwrap().success());\n+    let execute_self_expecting_abort = |arg| {\n+        let mut p = Command::new(&args[0])\n+                            .stdout(Stdio::piped())\n+                            .stdin(Stdio::piped())\n+                            .arg(arg).spawn().unwrap();\n+        assert!(!p.wait().unwrap().success());\n+    };\n+\n+    for (a,_f) in tests {\n+        execute_self_expecting_abort(a);\n+    }\n }"}, {"sha": "6e07a1611c5c316ff9c37c0dd978c728316f59a3", "filename": "src/test/ui/process/process-panic-after-fork.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a17eab7beddf87807d9d7fc71b7dfb90b5e2488a/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs?ref=a17eab7beddf87807d9d7fc71b7dfb90b5e2488a", "patch": "@@ -0,0 +1,150 @@\n+// run-pass\n+// no-prefer-dynamic\n+// ignore-wasm32-bare no libc\n+// ignore-windows\n+// ignore-sgx no libc\n+// ignore-emscripten no processes\n+// ignore-sgx no processes\n+\n+#![feature(bench_black_box)]\n+#![feature(rustc_private)]\n+#![feature(never_type)]\n+#![feature(panic_always_abort)]\n+\n+extern crate libc;\n+\n+use std::alloc::{GlobalAlloc, Layout};\n+use std::fmt;\n+use std::panic::{self, panic_any};\n+use std::os::unix::process::{CommandExt, ExitStatusExt};\n+use std::process::{self, Command, ExitStatus};\n+use std::sync::atomic::{AtomicU32, Ordering};\n+\n+use libc::c_int;\n+\n+/// This stunt allocator allows us to spot heap allocations in the child.\n+struct PidChecking<A> {\n+    parent: A,\n+    require_pid: AtomicU32,\n+}\n+\n+#[global_allocator]\n+static ALLOCATOR: PidChecking<std::alloc::System> = PidChecking {\n+    parent: std::alloc::System,\n+    require_pid: AtomicU32::new(0),\n+};\n+\n+impl<A> PidChecking<A> {\n+    fn engage(&self) {\n+        let parent_pid = process::id();\n+        eprintln!(\"engaging allocator trap, parent pid={}\", parent_pid);\n+        self.require_pid.store(parent_pid, Ordering::Release);\n+    }\n+    fn check(&self) {\n+        let require_pid = self.require_pid.load(Ordering::Acquire);\n+        if require_pid != 0 {\n+            let actual_pid = process::id();\n+            if require_pid != actual_pid {\n+                unsafe {\n+                    libc::raise(libc::SIGTRAP);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+unsafe impl<A:GlobalAlloc> GlobalAlloc for PidChecking<A> {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        self.check();\n+        self.parent.alloc(layout)\n+    }\n+\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        self.check();\n+        self.parent.dealloc(ptr, layout)\n+    }\n+\n+    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        self.check();\n+        self.parent.alloc_zeroed(layout)\n+    }\n+\n+    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n+        self.check();\n+        self.parent.realloc(ptr, layout, new_size)\n+    }\n+}\n+\n+fn expect_aborted(status: ExitStatus) {\n+    dbg!(status);\n+    let signal = status.signal().expect(\"expected child process to die of signal\");\n+    assert!(signal == libc::SIGABRT || signal == libc::SIGILL);\n+}\n+\n+fn main() {\n+    ALLOCATOR.engage();\n+\n+    fn run(do_panic: &dyn Fn()) -> ExitStatus {\n+        let child = unsafe { libc::fork() };\n+        assert!(child >= 0);\n+        if child == 0 {\n+            panic::always_abort();\n+            do_panic();\n+            process::exit(0);\n+        }\n+        let mut status: c_int = 0;\n+        let got = unsafe { libc::waitpid(child, &mut status, 0) };\n+        assert_eq!(got, child);\n+        let status = ExitStatus::from_raw(status.into());\n+        status\n+    }\n+\n+    fn one(do_panic: &dyn Fn()) {\n+        let status = run(do_panic);\n+        expect_aborted(status);\n+    }\n+\n+    one(&|| panic!());\n+    one(&|| panic!(\"some message\"));\n+    one(&|| panic!(\"message with argument: {}\", 42));\n+\n+    #[derive(Debug)]\n+    struct Wotsit { }\n+    one(&|| panic_any(Wotsit { }));\n+\n+    let mut c = Command::new(\"echo\");\n+    unsafe {\n+        c.pre_exec(|| panic!(\"{}\", \"crash now!\"));\n+    }\n+    let st = c.status().expect(\"failed to get command status\");\n+    expect_aborted(st);\n+\n+    struct DisplayWithHeap;\n+    impl fmt::Display for DisplayWithHeap {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {\n+            let s = vec![0; 100];\n+            let s = std::hint::black_box(s);\n+            write!(f, \"{:?}\", s)\n+        }\n+    }\n+\n+    // Some panics in the stdlib that we want not to allocate, as\n+    // otherwise these facilities become impossible to use in the\n+    // child after fork, which is really quite awkward.\n+\n+    one(&|| { None::<DisplayWithHeap>.unwrap(); });\n+    one(&|| { None::<DisplayWithHeap>.expect(\"unwrapped a none\"); });\n+    one(&|| { std::str::from_utf8(b\"\\xff\").unwrap(); });\n+    one(&|| {\n+        let x = [0, 1, 2, 3];\n+        let y = x[std::hint::black_box(4)];\n+        let _z = std::hint::black_box(y);\n+    });\n+\n+    // Finally, check that our stunt allocator can actually catch an allocation after fork.\n+    // ie, that our test is effective.\n+\n+    let status = run(&|| panic!(\"allocating to display... {}\", DisplayWithHeap));\n+    dbg!(status);\n+    assert_eq!(status.signal(), Some(libc::SIGTRAP));\n+}"}]}