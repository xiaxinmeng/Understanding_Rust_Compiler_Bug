{"sha": "fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "node_id": "C_kwDOAAsO6NoAKGZhODc2MmI3YjZjMmI3NWQ2YzgzZmIwMTFlZThmYTQ4NzQxNjg4Mjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-14T02:34:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-14T02:34:17Z"}, "message": "Auto merge of #112448 - nnethercote:no-tiny-cgus, r=wesleywiser\n\nIntroduce a minimum CGU size in non-incremental builds.\n\nBecause tiny CGUs slow down compilation *and* result in worse generated code.\n\nr? `@wesleywiser`", "tree": {"sha": "01687f18762f668dd6d7574380948424a2a12acd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01687f18762f668dd6d7574380948424a2a12acd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "html_url": "https://github.com/rust-lang/rust/commit/fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6330daade9766bbf896495898c2347dc3be6da17", "url": "https://api.github.com/repos/rust-lang/rust/commits/6330daade9766bbf896495898c2347dc3be6da17", "html_url": "https://github.com/rust-lang/rust/commit/6330daade9766bbf896495898c2347dc3be6da17"}, {"sha": "7c3ce02a1124b008addb9764173ad441f4741c00", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c3ce02a1124b008addb9764173ad441f4741c00", "html_url": "https://github.com/rust-lang/rust/commit/7c3ce02a1124b008addb9764173ad441f4741c00"}], "stats": {"total": 247, "additions": 201, "deletions": 46}, "files": [{"sha": "fa67a1b3310110d95989e4ea399409160cd6f57e", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "patch": "@@ -1385,7 +1385,7 @@ fn vcall_visibility_metadata<'ll, 'tcx>(\n     let trait_def_id = trait_ref_self.def_id();\n     let trait_vis = cx.tcx.visibility(trait_def_id);\n \n-    let cgus = cx.sess().codegen_units();\n+    let cgus = cx.sess().codegen_units().as_usize();\n     let single_cgu = cgus == 1;\n \n     let lto = cx.sess().lto();"}, {"sha": "109e9959aeac8ca57fcc9e6e73b2368747106b8a", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "patch": "@@ -646,10 +646,10 @@ fn produce_final_output_artifacts(\n         // rlib.\n         let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n \n-        let keep_numbered_bitcode = user_wants_bitcode && sess.codegen_units() > 1;\n+        let keep_numbered_bitcode = user_wants_bitcode && sess.codegen_units().as_usize() > 1;\n \n         let keep_numbered_objects =\n-            needs_crate_object || (user_wants_objects && sess.codegen_units() > 1);\n+            needs_crate_object || (user_wants_objects && sess.codegen_units().as_usize() > 1);\n \n         for module in compiled_modules.modules.iter() {\n             if let Some(ref path) = module.object {\n@@ -1923,7 +1923,7 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n \n         // FIXME: time_llvm_passes support - does this use a global context or\n         // something?\n-        if sess.codegen_units() == 1 && sess.opts.unstable_opts.time_llvm_passes {\n+        if sess.codegen_units().as_usize() == 1 && sess.opts.unstable_opts.time_llvm_passes {\n             self.backend.print_pass_timings()\n         }\n "}, {"sha": "ebcc3b0399973e409d811923abcf492d8309a6aa", "filename": "compiler/rustc_monomorphize/src/partitioning.rs", "status": "modified", "additions": 168, "deletions": 34, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning.rs?ref=fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "patch": "@@ -113,6 +113,7 @@ use rustc_middle::query::Providers;\n use rustc_middle::ty::print::{characteristic_def_id_of_type, with_no_trimmed_paths};\n use rustc_middle::ty::{self, visit::TypeVisitableExt, InstanceDef, TyCtxt};\n use rustc_session::config::{DumpMonoStatsFormat, SwitchWithOptPath};\n+use rustc_session::CodegenUnits;\n use rustc_span::symbol::Symbol;\n \n use crate::collector::UsageMap;\n@@ -121,7 +122,6 @@ use crate::errors::{CouldntDumpMonoStats, SymbolAlreadyDefined, UnknownCguCollec\n \n struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    target_cgu_count: usize,\n     usage_map: &'a UsageMap<'tcx>,\n }\n \n@@ -130,26 +130,30 @@ struct PlacedRootMonoItems<'tcx> {\n     codegen_units: Vec<CodegenUnit<'tcx>>,\n \n     internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+\n+    /// These must be obtained when the iterator in `partition` runs. They\n+    /// can't be obtained later because some inlined functions might not be\n+    /// reachable.\n+    unique_inlined_stats: (usize, usize),\n }\n \n // The output CGUs are sorted by name.\n fn partition<'tcx, I>(\n     tcx: TyCtxt<'tcx>,\n     mono_items: I,\n-    max_cgu_count: usize,\n     usage_map: &UsageMap<'tcx>,\n ) -> Vec<CodegenUnit<'tcx>>\n where\n     I: Iterator<Item = MonoItem<'tcx>>,\n {\n     let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning\");\n \n-    let cx = &PartitioningCx { tcx, target_cgu_count: max_cgu_count, usage_map };\n+    let cx = &PartitioningCx { tcx, usage_map };\n \n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n-    let PlacedRootMonoItems { mut codegen_units, internalization_candidates } = {\n+    let PlacedRootMonoItems { mut codegen_units, internalization_candidates, unique_inlined_stats } = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n         place_root_mono_items(cx, mono_items)\n     };\n@@ -158,15 +162,15 @@ where\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n+    debug_dump(tcx, \"ROOTS\", &codegen_units, unique_inlined_stats);\n \n     // Merge until we have at most `max_cgu_count` codegen units.\n     // `merge_codegen_units` is responsible for updating the CGU size\n     // estimates.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n         merge_codegen_units(cx, &mut codegen_units);\n-        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n+        debug_dump(tcx, \"MERGE\", &codegen_units, unique_inlined_stats);\n     }\n \n     // In the next step, we use the inlining map to determine which additional\n@@ -182,7 +186,7 @@ where\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n+    debug_dump(tcx, \"INLINE\", &codegen_units, unique_inlined_stats);\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n@@ -226,7 +230,7 @@ where\n     // Ensure CGUs are sorted by name, so that we get deterministic results.\n     assert!(codegen_units.is_sorted_by(|a, b| Some(a.name().as_str().cmp(b.name().as_str()))));\n \n-    debug_dump(tcx, \"FINAL\", &codegen_units);\n+    debug_dump(tcx, \"FINAL\", &codegen_units, unique_inlined_stats);\n \n     codegen_units\n }\n@@ -252,10 +256,16 @@ where\n     let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n     let cgu_name_cache = &mut FxHashMap::default();\n \n+    let mut num_unique_inlined_items = 0;\n+    let mut unique_inlined_items_size = 0;\n     for mono_item in mono_items {\n         match mono_item.instantiation_mode(cx.tcx) {\n             InstantiationMode::GloballyShared { .. } => {}\n-            InstantiationMode::LocalCopy => continue,\n+            InstantiationMode::LocalCopy => {\n+                num_unique_inlined_items += 1;\n+                unique_inlined_items_size += mono_item.size_estimate(cx.tcx);\n+                continue;\n+            }\n         }\n \n         let characteristic_def_id = characteristic_def_id_of_mono_item(cx.tcx, mono_item);\n@@ -300,7 +310,11 @@ where\n     let mut codegen_units: Vec<_> = codegen_units.into_values().collect();\n     codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n \n-    PlacedRootMonoItems { codegen_units, internalization_candidates }\n+    PlacedRootMonoItems {\n+        codegen_units,\n+        internalization_candidates,\n+        unique_inlined_stats: (num_unique_inlined_items, unique_inlined_items_size),\n+    }\n }\n \n // This function requires the CGUs to be sorted by name on input, and ensures\n@@ -309,7 +323,7 @@ fn merge_codegen_units<'tcx>(\n     cx: &PartitioningCx<'_, 'tcx>,\n     codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n ) {\n-    assert!(cx.target_cgu_count >= 1);\n+    assert!(cx.tcx.sess.codegen_units().as_usize() >= 1);\n \n     // A sorted order here ensures merging is deterministic.\n     assert!(codegen_units.is_sorted_by(|a, b| Some(a.name().as_str().cmp(b.name().as_str()))));\n@@ -318,11 +332,32 @@ fn merge_codegen_units<'tcx>(\n     let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n         codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n \n-    // Merge the two smallest codegen units until the target size is\n-    // reached.\n-    while codegen_units.len() > cx.target_cgu_count {\n-        // Sort small cgus to the back\n+    // Having multiple CGUs can drastically speed up compilation. But for\n+    // non-incremental builds, tiny CGUs slow down compilation *and* result in\n+    // worse generated code. So we don't allow CGUs smaller than this (unless\n+    // there is just one CGU, of course). Note that CGU sizes of 100,000+ are\n+    // common in larger programs, so this isn't all that large.\n+    const NON_INCR_MIN_CGU_SIZE: usize = 1000;\n+\n+    // Repeatedly merge the two smallest codegen units as long as:\n+    // - we have more CGUs than the upper limit, or\n+    // - (Non-incremental builds only) the user didn't specify a CGU count, and\n+    //   there are multiple CGUs, and some are below the minimum size.\n+    //\n+    // The \"didn't specify a CGU count\" condition is because when an explicit\n+    // count is requested we observe it as closely as possible. For example,\n+    // the `compiler_builtins` crate sets `codegen-units = 10000` and it's\n+    // critical they aren't merged. Also, some tests use explicit small values\n+    // and likewise won't work if small CGUs are merged.\n+    while codegen_units.len() > cx.tcx.sess.codegen_units().as_usize()\n+        || (cx.tcx.sess.opts.incremental.is_none()\n+            && matches!(cx.tcx.sess.codegen_units(), CodegenUnits::Default(_))\n+            && codegen_units.len() > 1\n+            && codegen_units.iter().any(|cgu| cgu.size_estimate() < NON_INCR_MIN_CGU_SIZE))\n+    {\n+        // Sort small cgus to the back.\n         codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+\n         let mut smallest = codegen_units.pop().unwrap();\n         let second_smallest = codegen_units.last_mut().unwrap();\n \n@@ -814,47 +849,147 @@ fn default_visibility(tcx: TyCtxt<'_>, id: DefId, is_generic: bool) -> Visibilit\n     }\n }\n \n-fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n+fn debug_dump<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'tcx>,\n+    label: &str,\n+    cgus: &[CodegenUnit<'tcx>],\n+    (unique_inlined_items, unique_inlined_size): (usize, usize),\n+) {\n     let dump = move || {\n         use std::fmt::Write;\n \n-        let num_cgus = cgus.len();\n-        let num_items: usize = cgus.iter().map(|cgu| cgu.items().len()).sum();\n-        let total_size: usize = cgus.iter().map(|cgu| cgu.size_estimate()).sum();\n-        let max_size = cgus.iter().map(|cgu| cgu.size_estimate()).max().unwrap();\n-        let min_size = cgus.iter().map(|cgu| cgu.size_estimate()).min().unwrap();\n-        let max_min_size_ratio = max_size as f64 / min_size as f64;\n+        let mut num_cgus = 0;\n+        let mut all_cgu_sizes = Vec::new();\n+\n+        // Note: every unique root item is placed exactly once, so the number\n+        // of unique root items always equals the number of placed root items.\n+\n+        let mut root_items = 0;\n+        // unique_inlined_items is passed in above.\n+        let mut placed_inlined_items = 0;\n+\n+        let mut root_size = 0;\n+        // unique_inlined_size is passed in above.\n+        let mut placed_inlined_size = 0;\n+\n+        for cgu in cgus.iter() {\n+            num_cgus += 1;\n+            all_cgu_sizes.push(cgu.size_estimate());\n+\n+            for (item, _) in cgu.items() {\n+                match item.instantiation_mode(tcx) {\n+                    InstantiationMode::GloballyShared { .. } => {\n+                        root_items += 1;\n+                        root_size += item.size_estimate(tcx);\n+                    }\n+                    InstantiationMode::LocalCopy => {\n+                        placed_inlined_items += 1;\n+                        placed_inlined_size += item.size_estimate(tcx);\n+                    }\n+                }\n+            }\n+        }\n+\n+        all_cgu_sizes.sort_unstable_by_key(|&n| cmp::Reverse(n));\n+\n+        let unique_items = root_items + unique_inlined_items;\n+        let placed_items = root_items + placed_inlined_items;\n+        let items_ratio = placed_items as f64 / unique_items as f64;\n+\n+        let unique_size = root_size + unique_inlined_size;\n+        let placed_size = root_size + placed_inlined_size;\n+        let size_ratio = placed_size as f64 / unique_size as f64;\n+\n+        let mean_cgu_size = placed_size as f64 / num_cgus as f64;\n+\n+        assert_eq!(placed_size, all_cgu_sizes.iter().sum::<usize>());\n \n         let s = &mut String::new();\n+        let _ = writeln!(s, \"{label}\");\n         let _ = writeln!(\n             s,\n-            \"{label} ({num_items} items, total_size={total_size}; {num_cgus} CGUs, \\\n-             max_size={max_size}, min_size={min_size}, max_size/min_size={max_min_size_ratio:.1}):\"\n+            \"- unique items: {unique_items} ({root_items} root + {unique_inlined_items} inlined), \\\n+               unique size: {unique_size} ({root_size} root + {unique_inlined_size} inlined)\\n\\\n+             - placed items: {placed_items} ({root_items} root + {placed_inlined_items} inlined), \\\n+               placed size: {placed_size} ({root_size} root + {placed_inlined_size} inlined)\\n\\\n+             - placed/unique items ratio: {items_ratio:.2}, \\\n+               placed/unique size ratio: {size_ratio:.2}\\n\\\n+             - CGUs: {num_cgus}, mean size: {mean_cgu_size:.1}, sizes: {}\",\n+            list(&all_cgu_sizes),\n         );\n+        let _ = writeln!(s);\n+\n         for (i, cgu) in cgus.iter().enumerate() {\n+            let name = cgu.name();\n+            let size = cgu.size_estimate();\n             let num_items = cgu.items().len();\n-            let _ = writeln!(\n-                s,\n-                \"- CGU[{i}] {} ({num_items} items, size={}):\",\n-                cgu.name(),\n-                cgu.size_estimate()\n-            );\n+            let mean_size = size as f64 / num_items as f64;\n+\n+            let mut placed_item_sizes: Vec<_> =\n+                cgu.items().iter().map(|(item, _)| item.size_estimate(tcx)).collect();\n+            placed_item_sizes.sort_unstable_by_key(|&n| cmp::Reverse(n));\n+            let sizes = list(&placed_item_sizes);\n+\n+            let _ = writeln!(s, \"- CGU[{i}]\");\n+            let _ = writeln!(s, \"  - {name}, size: {size}\");\n+            let _ =\n+                writeln!(s, \"  - items: {num_items}, mean size: {mean_size:.1}, sizes: {sizes}\",);\n \n             for (item, linkage) in cgu.items_in_deterministic_order(tcx) {\n                 let symbol_name = item.symbol_name(tcx).name;\n                 let symbol_hash_start = symbol_name.rfind('h');\n                 let symbol_hash = symbol_hash_start.map_or(\"<no hash>\", |i| &symbol_name[i..]);\n                 let size = item.size_estimate(tcx);\n+                let kind = match item.instantiation_mode(tcx) {\n+                    InstantiationMode::GloballyShared { .. } => \"root\",\n+                    InstantiationMode::LocalCopy => \"inlined\",\n+                };\n                 let _ = with_no_trimmed_paths!(writeln!(\n                     s,\n-                    \"  - {item} [{linkage:?}] [{symbol_hash}] (size={size})\"\n+                    \"  - {item} [{linkage:?}] [{symbol_hash}] ({kind}, size: {size})\"\n                 ));\n             }\n \n             let _ = writeln!(s);\n         }\n \n-        std::mem::take(s)\n+        return std::mem::take(s);\n+\n+        // Converts a slice to a string, capturing repetitions to save space.\n+        // E.g. `[4, 4, 4, 3, 2, 1, 1, 1, 1, 1]` -> \"[4 (x3), 3, 2, 1 (x5)]\".\n+        fn list(ns: &[usize]) -> String {\n+            let mut v = Vec::new();\n+            if ns.is_empty() {\n+                return \"[]\".to_string();\n+            }\n+\n+            let mut elem = |curr, curr_count| {\n+                if curr_count == 1 {\n+                    v.push(format!(\"{curr}\"));\n+                } else {\n+                    v.push(format!(\"{curr} (x{curr_count})\"));\n+                }\n+            };\n+\n+            let mut curr = ns[0];\n+            let mut curr_count = 1;\n+\n+            for &n in &ns[1..] {\n+                if n != curr {\n+                    elem(curr, curr_count);\n+                    curr = n;\n+                    curr_count = 1;\n+                } else {\n+                    curr_count += 1;\n+                }\n+            }\n+            elem(curr, curr_count);\n+\n+            let mut s = \"[\".to_string();\n+            s.push_str(&v.join(\", \"));\n+            s.push_str(\"]\");\n+            s\n+        }\n     };\n \n     debug!(\"{}\", dump());\n@@ -922,8 +1057,7 @@ fn collect_and_partition_mono_items(tcx: TyCtxt<'_>, (): ()) -> (&DefIdSet, &[Co\n     let (codegen_units, _) = tcx.sess.time(\"partition_and_assert_distinct_symbols\", || {\n         sync::join(\n             || {\n-                let mut codegen_units =\n-                    partition(tcx, items.iter().copied(), tcx.sess.codegen_units(), &usage_map);\n+                let mut codegen_units = partition(tcx, items.iter().copied(), &usage_map);\n                 codegen_units[0].make_primary();\n                 &*tcx.arena.alloc_from_iter(codegen_units)\n             },"}, {"sha": "5feea83edb6a3d6a3ddf0c84cd3871f78780bdd3", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "patch": "@@ -234,6 +234,27 @@ pub enum MetadataKind {\n     Compressed,\n }\n \n+#[derive(Clone, Copy)]\n+pub enum CodegenUnits {\n+    /// Specified by the user. In this case we try fairly hard to produce the\n+    /// number of CGUs requested.\n+    User(usize),\n+\n+    /// A default value, i.e. not specified by the user. In this case we take\n+    /// more liberties about CGU formation, e.g. avoid producing very small\n+    /// CGUs.\n+    Default(usize),\n+}\n+\n+impl CodegenUnits {\n+    pub fn as_usize(self) -> usize {\n+        match self {\n+            CodegenUnits::User(n) => n,\n+            CodegenUnits::Default(n) => n,\n+        }\n+    }\n+}\n+\n impl Session {\n     pub fn miri_unleashed_feature(&self, span: Span, feature_gate: Option<Symbol>) {\n         self.miri_unleashed_features.lock().push((span, feature_gate));\n@@ -1104,7 +1125,7 @@ impl Session {\n \n         // If there's only one codegen unit and LTO isn't enabled then there's\n         // no need for ThinLTO so just return false.\n-        if self.codegen_units() == 1 {\n+        if self.codegen_units().as_usize() == 1 {\n             return config::Lto::No;\n         }\n \n@@ -1206,19 +1227,19 @@ impl Session {\n \n     /// Returns the number of codegen units that should be used for this\n     /// compilation\n-    pub fn codegen_units(&self) -> usize {\n+    pub fn codegen_units(&self) -> CodegenUnits {\n         if let Some(n) = self.opts.cli_forced_codegen_units {\n-            return n;\n+            return CodegenUnits::User(n);\n         }\n         if let Some(n) = self.target.default_codegen_units {\n-            return n as usize;\n+            return CodegenUnits::Default(n as usize);\n         }\n \n         // If incremental compilation is turned on, we default to a high number\n         // codegen units in order to reduce the \"collateral damage\" small\n         // changes cause.\n         if self.opts.incremental.is_some() {\n-            return 256;\n+            return CodegenUnits::Default(256);\n         }\n \n         // Why is 16 codegen units the default all the time?\n@@ -1271,7 +1292,7 @@ impl Session {\n         // As a result 16 was chosen here! Mostly because it was a power of 2\n         // and most benchmarks agreed it was roughly a local optimum. Not very\n         // scientific.\n-        16\n+        CodegenUnits::Default(16)\n     }\n \n     pub fn teach(&self, code: &DiagnosticId) -> bool {"}, {"sha": "8de638dde4fbfc9a11e7320c7f898b0155d2a6cd", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/fa8762b7b6c2b75d6c83fb011ee8fa4874168829/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=fa8762b7b6c2b75d6c83fb011ee8fa4874168829", "patch": "@@ -31,8 +31,8 @@ Supported values can also be discovered by running `rustc --print code-models`.\n \n ## codegen-units\n \n-This flag controls how many code generation units the crate is split into. It\n-takes an integer greater than 0.\n+This flag controls the maximum number of code generation units the crate is\n+split into. It takes an integer greater than 0.\n \n When a crate is split into multiple codegen units, LLVM is able to process\n them in parallel. Increasing parallelism may speed up compile times, but may"}]}