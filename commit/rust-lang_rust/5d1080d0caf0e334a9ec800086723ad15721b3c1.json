{"sha": "5d1080d0caf0e334a9ec800086723ad15721b3c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMTA4MGQwY2FmMGUzMzRhOWVjODAwMDg2NzIzYWQxNTcyMWIzYzE=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-26T15:49:30Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-26T15:49:30Z"}, "message": "refactor `Lvalue` and `PrimVal::{SlicePtr, VtablePtr}` into `Value::ByValPair`", "tree": {"sha": "8f6a67aa578a98bb7262e5994bebdc8d93e207ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f6a67aa578a98bb7262e5994bebdc8d93e207ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d1080d0caf0e334a9ec800086723ad15721b3c1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX6UOKAAoJEFbW7qD8Z6xGfM8P/RSfQdEcz6PaHLjc+g87/e3T\nDbziCS5ClD4VdzMgYM96QaK/l209t3/Q4xfDl6NQ/kHAqjG0HbX7+CYR2zw+IQZg\n7lvUI2+0ZCIBmoA9JDhXNjp28SDM+rffMiOCPAQjQoUJCzEPT5bOTYZ5GfCCGIkB\niEIiEUfrFXTi+OcCg8d4MIqYkDAqZu9BTYfAsiG1GRlWfHA3/Q1cbGEOlPbGTSnJ\nM2m0het6+cyOLZ7c84ch6HDNx7rZ+gunxcvIii4CQ8chbcOsgxdKFmWYEA3Hc95I\nljjVV3ljwyteUWj0H1uOd9fPVj9MWrxb2QRY0mGyK72IpmTGvXJapgdqSKVMrIoG\ntTHOpFCkK2sjJqUbvSpR+D3PiJmQACHheG3S7WVMq2Jj7b+kcicWRlMjzwBEp6ie\nNJiFlsVIX5+xpAXSlK3GmzOgIGnO25JI9ydoUYfuu2BMturt1lkwDz0vHkjPbzdO\nKM9KXIAuqsXHigPkgyTRceZ487UucscDwsf3lBGhgNX7ObdcDWwdLJcTRO0LrM4X\nkIVgCDxJAFt31sN2pay5SnBhNYtpZZ4pMpI1oIHV7igiJT4aVQswdd5a65pIIobN\nV61UVXsgYeqLi2HQjWJFhzhTKhpAKv1A6Mp3nG/+6NgHRm/xCxlf8joY1C1SXdQT\nCaYDOo0pnzkKEQsTZLLP\n=cfdD\n-----END PGP SIGNATURE-----", "payload": "tree 8f6a67aa578a98bb7262e5994bebdc8d93e207ab\nparent fe614e342d6f40a7a4dc79aaf2cf349c424bceaf\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474904970 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474904970 +0200\n\nrefactor `Lvalue` and `PrimVal::{SlicePtr, VtablePtr}` into `Value::ByValPair`"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d1080d0caf0e334a9ec800086723ad15721b3c1", "html_url": "https://github.com/rust-lang/rust/commit/5d1080d0caf0e334a9ec800086723ad15721b3c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d1080d0caf0e334a9ec800086723ad15721b3c1/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe614e342d6f40a7a4dc79aaf2cf349c424bceaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe614e342d6f40a7a4dc79aaf2cf349c424bceaf", "html_url": "https://github.com/rust-lang/rust/commit/fe614e342d6f40a7a4dc79aaf2cf349c424bceaf"}], "stats": {"total": 285, "additions": 159, "deletions": 126}, "files": [{"sha": "03e62176881df2b7411df68defd2ffe09d1e033a", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=5d1080d0caf0e334a9ec800086723ad15721b3c1", "patch": "@@ -28,7 +28,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             U64(u) => self.cast_const_int(u, ty, false),\n             FnPtr(ptr) |\n             Ptr(ptr) => self.cast_ptr(ptr, ty),\n-            VtablePtr(..) | SlicePtr(..) => unimplemented!(),\n         }\n     }\n "}, {"sha": "aec16a668de7584cde28ab1af43f8b70bf504dac", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 123, "deletions": 101, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=5d1080d0caf0e334a9ec800086723ad15721b3c1", "patch": "@@ -101,20 +101,6 @@ pub struct Frame<'a, 'tcx: 'a> {\n     pub stmt: usize,\n }\n \n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-struct Lvalue {\n-    ptr: Pointer,\n-    extra: LvalueExtra,\n-}\n-\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-enum LvalueExtra {\n-    None,\n-    Length(u64),\n-    Vtable(Pointer),\n-    DowncastVariant(usize),\n-}\n-\n #[derive(Clone)]\n pub enum CachedMir<'mir, 'tcx: 'mir> {\n     Ref(&'mir mir::Mir<'tcx>),\n@@ -204,15 +190,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn str_to_primval(&mut self, s: &str) -> EvalResult<'tcx, PrimVal> {\n+    fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n         // FIXME: cache these allocs\n         let ptr = self.memory.allocate(s.len(), 1)?;\n         self.memory.write_bytes(ptr, s.as_bytes())?;\n         self.memory.freeze(ptr.alloc_id)?;\n-        Ok(PrimVal::SlicePtr(ptr, s.len() as u64))\n+        Ok(Value::ByValPair(PrimVal::Ptr(ptr), self.target_usize_primval(s.len() as u64)))\n     }\n \n-    fn const_to_primval(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, PrimVal> {\n+    fn const_to_value(&mut self, const_val: &ConstVal) -> EvalResult<'tcx, Value> {\n         use rustc::middle::const_val::ConstVal::*;\n         use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstFloat};\n \n@@ -236,7 +222,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Bool(b) => PrimVal::Bool(b),\n             Char(c) => PrimVal::Char(c),\n \n-            Str(ref s) => self.str_to_primval(s)?,\n+            Str(ref s) => return self.str_to_value(s),\n \n             ByteStr(ref bs) => {\n                 let ptr = self.memory.allocate(bs.len(), 1)?;\n@@ -258,7 +244,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 bug!(\"uninferred constants only exist before typeck\"),\n         };\n \n-        Ok(primval)\n+        Ok(Value::ByVal(primval))\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n@@ -565,30 +551,22 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Len(ref lvalue) => {\n                 let src = self.eval_lvalue(lvalue)?;\n                 let ty = self.lvalue_ty(lvalue);\n-                let len = match ty.sty {\n-                    ty::TyArray(_, n) => n as u64,\n-                    ty::TySlice(_) => if let LvalueExtra::Length(n) = src.extra {\n-                        n\n+                match ty.sty {\n+                    ty::TyArray(_, n) => self.memory.write_usize(dest, n as u64)?,\n+                    ty::TySlice(_) => if let Value::ByValPair(_, len) = src {\n+                        self.memory.write_primval(dest, len)?;\n                     } else {\n                         bug!(\"Rvalue::Len of a slice given non-slice pointer: {:?}\", src);\n                     },\n                     _ => bug!(\"Rvalue::Len expected array or slice, got {:?}\", ty),\n-                };\n-                self.memory.write_usize(dest, len)?;\n+                }\n             }\n \n             Ref(_, _, ref lvalue) => {\n-                let lv = self.eval_lvalue(lvalue)?;\n-                match lv.extra {\n-                    LvalueExtra::None => self.memory.write_ptr(dest, lv.ptr)?,\n-                    LvalueExtra::Length(len) => {\n-                        self.memory.write_primval(dest, PrimVal::SlicePtr(lv.ptr, len))?;\n-                    }\n-                    LvalueExtra::Vtable(ptr) => {\n-                        self.memory.write_primval(dest, PrimVal::VtablePtr(lv.ptr, ptr))?;\n-                    },\n-                    LvalueExtra::DowncastVariant(..) =>\n-                        bug!(\"attempted to take a reference to an enum downcast lvalue\"),\n+                match self.eval_lvalue(lvalue)? {\n+                    Value::ByRef(ptr) => self.memory.write_ptr(dest, ptr)?,\n+                    Value::ByVal(..) => bug!(\"cannot take reference of immediate\"),\n+                    pair @ Value::ByValPair(..) => self.write_value(pair, dest, dest_ty)?,\n                 }\n             }\n \n@@ -617,7 +595,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n                             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                                 let ptr = src.read_ptr(&self.memory)?;\n-                                self.memory.write_primval(dest, PrimVal::SlicePtr(ptr, length as u64))?;\n+                                self.memory.write_ptr(dest, ptr)?;\n+                                let ptr_size = self.memory.pointer_size() as isize;\n+                                let dest_extra = dest.offset(ptr_size);\n+                                self.memory.write_usize(dest_extra, length as u64)?;\n                             }\n                             (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n                                 // For now, upcasts are limited to changes in marker\n@@ -630,7 +611,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                                 let trait_ref = self.tcx.erase_regions(&trait_ref);\n                                 let vtable = self.get_vtable(trait_ref)?;\n                                 let ptr = src.read_ptr(&self.memory)?;\n-                                self.memory.write_primval(dest, PrimVal::VtablePtr(ptr, vtable))?;\n+\n+                                self.memory.write_ptr(dest, ptr)?;\n+                                let ptr_size = self.memory.pointer_size() as isize;\n+                                let dest_extra = dest.offset(ptr_size);\n+                                self.memory.write_ptr(dest_extra, vtable)?;\n                             },\n \n                             _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n@@ -646,17 +631,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             trace!(\"misc cast: {:?}\", src);\n                             let ptr_size = self.memory.pointer_size();\n                             match (src, self.type_is_fat_ptr(dest_ty)) {\n-                                (Value::ByVal(PrimVal::VtablePtr(data, meta)), true) => {\n-                                    self.memory.write_ptr(dest, data)?;\n-                                    self.memory.write_ptr(dest.offset(ptr_size as isize), meta)?;\n+                                (Value::ByValPair(data, meta), true) => {\n+                                    self.memory.write_primval(dest, data)?;\n+                                    self.memory.write_primval(dest.offset(ptr_size as isize), meta)?;\n                                 },\n-                                (Value::ByVal(PrimVal::SlicePtr(data, meta)), true) => {\n-                                    self.memory.write_ptr(dest, data)?;\n-                                    self.memory.write_usize(dest.offset(ptr_size as isize), meta)?;\n-                                },\n-                                (Value::ByVal(PrimVal::SlicePtr(data, _)), false) |\n-                                (Value::ByVal(PrimVal::VtablePtr(data, _)), false) => {\n-                                    self.memory.write_ptr(dest, data)?;\n+                                (Value::ByValPair(data, _), false) => {\n+                                    self.memory.write_primval(dest, data)?;\n                                 },\n                                 (Value::ByRef(ptr), true) => {\n                                     self.memory.copy(ptr, dest, ptr_size * 2, ptr_size)?;\n@@ -782,12 +762,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::mir::repr::Operand::*;\n         match *op {\n-            Consume(ref lvalue) => Ok(Value::ByRef(self.eval_lvalue(lvalue)?.to_ptr())),\n+            Consume(ref lvalue) => self.eval_lvalue(lvalue),\n \n             Constant(mir::Constant { ref literal, ty, .. }) => {\n                 use rustc::mir::repr::Literal;\n                 let value = match *literal {\n-                    Literal::Value { ref value } => Value::ByVal(self.const_to_primval(value)?),\n+                    Literal::Value { ref value } => self.const_to_value(value)?,\n \n                     Literal::Item { def_id, substs } => {\n                         if let ty::TyFnDef(..) = ty.sty {\n@@ -822,14 +802,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n     }\n \n-    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Lvalue> {\n+    fn eval_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>) -> EvalResult<'tcx, Value> {\n         use rustc::mir::repr::Lvalue::*;\n-        let ptr = match *lvalue {\n-            ReturnPointer => self.frame().return_ptr\n-                .expect(\"ReturnPointer used in a function with no return value\"),\n-            Arg(i) => self.frame().locals[i.index()],\n-            Var(i) => self.frame().locals[self.frame().var_offset + i.index()],\n-            Temp(i) => self.frame().locals[self.frame().temp_offset + i.index()],\n+        let value = match *lvalue {\n+            ReturnPointer => Value::ByRef(self.frame().return_ptr\n+                .expect(\"ReturnPointer used in a function with no return value\")),\n+            Arg(i) => Value::ByRef(self.frame().locals[i.index()]),\n+            Var(i) => Value::ByRef(self.frame().locals[self.frame().var_offset + i.index()]),\n+            Temp(i) => Value::ByRef(self.frame().locals[self.frame().temp_offset + i.index()]),\n \n             Static(def_id) => {\n                 let substs = subst::Substs::empty(self.tcx);\n@@ -838,25 +818,34 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     substs: substs,\n                     kind: ConstantKind::Global,\n                 };\n-                *self.statics.get(&cid).expect(\"static should have been cached (lvalue)\")\n+                Value::ByRef(*self.statics.get(&cid).expect(\"static should have been cached (lvalue)\"))\n             },\n \n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n                 trace!(\"projection base: {:?}\", base);\n                 trace!(\"projection: {:?}\", proj.elem);\n+                match base {\n+                    Value::ByRef(ptr) => self.memory.dump(ptr.alloc_id),\n+                    _ => {},\n+                }\n                 let base_ty = self.lvalue_ty(&proj.base);\n                 let base_layout = self.type_layout(base_ty);\n \n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n                     Field(field, field_ty) => {\n+                        let field_ty = self.monomorphize(field_ty, self.substs());\n                         use rustc::ty::layout::Layout::*;\n                         let variant = match *base_layout {\n                             Univariant { ref variant, .. } => variant,\n                             General { ref variants, .. } => {\n-                                if let LvalueExtra::DowncastVariant(variant_idx) = base.extra {\n-                                    &variants[variant_idx]\n+                                if let Value::ByValPair(PrimVal::Ptr(ptr), variant_idx) = base {\n+                                    // early exit, because enum variant field access is passed\n+                                    // as a non-fat-pointer ByValPair\n+                                    let idx = variant_idx.expect_uint(\"enum variant id not integral\") as usize;\n+                                    let offset = variants[idx].field_offset(field.index()).bytes() as isize;\n+                                    return Ok(ByRef(ptr.offset(offset)));\n                                 } else {\n                                     bug!(\"field access on enum had no variant index\");\n                                 }\n@@ -869,28 +858,36 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             _ => bug!(\"field access on non-product type: {:?}\", base_layout),\n                         };\n \n-                        let offset = variant.field_offset(field.index()).bytes();\n-                        let ptr = base.ptr.offset(offset as isize);\n-                        match (&field_ty.sty, base.extra) {\n-                            (&ty::TyStr, extra @ LvalueExtra::Length(_)) |\n-                            (&ty::TySlice(_), extra @ LvalueExtra::Length(_)) |\n-                            (&ty::TyTrait(_), extra @ LvalueExtra::Vtable(_)) => return Ok(Lvalue {\n-                                ptr: ptr,\n-                                extra: extra,\n-                            }),\n-                            (&ty::TyTrait(_), _) => bug!(\"trait field without vtable\"),\n-                            _ => ptr,\n+                        let offset = variant.field_offset(field.index()).bytes() as isize;\n+                        use self::value::Value::*;\n+                        match base {\n+                            ByRef(ptr) => if self.type_is_fat_ptr(field_ty) {\n+                                self.read_value(ptr.offset(offset), field_ty)?\n+                            } else {\n+                                ByRef(ptr.offset(offset))\n+                            },\n+                            // indexing into a field of an unsized struct\n+                            ByValPair(PrimVal::Ptr(ptr), extra) => if self.type_is_sized(field_ty) {\n+                                ByRef(ptr.offset(offset))\n+                            } else {\n+                                ByValPair(PrimVal::Ptr(ptr.offset(offset)), extra)\n+                            },\n+                            other => bug!(\"expected thin ptr, got: {:?}\", other),\n                         }\n                     },\n \n                     Downcast(_, variant) => {\n                         use rustc::ty::layout::Layout::*;\n                         match *base_layout {\n                             General { ref variants, .. } => {\n-                                return Ok(Lvalue {\n-                                    ptr: base.ptr.offset(variants[variant].field_offset(1).bytes() as isize),\n-                                    extra: LvalueExtra::DowncastVariant(variant),\n-                                });\n+                                use self::value::Value::*;\n+                                match base {\n+                                    ByRef(ptr) => return Ok(ByValPair(\n+                                        PrimVal::Ptr(ptr.offset(variants[variant].field_offset(1).bytes() as isize)),\n+                                        PrimVal::U64(variant as u64),\n+                                    )),\n+                                    other => bug!(\"bad downcast base: {:?}\", other),\n+                                }\n                             }\n                             RawNullablePointer { .. } | StructWrappedNullablePointer { .. } => {\n                                 return Ok(base);\n@@ -899,15 +896,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         }\n                     },\n \n-                    Deref => {\n-                        let (ptr, extra) = match self.read_primval(base.ptr, base_ty)? {\n-                            PrimVal::SlicePtr(ptr, n) => (ptr, LvalueExtra::Length(n)),\n-                            PrimVal::VtablePtr(ptr, vptr) => (ptr, LvalueExtra::Vtable(vptr)),\n-                            PrimVal::Ptr(ptr) => (ptr, LvalueExtra::None),\n-                            _ => bug!(\"can't deref non pointer types\"),\n-                        };\n-                        return Ok(Lvalue { ptr: ptr, extra: extra });\n-                    }\n+                    Deref => match self.follow_ref(base, base_ty)? {\n+                        Value::ByRef(..) => bug!(\"follow_ref broken\"),\n+                        // magical deref\n+                        Value::ByVal(PrimVal::Ptr(ptr)) => Value::ByRef(ptr),\n+                        Value::ByVal(..) => bug!(\"can't deref non pointer types\"),\n+                        // deref ops on fat pointers are no-ops\n+                        pair @ Value::ByValPair(..) => pair,\n+                    },\n \n                     Index(ref operand) => {\n                         let elem_size = match base_ty.sty {\n@@ -918,16 +914,20 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let n_ptr = self.eval_operand(operand)?;\n                         let usize = self.tcx.types.usize;\n                         let n = self.value_to_primval(n_ptr, usize)?.expect_uint(\"Projection::Index expected usize\");\n-                        base.ptr.offset(n as isize * elem_size as isize)\n+                        match base {\n+                            Value::ByRef(ptr) |\n+                            Value::ByValPair(PrimVal::Ptr(ptr), _) |\n+                            Value::ByVal(PrimVal::Ptr(ptr)) => Value::ByRef(ptr.offset(n as isize * elem_size as isize)),\n+                            other => bug!(\"index op on {:?}\", other),\n+                        }\n                     }\n \n                     ConstantIndex { .. } => unimplemented!(),\n                     Subslice { .. } => unimplemented!(),\n                 }\n             }\n         };\n-\n-        Ok(Lvalue { ptr: ptr, extra: LvalueExtra::None })\n+        Ok(value)\n     }\n \n     fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n@@ -958,15 +958,30 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.write_primval(ptr, primval)?;\n                 Ok(ptr)\n             }\n+\n+            Value::ByValPair(a, b) => {\n+                let size = self.type_size(ty);\n+                let align = self.type_align(ty);\n+                let ptr = self.memory.allocate(size, align)?;\n+                let ptr_size = self.memory.pointer_size() as isize;\n+                self.memory.write_primval(ptr, a)?;\n+                self.memory.write_primval(ptr.offset(ptr_size), b)?;\n+                Ok(ptr)\n+            }\n         }\n     }\n \n     fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match value {\n-            Value::ByRef(ptr) => self.read_primval(ptr, ty),\n+            Value::ByRef(ptr) => match self.read_value(ptr, ty)? {\n+                Value::ByRef(_) => bug!(\"read_value can't result in `ByRef`\"),\n+                Value::ByVal(primval) => Ok(primval),\n+                Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n+            },\n \n             // TODO(solson): Sanity-check the primval type against the input type.\n             Value::ByVal(primval) => Ok(primval),\n+            Value::ByValPair(..) => bug!(\"value_to_primval can't work with fat pointers\"),\n         }\n     }\n \n@@ -979,10 +994,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match value {\n             Value::ByRef(ptr) => self.move_(ptr, dest, dest_ty),\n             Value::ByVal(primval) => self.memory.write_primval(dest, primval),\n+            Value::ByValPair(a, b) => {\n+                self.memory.write_primval(dest, a)?;\n+                let extra_dest = dest.offset(self.memory.pointer_size() as isize);\n+                self.memory.write_primval(extra_dest, b)\n+            }\n+        }\n+    }\n+\n+    // ensures that this value isn't a `ByRef` anymore\n+    fn follow_ref(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n+        match value {\n+            Value::ByRef(ptr) => self.read_value(ptr, ty),\n+            other => Ok(other),\n         }\n     }\n \n-    pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n+    fn read_value(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         use syntax::ast::{IntTy, UintTy, FloatTy};\n         let val = match &ty.sty {\n             &ty::TyBool => PrimVal::Bool(self.memory.read_bool(ptr)?),\n@@ -1022,12 +1050,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 } else {\n                     // FIXME: extract the offset to the tail field for `Box<(i64, i32, [u8])>`\n                     let extra = ptr.offset(self.memory.pointer_size() as isize);\n-                    match self.tcx.struct_tail(ty).sty {\n-                        ty::TyTrait(..) => PrimVal::VtablePtr(p, self.memory.read_ptr(extra)?),\n+                    let extra = match self.tcx.struct_tail(ty).sty {\n+                        ty::TyTrait(..) => PrimVal::Ptr(self.memory.read_ptr(extra)?),\n                         ty::TySlice(..) |\n-                        ty::TyStr => PrimVal::SlicePtr(p, self.memory.read_usize(extra)?),\n+                        ty::TyStr => self.target_usize_primval(self.memory.read_usize(extra)?),\n                         _ => bug!(\"unsized primval ptr read from {:?}\", ty),\n-                    }\n+                    };\n+                    return Ok(Value::ByValPair(PrimVal::Ptr(p), extra));\n                 }\n             }\n \n@@ -1052,7 +1081,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             _ => bug!(\"primitive read of non-primitive type: {:?}\", ty),\n         };\n-        Ok(val)\n+        Ok(Value::ByVal(val))\n     }\n \n     fn frame(&self) -> &Frame<'a, 'tcx> {\n@@ -1083,13 +1112,6 @@ fn pointee_type(ptr_ty: ty::Ty) -> Option<ty::Ty> {\n     }\n }\n \n-impl Lvalue {\n-    fn to_ptr(self) -> Pointer {\n-        assert_eq!(self.extra, LvalueExtra::None);\n-        self.ptr\n-    }\n-}\n-\n impl<'mir, 'tcx: 'mir> Deref for CachedMir<'mir, 'tcx> {\n     type Target = mir::Mir<'tcx>;\n     fn deref(&self) -> &mir::Mir<'tcx> {"}, {"sha": "c025852bc5e458584c073164d6d2c5236b19b536", "filename": "src/interpreter/terminator/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fterminator%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fintrinsics.rs?ref=5d1080d0caf0e334a9ec800086723ad15721b3c1", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir::repr as mir;\n use rustc::ty::layout::Layout;\n use rustc::ty::subst::Substs;\n-use rustc::ty;\n+use rustc::ty::{self, Ty};\n \n use error::{EvalError, EvalResult};\n use memory::Pointer;\n@@ -17,6 +17,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         args: &[mir::Operand<'tcx>],\n         dest: Pointer,\n+        dest_ty: Ty<'tcx>,\n         dest_layout: &'tcx Layout,\n     ) -> EvalResult<'tcx, ()> {\n         let args_ptrs: EvalResult<Vec<Value>> = args.iter()\n@@ -202,8 +203,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"type_name\" => {\n                 let ty = substs.type_at(0);\n                 let ty_name = ty.to_string();\n-                let s = self.str_to_primval(&ty_name)?;\n-                self.memory.write_primval(dest, s)?;\n+                let s = self.str_to_value(&ty_name)?;\n+                self.write_value(s, dest, dest_ty)?;\n             }\n             \"type_id\" => {\n                 let ty = substs.type_at(0);"}, {"sha": "c4415415f6e4b4134d28f5e8e5cb6f5635189313", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=5d1080d0caf0e334a9ec800086723ad15721b3c1", "patch": "@@ -43,13 +43,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n+                let discr_ptr = self.eval_lvalue(discr)?;\n                 let discr_ty = self.lvalue_ty(discr);\n                 let discr_size = self\n                     .type_layout(discr_ty)\n                     .size(&self.tcx.data_layout)\n                     .bytes() as usize;\n-                let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n+                let discr_val = discr_ptr.read_uint(&self.memory, discr_size)?;\n                 if let ty::TyChar = discr_ty.sty {\n                     if ::std::char::from_u32(discr_val as u32).is_none() {\n                         return Err(EvalError::InvalidChar(discr_val as u64));\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = fn_ty.sig.0.output;\n                 let layout = self.type_layout(ty);\n                 let (ret, target) = destination.unwrap();\n-                self.call_intrinsic(def_id, substs, arg_operands, ret, layout)?;\n+                self.call_intrinsic(def_id, substs, arg_operands, ret, ty, layout)?;\n                 self.goto_block(target);\n                 Ok(())\n             }"}, {"sha": "6512fe9b1594174a3604aa8707d547b7a14e2d0b", "filename": "src/interpreter/value.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Finterpreter%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fvalue.rs?ref=5d1080d0caf0e334a9ec800086723ad15721b3c1", "patch": "@@ -14,24 +14,48 @@ use primval::PrimVal;\n pub(super) enum Value {\n     ByRef(Pointer),\n     ByVal(PrimVal),\n+    ByValPair(PrimVal, PrimVal),\n }\n \n impl Value {\n+\n     pub(super) fn read_ptr<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr),\n             ByVal(PrimVal::Ptr(ptr)) |\n             ByVal(PrimVal::FnPtr(ptr)) => Ok(ptr),\n+            ByValPair(..) => unimplemented!(),\n+            ByVal(_other) => unimplemented!(),\n+        }\n+    }\n+\n+    pub(super) fn read_uint<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>, size: usize) -> EvalResult<'tcx, u64> {\n+        use self::Value::*;\n+        match *self {\n+            ByRef(ptr) => mem.read_uint(ptr, size),\n+            ByVal(PrimVal::U8(u)) => Ok(u as u64),\n+            ByVal(PrimVal::U16(u)) => Ok(u as u64),\n+            ByVal(PrimVal::U32(u)) => Ok(u as u64),\n+            ByVal(PrimVal::U64(u)) => Ok(u as u64),\n+            ByValPair(..) => unimplemented!(),\n             ByVal(_other) => unimplemented!(),\n         }\n     }\n \n+    pub(super) fn to_ptr(&self) -> Pointer {\n+        use self::Value::*;\n+        match *self {\n+            ByRef(ptr) => ptr,\n+            other => bug!(\"expected pointer, got {:?}\", other),\n+        }\n+    }\n+\n     pub(super) fn expect_vtable<'a, 'tcx: 'a>(&self, mem: &Memory<'a, 'tcx>) -> EvalResult<'tcx, Pointer> {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_ptr(ptr.offset(mem.pointer_size() as isize)),\n-            ByVal(PrimVal::VtablePtr(_, vtable)) => Ok(vtable),\n+            ByValPair(_, PrimVal::Ptr(vtable)) => Ok(vtable),\n             _ => unimplemented!(),\n         }\n     }\n@@ -40,7 +64,10 @@ impl Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr) => mem.read_usize(ptr.offset(mem.pointer_size() as isize)),\n-            ByVal(PrimVal::SlicePtr(_, len)) => Ok(len),\n+            ByValPair(_, PrimVal::U8(len)) => Ok(len as u64),\n+            ByValPair(_, PrimVal::U16(len)) => Ok(len as u64),\n+            ByValPair(_, PrimVal::U32(len)) => Ok(len as u64),\n+            ByValPair(_, PrimVal::U64(len)) => Ok(len),\n             _ => unimplemented!(),\n         }\n     }"}, {"sha": "eeae014c6da1c8fb7926edaf95c3a33971b3c03f", "filename": "src/memory.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=5d1080d0caf0e334a9ec800086723ad15721b3c1", "patch": "@@ -550,20 +550,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             PrimVal::F64(f) => self.write_f64(ptr, f),\n             PrimVal::FnPtr(p) |\n             PrimVal::Ptr(p) => self.write_ptr(ptr, p),\n-            PrimVal::VtablePtr(p, v) => {\n-                assert_eq!(layout::FAT_PTR_ADDR, 0);\n-                assert_eq!(layout::FAT_PTR_EXTRA, 1);\n-                self.write_ptr(ptr, p)?;\n-                let vptr = ptr.offset(self.pointer_size() as isize);\n-                self.write_ptr(vptr, v)\n-            }\n-            PrimVal::SlicePtr(p, n) => {\n-                assert_eq!(layout::FAT_PTR_ADDR, 0);\n-                assert_eq!(layout::FAT_PTR_EXTRA, 1);\n-                self.write_ptr(ptr, p)?;\n-                let nptr = ptr.offset(self.pointer_size() as isize);\n-                self.write_usize(nptr, n)\n-            }\n         }\n     }\n "}, {"sha": "70934c2a549ac47b0fefcaa9e1ff134613c69e88", "filename": "src/primval.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d1080d0caf0e334a9ec800086723ad15721b3c1/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=5d1080d0caf0e334a9ec800086723ad15721b3c1", "patch": "@@ -14,8 +14,6 @@ pub enum PrimVal {\n \n     Ptr(Pointer),\n     FnPtr(Pointer),\n-    VtablePtr(Pointer, Pointer),\n-    SlicePtr(Pointer, u64),\n     Char(char),\n \n     F32(f32), F64(f64),"}]}