{"sha": "3a51caa6485b7db6ce323cba47dfbe7c44026af5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNTFjYWE2NDg1YjdkYjZjZTMyM2NiYTQ3ZGZiZTdjNDQwMjZhZjU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T02:30:03Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:15:26Z"}, "message": "typeck/pat.rs: extract `check_pat_tuple`.", "tree": {"sha": "6dc720826af297ebd37add7764edba645c502ef5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dc720826af297ebd37add7764edba645c502ef5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a51caa6485b7db6ce323cba47dfbe7c44026af5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a51caa6485b7db6ce323cba47dfbe7c44026af5", "html_url": "https://github.com/rust-lang/rust/commit/3a51caa6485b7db6ce323cba47dfbe7c44026af5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a51caa6485b7db6ce323cba47dfbe7c44026af5/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c16248d3a1893b985d7957bfed16ed119fdbfd6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c16248d3a1893b985d7957bfed16ed119fdbfd6f", "html_url": "https://github.com/rust-lang/rust/commit/c16248d3a1893b985d7957bfed16ed119fdbfd6f"}], "stats": {"total": 103, "additions": 58, "deletions": 45}, "files": [{"sha": "be128ea358e7ed21ed37f7b2de44b2c1eb7eca21", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/3a51caa6485b7db6ce323cba47dfbe7c44026af5/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a51caa6485b7db6ce323cba47dfbe7c44026af5/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=3a51caa6485b7db6ce323cba47dfbe7c44026af5", "patch": "@@ -105,48 +105,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected_ty\n             }\n             PatKind::Tuple(ref elements, ddpos) => {\n-                let mut expected_len = elements.len();\n-                if ddpos.is_some() {\n-                    // Require known type only when `..` is present.\n-                    if let ty::Tuple(ref tys) =\n-                            self.structurally_resolved_type(pat.span, expected).sty {\n-                        expected_len = tys.len();\n-                    }\n-                }\n-                let max_len = cmp::max(expected_len, elements.len());\n-\n-                let element_tys_iter = (0..max_len).map(|_| {\n-                    Kind::from(self.next_ty_var(\n-                        // FIXME: `MiscVariable` for now -- obtaining the span and name information\n-                        // from all tuple elements isn't trivial.\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeInference,\n-                            span: pat.span,\n-                        },\n-                    ))\n-                });\n-                let element_tys = tcx.mk_substs(element_tys_iter);\n-                let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n-                if let Some(mut err) = self.demand_eqtype_diag(pat.span, expected, pat_ty) {\n-                    err.emit();\n-                    // Walk subpatterns with an expected type of `err` in this case to silence\n-                    // further errors being emitted when using the bindings. #50333\n-                    let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n-                    for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(elem, &tcx.types.err, def_bm, discrim_span);\n-                    }\n-                    tcx.mk_tup(element_tys_iter)\n-                } else {\n-                    for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                        self.check_pat_walk(\n-                            elem,\n-                            &element_tys[i].expect_ty(),\n-                            def_bm,\n-                            discrim_span,\n-                        );\n-                    }\n-                    pat_ty\n-                }\n+                self.check_pat_tuple(pat.span, elements, ddpos, expected, def_bm, discrim_span)\n             }\n             PatKind::Box(ref inner) => {\n                 let inner_ty = self.next_ty_var(TypeVariableOrigin {\n@@ -807,7 +766,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             pat.hir_id);\n         if !pat_ty.is_fn() {\n             report_unexpected_res(res);\n-            return self.tcx.types.err;\n+            return tcx.types.err;\n         }\n \n         let variant = match res {\n@@ -833,8 +792,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.demand_eqtype_pat(pat.span, expected, pat_ty, match_arm_pat_span);\n \n         // Type-check subpatterns.\n-        if subpats.len() == variant.fields.len() ||\n-                subpats.len() < variant.fields.len() && ddpos.is_some() {\n+        if subpats.len() == variant.fields.len()\n+            || subpats.len() < variant.fields.len() && ddpos.is_some()\n+        {\n             let substs = match pat_ty.sty {\n                 ty::Adt(_, substs) => substs,\n                 _ => bug!(\"unexpected pattern type {:?}\", pat_ty),\n@@ -861,6 +821,59 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat_ty\n     }\n \n+    fn check_pat_tuple(\n+        &self,\n+        span: Span,\n+        elements: &'tcx [P<hir::Pat>],\n+        ddpos: Option<usize>,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let mut expected_len = elements.len();\n+        if ddpos.is_some() {\n+            // Require known type only when `..` is present.\n+            if let ty::Tuple(ref tys) = self.structurally_resolved_type(span, expected).sty {\n+                expected_len = tys.len();\n+            }\n+        }\n+        let max_len = cmp::max(expected_len, elements.len());\n+\n+        let element_tys_iter = (0..max_len).map(|_| {\n+            Kind::from(self.next_ty_var(\n+                // FIXME: `MiscVariable` for now -- obtaining the span and name information\n+                // from all tuple elements isn't trivial.\n+                TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::TypeInference,\n+                    span,\n+                },\n+            ))\n+        });\n+        let element_tys = tcx.mk_substs(element_tys_iter);\n+        let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n+        if let Some(mut err) = self.demand_eqtype_diag(span, expected, pat_ty) {\n+            err.emit();\n+            // Walk subpatterns with an expected type of `err` in this case to silence\n+            // further errors being emitted when using the bindings. #50333\n+            let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n+            for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                self.check_pat_walk(elem, &tcx.types.err, def_bm, discrim_span);\n+            }\n+            tcx.mk_tup(element_tys_iter)\n+        } else {\n+            for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n+                self.check_pat_walk(\n+                    elem,\n+                    &element_tys[i].expect_ty(),\n+                    def_bm,\n+                    discrim_span,\n+                );\n+            }\n+            pat_ty\n+        }\n+    }\n+\n     fn check_struct_pat_fields(\n         &self,\n         adt_ty: Ty<'tcx>,"}]}