{"sha": "2f79f73821db1f1f169abe526fc89c8b376636ea", "node_id": "C_kwDOAAsO6NoAKDJmNzlmNzM4MjFkYjFmMWYxNjlhYmU1MjZmYzg5YzhiMzc2NjM2ZWE", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-08T15:27:01Z"}, "committer": {"name": "b-naber", "email": "b_naber@gmx.de", "date": "2023-02-19T22:11:27Z"}, "message": "collect region contexts during mir renumbering", "tree": {"sha": "4667b7d366487daa5f886efcb9c5c4bff7ae1c44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4667b7d366487daa5f886efcb9c5c4bff7ae1c44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f79f73821db1f1f169abe526fc89c8b376636ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f79f73821db1f1f169abe526fc89c8b376636ea", "html_url": "https://github.com/rust-lang/rust/commit/2f79f73821db1f1f169abe526fc89c8b376636ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f79f73821db1f1f169abe526fc89c8b376636ea/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb35a7b4815774f7d8c8b9770df5a9719532755f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb35a7b4815774f7d8c8b9770df5a9719532755f", "html_url": "https://github.com/rust-lang/rust/commit/cb35a7b4815774f7d8c8b9770df5a9719532755f"}], "stats": {"total": 406, "additions": 364, "deletions": 42}, "files": [{"sha": "60fe88764f40fc5cfb915cfaa836fa79a94eaaee", "filename": "Cargo.lock", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f79f73821db1f1f169abe526fc89c8b376636ea/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2f79f73821db1f1f169abe526fc89c8b376636ea/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2f79f73821db1f1f169abe526fc89c8b376636ea", "patch": "@@ -782,7 +782,7 @@ dependencies = [\n  \"declare_clippy_lint\",\n  \"if_chain\",\n  \"itertools\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.9.2\",\n  \"quine-mc_cluskey\",\n  \"regex-syntax\",\n  \"rustc-semver\",\n@@ -2003,9 +2003,9 @@ dependencies = [\n \n [[package]]\n name = \"http-auth\"\n-version = \"0.1.6\"\n+version = \"0.1.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c0b40b39d66c28829a0cf4d09f7e139ff8201f7500a5083732848ed3b4b4d850\"\n+checksum = \"5430cacd7a1f9a02fbeb350dfc81a0e5ed42d81f3398cb0ba184017f85bdcfbc\"\n dependencies = [\n  \"memchr\",\n ]\n@@ -2555,7 +2555,7 @@ dependencies = [\n  \"memchr\",\n  \"once_cell\",\n  \"opener\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.9.2\",\n  \"regex\",\n  \"serde\",\n  \"serde_json\",\n@@ -2572,7 +2572,7 @@ dependencies = [\n  \"anyhow\",\n  \"handlebars 3.5.5\",\n  \"pretty_assertions\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.7.2\",\n  \"same-file\",\n  \"serde_json\",\n  \"url\",\n@@ -3269,6 +3269,17 @@ dependencies = [\n  \"cc\",\n ]\n \n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.7.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca36dea94d187597e104a5c8e4b07576a8a45aa5db48a65e12940d3eb7461f55\"\n+dependencies = [\n+ \"bitflags\",\n+ \"memchr\",\n+ \"unicase\",\n+]\n+\n [[package]]\n name = \"pulldown-cmark\"\n version = \"0.9.2\"\n@@ -4572,7 +4583,7 @@ name = \"rustc_resolve\"\n version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.9.2\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\","}, {"sha": "70f6a323e8810f2d107eb68fda88f40dba0886be", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 76, "deletions": 14, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=2f79f73821db1f1f169abe526fc89c8b376636ea", "patch": "@@ -25,7 +25,9 @@ use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, NllRegionVariableOrigin, TyCtxtInferExt};\n+use rustc_infer::infer::{\n+    DefiningAnchor, InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin, TyCtxtInferExt,\n+};\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, NonDivergingIntrinsic, Operand,\n     Place, PlaceElem, PlaceRef, VarDebugInfoContents,\n@@ -95,6 +97,7 @@ use nll::{PoloniusOutput, ToRegionVid};\n use place_ext::PlaceExt;\n use places_conflict::{places_conflict, PlaceConflictBias};\n use region_infer::RegionInferenceContext;\n+use renumber::RegionCtxt;\n \n // FIXME(eddyb) perhaps move this somewhere more centrally.\n #[derive(Debug)]\n@@ -168,10 +171,10 @@ fn do_mir_borrowck<'tcx>(\n     return_body_with_facts: bool,\n ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {\n     let def = input_body.source.with_opt_param().as_local().unwrap();\n-\n     debug!(?def);\n \n     let tcx = infcx.tcx;\n+    let infcx = BorrowckInferCtxt::new(infcx);\n     let param_env = tcx.param_env(def.did);\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n@@ -219,7 +222,7 @@ fn do_mir_borrowck<'tcx>(\n     let mut body_owned = input_body.clone();\n     let mut promoted = input_promoted.clone();\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, param_env, &mut body_owned, &mut promoted);\n+        nll::replace_regions_in_mir(&infcx, param_env, &mut body_owned, &mut promoted);\n     let body = &body_owned; // no further changes\n \n     let location_table_owned = LocationTable::new(body);\n@@ -257,7 +260,7 @@ fn do_mir_borrowck<'tcx>(\n         opt_closure_req,\n         nll_errors,\n     } = nll::compute_regions(\n-        infcx,\n+        &infcx,\n         free_regions,\n         body,\n         &promoted,\n@@ -272,12 +275,12 @@ fn do_mir_borrowck<'tcx>(\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n-    nll::dump_mir_results(infcx, &body, &regioncx, &opt_closure_req);\n+    nll::dump_mir_results(&infcx, &body, &regioncx, &opt_closure_req);\n \n     // We also have a `#[rustc_regions]` annotation that causes us to dump\n     // information.\n     nll::dump_annotation(\n-        infcx,\n+        &infcx,\n         &body,\n         &regioncx,\n         &opt_closure_req,\n@@ -321,7 +324,7 @@ fn do_mir_borrowck<'tcx>(\n \n         if let Err((move_data, move_errors)) = move_data_results {\n             let mut promoted_mbcx = MirBorrowckCtxt {\n-                infcx,\n+                infcx: &infcx,\n                 param_env,\n                 body: promoted_body,\n                 move_data: &move_data,\n@@ -350,7 +353,7 @@ fn do_mir_borrowck<'tcx>(\n     }\n \n     let mut mbcx = MirBorrowckCtxt {\n-        infcx,\n+        infcx: &infcx,\n         param_env,\n         body,\n         move_data: &mdpe.move_data,\n@@ -482,22 +485,81 @@ pub struct BodyWithBorrowckFacts<'tcx> {\n     pub location_table: LocationTable,\n }\n \n-struct BorrowckInferCtxt<'cx, 'tcx> {\n+pub struct BorrowckInferCtxt<'cx, 'tcx> {\n     pub(crate) infcx: &'cx InferCtxt<'tcx>,\n \n     #[cfg(debug_assertions)]\n-    pub(crate) _reg_var_to_origin: RefCell<FxHashMap<ty::Region<'tcx>, NllRegionVariableOrigin>>,\n+    pub(crate) reg_var_to_origin: RefCell<FxHashMap<ty::RegionVid, RegionCtxt>>,\n }\n \n impl<'cx, 'tcx> BorrowckInferCtxt<'cx, 'tcx> {\n     #[cfg(not(debug_assertions))]\n-    pub(crate) fn _new(infcx: &'cx InferCtxt<'tcx>) -> Self {\n+    pub(crate) fn new(infcx: &'cx InferCtxt<'tcx>) -> Self {\n         BorrowckInferCtxt { infcx }\n     }\n \n     #[cfg(debug_assertions)]\n-    pub(crate) fn _new(infcx: &'cx InferCtxt<'tcx>) -> Self {\n-        BorrowckInferCtxt { infcx, _reg_var_to_origin: RefCell::new(Default::default()) }\n+    pub(crate) fn new(infcx: &'cx InferCtxt<'tcx>) -> Self {\n+        BorrowckInferCtxt { infcx, reg_var_to_origin: RefCell::new(Default::default()) }\n+    }\n+\n+    #[cfg(not(debug_assertions))]\n+    pub(crate) fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n+        self.infcx.next_region_var(origin)\n+    }\n+\n+    #[cfg(debug_assertions)]\n+    pub(crate) fn next_region_var(\n+        &self,\n+        origin: RegionVariableOrigin,\n+        ctxt: RegionCtxt,\n+    ) -> ty::Region<'tcx> {\n+        let next_region = self.infcx.next_region_var(origin);\n+        let vid = next_region\n+            .try_get_var()\n+            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+\n+        debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n+        let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n+        let prev = var_to_origin.insert(vid, ctxt);\n+        debug!(\"var_to_origin after insertion: {:?}\", var_to_origin);\n+\n+        // This only makes sense if not called in a canonicalization context. If this\n+        // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n+        // or modify how we track nll region vars for that map.\n+        assert!(matches!(prev, None));\n+\n+        next_region\n+    }\n+\n+    #[cfg(not(debug_assertions))]\n+    pub(crate) fn next_nll_region_var(&self, origin: NllRegionVariableOrigin) -> ty::Region<'tcx> {\n+        self.infcx.next_nll_region_var(origin)\n+    }\n+\n+    #[cfg(debug_assertions)]\n+    #[instrument(skip(self), level = \"debug\")]\n+    pub(crate) fn next_nll_region_var(\n+        &self,\n+        origin: NllRegionVariableOrigin,\n+        ctxt: RegionCtxt,\n+    ) -> ty::Region<'tcx> {\n+        let next_region = self.infcx.next_nll_region_var(origin.clone());\n+        let vid = next_region\n+            .try_get_var()\n+            .unwrap_or_else(|| bug!(\"expected RegionKind::RegionVar on {:?}\", next_region));\n+\n+        debug!(\"inserting vid {:?} with origin {:?} into var_to_origin\", vid, origin);\n+        let mut var_to_origin = self.reg_var_to_origin.borrow_mut();\n+        let prev = var_to_origin.insert(vid, ctxt);\n+        debug!(\"var_to_origin after insertion: {:?}\", var_to_origin);\n+\n+        // This only makes sense if not called in a canonicalization context. If this\n+        // ever changes we either want to get rid of `BorrowckInferContext::reg_var_to_origin`\n+        // or modify how we track nll region vars for that map.\n+        assert!(matches!(prev, None));\n+\n+        next_region\n     }\n }\n \n@@ -510,7 +572,7 @@ impl<'cx, 'tcx> Deref for BorrowckInferCtxt<'cx, 'tcx> {\n }\n \n struct MirBorrowckCtxt<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n+    infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n     param_env: ParamEnv<'tcx>,\n     body: &'cx Body<'tcx>,\n     move_data: &'cx MoveData<'tcx>,"}, {"sha": "c3301ac1442158ef7a56bbaa85a39a98adcd12ae", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=2f79f73821db1f1f169abe526fc89c8b376636ea", "patch": "@@ -5,7 +5,6 @@\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::{create_dump_file, dump_enabled, dump_mir, PassWhere};\n use rustc_middle::mir::{\n     BasicBlock, Body, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind, Location,\n@@ -37,7 +36,7 @@ use crate::{\n     renumber,\n     type_check::{self, MirTypeckRegionConstraints, MirTypeckResults},\n     universal_regions::UniversalRegions,\n-    Upvar,\n+    BorrowckInferCtxt, Upvar,\n };\n \n pub type PoloniusOutput = Output<RustcFacts>;\n@@ -58,7 +57,7 @@ pub(crate) struct NllOutput<'tcx> {\n /// `compute_regions`.\n #[instrument(skip(infcx, param_env, body, promoted), level = \"debug\")]\n pub(crate) fn replace_regions_in_mir<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n@@ -157,7 +156,7 @@ fn populate_polonius_move_facts(\n ///\n /// This may result in errors being reported.\n pub(crate) fn compute_regions<'cx, 'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     universal_regions: UniversalRegions<'tcx>,\n     body: &Body<'tcx>,\n     promoted: &IndexVec<Promoted, Body<'tcx>>,\n@@ -258,6 +257,11 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n         borrow_set,\n     );\n \n+    if cfg!(debug_assertions) {\n+        let var_to_origin = infcx.reg_var_to_origin.borrow();\n+        debug!(\"var_to_origin: {:#?}\", var_to_origin);\n+    }\n+\n     let mut regioncx = RegionInferenceContext::new(\n         var_origins,\n         universal_regions,\n@@ -322,7 +326,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n }\n \n pub(super) fn dump_mir_results<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n@@ -372,7 +376,7 @@ pub(super) fn dump_mir_results<'tcx>(\n #[allow(rustc::diagnostic_outside_of_impl)]\n #[allow(rustc::untranslatable_diagnostic)]\n pub(super) fn dump_annotation<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &Body<'tcx>,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,"}, {"sha": "adf9869c34b1569bf964399d0baf8641b6244354", "filename": "compiler/rustc_borrowck/src/renumber.rs", "status": "modified", "additions": 110, "deletions": 5, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Frenumber.rs?ref=2f79f73821db1f1f169abe526fc89c8b376636ea", "patch": "@@ -1,18 +1,23 @@\n+<<<<<<< HEAD\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n+=======\n+use crate::BorrowckInferCtxt;\n+>>>>>>> 2464f768a17 (collect region contexts during mir renumbering)\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::mir::visit::{MutVisitor, TyContext};\n use rustc_middle::mir::Constant;\n use rustc_middle::mir::{Body, Location, Promoted};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc_span::Symbol;\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n #[instrument(skip(infcx, body, promoted), level = \"debug\")]\n pub fn renumber_mir<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) {\n@@ -29,8 +34,9 @@ pub fn renumber_mir<'tcx>(\n \n /// Replaces all regions appearing in `value` with fresh inference\n /// variables.\n+#[cfg(not(debug_assertions))]\n #[instrument(skip(infcx), level = \"debug\")]\n-pub fn renumber_regions<'tcx, T>(infcx: &InferCtxt<'tcx>, value: T) -> T\n+pub(crate) fn renumber_regions<'tcx, T>(infcx: &BorrowckInferCtxt<'_, 'tcx>, value: T) -> T\n where\n     T: TypeFoldable<'tcx>,\n {\n@@ -40,11 +46,73 @@ where\n     })\n }\n \n+/// Replaces all regions appearing in `value` with fresh inference\n+/// variables.\n+#[cfg(debug_assertions)]\n+#[instrument(skip(infcx), level = \"debug\")]\n+pub(crate) fn renumber_regions<'tcx, T>(\n+    infcx: &BorrowckInferCtxt<'_, 'tcx>,\n+    value: T,\n+    ctxt: RegionCtxt,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    infcx.tcx.fold_regions(value, |_region, _depth| {\n+        let origin = NllRegionVariableOrigin::Existential { from_forall: false };\n+        infcx.next_nll_region_var(origin, ctxt)\n+    })\n+}\n+\n+#[cfg(debug_assertions)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n+pub(crate) enum RegionCtxt {\n+    Location(Location),\n+    TyContext(TyContext),\n+    Free(Symbol),\n+    Bound(Symbol),\n+    LateBound(Symbol),\n+    Existential(Option<Symbol>),\n+    Placeholder(Symbol),\n+    Unknown,\n+}\n+\n+#[cfg(debug_assertions)]\n+impl RegionCtxt {\n+    /// Used to determine the representative of a component in the strongly connected\n+    /// constraint graph\n+    /// FIXME: don't use underscore here. Got a 'not used' error for some reason\n+    pub(crate) fn _preference_value(self) -> usize {\n+        let _anon = Symbol::intern(\"anon\");\n+\n+        match self {\n+            RegionCtxt::Unknown => 1,\n+            RegionCtxt::Existential(None) => 2,\n+            RegionCtxt::Existential(Some(_anon))\n+            | RegionCtxt::Free(_anon)\n+            | RegionCtxt::Bound(_anon)\n+            | RegionCtxt::LateBound(_anon) => 2,\n+            RegionCtxt::Location(_) => 3,\n+            RegionCtxt::TyContext(_) => 4,\n+            _ => 5,\n+        }\n+    }\n+}\n+\n struct NllVisitor<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'tcx>,\n+    infcx: &'a BorrowckInferCtxt<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> NllVisitor<'a, 'tcx> {\n+    #[cfg(debug_assertions)]\n+    fn renumber_regions<T>(&mut self, value: T, ctxt: RegionCtxt) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        renumber_regions(self.infcx, value, ctxt)\n+    }\n+\n+    #[cfg(not(debug_assertions))]\n     fn renumber_regions<T>(&mut self, value: T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n@@ -58,20 +126,39 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n+    #[cfg(not(debug_assertions))]\n     #[instrument(skip(self), level = \"debug\")]\n-    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _ty_context: TyContext) {\n         *ty = self.renumber_regions(*ty);\n \n         debug!(?ty);\n     }\n \n+    #[cfg(debug_assertions)]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _ty_context: TyContext) {\n+        *ty = self.renumber_regions(*ty, RegionCtxt::TyContext(_ty_context));\n+\n+        debug!(?ty);\n+    }\n+\n+    #[cfg(not(debug_assertions))]\n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, location: Location) {\n         *substs = self.renumber_regions(*substs);\n \n         debug!(?substs);\n     }\n \n+    #[cfg(debug_assertions)]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_substs(&mut self, substs: &mut SubstsRef<'tcx>, location: Location) {\n+        *substs = self.renumber_regions(*substs, RegionCtxt::Location(location));\n+\n+        debug!(?substs);\n+    }\n+\n+    #[cfg(not(debug_assertions))]\n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_region(&mut self, region: &mut ty::Region<'tcx>, location: Location) {\n         let old_region = *region;\n@@ -80,10 +167,28 @@ impl<'a, 'tcx> MutVisitor<'tcx> for NllVisitor<'a, 'tcx> {\n         debug!(?region);\n     }\n \n+    #[cfg(debug_assertions)]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_region(&mut self, region: &mut ty::Region<'tcx>, location: Location) {\n+        let old_region = *region;\n+        *region = self.renumber_regions(old_region, RegionCtxt::Location(location));\n+\n+        debug!(?region);\n+    }\n+\n+    #[cfg(not(debug_assertions))]\n     #[instrument(skip(self), level = \"debug\")]\n     fn visit_constant(&mut self, constant: &mut Constant<'tcx>, _location: Location) {\n         let literal = constant.literal;\n         constant.literal = self.renumber_regions(literal);\n         debug!(\"constant: {:#?}\", constant);\n     }\n+\n+    #[cfg(debug_assertions)]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_constant(&mut self, constant: &mut Constant<'tcx>, _location: Location) {\n+        let literal = constant.literal;\n+        constant.literal = self.renumber_regions(literal, RegionCtxt::Location(_location));\n+        debug!(\"constant: {:#?}\", constant);\n+    }\n }"}, {"sha": "8eb42ade65b04d1f6ba7054ab11eb6629a3ddb34", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=2f79f73821db1f1f169abe526fc89c8b376636ea", "patch": "@@ -1335,11 +1335,35 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                 };\n                 let (sig, map) = tcx.replace_late_bound_regions(sig, |br| {\n-                    self.infcx.next_region_var(LateBoundRegion(\n-                        term.source_info.span,\n-                        br.kind,\n-                        LateBoundRegionConversionTime::FnCall,\n-                    ))\n+                    #[cfg(not(debug_assertions))]\n+                    {\n+                        self.infcx.next_region_var(LateBoundRegion(\n+                            term.source_info.span,\n+                            br.kind,\n+                            LateBoundRegionConversionTime::FnCall,\n+                        ))\n+                    }\n+\n+                    #[cfg(debug_assertions)]\n+                    {\n+                        use crate::renumber::RegionCtxt;\n+                        use rustc_span::Symbol;\n+\n+                        let name = match br.kind {\n+                            ty::BoundRegionKind::BrAnon(_) => Symbol::intern(\"anon\"),\n+                            ty::BoundRegionKind::BrNamed(_, name) => name,\n+                            ty::BoundRegionKind::BrEnv => Symbol::intern(\"env\"),\n+                        };\n+\n+                        self.infcx.next_region_var(\n+                            LateBoundRegion(\n+                                term.source_info.span,\n+                                br.kind,\n+                                LateBoundRegionConversionTime::FnCall,\n+                            ),\n+                            RegionCtxt::LateBound(name),\n+                        )\n+                    }\n                 });\n                 debug!(?sig);\n                 // IMPORTANT: We have to prove well formed for the function signature before"}, {"sha": "919c772a20387d10bed61e3483131104f8089c5b", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 112, "deletions": 5, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=2f79f73821db1f1f169abe526fc89c8b376636ea", "patch": "@@ -20,15 +20,18 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin};\n+use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{\n     self, DefIdTree, InlineConstSubsts, InlineConstSubstsParts, RegionVid, Ty, TyCtxt,\n };\n use rustc_middle::ty::{InternalSubsts, SubstsRef};\n+use rustc_span::Symbol;\n use std::iter;\n \n use crate::nll::ToRegionVid;\n+use crate::renumber::RegionCtxt;\n+use crate::BorrowckInferCtxt;\n \n #[derive(Debug)]\n pub struct UniversalRegions<'tcx> {\n@@ -224,7 +227,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n     /// signature. This will also compute the relationships that are\n     /// known between those regions.\n     pub fn new(\n-        infcx: &InferCtxt<'tcx>,\n+        infcx: &BorrowckInferCtxt<'_, 'tcx>,\n         mir_def: ty::WithOptConstParam<LocalDefId>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n@@ -385,7 +388,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n }\n \n struct UniversalRegionsBuilder<'cx, 'tcx> {\n-    infcx: &'cx InferCtxt<'tcx>,\n+    infcx: &'cx BorrowckInferCtxt<'cx, 'tcx>,\n     mir_def: ty::WithOptConstParam<LocalDefId>,\n     mir_hir_id: HirId,\n     param_env: ty::ParamEnv<'tcx>,\n@@ -403,7 +406,13 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         assert_eq!(FIRST_GLOBAL_INDEX, self.infcx.num_region_vars());\n \n         // Create the \"global\" region that is always free in all contexts: 'static.\n+        #[cfg(not(debug_assertions))]\n         let fr_static = self.infcx.next_nll_region_var(FR).to_region_vid();\n+        #[cfg(debug_assertions)]\n+        let fr_static = self\n+            .infcx\n+            .next_nll_region_var(FR, RegionCtxt::Free(Symbol::intern(\"static\")))\n+            .to_region_vid();\n \n         // We've now added all the global regions. The next ones we\n         // add will be external.\n@@ -480,6 +489,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                     LangItem::VaList,\n                     Some(self.infcx.tcx.def_span(self.mir_def.did)),\n                 );\n+                let reg_vid = self.infcx.next_nll_region_var(FR, RegionCtxt::Free(Symbol::intern(\"c-variadic\")).to_region_vid();\n                 let region =\n                     self.infcx.tcx.mk_re_var(self.infcx.next_nll_region_var(FR).to_region_vid());\n                 let va_list_ty =\n@@ -491,7 +501,14 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n             }\n         }\n \n+        #[cfg(not(debug_assertions))]\n         let fr_fn_body = self.infcx.next_nll_region_var(FR).to_region_vid();\n+        #[cfg(debug_assertions)]\n+        let fr_fn_body = self\n+            .infcx\n+            .next_nll_region_var(FR, RegionCtxt::Free(Symbol::intern(\"fn_body\")))\n+            .to_region_vid();\n+\n         let num_universals = self.infcx.num_region_vars();\n \n         debug!(\"build: global regions = {}..{}\", FIRST_GLOBAL_INDEX, first_extern_index);\n@@ -718,7 +735,8 @@ trait InferCtxtExt<'tcx> {\n     );\n }\n \n-impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for BorrowckInferCtxt<'cx, 'tcx> {\n+    #[cfg(not(debug_assertions))]\n     fn replace_free_regions_with_nll_infer_vars<T>(\n         &self,\n         origin: NllRegionVariableOrigin,\n@@ -727,9 +745,33 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        self.tcx.fold_regions(value, |_region, _depth| self.next_nll_region_var(origin))\n+        self.tcx.fold_regions(value, |_region, _depth| self.infcx.next_nll_region_var(origin))\n     }\n \n+    #[cfg(debug_assertions)]\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn replace_free_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NllRegionVariableOrigin,\n+        value: T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.infcx.tcx.fold_regions(value, |region, _depth| {\n+            let name = match region.get_name() {\n+                Some(name) => name,\n+                _ => Symbol::intern(\"anon\"),\n+            };\n+            debug!(?region, ?name);\n+\n+            let reg_var = self.next_nll_region_var(origin, RegionCtxt::Free(name));\n+\n+            reg_var\n+        })\n+    }\n+\n+    #[cfg(not(debug_assertions))]\n     #[instrument(level = \"debug\", skip(self, indices))]\n     fn replace_bound_regions_with_nll_infer_vars<T>(\n         &self,\n@@ -752,6 +794,38 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         value\n     }\n \n+    #[cfg(debug_assertions)]\n+    #[instrument(level = \"debug\", skip(self, indices))]\n+    fn replace_bound_regions_with_nll_infer_vars<T>(\n+        &self,\n+        origin: NllRegionVariableOrigin,\n+        all_outlive_scope: LocalDefId,\n+        value: ty::Binder<'tcx, T>,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let (value, _map) = self.tcx.replace_late_bound_regions(value, |br| {\n+            debug!(?br);\n+            let liberated_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n+                scope: all_outlive_scope.to_def_id(),\n+                bound_region: br.kind,\n+            }));\n+\n+            let name = match br.kind.get_name() {\n+                Some(name) => name,\n+                _ => Symbol::intern(\"anon\"),\n+            };\n+\n+            let region_vid = self.next_nll_region_var(origin, RegionCtxt::Bound(name));\n+            indices.insert_late_bound_region(liberated_region, region_vid.to_region_vid());\n+            debug!(?liberated_region, ?region_vid);\n+            region_vid\n+        });\n+        value\n+    }\n+\n     /// Finds late-bound regions that do not appear in the parameter listing and adds them to the\n     /// indices vector. Typically, we identify late-bound regions as we process the inputs and\n     /// outputs of the closure/function. However, sometimes there are late-bound regions which do\n@@ -761,6 +835,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n     /// entries for them and store them in the indices map. This code iterates over the complete\n     /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n     /// inputs vector.\n+    #[cfg(not(debug_assertions))]\n     #[instrument(skip(self, indices))]\n     fn replace_late_bound_regions_with_nll_infer_vars_in_recursive_scope(\n         &self,\n@@ -792,6 +867,38 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             }\n         });\n     }\n+\n+    /// Finds late-bound regions that do not appear in the parameter listing and adds them to the\n+    /// indices vector. Typically, we identify late-bound regions as we process the inputs and\n+    /// outputs of the closure/function. However, sometimes there are late-bound regions which do\n+    /// not appear in the fn parameters but which are nonetheless in scope. The simplest case of\n+    /// this are unused functions, like fn foo<'a>() { } (see e.g., #51351). Despite not being used,\n+    /// users can still reference these regions (e.g., let x: &'a u32 = &22;), so we need to create\n+    /// entries for them and store them in the indices map. This code iterates over the complete\n+    /// set of late-bound regions and checks for any that we have not yet seen, adding them to the\n+    /// inputs vector.\n+    #[cfg(debug_assertions)]\n+    #[instrument(skip(self, indices))]\n+    fn replace_late_bound_regions_with_nll_infer_vars(\n+        &self,\n+        mir_def_id: LocalDefId,\n+        indices: &mut UniversalRegionIndices<'tcx>,\n+    ) {\n+        let typeck_root_def_id = self.tcx.typeck_root_def_id(mir_def_id.to_def_id());\n+        for_each_late_bound_region_defined_on(self.tcx, typeck_root_def_id, |r| {\n+            debug!(?r);\n+            if !indices.indices.contains_key(&r) {\n+                let name = match r.get_name() {\n+                    Some(name) => name,\n+                    _ => Symbol::intern(\"anon\"),\n+                };\n+\n+                let region_vid = self.next_nll_region_var(FR, RegionCtxt::LateBound(name));\n+                debug!(?region_vid);\n+                indices.insert_late_bound_region(r, region_vid.to_region_vid());\n+            }\n+        });\n+    }\n }\n \n impl<'tcx> UniversalRegionIndices<'tcx> {"}, {"sha": "64384fadc632b0627c511a6d19e2464c86bd8c40", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=2f79f73821db1f1f169abe526fc89c8b376636ea", "patch": "@@ -1111,11 +1111,13 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn next_nll_region_var(&self, origin: NllRegionVariableOrigin) -> ty::Region<'tcx> {\n         self.next_region_var(RegionVariableOrigin::Nll(origin))\n     }\n \n     /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub fn next_nll_region_var_in_universe(\n         &self,\n         origin: NllRegionVariableOrigin,"}, {"sha": "7f0935fb149fa4863020777bf93a5ead94eb315a", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=2f79f73821db1f1f169abe526fc89c8b376636ea", "patch": "@@ -1214,7 +1214,7 @@ impl<'tcx> MirVisitable<'tcx> for Option<Terminator<'tcx>> {\n \n /// Extra information passed to `visit_ty` and friends to give context\n /// about where the type etc appears.\n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug, Hash, Eq, PartialEq)]\n pub enum TyContext {\n     LocalDecl {\n         /// The index of the local variable we are visiting."}, {"sha": "c5d6df5b1adff737cfe75825f9a905b0aeb1b730", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f79f73821db1f1f169abe526fc89c8b376636ea/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=2f79f73821db1f1f169abe526fc89c8b376636ea", "patch": "@@ -1751,6 +1751,13 @@ impl<'tcx> Region<'tcx> {\n     pub fn is_var(self) -> bool {\n         matches!(self.kind(), ty::ReVar(_))\n     }\n+\n+    pub fn try_get_var(self) -> Option<RegionVid> {\n+        match self.kind() {\n+            ty::ReVar(vid) => Some(vid),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Type utilities"}]}