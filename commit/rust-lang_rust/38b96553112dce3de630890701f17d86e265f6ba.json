{"sha": "38b96553112dce3de630890701f17d86e265f6ba", "node_id": "C_kwDOAAsO6NoAKDM4Yjk2NTUzMTEyZGNlM2RlNjMwODkwNzAxZjE3ZDg2ZTI2NWY2YmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T22:07:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-07T22:07:56Z"}, "message": "Auto merge of #108877 - matthiaskrgr:rollup-7gwgvgc, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #108460 (migrate `rustc_hir_analysis` to session diagnostic [Part Two])\n - #108581 (Add a new config flag, dist.include-mingw-linker.)\n - #108583 (Account for binders correctly when adding default RPITIT method assumption)\n - #108783 (Sync rustc_codegen_gcc 2023/03/04)\n - #108793 (Append to existing `PYTHONPATH` in compiletest instead of overwriting)\n - #108822 (Remove references to PassManagerBuilder)\n - #108866 (Force to use the stage 2 compiler  when config.download_rustc is set)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0e794f9b5a65615f15fad3f3c47cae9eb3ecf0f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e794f9b5a65615f15fad3f3c47cae9eb3ecf0f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38b96553112dce3de630890701f17d86e265f6ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38b96553112dce3de630890701f17d86e265f6ba", "html_url": "https://github.com/rust-lang/rust/commit/38b96553112dce3de630890701f17d86e265f6ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38b96553112dce3de630890701f17d86e265f6ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3dfeeaa45f117281b19773d67f3f253de65cee1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3dfeeaa45f117281b19773d67f3f253de65cee1", "html_url": "https://github.com/rust-lang/rust/commit/e3dfeeaa45f117281b19773d67f3f253de65cee1"}, {"sha": "b0ec35362f7cb3a4a27af1af0a36b9359170ddfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0ec35362f7cb3a4a27af1af0a36b9359170ddfe", "html_url": "https://github.com/rust-lang/rust/commit/b0ec35362f7cb3a4a27af1af0a36b9359170ddfe"}], "stats": {"total": 7054, "additions": 5893, "deletions": 1161}, "files": [{"sha": "d2b7724a2215fc82381804e3031e7df191707ebb", "filename": "compiler/rustc_codegen_gcc/.github/workflows/ci.yml", "status": "modified", "additions": 66, "deletions": 45, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fci.yml?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -4,36 +4,72 @@ on:\n   - push\n   - pull_request\n \n+permissions:\n+  contents: read\n+\n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n jobs:\n   build:\n-    runs-on: ubuntu-latest\n+    runs-on: ubuntu-22.04\n \n     strategy:\n       fail-fast: false\n       matrix:\n-        libgccjit_version: [\"libgccjit.so\", \"libgccjit_without_int128.so\", \"libgccjit12.so\"]\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", extra: \"\", env_extra: \"\", artifacts_branch: \"master\" }\n+          - { gcc: \"libgccjit_without_int128.so\", extra: \"\", env_extra: \"\", artifacts_branch: \"master-without-128bit-integers\" }\n+          - { gcc: \"libgccjit12.so\", extra: \"--no-default-features\", env_extra: \"TEST_FLAGS='-Cpanic=abort -Zpanic-abort-tests'\", artifacts_branch: \"gcc12\" }\n+        commands: [\n+          \"--mini-tests\",\n+          \"--std-tests\",\n+          # FIXME: re-enable asm tests when GCC can emit in the right syntax.\n+          # \"--asm-tests\",\n+          \"--test-libcore\",\n+          \"--extended-rand-tests\",\n+          \"--extended-regex-example-tests\",\n+          \"--extended-regex-tests\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+          \"--test-failing-rustc\",\n+        ]\n \n     steps:\n-    - uses: actions/checkout@v2\n+    - uses: actions/checkout@v3\n \n-    - uses: actions/checkout@v2\n+    - uses: actions/checkout@v3\n       with:\n         repository: llvm/llvm-project\n         path: llvm\n \n     - name: Install packages\n-      run: sudo apt-get install ninja-build ripgrep\n+      # `llvm-14-tools` is needed to install the `FileCheck` binary which is used for asm tests.\n+      run: sudo apt-get install ninja-build ripgrep llvm-14-tools\n+\n+    - name: Install libgccjit12\n+      if: matrix.libgccjit_version.gcc == 'libgccjit12.so'\n+      run: sudo apt-get install libgccjit-12-dev\n \n     - name: Download artifact\n+      if: matrix.libgccjit_version.gcc != 'libgccjit12.so'\n       uses: dawidd6/action-download-artifact@v2\n       with:\n           workflow: main.yml\n-          name: ${{ matrix.libgccjit_version }}\n+          name: ${{ matrix.libgccjit_version.gcc }}\n           path: gcc-build\n           repo: antoyo/gcc\n+          branch: ${{ matrix.libgccjit_version.artifacts_branch }}\n+          event: push\n           search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n \n     - name: Setup path to libgccjit\n+      if: matrix.libgccjit_version.gcc == 'libgccjit12.so'\n+      run: echo /usr/lib/gcc/x86_64-linux-gnu/12 > gcc_path\n+\n+    - name: Setup path to libgccjit\n+      if: matrix.libgccjit_version.gcc != 'libgccjit12.so'\n       run: |\n           echo $(readlink -f gcc-build) > gcc_path\n           # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n@@ -48,49 +84,44 @@ jobs:\n     - name: Set RUST_COMPILER_RT_ROOT\n       run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n \n-    # https://github.com/actions/cache/issues/133\n-    - name: Fixup owner of ~/.cargo/\n-      # Don't remove the trailing /. It is necessary to follow the symlink.\n-      run: sudo chown -R $(whoami):$(id -ng) ~/.cargo/\n-\n     - name: Cache cargo installed crates\n-      uses: actions/cache@v1.1.2\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/bin\n         key: cargo-installed-crates2-ubuntu-latest\n \n     - name: Cache cargo registry\n-      uses: actions/cache@v1\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/registry\n         key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo index\n-      uses: actions/cache@v1\n+      uses: actions/cache@v3\n       with:\n         path: ~/.cargo/git\n         key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Cache cargo target dir\n-      uses: actions/cache@v1.1.2\n+      uses: actions/cache@v3\n       with:\n         path: target\n         key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n \n-    - name: Build\n-      if: matrix.libgccjit_version != 'libgccjit12.so'\n-      run: |\n-        ./prepare_build.sh\n-        ./build.sh\n-        cargo test\n-        ./clean_all.sh\n+    #- name: Cache rust repository\n+      ## We only clone the rust repository for rustc tests\n+      #if: ${{ contains(matrix.commands, 'rustc') }}\n+      #uses: actions/cache@v3\n+      #id: cache-rust-repository\n+      #with:\n+        #path: rust\n+        #key: ${{ runner.os }}-packages-${{ hashFiles('rust/.git/HEAD') }}\n \n     - name: Build\n-      if: matrix.libgccjit_version == 'libgccjit12.so'\n       run: |\n         ./prepare_build.sh\n-        ./build.sh --no-default-features\n-        cargo test --no-default-features\n+        ${{ matrix.libgccjit_version.env_extra }} ./build.sh ${{ matrix.libgccjit_version.extra }}\n+        ${{ matrix.libgccjit_version.env_extra }} cargo test ${{ matrix.libgccjit_version.extra }}\n         ./clean_all.sh\n \n     - name: Prepare dependencies\n@@ -106,26 +137,16 @@ jobs:\n         command: build\n         args: --release\n \n-    - name: Test\n-      if: matrix.libgccjit_version != 'libgccjit12.so'\n-      run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n+    - name: Add more failing tests for GCC 12\n+      if: ${{ matrix.libgccjit_version.gcc == 'libgccjit12.so' }}\n+      run: cat failing-ui-tests12.txt >> failing-ui-tests.txt\n \n-        ./test.sh --release\n-\n-    - name: Test\n-      if: matrix.libgccjit_version == 'libgccjit12.so'\n+    - name: Run tests\n       run: |\n-        # Enable backtraces for easier debugging\n-        export RUST_BACKTRACE=1\n-\n-        # Reduce amount of benchmark runs as they are slow\n-        export COMPILE_RUNS=2\n-        export RUN_RUNS=2\n+        ${{ matrix.libgccjit_version.env_extra }} ./test.sh --release --clean --build-sysroot ${{ matrix.commands }} ${{ matrix.libgccjit_version.extra }}\n \n-        ./test.sh --release --no-default-features\n+  duplicates:\n+    runs-on: ubuntu-latest\n+    steps:\n+      - uses: actions/checkout@v3\n+      - run: python tools/check_intrinsics_duplicates.py"}, {"sha": "c4e99469bc20b4fcf27dc2da43507a728d445555", "filename": "compiler/rustc_codegen_gcc/.github/workflows/release.yml", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Frelease.yml", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Frelease.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Frelease.yml?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,111 @@\n+name: CI with sysroot compiled in release mode\n+\n+on:\n+  - push\n+  - pull_request\n+\n+permissions:\n+  contents: read\n+\n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n+jobs:\n+  build:\n+    runs-on: ubuntu-latest\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", artifacts_branch: \"master\" }\n+        commands: [\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+        ]\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - uses: actions/checkout@v3\n+      with:\n+        repository: llvm/llvm-project\n+        path: llvm\n+\n+    - name: Install packages\n+      run: sudo apt-get install ninja-build ripgrep\n+\n+    - name: Download artifact\n+      uses: dawidd6/action-download-artifact@v2\n+      with:\n+          workflow: main.yml\n+          name: ${{ matrix.libgccjit_version.gcc }}\n+          path: gcc-build\n+          repo: antoyo/gcc\n+          branch: ${{ matrix.libgccjit_version.artifacts_branch }}\n+          event: push\n+          search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n+\n+    - name: Setup path to libgccjit\n+      run: |\n+          echo $(readlink -f gcc-build) > gcc_path\n+          # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n+          ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n+\n+    - name: Set env\n+      run: |\n+        echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"workspace=\"$GITHUB_WORKSPACE >> $GITHUB_ENV\n+\n+    - name: Set RUST_COMPILER_RT_ROOT\n+      run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/bin\n+        key: cargo-installed-crates2-ubuntu-latest\n+\n+    - name: Cache cargo registry\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/registry\n+        key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo index\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n+\n+    - name: Build\n+      run: |\n+        ./prepare_build.sh\n+        ./build.sh --release --release-sysroot\n+        cargo test\n+        ./clean_all.sh\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    # Compile is a separate step, as the actions-rs/cargo action supports error annotations\n+    - name: Compile\n+      uses: actions-rs/cargo@v1.0.3\n+      with:\n+        command: build\n+        args: --release\n+\n+    - name: Run tests\n+      run: |\n+        ./test.sh --release --clean --release-sysroot --build-sysroot ${{ matrix.commands }}"}, {"sha": "42fb35e738ffdbe3bfe14baa80287847a4b6531e", "filename": "compiler/rustc_codegen_gcc/.github/workflows/stdarch.yml", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fstdarch.yml", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fstdarch.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2F.github%2Fworkflows%2Fstdarch.yml?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,116 @@\n+name: stdarch tests with sysroot compiled in release mode\n+\n+on:\n+  - push\n+  - pull_request\n+\n+permissions:\n+  contents: read\n+\n+env:\n+  # Enable backtraces for easier debugging\n+  RUST_BACKTRACE: 1\n+\n+jobs:\n+  build:\n+    runs-on: ubuntu-latest\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        libgccjit_version:\n+          - { gcc: \"libgccjit.so\", artifacts_branch: \"master\" }\n+        commands: [\n+          \"--test-successful-rustc --nb-parts 2 --current-part 0\",\n+          \"--test-successful-rustc --nb-parts 2 --current-part 1\",\n+        ]\n+\n+    steps:\n+    - uses: actions/checkout@v3\n+\n+    - uses: actions/checkout@v3\n+      with:\n+        repository: llvm/llvm-project\n+        path: llvm\n+\n+    - name: Install packages\n+      run: sudo apt-get install ninja-build ripgrep\n+\n+    - name: Download artifact\n+      uses: dawidd6/action-download-artifact@v2\n+      with:\n+          workflow: main.yml\n+          name: ${{ matrix.libgccjit_version.gcc }}\n+          path: gcc-build\n+          repo: antoyo/gcc\n+          branch: ${{ matrix.libgccjit_version.artifacts_branch }}\n+          event: push\n+          search_artifacts: true # Because, instead, the action only check the last job ran and that won't work since we want multiple artifacts.\n+\n+    - name: Setup path to libgccjit\n+      run: |\n+          echo $(readlink -f gcc-build) > gcc_path\n+          # NOTE: the filename is still libgccjit.so even when the artifact name is different.\n+          ln gcc-build/libgccjit.so gcc-build/libgccjit.so.0\n+\n+    - name: Set env\n+      run: |\n+        echo \"LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"LD_LIBRARY_PATH=$(cat gcc_path)\" >> $GITHUB_ENV\n+        echo \"workspace=\"$GITHUB_WORKSPACE >> $GITHUB_ENV\n+\n+    - name: Set RUST_COMPILER_RT_ROOT\n+      run: echo \"RUST_COMPILER_RT_ROOT=\"${{ env.workspace }}/llvm/compiler-rt >> $GITHUB_ENV\n+\n+    - name: Cache cargo installed crates\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/bin\n+        key: cargo-installed-crates2-ubuntu-latest\n+\n+    - name: Cache cargo registry\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/registry\n+        key: ${{ runner.os }}-cargo-registry2-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo index\n+      uses: actions/cache@v3\n+      with:\n+        path: ~/.cargo/git\n+        key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}\n+\n+    - name: Cache cargo target dir\n+      uses: actions/cache@v3\n+      with:\n+        path: target\n+        key: ${{ runner.os }}-cargo-build-target-${{ hashFiles('rust-toolchain') }}\n+\n+    - name: Build\n+      run: |\n+        ./prepare_build.sh\n+        ./build.sh --release --release-sysroot\n+        cargo test\n+        ./clean_all.sh\n+\n+    - name: Prepare dependencies\n+      run: |\n+        git config --global user.email \"user@example.com\"\n+        git config --global user.name \"User\"\n+        ./prepare.sh\n+\n+    # Compile is a separate step, as the actions-rs/cargo action supports error annotations\n+    - name: Compile\n+      uses: actions-rs/cargo@v1.0.3\n+      with:\n+        command: build\n+        args: --release\n+\n+    - name: Run tests\n+      run: |\n+        ./test.sh --release --clean --release-sysroot --build-sysroot --mini-tests --std-tests --test-libcore\n+\n+    - name: Run stdarch tests\n+      run: |\n+        cd build_sysroot/sysroot_src/library/stdarch/\n+        CHANNEL=release TARGET=x86_64-unknown-linux-gnu ../../../../cargo.sh test"}, {"sha": "80e574189408828204c725279bb9d37cb3785a0c", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -35,15 +35,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#bdb86fb5092895ff5589726b33250010c64d93f6\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#eefb8c662d61477f34b7c32d26bcda5f1ef08432\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -208,6 +208,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"gccjit\",\n  \"lang_tester\",\n+ \"smallvec\",\n  \"tempfile\",\n ]\n \n@@ -220,6 +221,12 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"smallvec\"\n+version = \"1.10.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a507befe795404456341dfab10cef66ead4c041f62b8b11bbb92bffe5d0953e0\"\n+\n [[package]]\n name = \"tempfile\"\n version = \"3.2.0\""}, {"sha": "81066d9ce1f0acd9686f452d201db46eee17bc77", "filename": "compiler/rustc_codegen_gcc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.toml?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -27,6 +27,8 @@ gccjit = { git = \"https://github.com/antoyo/gccjit.rs\" }\n # Local copy.\n #gccjit = { path = \"../gccjit.rs\" }\n \n+smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n+\n [dev-dependencies]\n lang_tester = \"0.3.9\"\n tempfile = \"3.1.0\""}, {"sha": "bb741943892549aa118f2605ed9f8f2ebe160008", "filename": "compiler/rustc_codegen_gcc/Readme.md", "status": "modified", "additions": 86, "deletions": 6, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FReadme.md?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,5 +1,7 @@\n # WIP libgccjit codegen backend for rust\n \n+[![Chat on IRC](https://img.shields.io/badge/irc.libera.chat-%23rustc__codegen__gcc-blue.svg)](https://web.libera.chat/#rustc_codegen_gcc)\n+\n This is a GCC codegen for rustc, which means it can be loaded by the existing rustc frontend, but benefits from GCC: more architectures are supported and GCC's optimizations are used.\n \n **Despite its name, libgccjit can be used for ahead-of-time compilation, as is used here.**\n@@ -16,21 +18,61 @@ The patches in [this repository](https://github.com/antoyo/libgccjit-patches) ne\n (Those patches should work when applied on master, but in case it doesn't work, they are known to work when applied on 079c23cfe079f203d5df83fea8e92a60c7d7e878.)\n You can also use my [fork of gcc](https://github.com/antoyo/gcc) which already includes these patches.**\n \n+To build it (most of these instructions come from [here](https://gcc.gnu.org/onlinedocs/jit/internals/index.html), so don't hesitate to take a look there if you encounter an issue):\n+\n+```bash\n+$ git clone https://github.com/antoyo/gcc\n+$ sudo apt install flex libmpfr-dev libgmp-dev libmpc3 libmpc-dev\n+$ mkdir gcc-build gcc-install\n+$ cd gcc-build\n+$ ../gcc/configure \\\n+    --enable-host-shared \\\n+    --enable-languages=jit \\\n+    --enable-checking=release \\ # it enables extra checks which allow to find bugs\n+    --disable-bootstrap \\\n+    --disable-multilib \\\n+    --prefix=$(pwd)/../gcc-install\n+$ make -j4 # You can replace `4` with another number depending on how many cores you have.\n+```\n+\n+If you want to run libgccjit tests, you will need to also enable the C++ language in the `configure`:\n+\n+```bash\n+--enable-languages=jit,c++\n+```\n+\n+Then to run libgccjit tests:\n+\n+```bash\n+$ cd gcc # from the `gcc-build` folder\n+$ make check-jit\n+# To run one specific test:\n+$ make check-jit RUNTESTFLAGS=\"-v -v -v jit.exp=jit.dg/test-asm.cc\"\n+```\n+\n **Put the path to your custom build of libgccjit in the file `gcc_path`.**\n \n ```bash\n-$ git clone https://github.com/rust-lang/rustc_codegen_gcc.git\n-$ cd rustc_codegen_gcc\n+$ dirname $(readlink -f `find . -name libgccjit.so`) > gcc_path\n+```\n+\n+You also need to set RUST_COMPILER_RT_ROOT:\n+\n+```bash\n $ git clone https://github.com/llvm/llvm-project llvm --depth 1 --single-branch\n $ export RUST_COMPILER_RT_ROOT=\"$PWD/llvm/compiler-rt\"\n-$ ./prepare_build.sh # download and patch sysroot src\n-$ ./build.sh --release\n ```\n \n-To run the tests:\n+Then you can run commands like this:\n \n ```bash\n $ ./prepare.sh # download and patch sysroot src and install hyperfine for benchmarking\n+$ LIBRARY_PATH=$(cat gcc_path) LD_LIBRARY_PATH=$(cat gcc_path) ./build.sh --release\n+```\n+\n+To run the tests:\n+\n+```bash\n $ ./test.sh --release\n ```\n \n@@ -120,13 +162,52 @@ To print a debug representation of a tree:\n debug_tree(expr);\n ```\n \n+(defined in print-tree.h)\n+\n+To print a debug reprensentation of a gimple struct:\n+\n+```c\n+debug_gimple_stmt(gimple_struct)\n+```\n+\n To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n \n+To have the correct file paths in `gdb` instead of `/usr/src/debug/gcc/libstdc++-v3/libsupc++/eh_personality.cc`:\n+\n+Maybe by calling the following at the beginning of gdb:\n+\n+```\n+set substitute-path /usr/src/debug/gcc /path/to/gcc-repo/gcc\n+```\n+\n+TODO(antoyo): but that's not what I remember I was doing.\n+\n ### How to use a custom-build rustc\n \n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`).\n  * Clean and rebuild the codegen with `debug-current` in the file `rust-toolchain`.\n \n+### How to install a forked git-subtree\n+\n+Using git-subtree with `rustc` requires a patched git to make it work.\n+The PR that is needed is [here](https://github.com/gitgitgadget/git/pull/493).\n+Use the following instructions to install it:\n+\n+```\n+git clone git@github.com:tqc/git.git\n+cd git\n+git checkout tqc/subtree\n+make\n+make install\n+cd contrib/subtree\n+make\n+cp git-subtree ~/bin\n+```\n+\n+### How to use [mem-trace](https://github.com/antoyo/mem-trace)\n+\n+`rustc` needs to be built without `jemalloc` so that `mem-trace` can overload `malloc` since `jemalloc` is linked statically, so a `LD_PRELOAD`-ed library won't a chance to intercept the calls to `malloc`.\n+\n ### How to build a cross-compiling libgccjit\n \n #### Building libgccjit\n@@ -142,6 +223,5 @@ To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo b\n  * Since rustc doesn't support this architecture yet, set it back to `TARGET_TRIPLE=\"mips-unknown-linux-gnu\"` (or another target having the same attributes). Alternatively, create a [target specification file](https://book.avr-rust.com/005.1-the-target-specification-json-file.html) (note that the `arch` specified in this file must be supported by the rust compiler).\n  * Set `linker='-Clinker=m68k-linux-gcc'`.\n  * Set the path to the cross-compiling libgccjit in `gcc_path`.\n- * Disable the 128-bit integer types if the target doesn't support them by using `let i128_type = context.new_type::<i64>();` in `context.rs` (same for u128_type).\n  * Comment the line: `context.add_command_line_option(\"-masm=intel\");` in src/base.rs.\n  * (might not be necessary) Disable the compilation of libstd.so (and possibly libcore.so?)."}, {"sha": "9d692d599f6bef19852222ea918d3d942856f48c", "filename": "compiler/rustc_codegen_gcc/build_sysroot/build_sysroot.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fbuild_sysroot%2Fbuild_sysroot.sh?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -16,7 +16,7 @@ rm Cargo.lock test_target/Cargo.lock 2>/dev/null || true\n rm -r sysroot/ 2>/dev/null || true\n \n # Build libs\n-export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked -Cpanic=abort\"\n+export RUSTFLAGS=\"$RUSTFLAGS -Z force-unstable-if-unmarked\"\n if [[ \"$1\" == \"--release\" ]]; then\n     sysroot_channel='release'\n     RUSTFLAGS=\"$RUSTFLAGS -Zmir-opt-level=3\" cargo build --target $TARGET_TRIPLE --release"}, {"sha": "166e83901c4f956b1d89762126eaa3291a8a936b", "filename": "compiler/rustc_codegen_gcc/config.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fconfig.sh?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -38,7 +38,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Cpanic=abort -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+export RUSTFLAGS=\"$CG_RUSTFLAGS $linker -Csymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot $TEST_FLAGS\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "c80348ca549707570b3da827f1209ce65e673bc8", "filename": "compiler/rustc_codegen_gcc/example/alloc_example.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Falloc_example.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,4 +1,4 @@\n-#![feature(start, box_syntax, core_intrinsics, alloc_error_handler)]\n+#![feature(start, box_syntax, core_intrinsics, alloc_error_handler, lang_items)]\n #![no_std]\n \n extern crate alloc;\n@@ -18,16 +18,22 @@ extern \"C\" {\n \n #[panic_handler]\n fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n-    }\n+    core::intrinsics::abort();\n }\n \n #[alloc_error_handler]\n fn alloc_error_handler(_: alloc::alloc::Layout) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n-    }\n+    core::intrinsics::abort();\n+}\n+\n+#[lang = \"eh_personality\"]\n+fn eh_personality() -> ! {\n+    loop {}\n+}\n+\n+#[no_mangle]\n+unsafe extern \"C\" fn _Unwind_Resume() {\n+    core::intrinsics::unreachable();\n }\n \n #[start]"}, {"sha": "637b8dc53fefd6045253163f4eedde382035def8", "filename": "compiler/rustc_codegen_gcc/example/mini_core.rs", "status": "modified", "additions": 51, "deletions": 17, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,6 +1,6 @@\n #![feature(\n     no_core, lang_items, intrinsics, unboxed_closures, type_ascription, extern_types,\n-    untagged_unions, decl_macro, rustc_attrs, transparent_unions, auto_traits,\n+    decl_macro, rustc_attrs, transparent_unions, auto_traits,\n     thread_local\n )]\n #![no_core]\n@@ -17,6 +17,9 @@ pub trait Sized {}\n #[lang = \"destruct\"]\n pub trait Destruct {}\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -39,14 +42,14 @@ impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut\n impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n // *mut T -> *mut U\n impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n-impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U, ()>> for Box<T, ()> {}\n \n #[lang = \"receiver\"]\n pub trait Receiver {}\n \n impl<T: ?Sized> Receiver for &T {}\n impl<T: ?Sized> Receiver for &mut T {}\n-impl<T: ?Sized> Receiver for Box<T> {}\n+impl<T: ?Sized, A: Allocator> Receiver for Box<T, A> {}\n \n #[lang = \"copy\"]\n pub unsafe trait Copy {}\n@@ -396,7 +399,7 @@ pub struct PhantomData<T: ?Sized>;\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -405,13 +408,21 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n+    unsafe {\n+        libc::puts(\"Panicking\\n\\0\" as *const str as *const u8);\n+        intrinsics::abort();\n+    }\n+}\n+\n+#[lang = \"panic_cannot_unwind\"]\n+fn panic_cannot_unwind() -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\n\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -450,25 +461,40 @@ pub trait Deref {\n pub trait Allocator {\n }\n \n+impl Allocator for () {}\n+\n pub struct Global;\n \n impl Allocator for Global {}\n \n+#[repr(transparent)]\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[rustc_nonnull_optimization_guaranteed]\n+pub struct NonNull<T: ?Sized>(pub *const T);\n+\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> {}\n+\n+pub struct Unique<T: ?Sized> {\n+    pub pointer: NonNull<T>,\n+    pub _marker: PhantomData<T>,\n+}\n+\n+impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> {}\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> {}\n+\n #[lang = \"owned_box\"]\n-pub struct Box<\n-    T: ?Sized,\n-    A: Allocator = Global,\n->(*mut T, A);\n+pub struct Box<T: ?Sized, A: Allocator = Global>(Unique<T>, A);\n \n-impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n+impl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n \n impl<T: ?Sized, A: Allocator> Drop for Box<T, A> {\n     fn drop(&mut self) {\n         // drop is currently performed by compiler.\n     }\n }\n \n-impl<T> Deref for Box<T> {\n+impl<T: ?Sized, A: Allocator> Deref for Box<T, A> {\n     type Target = T;\n \n     fn deref(&self) -> &Self::Target {\n@@ -482,8 +508,8 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n }\n \n #[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: *mut T, alloc: A) {\n-    libc::free(ptr as *mut u8);\n+unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, _alloc: ()) {\n+    libc::free(ptr.pointer.0 as *mut u8);\n }\n \n #[lang = \"drop\"]\n@@ -505,17 +531,25 @@ pub union MaybeUninit<T> {\n }\n \n pub mod intrinsics {\n+    use crate::Sized;\n+\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n+        #[rustc_safe_intrinsic]\n         pub fn size_of<T>() -> usize;\n-        pub fn size_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn size_of_val<T: ?Sized>(val: *const T) -> usize;\n+        #[rustc_safe_intrinsic]\n         pub fn min_align_of<T>() -> usize;\n-        pub fn min_align_of_val<T: ?::Sized>(val: *const T) -> usize;\n+        pub fn min_align_of_val<T: ?Sized>(val: *const T) -> usize;\n         pub fn copy<T>(src: *const T, dst: *mut T, count: usize);\n         pub fn transmute<T, U>(e: T) -> U;\n         pub fn ctlz_nonzero<T>(x: T) -> T;\n-        pub fn needs_drop<T: ?::Sized>() -> bool;\n+        #[rustc_safe_intrinsic]\n+        pub fn needs_drop<T: ?Sized>() -> bool;\n+        #[rustc_safe_intrinsic]\n         pub fn bitreverse<T>(x: T) -> T;\n+        #[rustc_safe_intrinsic]\n         pub fn bswap<T>(x: T) -> T;\n         pub fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n         pub fn unreachable() -> !;"}, {"sha": "993a31e68eabc1ce647b1177da81474a29670ace", "filename": "compiler/rustc_codegen_gcc/example/mini_core_hello_world.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core_hello_world.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -85,6 +85,7 @@ fn start<T: Termination + 'static>(\n     main: fn() -> T,\n     argc: isize,\n     argv: *const *const u8,\n+    _sigpipe: u8,\n ) -> isize {\n     if argc == 3 {\n         unsafe { puts(*argv); }\n@@ -228,6 +229,7 @@ fn main() {\n     } as Box<dyn SomeTrait>;\n \n     const FUNC_REF: Option<fn()> = Some(main);\n+    #[allow(unreachable_code)]\n     match FUNC_REF {\n         Some(_) => {},\n         None => assert!(false),"}, {"sha": "95bcad2cd173edc5eb963ef39b816086436759a3", "filename": "compiler/rustc_codegen_gcc/example/mod_bench.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmod_bench.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -6,9 +6,7 @@ extern {}\n \n #[panic_handler]\n fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n-    }\n+    core::intrinsics::abort();\n }\n \n #[lang=\"eh_personality\"]\n@@ -32,6 +30,6 @@ fn main(_argc: isize, _argv: *const *const u8) -> isize {\n #[inline(never)]\n fn black_box(i: u32) {\n     if i != 1 {\n-        unsafe { core::intrinsics::abort(); }\n+        core::intrinsics::abort();\n     }\n }"}, {"sha": "5c171c49fd1940c8be7d44f6194a33e62dcef3b2", "filename": "compiler/rustc_codegen_gcc/example/std_example.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fstd_example.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,5 +1,6 @@\n #![feature(core_intrinsics, generators, generator_trait, is_sorted)]\n \n+#[cfg(feature=\"master\")]\n use std::arch::x86_64::*;\n use std::io::Write;\n use std::ops::Generator;"}, {"sha": "8539e27ea6a58352f5dc0f77b3b598051b37c05e", "filename": "compiler/rustc_codegen_gcc/failing-ui-tests.txt", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests.txt", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests.txt?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,68 @@\n+tests/ui/allocator/custom-in-block.rs\n+tests/ui/allocator/custom-in-submodule.rs\n+tests/ui/allocator/custom.rs\n+tests/ui/allocator/hygiene.rs\n+tests/ui/allocator/no_std-alloc-error-handler-custom.rs\n+tests/ui/allocator/no_std-alloc-error-handler-default.rs\n+tests/ui/allocator/xcrate-use.rs\n+tests/ui/allocator/xcrate-use2.rs\n+tests/ui/asm/may_unwind.rs\n+tests/ui/asm/x86_64/multiple-clobber-abi.rs\n+tests/ui/debuginfo/debuginfo-emit-llvm-ir-and-split-debuginfo.rs\n+tests/ui/functions-closures/parallel-codegen-closures.rs\n+tests/ui/linkage-attr/linkage1.rs\n+tests/ui/lto/dylib-works.rs\n+tests/ui/numbers-arithmetic/saturating-float-casts.rs\n+tests/ui/polymorphization/promoted-function.rs\n+tests/ui/process/nofile-limit.rs\n+tests/ui/sepcomp/sepcomp-cci.rs\n+tests/ui/sepcomp/sepcomp-extern.rs\n+tests/ui/sepcomp/sepcomp-fns-backwards.rs\n+tests/ui/sepcomp/sepcomp-fns.rs\n+tests/ui/sepcomp/sepcomp-statics.rs\n+tests/ui/simd/intrinsic/generic-arithmetic-pass.rs\n+tests/ui/sse2.rs\n+tests/ui/target-feature/missing-plusminus.rs\n+tests/ui/asm/x86_64/may_unwind.rs\n+tests/ui/backtrace.rs\n+tests/ui/catch-unwind-bang.rs\n+tests/ui/cfg/cfg-panic-abort.rs\n+tests/ui/drop/dynamic-drop-async.rs\n+tests/ui/drop/repeat-drop.rs\n+tests/ui/fmt/format-args-capture.rs\n+tests/ui/generator/panic-drops-resume.rs\n+tests/ui/generator/panic-drops.rs\n+tests/ui/intrinsics/panic-uninitialized-zeroed.rs\n+tests/ui/iterators/iter-sum-overflow-debug.rs\n+tests/ui/iterators/iter-sum-overflow-overflow-checks.rs\n+tests/ui/mir/mir_calls_to_shims.rs\n+tests/ui/mir/mir_drop_order.rs\n+tests/ui/mir/mir_let_chains_drop_order.rs\n+tests/ui/oom_unwind.rs\n+tests/ui/panic-runtime/abort-link-to-unwinding-crates.rs\n+tests/ui/panic-runtime/abort.rs\n+tests/ui/panic-runtime/link-to-abort.rs\n+tests/ui/unwind-no-uwtable.rs\n+tests/ui/parser/unclosed-delimiter-in-dep.rs\n+tests/ui/runtime/rt-explody-panic-payloads.rs\n+tests/ui/simd/intrinsic/ptr-cast.rs\n+tests/ui/binding/fn-arg-incomplete-pattern-drop-order.rs\n+tests/ui/consts/missing_span_in_backtrace.rs\n+tests/ui/drop/dynamic-drop.rs\n+tests/ui/dyn-star/box.rs\n+tests/ui/issues/issue-40883.rs\n+tests/ui/issues/issue-43853.rs\n+tests/ui/issues/issue-47364.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/assert-without-captures-does-not-create-unnecessary-code.rs\n+tests/ui/rfc-2091-track-caller/std-panic-locations.rs\n+tests/ui/rfcs/rfc1857-drop-order.rs\n+tests/ui/simd/issue-17170.rs\n+tests/ui/simd/issue-39720.rs\n+tests/ui/simd/issue-89193.rs\n+tests/ui/statics/issue-91050-1.rs\n+tests/ui/statics/issue-91050-2.rs\n+tests/ui/alloc-error/default-alloc-error-hook.rs\n+tests/ui/generator/panic-safe.rs\n+tests/ui/issues/issue-14875.rs\n+tests/ui/issues/issue-29948.rs\n+tests/ui/panic-while-printing.rs"}, {"sha": "8c27bd8b8ca89f133210fa477dca33946f3e11e0", "filename": "compiler/rustc_codegen_gcc/failing-ui-tests12.txt", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests12.txt", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests12.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ffailing-ui-tests12.txt?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,39 @@\n+tests/ui/asm/x86_64/issue-96797.rs\n+tests/ui/intrinsics/const-eval-select-x86_64.rs\n+tests/ui/packed/packed-struct-drop-aligned.rs\n+tests/ui/packed/packed-struct-generic-layout.rs\n+tests/ui/packed/packed-struct-layout.rs\n+tests/ui/packed/packed-struct-optimized-enum.rs\n+tests/ui/packed/packed-struct-size.rs\n+tests/ui/packed/packed-struct-vec.rs\n+tests/ui/packed/packed-tuple-struct-layout.rs\n+tests/ui/simd/array-type.rs\n+tests/ui/simd/intrinsic/float-minmax-pass.rs\n+tests/ui/simd/intrinsic/generic-arithmetic-saturating-pass.rs\n+tests/ui/simd/intrinsic/generic-as.rs\n+tests/ui/simd/intrinsic/generic-cast-pass.rs\n+tests/ui/simd/intrinsic/generic-cast-pointer-width.rs\n+tests/ui/simd/intrinsic/generic-comparison-pass.rs\n+tests/ui/simd/intrinsic/generic-elements-pass.rs\n+tests/ui/simd/intrinsic/generic-reduction-pass.rs\n+tests/ui/simd/intrinsic/generic-select-pass.rs\n+tests/ui/simd/intrinsic/inlining-issue67557-ice.rs\n+tests/ui/simd/intrinsic/inlining-issue67557.rs\n+tests/ui/simd/monomorphize-shuffle-index.rs\n+tests/ui/simd/shuffle.rs\n+tests/ui/simd/simd-bitmask.rs\n+tests/ui/generator/resume-after-return.rs\n+tests/ui/iterators/iter-step-overflow-debug.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/all-expr-kinds.rs\n+tests/ui/numbers-arithmetic/next-power-of-two-overflow-debug.rs\n+tests/ui/privacy/reachable-unnameable-items.rs\n+tests/ui/rfc-1937-termination-trait/termination-trait-in-test.rs\n+tests/ui/async-await/async-fn-size-moved-locals.rs\n+tests/ui/async-await/async-fn-size-uninit-locals.rs\n+tests/ui/cfg/cfg-panic.rs\n+tests/ui/generator/size-moved-locals.rs\n+tests/ui/macros/rfc-2011-nicer-assert-messages/all-not-available-cases.rs\n+tests/ui/simd/intrinsic/generic-gather-pass.rs\n+tests/ui/simd/issue-85915-simd-ptrs.rs\n+tests/ui/issues/issue-68010-large-zst-consts.rs\n+tests/ui/rust-2018/proc-macro-crate-in-paths.rs"}, {"sha": "0a94a08f8dca86fec574ab0833925d5f9b0df2e0", "filename": "compiler/rustc_codegen_gcc/locales/en-US.ftl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Flocales%2Fen-US.ftl?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -60,3 +60,9 @@ codegen_gcc_invalid_monomorphization_unsupported_cast =\n \n codegen_gcc_invalid_monomorphization_unsupported_operation =\n     invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+\n+codegen_gcc_invalid_minimum_alignment =\n+    invalid minimum global alignment: {$err}\n+\n+codegen_gcc_tied_target_features = the target features {$features} must all be either enabled or disabled together\n+    .help = add the missing features in a `target_feature` attribute"}, {"sha": "93c63b5dcacfda4c14539665d4a004baeb2ae3c3", "filename": "compiler/rustc_codegen_gcc/patches/0001-Add-stdarch-Cargo.toml-for-testing.patch", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Add-stdarch-Cargo.toml-for-testing.patch?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,39 @@\n+From c3821e02fbd6cb5ad6e06d759fccdc9073712375 Mon Sep 17 00:00:00 2001\n+From: Antoni Boucher <bouanto@zoho.com>\n+Date: Tue, 7 Jun 2022 21:40:13 -0400\n+Subject: [PATCH] Add stdarch Cargo.toml for testing\n+\n+---\n+ library/stdarch/Cargo.toml | 20 ++++++++++++++++++++\n+ 1 file changed, 20 insertions(+)\n+ create mode 100644 library/stdarch/Cargo.toml\n+\n+diff --git a/library/stdarch/Cargo.toml b/library/stdarch/Cargo.toml\n+new file mode 100644\n+index 0000000..fbe0a95\n+--- /dev/null\n++++ b/library/stdarch/Cargo.toml\n+@@ -0,0 +1,20 @@\n++[workspace]\n++members = [\n++  \"crates/core_arch\",\n++  \"crates/std_detect\",\n++  \"crates/stdarch-gen\",\n++  \"examples/\"\n++]\n++exclude = [\n++  \"crates/wasm-assert-instr-tests\"\n++]\n++\n++[profile.release]\n++debug = true\n++opt-level = 3\n++incremental = true\n++\n++[profile.bench]\n++debug = 1\n++opt-level = 3\n++incremental = true\n+-- \n+2.26.2.7.g19db9cfb68.dirty\n+"}, {"sha": "1b71df1ca8df2c4ef5eb86cf408c1574f7277d54", "filename": "compiler/rustc_codegen_gcc/patches/0001-Disable-examples.patch", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Disable-examples.patch", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Disable-examples.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0001-Disable-examples.patch?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,25 @@\n+From a2d53a324a02c04b76c0e9d39dc15cd443a3b8b2 Mon Sep 17 00:00:00 2001\n+From: Antoni Boucher <bouanto@zoho.com>\n+Date: Fri, 25 Nov 2022 11:18:11 -0500\n+Subject: [PATCH] Disable examples\n+\n+---\n+ library/stdarch/Cargo.toml | 2 +-\n+ 1 file changed, 1 insertion(+), 1 deletion(-)\n+\n+diff --git a/library/stdarch/Cargo.toml b/library/stdarch/Cargo.toml\n+index fbe0a95..748d72d 100644\n+--- a/library/stdarch/Cargo.toml\n++++ b/library/stdarch/Cargo.toml\n+@@ -3,7 +3,7 @@ members = [\n+   \"crates/core_arch\",\n+   \"crates/std_detect\",\n+   \"crates/stdarch-gen\",\n+-  \"examples/\"\n++  #\"examples/\"\n+ ]\n+ exclude = [\n+   \"crates/wasm-assert-instr-tests\"\n+-- \n+2.26.2.7.g19db9cfb68.dirty\n+"}, {"sha": "4db56fa3bd2c7667f525f8db752ef5c84d75f290", "filename": "compiler/rustc_codegen_gcc/patches/0022-core-Disable-not-compiling-tests.patch", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0022-core-Disable-not-compiling-tests.patch?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -18,7 +18,7 @@ new file mode 100644\n index 0000000..46fd999\n --- /dev/null\n +++ b/library/core/tests/Cargo.toml\n-@@ -0,0 +1,8 @@\n+@@ -0,0 +1,12 @@\n +[package]\n +name = \"core\"\n +version = \"0.0.0\"\n@@ -27,37 +27,18 @@ index 0000000..46fd999\n +[lib]\n +name = \"coretests\"\n +path = \"lib.rs\"\n-diff --git a/library/core/tests/num/flt2dec/mod.rs b/library/core/tests/num/flt2dec/mod.rs\n-index a35897e..f0bf645 100644\n---- a/library/core/tests/num/flt2dec/mod.rs\n-+++ b/library/core/tests/num/flt2dec/mod.rs\n-@@ -13,7 +13,6 @@ mod strategy {\n-     mod dragon;\n-     mod grisu;\n- }\n--mod random;\n- \n- pub fn decode_finite<T: DecodableFloat>(v: T) -> Decoded {\n-     match decode(v).1 {\n-diff --git a/library/core/tests/slice.rs b/library/core/tests/slice.rs\n-index 6609bc3..241b497 100644\n---- a/library/core/tests/slice.rs\n-+++ b/library/core/tests/slice.rs\n-@@ -1209,6 +1209,7 @@ fn brute_force_rotate_test_1() {\n-     }\n- }\n- \n-+/*\n- #[test]\n- #[cfg(not(target_arch = \"wasm32\"))]\n- fn sort_unstable() {\n-@@ -1394,6 +1395,7 @@ fn partition_at_index() {\n-     v.select_nth_unstable(0);\n-     assert!(v == [0xDEADBEEF]);\n- }\n-+*/\n- \n- #[test]\n- #[should_panic(expected = \"index 0 greater than length of slice\")]\n++\n++[dependencies]\n++rand = { version = \"0.8.5\", default-features = false }\n++rand_xorshift = { version = \"0.3.0\", default-features = false }\n+diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n+index 42a26ae..5ac1042 100644\n+--- a/library/core/tests/lib.rs\n++++ b/library/core/tests/lib.rs\n+@@ -1,3 +1,4 @@\n++#![cfg(test)]\n+ #![feature(alloc_layout_extra)]\n+ #![feature(array_chunks)]\n+ #![feature(array_methods)]\n --\n 2.21.0 (Apple Git-122)"}, {"sha": "c59a40df03988aeec2b908ad36e9e4413793533b", "filename": "compiler/rustc_codegen_gcc/patches/0024-core-Disable-portable-simd-test.patch", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fpatches%2F0024-core-Disable-portable-simd-test.patch?ref=e3dfeeaa45f117281b19773d67f3f253de65cee1", "patch": "@@ -1,28 +0,0 @@\n-From b1ae000f6da1abd3b8e9b80c40bc11c89b8ae93c Mon Sep 17 00:00:00 2001\n-From: bjorn3 <bjorn3@users.noreply.github.com>\n-Date: Thu, 30 Dec 2021 16:54:40 +0100\n-Subject: [PATCH] [core] Disable portable-simd test\n-\n----\n- library/core/tests/lib.rs | 1 -\n- 1 file changed, 1 deletion(-)\n-\n-diff --git a/library/core/tests/lib.rs b/library/core/tests/lib.rs\n-index 06c7be0..359e2e7 100644\n---- a/library/core/tests/lib.rs\n-+++ b/library/core/tests/lib.rs\n-@@ -75,7 +75,6 @@\n- #![feature(never_type)]\n- #![feature(unwrap_infallible)]\n--#![feature(portable_simd)]\n- #![feature(ptr_metadata)]\n- #![feature(once_cell)]\n- #![feature(option_result_contains)]\n-@@ -127,7 +126,6 @@ mod pin;\n- mod pin_macro;\n- mod ptr;\n- mod result;\n--mod simd;\n- mod slice;\n- mod str;\n- mod str_lossy;"}, {"sha": "933ecd45baadb63632cbd08ba7431e1a9e6ef077", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-06-06\"\n+channel = \"nightly-2023-03-02\"\n components = [\"rust-src\", \"rustc-dev\", \"llvm-tools-preview\"]"}, {"sha": "59143eac37b3f03a23ec3d7538b2a34feec9823c", "filename": "compiler/rustc_codegen_gcc/rustc_patches/compile_test.patch", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch", "raw_url": "https://github.com/rust-lang/rust/raw/e3dfeeaa45f117281b19773d67f3f253de65cee1/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frustc_patches%2Fcompile_test.patch?ref=e3dfeeaa45f117281b19773d67f3f253de65cee1", "patch": "@@ -1,14 +0,0 @@\n-diff --git a/src/tools/compiletest/src/header.rs b/src/tools/compiletest/src/header.rs\n-index 887d27fd6dca4..2c2239f2b83d1 100644\n---- a/src/tools/compiletest/src/header.rs\n-+++ b/src/tools/compiletest/src/header.rs\n-@@ -806,8 +806,8 @@ pub fn make_test_description<R: Read>(\n-     cfg: Option<&str>,\n- ) -> test::TestDesc {\n-     let mut ignore = false;\n-     #[cfg(not(bootstrap))]\n--    let ignore_message: Option<String> = None;\n-+    let ignore_message: Option<&str> = None;\n-     let mut should_fail = false;\n-\n-     let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();"}, {"sha": "4bad33ee879ee4f1c27ba1c2e1352f98c483d9e1", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,3 +1,5 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::FnAttribute;\n use gccjit::{FunctionType, GlobalKind, ToRValue};\n use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n use rustc_middle::bug;\n@@ -50,7 +52,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n \n         if tcx.sess.target.options.default_hidden_visibility {\n-            // TODO(antoyo): set visibility.\n+            #[cfg(feature=\"master\")]\n+            func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n         }\n         if tcx.sess.must_emit_unwind_tables() {\n             // TODO(antoyo): emit unwind tables.\n@@ -61,7 +64,8 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n             .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n             .collect();\n         let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n-        // TODO(antoyo): set visibility.\n+        #[cfg(feature=\"master\")]\n+        callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n         let block = func.new_block(\"entry\");\n \n@@ -90,12 +94,18 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         .collect();\n     let func = context.new_function(None, FunctionType::Exported, void, &args, name, false);\n \n+    if tcx.sess.target.default_hidden_visibility {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+    }\n+\n     let callee = alloc_error_handler_kind.fn_name(sym::oom);\n     let args: Vec<_> = types.iter().enumerate()\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();\n     let callee = context.new_function(None, FunctionType::Extern, void, &args, callee, false);\n-    //llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+    #[cfg(feature=\"master\")]\n+    callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n \n     let block = func.new_block(\"entry\");\n "}, {"sha": "41e9d61a10e50b53dd5b280cc7c1a1e236d163a8", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 125, "deletions": 86, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -157,7 +157,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     use ConstraintOrRegister::*;\n \n                     let (constraint, ty) = match (reg_to_gcc(reg), place) {\n-                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx, false)),\n+                        (Constraint(constraint), Some(place)) => (constraint, place.layout.gcc_type(self.cx)),\n                         // When `reg` is a class and not an explicit register but the out place is not specified,\n                         // we need to create an unused output variable to assign the output to. This var\n                         // needs to be of a type that's \"compatible\" with the register class, but specific type\n@@ -226,7 +226,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     // This decision is also backed by the fact that LLVM needs in and out\n                     // values to be of *exactly the same type*, not just \"compatible\".\n                     // I'm not sure if GCC is so picky too, but better safe than sorry.\n-                    let ty = in_value.layout.gcc_type(self.cx, false);\n+                    let ty = in_value.layout.gcc_type(self.cx);\n                     let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n \n                     // If the out_place is None (i.e `inout(reg) _` syntax was used), we translate\n@@ -286,7 +286,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                             continue\n                         };\n \n-                        let ty = out_place.layout.gcc_type(self.cx, false);\n+                        let ty = out_place.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n@@ -306,7 +306,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 // `in(\"explicit register\") var`\n                 InlineAsmOperandRef::In { reg, value } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n-                        let ty = value.layout.gcc_type(self.cx, false);\n+                        let ty = value.layout.gcc_type(self.cx);\n                         let reg_var = self.current_func().new_local(None, ty, \"input_register\");\n                         reg_var.set_register_name(reg_name);\n                         self.llbb().add_assignment(None, reg_var, value.immediate());\n@@ -325,7 +325,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n                     if let ConstraintOrRegister::Register(reg_name) = reg_to_gcc(reg) {\n                         // See explanation in the first pass.\n-                        let ty = in_value.layout.gcc_type(self.cx, false);\n+                        let ty = in_value.layout.gcc_type(self.cx);\n                         let tmp_var = self.current_func().new_local(None, ty, \"output_register\");\n                         tmp_var.set_register_name(reg_name);\n \n@@ -353,8 +353,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     inputs.push(AsmInOperand {\n                         constraint: \"X\".into(),\n                         rust_idx,\n-                        val: self.cx.rvalue_as_function(get_fn(self.cx, instance))\n-                            .get_address(None),\n+                        val: get_fn(self.cx, instance).get_address(None),\n                     });\n                 }\n \n@@ -382,15 +381,19 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         for piece in template {\n             match *piece {\n                 InlineAsmTemplatePiece::String(ref string) => {\n-                    // TODO(@Commeownist): switch to `Iterator::intersperse` once it's stable\n-                    let mut iter = string.split('%');\n-                    if let Some(s) = iter.next() {\n-                        template_str.push_str(s);\n-                    }\n-\n-                    for s in iter {\n-                        template_str.push_str(\"%%\");\n-                        template_str.push_str(s);\n+                    for char in string.chars() {\n+                        // TODO(antoyo): might also need to escape | if rustc doesn't do it.\n+                        let escaped_char =\n+                            match char {\n+                                '%' => \"%%\",\n+                                '{' => \"%{\",\n+                                '}' => \"%}\",\n+                                _ => {\n+                                    template_str.push(char);\n+                                    continue;\n+                                },\n+                            };\n+                        template_str.push_str(escaped_char);\n                     }\n                 }\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n@@ -565,56 +568,71 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n                 _ => unimplemented!(),\n             }\n         },\n+        // They can be retrieved from https://gcc.gnu.org/onlinedocs/gcc/Machine-Constraints.html\n         InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => unimplemented!(),\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => unimplemented!(),\n-            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => unimplemented!(),\n-            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => unimplemented!(),\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => \"w\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => \"x\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => {\n+                unreachable!(\"clobber-only\")\n+            }\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n-            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8) => unimplemented!(),\n-            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8)\n-            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => unimplemented!(),\n-            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n-            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => unimplemented!(),\n-            InlineAsmRegClass::Avr(_) => unimplemented!(),\n-            InlineAsmRegClass::Bpf(_) => unimplemented!(),\n-            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => unimplemented!(),\n-            InlineAsmRegClass::Msp430(_) => unimplemented!(),\n-            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => unimplemented!(),\n-            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => unimplemented!(),\n-            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => unimplemented!(),\n-            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => unimplemented!(),\n-            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => unimplemented!(),\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"t\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_upper) => \"d\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_pair) => \"r\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_iw) => \"w\",\n+            InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => \"e\",\n+            InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Bpf(BpfInlineAsmRegClass::wreg) => \"w\",\n+            InlineAsmRegClass::Hexagon(HexagonInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::reg) => \"d\", // more specific than \"r\"\n+            InlineAsmRegClass::Mips(MipsInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::Msp430(Msp430InlineAsmRegClass::reg) => \"r\",\n+            // https://github.com/gcc-mirror/gcc/blob/master/gcc/config/nvptx/nvptx.md -> look for\n+            // \"define_constraint\".\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n+\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::reg_nonzero) => \"b\",\n+            InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::cr)\n             | InlineAsmRegClass::PowerPC(PowerPCInlineAsmRegClass::xer) => {\n                 unreachable!(\"clobber-only\")\n             },\n-            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n-            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => {\n+                unreachable!(\"clobber-only\")\n+            }\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_byte) => \"q\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n             | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"Yk\",\n-            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => unimplemented!(),\n-            InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n             InlineAsmRegClass::X86(\n-                X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg | X86InlineAsmRegClass::tmm_reg,\n+                X86InlineAsmRegClass::kreg0\n+                | X86InlineAsmRegClass::x87_reg\n+                | X86InlineAsmRegClass::mmx_reg\n+                | X86InlineAsmRegClass::tmm_reg,\n             ) => unreachable!(\"clobber-only\"),\n             InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n                 bug!(\"GCC backend does not support SPIR-V\")\n             }\n-            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n-            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n+            InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => \"r\",\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::Err => unreachable!(),\n         }\n     };\n@@ -692,21 +710,23 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             && options.contains(InlineAsmOptions::ATT_SYNTAX);\n \n         // Build the template string\n-        let mut template_str = String::new();\n+        let mut template_str = \".pushsection .text\\n\".to_owned();\n+        if att_dialect {\n+            template_str.push_str(\".att_syntax\\n\");\n+        }\n         for piece in template {\n             match *piece {\n                 InlineAsmTemplatePiece::String(ref string) => {\n-                    for line in string.lines() {\n+                    let mut index = 0;\n+                    while index < string.len() {\n                         // NOTE: gcc does not allow inline comment, so remove them.\n-                        let line =\n-                            if let Some(index) = line.rfind(\"//\") {\n-                                &line[..index]\n-                            }\n-                            else {\n-                                line\n-                            };\n-                        template_str.push_str(line);\n-                        template_str.push('\\n');\n+                        let comment_index = string[index..].find(\"//\")\n+                            .map(|comment_index| comment_index + index)\n+                            .unwrap_or(string.len());\n+                        template_str.push_str(&string[index..comment_index]);\n+                        index = string[comment_index..].find('\\n')\n+                            .map(|index| index + comment_index)\n+                            .unwrap_or(string.len());\n                     }\n                 },\n                 InlineAsmTemplatePiece::Placeholder { operand_idx, modifier: _, span: _ } => {\n@@ -719,6 +739,8 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         }\n \n                         GlobalAsmOperandRef::SymFn { instance } => {\n+                            let function = get_fn(self, instance);\n+                            self.add_used_function(function);\n                             // TODO(@Amanieu): Additional mangling is needed on\n                             // some targets to add a leading underscore (Mach-O)\n                             // or byte count suffixes (x86 Windows).\n@@ -727,6 +749,7 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         }\n \n                         GlobalAsmOperandRef::SymStatic { def_id } => {\n+                            // TODO(antoyo): set the global variable as used.\n                             // TODO(@Amanieu): Additional mangling is needed on\n                             // some targets to add a leading underscore (Mach-O).\n                             let instance = Instance::mono(self.tcx, def_id);\n@@ -738,48 +761,51 @@ impl<'gcc, 'tcx> AsmMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             }\n         }\n \n-        let template_str =\n-            if att_dialect {\n-                format!(\".att_syntax\\n\\t{}\\n\\t.intel_syntax noprefix\", template_str)\n-            }\n-            else {\n-                template_str\n-            };\n+        if att_dialect {\n+            template_str.push_str(\"\\n\\t.intel_syntax noprefix\");\n+        }\n         // NOTE: seems like gcc will put the asm in the wrong section, so set it to .text manually.\n-        let template_str = format!(\".pushsection .text\\n{}\\n.popsection\", template_str);\n+        template_str.push_str(\"\\n.popsection\");\n         self.context.add_top_level_asm(None, &template_str);\n     }\n }\n \n fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option<char>) -> Option<char> {\n+    // The modifiers can be retrieved from\n+    // https://gcc.gnu.org/onlinedocs/gcc/Modifiers.html#Modifiers\n     match reg {\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => modifier,\n-        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => modifier,\n         InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n         | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n-            unimplemented!()\n+            if modifier == Some('v') { None } else { modifier }\n+        }\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::preg) => {\n+            unreachable!(\"clobber-only\")\n         }\n-        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)  => unimplemented!(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => None,\n         InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n-        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => unimplemented!(),\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => None,\n         InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n-        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => unimplemented!(),\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => Some('P'),\n         InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n-            unimplemented!()\n+            if modifier.is_none() {\n+                Some('q')\n+            } else {\n+                modifier\n+            }\n         }\n-        InlineAsmRegClass::Avr(_) => unimplemented!(),\n-        InlineAsmRegClass::Bpf(_) => unimplemented!(),\n-        InlineAsmRegClass::Hexagon(_) => unimplemented!(),\n-        InlineAsmRegClass::Mips(_) => unimplemented!(),\n-        InlineAsmRegClass::Msp430(_) => unimplemented!(),\n-        InlineAsmRegClass::Nvptx(_) => unimplemented!(),\n-        InlineAsmRegClass::PowerPC(_) => unimplemented!(),\n+        InlineAsmRegClass::Hexagon(_) => None,\n+        InlineAsmRegClass::Mips(_) => None,\n+        InlineAsmRegClass::Nvptx(_) => None,\n+        InlineAsmRegClass::PowerPC(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n-        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => unimplemented!(),\n-        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => unimplemented!(),\n+        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::vreg) => {\n+            unreachable!(\"clobber-only\")\n+        }\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n         | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => match modifier {\n             None => if arch == InlineAsmArch::X86_64 { Some('q') } else { Some('k') },\n@@ -803,16 +829,29 @@ fn modifier_to_gcc(arch: InlineAsmArch, reg: InlineAsmRegClass, modifier: Option\n             _ => unreachable!(),\n         },\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg0) => None,\n-        InlineAsmRegClass::X86(X86InlineAsmRegClass::x87_reg | X86InlineAsmRegClass::mmx_reg | X86InlineAsmRegClass::tmm_reg) => {\n+        InlineAsmRegClass::X86(\n+            X86InlineAsmRegClass::x87_reg\n+            | X86InlineAsmRegClass::mmx_reg\n+            | X86InlineAsmRegClass::kreg0\n+            | X86InlineAsmRegClass::tmm_reg,\n+        ) => {\n             unreachable!(\"clobber-only\")\n         }\n-        InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => unimplemented!(),\n+        InlineAsmRegClass::Wasm(WasmInlineAsmRegClass::local) => None,\n+        InlineAsmRegClass::Bpf(_) => None,\n+        InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_pair)\n+        | InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_iw)\n+        | InlineAsmRegClass::Avr(AvrInlineAsmRegClass::reg_ptr) => match modifier {\n+            Some('h') => Some('B'),\n+            Some('l') => Some('A'),\n+            _ => None,\n+        },\n+        InlineAsmRegClass::Avr(_) => None,\n+        InlineAsmRegClass::S390x(_) => None,\n+        InlineAsmRegClass::Msp430(_) => None,\n         InlineAsmRegClass::SpirV(SpirVInlineAsmRegClass::reg) => {\n             bug!(\"LLVM backend does not support SPIR-V\")\n-        },\n-        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::reg) => unimplemented!(),\n-        InlineAsmRegClass::S390x(S390xInlineAsmRegClass::freg) => unimplemented!(),\n+        }\n         InlineAsmRegClass::Err => unreachable!(),\n     }\n }"}, {"sha": "db841b1b52408ab51d986b042f77ff74046df018", "filename": "compiler/rustc_codegen_gcc/src/attributes.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fattributes.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,113 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::FnAttribute;\n+use gccjit::Function;\n+use rustc_attr::InstructionSetAttr;\n+use rustc_codegen_ssa::target_features::tied_target_features;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty;\n+use rustc_session::Session;\n+use rustc_span::symbol::sym;\n+use smallvec::{smallvec, SmallVec};\n+\n+use crate::{context::CodegenCx, errors::TiedTargetFeatures};\n+\n+// Given a map from target_features to whether they are enabled or disabled,\n+// ensure only valid combinations are allowed.\n+pub fn check_tied_features(sess: &Session, features: &FxHashMap<&str, bool>) -> Option<&'static [&'static str]> {\n+    for tied in tied_target_features(sess) {\n+        // Tied features must be set to the same value, or not set at all\n+        let mut tied_iter = tied.iter();\n+        let enabled = features.get(tied_iter.next().unwrap());\n+        if tied_iter.any(|feature| enabled != features.get(feature)) {\n+            return Some(tied);\n+        }\n+    }\n+    None\n+}\n+\n+// TODO(antoyo): maybe move to a new module gcc_util.\n+// To find a list of GCC's names, check https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\n+fn to_gcc_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]> {\n+    let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n+    match (arch, s) {\n+        (\"x86\", \"sse4.2\") => smallvec![\"sse4.2\", \"crc32\"],\n+        (\"x86\", \"pclmulqdq\") => smallvec![\"pclmul\"],\n+        (\"x86\", \"rdrand\") => smallvec![\"rdrnd\"],\n+        (\"x86\", \"bmi1\") => smallvec![\"bmi\"],\n+        (\"x86\", \"cmpxchg16b\") => smallvec![\"cx16\"],\n+        (\"x86\", \"avx512vaes\") => smallvec![\"vaes\"],\n+        (\"x86\", \"avx512gfni\") => smallvec![\"gfni\"],\n+        (\"x86\", \"avx512vpclmulqdq\") => smallvec![\"vpclmulqdq\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512vbmi2'.\n+        (\"x86\", \"avx512vbmi2\") => smallvec![\"avx512vbmi2\", \"avx512bw\"],\n+        // NOTE: seems like GCC requires 'avx512bw' for 'avx512bitalg'.\n+        (\"x86\", \"avx512bitalg\") => smallvec![\"avx512bitalg\", \"avx512bw\"],\n+        (\"aarch64\", \"rcpc2\") => smallvec![\"rcpc-immo\"],\n+        (\"aarch64\", \"dpb\") => smallvec![\"ccpp\"],\n+        (\"aarch64\", \"dpb2\") => smallvec![\"ccdp\"],\n+        (\"aarch64\", \"frintts\") => smallvec![\"fptoint\"],\n+        (\"aarch64\", \"fcma\") => smallvec![\"complxnum\"],\n+        (\"aarch64\", \"pmuv3\") => smallvec![\"perfmon\"],\n+        (\"aarch64\", \"paca\") => smallvec![\"pauth\"],\n+        (\"aarch64\", \"pacg\") => smallvec![\"pauth\"],\n+        // Rust ties fp and neon together. In LLVM neon implicitly enables fp,\n+        // but we manually enable neon when a feature only implicitly enables fp\n+        (\"aarch64\", \"f32mm\") => smallvec![\"f32mm\", \"neon\"],\n+        (\"aarch64\", \"f64mm\") => smallvec![\"f64mm\", \"neon\"],\n+        (\"aarch64\", \"fhm\") => smallvec![\"fp16fml\", \"neon\"],\n+        (\"aarch64\", \"fp16\") => smallvec![\"fullfp16\", \"neon\"],\n+        (\"aarch64\", \"jsconv\") => smallvec![\"jsconv\", \"neon\"],\n+        (\"aarch64\", \"sve\") => smallvec![\"sve\", \"neon\"],\n+        (\"aarch64\", \"sve2\") => smallvec![\"sve2\", \"neon\"],\n+        (\"aarch64\", \"sve2-aes\") => smallvec![\"sve2-aes\", \"neon\"],\n+        (\"aarch64\", \"sve2-sm4\") => smallvec![\"sve2-sm4\", \"neon\"],\n+        (\"aarch64\", \"sve2-sha3\") => smallvec![\"sve2-sha3\", \"neon\"],\n+        (\"aarch64\", \"sve2-bitperm\") => smallvec![\"sve2-bitperm\", \"neon\"],\n+        (_, s) => smallvec![s],\n+    }\n+}\n+\n+/// Composite function which sets GCC attributes for function depending on its AST (`#[attribute]`)\n+/// attributes.\n+pub fn from_fn_attrs<'gcc, 'tcx>(\n+    cx: &CodegenCx<'gcc, 'tcx>,\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    func: Function<'gcc>,\n+    instance: ty::Instance<'tcx>,\n+) {\n+    let codegen_fn_attrs = cx.tcx.codegen_fn_attrs(instance.def_id());\n+\n+    let function_features =\n+        codegen_fn_attrs.target_features.iter().map(|features| features.as_str()).collect::<Vec<&str>>();\n+\n+    if let Some(features) = check_tied_features(cx.tcx.sess, &function_features.iter().map(|features| (*features, true)).collect()) {\n+        let span = cx.tcx\n+            .get_attr(instance.def_id(), sym::target_feature)\n+            .map_or_else(|| cx.tcx.def_span(instance.def_id()), |a| a.span);\n+        cx.tcx.sess.create_err(TiedTargetFeatures {\n+            features: features.join(\", \"),\n+            span,\n+        })\n+            .emit();\n+        return;\n+    }\n+\n+    let mut function_features = function_features\n+        .iter()\n+        .flat_map(|feat| to_gcc_features(cx.tcx.sess, feat).into_iter())\n+        .chain(codegen_fn_attrs.instruction_set.iter().map(|x| match x {\n+            InstructionSetAttr::ArmA32 => \"-thumb-mode\", // TODO(antoyo): support removing feature.\n+            InstructionSetAttr::ArmT32 => \"thumb-mode\",\n+        }))\n+        .collect::<Vec<_>>();\n+\n+    // TODO(antoyo): check if we really need global backend features. (Maybe they could be applied\n+    // globally?)\n+    let mut global_features = cx.tcx.global_backend_features(()).iter().map(|s| s.as_str());\n+    function_features.extend(&mut global_features);\n+    let target_features = function_features.join(\",\");\n+    if !target_features.is_empty() {\n+        #[cfg(feature=\"master\")]\n+        func.add_attribute(FnAttribute::Target(&target_features));\n+    }\n+}"}, {"sha": "5f54ac4ebc69a63c5e372f3b23f73e0587f04901", "filename": "compiler/rustc_codegen_gcc/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fback%2Fwrite.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -57,6 +57,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                 if env::var(\"CG_GCCJIT_DUMP_TO_FILE\").as_deref() == Ok(\"1\") {\n                     let _ = fs::create_dir(\"/tmp/gccjit_dumps\");\n                     let path = &format!(\"/tmp/gccjit_dumps/{}.c\", module.name);\n+                    context.set_debug_info(true);\n                     context.dump_to_file(path, true);\n                 }\n                 context.compile_to_file(OutputKind::ObjectFile, obj_out.to_str().expect(\"path to str\"));"}, {"sha": "dcd560b3dcd952efe7d81228ac4403d1f8b748ab", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -8,6 +8,8 @@ use gccjit::{\n };\n use rustc_middle::dep_graph;\n use rustc_middle::ty::TyCtxt;\n+#[cfg(feature=\"master\")]\n+use rustc_middle::mir::mono::Visibility;\n use rustc_middle::mir::mono::Linkage;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n use rustc_codegen_ssa::base::maybe_create_entry_wrapper;\n@@ -20,6 +22,15 @@ use crate::GccContext;\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n \n+#[cfg(feature=\"master\")]\n+pub fn visibility_to_gcc(linkage: Visibility) -> gccjit::Visibility {\n+    match linkage {\n+        Visibility::Default => gccjit::Visibility::Default,\n+        Visibility::Hidden => gccjit::Visibility::Hidden,\n+        Visibility::Protected => gccjit::Visibility::Protected,\n+    }\n+}\n+\n pub fn global_linkage_to_gcc(linkage: Linkage) -> GlobalKind {\n     match linkage {\n         Linkage::External => GlobalKind::Imported,\n@@ -76,16 +87,34 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_i\n         // Instantiate monomorphizations without filling out definitions yet...\n         //let llvm_module = ModuleLlvm::new(tcx, &cgu_name.as_str());\n         let context = Context::default();\n+\n+        context.add_command_line_option(\"-fexceptions\");\n+        context.add_driver_option(\"-fexceptions\");\n+\n         // TODO(antoyo): only set on x86 platforms.\n         context.add_command_line_option(\"-masm=intel\");\n         // TODO(antoyo): only add the following cli argument if the feature is supported.\n         context.add_command_line_option(\"-msse2\");\n         context.add_command_line_option(\"-mavx2\");\n-        context.add_command_line_option(\"-msha\");\n-        context.add_command_line_option(\"-mpclmul\");\n         // FIXME(antoyo): the following causes an illegal instruction on vmovdqu64 in std_example on my CPU.\n         // Only add if the CPU supports it.\n-        //context.add_command_line_option(\"-mavx512f\");\n+        context.add_command_line_option(\"-msha\");\n+        context.add_command_line_option(\"-mpclmul\");\n+        context.add_command_line_option(\"-mfma\");\n+        context.add_command_line_option(\"-mfma4\");\n+        context.add_command_line_option(\"-m64\");\n+        context.add_command_line_option(\"-mbmi\");\n+        context.add_command_line_option(\"-mgfni\");\n+        //context.add_command_line_option(\"-mavxvnni\"); // The CI doesn't support this option.\n+        context.add_command_line_option(\"-mf16c\");\n+        context.add_command_line_option(\"-maes\");\n+        context.add_command_line_option(\"-mxsavec\");\n+        context.add_command_line_option(\"-mbmi2\");\n+        context.add_command_line_option(\"-mrtm\");\n+        context.add_command_line_option(\"-mvaes\");\n+        context.add_command_line_option(\"-mvpclmulqdq\");\n+        context.add_command_line_option(\"-mavx\");\n+\n         for arg in &tcx.sess.opts.cg.llvm_args {\n             context.add_command_line_option(arg);\n         }\n@@ -95,12 +124,20 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_i\n         context.add_command_line_option(\"-fno-semantic-interposition\");\n         // NOTE: Rust relies on LLVM not doing TBAA (https://github.com/rust-lang/unsafe-code-guidelines/issues/292).\n         context.add_command_line_option(\"-fno-strict-aliasing\");\n+        // NOTE: Rust relies on LLVM doing wrapping on overflow.\n+        context.add_command_line_option(\"-fwrapv\");\n \n         if tcx.sess.opts.unstable_opts.function_sections.unwrap_or(tcx.sess.target.function_sections) {\n             context.add_command_line_option(\"-ffunction-sections\");\n             context.add_command_line_option(\"-fdata-sections\");\n         }\n \n+        if env::var(\"CG_GCCJIT_DUMP_RTL\").as_deref() == Ok(\"1\") {\n+            context.add_command_line_option(\"-fdump-rtl-vregs\");\n+        }\n+        if env::var(\"CG_GCCJIT_DUMP_TREE_ALL\").as_deref() == Ok(\"1\") {\n+            context.add_command_line_option(\"-fdump-tree-all\");\n+        }\n         if env::var(\"CG_GCCJIT_DUMP_CODE\").as_deref() == Ok(\"1\") {\n             context.set_dump_code_on_compile(true);\n         }\n@@ -115,7 +152,7 @@ pub fn compile_codegen_unit(tcx: TyCtxt<'_>, cgu_name: Symbol, supports_128bit_i\n             context.set_keep_intermediates(true);\n         }\n \n-        // TODO(bjorn3): Remove once unwinding is properly implemented\n+        // NOTE: The codegen generates unrechable blocks.\n         context.set_allow_unreachable_blocks(true);\n \n         {"}, {"sha": "a3c8142bea2db08c0f669a9112e1878bc723d81b", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 332, "deletions": 81, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let actual_ty = actual_val.get_type();\n                 if expected_ty != actual_ty {\n-                    if !actual_ty.is_vector() && !expected_ty.is_vector() && actual_ty.is_integral() && expected_ty.is_integral() && actual_ty.get_size() != expected_ty.get_size() {\n+                    if !actual_ty.is_vector() && !expected_ty.is_vector() && (actual_ty.is_integral() && expected_ty.is_integral()) || (actual_ty.get_pointee().is_some() && expected_ty.get_pointee().is_some()) {\n                         self.context.new_cast(None, actual_val, expected_ty)\n                     }\n                     else if on_stack_param_indices.contains(&index) {\n@@ -226,6 +226,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                     else {\n                         assert!(!((actual_ty.is_vector() && !expected_ty.is_vector()) || (!actual_ty.is_vector() && expected_ty.is_vector())), \"{:?} ({}) -> {:?} ({}), index: {:?}[{}]\", actual_ty, actual_ty.is_vector(), expected_ty, expected_ty.is_vector(), func_ptr, index);\n                         // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n+                        // TODO: remove bitcast now that vector types can be compared?\n                         self.bitcast(actual_val, expected_ty)\n                     }\n                 }\n@@ -279,21 +280,30 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn function_ptr_call(&mut self, func_ptr: RValue<'gcc>, args: &[RValue<'gcc>], _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let args = self.check_ptr_call(\"call\", func_ptr, args);\n+        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n+        let func_name = format!(\"{:?}\", func_ptr);\n+        let previous_arg_count = args.len();\n+        let orig_args = args;\n+        let args = {\n+            let function_address_names = self.function_address_names.borrow();\n+            let original_function_name = function_address_names.get(&func_ptr);\n+            llvm::adjust_intrinsic_arguments(&self, gcc_func, args.into(), &func_name, original_function_name)\n+        };\n+        let args_adjusted = args.len() != previous_arg_count;\n+        let args = self.check_ptr_call(\"call\", func_ptr, &*args);\n \n         // gccjit requires to use the result of functions, even when it's not used.\n         // That's why we assign the result to a local or call add_eval().\n-        let gcc_func = func_ptr.get_type().dyncast_function_ptr_type().expect(\"function ptr\");\n         let return_type = gcc_func.get_return_type();\n         let void_type = self.context.new_type::<()>();\n         let current_func = self.block.get_function();\n \n         if return_type != void_type {\n             unsafe { RETURN_VALUE_COUNT += 1 };\n-            let result = current_func.new_local(None, return_type, &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n-            let func_name = format!(\"{:?}\", func_ptr);\n-            let args = llvm::adjust_intrinsic_arguments(&self, gcc_func, args, &func_name);\n-            self.block.add_assignment(None, result, self.cx.context.new_call_through_ptr(None, func_ptr, &args));\n+            let return_value = self.cx.context.new_call_through_ptr(None, func_ptr, &args);\n+            let return_value = llvm::adjust_intrinsic_return_value(&self, return_value, &func_name, &args, args_adjusted, orig_args);\n+            let result = current_func.new_local(None, return_value.get_type(), &format!(\"ptrReturnValue{}\", unsafe { RETURN_VALUE_COUNT }));\n+            self.block.add_assignment(None, result, return_value);\n             result.to_rvalue()\n         }\n         else {\n@@ -366,10 +376,10 @@ impl<'tcx> FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-impl<'gcc, 'tcx> Deref for Builder<'_, 'gcc, 'tcx> {\n+impl<'a, 'gcc, 'tcx> Deref for Builder<'a, 'gcc, 'tcx> {\n     type Target = CodegenCx<'gcc, 'tcx>;\n \n-    fn deref(&self) -> &Self::Target {\n+    fn deref<'b>(&'b self) -> &'a Self::Target {\n         self.cx\n     }\n }\n@@ -387,7 +397,7 @@ impl<'gcc, 'tcx> BackendTypes for Builder<'_, 'gcc, 'tcx> {\n }\n \n impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n-    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Self {\n+    fn build(cx: &'a CodegenCx<'gcc, 'tcx>, block: Block<'gcc>) -> Builder<'a, 'gcc, 'tcx> {\n         Builder::with_cx(cx, block)\n     }\n \n@@ -444,17 +454,36 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         self.block.end_with_switch(None, value, default_block, &gcc_cases);\n     }\n \n-    fn invoke(\n-        &mut self,\n-        typ: Type<'gcc>,\n-        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n-        func: RValue<'gcc>,\n-        args: &[RValue<'gcc>],\n-        then: Block<'gcc>,\n-        catch: Block<'gcc>,\n-        _funclet: Option<&Funclet>,\n-    ) -> RValue<'gcc> {\n-        // TODO(bjorn3): Properly implement unwinding.\n+    #[cfg(feature=\"master\")]\n+    fn invoke(&mut self, typ: Type<'gcc>, _fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let try_block = self.current_func().new_block(\"try\");\n+\n+        let current_block = self.block.clone();\n+        self.block = try_block;\n+        let call = self.call(typ, None, func, args, None); // TODO(antoyo): use funclet here?\n+        self.block = current_block;\n+\n+        let return_value = self.current_func()\n+            .new_local(None, call.get_type(), \"invokeResult\");\n+\n+        try_block.add_assignment(None, return_value, call);\n+\n+        try_block.end_with_jump(None, then);\n+\n+        if self.cleanup_blocks.borrow().contains(&catch) {\n+            self.block.add_try_finally(None, try_block, catch);\n+        }\n+        else {\n+            self.block.add_try_catch(None, try_block, catch);\n+        }\n+\n+        self.block.end_with_jump(None, then);\n+\n+        return_value.to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    fn invoke(&mut self, typ: Type<'gcc>, fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n         let call_site = self.call(typ, None, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n@@ -542,6 +571,31 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn frem(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        // TODO(antoyo): add check in libgccjit since using the binary operator % causes the following error:\n+        // during RTL pass: expand\n+        // libgccjit.so: error: in expmed_mode_index, at expmed.h:240\n+        // 0x7f0101d58dc6 expmed_mode_index\n+        //     ../../../gcc/gcc/expmed.h:240\n+        // 0x7f0101d58e35 expmed_op_cost_ptr\n+        //     ../../../gcc/gcc/expmed.h:262\n+        // 0x7f0101d594a1 sdiv_cost_ptr\n+        //     ../../../gcc/gcc/expmed.h:531\n+        // 0x7f0101d594f3 sdiv_cost\n+        //     ../../../gcc/gcc/expmed.h:549\n+        // 0x7f0101d6af7e expand_divmod(int, tree_code, machine_mode, rtx_def*, rtx_def*, rtx_def*, int, optab_methods)\n+        //     ../../../gcc/gcc/expmed.cc:4356\n+        // 0x7f0101d94f9e expand_expr_divmod\n+        //     ../../../gcc/gcc/expr.cc:8929\n+        // 0x7f0101d97a26 expand_expr_real_2(separate_ops*, rtx_def*, machine_mode, expand_modifier)\n+        //     ../../../gcc/gcc/expr.cc:9566\n+        // 0x7f0101bef6ef expand_gimple_stmt_1\n+        //     ../../../gcc/gcc/cfgexpand.cc:3967\n+        // 0x7f0101bef910 expand_gimple_stmt\n+        //     ../../../gcc/gcc/cfgexpand.cc:4028\n+        // 0x7f0101bf6ee7 expand_gimple_basic_block\n+        //     ../../../gcc/gcc/cfgexpand.cc:6069\n+        // 0x7f0101bf9194 execute\n+        //     ../../../gcc/gcc/cfgexpand.cc:6795\n         if a.get_type().is_compatible_with(self.cx.float_type) {\n             let fmodf = self.context.get_builtin_function(\"fmodf\");\n             // FIXME(antoyo): this seems to produce the wrong result.\n@@ -616,24 +670,29 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         a * b\n     }\n \n-    fn fadd_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fadd_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs + rhs\n     }\n \n-    fn fsub_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fsub_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs - rhs\n     }\n \n-    fn fmul_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fmul_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs * rhs\n     }\n \n-    fn fdiv_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn fdiv_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        lhs / rhs\n     }\n \n-    fn frem_fast(&mut self, _lhs: RValue<'gcc>, _rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn frem_fast(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        // NOTE: it seems like we cannot enable fast-mode for a single operation in GCC.\n+        self.frem(lhs, rhs)\n     }\n \n     fn checked_binop(&mut self, oop: OverflowOp, typ: Ty<'_>, lhs: Self::Value, rhs: Self::Value) -> (Self::Value, Self::Value) {\n@@ -722,7 +781,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if place.layout.is_gcc_immediate() {\n                 let load = self.load(\n-                    place.layout.gcc_type(self, false),\n+                    place.layout.gcc_type(self),\n                     place.llval,\n                     place.align,\n                 );\n@@ -733,7 +792,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             }\n             else if let abi::Abi::ScalarPair(ref a, ref b) = place.layout.abi {\n                 let b_offset = a.size(self).align_to(b.align(self).abi);\n-                let pair_type = place.layout.gcc_type(self, false);\n+                let pair_type = place.layout.gcc_type(self);\n \n                 let mut load = |i, scalar: &abi::Scalar, align| {\n                     let llptr = self.struct_gep(pair_type, place.llval, i as u64);\n@@ -833,26 +892,31 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n-        let mut result = ptr;\n+        let ptr_type = ptr.get_type();\n+        let mut pointee_type = ptr.get_type();\n+        // NOTE: we cannot use array indexing here like in inbounds_gep because array indexing is\n+        // always considered in bounds in GCC (TODO(antoyo): to be verified).\n+        // So, we have to cast to a number.\n+        let mut result = self.context.new_bitcast(None, ptr, self.sizet_type);\n+        // FIXME(antoyo): if there were more than 1 index, this code is probably wrong and would\n+        // require dereferencing the pointer.\n         for index in indices {\n-            result = self.context.new_array_access(None, result, *index).get_address(None).to_rvalue();\n+            pointee_type = pointee_type.get_pointee().expect(\"pointee type\");\n+            let pointee_size = self.context.new_rvalue_from_int(index.get_type(), pointee_type.get_size() as i32);\n+            result = result + self.gcc_int_cast(*index * pointee_size, self.sizet_type);\n         }\n-        result\n+        self.context.new_bitcast(None, result, ptr_type)\n     }\n \n     fn inbounds_gep(&mut self, _typ: Type<'gcc>, ptr: RValue<'gcc>, indices: &[RValue<'gcc>]) -> RValue<'gcc> {\n-        // FIXME(antoyo): would be safer if doing the same thing (loop) as gep.\n-        // TODO(antoyo): specify inbounds somehow.\n-        match indices.len() {\n-            1 => {\n-                self.context.new_array_access(None, ptr, indices[0]).get_address(None)\n-            },\n-            2 => {\n-                let array = ptr.dereference(None); // TODO(antoyo): assert that first index is 0?\n-                self.context.new_array_access(None, array, indices[1]).get_address(None)\n-            },\n-            _ => unimplemented!(),\n+        // NOTE: array indexing is always considered in bounds in GCC (TODO(antoyo): to be verified).\n+        let mut indices = indices.into_iter();\n+        let index = indices.next().expect(\"first index in inbounds_gep\");\n+        let mut result = self.context.new_array_access(None, ptr, *index);\n+        for index in indices {\n+            result = self.context.new_array_access(None, result, *index);\n         }\n+        result.get_address(None)\n     }\n \n     fn struct_gep(&mut self, value_type: Type<'gcc>, ptr: RValue<'gcc>, idx: u64) -> RValue<'gcc> {\n@@ -1034,8 +1098,19 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n-    fn extract_element(&mut self, _vec: RValue<'gcc>, _idx: RValue<'gcc>) -> RValue<'gcc> {\n-        unimplemented!();\n+    #[cfg(feature=\"master\")]\n+    fn extract_element(&mut self, vec: RValue<'gcc>, idx: RValue<'gcc>) -> RValue<'gcc> {\n+        self.context.new_vector_access(None, vec, idx).to_rvalue()\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    fn extract_element(&mut self, vec: RValue<'gcc>, idx: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = vec.get_type().unqualified().dyncast_vector().expect(\"Called extract_element on a non-vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let vec_num_units = vector_type.get_num_units();\n+        let array_type = self.context.new_array_type(None, element_type, vec_num_units as u64);\n+        let array = self.context.new_bitcast(None, vec, array_type).to_rvalue();\n+        self.context.new_array_access(None, array, idx).to_rvalue()\n     }\n \n     fn vector_splat(&mut self, _num_elts: usize, _elt: RValue<'gcc>) -> RValue<'gcc> {\n@@ -1116,22 +1191,52 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn set_personality_fn(&mut self, _personality: RValue<'gcc>) {\n-        // TODO(antoyo)\n+        #[cfg(feature=\"master\")]\n+        {\n+            let personality = self.rvalue_as_function(_personality);\n+            self.current_func().set_personality_function(personality);\n+        }\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn cleanup_landing_pad(&mut self, pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n+        self.set_personality_fn(pers_fn);\n+\n+        // NOTE: insert the current block in a variable so that a later call to invoke knows to\n+        // generate a try/finally instead of a try/catch for this block.\n+        self.cleanup_blocks.borrow_mut().insert(self.block);\n+\n+        let eh_pointer_builtin = self.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = self.cx.context.new_rvalue_zero(self.int_type);\n+        let ptr = self.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+\n+        let value1_type = self.u8_type.make_pointer();\n+        let ptr = self.cx.context.new_cast(None, ptr, value1_type);\n+        let value1 = ptr;\n+        let value2 = zero; // TODO(antoyo): set the proper value here (the type of exception?).\n+\n+        (value1, value2)\n     }\n \n+    #[cfg(not(feature=\"master\"))]\n     fn cleanup_landing_pad(&mut self, _pers_fn: RValue<'gcc>) -> (RValue<'gcc>, RValue<'gcc>) {\n-        (\n-            self.current_func().new_local(None, self.u8_type.make_pointer(), \"landing_pad0\")\n-                .to_rvalue(),\n-            self.current_func().new_local(None, self.i32_type, \"landing_pad1\").to_rvalue(),\n-        )\n-        // TODO(antoyo): Properly implement unwinding.\n-        // the above is just to make the compilation work as it seems\n-        // rustc_codegen_ssa now calls the unwinding builder methods even on panic=abort.\n+        let value1 = self.current_func().new_local(None, self.u8_type.make_pointer(), \"landing_pad0\")\n+                .to_rvalue();\n+        let value2 = self.current_func().new_local(None, self.i32_type, \"landing_pad1\").to_rvalue();\n+        (value1, value2)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn resume(&mut self, exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n+        let exn_type = exn0.get_type();\n+        let exn = self.context.new_cast(None, exn0, exn_type);\n+        let unwind_resume = self.context.get_target_builtin_function(\"__builtin_unwind_resume\");\n+        self.llbb().add_eval(None, self.context.new_call(None, unwind_resume, &[exn]));\n+        self.unreachable();\n     }\n \n+    #[cfg(not(feature=\"master\"))]\n     fn resume(&mut self, _exn0: RValue<'gcc>, _exn1: RValue<'gcc>) {\n-        // TODO(bjorn3): Properly implement unwinding.\n         self.unreachable();\n     }\n \n@@ -1160,6 +1265,15 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn atomic_cmpxchg(&mut self, dst: RValue<'gcc>, cmp: RValue<'gcc>, src: RValue<'gcc>, order: AtomicOrdering, failure_order: AtomicOrdering, weak: bool) -> RValue<'gcc> {\n         let expected = self.current_func().new_local(None, cmp.get_type(), \"expected\");\n         self.llbb().add_assignment(None, expected, cmp);\n+        // NOTE: gcc doesn't support a failure memory model that is stronger than the success\n+        // memory model.\n+        let order =\n+            if failure_order as i32 > order as i32 {\n+                failure_order\n+            }\n+            else {\n+                order\n+            };\n         let success = self.compare_exchange(dst, expected, src, order, failure_order, weak);\n \n         let pair_type = self.cx.type_struct(&[src.get_type(), self.bool_type], false);\n@@ -1469,7 +1583,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n     #[cfg(feature=\"master\")]\n     pub fn shuffle_vector(&mut self, v1: RValue<'gcc>, v2: RValue<'gcc>, mask: RValue<'gcc>) -> RValue<'gcc> {\n-        let struct_type = mask.get_type().is_struct().expect(\"mask of struct type\");\n+        let struct_type = mask.get_type().is_struct().expect(\"mask should be of struct type\");\n \n         // TODO(antoyo): use a recursive unqualified() here.\n         let vector_type = v1.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n@@ -1501,22 +1615,17 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             vector_elements.push(self.context.new_rvalue_zero(mask_element_type));\n         }\n \n-        let array_type = self.context.new_array_type(None, element_type, vec_num_units as i32);\n         let result_type = self.context.new_vector_type(element_type, mask_num_units as u64);\n         let (v1, v2) =\n             if vec_num_units < mask_num_units {\n                 // NOTE: the mask needs to be the same length as the input vectors, so join the 2\n                 // vectors and create a dummy second vector.\n-                // TODO(antoyo): switch to using new_vector_access.\n-                let array = self.context.new_bitcast(None, v1, array_type);\n                 let mut elements = vec![];\n                 for i in 0..vec_num_units {\n-                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                    elements.push(self.context.new_vector_access(None, v1, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n                 }\n-                // TODO(antoyo): switch to using new_vector_access.\n-                let array = self.context.new_bitcast(None, v2, array_type);\n                 for i in 0..(mask_num_units - vec_num_units) {\n-                    elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                    elements.push(self.context.new_vector_access(None, v2, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n                 }\n                 let v1 = self.context.new_rvalue_from_vector(None, result_type, &elements);\n                 let zero = self.context.new_rvalue_zero(element_type);\n@@ -1536,10 +1645,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             // NOTE: if padding was added, only select the number of elements of the masks to\n             // remove that padding in the result.\n             let mut elements = vec![];\n-            // TODO(antoyo): switch to using new_vector_access.\n-            let array = self.context.new_bitcast(None, result, array_type);\n             for i in 0..mask_num_units {\n-                elements.push(self.context.new_array_access(None, array, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n+                elements.push(self.context.new_vector_access(None, result, self.context.new_rvalue_from_int(self.int_type, i as i32)).to_rvalue());\n             }\n             self.context.new_rvalue_from_vector(None, result_type, &elements)\n         }\n@@ -1558,18 +1665,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_type = vector_type.get_element_type();\n+        let mask_element_type = self.type_ix(element_type.get_size() as u64 * 8);\n         let element_count = vector_type.get_num_units();\n         let mut vector_elements = vec![];\n         for i in 0..element_count {\n             vector_elements.push(i);\n         }\n-        let mask_type = self.context.new_vector_type(self.int_type, element_count as u64);\n+        let mask_type = self.context.new_vector_type(mask_element_type, element_count as u64);\n         let mut shift = 1;\n         let mut res = src;\n         while shift < element_count {\n             let vector_elements: Vec<_> =\n                 vector_elements.iter()\n-                    .map(|i| self.context.new_rvalue_from_int(self.int_type, ((i + shift) % element_count) as i32))\n+                    .map(|i| self.context.new_rvalue_from_int(mask_element_type, ((i + shift) % element_count) as i32))\n                     .collect();\n             let mask = self.context.new_rvalue_from_vector(None, mask_type, &vector_elements);\n             let shifted = self.context.new_rvalue_vector_perm(None, res, res, mask);\n@@ -1581,7 +1690,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    pub fn vector_reduce<F>(&mut self, src: RValue<'gcc>, op: F) -> RValue<'gcc>\n+    pub fn vector_reduce<F>(&mut self, _src: RValue<'gcc>, _op: F) -> RValue<'gcc>\n     where F: Fn(RValue<'gcc>, RValue<'gcc>, &'gcc Context<'gcc>) -> RValue<'gcc>\n     {\n         unimplemented!();\n@@ -1595,54 +1704,196 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         unimplemented!();\n     }\n \n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fadd(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        (0..element_count).into_iter()\n+            .map(|i| self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue())\n+            .fold(acc, |x, i| x + i)\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fadd(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n     pub fn vector_reduce_fmul_fast(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n         unimplemented!();\n     }\n \n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmul(&mut self, acc: RValue<'gcc>, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        (0..element_count).into_iter()\n+            .map(|i| self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue())\n+            .fold(acc, |x, i| x * i)\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmul(&mut self, _acc: RValue<'gcc>, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!()\n+    }\n+\n     // Inspired by Hacker's Delight min implementation.\n     pub fn vector_reduce_min(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n         self.vector_reduce(src, |a, b, context| {\n             let differences_or_zeros = difference_or_zero(a, b, context);\n-            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n+            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n         })\n     }\n \n     // Inspired by Hacker's Delight max implementation.\n     pub fn vector_reduce_max(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n         self.vector_reduce(src, |a, b, context| {\n             let differences_or_zeros = difference_or_zero(a, b, context);\n-            context.new_binary_op(None, BinaryOp::Plus, b.get_type(), b, differences_or_zeros)\n+            context.new_binary_op(None, BinaryOp::Minus, a.get_type(), a, differences_or_zeros)\n         })\n     }\n \n+    fn vector_extremum(&mut self, a: RValue<'gcc>, b: RValue<'gcc>, direction: ExtremumOperation) -> RValue<'gcc> {\n+        let vector_type = a.get_type();\n+\n+        // mask out the NaNs in b and replace them with the corresponding lane in a, so when a and\n+        // b get compared & spliced together, we get the numeric values instead of NaNs.\n+        let b_nan_mask = self.context.new_comparison(None, ComparisonOp::NotEquals, b, b);\n+        let mask_type = b_nan_mask.get_type();\n+        let b_nan_mask_inverted = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, mask_type, b_nan_mask);\n+        let a_cast = self.context.new_bitcast(None, a, mask_type);\n+        let b_cast = self.context.new_bitcast(None, b, mask_type);\n+        let res = (b_nan_mask & a_cast) | (b_nan_mask_inverted & b_cast);\n+        let b = self.context.new_bitcast(None, res, vector_type);\n+\n+        // now do the actual comparison\n+        let comparison_op = match direction {\n+            ExtremumOperation::Min => ComparisonOp::LessThan,\n+            ExtremumOperation::Max => ComparisonOp::GreaterThan,\n+        };\n+        let cmp = self.context.new_comparison(None, comparison_op, a, b);\n+        let cmp_inverted = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, cmp.get_type(), cmp);\n+        let res = (cmp & a_cast) | (cmp_inverted & res);\n+        self.context.new_bitcast(None, res, vector_type)\n+    }\n+\n+    pub fn vector_fmin(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_extremum(a, b, ExtremumOperation::Min)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmin(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut acc = self.context.new_vector_access(None, src, self.context.new_rvalue_zero(self.int_type)).to_rvalue();\n+        for i in 1..element_count {\n+            let elem = self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue();\n+            let cmp = self.context.new_comparison(None, ComparisonOp::LessThan, acc, elem);\n+            acc = self.select(cmp, acc, elem);\n+        }\n+        acc\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmin(&mut self, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n+    pub fn vector_fmax(&mut self, a: RValue<'gcc>, b: RValue<'gcc>) -> RValue<'gcc> {\n+        self.vector_extremum(a, b, ExtremumOperation::Max)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    pub fn vector_reduce_fmax(&mut self, src: RValue<'gcc>) -> RValue<'gcc> {\n+        let vector_type = src.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n+        let element_count = vector_type.get_num_units();\n+        let mut acc = self.context.new_vector_access(None, src, self.context.new_rvalue_zero(self.int_type)).to_rvalue();\n+        for i in 1..element_count {\n+            let elem = self.context\n+                .new_vector_access(None, src, self.context.new_rvalue_from_int(self.int_type, i as _))\n+                .to_rvalue();\n+            let cmp = self.context.new_comparison(None, ComparisonOp::GreaterThan, acc, elem);\n+            acc = self.select(cmp, acc, elem);\n+        }\n+        acc\n+    }\n+\n+    #[cfg(not(feature=\"master\"))]\n+    pub fn vector_reduce_fmax(&mut self, _src: RValue<'gcc>) -> RValue<'gcc> {\n+        unimplemented!();\n+    }\n+\n     pub fn vector_select(&mut self, cond: RValue<'gcc>, then_val: RValue<'gcc>, else_val: RValue<'gcc>) -> RValue<'gcc> {\n         // cond is a vector of integers, not of bools.\n-        let cond_type = cond.get_type();\n-        let vector_type = cond_type.unqualified().dyncast_vector().expect(\"vector type\");\n+        let vector_type = cond.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n         let num_units = vector_type.get_num_units();\n         let element_type = vector_type.get_element_type();\n+\n+        #[cfg(feature=\"master\")]\n+        let (cond, element_type) = {\n+            let then_val_vector_type = then_val.get_type().dyncast_vector().expect(\"vector type\");\n+            let then_val_element_type = then_val_vector_type.get_element_type();\n+            let then_val_element_size = then_val_element_type.get_size();\n+\n+            // NOTE: the mask needs to be of the same size as the other arguments in order for the &\n+            // operation to work.\n+            if then_val_element_size != element_type.get_size() {\n+                let new_element_type = self.type_ix(then_val_element_size as u64 * 8);\n+                let new_vector_type = self.context.new_vector_type(new_element_type, num_units as u64);\n+                let cond = self.context.convert_vector(None, cond, new_vector_type);\n+                (cond, new_element_type)\n+            }\n+            else {\n+                (cond, element_type)\n+            }\n+        };\n+\n+        let cond_type = cond.get_type();\n+\n         let zeros = vec![self.context.new_rvalue_zero(element_type); num_units];\n         let zeros = self.context.new_rvalue_from_vector(None, cond_type, &zeros);\n \n+        let result_type = then_val.get_type();\n+\n         let masks = self.context.new_comparison(None, ComparisonOp::NotEquals, cond, zeros);\n+        // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+        // the & operation work.\n+        let then_val = self.bitcast_if_needed(then_val, masks.get_type());\n         let then_vals = masks & then_val;\n \n-        let ones = vec![self.context.new_rvalue_one(element_type); num_units];\n-        let ones = self.context.new_rvalue_from_vector(None, cond_type, &ones);\n-        let inverted_masks = masks + ones;\n+        let minus_ones = vec![self.context.new_rvalue_from_int(element_type, -1); num_units];\n+        let minus_ones = self.context.new_rvalue_from_vector(None, cond_type, &minus_ones);\n+        let inverted_masks = masks ^ minus_ones;\n         // NOTE: sometimes, the type of else_val can be different than the type of then_val in\n         // libgccjit (vector of int vs vector of int32_t), but they should be the same for the AND\n         // operation to work.\n+        // TODO: remove bitcast now that vector types can be compared?\n         let else_val = self.context.new_bitcast(None, else_val, then_val.get_type());\n         let else_vals = inverted_masks & else_val;\n \n-        then_vals | else_vals\n+        let res = then_vals | else_vals;\n+        self.bitcast_if_needed(res, result_type)\n     }\n }\n \n fn difference_or_zero<'gcc>(a: RValue<'gcc>, b: RValue<'gcc>, context: &'gcc Context<'gcc>) -> RValue<'gcc> {\n     let difference = a - b;\n     let masks = context.new_comparison(None, ComparisonOp::GreaterThanEquals, b, a);\n+    // NOTE: masks is a vector of integers, but the values can be vectors of floats, so use bitcast to make\n+    // the & operation work.\n+    let a_type = a.get_type();\n+    let masks =\n+        if masks.get_type() != a_type {\n+            context.new_bitcast(None, masks, a_type)\n+        }\n+        else {\n+            masks\n+        };\n     difference & masks\n }\n "}, {"sha": "ba1e86562089e756e167d2cbf14990a7560c596f", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "modified", "additions": 105, "deletions": 8, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,9 +1,10 @@\n-use gccjit::{FunctionType, RValue};\n-use rustc_codegen_ssa::traits::BaseTypeMethods;\n+#[cfg(feature=\"master\")]\n+use gccjit::{FnAttribute, Visibility};\n+use gccjit::{FunctionType, Function};\n use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n-use crate::abi::FnAbiGccExt;\n+use crate::attributes;\n use crate::context::CodegenCx;\n \n /// Codegens a reference to a fn/method item, monomorphizing and\n@@ -13,22 +14,26 @@ use crate::context::CodegenCx;\n ///\n /// - `cx`: the crate context\n /// - `instance`: the instance to be instantiated\n-pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> RValue<'gcc> {\n+pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>) -> Function<'gcc> {\n     let tcx = cx.tcx();\n \n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n+    let sym = tcx.symbol_name(instance).name;\n+\n     if let Some(&func) = cx.function_instances.borrow().get(&instance) {\n         return func;\n     }\n \n-    let sym = tcx.symbol_name(instance).name;\n-\n     let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n \n     let func =\n-        if let Some(func) = cx.get_declared_value(&sym) {\n+        if let Some(_func) = cx.get_declared_value(&sym) {\n+            // FIXME(antoyo): we never reach this because get_declared_value only returns global variables\n+            // and here we try to get a function.\n+            unreachable!();\n+            /*\n             // Create a fn pointer with the new signature.\n             let ptrty = fn_abi.ptr_to_gcc_type(cx);\n \n@@ -61,13 +66,105 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             }\n             else {\n                 func\n-            }\n+            }*/\n         }\n         else {\n             cx.linkage.set(FunctionType::Extern);\n             let func = cx.declare_fn(&sym, &fn_abi);\n \n+            attributes::from_fn_attrs(cx, func, instance);\n+\n+            let instance_def_id = instance.def_id();\n+\n             // TODO(antoyo): set linkage and attributes.\n+\n+            // Apply an appropriate linkage/visibility value to our item that we\n+            // just declared.\n+            //\n+            // This is sort of subtle. Inside our codegen unit we started off\n+            // compilation by predefining all our own `MonoItem` instances. That\n+            // is, everything we're codegenning ourselves is already defined. That\n+            // means that anything we're actually codegenning in this codegen unit\n+            // will have hit the above branch in `get_declared_value`. As a result,\n+            // we're guaranteed here that we're declaring a symbol that won't get\n+            // defined, or in other words we're referencing a value from another\n+            // codegen unit or even another crate.\n+            //\n+            // So because this is a foreign value we blanket apply an external\n+            // linkage directive because it's coming from a different object file.\n+            // The visibility here is where it gets tricky. This symbol could be\n+            // referencing some foreign crate or foreign library (an `extern`\n+            // block) in which case we want to leave the default visibility. We may\n+            // also, though, have multiple codegen units. It could be a\n+            // monomorphization, in which case its expected visibility depends on\n+            // whether we are sharing generics or not. The important thing here is\n+            // that the visibility we apply to the declaration is the same one that\n+            // has been applied to the definition (wherever that definition may be).\n+            let is_generic = instance.substs.non_erasable_generics().next().is_some();\n+\n+            if is_generic {\n+                // This is a monomorphization. Its expected visibility depends\n+                // on whether we are in share-generics mode.\n+\n+                if cx.tcx.sess.opts.share_generics() {\n+                    // We are in share_generics mode.\n+\n+                    if let Some(instance_def_id) = instance_def_id.as_local() {\n+                        // This is a definition from the current crate. If the\n+                        // definition is unreachable for downstream crates or\n+                        // the current crate does not re-export generics, the\n+                        // definition of the instance will have been declared\n+                        // as `hidden`.\n+                        if cx.tcx.is_unreachable_local_definition(instance_def_id)\n+                            || !cx.tcx.local_crate_exports_generics()\n+                        {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a monomorphization of a generic function\n+                        // defined in an upstream crate.\n+                        if instance.upstream_monomorphization(tcx).is_some() {\n+                            // This is instantiated in another crate. It cannot\n+                            // be `hidden`.\n+                        } else {\n+                            // This is a local instantiation of an upstream definition.\n+                            // If the current crate does not re-export it\n+                            // (because it is a C library or an executable), it\n+                            // will have been declared `hidden`.\n+                            if !cx.tcx.local_crate_exports_generics() {\n+                                #[cfg(feature=\"master\")]\n+                                func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    // When not sharing generics, all instances are in the same\n+                    // crate and have hidden visibility\n+                    #[cfg(feature=\"master\")]\n+                    func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                }\n+            } else {\n+                // This is a non-generic function\n+                if cx.tcx.is_codegened_item(instance_def_id) {\n+                    // This is a function that is instantiated in the local crate\n+\n+                    if instance_def_id.is_local() {\n+                        // This is function that is defined in the local crate.\n+                        // If it is not reachable, it is hidden.\n+                        if !cx.tcx.is_reachable_non_generic(instance_def_id) {\n+                            #[cfg(feature=\"master\")]\n+                            func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                        }\n+                    } else {\n+                        // This is a function from an upstream crate that has\n+                        // been instantiated here. These are always hidden.\n+                        #[cfg(feature=\"master\")]\n+                        func.add_attribute(FnAttribute::Visibility(Visibility::Hidden));\n+                    }\n+                }\n+            }\n+\n             func\n         };\n "}, {"sha": "76fc7bd222e1e072e13cd5ebdb2221bf9585bda8", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -36,7 +36,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) -> RValue<'gcc> {\n     let context = &cx.context;\n     let byte_type = context.new_type::<u8>();\n-    let typ = context.new_array_type(None, byte_type, bytes.len() as i32);\n+    let typ = context.new_array_type(None, byte_type, bytes.len() as u64);\n     let elements: Vec<_> =\n         bytes.iter()\n         .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n@@ -115,8 +115,8 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         self.const_uint(self.usize_type, i)\n     }\n \n-    fn const_u8(&self, _i: u8) -> RValue<'gcc> {\n-        unimplemented!();\n+    fn const_u8(&self, i: u8) -> RValue<'gcc> {\n+        self.const_uint(self.type_u8(), i as u64)\n     }\n \n     fn const_real(&self, typ: Type<'gcc>, val: f64) -> RValue<'gcc> {\n@@ -133,7 +133,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             .1;\n         let len = s.len();\n         let cs = self.const_ptrcast(str_global.get_address(None),\n-            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self, true)),\n+            self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self)),\n         );\n         (cs, self.const_usize(len as u64))\n     }\n@@ -174,8 +174,18 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 }\n \n                 let value = self.const_uint_big(self.type_ix(bitsize), data);\n-                // TODO(bjorn3): assert size is correct\n-                self.const_bitcast(value, ty)\n+                let bytesize = layout.size(self).bytes();\n+                if bitsize > 1 && ty.is_integral() && bytesize as u32 == ty.get_size() {\n+                    // NOTE: since the intrinsic _xabort is called with a bitcast, which\n+                    // is non-const, but expects a constant, do a normal cast instead of a bitcast.\n+                    // FIXME(antoyo): fix bitcast to work in constant contexts.\n+                    // TODO(antoyo): perhaps only use bitcast for pointers?\n+                    self.context.new_cast(None, value, ty)\n+                }\n+                else {\n+                    // TODO(bjorn3): assert size is correct\n+                    self.const_bitcast(value, ty)\n+                }\n             }\n             Scalar::Ptr(ptr, _size) => {\n                 let (alloc_id, offset) = ptr.into_parts();\n@@ -227,11 +237,11 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn from_const_alloc(&self, layout: TyAndLayout<'tcx>, alloc: ConstAllocation<'tcx>, offset: Size) -> PlaceRef<'tcx, RValue<'gcc>> {\n         assert_eq!(alloc.inner().align, layout.align.abi);\n-        let ty = self.type_ptr_to(layout.gcc_type(self, true));\n+        let ty = self.type_ptr_to(layout.gcc_type(self));\n         let value =\n             if layout.size == Size::ZERO {\n                 let value = self.const_usize(alloc.inner().align.bytes());\n-                self.context.new_cast(None, value, ty)\n+                self.const_bitcast(value, ty)\n             }\n             else {\n                 let init = const_alloc_to_gcc(self, alloc);"}, {"sha": "792ab8f890d8feab0f2c7cabdf30d293c1551c17", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 86, "deletions": 85, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,8 +1,8 @@\n-use gccjit::{GlobalKind, LValue, RValue, ToRValue, Type};\n+#[cfg(feature = \"master\")]\n+use gccjit::FnAttribute;\n+use gccjit::{Function, GlobalKind, LValue, RValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n-use rustc_hir as hir;\n-use rustc_hir::Node;\n-use rustc_middle::{bug, span_bug};\n+use rustc_middle::span_bug;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::ty::{self, Instance, Ty};\n@@ -13,6 +13,7 @@ use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRan\n \n use crate::base;\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMinimumAlignment;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -30,6 +31,21 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n+fn set_global_alignment<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, gv: LValue<'gcc>, mut align: Align) {\n+    // The target may require greater alignment for globals than the type does.\n+    // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n+    // which can force it to be smaller. Rust doesn't support this yet.\n+    if let Some(min) = cx.sess().target.min_global_align {\n+        match Align::from_bits(min) {\n+            Ok(min) => align = align.max(min),\n+            Err(err) => {\n+                cx.sess().emit_err(InvalidMinimumAlignment { err });\n+            }\n+        }\n+    }\n+    gv.set_alignment(align.bytes() as i32);\n+}\n+\n impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn static_addr_of(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n         // TODO(antoyo): implement a proper rvalue comparison in libgccjit instead of doing the\n@@ -79,9 +95,9 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n-        // TODO(antoyo): set alignment.\n+        set_global_alignment(self, global, self.align_of(ty));\n \n         let value = self.bitcast_if_needed(value, gcc_type);\n         global.global_set_initializer_rvalue(value);\n@@ -158,12 +174,19 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n         // TODO(antoyo)\n     }\n \n-    fn add_compiler_used_global(&self, _global: RValue<'gcc>) {\n-        // TODO(antoyo)\n+    fn add_compiler_used_global(&self, global: RValue<'gcc>) {\n+        // NOTE: seems like GCC does not make the distinction between compiler.used and used.\n+        self.add_used_global(global);\n     }\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    pub fn add_used_function(&self, function: Function<'gcc>) {\n+        #[cfg(feature = \"master\")]\n+        function.add_attribute(FnAttribute::Used);\n+    }\n+\n     pub fn static_addr_of_mut(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n         let global =\n             match kind {\n@@ -208,82 +231,59 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         let sym = self.tcx.symbol_name(instance).name;\n \n         let global =\n-            if let Some(def_id) = def_id.as_local() {\n-                let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                let llty = self.layout_of(ty).gcc_type(self, true);\n-                // FIXME: refactor this to work without accessing the HIR\n-                let global = match self.tcx.hir().get(id) {\n-                    Node::Item(&hir::Item { span, kind: hir::ItemKind::Static(..), .. }) => {\n-                        if let Some(global) = self.get_declared_value(&sym) {\n-                            if self.val_ty(global) != self.type_ptr_to(llty) {\n-                                span_bug!(span, \"Conflicting types for static\");\n-                            }\n-                        }\n-\n-                        let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-                        let global = self.declare_global(\n-                            &sym,\n-                            llty,\n-                            GlobalKind::Exported,\n-                            is_tls,\n-                            fn_attrs.link_section,\n-                        );\n-\n-                        if !self.tcx.is_reachable_non_generic(def_id) {\n-                            // TODO(antoyo): set visibility.\n-                        }\n-\n-                        global\n-                    }\n-\n-                    Node::ForeignItem(&hir::ForeignItem {\n-                        span: _,\n-                        kind: hir::ForeignItemKind::Static(..),\n-                        ..\n-                    }) => {\n-                        let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n-                        check_and_apply_linkage(&self, &fn_attrs, ty, sym)\n-                    }\n-\n-                    item => bug!(\"get_static: expected static, found {:?}\", item),\n-                };\n+            if def_id.is_local() && !self.tcx.is_foreign_item(def_id) {\n+            let llty = self.layout_of(ty).gcc_type(self);\n+            if let Some(global) = self.get_declared_value(sym) {\n+                if self.val_ty(global) != self.type_ptr_to(llty) {\n+                    span_bug!(self.tcx.def_span(def_id), \"Conflicting types for static\");\n+                }\n+            }\n \n-                global\n+            let is_tls = fn_attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n+            let global = self.declare_global(\n+                &sym,\n+                llty,\n+                GlobalKind::Exported,\n+                is_tls,\n+                fn_attrs.link_section,\n+            );\n+\n+            if !self.tcx.is_reachable_non_generic(def_id) {\n+                // TODO(antoyo): set visibility.\n             }\n-            else {\n-                // FIXME(nagisa): perhaps the map of externs could be offloaded to llvm somehow?\n-                //debug!(\"get_static: sym={} item_attr={:?}\", sym, self.tcx.item_attrs(def_id));\n-\n-                let attrs = self.tcx.codegen_fn_attrs(def_id);\n-                let global = check_and_apply_linkage(&self, &attrs, ty, sym);\n-\n-                let needs_dll_storage_attr = false; // TODO(antoyo)\n-\n-                // If this assertion triggers, there's something wrong with commandline\n-                // argument validation.\n-                debug_assert!(\n-                    !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n-                        && self.tcx.sess.target.options.is_like_msvc\n-                        && self.tcx.sess.opts.cg.prefer_dynamic)\n-                );\n-\n-                if needs_dll_storage_attr {\n-                    // This item is external but not foreign, i.e., it originates from an external Rust\n-                    // crate. Since we don't know whether this crate will be linked dynamically or\n-                    // statically in the final application, we always mark such symbols as 'dllimport'.\n-                    // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n-                    // to make things work.\n-                    //\n-                    // However, in some scenarios we defer emission of statics to downstream\n-                    // crates, so there are cases where a static with an upstream DefId\n-                    // is actually present in the current crate. We can find out via the\n-                    // is_codegened_item query.\n-                    if !self.tcx.is_codegened_item(def_id) {\n-                        unimplemented!();\n-                    }\n+\n+            global\n+        } else {\n+            check_and_apply_linkage(&self, &fn_attrs, ty, sym)\n+        };\n+\n+        if !def_id.is_local() {\n+            let needs_dll_storage_attr = false; // TODO(antoyo)\n+\n+            // If this assertion triggers, there's something wrong with commandline\n+            // argument validation.\n+            debug_assert!(\n+                !(self.tcx.sess.opts.cg.linker_plugin_lto.enabled()\n+                    && self.tcx.sess.target.options.is_like_msvc\n+                    && self.tcx.sess.opts.cg.prefer_dynamic)\n+            );\n+\n+            if needs_dll_storage_attr {\n+                // This item is external but not foreign, i.e., it originates from an external Rust\n+                // crate. Since we don't know whether this crate will be linked dynamically or\n+                // statically in the final application, we always mark such symbols as 'dllimport'.\n+                // If final linkage happens to be static, we rely on compiler-emitted __imp_ stubs\n+                // to make things work.\n+                //\n+                // However, in some scenarios we defer emission of statics to downstream\n+                // crates, so there are cases where a static with an upstream DefId\n+                // is actually present in the current crate. We can find out via the\n+                // is_codegened_item query.\n+                if !self.tcx.is_codegened_item(def_id) {\n+                    unimplemented!();\n                 }\n-                global\n-            };\n+            }\n+        }\n \n         // TODO(antoyo): set dll storage class.\n \n@@ -357,7 +357,7 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n \n fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-    let llty = cx.layout_of(ty).gcc_type(cx, true);\n+    let gcc_type = cx.layout_of(ty).gcc_type(cx);\n     if let Some(linkage) = attrs.import_linkage {\n         // Declare a symbol `foo` with the desired linkage.\n         let global1 = cx.declare_global_with_linkage(&sym, cx.type_i8(), base::global_linkage_to_gcc(linkage));\n@@ -370,9 +370,10 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // zero.\n         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n         real_name.push_str(&sym);\n-        let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n+        let global2 = cx.define_global(&real_name, gcc_type, is_tls, attrs.link_section);\n         // TODO(antoyo): set linkage.\n-        global2.global_set_initializer_rvalue(global1.get_address(None));\n+        let value = cx.const_ptrcast(global1.get_address(None), gcc_type);\n+        global2.global_set_initializer_rvalue(value);\n         // TODO(antoyo): use global_set_initializer() when it will work.\n         global2\n     }\n@@ -386,6 +387,6 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // don't do this then linker errors can be generated where the linker\n         // complains that one object files has a thread local version of the\n         // symbol and another one doesn't.\n-        cx.declare_global(&sym, llty, GlobalKind::Imported, is_tls, attrs.link_section)\n+        cx.declare_global(&sym, gcc_type, GlobalKind::Imported, is_tls, attrs.link_section)\n     }\n }"}, {"sha": "661681bdb50f2f1094b0f18736ad43846110cc64", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 49, "deletions": 34, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,17 +1,18 @@\n use std::cell::{Cell, RefCell};\n \n-use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Struct, Type};\n+use gccjit::{Block, CType, Context, Function, FunctionPtrType, FunctionType, LValue, RValue, Type};\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::traits::{\n     BackendTypes,\n+    BaseTypeMethods,\n     MiscMethods,\n };\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::span_bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n+use rustc_middle::ty::layout::{FnAbiError, FnAbiOf, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n use rustc_span::{Span, source_map::respan};\n use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n@@ -33,6 +34,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     // TODO(bjorn3): Can this field be removed?\n     pub current_func: RefCell<Option<Function<'gcc>>>,\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n+    pub function_address_names: RefCell<FxHashMap<RValue<'gcc>, String>>,\n \n     pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n     pub intrinsics: RefCell<FxHashMap<String, Function<'gcc>>>,\n@@ -78,12 +80,10 @@ pub struct CodegenCx<'gcc, 'tcx> {\n \n     pub struct_types: RefCell<FxHashMap<Vec<Type<'gcc>>, Type<'gcc>>>,\n \n-    pub types_with_fields_to_set: RefCell<FxHashMap<Type<'gcc>, (Struct<'gcc>, TyAndLayout<'tcx>)>>,\n-\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n     /// Cache function instances of monomorphic and polymorphic items\n-    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n+    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, Function<'gcc>>>,\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n@@ -110,6 +110,7 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     local_gen_sym_counter: Cell<usize>,\n \n     eh_personality: Cell<Option<RValue<'gcc>>>,\n+    pub rust_try_fn: Cell<Option<(Type<'gcc>, Function<'gcc>)>>,\n \n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n \n@@ -119,6 +120,8 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// they can be dereferenced later.\n     /// FIXME(antoyo): fix the rustc API to avoid having this hack.\n     pub structs_as_pointer: RefCell<FxHashSet<RValue<'gcc>>>,\n+\n+    pub cleanup_blocks: RefCell<FxHashSet<Block<'gcc>>>,\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -194,6 +197,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             context,\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n+            function_address_names: Default::default(),\n             functions: RefCell::new(functions),\n             intrinsics: RefCell::new(FxHashMap::default()),\n \n@@ -243,11 +247,12 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             types: Default::default(),\n             tcx,\n             struct_types: Default::default(),\n-            types_with_fields_to_set: Default::default(),\n             local_gen_sym_counter: Cell::new(0),\n             eh_personality: Cell::new(None),\n+            rust_try_fn: Cell::new(None),\n             pointee_infos: Default::default(),\n             structs_as_pointer: Default::default(),\n+            cleanup_blocks: Default::default(),\n         }\n     }\n \n@@ -327,8 +332,9 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn get_fn(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n         let func = get_fn(self, instance);\n-        *self.current_func.borrow_mut() = Some(self.rvalue_as_function(func));\n-        func\n+        *self.current_func.borrow_mut() = Some(func);\n+        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n+        unsafe { std::mem::transmute(func) }\n     }\n \n     fn get_fn_addr(&self, instance: Instance<'tcx>) -> RValue<'gcc> {\n@@ -339,15 +345,15 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                 self.intrinsics.borrow()[func_name].clone()\n             }\n             else {\n-                let func = get_fn(self, instance);\n-                self.rvalue_as_function(func)\n+                get_fn(self, instance)\n             };\n         let ptr = func.get_address(None);\n \n         // TODO(antoyo): don't do this twice: i.e. in declare_fn and here.\n         // FIXME(antoyo): the rustc API seems to call get_fn_addr() when not needed (e.g. for FFI).\n \n         self.normal_function_addresses.borrow_mut().insert(ptr);\n+        self.function_address_names.borrow_mut().insert(ptr, func_name.to_string());\n \n         ptr\n     }\n@@ -377,31 +383,40 @@ impl<'gcc, 'tcx> MiscMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             return llpersonality;\n         }\n         let tcx = self.tcx;\n-        let llfn = match tcx.lang_items().eh_personality() {\n-            Some(def_id) if !wants_msvc_seh(self.sess()) => self.get_fn_addr(\n-                ty::Instance::resolve(\n-                    tcx,\n-                    ty::ParamEnv::reveal_all(),\n-                    def_id,\n-                    ty::List::empty(),\n-                )\n-                .unwrap().unwrap(),\n-            ),\n-            _ => {\n-                let _name = if wants_msvc_seh(self.sess()) {\n-                    \"__CxxFrameHandler3\"\n-                } else {\n-                    \"rust_eh_personality\"\n-                };\n-                //let func = self.declare_func(name, self.type_i32(), &[], true);\n-                // FIXME(antoyo): this hack should not be needed. That will probably be removed when\n-                // unwinding support is added.\n-                self.context.new_rvalue_from_int(self.int_type, 0)\n-            }\n-        };\n+        let func =\n+            match tcx.lang_items().eh_personality() {\n+                Some(def_id) if !wants_msvc_seh(self.sess()) => {\n+                    let instance =\n+                        ty::Instance::resolve(\n+                            tcx,\n+                            ty::ParamEnv::reveal_all(),\n+                            def_id,\n+                            ty::List::empty(),\n+                        )\n+                        .unwrap().unwrap();\n+\n+                    let symbol_name = tcx.symbol_name(instance).name;\n+                    let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n+                    self.linkage.set(FunctionType::Extern);\n+                    let func = self.declare_fn(symbol_name, &fn_abi);\n+                    let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n+                    func\n+                },\n+                _ => {\n+                    let name =\n+                        if wants_msvc_seh(self.sess()) {\n+                            \"__CxxFrameHandler3\"\n+                        }\n+                        else {\n+                            \"rust_eh_personality\"\n+                        };\n+                    let func = self.declare_func(name, self.type_i32(), &[], true);\n+                    unsafe { std::mem::transmute(func) }\n+                }\n+            };\n         // TODO(antoyo): apply target cpu attributes.\n-        self.eh_personality.set(Some(llfn));\n-        llfn\n+        self.eh_personality.set(Some(func));\n+        func\n     }\n \n     fn sess(&self) -> &Session {"}, {"sha": "4748e7e4be2a3afe401ed49886cc7ae9a862c6b3", "filename": "compiler/rustc_codegen_gcc/src/declare.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -38,12 +38,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         global\n     }\n \n-    /*pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> RValue<'gcc> {\n-        self.linkage.set(FunctionType::Exported);\n-        let func = declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n-    }*/\n+    pub fn declare_func(&self, name: &str, return_type: Type<'gcc>, params: &[Type<'gcc>], variadic: bool) -> Function<'gcc> {\n+        self.linkage.set(FunctionType::Extern);\n+        declare_raw_fn(self, name, () /*llvm::CCallConv*/, return_type, params, variadic)\n+    }\n \n     pub fn declare_global(&self, name: &str, ty: Type<'gcc>, global_kind: GlobalKind, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         let global = self.context.new_global(None, global_kind, ty, name);\n@@ -79,12 +77,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n+    pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> Function<'gcc> {\n         let (return_type, params, variadic, on_stack_param_indices) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n         self.on_stack_function_params.borrow_mut().insert(func, on_stack_param_indices);\n-        // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n-        unsafe { std::mem::transmute(func) }\n+        func\n     }\n \n     pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {"}, {"sha": "9305bd1e043d564010bd360c27b92ef4b266e82a", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -221,3 +221,18 @@ pub(crate) struct UnwindingInlineAsm {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_invalid_minimum_alignment)]\n+pub(crate) struct InvalidMinimumAlignment {\n+    pub err: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc_tied_target_features)]\n+#[help]\n+pub(crate) struct TiedTargetFeatures {\n+    #[primary_span]\n+    pub span: Span,\n+    pub features: String,\n+}"}, {"sha": "0cf1204791d336c75afe591660e994e7e94fb36a", "filename": "compiler/rustc_codegen_gcc/src/int.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fint.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -389,18 +389,22 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 };\n             self.context.new_comparison(None, op, cmp, self.context.new_rvalue_from_int(self.int_type, limit))\n         }\n+        else if a_type.get_pointee().is_some() && b_type.get_pointee().is_some() {\n+            // NOTE: gcc cannot compare pointers to different objects, but rustc does that, so cast them to usize.\n+            lhs = self.context.new_bitcast(None, lhs, self.usize_type);\n+            rhs = self.context.new_bitcast(None, rhs, self.usize_type);\n+            self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n+        }\n         else {\n-            let left_type = lhs.get_type();\n-            let right_type = rhs.get_type();\n-            if left_type != right_type {\n+            if a_type != b_type {\n                 // NOTE: because libgccjit cannot compare function pointers.\n-                if left_type.dyncast_function_ptr_type().is_some() && right_type.dyncast_function_ptr_type().is_some() {\n+                if a_type.dyncast_function_ptr_type().is_some() && b_type.dyncast_function_ptr_type().is_some() {\n                     lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n                     rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n                 }\n                 // NOTE: hack because we try to cast a vector type to the same vector type.\n-                else if format!(\"{:?}\", left_type) != format!(\"{:?}\", right_type) {\n-                    rhs = self.context.new_cast(None, rhs, left_type);\n+                else if format!(\"{:?}\", a_type) != format!(\"{:?}\", b_type) {\n+                    rhs = self.context.new_cast(None, rhs, a_type);\n                 }\n             }\n             self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)"}, {"sha": "8a4559355ea6716877df1b2de076d43e51a6cf38", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/archs.rs", "status": "modified", "additions": 2379, "deletions": 64, "changes": 2443, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Farchs.rs?ref=38b96553112dce3de630890701f17d86e265f6ba"}, {"sha": "0edec566be309987bac044515be59f69d4ab8c86", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/llvm.rs", "status": "modified", "additions": 663, "deletions": 134, "changes": 797, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fllvm.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,159 +1,387 @@\n use std::borrow::Cow;\n \n-use gccjit::{Function, FunctionPtrType, RValue, ToRValue};\n+use gccjit::{Function, FunctionPtrType, RValue, ToRValue, UnaryOp};\n+use rustc_codegen_ssa::traits::BuilderMethods;\n \n use crate::{context::CodegenCx, builder::Builder};\n \n-pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str) -> Cow<'b, [RValue<'gcc>]> {\n+pub fn adjust_intrinsic_arguments<'a, 'b, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, gcc_func: FunctionPtrType<'gcc>, mut args: Cow<'b, [RValue<'gcc>]>, func_name: &str, original_function_name: Option<&String>) -> Cow<'b, [RValue<'gcc>]> {\n     // Some LLVM intrinsics do not map 1-to-1 to GCC intrinsics, so we add the missing\n     // arguments here.\n     if gcc_func.get_param_count() != args.len() {\n         match &*func_name {\n-            \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n-                // FIXME(antoyo): the following intrinsics has 4 (or 5) arguments according to the doc, but is defined with 2 (or 3) arguments in library/stdarch/crates/core_arch/src/x86/avx512f.rs.\n+            // NOTE: the following intrinsics have a different number of parameters in LLVM and GCC.\n+            \"__builtin_ia32_prold512_mask\" | \"__builtin_ia32_pmuldq512_mask\" | \"__builtin_ia32_pmuludq512_mask\"\n                 | \"__builtin_ia32_pmaxsd512_mask\" | \"__builtin_ia32_pmaxsq512_mask\" | \"__builtin_ia32_pmaxsq256_mask\"\n-                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\" | \"__builtin_ia32_pmaxuq256_mask\"\n-                | \"__builtin_ia32_pmaxuq128_mask\"\n+                | \"__builtin_ia32_pmaxsq128_mask\" | \"__builtin_ia32_pmaxud512_mask\" | \"__builtin_ia32_pmaxuq512_mask\"\n                 | \"__builtin_ia32_pminsd512_mask\" | \"__builtin_ia32_pminsq512_mask\" | \"__builtin_ia32_pminsq256_mask\"\n-                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\" | \"__builtin_ia32_pminuq256_mask\"\n-                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\"\n+                | \"__builtin_ia32_pminsq128_mask\" | \"__builtin_ia32_pminud512_mask\" | \"__builtin_ia32_pminuq512_mask\"\n+                | \"__builtin_ia32_prolq512_mask\" | \"__builtin_ia32_prorq512_mask\" | \"__builtin_ia32_pslldi512_mask\"\n+                | \"__builtin_ia32_psrldi512_mask\" | \"__builtin_ia32_psllqi512_mask\" | \"__builtin_ia32_psrlqi512_mask\"\n+                | \"__builtin_ia32_pslld512_mask\" | \"__builtin_ia32_psrld512_mask\" | \"__builtin_ia32_psllq512_mask\"\n+                | \"__builtin_ia32_psrlq512_mask\" | \"__builtin_ia32_psrad512_mask\" | \"__builtin_ia32_psraq512_mask\"\n+                | \"__builtin_ia32_psradi512_mask\" | \"__builtin_ia32_psraqi512_mask\" | \"__builtin_ia32_psrav16si_mask\"\n+                | \"__builtin_ia32_psrav8di_mask\" | \"__builtin_ia32_prolvd512_mask\" | \"__builtin_ia32_prorvd512_mask\"\n+                | \"__builtin_ia32_prolvq512_mask\" | \"__builtin_ia32_prorvq512_mask\" | \"__builtin_ia32_psllv16si_mask\"\n+                | \"__builtin_ia32_psrlv16si_mask\" | \"__builtin_ia32_psllv8di_mask\" | \"__builtin_ia32_psrlv8di_mask\"\n+                | \"__builtin_ia32_permvarsi512_mask\" | \"__builtin_ia32_vpermilvarps512_mask\"\n+                | \"__builtin_ia32_vpermilvarpd512_mask\" | \"__builtin_ia32_permvardi512_mask\"\n+                | \"__builtin_ia32_permvarsf512_mask\" | \"__builtin_ia32_permvarqi512_mask\"\n+                | \"__builtin_ia32_permvarqi256_mask\" | \"__builtin_ia32_permvarqi128_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb512_mask\" | \"__builtin_ia32_vpmultishiftqb256_mask\"\n+                | \"__builtin_ia32_vpmultishiftqb128_mask\"\n                 => {\n-                    // TODO: refactor by separating those intrinsics outside of this branch.\n-                    let add_before_last_arg =\n-                        match &*func_name {\n-                            \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n-                                | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\"\n-                                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => true,\n-                            _ => false,\n-                        };\n-                    let new_first_arg_is_zero =\n-                        match &*func_name {\n-                            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\"\n-                                | \"__builtin_ia32_pminuq256_mask\" | \"__builtin_ia32_pminuq128_mask\" => true,\n-                            _ => false\n-                        };\n-                    let arg3_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 1,\n-                            _ => 2,\n-                        };\n-                    let mut new_args = args.to_vec();\n-                    let arg3_type = gcc_func.get_param_type(arg3_index);\n-                    let first_arg =\n-                        if new_first_arg_is_zero {\n-                            let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n-                            let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n-                            let num_units = vector_type.get_num_units();\n-                            builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units])\n-                        }\n-                        else {\n-                            builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue()\n-                        };\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, first_arg);\n-                    }\n-                    else {\n-                        new_args.push(first_arg);\n-                    }\n-                    let arg4_index =\n-                        match &*func_name {\n-                            \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => 2,\n-                            _ => 3,\n-                        };\n-                    let arg4_type = gcc_func.get_param_type(arg4_index);\n-                    let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                    if add_before_last_arg {\n-                        new_args.insert(new_args.len() - 1, minus_one);\n-                    }\n-                    else {\n-                        new_args.push(minus_one);\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let first_arg = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pmaxuq256_mask\" | \"__builtin_ia32_pmaxuq128_mask\" | \"__builtin_ia32_pminuq256_mask\"\n+                | \"__builtin_ia32_pminuq128_mask\" | \"__builtin_ia32_prold256_mask\" | \"__builtin_ia32_prold128_mask\"\n+                | \"__builtin_ia32_prord512_mask\" | \"__builtin_ia32_prord256_mask\" | \"__builtin_ia32_prord128_mask\"\n+                | \"__builtin_ia32_prolq256_mask\" | \"__builtin_ia32_prolq128_mask\" | \"__builtin_ia32_prorq256_mask\"\n+                | \"__builtin_ia32_prorq128_mask\" | \"__builtin_ia32_psraq256_mask\" | \"__builtin_ia32_psraq128_mask\"\n+                | \"__builtin_ia32_psraqi256_mask\" | \"__builtin_ia32_psraqi128_mask\" | \"__builtin_ia32_psravq256_mask\"\n+                | \"__builtin_ia32_psravq128_mask\" | \"__builtin_ia32_prolvd256_mask\" | \"__builtin_ia32_prolvd128_mask\"\n+                | \"__builtin_ia32_prorvd256_mask\" | \"__builtin_ia32_prorvd128_mask\" | \"__builtin_ia32_prolvq256_mask\"\n+                | \"__builtin_ia32_prolvq128_mask\" | \"__builtin_ia32_prorvq256_mask\" | \"__builtin_ia32_prorvq128_mask\"\n+                | \"__builtin_ia32_permvardi256_mask\" | \"__builtin_ia32_permvardf512_mask\" | \"__builtin_ia32_permvardf256_mask\"\n+                | \"__builtin_ia32_pmulhuw512_mask\" | \"__builtin_ia32_pmulhw512_mask\" | \"__builtin_ia32_pmulhrsw512_mask\"\n+                | \"__builtin_ia32_pmaxuw512_mask\" | \"__builtin_ia32_pmaxub512_mask\" | \"__builtin_ia32_pmaxsw512_mask\"\n+                | \"__builtin_ia32_pmaxsb512_mask\" | \"__builtin_ia32_pminuw512_mask\" | \"__builtin_ia32_pminub512_mask\"\n+                | \"__builtin_ia32_pminsw512_mask\" | \"__builtin_ia32_pminsb512_mask\"\n+                | \"__builtin_ia32_pmaddwd512_mask\" | \"__builtin_ia32_pmaddubsw512_mask\" | \"__builtin_ia32_packssdw512_mask\"\n+                | \"__builtin_ia32_packsswb512_mask\" | \"__builtin_ia32_packusdw512_mask\" | \"__builtin_ia32_packuswb512_mask\"\n+                | \"__builtin_ia32_pavgw512_mask\" | \"__builtin_ia32_pavgb512_mask\" | \"__builtin_ia32_psllw512_mask\"\n+                | \"__builtin_ia32_psllwi512_mask\" | \"__builtin_ia32_psllv32hi_mask\" | \"__builtin_ia32_psrlw512_mask\"\n+                | \"__builtin_ia32_psrlwi512_mask\" | \"__builtin_ia32_psllv16hi_mask\" | \"__builtin_ia32_psllv8hi_mask\"\n+                | \"__builtin_ia32_psrlv32hi_mask\" | \"__builtin_ia32_psraw512_mask\" | \"__builtin_ia32_psrawi512_mask\"\n+                | \"__builtin_ia32_psrlv16hi_mask\" | \"__builtin_ia32_psrlv8hi_mask\" | \"__builtin_ia32_psrav32hi_mask\"\n+                | \"__builtin_ia32_permvarhi512_mask\" | \"__builtin_ia32_pshufb512_mask\" | \"__builtin_ia32_psrav16hi_mask\"\n+                | \"__builtin_ia32_psrav8hi_mask\" | \"__builtin_ia32_permvarhi256_mask\" | \"__builtin_ia32_permvarhi128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let vector_type = arg3_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg3_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_dbpsadbw512_mask\" | \"__builtin_ia32_dbpsadbw256_mask\" | \"__builtin_ia32_dbpsadbw128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let vector_type = arg4_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg4_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+                | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                // Remove last arg as it doesn't seem to be used in GCC and is always false.\n+                new_args.pop();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpconflictsi_512_mask\" | \"__builtin_ia32_vpconflictsi_256_mask\"\n+                | \"__builtin_ia32_vpconflictsi_128_mask\" | \"__builtin_ia32_vpconflictdi_512_mask\"\n+                | \"__builtin_ia32_vpconflictdi_256_mask\" | \"__builtin_ia32_vpconflictdi_128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let vector_type = arg2_type.dyncast_vector().expect(\"vector type\");\n+                let zero = builder.context.new_rvalue_zero(vector_type.get_element_type());\n+                let num_units = vector_type.get_num_units();\n+                let first_arg = builder.context.new_rvalue_from_vector(None, arg2_type, &vec![zero; num_units]);\n+                new_args.push(first_arg);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n+                | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n+                | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let arg5_type = gcc_func.get_param_type(4);\n+                let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+\n+                let mut last_arg = None;\n+                if args.len() == 4 {\n+                    last_arg = new_args.pop();\n+                }\n+\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+\n+                if args.len() == 3 {\n+                    // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n+                    // the same GCC intrinsic, but the former has 3 parameters and the\n+                    // latter has 4 so it doesn't require this additional argument.\n+                    let arg5_type = gcc_func.get_param_type(4);\n+                    new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n+                }\n+\n+                if let Some(last_arg) = last_arg {\n+                    new_args.push(last_arg);\n+                }\n+\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n+                | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n+                | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n+                | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n+                | \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n+                |  \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermi2vard512_mask\" | \"__builtin_ia32_vpermi2vard256_mask\"\n+                | \"__builtin_ia32_vpermi2vard128_mask\" | \"__builtin_ia32_vpermi2varq512_mask\"\n+                | \"__builtin_ia32_vpermi2varq256_mask\" | \"__builtin_ia32_vpermi2varq128_mask\"\n+                | \"__builtin_ia32_vpermi2varps512_mask\" | \"__builtin_ia32_vpermi2varps256_mask\"\n+                | \"__builtin_ia32_vpermi2varps128_mask\" | \"__builtin_ia32_vpermi2varpd512_mask\"\n+                | \"__builtin_ia32_vpermi2varpd256_mask\" | \"__builtin_ia32_vpermi2varpd128_mask\" | \"__builtin_ia32_vpmadd52huq512_mask\"\n+                | \"__builtin_ia32_vpmadd52luq512_mask\" | \"__builtin_ia32_vpmadd52huq256_mask\" | \"__builtin_ia32_vpmadd52luq256_mask\"\n+                | \"__builtin_ia32_vpmadd52huq128_mask\"\n+                => {\n+                let mut new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                new_args.push(minus_one);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\"\n+                | \"__builtin_ia32_sqrtps512_mask\" | \"__builtin_ia32_sqrtpd512_mask\" => {\n+                let mut new_args = args.to_vec();\n+                let last_arg = new_args.pop().expect(\"last arg\");\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let undefined = builder.current_func().new_local(None, arg2_type, \"undefined_for_intrinsic\").to_rvalue();\n+                new_args.push(undefined);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let minus_one = builder.context.new_rvalue_from_int(arg3_type, -1);\n+                new_args.push(minus_one);\n+                new_args.push(last_arg);\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_stmxcsr\" => {\n+                args = vec![].into();\n+            },\n+            \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+                let mut new_args = args.to_vec();\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let variable = builder.current_func().new_local(None, arg2_type, \"addcarryResult\");\n+                new_args.push(variable.get_address(None));\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_vpermt2varqi512_mask\" | \"__builtin_ia32_vpermt2varqi256_mask\"\n+                | \"__builtin_ia32_vpermt2varqi128_mask\" | \"__builtin_ia32_vpermt2varhi512_mask\"\n+                | \"__builtin_ia32_vpermt2varhi256_mask\" | \"__builtin_ia32_vpermt2varhi128_mask\"\n+                => {\n+                let new_args = args.to_vec();\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n+                args = vec![new_args[1], new_args[0], new_args[2], minus_one].into();\n+            },\n+            \"__builtin_ia32_xrstor\" | \"__builtin_ia32_xsavec\" => {\n+                let new_args = args.to_vec();\n+                let thirty_two = builder.context.new_rvalue_from_int(new_args[1].get_type(), 32);\n+                let arg2 = new_args[1] << thirty_two | new_args[2];\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg2 = builder.context.new_cast(None, arg2, arg2_type);\n+                args = vec![new_args[0], arg2].into();\n+            },\n+            \"__builtin_prefetch\" => {\n+                let mut new_args = args.to_vec();\n+                new_args.pop();\n+                args = new_args.into();\n+            },\n+            _ => (),\n+        }\n+    }\n+    else {\n+        match &*func_name {\n+            \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+                let new_args = args.to_vec();\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let arg3 = builder.context.new_cast(None, new_args[4], arg3_type);\n+                let arg4_type = gcc_func.get_param_type(3);\n+                let arg4 = builder.context.new_bitcast(None, new_args[2], arg4_type);\n+                args = vec![new_args[0], new_args[1], arg3, arg4, new_args[3], new_args[5]].into();\n+            },\n+            // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+            // FIXME: the intrinsics like _mm_mask_fmadd_sd should probably directly call the GCC\n+            // instrinsic to avoid this.\n+            \"__builtin_ia32_vfmaddss3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 4]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 4]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 4]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsd3_round\" => {\n+                let new_args = args.to_vec();\n+                let arg1_type = gcc_func.get_param_type(0);\n+                let arg2_type = gcc_func.get_param_type(1);\n+                let arg3_type = gcc_func.get_param_type(2);\n+                let a = builder.context.new_rvalue_from_vector(None, arg1_type, &[new_args[0]; 2]);\n+                let b = builder.context.new_rvalue_from_vector(None, arg2_type, &[new_args[1]; 2]);\n+                let c = builder.context.new_rvalue_from_vector(None, arg3_type, &[new_args[2]; 2]);\n+                args = vec![a, b, c, new_args[3]].into();\n+            },\n+            \"__builtin_ia32_vfmaddsubpd256\" | \"__builtin_ia32_vfmaddsubps\" | \"__builtin_ia32_vfmaddsubps256\"\n+                | \"__builtin_ia32_vfmaddsubpd\" => {\n+                if let Some(original_function_name) = original_function_name {\n+                    match &**original_function_name {\n+                        \"llvm.x86.fma.vfmsubadd.pd.256\" | \"llvm.x86.fma.vfmsubadd.ps\" | \"llvm.x86.fma.vfmsubadd.ps.256\"\n+                            | \"llvm.x86.fma.vfmsubadd.pd\" => {\n+                            // NOTE: since both llvm.x86.fma.vfmsubadd.ps and llvm.x86.fma.vfmaddsub.ps maps to\n+                            // __builtin_ia32_vfmaddsubps, only add minus if this comes from a\n+                            // subadd LLVM intrinsic, e.g. _mm256_fmsubadd_pd.\n+                            let mut new_args = args.to_vec();\n+                            let arg3 = &mut new_args[2];\n+                            *arg3 = builder.context.new_unary_op(None, UnaryOp::Minus, arg3.get_type(), *arg3);\n+                            args = new_args.into();\n+                        },\n+                        _ => (),\n                     }\n-                    args = new_args.into();\n-                },\n-                \"__builtin_ia32_pternlogd512_mask\" | \"__builtin_ia32_pternlogd256_mask\"\n-                    | \"__builtin_ia32_pternlogd128_mask\" | \"__builtin_ia32_pternlogq512_mask\"\n-                    | \"__builtin_ia32_pternlogq256_mask\" | \"__builtin_ia32_pternlogq128_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let arg5_type = gcc_func.get_param_type(4);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg5_type, -1);\n-                        new_args.push(minus_one);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-\n-                        let mut last_arg = None;\n-                        if args.len() == 4 {\n-                            last_arg = new_args.pop();\n-                        }\n-\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-\n-                        if args.len() == 3 {\n-                            // Both llvm.fma.v16f32 and llvm.x86.avx512.vfmadd.ps.512 maps to\n-                            // the same GCC intrinsic, but the former has 3 parameters and the\n-                            // latter has 4 so it doesn't require this additional argument.\n-                            let arg5_type = gcc_func.get_param_type(4);\n-                            new_args.push(builder.context.new_rvalue_from_int(arg5_type, 4));\n-                        }\n-\n-                        if let Some(last_arg) = last_arg {\n-                            new_args.push(last_arg);\n-                        }\n-\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n-                        | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n-                        | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n-                        | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg3_type = gcc_func.get_param_type(2);\n-                        let undefined = builder.current_func().new_local(None, arg3_type, \"undefined_for_intrinsic\").to_rvalue();\n-                        new_args.push(undefined);\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n-                        let mut new_args = args.to_vec();\n-                        let last_arg = new_args.pop().expect(\"last arg\");\n-                        let arg4_type = gcc_func.get_param_type(3);\n-                        let minus_one = builder.context.new_rvalue_from_int(arg4_type, -1);\n-                        new_args.push(minus_one);\n-                        new_args.push(last_arg);\n-                        args = new_args.into();\n-                    },\n-                    _ => (),\n+                }\n+            },\n+            \"__builtin_ia32_ldmxcsr\" => {\n+                // The builtin __builtin_ia32_ldmxcsr takes an integer value while llvm.x86.sse.ldmxcsr takes a pointer,\n+                // so dereference the pointer.\n+                let mut new_args = args.to_vec();\n+                let uint_ptr_type = builder.uint_type.make_pointer();\n+                let arg1 = builder.context.new_cast(None, args[0], uint_ptr_type);\n+                new_args[0] = arg1.dereference(None).to_rvalue();\n+                args = new_args.into();\n+            },\n+            \"__builtin_ia32_rcp14sd_mask\" | \"__builtin_ia32_rcp14ss_mask\" | \"__builtin_ia32_rsqrt14sd_mask\"\n+                | \"__builtin_ia32_rsqrt14ss_mask\" => {\n+                let new_args = args.to_vec();\n+                args = vec![new_args[1], new_args[0], new_args[2], new_args[3]].into();\n+            },\n+            \"__builtin_ia32_sqrtsd_mask_round\" | \"__builtin_ia32_sqrtss_mask_round\" => {\n+                let new_args = args.to_vec();\n+                args = vec![new_args[1], new_args[0], new_args[2], new_args[3], new_args[4]].into();\n+            },\n+            _ => (),\n         }\n     }\n \n     args\n }\n \n+pub fn adjust_intrinsic_return_value<'a, 'gcc, 'tcx>(builder: &Builder<'a, 'gcc, 'tcx>, mut return_value: RValue<'gcc>, func_name: &str, args: &[RValue<'gcc>], args_adjusted: bool, orig_args: &[RValue<'gcc>]) -> RValue<'gcc> {\n+    match func_name {\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => {\n+            #[cfg(feature=\"master\")]\n+            {\n+                let zero = builder.context.new_rvalue_zero(builder.int_type);\n+                return_value = builder.context.new_vector_access(None, return_value, zero).to_rvalue();\n+            }\n+        },\n+        \"__builtin_ia32_addcarryx_u64\" | \"__builtin_ia32_sbb_u64\" | \"__builtin_ia32_addcarryx_u32\" | \"__builtin_ia32_sbb_u32\" => {\n+            // Both llvm.x86.addcarry.32 and llvm.x86.addcarryx.u32 points to the same GCC builtin,\n+            // but only the former requires adjusting the return value.\n+            // Those 2 LLVM intrinsics differ by their argument count, that's why we check if the\n+            // arguments were adjusted.\n+            if args_adjusted {\n+                let last_arg = args.last().expect(\"last arg\");\n+                let field1 = builder.context.new_field(None, builder.u8_type, \"carryFlag\");\n+                let field2 = builder.context.new_field(None, args[1].get_type(), \"carryResult\");\n+                let struct_type = builder.context.new_struct_type(None, \"addcarryResult\", &[field1, field2]);\n+                return_value = builder.context.new_struct_constructor(None, struct_type.as_type(), None, &[return_value, last_arg.dereference(None).to_rvalue()]);\n+            }\n+        },\n+        \"__builtin_ia32_stmxcsr\" => {\n+            // The builtin __builtin_ia32_stmxcsr returns a value while llvm.x86.sse.stmxcsr writes\n+            // the result in its pointer argument.\n+            // We removed the argument since __builtin_ia32_stmxcsr takes no arguments, so we need\n+            // to get back the original argument to get the pointer we need to write the result to.\n+            let uint_ptr_type = builder.uint_type.make_pointer();\n+            let ptr = builder.context.new_cast(None, orig_args[0], uint_ptr_type);\n+            builder.llbb().add_assignment(None, ptr.dereference(None), return_value);\n+            // The return value was assigned to the result pointer above. In order to not call the\n+            // builtin twice, we overwrite the return value with a dummy value.\n+            return_value = builder.context.new_rvalue_zero(builder.int_type);\n+        },\n+        _ => (),\n+    }\n+\n+    return_value\n+}\n+\n pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n-    // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n-    // last argument type check.\n     // FIXME(antoyo): find a way to refactor in order to avoid this hack.\n     match func_name {\n+        // NOTE: these intrinsics have missing parameters before the last one, so ignore the\n+        // last argument type check.\n         \"__builtin_ia32_maxps512_mask\" | \"__builtin_ia32_maxpd512_mask\"\n             | \"__builtin_ia32_minps512_mask\" | \"__builtin_ia32_minpd512_mask\" | \"__builtin_ia32_sqrtps512_mask\"\n             | \"__builtin_ia32_sqrtpd512_mask\" | \"__builtin_ia32_addps512_mask\" | \"__builtin_ia32_addpd512_mask\"\n             | \"__builtin_ia32_subps512_mask\" | \"__builtin_ia32_subpd512_mask\"\n             | \"__builtin_ia32_mulps512_mask\" | \"__builtin_ia32_mulpd512_mask\"\n             | \"__builtin_ia32_divps512_mask\" | \"__builtin_ia32_divpd512_mask\"\n-            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\" => {\n+            | \"__builtin_ia32_vfmaddsubps512_mask\" | \"__builtin_ia32_vfmaddsubpd512_mask\"\n+            | \"__builtin_ia32_cvtdq2ps512_mask\" | \"__builtin_ia32_cvtudq2ps512_mask\" => {\n                 if index == args_len - 1 {\n                     return true;\n                 }\n             },\n+        \"__builtin_ia32_rndscaless_mask_round\" | \"__builtin_ia32_rndscalesd_mask_round\" => {\n+            if index == 2 || index == 3 {\n+                return true;\n+            }\n+        },\n         \"__builtin_ia32_vfmaddps512_mask\" | \"__builtin_ia32_vfmaddpd512_mask\" => {\n             // Since there are two LLVM intrinsics that map to each of these GCC builtins and only\n             // one of them has a missing parameter before the last one, we check the number of\n@@ -162,6 +390,14 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n                 return true;\n             }\n         },\n+        // NOTE: the LLVM intrinsic receives 3 floats, but the GCC builtin requires 3 vectors.\n+        \"__builtin_ia32_vfmaddss3_round\" | \"__builtin_ia32_vfmaddsd3_round\" => return true,\n+        \"__builtin_ia32_vplzcntd_512_mask\" | \"__builtin_ia32_vplzcntd_256_mask\" | \"__builtin_ia32_vplzcntd_128_mask\"\n+            | \"__builtin_ia32_vplzcntq_512_mask\" | \"__builtin_ia32_vplzcntq_256_mask\" | \"__builtin_ia32_vplzcntq_128_mask\" => {\n+            if index == args_len - 1 {\n+                return true;\n+            }\n+        },\n         _ => (),\n     }\n \n@@ -171,7 +407,7 @@ pub fn ignore_arg_cast(func_name: &str, index: usize, args_len: usize) -> bool {\n #[cfg(not(feature=\"master\"))]\n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n     match name {\n-        \"llvm.x86.xgetbv\" => {\n+        \"llvm.x86.xgetbv\" | \"llvm.x86.sse2.pause\" => {\n             let gcc_name = \"__builtin_trap\";\n             let func = cx.context.get_builtin_function(gcc_name);\n             cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n@@ -183,24 +419,26 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n \n #[cfg(feature=\"master\")]\n pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function<'gcc> {\n+    match name {\n+        \"llvm.prefetch\" => {\n+            let gcc_name = \"__builtin_prefetch\";\n+            let func = cx.context.get_builtin_function(gcc_name);\n+            cx.functions.borrow_mut().insert(gcc_name.to_string(), func);\n+            return func\n+        },\n+        _ => (),\n+    }\n+\n     let gcc_name = match name {\n         \"llvm.x86.xgetbv\" => \"__builtin_ia32_xgetbv\",\n         // NOTE: this doc specifies the equivalent GCC builtins: http://huonw.github.io/llvmint/llvmint/x86/index.html\n         \"llvm.sqrt.v2f64\" => \"__builtin_ia32_sqrtpd\",\n         \"llvm.x86.avx512.pmul.dq.512\" => \"__builtin_ia32_pmuldq512_mask\",\n         \"llvm.x86.avx512.pmulu.dq.512\" => \"__builtin_ia32_pmuludq512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.256\" => \"__builtin_ia32_pmaxsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxs.q.128\" => \"__builtin_ia32_pmaxsq128_mask\",\n         \"llvm.x86.avx512.max.ps.512\" => \"__builtin_ia32_maxps512_mask\",\n         \"llvm.x86.avx512.max.pd.512\" => \"__builtin_ia32_maxpd512_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.256\" => \"__builtin_ia32_pmaxuq256_mask\",\n-        \"llvm.x86.avx512.mask.pmaxu.q.128\" => \"__builtin_ia32_pmaxuq128_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.256\" => \"__builtin_ia32_pminsq256_mask\",\n-        \"llvm.x86.avx512.mask.pmins.q.128\" => \"__builtin_ia32_pminsq128_mask\",\n         \"llvm.x86.avx512.min.ps.512\" => \"__builtin_ia32_minps512_mask\",\n         \"llvm.x86.avx512.min.pd.512\" => \"__builtin_ia32_minpd512_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.256\" => \"__builtin_ia32_pminuq256_mask\",\n-        \"llvm.x86.avx512.mask.pminu.q.128\" => \"__builtin_ia32_pminuq128_mask\",\n         \"llvm.fma.v16f32\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.fma.v8f64\" => \"__builtin_ia32_vfmaddpd512_mask\",\n         \"llvm.x86.avx512.vfmaddsub.ps.512\" => \"__builtin_ia32_vfmaddsubps512_mask\",\n@@ -221,6 +459,153 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx512.div.pd.512\" => \"__builtin_ia32_divpd512_mask\",\n         \"llvm.x86.avx512.vfmadd.ps.512\" => \"__builtin_ia32_vfmaddps512_mask\",\n         \"llvm.x86.avx512.vfmadd.pd.512\" => \"__builtin_ia32_vfmaddpd512_mask\",\n+        \"llvm.x86.avx512.sitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtdq2ps512_mask\",\n+        \"llvm.x86.avx512.uitofp.round.v16f32.v16i32\" => \"__builtin_ia32_cvtudq2ps512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.512\" => \"__builtin_ia32_ucmpd512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.256\" => \"__builtin_ia32_ucmpd256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.d.128\" => \"__builtin_ia32_ucmpd128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.512\" => \"__builtin_ia32_cmpd512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.256\" => \"__builtin_ia32_cmpd256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.d.128\" => \"__builtin_ia32_cmpd128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.512\" => \"__builtin_ia32_ucmpq512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.256\" => \"__builtin_ia32_ucmpq256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.q.128\" => \"__builtin_ia32_ucmpq128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.512\" => \"__builtin_ia32_cmpq512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.256\" => \"__builtin_ia32_cmpq256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.q.128\" => \"__builtin_ia32_cmpq128_mask\",\n+        \"llvm.x86.avx512.mask.max.ss.round\" => \"__builtin_ia32_maxss_mask_round\",\n+        \"llvm.x86.avx512.mask.max.sd.round\" => \"__builtin_ia32_maxsd_mask_round\",\n+        \"llvm.x86.avx512.mask.min.ss.round\" => \"__builtin_ia32_minss_mask_round\",\n+        \"llvm.x86.avx512.mask.min.sd.round\" => \"__builtin_ia32_minsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.ss\" => \"__builtin_ia32_sqrtss_mask_round\",\n+        \"llvm.x86.avx512.mask.sqrt.sd\" => \"__builtin_ia32_sqrtsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.ss\" => \"__builtin_ia32_getexpss_mask_round\",\n+        \"llvm.x86.avx512.mask.getexp.sd\" => \"__builtin_ia32_getexpsd_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.ss\" => \"__builtin_ia32_getmantss_mask_round\",\n+        \"llvm.x86.avx512.mask.getmant.sd\" => \"__builtin_ia32_getmantsd_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.ss\" => \"__builtin_ia32_rndscaless_mask_round\",\n+        \"llvm.x86.avx512.mask.rndscale.sd\" => \"__builtin_ia32_rndscalesd_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.ss\" => \"__builtin_ia32_scalefss_mask_round\",\n+        \"llvm.x86.avx512.mask.scalef.sd\" => \"__builtin_ia32_scalefsd_mask_round\",\n+        \"llvm.x86.avx512.vfmadd.f32\" => \"__builtin_ia32_vfmaddss3_round\",\n+        \"llvm.x86.avx512.vfmadd.f64\" => \"__builtin_ia32_vfmaddsd3_round\",\n+        \"llvm.ceil.v4f64\" => \"__builtin_ia32_ceilpd256\",\n+        \"llvm.ceil.v8f32\" => \"__builtin_ia32_ceilps256\",\n+        \"llvm.floor.v4f64\" => \"__builtin_ia32_floorpd256\",\n+        \"llvm.floor.v8f32\" => \"__builtin_ia32_floorps256\",\n+        \"llvm.sqrt.v4f64\" => \"__builtin_ia32_sqrtpd256\",\n+        \"llvm.x86.sse.stmxcsr\" => \"__builtin_ia32_stmxcsr\",\n+        \"llvm.x86.sse.ldmxcsr\" => \"__builtin_ia32_ldmxcsr\",\n+        \"llvm.ctpop.v16i32\" => \"__builtin_ia32_vpopcountd_v16si\",\n+        \"llvm.ctpop.v8i32\" => \"__builtin_ia32_vpopcountd_v8si\",\n+        \"llvm.ctpop.v4i32\" => \"__builtin_ia32_vpopcountd_v4si\",\n+        \"llvm.ctpop.v8i64\" => \"__builtin_ia32_vpopcountq_v8di\",\n+        \"llvm.ctpop.v4i64\" => \"__builtin_ia32_vpopcountq_v4di\",\n+        \"llvm.ctpop.v2i64\" => \"__builtin_ia32_vpopcountq_v2di\",\n+        \"llvm.x86.addcarry.64\" => \"__builtin_ia32_addcarryx_u64\",\n+        \"llvm.x86.subborrow.64\" => \"__builtin_ia32_sbb_u64\",\n+        \"llvm.floor.v2f64\" => \"__builtin_ia32_floorpd\",\n+        \"llvm.floor.v4f32\" => \"__builtin_ia32_floorps\",\n+        \"llvm.ceil.v2f64\" => \"__builtin_ia32_ceilpd\",\n+        \"llvm.ceil.v4f32\" => \"__builtin_ia32_ceilps\",\n+        \"llvm.fma.v2f64\" => \"__builtin_ia32_vfmaddpd\",\n+        \"llvm.fma.v4f64\" => \"__builtin_ia32_vfmaddpd256\",\n+        \"llvm.fma.v4f32\" => \"__builtin_ia32_vfmaddps\",\n+        \"llvm.fma.v8f32\" => \"__builtin_ia32_vfmaddps256\",\n+        \"llvm.ctlz.v16i32\" => \"__builtin_ia32_vplzcntd_512_mask\",\n+        \"llvm.ctlz.v8i32\" => \"__builtin_ia32_vplzcntd_256_mask\",\n+        \"llvm.ctlz.v4i32\" => \"__builtin_ia32_vplzcntd_128_mask\",\n+        \"llvm.ctlz.v8i64\" => \"__builtin_ia32_vplzcntq_512_mask\",\n+        \"llvm.ctlz.v4i64\" => \"__builtin_ia32_vplzcntq_256_mask\",\n+        \"llvm.ctlz.v2i64\" => \"__builtin_ia32_vplzcntq_128_mask\",\n+        \"llvm.ctpop.v32i16\" => \"__builtin_ia32_vpopcountw_v32hi\",\n+        \"llvm.x86.fma.vfmsub.sd\" => \"__builtin_ia32_vfmsubsd3\",\n+        \"llvm.x86.fma.vfmsub.ss\" => \"__builtin_ia32_vfmsubss3\",\n+        \"llvm.x86.fma.vfmsubadd.pd\" => \"__builtin_ia32_vfmaddsubpd\",\n+        \"llvm.x86.fma.vfmsubadd.pd.256\" => \"__builtin_ia32_vfmaddsubpd256\",\n+        \"llvm.x86.fma.vfmsubadd.ps\" => \"__builtin_ia32_vfmaddsubps\",\n+        \"llvm.x86.fma.vfmsubadd.ps.256\" => \"__builtin_ia32_vfmaddsubps256\",\n+        \"llvm.x86.fma.vfnmadd.sd\" => \"__builtin_ia32_vfnmaddsd3\",\n+        \"llvm.x86.fma.vfnmadd.ss\" => \"__builtin_ia32_vfnmaddss3\",\n+        \"llvm.x86.fma.vfnmsub.sd\" => \"__builtin_ia32_vfnmsubsd3\",\n+        \"llvm.x86.fma.vfnmsub.ss\" => \"__builtin_ia32_vfnmsubss3\",\n+        \"llvm.x86.avx512.conflict.d.512\" => \"__builtin_ia32_vpconflictsi_512_mask\",\n+        \"llvm.x86.avx512.conflict.d.256\" => \"__builtin_ia32_vpconflictsi_256_mask\",\n+        \"llvm.x86.avx512.conflict.d.128\" => \"__builtin_ia32_vpconflictsi_128_mask\",\n+        \"llvm.x86.avx512.conflict.q.512\" => \"__builtin_ia32_vpconflictdi_512_mask\",\n+        \"llvm.x86.avx512.conflict.q.256\" => \"__builtin_ia32_vpconflictdi_256_mask\",\n+        \"llvm.x86.avx512.conflict.q.128\" => \"__builtin_ia32_vpconflictdi_128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.512\" => \"__builtin_ia32_vpermt2varqi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.256\" => \"__builtin_ia32_vpermt2varqi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.qi.128\" => \"__builtin_ia32_vpermt2varqi128_mask\",\n+        \"llvm.x86.avx512.permvar.qi.512\" => \"__builtin_ia32_permvarqi512_mask\",\n+        \"llvm.x86.avx512.permvar.qi.256\" => \"__builtin_ia32_permvarqi256_mask\",\n+        \"llvm.x86.avx512.permvar.qi.128\" => \"__builtin_ia32_permvarqi128_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.512\" => \"__builtin_ia32_vpmultishiftqb512_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.256\" => \"__builtin_ia32_vpmultishiftqb256_mask\",\n+        \"llvm.x86.avx512.pmultishift.qb.128\" => \"__builtin_ia32_vpmultishiftqb128_mask\",\n+        \"llvm.ctpop.v16i16\" => \"__builtin_ia32_vpopcountw_v16hi\",\n+        \"llvm.ctpop.v8i16\" => \"__builtin_ia32_vpopcountw_v8hi\",\n+        \"llvm.ctpop.v64i8\" => \"__builtin_ia32_vpopcountb_v64qi\",\n+        \"llvm.ctpop.v32i8\" => \"__builtin_ia32_vpopcountb_v32qi\",\n+        \"llvm.ctpop.v16i8\" => \"__builtin_ia32_vpopcountb_v16qi\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.512\" => \"__builtin_ia32_vpshufbitqmb512_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.256\" => \"__builtin_ia32_vpshufbitqmb256_mask\",\n+        \"llvm.x86.avx512.mask.vpshufbitqmb.128\" => \"__builtin_ia32_vpshufbitqmb128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.512\" => \"__builtin_ia32_ucmpw512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.256\" => \"__builtin_ia32_ucmpw256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.w.128\" => \"__builtin_ia32_ucmpw128_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.512\" => \"__builtin_ia32_ucmpb512_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.256\" => \"__builtin_ia32_ucmpb256_mask\",\n+        \"llvm.x86.avx512.mask.ucmp.b.128\" => \"__builtin_ia32_ucmpb128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.512\" => \"__builtin_ia32_cmpw512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.256\" => \"__builtin_ia32_cmpw256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.w.128\" => \"__builtin_ia32_cmpw128_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.512\" => \"__builtin_ia32_cmpb512_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.256\" => \"__builtin_ia32_cmpb256_mask\",\n+        \"llvm.x86.avx512.mask.cmp.b.128\" => \"__builtin_ia32_cmpb128_mask\",\n+        \"llvm.x86.xrstor\" => \"__builtin_ia32_xrstor\",\n+        \"llvm.x86.xsavec\" => \"__builtin_ia32_xsavec\",\n+        \"llvm.x86.addcarry.32\" => \"__builtin_ia32_addcarryx_u32\",\n+        \"llvm.x86.subborrow.32\" => \"__builtin_ia32_sbb_u32\",\n+        \"llvm.x86.avx512.mask.compress.store.w.512\" => \"__builtin_ia32_compressstoreuhi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.256\" => \"__builtin_ia32_compressstoreuhi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.w.128\" => \"__builtin_ia32_compressstoreuhi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.512\" => \"__builtin_ia32_compressstoreuqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.256\" => \"__builtin_ia32_compressstoreuqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.store.b.128\" => \"__builtin_ia32_compressstoreuqi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.512\" => \"__builtin_ia32_compresshi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.256\" => \"__builtin_ia32_compresshi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.w.128\" => \"__builtin_ia32_compresshi128_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.512\" => \"__builtin_ia32_compressqi512_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.256\" => \"__builtin_ia32_compressqi256_mask\",\n+        \"llvm.x86.avx512.mask.compress.b.128\" => \"__builtin_ia32_compressqi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.512\" => \"__builtin_ia32_expandhi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.256\" => \"__builtin_ia32_expandhi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.w.128\" => \"__builtin_ia32_expandhi128_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.512\" => \"__builtin_ia32_expandqi512_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.256\" => \"__builtin_ia32_expandqi256_mask\",\n+        \"llvm.x86.avx512.mask.expand.b.128\" => \"__builtin_ia32_expandqi128_mask\",\n+        \"llvm.fshl.v8i64\" => \"__builtin_ia32_vpshldv_v8di\",\n+        \"llvm.fshl.v4i64\" => \"__builtin_ia32_vpshldv_v4di\",\n+        \"llvm.fshl.v2i64\" => \"__builtin_ia32_vpshldv_v2di\",\n+        \"llvm.fshl.v16i32\" => \"__builtin_ia32_vpshldv_v16si\",\n+        \"llvm.fshl.v8i32\" => \"__builtin_ia32_vpshldv_v8si\",\n+        \"llvm.fshl.v4i32\" => \"__builtin_ia32_vpshldv_v4si\",\n+        \"llvm.fshl.v32i16\" => \"__builtin_ia32_vpshldv_v32hi\",\n+        \"llvm.fshl.v16i16\" => \"__builtin_ia32_vpshldv_v16hi\",\n+        \"llvm.fshl.v8i16\" => \"__builtin_ia32_vpshldv_v8hi\",\n+        \"llvm.fshr.v8i64\" => \"__builtin_ia32_vpshrdv_v8di\",\n+        \"llvm.fshr.v4i64\" => \"__builtin_ia32_vpshrdv_v4di\",\n+        \"llvm.fshr.v2i64\" => \"__builtin_ia32_vpshrdv_v2di\",\n+        \"llvm.fshr.v16i32\" => \"__builtin_ia32_vpshrdv_v16si\",\n+        \"llvm.fshr.v8i32\" => \"__builtin_ia32_vpshrdv_v8si\",\n+        \"llvm.fshr.v4i32\" => \"__builtin_ia32_vpshrdv_v4si\",\n+        \"llvm.fshr.v32i16\" => \"__builtin_ia32_vpshrdv_v32hi\",\n+        \"llvm.fshr.v16i16\" => \"__builtin_ia32_vpshrdv_v16hi\",\n+        \"llvm.fshr.v8i16\" => \"__builtin_ia32_vpshrdv_v8hi\",\n+        \"llvm.x86.fma.vfmadd.sd\" => \"__builtin_ia32_vfmaddsd3\",\n+        \"llvm.x86.fma.vfmadd.ss\" => \"__builtin_ia32_vfmaddss3\",\n \n         // The above doc points to unknown builtins for the following, so override them:\n         \"llvm.x86.avx2.gather.d.d\" => \"__builtin_ia32_gathersiv4si\",\n@@ -239,7 +624,151 @@ pub fn intrinsic<'gcc, 'tcx>(name: &str, cx: &CodegenCx<'gcc, 'tcx>) -> Function\n         \"llvm.x86.avx2.gather.q.q.256\" => \"__builtin_ia32_gatherdiv4di\",\n         \"llvm.x86.avx2.gather.q.pd\" => \"__builtin_ia32_gatherdiv2df\",\n         \"llvm.x86.avx2.gather.q.pd.256\" => \"__builtin_ia32_gatherdiv4df\",\n-        \"\" => \"\",\n+        \"llvm.x86.avx512.pslli.d.512\" => \"__builtin_ia32_pslldi512_mask\",\n+        \"llvm.x86.avx512.psrli.d.512\" => \"__builtin_ia32_psrldi512_mask\",\n+        \"llvm.x86.avx512.pslli.q.512\" => \"__builtin_ia32_psllqi512_mask\",\n+        \"llvm.x86.avx512.psrli.q.512\" => \"__builtin_ia32_psrlqi512_mask\",\n+        \"llvm.x86.avx512.psll.d.512\" => \"__builtin_ia32_pslld512_mask\",\n+        \"llvm.x86.avx512.psrl.d.512\" => \"__builtin_ia32_psrld512_mask\",\n+        \"llvm.x86.avx512.psll.q.512\" => \"__builtin_ia32_psllq512_mask\",\n+        \"llvm.x86.avx512.psrl.q.512\" => \"__builtin_ia32_psrlq512_mask\",\n+        \"llvm.x86.avx512.psra.d.512\" => \"__builtin_ia32_psrad512_mask\",\n+        \"llvm.x86.avx512.psra.q.512\" => \"__builtin_ia32_psraq512_mask\",\n+        \"llvm.x86.avx512.psra.q.256\" => \"__builtin_ia32_psraq256_mask\",\n+        \"llvm.x86.avx512.psra.q.128\" => \"__builtin_ia32_psraq128_mask\",\n+        \"llvm.x86.avx512.psrai.d.512\" => \"__builtin_ia32_psradi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.512\" => \"__builtin_ia32_psraqi512_mask\",\n+        \"llvm.x86.avx512.psrai.q.256\" => \"__builtin_ia32_psraqi256_mask\",\n+        \"llvm.x86.avx512.psrai.q.128\" => \"__builtin_ia32_psraqi128_mask\",\n+        \"llvm.x86.avx512.psrav.d.512\" => \"__builtin_ia32_psrav16si_mask\",\n+        \"llvm.x86.avx512.psrav.q.512\" => \"__builtin_ia32_psrav8di_mask\",\n+        \"llvm.x86.avx512.psrav.q.256\" => \"__builtin_ia32_psravq256_mask\",\n+        \"llvm.x86.avx512.psrav.q.128\" => \"__builtin_ia32_psravq128_mask\",\n+        \"llvm.x86.avx512.psllv.d.512\" => \"__builtin_ia32_psllv16si_mask\",\n+        \"llvm.x86.avx512.psrlv.d.512\" => \"__builtin_ia32_psrlv16si_mask\",\n+        \"llvm.x86.avx512.psllv.q.512\" => \"__builtin_ia32_psllv8di_mask\",\n+        \"llvm.x86.avx512.psrlv.q.512\" => \"__builtin_ia32_psrlv8di_mask\",\n+        \"llvm.x86.avx512.permvar.si.512\" => \"__builtin_ia32_permvarsi512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.ps.512\" => \"__builtin_ia32_vpermilvarps512_mask\",\n+        \"llvm.x86.avx512.vpermilvar.pd.512\" => \"__builtin_ia32_vpermilvarpd512_mask\",\n+        \"llvm.x86.avx512.permvar.di.512\" => \"__builtin_ia32_permvardi512_mask\",\n+        \"llvm.x86.avx512.permvar.di.256\" => \"__builtin_ia32_permvardi256_mask\",\n+        \"llvm.x86.avx512.permvar.sf.512\" => \"__builtin_ia32_permvarsf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.512\" => \"__builtin_ia32_permvardf512_mask\",\n+        \"llvm.x86.avx512.permvar.df.256\" => \"__builtin_ia32_permvardf256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.512\" => \"__builtin_ia32_vpermi2vard512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.256\" => \"__builtin_ia32_vpermi2vard256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.d.128\" => \"__builtin_ia32_vpermi2vard128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.512\" => \"__builtin_ia32_vpermi2varq512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.256\" => \"__builtin_ia32_vpermi2varq256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.q.128\" => \"__builtin_ia32_vpermi2varq128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.512\" => \"__builtin_ia32_vpermi2varps512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.256\" => \"__builtin_ia32_vpermi2varps256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.ps.128\" => \"__builtin_ia32_vpermi2varps128_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.512\" => \"__builtin_ia32_vpermi2varpd512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.256\" => \"__builtin_ia32_vpermi2varpd256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.pd.128\" => \"__builtin_ia32_vpermi2varpd128_mask\",\n+        \"llvm.x86.avx512.mask.add.ss.round\" => \"__builtin_ia32_addss_mask_round\",\n+        \"llvm.x86.avx512.mask.add.sd.round\" => \"__builtin_ia32_addsd_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.ss.round\" => \"__builtin_ia32_subss_mask_round\",\n+        \"llvm.x86.avx512.mask.sub.sd.round\" => \"__builtin_ia32_subsd_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.ss.round\" => \"__builtin_ia32_mulss_mask_round\",\n+        \"llvm.x86.avx512.mask.mul.sd.round\" => \"__builtin_ia32_mulsd_mask_round\",\n+        \"llvm.x86.avx512.mask.div.ss.round\" => \"__builtin_ia32_divss_mask_round\",\n+        \"llvm.x86.avx512.mask.div.sd.round\" => \"__builtin_ia32_divsd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtss2sd.round\" => \"__builtin_ia32_cvtss2sd_mask_round\",\n+        \"llvm.x86.avx512.mask.cvtsd2ss.round\" => \"__builtin_ia32_cvtsd2ss_mask_round\",\n+        \"llvm.x86.avx512.mask.range.ss\" => \"__builtin_ia32_rangess128_mask_round\",\n+        \"llvm.x86.avx512.mask.range.sd\" => \"__builtin_ia32_rangesd128_mask_round\",\n+        \"llvm.x86.avx512.rcp28.ss\" => \"__builtin_ia32_rcp28ss_mask_round\",\n+        \"llvm.x86.avx512.rcp28.sd\" => \"__builtin_ia32_rcp28sd_mask_round\",\n+        \"llvm.x86.avx512.rsqrt28.ss\" => \"__builtin_ia32_rsqrt28ss_mask_round\",\n+        \"llvm.x86.avx512.rsqrt28.sd\" => \"__builtin_ia32_rsqrt28sd_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.add.sh.round\" => \"__builtin_ia32_addsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.div.sh.round\" => \"__builtin_ia32_divsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.getmant.sh\" => \"__builtin_ia32_getmantsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.max.sh.round\" => \"__builtin_ia32_maxsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.min.sh.round\" => \"__builtin_ia32_minsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.mul.sh.round\" => \"__builtin_ia32_mulsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.rndscale.sh\" => \"__builtin_ia32_rndscalesh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.scalef.sh\" => \"__builtin_ia32_scalefsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.sub.sh.round\" => \"__builtin_ia32_subsh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsd2sh.round\" => \"__builtin_ia32_vcvtsd2sh_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsh2sd.round\" => \"__builtin_ia32_vcvtsh2sd_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtsh2ss.round\" => \"__builtin_ia32_vcvtsh2ss_mask_round\",\n+        \"llvm.x86.avx512fp16.mask.vcvtss2sh.round\" => \"__builtin_ia32_vcvtss2sh_mask_round\",\n+        \"llvm.x86.aesni.aesenc.256\" => \"__builtin_ia32_vaesenc_v32qi\",\n+        \"llvm.x86.aesni.aesenclast.256\" => \"__builtin_ia32_vaesenclast_v32qi\",\n+        \"llvm.x86.aesni.aesdec.256\" => \"__builtin_ia32_vaesdec_v32qi\",\n+        \"llvm.x86.aesni.aesdeclast.256\" => \"__builtin_ia32_vaesdeclast_v32qi\",\n+        \"llvm.x86.aesni.aesenc.512\" => \"__builtin_ia32_vaesenc_v64qi\",\n+        \"llvm.x86.aesni.aesenclast.512\" => \"__builtin_ia32_vaesenclast_v64qi\",\n+        \"llvm.x86.aesni.aesdec.512\" => \"__builtin_ia32_vaesdec_v64qi\",\n+        \"llvm.x86.aesni.aesdeclast.512\" => \"__builtin_ia32_vaesdeclast_v64qi\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.128\" => \"__builtin_ia32_cvtne2ps2bf16_v8bf\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.256\" => \"__builtin_ia32_cvtne2ps2bf16_v16bf\",\n+        \"llvm.x86.avx512bf16.cvtne2ps2bf16.512\" => \"__builtin_ia32_cvtne2ps2bf16_v32bf\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.256\" => \"__builtin_ia32_cvtneps2bf16_v8sf\",\n+        \"llvm.x86.avx512bf16.cvtneps2bf16.512\" => \"__builtin_ia32_cvtneps2bf16_v16sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.128\" => \"__builtin_ia32_dpbf16ps_v4sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.256\" => \"__builtin_ia32_dpbf16ps_v8sf\",\n+        \"llvm.x86.avx512bf16.dpbf16ps.512\" => \"__builtin_ia32_dpbf16ps_v16sf\",\n+        \"llvm.x86.pclmulqdq.512\" => \"__builtin_ia32_vpclmulqdq_v8di\",\n+        \"llvm.x86.pclmulqdq.256\" => \"__builtin_ia32_vpclmulqdq_v4di\",\n+        \"llvm.x86.avx512.pmulhu.w.512\" => \"__builtin_ia32_pmulhuw512_mask\",\n+        \"llvm.x86.avx512.pmulh.w.512\" => \"__builtin_ia32_pmulhw512_mask\",\n+        \"llvm.x86.avx512.pmul.hr.sw.512\" => \"__builtin_ia32_pmulhrsw512_mask\",\n+        \"llvm.x86.avx512.pmaddw.d.512\" => \"__builtin_ia32_pmaddwd512_mask\",\n+        \"llvm.x86.avx512.pmaddubs.w.512\" => \"__builtin_ia32_pmaddubsw512_mask\",\n+        \"llvm.x86.avx512.packssdw.512\" => \"__builtin_ia32_packssdw512_mask\",\n+        \"llvm.x86.avx512.packsswb.512\" => \"__builtin_ia32_packsswb512_mask\",\n+        \"llvm.x86.avx512.packusdw.512\" => \"__builtin_ia32_packusdw512_mask\",\n+        \"llvm.x86.avx512.packuswb.512\" => \"__builtin_ia32_packuswb512_mask\",\n+        \"llvm.x86.avx512.pavg.w.512\" => \"__builtin_ia32_pavgw512_mask\",\n+        \"llvm.x86.avx512.pavg.b.512\" => \"__builtin_ia32_pavgb512_mask\",\n+        \"llvm.x86.avx512.psll.w.512\" => \"__builtin_ia32_psllw512_mask\",\n+        \"llvm.x86.avx512.pslli.w.512\" => \"__builtin_ia32_psllwi512_mask\",\n+        \"llvm.x86.avx512.psllv.w.512\" => \"__builtin_ia32_psllv32hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.256\" => \"__builtin_ia32_psllv16hi_mask\",\n+        \"llvm.x86.avx512.psllv.w.128\" => \"__builtin_ia32_psllv8hi_mask\",\n+        \"llvm.x86.avx512.psrl.w.512\" => \"__builtin_ia32_psrlw512_mask\",\n+        \"llvm.x86.avx512.psrli.w.512\" => \"__builtin_ia32_psrlwi512_mask\",\n+        \"llvm.x86.avx512.psrlv.w.512\" => \"__builtin_ia32_psrlv32hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.256\" => \"__builtin_ia32_psrlv16hi_mask\",\n+        \"llvm.x86.avx512.psrlv.w.128\" => \"__builtin_ia32_psrlv8hi_mask\",\n+        \"llvm.x86.avx512.psra.w.512\" => \"__builtin_ia32_psraw512_mask\",\n+        \"llvm.x86.avx512.psrai.w.512\" => \"__builtin_ia32_psrawi512_mask\",\n+        \"llvm.x86.avx512.psrav.w.512\" => \"__builtin_ia32_psrav32hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.256\" => \"__builtin_ia32_psrav16hi_mask\",\n+        \"llvm.x86.avx512.psrav.w.128\" => \"__builtin_ia32_psrav8hi_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.512\" => \"__builtin_ia32_vpermt2varhi512_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.256\" => \"__builtin_ia32_vpermt2varhi256_mask\",\n+        \"llvm.x86.avx512.vpermi2var.hi.128\" => \"__builtin_ia32_vpermt2varhi128_mask\",\n+        \"llvm.x86.avx512.permvar.hi.512\" => \"__builtin_ia32_permvarhi512_mask\",\n+        \"llvm.x86.avx512.permvar.hi.256\" => \"__builtin_ia32_permvarhi256_mask\",\n+        \"llvm.x86.avx512.permvar.hi.128\" => \"__builtin_ia32_permvarhi128_mask\",\n+        \"llvm.x86.avx512.pshuf.b.512\" => \"__builtin_ia32_pshufb512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.512\" => \"__builtin_ia32_dbpsadbw512_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.256\" => \"__builtin_ia32_dbpsadbw256_mask\",\n+        \"llvm.x86.avx512.dbpsadbw.128\" => \"__builtin_ia32_dbpsadbw128_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.512\" => \"__builtin_ia32_vpmadd52huq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.512\" => \"__builtin_ia32_vpmadd52luq512_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.256\" => \"__builtin_ia32_vpmadd52huq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52l.uq.256\" => \"__builtin_ia32_vpmadd52luq256_mask\",\n+        \"llvm.x86.avx512.vpmadd52h.uq.128\" => \"__builtin_ia32_vpmadd52huq128_mask\",\n+        \"llvm.x86.avx512.vpdpwssd.512\" => \"__builtin_ia32_vpdpwssd_v16si\",\n+        \"llvm.x86.avx512.vpdpwssd.256\" => \"__builtin_ia32_vpdpwssd_v8si\",\n+        \"llvm.x86.avx512.vpdpwssd.128\" => \"__builtin_ia32_vpdpwssd_v4si\",\n+        \"llvm.x86.avx512.vpdpwssds.512\" => \"__builtin_ia32_vpdpwssds_v16si\",\n+        \"llvm.x86.avx512.vpdpwssds.256\" => \"__builtin_ia32_vpdpwssds_v8si\",\n+        \"llvm.x86.avx512.vpdpwssds.128\" => \"__builtin_ia32_vpdpwssds_v4si\",\n+        \"llvm.x86.avx512.vpdpbusd.512\" => \"__builtin_ia32_vpdpbusd_v16si\",\n+        \"llvm.x86.avx512.vpdpbusd.256\" => \"__builtin_ia32_vpdpbusd_v8si\",\n+        \"llvm.x86.avx512.vpdpbusd.128\" => \"__builtin_ia32_vpdpbusd_v4si\",\n+        \"llvm.x86.avx512.vpdpbusds.512\" => \"__builtin_ia32_vpdpbusds_v16si\",\n+        \"llvm.x86.avx512.vpdpbusds.256\" => \"__builtin_ia32_vpdpbusds_v8si\",\n+        \"llvm.x86.avx512.vpdpbusds.128\" => \"__builtin_ia32_vpdpbusds_v4si\",\n+\n         // NOTE: this file is generated by https://github.com/GuillaumeGomez/llvmint/blob/master/generate_list.py\n         _ => include!(\"archs.rs\"),\n     };"}, {"sha": "94dc8c9e93b0de1b4ce3145503b4c8b33a7b6c1c", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 150, "deletions": 6, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,22 +1,33 @@\n pub mod llvm;\n mod simd;\n \n+#[cfg(feature=\"master\")]\n+use std::iter;\n+\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n use rustc_codegen_ssa::common::IntPredicate;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n+#[cfg(feature=\"master\")]\n+use rustc_codegen_ssa::traits::{DerivedTypeMethods, MiscMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Instance, Ty};\n use rustc_middle::ty::layout::LayoutOf;\n+#[cfg(feature=\"master\")]\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n use rustc_span::{Span, Symbol, symbol::kw, sym};\n use rustc_target::abi::HasDataLayout;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::spec::PanicStrategy;\n+#[cfg(feature=\"master\")]\n+use rustc_target::spec::abi::Abi;\n \n use crate::abi::GccType;\n+#[cfg(feature=\"master\")]\n+use crate::abi::FnAbiGccExt;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n@@ -93,7 +104,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let name = tcx.item_name(def_id);\n         let name_str = name.as_str();\n \n-        let llret_ty = self.layout_of(ret_ty).gcc_type(self, true);\n+        let llret_ty = self.layout_of(ret_ty).gcc_type(self);\n         let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n \n         let simple = get_simple_intrinsic(self, name);\n@@ -406,7 +417,7 @@ impl<'gcc, 'tcx> ArgAbiExt<'gcc, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n     /// Gets the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e., the result of `type_of::type_of`.\n     fn memory_ty(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n-        self.layout.gcc_type(cx, true)\n+        self.layout.gcc_type(cx)\n     }\n \n     /// Stores a direct/indirect value described by this ArgAbi into a\n@@ -1122,10 +1133,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n }\n \n-fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n-    // NOTE: the `|| true` here is to use the panic=abort strategy with panic=unwind too\n-    if bx.sess().panic_strategy() == PanicStrategy::Abort || true {\n-        // TODO(bjorn3): Properly implement unwinding and remove the `|| true` once this is done.\n+fn try_intrinsic<'a, 'b, 'gcc, 'tcx>(bx: &'b mut Builder<'a, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    if bx.sess().panic_strategy() == PanicStrategy::Abort {\n         bx.call(bx.type_void(), None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n@@ -1136,6 +1145,141 @@ fn try_intrinsic<'gcc, 'tcx>(bx: &mut Builder<'_, 'gcc, 'tcx>, try_func: RValue<\n         unimplemented!();\n     }\n     else {\n+        #[cfg(feature=\"master\")]\n+        codegen_gnu_try(bx, try_func, data, _catch_func, dest);\n+        #[cfg(not(feature=\"master\"))]\n         unimplemented!();\n     }\n }\n+\n+// Definition of the standard `try` function for Rust using the GNU-like model\n+// of exceptions (e.g., the normal semantics of LLVM's `landingpad` and `invoke`\n+// instructions).\n+//\n+// This codegen is a little surprising because we always call a shim\n+// function instead of inlining the call to `invoke` manually here. This is done\n+// because in LLVM we're only allowed to have one personality per function\n+// definition. The call to the `try` intrinsic is being inlined into the\n+// function calling it, and that function may already have other personality\n+// functions in play. By calling a shim we're guaranteed that our shim will have\n+// the right personality function.\n+#[cfg(feature=\"master\")]\n+fn codegen_gnu_try<'gcc>(bx: &mut Builder<'_, 'gcc, '_>, try_func: RValue<'gcc>, data: RValue<'gcc>, catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n+    let cx: &CodegenCx<'gcc, '_> = bx.cx;\n+    let (llty, func) = get_rust_try_fn(cx, &mut |mut bx| {\n+        // Codegens the shims described above:\n+        //\n+        //   bx:\n+        //      invoke %try_func(%data) normal %normal unwind %catch\n+        //\n+        //   normal:\n+        //      ret 0\n+        //\n+        //   catch:\n+        //      (%ptr, _) = landingpad\n+        //      call %catch_func(%data, %ptr)\n+        //      ret 1\n+        let then = bx.append_sibling_block(\"then\");\n+        let catch = bx.append_sibling_block(\"catch\");\n+\n+        let func = bx.current_func();\n+        let try_func = func.get_param(0).to_rvalue();\n+        let data = func.get_param(1).to_rvalue();\n+        let catch_func = func.get_param(2).to_rvalue();\n+        let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n+\n+        let current_block = bx.block.clone();\n+\n+        bx.switch_to_block(then);\n+        bx.ret(bx.const_i32(0));\n+\n+        // Type indicator for the exception being thrown.\n+        //\n+        // The value is a pointer to the exception object\n+        // being thrown.\n+        bx.switch_to_block(catch);\n+        bx.set_personality_fn(bx.eh_personality());\n+\n+        let eh_pointer_builtin = bx.cx.context.get_target_builtin_function(\"__builtin_eh_pointer\");\n+        let zero = bx.cx.context.new_rvalue_zero(bx.int_type);\n+        let ptr = bx.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n+        let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n+        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n+        bx.ret(bx.const_i32(1));\n+\n+        // NOTE: the blocks must be filled before adding the try/catch, otherwise gcc will not\n+        // generate a try/catch.\n+        // FIXME(antoyo): add a check in the libgccjit API to prevent this.\n+        bx.switch_to_block(current_block);\n+        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n+    });\n+\n+    let func = unsafe { std::mem::transmute(func) };\n+\n+    // Note that no invoke is used here because by definition this function\n+    // can't panic (that's what it's catching).\n+    let ret = bx.call(llty, None, func, &[try_func, data, catch_func], None);\n+    let i32_align = bx.tcx().data_layout.i32_align.abi;\n+    bx.store(ret, dest, i32_align);\n+}\n+\n+\n+// Helper function used to get a handle to the `__rust_try` function used to\n+// catch exceptions.\n+//\n+// This function is only generated once and is then cached.\n+#[cfg(feature=\"master\")]\n+fn get_rust_try_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    if let Some(llfn) = cx.rust_try_fn.get() {\n+        return llfn;\n+    }\n+\n+    // Define the type up front for the signature of the rust_try function.\n+    let tcx = cx.tcx;\n+    let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n+    // `unsafe fn(*mut i8) -> ()`\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        iter::once(i8p),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(*mut i8, *mut i8) -> ()`\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n+        [i8p, i8p].iter().cloned(),\n+        tcx.mk_unit(),\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    )));\n+    // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n+    let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n+        [try_fn_ty, i8p, catch_fn_ty],\n+        tcx.types.i32,\n+        false,\n+        rustc_hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    ));\n+    let rust_try = gen_fn(cx, \"__rust_try\", rust_fn_sig, codegen);\n+    cx.rust_try_fn.set(Some(rust_try));\n+    rust_try\n+}\n+\n+// Helper function to give a Block to a closure to codegen a shim function.\n+// This is currently primarily used for the `try` intrinsic functions above.\n+#[cfg(feature=\"master\")]\n+fn gen_fn<'a, 'gcc, 'tcx>(cx: &'a CodegenCx<'gcc, 'tcx>, name: &str, rust_fn_sig: ty::PolyFnSig<'tcx>, codegen: &mut dyn FnMut(Builder<'a, 'gcc, 'tcx>)) -> (Type<'gcc>, Function<'gcc>) {\n+    let fn_abi = cx.fn_abi_of_fn_ptr(rust_fn_sig, ty::List::empty());\n+    let (typ, _, _, _) = fn_abi.gcc_type(cx);\n+    // FIXME(eddyb) find a nicer way to do this.\n+    cx.linkage.set(FunctionType::Internal);\n+    let func = cx.declare_fn(name, fn_abi);\n+    let func_val = unsafe { std::mem::transmute(func) };\n+    cx.set_frame_pointer_type(func_val);\n+    cx.apply_target_cpu_attr(func_val);\n+    let block = Builder::append_block(cx, func_val, \"entry-block\");\n+    let bx = Builder::build(cx, block);\n+    codegen(bx);\n+    (typ, func)\n+}"}, {"sha": "b59c3a64f5728bdd2ad61fd728ccc64b4e9709b9", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 582, "deletions": 257, "changes": 839, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,8 +1,13 @@\n-use std::cmp::Ordering;\n+#[cfg(feature=\"master\")]\n+use gccjit::{ComparisonOp, UnaryOp};\n+use gccjit::ToRValue;\n+use gccjit::{BinaryOp, RValue, Type};\n \n-use gccjit::{BinaryOp, RValue, ToRValue, Type};\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::TypeKind;\n+use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+#[cfg(feature=\"master\")]\n+use rustc_codegen_ssa::errors::ExpectedPointerMutability;\n+use rustc_codegen_ssa::errors::InvalidMonomorphization;\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -14,18 +19,21 @@ use rustc_span::{sym, Span, Symbol};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n+#[cfg(feature=\"master\")]\n+use crate::context::CodegenCx;\n+#[cfg(feature=\"master\")]\n+use crate::errors::{InvalidMonomorphizationExpectedSignedUnsigned, InvalidMonomorphizationInsertedType};\n use crate::errors::{\n-    InvalidMonomorphizationExpectedSignedUnsigned, InvalidMonomorphizationExpectedSimd,\n-    InvalidMonomorphizationInsertedType, InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationInvalidBitmask,\n     InvalidMonomorphizationInvalidFloatVector, InvalidMonomorphizationMaskType,\n     InvalidMonomorphizationMismatchedLengths, InvalidMonomorphizationNotFloat,\n     InvalidMonomorphizationReturnElement, InvalidMonomorphizationReturnIntegerType,\n     InvalidMonomorphizationReturnLength, InvalidMonomorphizationReturnLengthInputType,\n     InvalidMonomorphizationReturnType, InvalidMonomorphizationSimdShuffle,\n-    InvalidMonomorphizationUnrecognized, InvalidMonomorphizationUnsupportedCast,\n-    InvalidMonomorphizationUnsupportedElement, InvalidMonomorphizationUnsupportedOperation,\n+    InvalidMonomorphizationUnrecognized, InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationUnsupportedOperation,\n };\n-use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n     bx: &mut Builder<'a, 'gcc, 'tcx>,\n@@ -105,14 +113,19 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let arg1_vector_type = arg1_type.unqualified().dyncast_vector().expect(\"vector type\");\n         let arg1_element_type = arg1_vector_type.get_element_type();\n \n+        // NOTE: since the arguments can be vectors of floats, make sure the mask is a vector of\n+        // integer.\n+        let mask_element_type = bx.type_ix(arg1_element_type.get_size() as u64 * 8);\n+        let vector_mask_type = bx.context.new_vector_type(mask_element_type, arg1_vector_type.get_num_units() as u64);\n+\n         let mut elements = vec![];\n         let one = bx.context.new_rvalue_one(mask.get_type());\n         for _ in 0..len {\n-            let element = bx.context.new_cast(None, mask & one, arg1_element_type);\n+            let element = bx.context.new_cast(None, mask & one, mask_element_type);\n             elements.push(element);\n             mask = mask >> one;\n         }\n-        let vector_mask = bx.context.new_rvalue_from_vector(None, arg1_type, &elements);\n+        let vector_mask = bx.context.new_rvalue_from_vector(None, vector_mask_type, &elements);\n \n         return Ok(bx.vector_select(vector_mask, arg1, args[2].immediate()));\n     }\n@@ -210,48 +223,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n         let value = args[2].immediate();\n-        // TODO(antoyo): use a recursive unqualified() here.\n-        let vector_type = vector.get_type().unqualified().dyncast_vector().expect(\"vector type\");\n-        let element_type = vector_type.get_element_type();\n-        // NOTE: we cannot cast to an array and assign to its element here because the value might\n-        // not be an l-value. So, call a builtin to set the element.\n-        // TODO(antoyo): perhaps we could create a new vector or maybe there's a GIMPLE instruction for that?\n-        // TODO(antoyo): don't use target specific builtins here.\n-        let func_name = match in_len {\n-            2 => {\n-                if element_type == bx.i64_type {\n-                    \"__builtin_ia32_vec_set_v2di\"\n-                } else {\n-                    unimplemented!();\n-                }\n-            }\n-            4 => {\n-                if element_type == bx.i32_type {\n-                    \"__builtin_ia32_vec_set_v4si\"\n-                } else {\n-                    unimplemented!();\n-                }\n-            }\n-            8 => {\n-                if element_type == bx.i16_type {\n-                    \"__builtin_ia32_vec_set_v8hi\"\n-                } else {\n-                    unimplemented!();\n-                }\n-            }\n-            _ => unimplemented!(\"Len: {}\", in_len),\n-        };\n-        let builtin = bx.context.get_target_builtin_function(func_name);\n-        let param1_type = builtin.get_param(0).to_rvalue().get_type();\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        let vector = bx.cx.bitcast_if_needed(vector, param1_type);\n-        let result = bx.context.new_call(\n-            None,\n-            builtin,\n-            &[vector, value, bx.context.new_cast(None, index, bx.int_type)],\n-        );\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vector.get_type()));\n+        let variable = bx.current_func().new_local(None, vector.get_type(), \"new_vector\");\n+        bx.llbb().add_assignment(None, variable, vector);\n+        let lvalue = bx.context.new_vector_access(None, variable.to_rvalue(), index);\n+        // TODO(antoyo): if simd_insert is constant, use BIT_REF.\n+        bx.llbb().add_assignment(None, lvalue, value);\n+        return Ok(variable.to_rvalue());\n     }\n \n     #[cfg(feature = \"master\")]\n@@ -280,7 +257,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n \n-    if name == sym::simd_cast {\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_cast || name == sym::simd_as {\n         require_simd!(ret_ty, \"return\");\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n@@ -301,125 +279,40 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n \n         enum Style {\n             Float,\n-            Int(/* is signed? */ bool),\n+            Int,\n             Unsupported,\n         }\n \n-        let (in_style, in_width) = match in_elem.kind() {\n-            // vectors of pointer-sized integers should've been\n-            // disallowed before here, so this unwrap is safe.\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-        let (out_style, out_width) = match out_elem.kind() {\n-            ty::Int(i) => (\n-                Style::Int(true),\n-                i.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Uint(u) => (\n-                Style::Int(false),\n-                u.normalize(bx.tcx().sess.target.pointer_width).bit_width().unwrap(),\n-            ),\n-            ty::Float(f) => (Style::Float, f.bit_width()),\n-            _ => (Style::Unsupported, 0),\n-        };\n-\n-        let extend = |in_type, out_type| {\n-            let vector_type = bx.context.new_vector_type(out_type, 8);\n-            let vector = args[0].immediate();\n-            let array_type = bx.context.new_array_type(None, in_type, 8);\n-            // TODO(antoyo): switch to using new_vector_access or __builtin_convertvector for vector casting.\n-            let array = bx.context.new_bitcast(None, vector, array_type);\n-\n-            let cast_vec_element = |index| {\n-                let index = bx.context.new_rvalue_from_int(bx.int_type, index);\n-                bx.context.new_cast(\n-                    None,\n-                    bx.context.new_array_access(None, array, index).to_rvalue(),\n-                    out_type,\n-                )\n+        let in_style =\n+            match in_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n             };\n \n-            bx.context.new_rvalue_from_vector(\n-                None,\n-                vector_type,\n-                &[\n-                    cast_vec_element(0),\n-                    cast_vec_element(1),\n-                    cast_vec_element(2),\n-                    cast_vec_element(3),\n-                    cast_vec_element(4),\n-                    cast_vec_element(5),\n-                    cast_vec_element(6),\n-                    cast_vec_element(7),\n-                ],\n-            )\n-        };\n+        let out_style =\n+            match out_elem.kind() {\n+                ty::Int(_) | ty::Uint(_) => Style::Int,\n+                ty::Float(_) => Style::Float,\n+                 _ => Style::Unsupported,\n+            };\n \n         match (in_style, out_style) {\n-            (Style::Int(in_is_signed), Style::Int(_)) => {\n-                return Ok(match in_width.cmp(&out_width) {\n-                    Ordering::Greater => bx.trunc(args[0].immediate(), llret_ty),\n-                    Ordering::Equal => args[0].immediate(),\n-                    Ordering::Less => {\n-                        if in_is_signed {\n-                            match (in_width, out_width) {\n-                                // FIXME(antoyo): the function _mm_cvtepi8_epi16 should directly\n-                                // call an intrinsic equivalent to __builtin_ia32_pmovsxbw128 so that\n-                                // we can generate a call to it.\n-                                (8, 16) => extend(bx.i8_type, bx.i16_type),\n-                                (8, 32) => extend(bx.i8_type, bx.i32_type),\n-                                (8, 64) => extend(bx.i8_type, bx.i64_type),\n-                                (16, 32) => extend(bx.i16_type, bx.i32_type),\n-                                (32, 64) => extend(bx.i32_type, bx.i64_type),\n-                                (16, 64) => extend(bx.i16_type, bx.i64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        } else {\n-                            match (in_width, out_width) {\n-                                (8, 16) => extend(bx.u8_type, bx.u16_type),\n-                                (8, 32) => extend(bx.u8_type, bx.u32_type),\n-                                (8, 64) => extend(bx.u8_type, bx.u64_type),\n-                                (16, 32) => extend(bx.u16_type, bx.u32_type),\n-                                (16, 64) => extend(bx.u16_type, bx.u64_type),\n-                                (32, 64) => extend(bx.u32_type, bx.u64_type),\n-                                _ => unimplemented!(\"in: {}, out: {}\", in_width, out_width),\n-                            }\n-                        }\n+            (Style::Unsupported, Style::Unsupported) => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::UnsupportedCast {\n+                        span,\n+                        name,\n+                        in_ty,\n+                        in_elem,\n+                        ret_ty,\n+                        out_elem\n                     }\n-                });\n-            }\n-            (Style::Int(_), Style::Float) => {\n-                // TODO: add support for internal functions in libgccjit to get access to IFN_VEC_CONVERT which is\n-                // doing like __builtin_convertvector?\n-                // Or maybe provide convert_vector as an API since it might not easy to get the\n-                // types of internal functions.\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Int(_)) => {\n-                unimplemented!();\n-            }\n-            (Style::Float, Style::Float) => {\n-                unimplemented!();\n-            }\n-            _ => { /* Unsupported. Fallthrough. */ }\n+                );\n+            },\n+            _ => return Ok(bx.context.convert_vector(None, args[0].immediate(), llret_ty)),\n         }\n-        return_error!(InvalidMonomorphizationUnsupportedCast {\n-            span,\n-            name,\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n-        });\n     }\n \n     macro_rules! arith_binary {\n@@ -436,6 +329,71 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         }\n     }\n \n+    if name == sym::simd_bitmask {\n+        // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n+        // vector mask and returns the most significant bit (MSB) of each lane in the form\n+        // of either:\n+        // * an unsigned integer\n+        // * an array of `u8`\n+        // If the vector has less than 8 lanes, a u8 is returned with zeroed trailing bits.\n+        //\n+        // The bit order of the result depends on the byte endianness, LSB-first for little\n+        // endian and MSB-first for big endian.\n+\n+        let vector = args[0].immediate();\n+        let vector_type = vector.get_type().dyncast_vector().expect(\"vector type\");\n+        let elem_type = vector_type.get_element_type();\n+\n+        let expected_int_bits = in_len.max(8);\n+        let expected_bytes = expected_int_bits / 8 + ((expected_int_bits % 8 > 0) as u64);\n+\n+        // FIXME(antoyo): that's not going to work for masks bigger than 128 bits.\n+        let result_type = bx.type_ix(expected_int_bits);\n+        let mut result = bx.context.new_rvalue_zero(result_type);\n+\n+        let elem_size = elem_type.get_size() * 8;\n+        let sign_shift = bx.context.new_rvalue_from_int(elem_type, elem_size as i32 - 1);\n+        let one = bx.context.new_rvalue_one(elem_type);\n+\n+        let mut shift = 0;\n+        for i in 0..in_len {\n+            let elem = bx.extract_element(vector, bx.context.new_rvalue_from_int(bx.int_type, i as i32));\n+            let shifted = elem >> sign_shift;\n+            let masked = shifted & one;\n+            result = result | (bx.context.new_cast(None, masked, result_type) << bx.context.new_rvalue_from_int(result_type, shift));\n+            shift += 1;\n+        }\n+\n+        match ret_ty.kind() {\n+            ty::Uint(i) if i.bit_width() == Some(expected_int_bits) => {\n+                // Zero-extend iN to the bitmask type:\n+                return Ok(result);\n+            }\n+            ty::Array(elem, len)\n+                if matches!(elem.kind(), ty::Uint(ty::UintTy::U8))\n+                    && len.try_eval_target_usize(bx.tcx, ty::ParamEnv::reveal_all())\n+                        == Some(expected_bytes) =>\n+            {\n+                // Zero-extend iN to the array length:\n+                let ze = bx.zext(result, bx.type_ix(expected_bytes * 8));\n+\n+                // Convert the integer to a byte array\n+                let ptr = bx.alloca(bx.type_ix(expected_bytes * 8), Align::ONE);\n+                bx.store(ze, ptr, Align::ONE);\n+                let array_ty = bx.type_array(bx.type_i8(), expected_bytes);\n+                let ptr = bx.pointercast(ptr, bx.cx.type_ptr_to(array_ty));\n+                return Ok(bx.load(array_ty, ptr, Align::ONE));\n+            }\n+            _ => return_error!(InvalidMonomorphization::CannotReturn {\n+                span,\n+                name,\n+                ret_ty,\n+                expected_int_bits,\n+                expected_bytes\n+            }),\n+        }\n+    }\n+\n     fn simd_simple_float_intrinsic<'gcc, 'tcx>(\n         name: Symbol,\n         in_elem: Ty<'_>,\n@@ -451,55 +409,66 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                 return Err(());\n             }};\n         }\n-        let (elem_ty_str, elem_ty) = if let ty::Float(f) = in_elem.kind() {\n-            let elem_ty = bx.cx.type_float_from_ty(*f);\n-            match f.bit_width() {\n-                32 => (\"f32\", elem_ty),\n-                64 => (\"f64\", elem_ty),\n-                _ => {\n-                    return_error!(InvalidMonomorphizationInvalidFloatVector {\n-                        span,\n-                        name,\n-                        elem_ty: f.name_str(),\n-                        vec_ty: in_ty\n-                    });\n+        let (elem_ty_str, elem_ty) =\n+            if let ty::Float(f) = in_elem.kind() {\n+                let elem_ty = bx.cx.type_float_from_ty(*f);\n+                match f.bit_width() {\n+                    32 => (\"f\", elem_ty),\n+                    64 => (\"\", elem_ty),\n+                    _ => {\n+                        return_error!(InvalidMonomorphizationInvalidFloatVector { span, name, elem_ty: f.name_str(), vec_ty: in_ty });\n+                    }\n                 }\n             }\n-        } else {\n-            return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n-        };\n+            else {\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n+            };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n \n-        let (intr_name, fn_ty) = match name {\n-            sym::simd_ceil => (\"ceil\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)), // TODO(antoyo): pand with 170141183420855150465331762880109871103\n-            sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fexp2 => (\"exp2\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_flog10 => (\"log10\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_flog2 => (\"log2\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_flog => (\"log\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n-            sym::simd_fpowi => (\"powi\", bx.type_func(&[vec_ty, bx.type_i32()], vec_ty)),\n-            sym::simd_fpow => (\"pow\", bx.type_func(&[vec_ty, vec_ty], vec_ty)),\n-            sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n-            sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-            _ => return_error!(InvalidMonomorphizationUnrecognized { span, name }),\n-        };\n-        let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n-        let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n-        let function: RValue<'gcc> = unsafe { std::mem::transmute(function) };\n-        let c = bx.call(\n-            fn_ty,\n-            None,\n-            function,\n-            &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n-            None,\n-        );\n+        let intr_name =\n+            match name {\n+                sym::simd_ceil => \"ceil\",\n+                sym::simd_fabs => \"fabs\", // TODO(antoyo): pand with 170141183420855150465331762880109871103\n+                sym::simd_fcos => \"cos\",\n+                sym::simd_fexp2 => \"exp2\",\n+                sym::simd_fexp => \"exp\",\n+                sym::simd_flog10 => \"log10\",\n+                sym::simd_flog2 => \"log2\",\n+                sym::simd_flog => \"log\",\n+                sym::simd_floor => \"floor\",\n+                sym::simd_fma => \"fma\",\n+                sym::simd_fpowi => \"__builtin_powi\",\n+                sym::simd_fpow => \"pow\",\n+                sym::simd_fsin => \"sin\",\n+                sym::simd_fsqrt => \"sqrt\",\n+                sym::simd_round => \"round\",\n+                sym::simd_trunc => \"trunc\",\n+                _ => return_error!(InvalidMonomorphizationUnrecognized { span, name })\n+            };\n+        let builtin_name = format!(\"{}{}\", intr_name, elem_ty_str);\n+        let funcs = bx.cx.functions.borrow();\n+        let function = funcs.get(&builtin_name).unwrap_or_else(|| panic!(\"unable to find builtin function {}\", builtin_name));\n+\n+        // TODO(antoyo): add platform-specific behavior here for architectures that have these\n+        // intrinsics as instructions (for instance, gpus)\n+        let mut vector_elements = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.ulong_type, i as i64);\n+            // we have to treat fpowi specially, since fpowi's second argument is always an i32\n+            let arguments = if name == sym::simd_fpowi {\n+                vec![\n+                    bx.extract_element(args[0].immediate(), index).to_rvalue(),\n+                    args[1].immediate(),\n+                ]\n+            } else {\n+                args.iter()\n+                    .map(|arg| bx.extract_element(arg.immediate(), index).to_rvalue())\n+                    .collect()\n+            };\n+            vector_elements.push(bx.context.new_call(None, *function, &arguments));\n+        }\n+        let c = bx.context.new_rvalue_from_vector(None, vec_ty, &vector_elements);\n         Ok(c)\n     }\n \n@@ -525,6 +494,297 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         return simd_simple_float_intrinsic(name, in_elem, in_ty, in_len, bx, span, args);\n     }\n \n+    #[cfg(feature=\"master\")]\n+    fn vector_ty<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, elem_ty: Ty<'tcx>, vec_len: u64) -> Type<'gcc> {\n+        // FIXME: use cx.layout_of(ty).llvm_type() ?\n+        let elem_ty = match *elem_ty.kind() {\n+            ty::Int(v) => cx.type_int_from_ty(v),\n+            ty::Uint(v) => cx.type_uint_from_ty(v),\n+            ty::Float(v) => cx.type_float_from_ty(v),\n+            _ => unreachable!(),\n+        };\n+        cx.type_vector(elem_ty, vec_len)\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    fn gather<'a, 'gcc, 'tcx>(default: RValue<'gcc>, pointers: RValue<'gcc>, mask: RValue<'gcc>, pointer_count: usize, bx: &mut Builder<'a, 'gcc, 'tcx>, in_len: u64, underlying_ty: Ty<'tcx>, invert: bool) -> RValue<'gcc> {\n+        let vector_type =\n+            if pointer_count > 1 {\n+                bx.context.new_vector_type(bx.usize_type, in_len)\n+            }\n+            else {\n+                vector_ty(bx, underlying_ty, in_len)\n+            };\n+        let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n+\n+        let mut values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+\n+            let ptr_type = elem_type.make_pointer();\n+            let ptr = bx.context.new_bitcast(None, int, ptr_type);\n+            let value = ptr.dereference(None).to_rvalue();\n+            values.push(value);\n+        }\n+\n+        let vector = bx.context.new_rvalue_from_vector(None, vector_type, &values);\n+\n+        let mut mask_types = vec![];\n+        let mut mask_values = vec![];\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_long(bx.i32_type, i as i64);\n+            mask_types.push(bx.context.new_field(None, bx.i32_type, \"m\"));\n+            let mask_value = bx.context.new_vector_access(None, mask, index).to_rvalue();\n+            let masked = bx.context.new_rvalue_from_int(bx.i32_type, in_len as i32) & mask_value;\n+            let value = index + masked;\n+            mask_values.push(value);\n+        }\n+        let mask_type = bx.context.new_struct_type(None, \"mask_type\", &mask_types);\n+        let mask = bx.context.new_struct_constructor(None, mask_type.as_type(), None, &mask_values);\n+\n+        if invert {\n+            bx.shuffle_vector(vector, default, mask)\n+        }\n+        else {\n+            bx.shuffle_vector(default, vector, mask)\n+        }\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_gather {\n+        // simd_gather(values: <N x T>, pointers: <N x *_ T>,\n+        //             mask: <N x i{M}>) -> <N x T>\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+        require_simd!(ret_ty, \"return\");\n+\n+        // Of the same length:\n+        let (out_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (out_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == out_len,\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len\n+            }\n+        );\n+        require!(\n+            in_len == out_len2,\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: out_len2\n+            }\n+        );\n+\n+        // The return type must match the first argument type\n+        require!(\n+            ret_ty == in_ty,\n+            InvalidMonomorphization::ExpectedReturnType { span, name, in_ty, ret_ty }\n+        );\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: Ty<'_>) -> usize {\n+            match t.kind() {\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n+            match t.kind() {\n+                ty::RawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem => (ptr_count(element_ty1), non_ptr(element_ty1)),\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Not,\n+                    }\n+                );\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        match element_ty2.kind() {\n+            ty::Int(_) => (),\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n+                );\n+            }\n+        }\n+\n+        return Ok(gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, false));\n+    }\n+\n+    #[cfg(feature=\"master\")]\n+    if name == sym::simd_scatter {\n+        // simd_scatter(values: <N x T>, pointers: <N x *mut T>,\n+        //             mask: <N x i{M}>) -> ()\n+        // * N: number of elements in the input vectors\n+        // * T: type of the element to load\n+        // * M: any integer width is supported, will be truncated to i1\n+\n+        // All types must be simd vector types\n+        require_simd!(in_ty, \"first\");\n+        require_simd!(arg_tys[1], \"second\");\n+        require_simd!(arg_tys[2], \"third\");\n+\n+        // Of the same length:\n+        let (element_len1, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (element_len2, _) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        require!(\n+            in_len == element_len1,\n+            InvalidMonomorphization::SecondArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[1],\n+                out_len: element_len1\n+            }\n+        );\n+        require!(\n+            in_len == element_len2,\n+            InvalidMonomorphization::ThirdArgumentLength {\n+                span,\n+                name,\n+                in_len,\n+                in_ty,\n+                arg_ty: arg_tys[2],\n+                out_len: element_len2\n+            }\n+        );\n+\n+        // This counts how many pointers\n+        fn ptr_count(t: Ty<'_>) -> usize {\n+            match t.kind() {\n+                ty::RawPtr(p) => 1 + ptr_count(p.ty),\n+                _ => 0,\n+            }\n+        }\n+\n+        // Non-ptr type\n+        fn non_ptr(t: Ty<'_>) -> Ty<'_> {\n+            match t.kind() {\n+                ty::RawPtr(p) => non_ptr(p.ty),\n+                _ => t,\n+            }\n+        }\n+\n+        // The second argument must be a simd vector with an element type that's a pointer\n+        // to the element type of the first argument\n+        let (_, element_ty0) = arg_tys[0].simd_size_and_type(bx.tcx());\n+        let (_, element_ty1) = arg_tys[1].simd_size_and_type(bx.tcx());\n+        let (_, element_ty2) = arg_tys[2].simd_size_and_type(bx.tcx());\n+        let (pointer_count, underlying_ty) = match element_ty1.kind() {\n+            ty::RawPtr(p) if p.ty == in_elem && p.mutbl == hir::Mutability::Mut => {\n+                (ptr_count(element_ty1), non_ptr(element_ty1))\n+            }\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ExpectedElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty1,\n+                        second_arg: arg_tys[1],\n+                        in_elem,\n+                        in_ty,\n+                        mutability: ExpectedPointerMutability::Mut,\n+                    }\n+                );\n+                unreachable!();\n+            }\n+        };\n+        assert!(pointer_count > 0);\n+        assert_eq!(pointer_count - 1, ptr_count(element_ty0));\n+        assert_eq!(underlying_ty, non_ptr(element_ty0));\n+\n+        // The element type of the third argument must be a signed integer type of any width:\n+        match element_ty2.kind() {\n+            ty::Int(_) => (),\n+            _ => {\n+                require!(\n+                    false,\n+                    InvalidMonomorphization::ThirdArgElementType {\n+                        span,\n+                        name,\n+                        expected_element: element_ty2,\n+                        third_arg: arg_tys[2]\n+                    }\n+                );\n+            }\n+        }\n+\n+        let result = gather(args[0].immediate(), args[1].immediate(), args[2].immediate(), pointer_count, bx, in_len, underlying_ty, true);\n+\n+        let pointers = args[1].immediate();\n+\n+        let vector_type =\n+            if pointer_count > 1 {\n+                bx.context.new_vector_type(bx.usize_type, in_len)\n+            }\n+            else {\n+                vector_ty(bx, underlying_ty, in_len)\n+            };\n+        let elem_type = vector_type.dyncast_vector().expect(\"vector type\").get_element_type();\n+\n+        for i in 0..in_len {\n+            let index = bx.context.new_rvalue_from_int(bx.int_type, i as i32);\n+            let value = bx.context.new_vector_access(None, result, index);\n+\n+            let int = bx.context.new_vector_access(None, pointers, index).to_rvalue();\n+            let ptr_type = elem_type.make_pointer();\n+            let ptr = bx.context.new_bitcast(None, int, ptr_type);\n+            bx.llbb().add_assignment(None, ptr.dereference(None), value);\n+        }\n+\n+        return Ok(bx.context.new_rvalue_zero(bx.i32_type));\n+    }\n+\n     arith_binary! {\n         simd_add: Uint, Int => add, Float => fadd;\n         simd_sub: Uint, Int => sub, Float => fsub;\n@@ -536,6 +796,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         simd_and: Uint, Int => and;\n         simd_or: Uint, Int => or; // FIXME(antoyo): calling `or` might not work on vectors.\n         simd_xor: Uint, Int => xor;\n+        simd_fmin: Float => vector_fmin;\n+        simd_fmax: Float => vector_fmax;\n     }\n \n     macro_rules! arith_unary {\n@@ -562,10 +824,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         let rhs = args[1].immediate();\n         let is_add = name == sym::simd_saturating_add;\n         let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n-        let (signed, elem_width, elem_ty) = match *in_elem.kind() {\n-            ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n-            ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n-            _ => {\n+        let (signed, elem_width, elem_ty) =\n+            match *in_elem.kind() {\n+                ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_int_from_ty(i)),\n+                ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits) / 8, bx.cx.type_uint_from_ty(i)),\n+                _ => {\n                 return_error!(InvalidMonomorphizationExpectedSignedUnsigned {\n                     span,\n                     name,\n@@ -574,33 +837,78 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                 });\n             }\n         };\n-        let builtin_name = match (signed, is_add, in_len, elem_width) {\n-            (true, true, 32, 8) => \"__builtin_ia32_paddsb256\", // TODO(antoyo): cast arguments to unsigned.\n-            (false, true, 32, 8) => \"__builtin_ia32_paddusb256\",\n-            (true, true, 16, 16) => \"__builtin_ia32_paddsw256\",\n-            (false, true, 16, 16) => \"__builtin_ia32_paddusw256\",\n-            (true, false, 16, 16) => \"__builtin_ia32_psubsw256\",\n-            (false, false, 16, 16) => \"__builtin_ia32_psubusw256\",\n-            (true, false, 32, 8) => \"__builtin_ia32_psubsb256\",\n-            (false, false, 32, 8) => \"__builtin_ia32_psubusb256\",\n-            _ => unimplemented!(\n-                \"signed: {}, is_add: {}, in_len: {}, elem_width: {}\",\n-                signed,\n-                is_add,\n-                in_len,\n-                elem_width\n-            ),\n-        };\n-        let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n-\n-        let func = bx.context.get_target_builtin_function(builtin_name);\n-        let param1_type = func.get_param(0).to_rvalue().get_type();\n-        let param2_type = func.get_param(1).to_rvalue().get_type();\n-        let lhs = bx.cx.bitcast_if_needed(lhs, param1_type);\n-        let rhs = bx.cx.bitcast_if_needed(rhs, param2_type);\n-        let result = bx.context.new_call(None, func, &[lhs, rhs]);\n-        // TODO(antoyo): perhaps use __builtin_convertvector for vector casting.\n-        return Ok(bx.context.new_bitcast(None, result, vec_ty));\n+\n+        let result =\n+            match (signed, is_add) {\n+                (false, true) => {\n+                    let res = lhs + rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n+                    res | cmp\n+                },\n+                (true, true) => {\n+                    // Algorithm from: https://codereview.stackexchange.com/questions/115869/saturated-signed-addition\n+                    // TODO(antoyo): improve using conditional operators if possible.\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                },\n+                (false, false) => {\n+                    let res = lhs - rhs;\n+                    let cmp = bx.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n+                    res & cmp\n+                },\n+                (true, false) => {\n+                    let arg_type = lhs.get_type();\n+                    // TODO(antoyo): this uses the same algorithm from saturating add, but add the\n+                    // negative of the right operand. Find a proper subtraction algorithm.\n+                    let rhs = bx.context.new_unary_op(None, UnaryOp::Minus, arg_type, rhs);\n+\n+                    // TODO(antoyo): convert lhs and rhs to unsigned.\n+                    let sum = lhs + rhs;\n+                    let vector_type = arg_type.dyncast_vector().expect(\"vector type\");\n+                    let unit = vector_type.get_num_units();\n+                    let a = bx.context.new_rvalue_from_int(elem_ty, ((elem_width as i32) << 3) - 1);\n+                    let width = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![a; unit]);\n+\n+                    let xor1 = lhs ^ rhs;\n+                    let xor2 = lhs ^ sum;\n+                    let and = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, xor1) & xor2;\n+                    let mask = and >> width;\n+\n+                    let one = bx.context.new_rvalue_one(elem_ty);\n+                    let ones = bx.context.new_rvalue_from_vector(None, lhs.get_type(), &vec![one; unit]);\n+                    let shift1 = ones << width;\n+                    let shift2 = sum >> width;\n+                    let mask_min = shift1 ^ shift2;\n+\n+                    let and1 = bx.context.new_unary_op(None, UnaryOp::BitwiseNegate, arg_type, mask) & sum;\n+                    let and2 = mask & mask_min;\n+\n+                    and1 + and2\n+                }\n+            };\n+\n+        return Ok(result);\n     }\n \n     macro_rules! arith_red {\n@@ -650,33 +958,50 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n         add,\n         0.0 // TODO: Use this argument.\n     );\n-    arith_red!(simd_reduce_mul_unordered: BinaryOp::Mult, vector_reduce_fmul_fast, false, mul, 1.0);\n+    arith_red!(\n+        simd_reduce_mul_unordered: BinaryOp::Mult,\n+        vector_reduce_fmul_fast,\n+        false,\n+        mul,\n+        1.0\n+    );\n+    arith_red!(\n+        simd_reduce_add_ordered: BinaryOp::Plus,\n+        vector_reduce_fadd,\n+        true,\n+        add,\n+        0.0\n+    );\n+    arith_red!(\n+        simd_reduce_mul_ordered: BinaryOp::Mult,\n+        vector_reduce_fmul,\n+        true,\n+        mul,\n+        1.0\n+    );\n+\n \n     macro_rules! minmax_red {\n-        ($name:ident: $reduction:ident) => {\n+        ($name:ident: $int_red:ident, $float_red:ident) => {\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n                     InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n-                    ty::Int(_) | ty::Uint(_) | ty::Float(_) => {\n-                        Ok(bx.$reduction(args[0].immediate()))\n-                    }\n-                    _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n-                        span,\n-                        name,\n-                        in_ty,\n-                        elem_ty: in_elem,\n-                        ret_ty\n-                    }),\n+                    ty::Int(_) | ty::Uint(_) => Ok(bx.$int_red(args[0].immediate())),\n+                    ty::Float(_) => Ok(bx.$float_red(args[0].immediate())),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n     }\n \n-    minmax_red!(simd_reduce_min: vector_reduce_min);\n-    minmax_red!(simd_reduce_max: vector_reduce_max);\n+    minmax_red!(simd_reduce_min: vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(simd_reduce_max: vector_reduce_max, vector_reduce_fmax);\n+    // TODO(sadlerap): revisit these intrinsics to generate more optimal reductions\n+    minmax_red!(simd_reduce_min_nanless: vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(simd_reduce_max_nanless: vector_reduce_max, vector_reduce_fmax);\n \n     macro_rules! bitwise_red {\n         ($name:ident : $op:expr, $boolean:expr) => {\n@@ -699,15 +1024,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n                         }),\n                     }\n \n-                    // boolean reductions operate on vectors of i1s:\n-                    let i1 = bx.type_i1();\n-                    let i1xn = bx.type_vector(i1, in_len as u64);\n-                    bx.trunc(args[0].immediate(), i1xn)\n+                    args[0].immediate()\n                 };\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n                         let r = bx.vector_reduce_op(input, $op);\n-                        Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n+                        Ok(if !$boolean { r } else { bx.icmp(IntPredicate::IntNE, r, bx.context.new_rvalue_zero(r.get_type())) })\n                     }\n                     _ => return_error!(InvalidMonomorphizationUnsupportedElement {\n                         span,\n@@ -723,6 +1045,9 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(\n \n     bitwise_red!(simd_reduce_and: BinaryOp::BitwiseAnd, false);\n     bitwise_red!(simd_reduce_or: BinaryOp::BitwiseOr, false);\n+    bitwise_red!(simd_reduce_xor: BinaryOp::BitwiseXor, false);\n+    bitwise_red!(simd_reduce_all: BinaryOp::BitwiseAnd, true);\n+    bitwise_red!(simd_reduce_any: BinaryOp::BitwiseOr, true);\n \n     unimplemented!(\"simd {}\", name);\n }"}, {"sha": "1b7feb5f8a18e77edd9edd8f6c74b5bc619b205b", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,7 +1,7 @@\n /*\n  * TODO(antoyo): implement equality in libgccjit based on https://zpz.github.io/blog/overloading-equality-operator-in-cpp-class-hierarchy/ (for type equality?)\n  * TODO(antoyo): support #[inline] attributes.\n- * TODO(antoyo): support LTO (gcc's equivalent to Thin LTO is enabled by -fwhopr: https://stackoverflow.com/questions/64954525/does-gcc-have-thin-lto).\n+ * TODO(antoyo): support LTO (gcc's equivalent to Full LTO is -flto -flto-partition=one \u2014 https://documentation.suse.com/sbp/all/html/SBP-GCC-10/index.html).\n  *\n  * TODO(antoyo): remove the patches.\n  */\n@@ -23,6 +23,7 @@\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;\n+extern crate rustc_attr;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n@@ -43,6 +44,7 @@ mod abi;\n mod allocator;\n mod archive;\n mod asm;\n+mod attributes;\n mod back;\n mod base;\n mod builder;\n@@ -314,9 +316,12 @@ pub fn target_features(sess: &Session, allow_unstable: bool) -> Vec<Symbol> {\n         .filter(|_feature| {\n             // TODO(antoyo): implement a way to get enabled feature in libgccjit.\n             // Probably using the equivalent of __builtin_cpu_supports.\n+            // TODO(antoyo): maybe use whatever outputs the following command:\n+            // gcc -march=native -Q --help=target\n             #[cfg(feature=\"master\")]\n             {\n-                _feature.contains(\"sse\") || _feature.contains(\"avx\")\n+                // NOTE: the CPU in the CI doesn't support sse4a, so disable it to make the stdarch tests pass in the CI.\n+                (_feature.contains(\"sse\") || _feature.contains(\"avx\")) && !_feature.contains(\"avx512\") && !_feature.contains(\"sse4a\")\n             }\n             #[cfg(not(feature=\"master\"))]\n             {"}, {"sha": "c1f6340866cacc5edc6e13276f47f2fa4be140cd", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,38 +1,66 @@\n+#[cfg(feature=\"master\")]\n+use gccjit::{VarAttribute, FnAttribute};\n use rustc_codegen_ssa::traits::PreDefineMethods;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::{self, Instance, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n-use rustc_span::def_id::DefId;\n \n+use crate::attributes;\n use crate::base;\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n-    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_static(&self, def_id: DefId, _linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         let attrs = self.tcx.codegen_fn_attrs(def_id);\n         let instance = Instance::mono(self.tcx, def_id);\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n-        let gcc_type = self.layout_of(ty).gcc_type(self, true);\n+        let gcc_type = self.layout_of(ty).gcc_type(self);\n \n         let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n         let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section);\n+        #[cfg(feature=\"master\")]\n+        global.add_attribute(VarAttribute::Visibility(base::visibility_to_gcc(visibility)));\n \n-        // TODO(antoyo): set linkage and visibility.\n+        // TODO(antoyo): set linkage.\n         self.instances.borrow_mut().insert(instance, global);\n     }\n \n-    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n+    #[cfg_attr(not(feature=\"master\"), allow(unused_variables))]\n+    fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, visibility: Visibility, symbol_name: &str) {\n         assert!(!instance.substs.needs_infer());\n \n         let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));\n-        let _decl = self.declare_fn(symbol_name, &fn_abi);\n+        let decl = self.declare_fn(symbol_name, &fn_abi);\n         //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());\n \n+        attributes::from_fn_attrs(self, decl, instance);\n+\n+        // If we're compiling the compiler-builtins crate, e.g., the equivalent of\n+        // compiler-rt, then we want to implicitly compile everything with hidden\n+        // visibility as we're going to link this object all over the place but\n+        // don't want the symbols to get exported.\n+        if linkage != Linkage::Internal\n+            && linkage != Linkage::Private\n+            && self.tcx.is_compiler_builtins(LOCAL_CRATE)\n+        {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+        }\n+        else {\n+            #[cfg(feature=\"master\")]\n+            decl.add_attribute(FnAttribute::Visibility(base::visibility_to_gcc(visibility)));\n+        }\n+\n         // TODO(antoyo): call set_link_section() to allow initializing argc/argv.\n         // TODO(antoyo): set unique comdat.\n         // TODO(antoyo): use inline attribute from there in linkage.set() above.\n+\n+        self.functions.borrow_mut().insert(symbol_name.to_string(), decl);\n+        self.function_instances.borrow_mut().insert(instance, unsafe { std::mem::transmute(decl) });\n     }\n }"}, {"sha": "daa661f35c4c108767b9bfde5476544944506b47", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,5 +1,3 @@\n-use std::convert::TryInto;\n-\n use gccjit::{RValue, Struct, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, TypeMembershipMethods};\n use rustc_codegen_ssa::common::TypeKind;\n@@ -202,23 +200,17 @@ impl<'gcc, 'tcx> BaseTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         value.get_type()\n     }\n \n-    fn type_array(&self, ty: Type<'gcc>, mut len: u64) -> Type<'gcc> {\n-        if let Some(struct_type) = ty.is_struct() {\n+    fn type_array(&self, ty: Type<'gcc>, len: u64) -> Type<'gcc> {\n+        // TODO: remove this as well?\n+        /*if let Some(struct_type) = ty.is_struct() {\n             if struct_type.get_field_count() == 0 {\n                 // NOTE: since gccjit only supports i32 for the array size and libcore's tests uses a\n                 // size of usize::MAX in test_binary_search, we workaround this by setting the size to\n                 // zero for ZSTs.\n                 // FIXME(antoyo): fix gccjit API.\n                 len = 0;\n             }\n-        }\n-\n-        // NOTE: see note above. Some other test uses usize::MAX.\n-        if len == u64::MAX {\n-            len = 0;\n-        }\n-\n-        let len: i32 = len.try_into().expect(\"array len\");\n+        }*/\n \n         self.context.new_array_type(None, ty, len)\n     }\n@@ -247,10 +239,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn type_named_struct(&self, name: &str) -> Struct<'gcc> {\n         self.context.new_opaque_struct_type(None, name)\n     }\n-\n-    pub fn type_bool(&self) -> Type<'gcc> {\n-        self.context.new_type::<bool>()\n-    }\n }\n \n pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>) -> (Vec<Type<'gcc>>, bool) {\n@@ -273,7 +261,7 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n         assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n         result.push(cx.type_padding_filler(padding, padding_align));\n \n-        result.push(field.gcc_type(cx, !field.ty.is_any_ptr())); // FIXME(antoyo): might need to check if the type is inside another, like Box<Type>.\n+        result.push(field.gcc_type(cx));\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n     }"}, {"sha": "5df8c1a209db2e8f9301edb488379200f66832a9", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::bug;\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n+use rustc_target::abi::{self, Abi, Align, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n \n use crate::abi::{FnAbiGccExt, GccType};\n@@ -50,11 +50,25 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n-pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n+impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n+    pub fn align_of(&self, ty: Ty<'tcx>) -> Align {\n+        self.layout_of(ty).align.abi\n+    }\n+}\n+\n+fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout<'tcx>, defer: &mut Option<(Struct<'gcc>, TyAndLayout<'tcx>)>) -> Type<'gcc> {\n     match layout.abi {\n         Abi::Scalar(_) => bug!(\"handled elsewhere\"),\n         Abi::Vector { ref element, count } => {\n             let element = layout.scalar_gcc_type_at(cx, element, Size::ZERO);\n+            let element =\n+                // NOTE: gcc doesn't allow pointer types in vectors.\n+                if element.get_pointee().is_some() {\n+                    cx.usize_type\n+                }\n+                else {\n+                    element\n+                };\n             return cx.context.new_vector_type(element, count);\n         },\n         Abi::ScalarPair(..) => {\n@@ -114,7 +128,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n                 },\n             }\n         }\n-        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx, true), count),\n+        FieldsShape::Array { count, .. } => cx.type_array(layout.field(cx, 0).gcc_type(cx), count),\n         FieldsShape::Arbitrary { .. } =>\n             match name {\n                 None => {\n@@ -133,7 +147,7 @@ pub fn uncached_gcc_type<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLa\n pub trait LayoutGccExt<'tcx> {\n     fn is_gcc_immediate(&self) -> bool;\n     fn is_gcc_scalar_pair(&self) -> bool;\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc>;\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn immediate_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc>;\n     fn scalar_pair_element_gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, index: usize, immediate: bool) -> Type<'gcc>;\n@@ -168,8 +182,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n     /// with the inner-most trailing unsized field using the \"minimal unit\"\n     /// of that field's type - this is useful for taking the address of\n     /// that field and ensuring the struct has the right alignment.\n-    //TODO(antoyo): do we still need the set_fields parameter?\n-    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, set_fields: bool) -> Type<'gcc> {\n+    fn gcc_type<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n         if let Abi::Scalar(ref scalar) = self.abi {\n             // Use a different cache for scalars because pointers to DSTs\n             // can be either fat or thin (data pointers of fat pointers).\n@@ -179,10 +192,10 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             let ty =\n                 match *self.ty.kind() {\n                     ty::Ref(_, ty, _) | ty::RawPtr(ty::TypeAndMut { ty, .. }) => {\n-                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx, set_fields))\n+                        cx.type_ptr_to(cx.layout_of(ty).gcc_type(cx))\n                     }\n                     ty::Adt(def, _) if def.is_box() => {\n-                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx, true))\n+                        cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx))\n                     }\n                     ty::FnPtr(sig) => cx.fn_ptr_backend_type(&cx.fn_abi_of_fn_ptr(sig, ty::List::empty())),\n                     _ => self.scalar_gcc_type_at(cx, scalar, Size::ZERO),\n@@ -199,13 +212,6 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n             };\n         let cached_type = cx.types.borrow().get(&(self.ty, variant_index)).cloned();\n         if let Some(ty) = cached_type {\n-            let type_to_set_fields = cx.types_with_fields_to_set.borrow_mut().remove(&ty);\n-            if let Some((struct_type, layout)) = type_to_set_fields {\n-                // Since we might be trying to generate a type containing another type which is not\n-                // completely generated yet, we deferred setting the fields until now.\n-                let (fields, packed) = struct_fields(cx, layout);\n-                cx.set_struct_body(struct_type, &fields, packed);\n-            }\n             return ty;\n         }\n \n@@ -222,17 +228,17 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 if let Some(v) = variant_index {\n                     layout = layout.for_variant(cx, v);\n                 }\n-                layout.gcc_type(cx, true)\n+                layout.gcc_type(cx)\n             }\n             else {\n                 uncached_gcc_type(cx, *self, &mut defer)\n             };\n \n         cx.types.borrow_mut().insert((self.ty, variant_index), ty);\n \n-        if let Some((ty, layout)) = defer {\n+        if let Some((deferred_ty, layout)) = defer {\n             let (fields, packed) = struct_fields(cx, layout);\n-            cx.set_struct_body(ty, &fields, packed);\n+            cx.set_struct_body(deferred_ty, &fields, packed);\n         }\n \n         ty\n@@ -244,7 +250,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                 return cx.type_i1();\n             }\n         }\n-        self.gcc_type(cx, true)\n+        self.gcc_type(cx)\n     }\n \n     fn scalar_gcc_type_at<'gcc>(&self, cx: &CodegenCx<'gcc, 'tcx>, scalar: &abi::Scalar, offset: Size) -> Type<'gcc> {\n@@ -273,7 +279,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n         // pointee types, to avoid bitcasting every `OperandRef::deref`.\n         match self.ty.kind() {\n             ty::Ref(..) | ty::RawPtr(_) => {\n-                return self.field(cx, index).gcc_type(cx, true);\n+                return self.field(cx, index).gcc_type(cx);\n             }\n             // only wide pointer boxes are handled as pointers\n             // thin pointer boxes with scalar allocators are handled by the general logic below\n@@ -343,7 +349,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n \n impl<'gcc, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {\n-        layout.gcc_type(self, true)\n+        layout.gcc_type(self)\n     }\n \n     fn immediate_backend_type(&self, layout: TyAndLayout<'tcx>) -> Type<'gcc> {"}, {"sha": "6139892aefca7d2d42bf35aad2bb9de2726e7f40", "filename": "compiler/rustc_codegen_gcc/test.sh", "status": "modified", "additions": 184, "deletions": 56, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftest.sh?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -17,17 +17,20 @@ export LIBRARY_PATH=\"$GCC_PATH\"\n flags=\n gcc_master_branch=1\n channel=\"debug\"\n-func=all\n+funcs=()\n build_only=0\n+nb_parts=0\n+current_part=0\n \n while [[ $# -gt 0 ]]; do\n     case $1 in\n         --release)\n             codegen_channel=release\n+            channel=\"release\"\n             shift\n             ;;\n         --release-sysroot)\n-            sysroot_channel=release\n+            sysroot_channel=\"--release\"\n             shift\n             ;;\n         --no-default-features)\n@@ -40,43 +43,83 @@ while [[ $# -gt 0 ]]; do\n             flags=\"$flags --features $1\"\n             shift\n             ;;\n-        --release)\n-            channel=\"release\"\n+        \"--test-rustc\")\n+            funcs+=(test_rustc)\n             shift\n             ;;\n-        \"--test-rustc\")\n-            func=test_rustc\n+        \"--test-successful-rustc\")\n+            funcs+=(test_successful_rustc)\n+            shift\n+            ;;\n+        \"--test-failing-rustc\")\n+            funcs+=(test_failing_rustc)\n             shift\n             ;;\n \n         \"--test-libcore\")\n-            func=test_libcore\n+            funcs+=(test_libcore)\n             shift\n             ;;\n \n         \"--clean-ui-tests\")\n-            func=clean_ui_tests\n+            funcs+=(clean_ui_tests)\n+            shift\n+            ;;\n+        \"--clean\")\n+            funcs+=(clean)\n             shift\n             ;;\n \n         \"--std-tests\")\n-            func=std_tests\n+            funcs+=(std_tests)\n+            shift\n+            ;;\n+\n+        \"--asm-tests\")\n+            funcs+=(asm_tests)\n             shift\n             ;;\n \n         \"--extended-tests\")\n-            func=extended_sysroot_tests\n+            funcs+=(extended_sysroot_tests)\n+            shift\n+            ;;\n+        \"--extended-rand-tests\")\n+            funcs+=(extended_rand_tests)\n+            shift\n+            ;;\n+        \"--extended-regex-example-tests\")\n+            funcs+=(extended_regex_example_tests)\n+            shift\n+            ;;\n+        \"--extended-regex-tests\")\n+            funcs+=(extended_regex_tests)\n+            shift\n+            ;;\n+\n+        \"--mini-tests\")\n+            funcs+=(mini_tests)\n             shift\n             ;;\n \n         \"--build-sysroot\")\n-            func=build_sysroot\n+            funcs+=(build_sysroot)\n             shift\n             ;;\n         \"--build\")\n             build_only=1\n             shift\n             ;;\n+        \"--nb-parts\")\n+            shift\n+            nb_parts=$1\n+            shift\n+            ;;\n+        \"--current-part\")\n+            shift\n+            current_part=$1\n+            shift\n+            ;;\n         *)\n             echo \"Unknown option $1\"\n             exit 1\n@@ -87,14 +130,14 @@ done\n if [[ $channel == \"release\" ]]; then\n     export CHANNEL='release'\n     CARGO_INCREMENTAL=1 cargo rustc --release $flags\n-    shift\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n     cargo rustc $flags\n fi\n \n if (( $build_only == 1 )); then\n+    echo \"Since it's 'build-only', exiting...\"\n     exit\n fi\n \n@@ -119,7 +162,7 @@ function mini_tests() {\n \n function build_sysroot() {\n     echo \"[BUILD] sysroot\"\n-    time ./build_sysroot/build_sysroot.sh\n+    time ./build_sysroot/build_sysroot.sh $sysroot_channel\n }\n \n function std_tests() {\n@@ -148,17 +191,57 @@ function std_tests() {\n     $RUN_WRAPPER ./target/out/std_example --target $TARGET_TRIPLE\n \n     echo \"[AOT] subslice-patterns-const-eval\"\n-    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin $TEST_FLAGS --target $TARGET_TRIPLE\n     $RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n \n     echo \"[AOT] track-caller-attribute\"\n-    $RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUSTC example/track-caller-attribute.rs --crate-type bin $TEST_FLAGS --target $TARGET_TRIPLE\n     $RUN_WRAPPER ./target/out/track-caller-attribute\n \n     echo \"[BUILD] mod_bench\"\n     $RUSTC example/mod_bench.rs --crate-type bin --target $TARGET_TRIPLE\n }\n \n+function setup_rustc() {\n+    rust_toolchain=$(cat rust-toolchain | grep channel | sed 's/channel = \"\\(.*\\)\"/\\1/')\n+\n+    git clone https://github.com/rust-lang/rust.git || true\n+    cd rust\n+    git fetch\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n+    export RUSTFLAGS=\n+\n+    rm config.toml || true\n+\n+    cat > config.toml <<EOF\n+[rust]\n+codegen-backends = []\n+deny-warnings = false\n+\n+[build]\n+cargo = \"$(which cargo)\"\n+local-rebuild = true\n+rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n+\n+[target.x86_64-unknown-linux-gnu]\n+llvm-filecheck = \"`which FileCheck-10 || which FileCheck-11 || which FileCheck-12 || which FileCheck-13 || which FileCheck-14`\"\n+\n+[llvm]\n+download-ci-llvm = false\n+EOF\n+\n+    rustc -V | cut -d' ' -f3 | tr -d '('\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') tests\n+}\n+\n+function asm_tests() {\n+    setup_rustc\n+\n+    echo \"[TEST] rustc test suite\"\n+    RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 tests/assembly/asm --rustc-args \"$RUSTC_ARGS\"\n+}\n+\n # FIXME(antoyo): linker gives multiple definitions error on Linux\n #echo \"[BUILD] sysroot in release mode\"\n #./build_sysroot/build_sysroot.sh --release\n@@ -187,7 +270,7 @@ function test_libcore() {\n #echo \"[BENCH RUN] mod_bench\"\n #hyperfine --runs ${RUN_RUNS:-10} ./target/out/mod_bench{,_inline} ./target/out/mod_bench_llvm_*\n \n-function extended_sysroot_tests() {\n+function extended_rand_tests() {\n     if (( $gcc_master_branch == 0 )); then\n         return\n     fi\n@@ -197,17 +280,12 @@ function extended_sysroot_tests() {\n     echo \"[TEST] rust-random/rand\"\n     ../cargo.sh test --workspace\n     popd\n+}\n \n-    #pushd simple-raytracer\n-    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n-    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n-    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n-    #\"../cargo.sh build\"\n-\n-    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n-    #cp ./target/debug/main ./raytracer_cg_gcc\n-    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n-    #popd\n+function extended_regex_example_tests() {\n+    if (( $gcc_master_branch == 0 )); then\n+        return\n+    fi\n \n     pushd regex\n     echo \"[TEST] rust-lang/regex example shootout-regex-dna\"\n@@ -219,73 +297,123 @@ function extended_sysroot_tests() {\n         | ../cargo.sh run --example shootout-regex-dna \\\n         | grep -v \"Spawned thread\" > res.txt\n     diff -u res.txt examples/regexdna-output.txt\n+    popd\n+}\n+\n+function extended_regex_tests() {\n+    if (( $gcc_master_branch == 0 )); then\n+        return\n+    fi\n \n+    pushd regex\n     echo \"[TEST] rust-lang/regex tests\"\n+    export CG_RUSTFLAGS=\"--cap-lints warn\" # newer aho_corasick versions throw a deprecation warning\n     ../cargo.sh test --tests -- --exclude-should-panic --test-threads 1 -Zunstable-options -q\n     popd\n }\n \n-function test_rustc() {\n-    echo\n-    echo \"[TEST] rust-lang/rust\"\n-\n-    rust_toolchain=$(cat rust-toolchain | grep channel | sed 's/channel = \"\\(.*\\)\"/\\1/')\n-\n-    git clone https://github.com/rust-lang/rust.git || true\n-    cd rust\n-    git fetch\n-    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n-    export RUSTFLAGS=\n-\n-    git apply ../rustc_patches/compile_test.patch || true\n+function extended_sysroot_tests() {\n+    #pushd simple-raytracer\n+    #echo \"[BENCH COMPILE] ebobby/simple-raytracer\"\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" --warmup 1 --prepare \"cargo clean\" \\\n+    #\"RUSTC=rustc RUSTFLAGS='' cargo build\" \\\n+    #\"../cargo.sh build\"\n \n-    rm config.toml || true\n+    #echo \"[BENCH RUN] ebobby/simple-raytracer\"\n+    #cp ./target/debug/main ./raytracer_cg_gcc\n+    #hyperfine --runs \"${RUN_RUNS:-10}\" ./raytracer_cg_llvm ./raytracer_cg_gcc\n+    #popd\n \n-    cat > config.toml <<EOF\n-[rust]\n-codegen-backends = []\n-deny-warnings = false\n+    extended_rand_tests\n+    extended_regex_example_tests\n+    extended_regex_tests\n+}\n \n-[build]\n-cargo = \"$(which cargo)\"\n-local-rebuild = true\n-rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n-EOF\n+function test_rustc() {\n+    echo\n+    echo \"[TEST] rust-lang/rust\"\n \n-    rustc -V | cut -d' ' -f3 | tr -d '('\n-    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') tests\n+    setup_rustc\n \n     for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" tests/ui); do\n       rm $test\n     done\n \n     git checkout -- tests/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n \n-    rm -r tests/ui/{abi*,extern/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,test*,*lto*.rs} || true\n-    for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" tests/ui); do\n+    rm -r tests/ui/{abi*,extern/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,borrowck/,chalkify/bugs/,test*,*lto*.rs,consts/const-float-bits-reject-conv.rs,consts/issue-miri-1910.rs} || true\n+    rm tests/ui/mir/mir_heavy_promoted.rs # this tests is oom-killed in the CI.\n+    for test in $(rg --files-with-matches \"thread|lto\" tests/ui); do\n       rm $test\n     done\n+    git checkout tests/ui/lto/auxiliary/dylib.rs\n     git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n     git checkout tests/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n+    git checkout tests/ui/macros/rfc-2011-nicer-assert-messages/auxiliary/common.rs\n+\n+    RUSTC_ARGS=\"$TEST_FLAGS -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot\"\n+\n+    if [ $# -eq 0 ]; then\n+        # No argument supplied to the function. Doing nothing.\n+        echo \"No argument provided. Keeping all UI tests\"\n+    elif [ $1 = \"0\" ]; then\n+        # Removing the failing tests.\n+        xargs -a ../failing-ui-tests.txt -d'\\n' rm\n+    else\n+        # Removing all tests.\n+        find tests/ui -type f -name '*.rs' -not -path '*/auxiliary/*' -delete\n+        # Putting back only the failing ones.\n+        xargs -a ../failing-ui-tests.txt -d'\\n' git checkout --\n+    fi\n \n-    RUSTC_ARGS=\"-Zpanic-abort-tests -Csymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+    if [ $nb_parts -gt 0 ]; then\n+        echo \"Splitting ui_test into $nb_parts parts (and running part $current_part)\"\n+        find tests/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" > ui_tests\n+        # To ensure it'll be always the same sub files, we sort the content.\n+        sort ui_tests -o ui_tests\n+        count=$((`wc -l < ui_tests` / $nb_parts))\n+        # We increment the number of tests by one because if this is an odd number, we would skip\n+        # one test.\n+        count=$((count + 1))\n+        split -d -l $count -a 1 ui_tests ui_tests.split\n+        # Removing all tests.\n+        find tests/ui -type f -name '*.rs' -not -path \"*/auxiliary/*\" -delete\n+        # Putting back only the ones we want to test.\n+        xargs -a \"ui_tests.split$current_part\" -d'\\n' git checkout --\n+    fi\n \n     echo \"[TEST] rustc test suite\"\n     COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 tests/ui/ --rustc-args \"$RUSTC_ARGS\"\n }\n \n+function test_failing_rustc() {\n+    test_rustc \"1\"\n+}\n+\n+function test_successful_rustc() {\n+    test_rustc \"0\"\n+}\n+\n function clean_ui_tests() {\n-    find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -exec rm -rf {} \\;\n+    find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -delete\n }\n \n function all() {\n     clean\n     mini_tests\n     build_sysroot\n     std_tests\n+    #asm_tests\n     test_libcore\n     extended_sysroot_tests\n     test_rustc\n }\n \n-$func\n+if [ ${#funcs[@]} -eq 0 ]; then\n+    echo \"No command passed, running '--all'...\"\n+    all\n+else\n+    for t in ${funcs[@]}; do\n+        $t\n+    done\n+fi"}, {"sha": "06de26f7efc9f8c8497e79e4d24e911ed6dbe80c", "filename": "compiler/rustc_codegen_gcc/tests/lang_tests_common.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Flang_tests_common.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -46,11 +46,15 @@ pub fn main_inner(profile: Profile) {\n                 &format!(\"-Zcodegen-backend={}/target/debug/librustc_codegen_gcc.so\", current_dir),\n                 \"--sysroot\", &format!(\"{}/build_sysroot/sysroot/\", current_dir),\n                 \"-Zno-parallel-llvm\",\n-                \"-C\", \"panic=abort\",\n                 \"-C\", \"link-arg=-lc\",\n                 \"-o\", exe.to_str().expect(\"to_str\"),\n                 path.to_str().expect(\"to_str\"),\n             ]);\n+            if let Some(flags) = option_env!(\"TEST_FLAGS\") {\n+                for flag in flags.split_whitespace() {\n+                    compiler.arg(&flag);\n+                }\n+            }\n             match profile {\n                 Profile::Debug => {}\n                 Profile::Release => {"}, {"sha": "25041d93e748a6feb2acbd7c14aff9011bb1e7a4", "filename": "compiler/rustc_codegen_gcc/tests/run/abort1.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort1.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -33,6 +33,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "e7443c8dbe5b2f5574784f0b85ea54644904e082", "filename": "compiler/rustc_codegen_gcc/tests/run/abort2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fabort2.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -33,6 +33,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "49b28d98f2fecaa4d0bb0f6935cf460ca441f012", "filename": "compiler/rustc_codegen_gcc/tests/run/array.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Farray.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -79,7 +79,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -105,6 +105,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "427c1a250339749f41627b0d6e7dd40f6886cf7a", "filename": "compiler/rustc_codegen_gcc/tests/run/assign.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fassign.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -57,14 +57,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);"}, {"sha": "8daa681abf7dac19c0838b9717890a8c1119094e", "filename": "compiler/rustc_codegen_gcc/tests/run/closure.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fclosure.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -97,10 +97,14 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n+#[lang = \"tuple_trait\"]\n+pub trait Tuple {}\n+\n #[lang = \"unsize\"]\n pub trait Unsize<T: ?Sized> {}\n \n@@ -114,7 +118,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n \n #[lang = \"fn_once\"]\n #[rustc_paren_sugar]\n-pub trait FnOnce<Args> {\n+pub trait FnOnce<Args: Tuple> {\n     #[lang = \"fn_once_output\"]\n     type Output;\n \n@@ -123,7 +127,7 @@ pub trait FnOnce<Args> {\n \n #[lang = \"fn_mut\"]\n #[rustc_paren_sugar]\n-pub trait FnMut<Args>: FnOnce<Args> {\n+pub trait FnMut<Args: Tuple>: FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n@@ -177,7 +181,7 @@ impl Add for isize {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();"}, {"sha": "b7a13081deae0df4babd931ae1f968ff3cbfe05e", "filename": "compiler/rustc_codegen_gcc/tests/run/condition.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fcondition.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -82,7 +82,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -108,6 +108,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "8a196f774c82bcd6cb5930cee4a823124513db07", "filename": "compiler/rustc_codegen_gcc/tests/run/fun_ptr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Ffun_ptr.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -76,7 +76,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -102,6 +102,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "bfe73c38435a31ec68ccdeff5bd861b392cec3d7", "filename": "compiler/rustc_codegen_gcc/tests/run/int.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -3,22 +3,14 @@\n // Run-time:\n //   status: 0\n \n-#![feature(const_black_box, core_intrinsics, start)]\n-\n-#![no_std]\n-\n-#[panic_handler]\n-fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    core::intrinsics::abort();\n-}\n+#![feature(const_black_box)]\n \n /*\n  * Code\n  */\n \n-#[start]\n-fn main(_argc: isize, _argv: *const *const u8) -> isize {\n-    use core::hint::black_box;\n+fn main() {\n+    use std::hint::black_box;\n \n     macro_rules! check {\n         ($ty:ty, $expr:expr) => {\n@@ -335,6 +327,4 @@ fn main(_argc: isize, _argv: *const *const u8) -> isize {\n         const VAL5: T = 73236519889708027473620326106273939584_i128;\n         check_ops128!();\n     }\n-\n-    0\n }"}, {"sha": "c3fcb3c0a2a069ac97b36066be3f3abe9fab5f0d", "filename": "compiler/rustc_codegen_gcc/tests/run/int_overflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fint_overflow.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -55,14 +55,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         // Panicking is expected iff overflow checking is enabled.\n         #[cfg(debug_assertions)]"}, {"sha": "2a2ea8b8bf0ab0152cb618ce84fd1f3194292891", "filename": "compiler/rustc_codegen_gcc/tests/run/mut_ref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fmut_ref.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -59,14 +59,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);"}, {"sha": "67b9f241dbbb3d06bbba2c3571824a56d54de35a", "filename": "compiler/rustc_codegen_gcc/tests/run/operations.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Foperations.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -65,14 +65,15 @@ mod libc {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }\n \n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         libc::fflush(libc::stdout);"}, {"sha": "da8a8295d564cc31012f6baac799d5180ac644a4", "filename": "compiler/rustc_codegen_gcc/tests/run/ptr_cast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fptr_cast.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -76,7 +76,7 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n #[lang = \"panic\"]\n #[track_caller]\n #[no_mangle]\n-pub fn panic(_msg: &str) -> ! {\n+pub fn panic(_msg: &'static str) -> ! {\n     unsafe {\n         libc::puts(\"Panicking\\0\" as *const str as *const u8);\n         intrinsics::abort();\n@@ -102,6 +102,7 @@ fn panic_bounds_check(index: usize, len: usize) -> ! {\n \n mod intrinsics {\n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "96f1c4792e58fa199f794bfd9f6565691bc301da", "filename": "compiler/rustc_codegen_gcc/tests/run/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fslice.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -102,6 +102,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "19201f1df2667ca9a6e21450690415865b85f63e", "filename": "compiler/rustc_codegen_gcc/tests/run/static.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftests%2Frun%2Fstatic.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -45,6 +45,7 @@ mod intrinsics {\n     use super::Sized;\n \n     extern \"rust-intrinsic\" {\n+        #[rustc_safe_intrinsic]\n         pub fn abort() -> !;\n     }\n }"}, {"sha": "c09fb3c759f3b10189ac2780096a6731d43ad974", "filename": "compiler/rustc_codegen_gcc/tools/check_intrinsics_duplicates.py", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftools%2Fcheck_intrinsics_duplicates.py", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftools%2Fcheck_intrinsics_duplicates.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftools%2Fcheck_intrinsics_duplicates.py?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,67 @@\n+import sys\n+\n+\n+def check_duplicates():\n+    auto_content = \"\"\n+    manual_content = \"\"\n+\n+    with open(\"src/intrinsic/llvm.rs\", \"r\", encoding=\"utf8\") as f:\n+        manual_content = f.read()\n+    with open(\"src/intrinsic/archs.rs\", \"r\", encoding=\"utf8\") as f:\n+        auto_content = f.read()\n+\n+    intrinsics_map = {}\n+    for line in auto_content.splitlines():\n+        line = line.strip()\n+        if not line.startswith('\"'):\n+            continue\n+        parts = line.split('\"')\n+        if len(parts) != 5:\n+            continue\n+        intrinsics_map[parts[1]] = parts[3]\n+\n+    if len(intrinsics_map) == 0:\n+        print(\"No intrinsics found in auto code... Aborting.\")\n+        return 1\n+    print(\"Found {} intrinsics in auto code\".format(len(intrinsics_map)))\n+    errors = []\n+    lines = manual_content.splitlines()\n+    pos = 0\n+    found = 0\n+    while pos < len(lines):\n+        line = lines[pos].strip()\n+        # This is our marker.\n+        if line == \"let gcc_name = match name {\":\n+            while pos < len(lines):\n+                line = lines[pos].strip()\n+                pos += 1\n+                if line == \"};\":\n+                    # We're done!\n+                    if found == 0:\n+                        print(\"No intrinsics found in manual code even though we found the \"\n+                            \"marker... Aborting...\")\n+                        return 1\n+                    for error in errors:\n+                        print(\"ERROR => {}\".format(error))\n+                    return 1 if len(errors) != 0 else 0\n+                parts = line.split('\"')\n+                if len(parts) != 5:\n+                    continue\n+                found += 1\n+                if parts[1] in intrinsics_map:\n+                    if parts[3] != intrinsics_map[parts[1]]:\n+                        print(\"Same intrinsics (`{}` at line {}) but different GCC \"\n+                            \"translations: `{}` != `{}`\".format(\n+                                parts[1], pos, intrinsics_map[parts[1]], parts[3]))\n+                    else:\n+                        errors.append(\"Duplicated intrinsics: `{}` at line {}. Please remove it \"\n+                            \" from manual code\".format(parts[1], pos))\n+            # Weird but whatever...\n+            return 1 if len(errors) != 0 else 0\n+        pos += 1\n+    print(\"No intrinsics found in manual code... Aborting\")\n+    return 1\n+\n+\n+if __name__ == \"__main__\":\n+    sys.exit(check_duplicates())"}, {"sha": "6188924b0d50a52ef4ac4ca30ee28ebd02eac216", "filename": "compiler/rustc_codegen_gcc/tools/generate_intrinsics.py", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftools%2Fgenerate_intrinsics.py?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -13,7 +13,7 @@ def run_command(command, cwd=None):\n         sys.exit(1)\n \n \n-def clone_repository(repo_name, path, repo_url, sub_path=None):\n+def clone_repository(repo_name, path, repo_url, sub_paths=None):\n     if os.path.exists(path):\n         while True:\n             choice = input(\"There is already a `{}` folder, do you want to update it? [y/N]\".format(path))\n@@ -27,69 +27,58 @@ def clone_repository(repo_name, path, repo_url, sub_path=None):\n             else:\n                 print(\"Didn't understand answer...\")\n     print(\"Cloning {} repository...\".format(repo_name))\n-    if sub_path is None:\n+    if sub_paths is None:\n         run_command([\"git\", \"clone\", repo_url, \"--depth\", \"1\", path])\n     else:\n         run_command([\"git\", \"clone\", repo_url, \"--filter=tree:0\", \"--no-checkout\", path])\n         run_command([\"git\", \"sparse-checkout\", \"init\"], cwd=path)\n-        run_command([\"git\", \"sparse-checkout\", \"set\", \"add\", sub_path], cwd=path)\n+        run_command([\"git\", \"sparse-checkout\", \"set\", *sub_paths], cwd=path)\n         run_command([\"git\", \"checkout\"], cwd=path)\n \n \n def append_intrinsic(array, intrinsic_name, translation):\n     array.append((intrinsic_name, translation))\n \n \n-def extract_instrinsics(intrinsics, file):\n-    print(\"Extracting intrinsics from `{}`...\".format(file))\n-    with open(file, \"r\", encoding=\"utf8\") as f:\n-        content = f.read()\n+def convert_to_string(content):\n+    if content.__class__.__name__ == 'bytes':\n+        return content.decode('utf-8')\n+    return content\n \n-    lines = content.splitlines()\n+\n+def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n+    p = subprocess.Popen(\n+        [\"llvm-tblgen\", \"llvm/IR/Intrinsics.td\"],\n+        cwd=os.path.join(llvm_path, \"llvm/include\"),\n+        stdout=subprocess.PIPE)\n+    output, err = p.communicate()\n+    lines = convert_to_string(output).splitlines()\n     pos = 0\n-    current_arch = None\n     while pos < len(lines):\n-        line = lines[pos].strip()\n-        if line.startswith(\"let TargetPrefix =\"):\n-            current_arch = line.split('\"')[1].strip()\n-            if len(current_arch) == 0:\n-                current_arch = None\n-        elif current_arch is None:\n-            pass\n-        elif line == \"}\":\n-            current_arch = None\n-        elif line.startswith(\"def \"):\n-            content = \"\"\n-            while not content.endswith(\";\") and not content.endswith(\"}\") and pos < len(lines):\n-                line = lines[pos].split(\" // \")[0].strip()\n-                content += line\n-                pos += 1\n-            entries = re.findall('GCCBuiltin<\"(\\\\w+)\">', content)\n-            if len(entries) > 0:\n-                intrinsic = content.split(\"def \")[1].strip().split(\":\")[0].strip()\n-                intrinsic = intrinsic.split(\"_\")\n-                if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n-                    continue\n-                intrinsic[0] = \"llvm\"\n-                intrinsic = \".\".join(intrinsic)\n-                if current_arch not in intrinsics:\n-                    intrinsics[current_arch] = []\n-                for entry in entries:\n-                    append_intrinsic(intrinsics[current_arch], intrinsic, entry)\n+        line = lines[pos]\n+        if not line.startswith(\"def \"):\n+            pos += 1\n             continue\n-        pos += 1\n-        continue\n-    print(\"Done!\")\n-\n-\n-def extract_instrinsics_from_llvm(llvm_path, intrinsics):\n-    files = []\n-    intrinsics_path = os.path.join(llvm_path, \"llvm/include/llvm/IR\")\n-    for (dirpath, dirnames, filenames) in walk(intrinsics_path):\n-        files.extend([os.path.join(intrinsics_path, f) for f in filenames if f.endswith(\".td\")])\n-\n-    for file in files:\n-        extract_instrinsics(intrinsics, file)\n+        intrinsic = line.split(\" \")[1].strip()\n+        content = line\n+        while pos < len(lines):\n+            line = lines[pos].split(\" // \")[0].strip()\n+            content += line\n+            pos += 1\n+            if line == \"}\":\n+                break\n+        entries = re.findall('string ClangBuiltinName = \"(\\\\w+)\";', content)\n+        current_arch = re.findall('string TargetPrefix = \"(\\\\w+)\";', content)\n+        if len(entries) == 1 and len(current_arch) == 1:\n+            current_arch = current_arch[0]\n+            intrinsic = intrinsic.split(\"_\")\n+            if len(intrinsic) < 2 or intrinsic[0] != \"int\":\n+                continue\n+            intrinsic[0] = \"llvm\"\n+            intrinsic = \".\".join(intrinsic)\n+            if current_arch not in intrinsics:\n+                intrinsics[current_arch] = []\n+            append_intrinsic(intrinsics[current_arch], intrinsic, entries[0])\n \n \n def append_translation(json_data, p, array):\n@@ -193,6 +182,8 @@ def update_intrinsics(llvm_path, llvmint, llvmint2):\n             for entry in intrinsics[arch]:\n                 if entry[2] == True: # if it is a duplicate\n                     out.write('    // [DUPLICATE]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n+                elif \"_round_mask\" in entry[1]:\n+                    out.write('    // [INVALID CONVERSION]: \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n                 else:\n                     out.write('    \"{}\" => \"{}\",\\n'.format(entry[0], entry[1]))\n         out.write('    _ => unimplemented!(\"***** unsupported LLVM intrinsic {}\", name),\\n')\n@@ -219,7 +210,7 @@ def main():\n         \"llvm-project\",\n         llvm_path,\n         \"https://github.com/llvm/llvm-project\",\n-        sub_path=\"llvm/include/llvm/IR\",\n+        sub_paths=[\"llvm/include/llvm/IR\", \"llvm/include/llvm/CodeGen/\"],\n     )\n     clone_repository(\n         \"llvmint\","}, {"sha": "509cb0fef565e167775be25218723d632e960a29", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -640,9 +640,6 @@ extern \"C\" {\n pub struct Builder<'a>(InvariantOpaque<'a>);\n #[repr(C)]\n pub struct PassManager<'a>(InvariantOpaque<'a>);\n-extern \"C\" {\n-    pub type PassManagerBuilder;\n-}\n extern \"C\" {\n     pub type Pass;\n }"}, {"sha": "50e857ef60d1d8dc796fc1c36361ff86d21b1243", "filename": "compiler/rustc_hir_analysis/locales/en-US.ftl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -155,3 +155,11 @@ hir_analysis_cannot_capture_late_bound_ty_in_anon_const =\n hir_analysis_cannot_capture_late_bound_const_in_anon_const =\n     cannot capture late-bound const parameter in a constant\n     .label = parameter defined here\n+\n+hir_analysis_variances_of = {$variances_of}\n+\n+hir_analysis_pass_to_variadic_function = can't pass `{$ty}` to variadic function\n+    .suggestion = cast the value to `{$cast_ty}`\n+    .help = cast the value to `{$cast_ty}`\n+\n+hir_analysis_cast_thin_pointer_to_fat_pointer = cannot cast thin pointer `{$expr_ty}` to fat pointer `{$cast_ty}`"}, {"sha": "74fec93d91e1eddd4e80dec32ac09caaf3f54f12", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -399,3 +399,34 @@ pub(crate) enum CannotCaptureLateBoundInAnonConst {\n         def_span: Span,\n     },\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_variances_of)]\n+pub(crate) struct VariancesOf {\n+    #[primary_span]\n+    pub span: Span,\n+    pub variances_of: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_pass_to_variadic_function, code = \"E0617\")]\n+pub(crate) struct PassToVariadicFunction<'tcx, 'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'tcx>,\n+    pub cast_ty: &'a str,\n+    #[suggestion(code = \"{replace}\", applicability = \"machine-applicable\")]\n+    pub sugg_span: Option<Span>,\n+    pub replace: String,\n+    #[help]\n+    pub help: Option<()>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_cast_thin_pointer_to_fat_pointer, code = \"E0607\")]\n+pub(crate) struct CastThinPointerToFatPointer<'tcx> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub expr_ty: Ty<'tcx>,\n+    pub cast_ty: String,\n+}"}, {"sha": "0bfbf99cb0b588b9ebb51acd0f1ba69b13fe58f4", "filename": "compiler/rustc_hir_analysis/src/structured_errors/missing_cast_for_variadic_arg.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fmissing_cast_for_variadic_arg.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,5 +1,5 @@\n-use crate::structured_errors::StructuredDiagnostic;\n-use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n+use crate::{errors, structured_errors::StructuredDiagnostic};\n+use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n use rustc_middle::ty::{Ty, TypeVisitableExt};\n use rustc_session::Session;\n use rustc_span::Span;\n@@ -21,27 +21,26 @@ impl<'tcx> StructuredDiagnostic<'tcx> for MissingCastForVariadicArg<'tcx, '_> {\n     }\n \n     fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = self.sess.struct_span_err_with_code(\n-            self.span,\n-            &format!(\"can't pass `{}` to variadic function\", self.ty),\n-            self.code(),\n-        );\n+        let (sugg_span, replace, help) =\n+            if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.span) {\n+                (Some(self.span), format!(\"{} as {}\", snippet, self.cast_ty), None)\n+            } else {\n+                (None, \"\".to_string(), Some(()))\n+            };\n+\n+        let mut err = self.sess.create_err(errors::PassToVariadicFunction {\n+            span: self.span,\n+            ty: self.ty,\n+            cast_ty: self.cast_ty,\n+            help,\n+            replace,\n+            sugg_span,\n+        });\n \n         if self.ty.references_error() {\n             err.downgrade_to_delayed_bug();\n         }\n \n-        if let Ok(snippet) = self.sess.source_map().span_to_snippet(self.span) {\n-            err.span_suggestion(\n-                self.span,\n-                &format!(\"cast the value to `{}`\", self.cast_ty),\n-                format!(\"{} as {}\", snippet, self.cast_ty),\n-                Applicability::MachineApplicable,\n-            );\n-        } else {\n-            err.help(&format!(\"cast the value to `{}`\", self.cast_ty));\n-        }\n-\n         err\n     }\n "}, {"sha": "910417abe6e7c670c9b6b5e51f3d017eab041f4a", "filename": "compiler/rustc_hir_analysis/src/structured_errors/sized_unsized_cast.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fsized_unsized_cast.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,4 +1,4 @@\n-use crate::structured_errors::StructuredDiagnostic;\n+use crate::{errors, structured_errors::StructuredDiagnostic};\n use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n use rustc_middle::ty::{Ty, TypeVisitableExt};\n use rustc_session::Session;\n@@ -21,14 +21,11 @@ impl<'tcx> StructuredDiagnostic<'tcx> for SizedUnsizedCast<'tcx> {\n     }\n \n     fn diagnostic_common(&self) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n-        let mut err = self.sess.struct_span_err_with_code(\n-            self.span,\n-            &format!(\n-                \"cannot cast thin pointer `{}` to fat pointer `{}`\",\n-                self.expr_ty, self.cast_ty\n-            ),\n-            self.code(),\n-        );\n+        let mut err = self.sess.create_err(errors::CastThinPointerToFatPointer {\n+            span: self.span,\n+            expr_ty: self.expr_ty,\n+            cast_ty: self.cast_ty.to_owned(),\n+        });\n \n         if self.expr_ty.references_error() {\n             err.downgrade_to_delayed_bug();"}, {"sha": "64614831f560f99bef2f2f83c08fab2c99366f66", "filename": "compiler/rustc_hir_analysis/src/variance/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1,14 +1,19 @@\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::sym;\n \n+use crate::errors;\n+\n pub fn test_variance(tcx: TyCtxt<'_>) {\n     // For unit testing: check for a special \"rustc_variance\"\n     // attribute and report an error with various results if found.\n     for id in tcx.hir().items() {\n         if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_variance) {\n             let variances_of = tcx.variances_of(id.owner_id);\n \n-            tcx.sess.struct_span_err(tcx.def_span(id.owner_id), format!(\"{variances_of:?}\")).emit();\n+            tcx.sess.emit_err(errors::VariancesOf {\n+                span: tcx.def_span(id.owner_id),\n+                variances_of: format!(\"{variances_of:?}\"),\n+            });\n         }\n     }\n }"}, {"sha": "e604e44a7157b8876180aa57810a5808fb842c0f", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -26,7 +26,6 @@\n #endif\n #include \"llvm/Support/Host.h\"\n #include \"llvm/Target/TargetMachine.h\"\n-#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n #include \"llvm/Transforms/IPO/AlwaysInliner.h\"\n #include \"llvm/Transforms/IPO/FunctionImport.h\"\n #include \"llvm/Transforms/IPO/Internalize.h\"\n@@ -35,7 +34,6 @@\n #include \"llvm/Transforms/Utils/FunctionImportUtils.h\"\n #include \"llvm/LTO/LTO.h\"\n #include \"llvm/Bitcode/BitcodeWriter.h\"\n-#include \"llvm-c/Transforms/PassManagerBuilder.h\"\n \n #include \"llvm/Transforms/Instrumentation.h\"\n #include \"llvm/Transforms/Instrumentation/AddressSanitizer.h\""}, {"sha": "70c9de91fbfef62a4d50b04cb488dd07a833005c", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -142,12 +142,14 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n         && tcx.associated_item(def_id).container == ty::AssocItemContainer::TraitContainer\n     {\n         let sig = tcx.fn_sig(def_id).subst_identity();\n-        sig.visit_with(&mut ImplTraitInTraitFinder {\n+        // We accounted for the binder of the fn sig, so skip the binder.\n+        sig.skip_binder().visit_with(&mut ImplTraitInTraitFinder {\n             tcx,\n             fn_def_id: def_id,\n             bound_vars: sig.bound_vars(),\n             predicates: &mut predicates,\n             seen: FxHashSet::default(),\n+            depth: ty::INNERMOST,\n         });\n     }\n \n@@ -244,15 +246,36 @@ struct ImplTraitInTraitFinder<'a, 'tcx> {\n     fn_def_id: DefId,\n     bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n     seen: FxHashSet<DefId>,\n+    depth: ty::DebruijnIndex,\n }\n \n impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n+    fn visit_binder<T: TypeVisitable<TyCtxt<'tcx>>>(\n+        &mut self,\n+        binder: &ty::Binder<'tcx, T>,\n+    ) -> std::ops::ControlFlow<Self::BreakTy> {\n+        self.depth.shift_in(1);\n+        let binder = binder.super_visit_with(self);\n+        self.depth.shift_out(1);\n+        binder\n+    }\n+\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n         if let ty::Alias(ty::Projection, alias_ty) = *ty.kind()\n             && self.tcx.def_kind(alias_ty.def_id) == DefKind::ImplTraitPlaceholder\n             && self.tcx.impl_trait_in_trait_parent(alias_ty.def_id) == self.fn_def_id\n             && self.seen.insert(alias_ty.def_id)\n         {\n+            // We have entered some binders as we've walked into the\n+            // bounds of the RPITIT. Shift these binders back out when\n+            // constructing the top-level projection predicate.\n+            let alias_ty = self.tcx.fold_regions(alias_ty, |re, _| {\n+                if let ty::ReLateBound(index, bv) = re.kind() {\n+                    self.tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n+                } else {\n+                    re\n+                }\n+            });\n             self.predicates.push(\n                 ty::Binder::bind_with_vars(\n                     ty::ProjectionPredicate {"}, {"sha": "dee0d8f254b63596dfded6caf64c7c197dbcb9ab", "filename": "config.toml.example", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -659,6 +659,10 @@ changelog-seen = 2\n # Build compiler with the optimization enabled and -Zvalidate-mir, currently only for `std`\n #validate-mir-opts = 3\n \n+# Copy the linker, DLLs, and various libraries from MinGW into the rustc toolchain.\n+# Only applies when the host or target is pc-windows-gnu.\n+#include-mingw-linker = true\n+\n # =============================================================================\n # Options for specific targets\n #"}, {"sha": "3d48db8660a261fab90b28217a6efebe93a4fa3b", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -910,14 +910,16 @@ impl<'a> Builder<'a> {\n     /// new artifacts, it can't be used to rely on the presence of a particular\n     /// sysroot.\n     ///\n-    /// See `force_use_stage1` for documentation on what each argument is.\n+    /// See `force_use_stage1` and `force_use_stage2` for documentation on what each argument is.\n     pub fn compiler_for(\n         &self,\n         stage: u32,\n         host: TargetSelection,\n         target: TargetSelection,\n     ) -> Compiler {\n-        if self.build.force_use_stage1(Compiler { stage, host }, target) {\n+        if self.build.force_use_stage2() {\n+            self.compiler(2, self.config.build)\n+        } else if self.build.force_use_stage1(Compiler { stage, host }, target) {\n             self.compiler(1, self.config.build)\n         } else {\n             self.compiler(stage, host)"}, {"sha": "4f417d36511ba6af6bffcae40a1e29b61711d0f8", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -190,6 +190,7 @@ pub struct Config {\n     pub dist_sign_folder: Option<PathBuf>,\n     pub dist_upload_addr: Option<String>,\n     pub dist_compression_formats: Option<Vec<String>>,\n+    pub dist_include_mingw_linker: bool,\n \n     // libstd features\n     pub backtrace: bool, // support for RUST_BACKTRACE\n@@ -700,6 +701,7 @@ define_config! {\n         src_tarball: Option<bool> = \"src-tarball\",\n         missing_tools: Option<bool> = \"missing-tools\",\n         compression_formats: Option<Vec<String>> = \"compression-formats\",\n+        include_mingw_linker: Option<bool> = \"include-mingw-linker\",\n     }\n }\n \n@@ -816,6 +818,7 @@ impl Config {\n         config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n         config.deny_warnings = true;\n         config.bindir = \"bin\".into();\n+        config.dist_include_mingw_linker = true;\n \n         // set by build.rs\n         config.build = TargetSelection::from_user(&env!(\"BUILD_TRIPLE\"));\n@@ -1299,6 +1302,7 @@ impl Config {\n             config.dist_compression_formats = t.compression_formats;\n             set(&mut config.rust_dist_src, t.src_tarball);\n             set(&mut config.missing_tools, t.missing_tools);\n+            set(&mut config.dist_include_mingw_linker, t.include_mingw_linker)\n         }\n \n         if let Some(r) = build.rustfmt {"}, {"sha": "c9384004100b20ea77f09d60cf710d3a0891f080", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -324,7 +324,7 @@ impl Step for Mingw {\n     /// without any extra installed software (e.g., we bundle gcc, libraries, etc).\n     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {\n         let host = self.host;\n-        if !host.ends_with(\"pc-windows-gnu\") {\n+        if !host.ends_with(\"pc-windows-gnu\") || !builder.config.dist_include_mingw_linker {\n             return None;\n         }\n \n@@ -380,7 +380,7 @@ impl Step for Rustc {\n         // anything requiring us to distribute a license, but it's likely the\n         // install will *also* include the rust-mingw package, which also needs\n         // licenses, so to be safe we just include it here in all MinGW packages.\n-        if host.ends_with(\"pc-windows-gnu\") {\n+        if host.ends_with(\"pc-windows-gnu\") && builder.config.dist_include_mingw_linker {\n             make_win_dist(tarball.image_dir(), &tmpdir(builder), host, builder);\n             tarball.add_dir(builder.src.join(\"src/etc/third-party\"), \"share/doc\");\n         }"}, {"sha": "ebd42bcf678cb98e85110ae0456ea3ed5c75633e", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -1209,6 +1209,15 @@ impl Build {\n             && (self.hosts.iter().any(|h| *h == target) || target == self.build)\n     }\n \n+    /// Checks whether the `compiler` compiling for `target` should be forced to\n+    /// use a stage2 compiler instead.\n+    ///\n+    /// When we download the pre-compiled version of rustc it should be forced to\n+    /// use a stage2 compiler.\n+    fn force_use_stage2(&self) -> bool {\n+        self.config.download_rustc()\n+    }\n+\n     /// Given `num` in the form \"a.b.c\" return a \"release string\" which\n     /// describes the release version number.\n     ///"}, {"sha": "a127875b55d5ffc3eba277ee330e427bc4133a8e", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -983,7 +983,12 @@ impl<'test> TestCx<'test> {\n                 &[\"-quiet\".as_ref(), \"-batch\".as_ref(), \"-nx\".as_ref(), &debugger_script];\n \n             let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n-            gdb.args(debugger_opts).env(\"PYTHONPATH\", rust_pp_module_abs_path);\n+            let pythonpath = if let Ok(pp) = std::env::var(\"PYTHONPATH\") {\n+                format!(\"{pp}:{rust_pp_module_abs_path}\")\n+            } else {\n+                rust_pp_module_abs_path\n+            };\n+            gdb.args(debugger_opts).env(\"PYTHONPATH\", pythonpath);\n \n             debugger_run_result =\n                 self.compose_and_run(gdb, self.config.run_lib_path.to_str().unwrap(), None, None);\n@@ -1149,13 +1154,18 @@ impl<'test> TestCx<'test> {\n     ) -> ProcRes {\n         // Prepare the lldb_batchmode which executes the debugger script\n         let lldb_script_path = rust_src_root.join(\"src/etc/lldb_batchmode.py\");\n+        let pythonpath = if let Ok(pp) = std::env::var(\"PYTHONPATH\") {\n+            format!(\"{pp}:{}\", self.config.lldb_python_dir.as_ref().unwrap())\n+        } else {\n+            self.config.lldb_python_dir.as_ref().unwrap().to_string()\n+        };\n         self.cmd2procres(\n             Command::new(&self.config.python)\n                 .arg(&lldb_script_path)\n                 .arg(test_executable)\n                 .arg(debugger_script)\n                 .env(\"PYTHONUNBUFFERED\", \"1\") // Help debugging #78665\n-                .env(\"PYTHONPATH\", self.config.lldb_python_dir.as_ref().unwrap()),\n+                .env(\"PYTHONPATH\", pythonpath),\n         )\n     }\n "}, {"sha": "5cf90c5d93c24da7f00de5e0bf54167239791870", "filename": "tests/ui/impl-trait/in-trait/default-method-binder-shifting.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.rs?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+#![feature(return_position_impl_trait_in_trait)]\n+//~^ WARN the feature `return_position_impl_trait_in_trait` is incomplete\n+\n+trait Trait {\n+    type Type;\n+\n+    // Check that we're adjusting bound vars correctly when installing the default\n+    // method projection assumptions.\n+    fn method(&self) -> impl Trait<Type = impl Sized + '_>;\n+}\n+\n+fn main() {}"}, {"sha": "7c7ebcdb7e717d79f847dc0165615ec6d97b8722", "filename": "tests/ui/impl-trait/in-trait/default-method-binder-shifting.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38b96553112dce3de630890701f17d86e265f6ba/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38b96553112dce3de630890701f17d86e265f6ba/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fin-trait%2Fdefault-method-binder-shifting.stderr?ref=38b96553112dce3de630890701f17d86e265f6ba", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `return_position_impl_trait_in_trait` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/default-method-binder-shifting.rs:3:12\n+   |\n+LL | #![feature(return_position_impl_trait_in_trait)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: 1 warning emitted\n+"}]}