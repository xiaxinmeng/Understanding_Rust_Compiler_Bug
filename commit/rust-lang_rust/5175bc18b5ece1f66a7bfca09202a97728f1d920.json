{"sha": "5175bc18b5ece1f66a7bfca09202a97728f1d920", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNzViYzE4YjVlY2UxZjY2YTdiZmNhMDkyMDJhOTc3MjhmMWQ5MjA=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-08T10:38:30Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-09T09:27:56Z"}, "message": "rustc_typeck: do not mutate tables directly during upvar inference.", "tree": {"sha": "cbb21b2b04c32ddaa45e6be5b066531e873ad9f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbb21b2b04c32ddaa45e6be5b066531e873ad9f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5175bc18b5ece1f66a7bfca09202a97728f1d920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5175bc18b5ece1f66a7bfca09202a97728f1d920", "html_url": "https://github.com/rust-lang/rust/commit/5175bc18b5ece1f66a7bfca09202a97728f1d920", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5175bc18b5ece1f66a7bfca09202a97728f1d920/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b1b05bcebc1c6c8c2a7acdaa1970167c5b98cb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b1b05bcebc1c6c8c2a7acdaa1970167c5b98cb4", "html_url": "https://github.com/rust-lang/rust/commit/8b1b05bcebc1c6c8c2a7acdaa1970167c5b98cb4"}], "stats": {"total": 326, "additions": 107, "deletions": 219}, "files": [{"sha": "6e9d028aa64798190020d062b7b825f47a083d83", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=5175bc18b5ece1f66a7bfca09202a97728f1d920", "patch": "@@ -1521,10 +1521,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         !traits::type_known_to_meet_bound(self, param_env, ty, copy_def_id, span)\n     }\n \n-    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n-        self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n-    }\n-\n     pub fn closure_kind(&self,\n                         def_id: DefId)\n                         -> Option<ty::ClosureKind>"}, {"sha": "4075d28a396a513ec61e90f52b75cc83bfb1021d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 18, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5175bc18b5ece1f66a7bfca09202a97728f1d920", "patch": "@@ -270,23 +270,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                param_env: ty::ParamEnv<'tcx>)\n                -> Self\n-    {\n-        ExprUseVisitor::with_options(delegate,\n-                                     infcx,\n-                                     param_env,\n-                                     region_maps,\n-                                     mc::MemCategorizationOptions::default())\n-    }\n-\n-    pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n-                        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                        param_env: ty::ParamEnv<'tcx>,\n-                        region_maps: &'a RegionMaps,\n-                        options: mc::MemCategorizationOptions)\n-               -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::with_options(infcx, region_maps, options),\n+            mc: mc::MemCategorizationContext::new(infcx, region_maps),\n             delegate,\n             param_env,\n         }\n@@ -678,8 +664,8 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n-        //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adjustments = self.mc.infcx.tables.borrow().expr_adjustments(expr).to_vec();\n+        let tables = self.mc.infcx.tables.borrow();\n+        let adjustments = tables.expr_adjustments(expr);\n         let mut cmt = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         for adjustment in adjustments {\n             debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n@@ -896,7 +882,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 let id_var = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n-                let upvar_capture = self.mc.infcx.upvar_capture(upvar_id).unwrap();\n+                let upvar_capture = self.mc.infcx.tables.borrow().upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                    fn_decl_span,\n                                                                    freevar.def));"}, {"sha": "ddbc7f91097d5c6b83666d215fec6f30ca7034f8", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 59, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5175bc18b5ece1f66a7bfca09202a97728f1d920", "patch": "@@ -283,18 +283,6 @@ impl ast_node for hir::Pat {\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     pub region_maps: &'a RegionMaps,\n-    options: MemCategorizationOptions,\n-}\n-\n-#[derive(Copy, Clone, Default)]\n-pub struct MemCategorizationOptions {\n-    // If true, then when analyzing a closure upvar, if the closure\n-    // has a missing kind, we treat it like a Fn closure. When false,\n-    // we ICE if the closure has a missing kind. Should be false\n-    // except during closure kind inference. It is used by the\n-    // mem-categorization code to be able to have stricter assertions\n-    // (which are always true except during upvar inference).\n-    pub during_closure_kind_inference: bool,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -400,20 +388,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n                region_maps: &'a RegionMaps)\n                -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext::with_options(infcx,\n-                                               region_maps,\n-                                               MemCategorizationOptions::default())\n-    }\n-\n-    pub fn with_options(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                        region_maps: &'a RegionMaps,\n-                        options: MemCategorizationOptions)\n-                        -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext {\n-            infcx: infcx,\n-            region_maps: region_maps,\n-            options: options,\n-        }\n+        MemCategorizationContext { infcx, region_maps }\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -620,38 +595,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n           Def::Upvar(def_id, _, fn_node_id) => {\n               let var_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-              let ty = self.node_ty(fn_node_id)?;\n-              match ty.sty {\n-                  ty::TyClosure(closure_id, _) => {\n-                      match self.infcx.closure_kind(closure_id) {\n-                          Some(kind) => {\n-                              self.cat_upvar(id, span, var_id, fn_node_id, kind)\n-                          }\n-                          None => {\n-                              if !self.options.during_closure_kind_inference {\n-                                  span_bug!(\n-                                      span,\n-                                      \"No closure kind for {:?}\",\n-                                      closure_id);\n-                              }\n-\n-                              // during closure kind inference, we\n-                              // don't know the closure kind yet, but\n-                              // it's ok because we detect that we are\n-                              // accessing an upvar and handle that\n-                              // case specially anyhow. Use Fn\n-                              // arbitrarily.\n-                              self.cat_upvar(id, span, var_id, fn_node_id, ty::ClosureKind::Fn)\n-                          }\n-                      }\n-                  }\n-                  _ => {\n-                      span_bug!(\n-                          span,\n-                          \"Upvar of non-closure {} - {:?}\",\n-                          fn_node_id,\n-                          ty);\n-                  }\n+              let closure_id = self.tcx().hir.local_def_id(fn_node_id);\n+              match self.infcx.closure_kind(closure_id) {\n+                Some(kind) => {\n+                    self.cat_upvar(id, span, var_id, fn_node_id, kind)\n+                }\n+                None => {\n+                    span_bug!(span, \"No closure kind for {:?}\", closure_id);\n+                }\n               }\n           }\n \n@@ -743,7 +694,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // for that.\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n-        let upvar_capture = self.infcx.upvar_capture(upvar_id).unwrap();\n+        let upvar_capture = self.infcx.tables.borrow().upvar_capture(upvar_id);\n         let cmt_result = match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n                 cmt_result"}, {"sha": "2d81606329e57d89e530101e7a1cb116b85a7f59", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=5175bc18b5ece1f66a7bfca09202a97728f1d920", "patch": "@@ -376,8 +376,8 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n-    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n-        Some(self.upvar_capture_map.get(&upvar_id).unwrap().clone())\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n+        self.upvar_capture_map[&upvar_id]\n     }\n }\n "}, {"sha": "7490ee60e1f9f6c10f8da4fc12591cd45efaa581", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=5175bc18b5ece1f66a7bfca09202a97728f1d920", "patch": "@@ -365,13 +365,14 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n             let var_id = tcx.hir.as_local_node_id(fv.def.def_id()).unwrap();\n-            let by_ref = hir.tables().upvar_capture(ty::UpvarId {\n+            let capture = hir.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_id,\n                 closure_expr_id: fn_id\n-            }).map_or(false, |capture| match capture {\n+            });\n+            let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n                 ty::UpvarCapture::ByRef(..) => true\n-            });\n+            };\n             let mut decl = UpvarDecl {\n                 debug_name: keywords::Invalid.name(),\n                 by_ref: by_ref"}, {"sha": "474feefabbb88dcc12d14967818e0217031e5805", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5175bc18b5ece1f66a7bfca09202a97728f1d920", "patch": "@@ -758,13 +758,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 var_id: id_var,\n                 closure_expr_id: closure_expr_id,\n             };\n-            let upvar_capture = match cx.tables().upvar_capture(upvar_id) {\n-                Some(c) => c,\n-                None => {\n-                    span_bug!(expr.span, \"no upvar_capture for {:?}\", upvar_id);\n-                }\n-            };\n-            match upvar_capture {\n+            match cx.tables().upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => {\n                     ExprKind::Deref {\n@@ -878,7 +872,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,\n     };\n-    let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n+    let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n     let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {"}, {"sha": "9c3e5cd1f4005f6d2598da7fabfd3d8e0bb0c55e", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5175bc18b5ece1f66a7bfca09202a97728f1d920", "patch": "@@ -834,8 +834,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             mc.cat_expr_unadjusted(expr)?\n         };\n \n-        //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adjustments = self.tables.borrow().expr_adjustments(&expr).to_vec();\n+        let tables = self.tables.borrow();\n+        let adjustments = tables.expr_adjustments(&expr);\n         if adjustments.is_empty() {\n             return Ok(cmt);\n         }\n@@ -1215,8 +1215,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // Detect by-ref upvar `x`:\n         let cause = match note {\n             mc::NoteUpvarRef(ref upvar_id) => {\n-                let upvar_capture_map = &self.tables.borrow_mut().upvar_capture_map;\n-                match upvar_capture_map.get(upvar_id) {\n+                match self.tables.borrow().upvar_capture_map.get(upvar_id) {\n                     Some(&ty::UpvarCapture::ByRef(ref upvar_borrow)) => {\n                         // The mutability of the upvar may have been modified\n                         // by the above adjustment, so update our local variable."}, {"sha": "1f0911bb234e6fc170c4957c6d13d4cc10095c11", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 82, "deletions": 121, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5175bc18b5ece1f66a7bfca09202a97728f1d920/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=5175bc18b5ece1f66a7bfca09202a97728f1d920", "patch": "@@ -53,31 +53,22 @@ use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::util::nodemap::NodeMap;\n \n-///////////////////////////////////////////////////////////////////////////\n-// PUBLIC ENTRY POINTS\n+use std::collections::hash_map::Entry;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_analyze(&self, body: &'gcx hir::Body) {\n-        let mut seed = SeedBorrowKind::new(self);\n-        seed.visit_body(body);\n-\n-        let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n-        adjust.visit_body(body);\n+        InferBorrowKindVisitor { fcx: self }.visit_body(body);\n \n         // it's our job to process these.\n         assert!(self.deferred_call_resolutions.borrow().is_empty());\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// SEED BORROW KIND\n-\n-struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct InferBorrowKindVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n         NestedVisitorMap::None\n     }\n@@ -87,7 +78,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n             hir::ExprClosure(cc, _, body_id, _) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n-                self.check_closure(expr, cc);\n+                self.fcx.analyze_closure(expr.id, expr.span, body, cc);\n             }\n \n             _ => { }\n@@ -97,85 +88,71 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>) -> SeedBorrowKind<'a, 'gcx, 'tcx> {\n-        SeedBorrowKind { fcx: fcx, temp_closure_kinds: NodeMap() }\n-    }\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+    fn analyze_closure(&self,\n+                       id: ast::NodeId,\n+                       span: Span,\n+                       body: &hir::Body,\n+                       capture_clause: hir::CaptureClause) {\n+        /*!\n+         * Analysis starting point.\n+         */\n \n-    fn check_closure(&mut self,\n-                     expr: &hir::Expr,\n-                     capture_clause: hir::CaptureClause)\n-    {\n-        if !self.fcx.tables.borrow().closure_kinds.contains_key(&expr.id) {\n-            self.temp_closure_kinds.insert(expr.id, (ty::ClosureKind::Fn, None));\n-            debug!(\"check_closure: adding closure {:?} as Fn\", expr.id);\n-        }\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n \n-        self.fcx.tcx.with_freevars(expr.id, |freevars| {\n+        let infer_kind = match self.tables.borrow_mut().closure_kinds.entry(id) {\n+            Entry::Occupied(_) => false,\n+            Entry::Vacant(entry) => {\n+                debug!(\"check_closure: adding closure {:?} as Fn\", id);\n+                entry.insert((ty::ClosureKind::Fn, None));\n+                true\n+            }\n+        };\n+\n+        self.tcx.with_freevars(id, |freevars| {\n             for freevar in freevars {\n                 let def_id = freevar.def.def_id();\n-                let var_node_id = self.fcx.tcx.hir.as_local_node_id(def_id).unwrap();\n+                let var_node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                             closure_expr_id: expr.id };\n+                                             closure_expr_id: id };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n \n                 let capture_kind = match capture_clause {\n                     hir::CaptureByValue => {\n                         ty::UpvarCapture::ByValue\n                     }\n                     hir::CaptureByRef => {\n-                        let origin = UpvarRegion(upvar_id, expr.span);\n-                        let freevar_region = self.fcx.next_region_var(origin);\n+                        let origin = UpvarRegion(upvar_id, span);\n+                        let freevar_region = self.next_region_var(origin);\n                         let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n                                                              region: freevar_region };\n                         ty::UpvarCapture::ByRef(upvar_borrow)\n                     }\n                 };\n \n-                self.fcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n+                self.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n             }\n         });\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// ADJUST BORROW KIND\n-\n-struct AdjustBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n-}\n-\n-impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-           temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>)\n-           -> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n-        AdjustBorrowKind { fcx: fcx, temp_closure_kinds: temp_closure_kinds }\n-    }\n-\n-    fn analyze_closure(&mut self,\n-                       id: ast::NodeId,\n-                       span: Span,\n-                       body: &hir::Body) {\n-        /*!\n-         * Analysis starting point.\n-         */\n-\n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n \n         {\n-            let body_owner_def_id = self.fcx.tcx.hir.body_owner_def_id(body.id());\n-            let region_maps = &self.fcx.tcx.region_maps(body_owner_def_id);\n-            let param_env = self.fcx.param_env;\n-            let mut euv =\n-                euv::ExprUseVisitor::with_options(self,\n-                                                  self.fcx,\n-                                                  param_env,\n-                                                  region_maps,\n-                                                  mc::MemCategorizationOptions {\n-                                                      during_closure_kind_inference: true\n-                                                  });\n-            euv.consume_body(body);\n+            let body_owner_def_id = self.tcx.hir.body_owner_def_id(body.id());\n+            let region_maps = &self.tcx.region_maps(body_owner_def_id);\n+            let mut delegate = InferBorrowKind {\n+                fcx: self,\n+                adjust_closure_kinds: NodeMap(),\n+                adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n+            };\n+            euv::ExprUseVisitor::new(&mut delegate, region_maps, self, self.param_env)\n+                .consume_body(body);\n+\n+            // Write the adjusted values back into the main tables.\n+            if infer_kind {\n+                if let Some(kind) = delegate.adjust_closure_kinds.remove(&id) {\n+                    self.tables.borrow_mut().closure_kinds.insert(id, kind);\n+                }\n+            }\n+            self.tables.borrow_mut().upvar_capture_map.extend(\n+                delegate.adjust_upvar_captures);\n         }\n \n         // Now that we've analyzed the closure, we know how each\n@@ -191,7 +168,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Extract the type variables UV0...UVn.\n-        let (def_id, closure_substs) = match self.fcx.node_ty(id).sty {\n+        let (def_id, closure_substs) = match self.node_ty(id).sty {\n             ty::TyClosure(def_id, substs) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n@@ -206,44 +183,41 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n                id, closure_substs, final_upvar_tys);\n         for (upvar_ty, final_upvar_ty) in\n-            closure_substs.upvar_tys(def_id, self.fcx.tcx).zip(final_upvar_tys)\n+            closure_substs.upvar_tys(def_id, self.tcx).zip(final_upvar_tys)\n         {\n-            self.fcx.demand_eqtype(span, final_upvar_ty, upvar_ty);\n+            self.demand_eqtype(span, final_upvar_ty, upvar_ty);\n         }\n \n-        // If we are also inferred the closure kind here, update the\n-        // main table and process any deferred resolutions.\n-        if let Some(&(kind, context)) = self.temp_closure_kinds.get(&id) {\n-            self.fcx.tables.borrow_mut().closure_kinds.insert(id, (kind, context));\n-            let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n-            debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n-\n+        // If we are also inferred the closure kind here,\n+        // process any deferred resolutions.\n+        if infer_kind {\n+            let closure_def_id = self.tcx.hir.local_def_id(id);\n             let deferred_call_resolutions =\n-                self.fcx.remove_deferred_call_resolutions(closure_def_id);\n+                self.remove_deferred_call_resolutions(closure_def_id);\n             for deferred_call_resolution in deferred_call_resolutions {\n-                deferred_call_resolution.resolve(self.fcx);\n+                deferred_call_resolution.resolve(self);\n             }\n         }\n     }\n \n     // Returns a list of `ClosureUpvar`s for each upvar.\n-    fn final_upvar_tys(&mut self, closure_id: ast::NodeId) -> Vec<Ty<'tcx>> {\n+    fn final_upvar_tys(&self, closure_id: ast::NodeId) -> Vec<Ty<'tcx>> {\n         // Presently an unboxed closure type cannot \"escape\" out of a\n         // function, so we will only encounter ones that originated in the\n         // local crate or were inlined into it along with some function.\n         // This may change if abstract return types of some sort are\n         // implemented.\n-        let tcx = self.fcx.tcx;\n+        let tcx = self.tcx;\n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter().map(|freevar| {\n                 let def_id = freevar.def.def_id();\n                 let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar_ty = self.fcx.node_ty(var_id);\n+                let freevar_ty = self.node_ty(var_id);\n                 let upvar_id = ty::UpvarId {\n                     var_id: var_id,\n                     closure_expr_id: closure_id\n                 };\n-                let capture = self.fcx.upvar_capture(upvar_id).unwrap();\n+                let capture = self.tables.borrow().upvar_capture(upvar_id);\n \n                 debug!(\"var_id={:?} freevar_ty={:?} capture={:?}\",\n                        var_id, freevar_ty, capture);\n@@ -260,7 +234,15 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             }).collect()\n         })\n     }\n+}\n \n+struct InferBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    adjust_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+    adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     fn adjust_upvar_borrow_kind_for_consume(&mut self,\n                                             cmt: mc::cmt<'tcx>,\n                                             mode: euv::ConsumeMode)\n@@ -297,9 +279,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                                                  guarantor.span,\n                                                  tcx.hir.name(upvar_id.var_id));\n \n-                        let upvar_capture_map =\n-                            &mut self.fcx.tables.borrow_mut().upvar_capture_map;\n-                        upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n+                        self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n                     mc::NoteClosureEnv(upvar_id) => {\n                         // we get just a closureenv ref if this is a\n@@ -410,11 +390,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                 // upvar, then we need to modify the\n                 // borrow_kind of the upvar to make sure it\n                 // is inferred to mutable if necessary\n-                {\n-                    let upvar_capture_map = &mut self.fcx.tables.borrow_mut().upvar_capture_map;\n-                    let ub = upvar_capture_map.get_mut(&upvar_id).unwrap();\n-                    self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n-                }\n+                self.adjust_upvar_borrow_kind(upvar_id, borrow_kind);\n \n                 // also need to be in an FnMut closure since this is not an ImmBorrow\n                 self.adjust_closure_kind(upvar_id.closure_expr_id,\n@@ -448,22 +424,25 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     /// some particular use.\n     fn adjust_upvar_borrow_kind(&mut self,\n                                 upvar_id: ty::UpvarId,\n-                                upvar_capture: &mut ty::UpvarCapture,\n                                 kind: ty::BorrowKind) {\n+        let upvar_capture = self.adjust_upvar_captures.get(&upvar_id).cloned()\n+            .unwrap_or_else(|| self.fcx.tables.borrow().upvar_capture(upvar_id));\n         debug!(\"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n                upvar_id, upvar_capture, kind);\n \n-        match *upvar_capture {\n+        match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n                 // Upvar is already by-value, the strongest criteria.\n             }\n-            ty::UpvarCapture::ByRef(ref mut upvar_borrow) => {\n+            ty::UpvarCapture::ByRef(mut upvar_borrow) => {\n                 match (upvar_borrow.kind, kind) {\n                     // Take RHS:\n                     (ty::ImmBorrow, ty::UniqueImmBorrow) |\n                     (ty::ImmBorrow, ty::MutBorrow) |\n                     (ty::UniqueImmBorrow, ty::MutBorrow) => {\n                         upvar_borrow.kind = kind;\n+                        self.adjust_upvar_captures.insert(upvar_id,\n+                            ty::UpvarCapture::ByRef(upvar_borrow));\n                     }\n                     // Take LHS:\n                     (ty::ImmBorrow, ty::ImmBorrow) |\n@@ -484,7 +463,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n                closure_id, new_kind, upvar_span, var_name);\n \n-        if let Some(&(existing_kind, _)) = self.temp_closure_kinds.get(&closure_id) {\n+        let closure_kind = self.adjust_closure_kinds.get(&closure_id).cloned()\n+            .or_else(|| self.fcx.tables.borrow().closure_kinds.get(&closure_id).cloned());\n+        if let Some((existing_kind, _)) = closure_kind {\n             debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n                    closure_id, existing_kind, new_kind);\n \n@@ -500,7 +481,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                 (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n                 (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                     // new kind is stronger than the old kind\n-                    self.temp_closure_kinds.insert(\n+                    self.adjust_closure_kinds.insert(\n                         closure_id,\n                         (new_kind, Some((upvar_span, var_name)))\n                     );\n@@ -510,27 +491,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_fn(&mut self,\n-                fn_kind: intravisit::FnKind<'gcx>,\n-                decl: &'gcx hir::FnDecl,\n-                body: hir::BodyId,\n-                span: Span,\n-                id: ast::NodeId)\n-    {\n-        intravisit::walk_fn(self, fn_kind, decl, body, span, id);\n-\n-        let body = self.fcx.tcx.hir.body(body);\n-        self.visit_body(body);\n-        self.analyze_closure(id, span, body);\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,"}]}