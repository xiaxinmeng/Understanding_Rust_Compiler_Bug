{"sha": "892cb143e5984f220e6b26b48d972bd1f4644298", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5MmNiMTQzZTU5ODRmMjIwZTZiMjZiNDhkOTcyYmQxZjQ2NDQyOTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-26T12:48:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-26T12:48:53Z"}, "message": "Auto merge of #67290 - jonas-schievink:leak-audit, r=KodrAus\n\nAudit liballoc for leaks in `Drop` impls when user destructor panics\n\nInspired by https://github.com/rust-lang/rust/pull/67243 and https://github.com/rust-lang/rust/pull/67235, this audits and hopefully fixes the remaining `Drop` impls in liballoc for resource leaks in the presence of panics in destructors called by the affected `Drop` impl.\n\nThis does not touch `Hash{Map,Set}` since they live in hashbrown. They have similar issues though.\n\nr? @KodrAus", "tree": {"sha": "196b7add117dcb113ed0935e589060720f89ab84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/196b7add117dcb113ed0935e589060720f89ab84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/892cb143e5984f220e6b26b48d972bd1f4644298", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/892cb143e5984f220e6b26b48d972bd1f4644298", "html_url": "https://github.com/rust-lang/rust/commit/892cb143e5984f220e6b26b48d972bd1f4644298", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/892cb143e5984f220e6b26b48d972bd1f4644298/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a0d106109d73ed2e45a9925a9512ade2afb7df9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a0d106109d73ed2e45a9925a9512ade2afb7df9", "html_url": "https://github.com/rust-lang/rust/commit/3a0d106109d73ed2e45a9925a9512ade2afb7df9"}, {"sha": "e5987a062f487321bdfcbbdac4b0b30548258631", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5987a062f487321bdfcbbdac4b0b30548258631", "html_url": "https://github.com/rust-lang/rust/commit/e5987a062f487321bdfcbbdac4b0b30548258631"}], "stats": {"total": 625, "additions": 497, "deletions": 128}, "files": [{"sha": "f38fe997b732c8effae96bbbd60722cc9673369e", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -147,7 +147,7 @@\n \n use core::fmt;\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n-use core::mem::{size_of, swap, ManuallyDrop};\n+use core::mem::{self, size_of, swap, ManuallyDrop};\n use core::ops::{Deref, DerefMut};\n use core::ptr;\n \n@@ -1239,7 +1239,19 @@ pub struct DrainSorted<'a, T: Ord> {\n impl<'a, T: Ord> Drop for DrainSorted<'a, T> {\n     /// Removes heap elements in heap order.\n     fn drop(&mut self) {\n-        while let Some(_) = self.inner.pop() {}\n+        struct DropGuard<'r, 'a, T: Ord>(&'r mut DrainSorted<'a, T>);\n+\n+        impl<'r, 'a, T: Ord> Drop for DropGuard<'r, 'a, T> {\n+            fn drop(&mut self) {\n+                while let Some(_) = self.0.inner.pop() {}\n+            }\n+        }\n+\n+        while let Some(item) = self.inner.pop() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n     }\n }\n "}, {"sha": "b1f0ef0085f2d42a91f4145302ff788c7aea8358", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -1470,7 +1470,22 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n impl<K, V> Drop for IntoIter<K, V> {\n     fn drop(&mut self) {\n-        self.for_each(drop);\n+        struct DropGuard<'a, K, V>(&'a mut IntoIter<K, V>);\n+\n+        impl<'a, K, V> Drop for DropGuard<'a, K, V> {\n+            fn drop(&mut self) {\n+                // Continue the same loop we perform below. This only runs when unwinding, so we\n+                // don't have to care about panics this time (they'll abort).\n+                while let Some(_) = self.0.next() {}\n+            }\n+        }\n+\n+        while let Some(pair) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(pair);\n+            mem::forget(guard);\n+        }\n+\n         unsafe {\n             let leaf_node = ptr::read(&self.front).into_node();\n             if leaf_node.is_shared_root() {"}, {"sha": "a9b4e3e4706b80dbde8281823290abf574076fa4", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -1611,7 +1611,24 @@ where\n     F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        self.for_each(drop);\n+        struct DropGuard<'r, 'a, T, F>(&'r mut DrainFilter<'a, T, F>)\n+        where\n+            F: FnMut(&mut T) -> bool;\n+\n+        impl<'r, 'a, T, F> Drop for DropGuard<'r, 'a, T, F>\n+        where\n+            F: FnMut(&mut T) -> bool,\n+        {\n+            fn drop(&mut self) {\n+                self.0.for_each(drop);\n+            }\n+        }\n+\n+        while let Some(item) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n     }\n }\n "}, {"sha": "85d1d98b8a9c23bfb3b908baeb7f7f78d99f481c", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 21, "deletions": 108, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -22,6 +22,11 @@ use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub use self::drain::Drain;\n+\n+mod drain;\n+\n #[cfg(test)]\n mod tests;\n \n@@ -866,6 +871,18 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"deque_extras\", since = \"1.16.0\")]\n     pub fn truncate(&mut self, len: usize) {\n+        /// Runs the destructor for all items in the slice when it gets dropped (normally or\n+        /// during unwinding).\n+        struct Dropper<'a, T>(&'a mut [T]);\n+\n+        impl<'a, T> Drop for Dropper<'a, T> {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    ptr::drop_in_place(self.0);\n+                }\n+            }\n+        }\n+\n         // Safe because:\n         //\n         // * Any slice passed to `drop_in_place` is valid; the second case has\n@@ -888,8 +905,11 @@ impl<T> VecDeque<T> {\n                 let drop_back = back as *mut _;\n                 let drop_front = front.get_unchecked_mut(len..) as *mut _;\n                 self.head = self.wrap_sub(self.head, num_dropped);\n+\n+                // Make sure the second half is dropped even when a destructor\n+                // in the first one panics.\n+                let _back_dropper = Dropper(&mut *drop_back);\n                 ptr::drop_in_place(drop_front);\n-                ptr::drop_in_place(drop_back);\n             }\n         }\n     }\n@@ -2526,113 +2546,6 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n-/// A draining iterator over the elements of a `VecDeque`.\n-///\n-/// This `struct` is created by the [`drain`] method on [`VecDeque`]. See its\n-/// documentation for more.\n-///\n-/// [`drain`]: struct.VecDeque.html#method.drain\n-/// [`VecDeque`]: struct.VecDeque.html\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-pub struct Drain<'a, T: 'a> {\n-    after_tail: usize,\n-    after_head: usize,\n-    iter: Iter<'a, T>,\n-    deque: NonNull<VecDeque<T>>,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Drain\")\n-            .field(&self.after_tail)\n-            .field(&self.after_head)\n-            .field(&self.iter)\n-            .finish()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<T: Send> Send for Drain<'_, T> {}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Drop for Drain<'_, T> {\n-    fn drop(&mut self) {\n-        self.for_each(drop);\n-\n-        let source_deque = unsafe { self.deque.as_mut() };\n-\n-        // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n-        //\n-        //        T   t   h   H\n-        // [. . . o o x x o o . . .]\n-        //\n-        let orig_tail = source_deque.tail;\n-        let drain_tail = source_deque.head;\n-        let drain_head = self.after_tail;\n-        let orig_head = self.after_head;\n-\n-        let tail_len = count(orig_tail, drain_tail, source_deque.cap());\n-        let head_len = count(drain_head, orig_head, source_deque.cap());\n-\n-        // Restore the original head value\n-        source_deque.head = orig_head;\n-\n-        match (tail_len, head_len) {\n-            (0, 0) => {\n-                source_deque.head = 0;\n-                source_deque.tail = 0;\n-            }\n-            (0, _) => {\n-                source_deque.tail = drain_head;\n-            }\n-            (_, 0) => {\n-                source_deque.head = drain_tail;\n-            }\n-            _ => unsafe {\n-                if tail_len <= head_len {\n-                    source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n-                    source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n-                } else {\n-                    source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n-                    source_deque.wrap_copy(drain_tail, drain_head, head_len);\n-                }\n-            },\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> Iterator for Drain<'_, T> {\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<T> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(elt) })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> DoubleEndedIterator for Drain<'_, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<T> {\n-        self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n-    }\n-}\n-\n-#[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<T> ExactSizeIterator for Drain<'_, T> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Drain<'_, T> {}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for VecDeque<A> {\n     fn eq(&self, other: &VecDeque<A>) -> bool {"}, {"sha": "1ae94de75adb7174f076a4cb61b10260089c142a", "filename": "src/liballoc/collections/vec_deque/drain.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Fvec_deque%2Fdrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fcollections%2Fvec_deque%2Fdrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Fdrain.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -0,0 +1,126 @@\n+use core::iter::FusedIterator;\n+use core::ptr::{self, NonNull};\n+use core::{fmt, mem};\n+\n+use super::{count, Iter, VecDeque};\n+\n+/// A draining iterator over the elements of a `VecDeque`.\n+///\n+/// This `struct` is created by the [`drain`] method on [`VecDeque`]. See its\n+/// documentation for more.\n+///\n+/// [`drain`]: struct.VecDeque.html#method.drain\n+/// [`VecDeque`]: struct.VecDeque.html\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+pub struct Drain<'a, T: 'a> {\n+    pub(crate) after_tail: usize,\n+    pub(crate) after_head: usize,\n+    pub(crate) iter: Iter<'a, T>,\n+    pub(crate) deque: NonNull<VecDeque<T>>,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"Drain\")\n+            .field(&self.after_tail)\n+            .field(&self.after_head)\n+            .field(&self.iter)\n+            .finish()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+unsafe impl<T: Send> Send for Drain<'_, T> {}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T> Drop for Drain<'_, T> {\n+    fn drop(&mut self) {\n+        struct DropGuard<'r, 'a, T>(&'r mut Drain<'a, T>);\n+\n+        impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n+            fn drop(&mut self) {\n+                self.0.for_each(drop);\n+\n+                let source_deque = unsafe { self.0.deque.as_mut() };\n+\n+                // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n+                //\n+                //        T   t   h   H\n+                // [. . . o o x x o o . . .]\n+                //\n+                let orig_tail = source_deque.tail;\n+                let drain_tail = source_deque.head;\n+                let drain_head = self.0.after_tail;\n+                let orig_head = self.0.after_head;\n+\n+                let tail_len = count(orig_tail, drain_tail, source_deque.cap());\n+                let head_len = count(drain_head, orig_head, source_deque.cap());\n+\n+                // Restore the original head value\n+                source_deque.head = orig_head;\n+\n+                match (tail_len, head_len) {\n+                    (0, 0) => {\n+                        source_deque.head = 0;\n+                        source_deque.tail = 0;\n+                    }\n+                    (0, _) => {\n+                        source_deque.tail = drain_head;\n+                    }\n+                    (_, 0) => {\n+                        source_deque.head = drain_tail;\n+                    }\n+                    _ => unsafe {\n+                        if tail_len <= head_len {\n+                            source_deque.tail = source_deque.wrap_sub(drain_head, tail_len);\n+                            source_deque.wrap_copy(source_deque.tail, orig_tail, tail_len);\n+                        } else {\n+                            source_deque.head = source_deque.wrap_add(drain_tail, head_len);\n+                            source_deque.wrap_copy(drain_tail, drain_head, head_len);\n+                        }\n+                    },\n+                }\n+            }\n+        }\n+\n+        while let Some(item) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n+\n+        DropGuard(self);\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T> Iterator for Drain<'_, T> {\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<T> {\n+        self.iter.next().map(|elt| unsafe { ptr::read(elt) })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T> DoubleEndedIterator for Drain<'_, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<T> {\n+        self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n+    }\n+}\n+\n+#[stable(feature = \"drain\", since = \"1.6.0\")]\n+impl<T> ExactSizeIterator for Drain<'_, T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Drain<'_, T> {}"}, {"sha": "be5516f54f37b75a519084609b90dd6eed9343a9", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -1,6 +1,8 @@\n use std::collections::binary_heap::{Drain, PeekMut};\n use std::collections::BinaryHeap;\n use std::iter::TrustedLen;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicU32, Ordering};\n \n #[test]\n fn test_iterator() {\n@@ -275,6 +277,37 @@ fn test_drain_sorted() {\n     assert!(q.is_empty());\n }\n \n+#[test]\n+fn test_drain_sorted_leak() {\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(u32, bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            DROPS.fetch_add(1, Ordering::SeqCst);\n+\n+            if self.1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = BinaryHeap::from(vec![\n+        D(0, false),\n+        D(1, false),\n+        D(2, false),\n+        D(3, true),\n+        D(4, false),\n+        D(5, false),\n+    ]);\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_sorted()))).ok();\n+\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 6);\n+}\n+\n #[test]\n fn test_extend_ref() {\n     let mut a = BinaryHeap::new();"}, {"sha": "fd07a4d3926c3897bf26e789fc30ca5386ba5da2", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -5,7 +5,9 @@ use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n+use std::panic::catch_unwind;\n use std::rc::Rc;\n+use std::sync::atomic::{AtomicU32, Ordering};\n \n use super::DeterministicRng;\n \n@@ -1017,3 +1019,29 @@ fn test_split_off_large_random_sorted() {\n     assert!(map.into_iter().eq(data.clone().into_iter().filter(|x| x.0 < key)));\n     assert!(right.into_iter().eq(data.into_iter().filter(|x| x.0 >= key)));\n }\n+\n+#[test]\n+fn test_into_iter_drop_leak() {\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    struct D;\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 3 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut map = BTreeMap::new();\n+    map.insert(\"a\", D);\n+    map.insert(\"b\", D);\n+    map.insert(\"c\", D);\n+    map.insert(\"d\", D);\n+    map.insert(\"e\", D);\n+\n+    catch_unwind(move || drop(map.into_iter())).ok();\n+\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 5);\n+}"}, {"sha": "afcb9e03fd097db71203c13a44c58322341e3777", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -1,5 +1,5 @@\n use std::collections::LinkedList;\n-use std::panic::catch_unwind;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n \n #[test]\n fn test_basic() {\n@@ -531,6 +531,74 @@ fn drain_filter_complex() {\n     }\n }\n \n+#[test]\n+fn drain_filter_drop_panic_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(true));\n+    q.push_front(D(false));\n+\n+    catch_unwind(AssertUnwindSafe(|| drop(q.drain_filter(|_| true)))).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 8);\n+    assert!(q.is_empty());\n+}\n+\n+#[test]\n+fn drain_filter_pred_panic_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    #[derive(Debug)]\n+    struct D(u32);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(3));\n+    q.push_back(D(4));\n+    q.push_back(D(5));\n+    q.push_back(D(6));\n+    q.push_back(D(7));\n+    q.push_front(D(2));\n+    q.push_front(D(1));\n+    q.push_front(D(0));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(q.drain_filter(|item| if item.0 >= 2 { panic!() } else { true }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(unsafe { DROPS }, 2); // 0 and 1\n+    assert_eq!(q.len(), 6);\n+}\n+\n #[test]\n fn test_drop() {\n     static mut DROPS: i32 = 0;"}, {"sha": "9c4ac52acac2a749b9c55803b7645ed180af24d5", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -1,6 +1,7 @@\n use std::borrow::Cow;\n use std::collections::TryReserveError::*;\n use std::mem::size_of;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::vec::{Drain, IntoIter};\n use std::{isize, usize};\n \n@@ -585,6 +586,44 @@ fn test_drain_inclusive_out_of_bounds() {\n     v.drain(5..=5);\n }\n \n+#[test]\n+fn test_drain_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct D(u32, bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut v = vec![\n+        D(0, false),\n+        D(1, false),\n+        D(2, false),\n+        D(3, false),\n+        D(4, true),\n+        D(5, false),\n+        D(6, false),\n+    ];\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        v.drain(2..=5);\n+    }))\n+    .ok();\n+\n+    assert_eq!(unsafe { DROPS }, 4);\n+    assert_eq!(v, vec![D(0, false), D(1, false), D(6, false),]);\n+}\n+\n #[test]\n fn test_splice() {\n     let mut v = vec![1, 2, 3, 4, 5];\n@@ -726,6 +765,31 @@ fn test_into_iter_clone() {\n     assert_eq!(it.next(), None);\n }\n \n+#[test]\n+fn test_into_iter_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let v = vec![D(false), D(true), D(false)];\n+\n+    catch_unwind(move || drop(v.into_iter())).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 3);\n+}\n+\n #[test]\n fn test_cow_from() {\n     let borrowed: &[_] = &[\"borrowed\", \"(slice)\"];"}, {"sha": "101dd67d97a9a4a37bc37218ad21e9b22a16ea7b", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -2,7 +2,7 @@ use std::collections::TryReserveError::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n use std::mem::size_of;\n-use std::panic::catch_unwind;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::{isize, usize};\n \n use crate::hash;\n@@ -1573,3 +1573,75 @@ fn test_try_rfold_moves_iter() {\n     assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n     assert_eq!(iter.next_back(), Some(&70));\n }\n+\n+#[test]\n+fn truncate_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = VecDeque::new();\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_front(D(true));\n+    q.push_front(D(false));\n+    q.push_front(D(false));\n+\n+    catch_unwind(AssertUnwindSafe(|| q.truncate(1))).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 7);\n+}\n+\n+#[test]\n+fn test_drain_leak() {\n+    static mut DROPS: i32 = 0;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct D(u32, bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut v = VecDeque::new();\n+    v.push_back(D(4, false));\n+    v.push_back(D(5, false));\n+    v.push_back(D(6, false));\n+    v.push_front(D(3, false));\n+    v.push_front(D(2, true));\n+    v.push_front(D(1, false));\n+    v.push_front(D(0, false));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        v.drain(1..=4);\n+    }))\n+    .ok();\n+\n+    assert_eq!(unsafe { DROPS }, 4);\n+    assert_eq!(v.len(), 3);\n+    drop(v);\n+    assert_eq!(unsafe { DROPS }, 7);\n+}"}, {"sha": "29987ac44e6f9db2037392a817cb3194f7ce01b2", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/892cb143e5984f220e6b26b48d972bd1f4644298/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=892cb143e5984f220e6b26b48d972bd1f4644298", "patch": "@@ -2622,7 +2622,9 @@ impl<T: Clone> Clone for IntoIter<T> {\n unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n     fn drop(&mut self) {\n         // destroy the remaining elements\n-        for _x in self.by_ref() {}\n+        unsafe {\n+            ptr::drop_in_place(self.as_mut_slice());\n+        }\n \n         // RawVec handles deallocation\n         let _ = unsafe { RawVec::from_raw_parts(self.buf.as_ptr(), self.cap) };\n@@ -2702,23 +2704,42 @@ impl<T> DoubleEndedIterator for Drain<'_, T> {\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n impl<T> Drop for Drain<'_, T> {\n     fn drop(&mut self) {\n-        // exhaust self first\n-        self.for_each(drop);\n+        /// Continues dropping the remaining elements in the `Drain`, then moves back the\n+        /// un-`Drain`ed elements to restore the original `Vec`.\n+        struct DropGuard<'r, 'a, T>(&'r mut Drain<'a, T>);\n \n-        if self.tail_len > 0 {\n-            unsafe {\n-                let source_vec = self.vec.as_mut();\n-                // memmove back untouched tail, update to new length\n-                let start = source_vec.len();\n-                let tail = self.tail_start;\n-                if tail != start {\n-                    let src = source_vec.as_ptr().add(tail);\n-                    let dst = source_vec.as_mut_ptr().add(start);\n-                    ptr::copy(src, dst, self.tail_len);\n+        impl<'r, 'a, T> Drop for DropGuard<'r, 'a, T> {\n+            fn drop(&mut self) {\n+                // Continue the same loop we have below. If the loop already finished, this does\n+                // nothing.\n+                self.0.for_each(drop);\n+\n+                if self.0.tail_len > 0 {\n+                    unsafe {\n+                        let source_vec = self.0.vec.as_mut();\n+                        // memmove back untouched tail, update to new length\n+                        let start = source_vec.len();\n+                        let tail = self.0.tail_start;\n+                        if tail != start {\n+                            let src = source_vec.as_ptr().add(tail);\n+                            let dst = source_vec.as_mut_ptr().add(start);\n+                            ptr::copy(src, dst, self.0.tail_len);\n+                        }\n+                        source_vec.set_len(start + self.0.tail_len);\n+                    }\n                 }\n-                source_vec.set_len(start + self.tail_len);\n             }\n         }\n+\n+        // exhaust self first\n+        while let Some(item) = self.next() {\n+            let guard = DropGuard(self);\n+            drop(item);\n+            mem::forget(guard);\n+        }\n+\n+        // Drop a `DropGuard` to move back the non-drained tail of `self`.\n+        DropGuard(self);\n     }\n }\n "}]}