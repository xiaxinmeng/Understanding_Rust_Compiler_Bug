{"sha": "41134be153ec0e152b0bb5cf79731abdde7c4e04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMTM0YmUxNTNlYzBlMTUyYjBiYjVjZjc5NzMxYWJkZGU3YzRlMDQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-09T00:13:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-09T00:13:28Z"}, "message": "Rollup merge of #78026 - sunfishcode:symlink-hard-link, r=dtolnay\n\nDefine `fs::hard_link` to not follow symlinks.\n\nPOSIX leaves it [implementation-defined] whether `link` follows symlinks.\nIn practice, for example, on Linux it does not and on FreeBSD it does.\nSo, switch to `linkat`, so that we can pick a behavior rather than\ndepending on OS defaults.\n\nPick the option to not follow symlinks. This is somewhat arbitrary, but\nseems the less surprising choice because hard linking is a very\nlow-level feature which requires the source and destination to be on\nthe same mounted filesystem, and following a symbolic link could end\nup in a different mounted filesystem.\n\n[implementation-defined]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/link.html", "tree": {"sha": "711a7cbc785c67e8bc87613a2d13200d2bcdb210", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/711a7cbc785c67e8bc87613a2d13200d2bcdb210"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41134be153ec0e152b0bb5cf79731abdde7c4e04", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfqImpCRBK7hj4Ov3rIwAAdHIIAAIGA6HpszLd4MzJc6Xf1AVV\n8zkhv8nGKrus5GJSUcG5TrfyDmSVwyWhO12p714KGjRZFlspn//DezbrOe38GYop\niPuGfj1M/Q0NkvMM/cis3neFXpqCS/rRx1f7Vbr4x2jZoESN2J1E1/yCeBddhRAW\nCZoMK0yvRhTGBZUrB1IOPag6IOOUmVg5YNUcC1hm2OxPX6LDGQlyVdm9Ipmrohvb\nfYHqVuyqMdUcT3NH6mx2+l7OK+E7SujwdisdT4z8lPooSYJbeQ0uxpQ1KcauIfiZ\nVGMcIsuHQdbXqnxOJhtYzxXPshFB/BblpvWCRL7wlFIk52DNgLpOaEhg59uTPDU=\n=KF+0\n-----END PGP SIGNATURE-----\n", "payload": "tree 711a7cbc785c67e8bc87613a2d13200d2bcdb210\nparent d69ee57f977d03644acd8fbfd1799410e2c02db3\nparent 6249cda78f0cd32b60fb11702b7ffef3e3bab0b2\nauthor Dylan DPC <dylan.dpc@gmail.com> 1604880808 +0100\ncommitter GitHub <noreply@github.com> 1604880808 +0100\n\nRollup merge of #78026 - sunfishcode:symlink-hard-link, r=dtolnay\n\nDefine `fs::hard_link` to not follow symlinks.\n\nPOSIX leaves it [implementation-defined] whether `link` follows symlinks.\nIn practice, for example, on Linux it does not and on FreeBSD it does.\nSo, switch to `linkat`, so that we can pick a behavior rather than\ndepending on OS defaults.\n\nPick the option to not follow symlinks. This is somewhat arbitrary, but\nseems the less surprising choice because hard linking is a very\nlow-level feature which requires the source and destination to be on\nthe same mounted filesystem, and following a symbolic link could end\nup in a different mounted filesystem.\n\n[implementation-defined]: https://pubs.opengroup.org/onlinepubs/9699919799/functions/link.html\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41134be153ec0e152b0bb5cf79731abdde7c4e04", "html_url": "https://github.com/rust-lang/rust/commit/41134be153ec0e152b0bb5cf79731abdde7c4e04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41134be153ec0e152b0bb5cf79731abdde7c4e04/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d69ee57f977d03644acd8fbfd1799410e2c02db3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d69ee57f977d03644acd8fbfd1799410e2c02db3", "html_url": "https://github.com/rust-lang/rust/commit/d69ee57f977d03644acd8fbfd1799410e2c02db3"}, {"sha": "6249cda78f0cd32b60fb11702b7ffef3e3bab0b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6249cda78f0cd32b60fb11702b7ffef3e3bab0b2", "html_url": "https://github.com/rust-lang/rust/commit/6249cda78f0cd32b60fb11702b7ffef3e3bab0b2"}], "stats": {"total": 74, "additions": 71, "deletions": 3}, "files": [{"sha": "c256f556b3c8f207fcc307dabf6a4b633fc492fc", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41134be153ec0e152b0bb5cf79731abdde7c4e04/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41134be153ec0e152b0bb5cf79731abdde7c4e04/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=41134be153ec0e152b0bb5cf79731abdde7c4e04", "patch": "@@ -1701,10 +1701,14 @@ pub fn copy<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<u64> {\n /// The `dst` path will be a link pointing to the `src` path. Note that systems\n /// often require these two paths to both be located on the same filesystem.\n ///\n+/// If `src` names a symbolic link, it is platform-specific whether the symbolic\n+/// link is followed. On platforms where it's possible to not follow it, it is\n+/// not followed, and the created hard link points to the symbolic link itself.\n+///\n /// # Platform-specific behavior\n ///\n-/// This function currently corresponds to the `link` function on Unix\n-/// and the `CreateHardLink` function on Windows.\n+/// This function currently corresponds to the `linkat` function with no flags\n+/// on Unix and the `CreateHardLink` function on Windows.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: io#platform-specific-behavior"}, {"sha": "0642dca8e48a7b06ee3526e9fa3248043486c440", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/41134be153ec0e152b0bb5cf79731abdde7c4e04/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41134be153ec0e152b0bb5cf79731abdde7c4e04/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=41134be153ec0e152b0bb5cf79731abdde7c4e04", "patch": "@@ -1336,3 +1336,54 @@ fn metadata_access_times() {\n         }\n     }\n }\n+\n+/// Test creating hard links to symlinks.\n+#[test]\n+fn symlink_hard_link() {\n+    let tmpdir = tmpdir();\n+\n+    // Create \"file\", a file.\n+    check!(fs::File::create(tmpdir.join(\"file\")));\n+\n+    // Create \"symlink\", a symlink to \"file\".\n+    check!(symlink_file(\"file\", tmpdir.join(\"symlink\")));\n+\n+    // Create \"hard_link\", a hard link to \"symlink\".\n+    check!(fs::hard_link(tmpdir.join(\"symlink\"), tmpdir.join(\"hard_link\")));\n+\n+    // \"hard_link\" should appear as a symlink.\n+    assert!(check!(fs::symlink_metadata(tmpdir.join(\"hard_link\"))).file_type().is_symlink());\n+\n+    // We sould be able to open \"file\" via any of the above names.\n+    let _ = check!(fs::File::open(tmpdir.join(\"file\")));\n+    assert!(fs::File::open(tmpdir.join(\"file.renamed\")).is_err());\n+    let _ = check!(fs::File::open(tmpdir.join(\"symlink\")));\n+    let _ = check!(fs::File::open(tmpdir.join(\"hard_link\")));\n+\n+    // Rename \"file\" to \"file.renamed\".\n+    check!(fs::rename(tmpdir.join(\"file\"), tmpdir.join(\"file.renamed\")));\n+\n+    // Now, the symlink and the hard link should be dangling.\n+    assert!(fs::File::open(tmpdir.join(\"file\")).is_err());\n+    let _ = check!(fs::File::open(tmpdir.join(\"file.renamed\")));\n+    assert!(fs::File::open(tmpdir.join(\"symlink\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"hard_link\")).is_err());\n+\n+    // The symlink and the hard link should both still point to \"file\".\n+    assert!(fs::read_link(tmpdir.join(\"file\")).is_err());\n+    assert!(fs::read_link(tmpdir.join(\"file.renamed\")).is_err());\n+    assert_eq!(check!(fs::read_link(tmpdir.join(\"symlink\"))), Path::new(\"file\"));\n+    assert_eq!(check!(fs::read_link(tmpdir.join(\"hard_link\"))), Path::new(\"file\"));\n+\n+    // Remove \"file.renamed\".\n+    check!(fs::remove_file(tmpdir.join(\"file.renamed\")));\n+\n+    // Now, we can't open the file by any name.\n+    assert!(fs::File::open(tmpdir.join(\"file\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"file.renamed\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"symlink\")).is_err());\n+    assert!(fs::File::open(tmpdir.join(\"hard_link\")).is_err());\n+\n+    // \"hard_link\" should still appear as a symlink.\n+    assert!(check!(fs::symlink_metadata(tmpdir.join(\"hard_link\"))).file_type().is_symlink());\n+}"}, {"sha": "96594095cc36df46d0cf69572815460a261b9b49", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/41134be153ec0e152b0bb5cf79731abdde7c4e04/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41134be153ec0e152b0bb5cf79731abdde7c4e04/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=41134be153ec0e152b0bb5cf79731abdde7c4e04", "patch": "@@ -1081,7 +1081,20 @@ pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n pub fn link(src: &Path, dst: &Path) -> io::Result<()> {\n     let src = cstr(src)?;\n     let dst = cstr(dst)?;\n-    cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n+    cfg_if::cfg_if! {\n+        if #[cfg(any(target_os = \"vxworks\", target_os = \"redox\", target_os = \"android\"))] {\n+            // VxWorks, Redox, and old versions of Android lack `linkat`, so use\n+            // `link` instead. POSIX leaves it implementation-defined whether\n+            // `link` follows symlinks, so rely on the `symlink_hard_link` test\n+            // in library/std/src/fs/tests.rs to check the behavior.\n+            cvt(unsafe { libc::link(src.as_ptr(), dst.as_ptr()) })?;\n+        } else {\n+            // Use `linkat` with `AT_FDCWD` instead of `link` as `linkat` gives\n+            // us a flag to specify how symlinks should be handled. Pass 0 as\n+            // the flags argument, meaning don't follow symlinks.\n+            cvt(unsafe { libc::linkat(libc::AT_FDCWD, src.as_ptr(), libc::AT_FDCWD, dst.as_ptr(), 0) })?;\n+        }\n+    }\n     Ok(())\n }\n "}]}