{"sha": "10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwZDk0OWFhM2VhYjJmNGYyN2FjNTBjNWZiY2I5NWZmYmU4YjExZTU=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-12-22T16:07:47Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-12-22T18:12:07Z"}, "message": "Rollup merge of #56979 - VardhanThigle:Vardhan/rust-sgx-unwind-support, r=alexcrichton\n\nAdding unwinding support for x86_64_fortanix_unknown_sgx target.\n\nUnwinding support is provided by our port of LLVM's libunwind which is available from https://github.com/fortanix/libunwind/tree/release_50.\n\nlibunwind requires support for rwlock and printing to stderr, which is only provided by `std` for this target. This poses two problems: 1) how to expose the `std` functionality to C and 2) dependency inversion.\n\n### Exposing `std`\n\nFor exposing the functionality we chose to expose the following symbols:\n\n* __rust_rwlock_rdlock\n* __rust_rwlock_wrlock\n* __rust_rwlock_unlock\n* __rust_print_err\n* __rust_abort\n\nAlso, the following are needed from `alloc`:\n\n* __rust_alloc\n* __rust_dealloc\n\n#### Rust RWLock in C\n\nIn `libunwind`, RWLock is initialized as a templated static variable:\n\n```c\npthread_rwlock_t DwarfFDECache<A>::_lock = PTHREAD_RWLOCK_INITIALIZER;\n```\n\nI don't know of a good way to use the Rust sys::rwlock::RWLock type and initializer there. We could have a static global variable in Rust, but that doesn't work with the templating. The variable needs to be initialized statically, since this target doesn't support the .init section. Currently, I just used a byte array and standard C array initialization. The mapping between this C type and the Rust type needs to be manually maintained. There is a compile-time check and a unit test to make sure the Rust versions of these C definitions match the actual Rust type. If any reviewer knows of a better solution, please do tell.\n\n### Dependency inversion issue\n\n`std` depends on `panic_unwind` which depends on `libunwind`, and `libunwind` depends on `std`. This is not normally supported by Rust's linking system. Therefore we use raw C exports from `std` *and* `libunwind.a` is linked last in the target `post_link_objects` instead of being built as part of the Rust `libunwind`. Currently, all C exports are defined in `src/libstd/sys/sgx/rwlock.rs` to overcome LTO issues. Only the `__rust_rwlock_*` definitions *need* to live there for privacy reasons. Once again, if any reviewer knows of a better solution, please do tell.\n\nr? @alexcrichton", "tree": {"sha": "57d542dcc1498e8f8fa1d1033f4879d592bf3da9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57d542dcc1498e8f8fa1d1033f4879d592bf3da9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlwefncACgkQ/vbIBR0O\nATz00hAAuSUmbZ7c84dnirObZZ/uOnzGuWVi7qI1CDZhr+axgJyvR21HF91bxuKO\ne4jOKoAcGm9GZe5pnFFAfVZcH5FFyvy078Le/Z0PQgP9/CDKsySWFaOciHGMYFsu\nayj8CjeomT489xL2CEJbtYRhwI5KueHi4OXS8cigTJWvqw0xD5km1GC2POkwrArV\nUqgC3rQckfMcG3y/aNV1xZ+VRC0U0Hq5VUVY5VeRiSTmA2RJo2S+IIlyNmKdf7aa\njcKLPx475T+oGa5hVfk5pG6LV5CR7Kv46QnL4VNRRcweZs806FqqZ76eKZOcVnIb\ntDuHagIMncSXpQluFz9Cvt9wkmd8QJZVbwr/vh26p49O2WF1QUbuRxq1pKHglLw6\nQRltQkcipaZWvWy64Qf/QDkX3hm18ZnmX51ZzNvi6bYdifd7GbZdSwMG0zIpohTS\n4Pm7k562VS2zL8Pb3QnJ6rLeB/iX5wfkNzZwFh4YOziJfaO6t3KH1gdop05zDS+C\nAy2zwG1q4TuZUZk5wedSG30zrpjqW/0TSGQ830rMBCn+2OcSozE1f1/+4Y7dgREU\nH+al+ShZEsz29m/hTGt7kkRd6VFbJ3QWs2cpgM8ctwU+tKcuoKI8kAQwu1aE2g2U\nIsxR133iRvPo9BiG/sNgubvPeUfDv4LzqPPUwuXYMpDgeulgo10=\n=OewJ\n-----END PGP SIGNATURE-----", "payload": "tree 57d542dcc1498e8f8fa1d1033f4879d592bf3da9\nparent de2ba78dfe6ad7a2502c3708e4719f364e7022ee\nparent 885cf2a2afd6da270287cfc3bfa651ac737d0378\nauthor kennytm <kennytm@gmail.com> 1545494867 +0800\ncommitter kennytm <kennytm@gmail.com> 1545502327 +0800\n\nRollup merge of #56979 - VardhanThigle:Vardhan/rust-sgx-unwind-support, r=alexcrichton\n\nAdding unwinding support for x86_64_fortanix_unknown_sgx target.\n\nUnwinding support is provided by our port of LLVM's libunwind which is available from https://github.com/fortanix/libunwind/tree/release_50.\n\nlibunwind requires support for rwlock and printing to stderr, which is only provided by `std` for this target. This poses two problems: 1) how to expose the `std` functionality to C and 2) dependency inversion.\n\n### Exposing `std`\n\nFor exposing the functionality we chose to expose the following symbols:\n\n* __rust_rwlock_rdlock\n* __rust_rwlock_wrlock\n* __rust_rwlock_unlock\n* __rust_print_err\n* __rust_abort\n\nAlso, the following are needed from `alloc`:\n\n* __rust_alloc\n* __rust_dealloc\n\n#### Rust RWLock in C\n\nIn `libunwind`, RWLock is initialized as a templated static variable:\n\n```c\npthread_rwlock_t DwarfFDECache<A>::_lock = PTHREAD_RWLOCK_INITIALIZER;\n```\n\nI don't know of a good way to use the Rust sys::rwlock::RWLock type and initializer there. We could have a static global variable in Rust, but that doesn't work with the templating. The variable needs to be initialized statically, since this target doesn't support the .init section. Currently, I just used a byte array and standard C array initialization. The mapping between this C type and the Rust type needs to be manually maintained. There is a compile-time check and a unit test to make sure the Rust versions of these C definitions match the actual Rust type. If any reviewer knows of a better solution, please do tell.\n\n### Dependency inversion issue\n\n`std` depends on `panic_unwind` which depends on `libunwind`, and `libunwind` depends on `std`. This is not normally supported by Rust's linking system. Therefore we use raw C exports from `std` *and* `libunwind.a` is linked last in the target `post_link_objects` instead of being built as part of the Rust `libunwind`. Currently, all C exports are defined in `src/libstd/sys/sgx/rwlock.rs` to overcome LTO issues. Only the `__rust_rwlock_*` definitions *need* to live there for privacy reasons. Once again, if any reviewer knows of a better solution, please do tell.\n\nr? @alexcrichton\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5", "html_url": "https://github.com/rust-lang/rust/commit/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "de2ba78dfe6ad7a2502c3708e4719f364e7022ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/de2ba78dfe6ad7a2502c3708e4719f364e7022ee", "html_url": "https://github.com/rust-lang/rust/commit/de2ba78dfe6ad7a2502c3708e4719f364e7022ee"}, {"sha": "885cf2a2afd6da270287cfc3bfa651ac737d0378", "url": "https://api.github.com/repos/rust-lang/rust/commits/885cf2a2afd6da270287cfc3bfa651ac737d0378", "html_url": "https://github.com/rust-lang/rust/commit/885cf2a2afd6da270287cfc3bfa651ac737d0378"}], "stats": {"total": 198, "additions": 168, "deletions": 30}, "files": [{"sha": "cfe671c626bcf040b14c4b5dd328ddd535783232", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5", "patch": "@@ -62,7 +62,7 @@ cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n         mod imp;\n-    } else if #[cfg(any(target_arch = \"wasm32\", target_env = \"sgx\"))] {\n+    } else if #[cfg(target_arch = \"wasm32\")] {\n         #[path = \"dummy.rs\"]\n         mod imp;\n     } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {"}, {"sha": "6a6aab2bea3664d9794162cb0f77825c2c7d6d0b", "filename": "src/librustc_target/spec/x86_64_fortanix_unknown_sgx.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_fortanix_unknown_sgx.rs?ref=10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5", "patch": "@@ -10,28 +10,29 @@\n \n use std::iter;\n \n-use super::{LinkerFlavor, Target, TargetOptions, PanicStrategy};\n+use super::{LinkerFlavor, PanicStrategy, Target, TargetOptions};\n \n pub fn target() -> Result<Target, String> {\n     const PRE_LINK_ARGS: &[&str] = &[\n         \"-Wl,--as-needed\",\n         \"-Wl,-z,noexecstack\",\n         \"-m64\",\n-         \"-fuse-ld=gold\",\n-         \"-nostdlib\",\n-         \"-shared\",\n-         \"-Wl,-e,sgx_entry\",\n-         \"-Wl,-Bstatic\",\n-         \"-Wl,--gc-sections\",\n-         \"-Wl,-z,text\",\n-         \"-Wl,-z,norelro\",\n-         \"-Wl,--rosegment\",\n-         \"-Wl,--no-undefined\",\n-         \"-Wl,--error-unresolved-symbols\",\n-         \"-Wl,--no-undefined-version\",\n-         \"-Wl,-Bsymbolic\",\n-         \"-Wl,--export-dynamic\",\n+        \"-fuse-ld=gold\",\n+        \"-nostdlib\",\n+        \"-shared\",\n+        \"-Wl,-e,sgx_entry\",\n+        \"-Wl,-Bstatic\",\n+        \"-Wl,--gc-sections\",\n+        \"-Wl,-z,text\",\n+        \"-Wl,-z,norelro\",\n+        \"-Wl,--rosegment\",\n+        \"-Wl,--no-undefined\",\n+        \"-Wl,--error-unresolved-symbols\",\n+        \"-Wl,--no-undefined-version\",\n+        \"-Wl,-Bsymbolic\",\n+        \"-Wl,--export-dynamic\",\n     ];\n+\n     const EXPORT_SYMBOLS: &[&str] = &[\n         \"sgx_entry\",\n         \"HEAP_BASE\",\n@@ -41,19 +42,26 @@ pub fn target() -> Result<Target, String> {\n         \"ENCLAVE_SIZE\",\n         \"CFGDATA_BASE\",\n         \"DEBUG\",\n+        \"EH_FRM_HDR_BASE\",\n+        \"EH_FRM_HDR_SIZE\",\n+        \"TEXT_BASE\",\n+        \"TEXT_SIZE\",\n     ];\n     let opts = TargetOptions {\n         dynamic_linking: false,\n         executables: true,\n         linker_is_gnu: true,\n         max_atomic_width: Some(64),\n-        panic_strategy: PanicStrategy::Abort,\n+        panic_strategy: PanicStrategy::Unwind,\n         cpu: \"x86-64\".into(),\n         features: \"+rdrnd,+rdseed\".into(),\n         position_independent_executables: true,\n-        pre_link_args: iter::once(\n-                (LinkerFlavor::Gcc, PRE_LINK_ARGS.iter().cloned().map(String::from).collect())\n-        ).collect(),\n+        pre_link_args: iter::once((\n+            LinkerFlavor::Gcc,\n+            PRE_LINK_ARGS.iter().cloned().map(String::from).collect(),\n+        ))\n+        .collect(),\n+        post_link_objects: vec![\"libunwind.a\".into()],\n         override_export_symbols: Some(EXPORT_SYMBOLS.iter().cloned().map(String::from).collect()),\n         ..Default::default()\n     };"}, {"sha": "49ede0674ce42cbe3e43a042194aa8448ddaa980", "filename": "src/libstd/sys/sgx/abi/entry.S", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5", "patch": "@@ -56,6 +56,14 @@ IMAGE_BASE:\n     globvar CFGDATA_BASE 8\n     /*  Non-zero if debugging is enabled, zero otherwise */\n     globvar DEBUG 1\n+    /*  The base address (relative to enclave start) of the enclave text section */\n+    globvar TEXT_BASE 8\n+    /*  The size in bytes of enclacve text section */\n+    globvar TEXT_SIZE 8\n+    /*  The base address (relative to enclave start) of the enclave EH_FRM_HDR section */\n+    globvar EH_FRM_HDR_BASE 8\n+    /*  The size in bytes of enclacve EH_FRM_HDR section */\n+    globvar EH_FRM_HDR_SIZE 8\n \n .Lreentry_panic_msg:\n     .asciz \"Re-entered panicked enclave!\""}, {"sha": "d1af98bd4f525ccf9e89cd4a6da5dfed35be0dd4", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 131, "deletions": 6, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5", "patch": "@@ -9,22 +9,33 @@\n // except according to those terms.\n \n use num::NonZeroUsize;\n+use slice;\n+use str;\n \n-use super::waitqueue::{WaitVariable, WaitQueue, SpinMutex, NotifiedTcs, try_lock_or_false};\n+use super::waitqueue::{\n+    try_lock_or_false, NotifiedTcs, SpinMutex, SpinMutexGuard, WaitQueue, WaitVariable,\n+};\n+use mem;\n \n pub struct RWLock {\n     readers: SpinMutex<WaitVariable<Option<NonZeroUsize>>>,\n     writer: SpinMutex<WaitVariable<bool>>,\n }\n \n+// Below is to check at compile time, that RWLock has size of 128 bytes.\n+#[allow(dead_code)]\n+unsafe fn rw_lock_size_assert(r: RWLock) {\n+    mem::transmute::<RWLock, [u8; 128]>(r);\n+}\n+\n //unsafe impl Send for RWLock {}\n //unsafe impl Sync for RWLock {} // FIXME\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n         RWLock {\n             readers: SpinMutex::new(WaitVariable::new(None)),\n-            writer: SpinMutex::new(WaitVariable::new(false))\n+            writer: SpinMutex::new(WaitVariable::new(false)),\n         }\n     }\n \n@@ -89,9 +100,11 @@ impl RWLock {\n     }\n \n     #[inline]\n-    pub unsafe fn read_unlock(&self) {\n-        let mut rguard = self.readers.lock();\n-        let wguard = self.writer.lock();\n+    unsafe fn __read_unlock(\n+        &self,\n+        mut rguard: SpinMutexGuard<WaitVariable<Option<NonZeroUsize>>>,\n+        wguard: SpinMutexGuard<WaitVariable<bool>>,\n+    ) {\n         *rguard.lock_var_mut() = NonZeroUsize::new(rguard.lock_var().unwrap().get() - 1);\n         if rguard.lock_var().is_some() {\n             // There are other active readers\n@@ -107,9 +120,18 @@ impl RWLock {\n     }\n \n     #[inline]\n-    pub unsafe fn write_unlock(&self) {\n+    pub unsafe fn read_unlock(&self) {\n         let rguard = self.readers.lock();\n         let wguard = self.writer.lock();\n+        self.__read_unlock(rguard, wguard);\n+    }\n+\n+    #[inline]\n+    unsafe fn __write_unlock(\n+        &self,\n+        rguard: SpinMutexGuard<WaitVariable<Option<NonZeroUsize>>>,\n+        wguard: SpinMutexGuard<WaitVariable<bool>>,\n+    ) {\n         if let Err(mut wguard) = WaitQueue::notify_one(wguard) {\n             // No writers waiting, release the write lock\n             *wguard.lock_var_mut() = false;\n@@ -128,6 +150,109 @@ impl RWLock {\n         }\n     }\n \n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        let rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        self.__write_unlock(rguard, wguard);\n+    }\n+\n+    #[inline]\n+    unsafe fn unlock(&self) {\n+        let rguard = self.readers.lock();\n+        let wguard = self.writer.lock();\n+        if *wguard.lock_var() == true {\n+            self.__write_unlock(rguard, wguard);\n+        } else {\n+            self.__read_unlock(rguard, wguard);\n+        }\n+    }\n+\n     #[inline]\n     pub unsafe fn destroy(&self) {}\n }\n+\n+const EINVAL: i32 = 22;\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_rwlock_rdlock(p: *mut RWLock) -> i32 {\n+    if p.is_null() {\n+        return EINVAL;\n+    }\n+    (*p).read();\n+    return 0;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_rwlock_wrlock(p: *mut RWLock) -> i32 {\n+    if p.is_null() {\n+        return EINVAL;\n+    }\n+    (*p).write();\n+    return 0;\n+}\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_rwlock_unlock(p: *mut RWLock) -> i32 {\n+    if p.is_null() {\n+        return EINVAL;\n+    }\n+    (*p).unlock();\n+    return 0;\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_print_err(m: *mut u8, s: i32) {\n+    if s < 0 {\n+        return;\n+    }\n+    let buf = slice::from_raw_parts(m as *const u8, s as _);\n+    if let Ok(s) = str::from_utf8(&buf[..buf.iter().position(|&b| b == 0).unwrap_or(buf.len())]) {\n+        eprint!(\"{}\", s);\n+    }\n+}\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn __rust_abort() {\n+    ::sys::abort_internal();\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    use super::*;\n+    use core::array::FixedSizeArray;\n+    use mem::MaybeUninit;\n+    use {mem, ptr};\n+\n+    // The below test verifies that the bytes of initialized RWLock are the ones\n+    // we use in libunwind.\n+    // If they change we need to update src/UnwindRustSgx.h in libunwind.\n+    #[test]\n+    fn test_c_rwlock_initializer() {\n+        const RWLOCK_INIT: &[u8] = &[\n+            0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+            0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n+        ];\n+\n+        let mut init = MaybeUninit::<RWLock>::zeroed();\n+        init.set(RWLock::new());\n+        assert_eq!(\n+            mem::transmute::<_, [u8; 128]>(init.into_inner()).as_slice(),\n+            RWLOCK_INIT\n+        );\n+    }\n+}"}, {"sha": "954eb9d6d03ba81b27c0ed6ed92ca2d0d85e11de", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=10d949aa3eab2f4f27ac50c5fbcb95ffbe8b11e5", "patch": "@@ -26,10 +26,7 @@ mod macros;\n cfg_if! {\n     if #[cfg(target_env = \"msvc\")] {\n         // no extra unwinder support needed\n-    } else if #[cfg(any(\n-        all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n-        target_env = \"sgx\"\n-    ))] {\n+    } else if #[cfg(all(target_arch = \"wasm32\", not(target_os = \"emscripten\")))] {\n         // no unwinder on the system!\n     } else {\n         extern crate libc;"}]}