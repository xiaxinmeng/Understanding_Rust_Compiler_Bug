{"sha": "036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNmQ4YzQxODk3MDk5YjU4MjJlYWZhNDBlM2YxZmQyY2RjNGE5MmE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T19:51:10Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-21T19:51:10Z"}, "message": "rollup merge of #21252: nikomatsakis/assoc-type-ice-hunt-take-2\n\nProject region bounds out of the trait when deciding whether a projection type outlives a given regions.\n\nFixes #20890.\nFixes #21150.", "tree": {"sha": "c22f90ce2bc19adbcdd2fdf9284ea674fc5cadd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c22f90ce2bc19adbcdd2fdf9284ea674fc5cadd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "html_url": "https://github.com/rust-lang/rust/commit/036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4df69a40a0c5cbde4ab75e84e06afe10a447012", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4df69a40a0c5cbde4ab75e84e06afe10a447012", "html_url": "https://github.com/rust-lang/rust/commit/f4df69a40a0c5cbde4ab75e84e06afe10a447012"}, {"sha": "626db33bc8c0f45eef88d60e845032c9953f6a3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/626db33bc8c0f45eef88d60e845032c9953f6a3a", "html_url": "https://github.com/rust-lang/rust/commit/626db33bc8c0f45eef88d60e845032c9953f6a3a"}], "stats": {"total": 386, "additions": 384, "deletions": 2}, "files": [{"sha": "568286e39d597df84be12997581b347890fcbd5b", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -84,6 +84,7 @@ pub struct FulfillmentContext<'tcx> {\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n }\n \n+#[derive(Clone)]\n pub struct RegionObligation<'tcx> {\n     pub sub_region: ty::Region,\n     pub sup_type: Ty<'tcx>,"}, {"sha": "6403c1af8e147b38e33a0129efd58c1d9c94b8a9", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -297,14 +297,25 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n-        let fulfillment_cx = self.fcx.inh.fulfillment_cx.borrow();\n-        for r_o in fulfillment_cx.region_obligations(node_id).iter() {\n+\n+        // Make a copy of the region obligations vec because we'll need\n+        // to be able to borrow the fulfillment-cx below when projecting.\n+        let region_obligations =\n+            self.fcx.inh.fulfillment_cx.borrow()\n+                                       .region_obligations(node_id)\n+                                       .to_vec();\n+\n+        for r_o in region_obligations.iter() {\n             debug!(\"visit_region_obligations: r_o={}\",\n                    r_o.repr(self.tcx()));\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = infer::RelateRegionParamBound(r_o.cause.span);\n             type_must_outlive(self, origin, sup_type, r_o.sub_region);\n         }\n+\n+        // Processing the region obligations should not cause the list to grow further:\n+        assert_eq!(region_obligations.len(),\n+                   self.fcx.inh.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n@@ -1480,6 +1491,15 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                    generic.to_ty(rcx.tcx()),\n                                    param_env.caller_bounds.predicates.as_slice().to_vec());\n \n+    // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n+    match *generic {\n+        GenericKind::Param(..) => { }\n+        GenericKind::Projection(ref projection_ty) => {\n+            param_bounds.push_all(\n+                &projection_bounds(rcx, origin.span(), projection_ty)[]);\n+        }\n+    }\n+\n     // Add in the default bound of fn body that applies to all in\n     // scope type parameters:\n     param_bounds.push(param_env.implicit_region_bound);\n@@ -1511,3 +1531,73 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                          region,\n                                          param_bounds);\n }\n+\n+fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                              span: Span,\n+                              projection_ty: &ty::ProjectionTy<'tcx>)\n+                              -> Vec<ty::Region>\n+{\n+    let fcx = rcx.fcx;\n+    let tcx = fcx.tcx();\n+    let infcx = fcx.infcx();\n+\n+    debug!(\"projection_bounds(projection_ty={})\",\n+           projection_ty.repr(tcx));\n+\n+    let ty = ty::mk_projection(tcx, projection_ty.trait_ref.clone(), projection_ty.item_name);\n+\n+    // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n+    // in looking for a trait definition like:\n+    //\n+    // ```\n+    // trait SomeTrait<'a> {\n+    //     type SomeType : 'a;\n+    // }\n+    // ```\n+    //\n+    // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n+    let trait_def = ty::lookup_trait_def(tcx, projection_ty.trait_ref.def_id);\n+    let predicates = trait_def.generics.predicates.as_slice().to_vec();\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|predicate| {\n+            // we're only interesting in `T : 'a` style predicates:\n+            let outlives = match predicate {\n+                ty::Predicate::TypeOutlives(data) => data,\n+                _ => { return None; }\n+            };\n+\n+            debug!(\"projection_bounds: outlives={} (1)\",\n+                   outlives.repr(tcx));\n+\n+            // apply the substitutions (and normalize any projected types)\n+            let outlives = fcx.instantiate_type_scheme(span,\n+                                                       projection_ty.trait_ref.substs,\n+                                                       &outlives);\n+\n+            debug!(\"projection_bounds: outlives={} (2)\",\n+                   outlives.repr(tcx));\n+\n+            let region_result = infcx.try(|_| {\n+                let (outlives, _) =\n+                    infcx.replace_late_bound_regions_with_fresh_var(\n+                        span,\n+                        infer::AssocTypeProjection(projection_ty.item_name),\n+                        &outlives);\n+\n+                debug!(\"projection_bounds: outlives={} (3)\",\n+                       outlives.repr(tcx));\n+\n+                // check whether this predicate applies to our current projection\n+                match infer::mk_eqty(infcx, false, infer::Misc(span), ty, outlives.0) {\n+                    Ok(()) => { Ok(outlives.1) }\n+                    Err(_) => { Err(()) }\n+                }\n+            });\n+\n+            debug!(\"projection_bounds: region_result={}\",\n+                   region_result.repr(tcx));\n+\n+            region_result.ok()\n+        })\n+        .collect()\n+}"}, {"sha": "f833361e3b505cc136f093ab56db2ae7b99419b0", "filename": "src/test/compile-fail/regions-assoc-type-region-bound-in-trait-not-met.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-region-bound-in-trait-not-met.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-region-bound-in-trait-not-met.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-region-bound-in-trait-not-met.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the compiler checks that arbitrary region bounds declared\n+// in the trait must be satisfied on the impl. Issue #20890.\n+\n+trait Foo<'a> { type Value: 'a; }\n+\n+impl<'a> Foo<'a> for &'a i16 {\n+    // OK.\n+    type Value = &'a i32;\n+}\n+\n+impl<'a> Foo<'static> for &'a i32 {\n+    //~^ ERROR cannot infer\n+    type Value = &'a i32;\n+}\n+\n+impl<'a,'b> Foo<'b> for &'a i64 {\n+    //~^ ERROR cannot infer\n+    type Value = &'a i32;\n+}\n+\n+fn main() { }"}, {"sha": "0871d8b01f6e49e324481cf3677fd5d4d16c25eb", "filename": "src/test/compile-fail/regions-assoc-type-static-bound-in-trait-not-met.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-static-bound-in-trait-not-met.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-static-bound-in-trait-not-met.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-assoc-type-static-bound-in-trait-not-met.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the compiler checks that the 'static bound declared in\n+// the trait must be satisfied on the impl. Issue #20890.\n+\n+trait Foo { type Value: 'static; }\n+\n+impl<'a> Foo for &'a i32 {\n+    //~^ ERROR cannot infer\n+    type Value = &'a i32;\n+}\n+\n+impl<'a> Foo for i32 {\n+    // OK.\n+    type Value = i32;\n+}\n+\n+fn main() { }"}, {"sha": "818f0e139419670a29241a6aed975b5be0591634", "filename": "src/test/run-fail/issue-20971.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-fail%2Fissue-20971.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-fail%2Fissue-20971.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-20971.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for Issue #20971.\n+\n+// error-pattern:Hello, world!\n+\n+pub trait Parser {\n+    type Input;\n+    fn parse(&mut self, input: <Self as Parser>::Input);\n+}\n+\n+impl Parser for () {\n+    type Input = ();\n+    fn parse(&mut self, input: ()) {\n+\n+    }\n+}\n+\n+pub fn many() -> Box<Parser<Input=<() as Parser>::Input> + 'static> {\n+    panic!(\"Hello, world!\")\n+}\n+\n+fn main() {\n+    many()\n+        .parse(());\n+}"}, {"sha": "911ee715da2811d3088c29496d1088f62efb6013", "filename": "src/test/run-pass/issue-20763-1.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fissue-20763-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fissue-20763-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20763-1.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait T0 { type O; }\n+\n+struct S<A>(A);\n+impl<A> T0 for S<A> { type O = A; }\n+\n+trait T1: T0 {\n+    // this looks okay but as we see below, `f` is unusable\n+    fn m0<F: Fn(<Self as T0>::O) -> bool>(self, f: F) -> bool;\n+}\n+\n+// complains about the bounds on F here not being required by the trait\n+impl<A> T1 for S<A> {\n+    fn m0<F: Fn(A) -> bool>(self, f: F) -> bool { f(self.0) }\n+}\n+\n+// // complains about mismatched types: <S<A> as T0>::O vs. A\n+// impl<A> T1 for S<A>\n+// {\n+//     fn m0<F: Fn(<Self as T0>::O) -> bool>(self, f: F) -> bool { f(self.0) }\n+// }\n+\n+fn main() { }"}, {"sha": "a17c7b6ade48e4111b3cacd59b40d52e5590595b", "filename": "src/test/run-pass/issue-20763-2.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fissue-20763-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fissue-20763-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20763-2.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait T0 { type O; }\n+\n+struct S<A>(A);\n+impl<A> T0 for S<A> { type O = A; }\n+\n+trait T1: T0 {\n+    // this looks okay but as we see below, `f` is unusable\n+    fn m0<F: Fn(<Self as T0>::O) -> bool>(self, f: F) -> bool;\n+}\n+\n+// complains about mismatched types: <S<A> as T0>::O vs. A\n+impl<A> T1 for S<A>\n+{\n+    fn m0<F: Fn(<Self as T0>::O) -> bool>(self, f: F) -> bool { f(self.0) }\n+}\n+\n+fn main() { }"}, {"sha": "c4f3c33f2698305191c244626b910873f7565a95", "filename": "src/test/run-pass/issue-20797.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fissue-20797.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20797.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #20797.\n+\n+use std::default::Default;\n+use std::io::IoResult;\n+use std::io::fs;\n+use std::io::fs::PathExtensions;\n+\n+/// A strategy for acquiring more subpaths to walk.\n+pub trait Strategy {\n+  type P: PathExtensions;\n+  /// Get additional subpaths from a given path.\n+  fn get_more(&self, item: &Self::P) -> IoResult<Vec<Self::P>>;\n+  /// Determine whether a path should be walked further.\n+  /// This is run against each item from `get_more()`.\n+  fn prune(&self, p: &Self::P) -> bool;\n+}\n+\n+/// The basic fully-recursive strategy. Nothing is pruned.\n+#[derive(Copy, Default)]\n+pub struct Recursive;\n+\n+impl Strategy for Recursive {\n+  type P = Path;\n+  fn get_more(&self, p: &Path) -> IoResult<Vec<Path>> { fs::readdir(p) }\n+\n+  fn prune(&self, _: &Path) -> bool { false }\n+}\n+\n+/// A directory walker of `P` using strategy `S`.\n+pub struct Subpaths<S: Strategy> {\n+    stack: Vec<S::P>,\n+    strategy: S,\n+}\n+\n+impl<S: Strategy> Subpaths<S> {\n+  /// Create a directory walker with a root path and strategy.\n+  pub fn new(p: &S::P, strategy: S) -> IoResult<Subpaths<S>> {\n+    let stack = try!(strategy.get_more(p));\n+    Ok(Subpaths { stack: stack, strategy: strategy })\n+  }\n+}\n+\n+impl<S: Default + Strategy> Subpaths<S> {\n+  /// Create a directory walker with a root path and a default strategy.\n+  pub fn walk(p: &S::P) -> IoResult<Subpaths<S>> {\n+      Subpaths::new(p, Default::default())\n+  }\n+}\n+\n+impl<S: Default + Strategy> Default for Subpaths<S> {\n+  fn default() -> Subpaths<S> {\n+    Subpaths { stack: Vec::new(), strategy: Default::default() }\n+  }\n+}\n+\n+impl<S: Strategy> Iterator for Subpaths<S> {\n+  type Item = S::P;\n+  fn next (&mut self) -> Option<S::P> {\n+    let mut opt_path = self.stack.pop();\n+    while opt_path.is_some() && self.strategy.prune(opt_path.as_ref().unwrap()) {\n+      opt_path = self.stack.pop();\n+    }\n+    match opt_path {\n+      Some(path) => {\n+        if PathExtensions::is_dir(&path) {\n+          let result = self.strategy.get_more(&path);\n+          match result {\n+            Ok(dirs) => { self.stack.extend(dirs.into_iter()); },\n+            Err(..) => { }\n+          }\n+        }\n+        Some(path)\n+      }\n+      None => None,\n+    }\n+  }\n+}\n+\n+fn main() {\n+  let mut walker: Subpaths<Recursive> = Subpaths::walk(&Path::new(\"/home\")).unwrap();\n+}"}, {"sha": "77e1a214764540d7226f6fe1f543f6fdb0986442", "filename": "src/test/run-pass/regions-assoc-type-region-bound.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fregions-assoc-type-region-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fregions-assoc-type-region-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-assoc-type-region-bound.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the compiler considers the 'a bound declared in the\n+// trait. Issue #20890.\n+\n+trait Foo<'a> {\n+    type Value: 'a;\n+\n+    fn get(&self) -> &'a Self::Value;\n+}\n+\n+fn takes_foo<'a,F: Foo<'a>>(f: &'a F) {\n+    // This call would be illegal, because it results in &'a F::Value,\n+    // and the only way we know that `F::Value : 'a` is because of the\n+    // trait declaration.\n+\n+    f.get();\n+}\n+\n+fn main() { }"}, {"sha": "6b629a9035db2538504b947f0534e9b17070e317", "filename": "src/test/run-pass/regions-assoc-type-static-bound.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fregions-assoc-type-static-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/036d8c41897099b5822eafa40e3f1fd2cdc4a92a/src%2Ftest%2Frun-pass%2Fregions-assoc-type-static-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-assoc-type-static-bound.rs?ref=036d8c41897099b5822eafa40e3f1fd2cdc4a92a", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the compiler considers the 'static bound declared in the\n+// trait. Issue #20890.\n+\n+trait Foo { type Value: 'static; }\n+\n+fn require_static<T: 'static>() {}\n+\n+fn takes_foo<F: Foo>() {\n+    require_static::<F::Value>()\n+}\n+\n+fn main() { }"}]}