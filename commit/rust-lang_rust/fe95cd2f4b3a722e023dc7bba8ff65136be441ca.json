{"sha": "fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOTVjZDJmNGIzYTcyMmUwMjNkYzdiYmE4ZmY2NTEzNmJlNDQxY2E=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-30T15:38:16Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-06T11:30:08Z"}, "message": "revamp pre-expansion gating infra", "tree": {"sha": "5a2c5c46f37acf583e81dfc7cd0d73b2f5b53f75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a2c5c46f37acf583e81dfc7cd0d73b2f5b53f75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "html_url": "https://github.com/rust-lang/rust/commit/fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8b190ac4ad79e58d21ee1d573529ff74d8eedaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8b190ac4ad79e58d21ee1d573529ff74d8eedaa", "html_url": "https://github.com/rust-lang/rust/commit/e8b190ac4ad79e58d21ee1d573529ff74d8eedaa"}], "stats": {"total": 133, "additions": 65, "deletions": 68}, "files": [{"sha": "ea9946a8b7a0024d9e6a73057c82dabbd8ea93c4", "filename": "src/libsyntax/feature_gate/check.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate%2Fcheck.rs?ref=fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "patch": "@@ -862,18 +862,17 @@ pub fn check_crate(krate: &ast::Crate,\n     maybe_stage_features(&parse_sess.span_diagnostic, krate, unstable);\n     let mut visitor = PostExpansionVisitor { parse_sess, features };\n \n+    let spans = parse_sess.gated_spans.spans.borrow();\n     macro_rules! gate_all {\n-        ($gate:ident, $msg:literal) => { gate_all!($gate, $gate, $msg); };\n-        ($spans:ident, $gate:ident, $msg:literal) => {\n-            for span in &*parse_sess.gated_spans.$spans.borrow() {\n+        ($gate:ident, $msg:literal) => {\n+            for span in spans.get(&sym::$gate).unwrap_or(&vec![]) {\n                 gate_feature!(&visitor, $gate, *span, $msg);\n             }\n         }\n     }\n-\n     gate_all!(let_chains, \"`let` expressions in this position are experimental\");\n     gate_all!(async_closure, \"async closures are unstable\");\n-    gate_all!(yields, generators, \"yield syntax is experimental\");\n+    gate_all!(generators, \"yield syntax is experimental\");\n     gate_all!(or_patterns, \"or-patterns syntax is experimental\");\n     gate_all!(const_extern_fn, \"`const extern fn` definitions are unstable\");\n \n@@ -901,7 +900,6 @@ pub fn check_crate(krate: &ast::Crate,\n     gate_all!(try_blocks, \"`try` blocks are unstable\");\n     gate_all!(label_break_value, \"labels on blocks are unstable\");\n     gate_all!(box_syntax, \"box expression syntax is experimental; you can call `Box::new` instead\");\n-\n     // To avoid noise about type ascription in common syntax errors,\n     // only emit if it is the *only* error. (Also check it last.)\n     if parse_sess.span_diagnostic.err_count() == 0 {"}, {"sha": "efd716e7c4aa60b424165aa58347b5aa27ff687c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "patch": "@@ -1121,7 +1121,7 @@ impl<'a> Parser<'a> {\n         self.expected_tokens.push(TokenType::Keyword(kw::Crate));\n         if self.is_crate_vis() {\n             self.bump(); // `crate`\n-            self.sess.gated_spans.crate_visibility_modifier.borrow_mut().push(self.prev_span);\n+            self.sess.gated_spans.gate(sym::crate_visibility_modifier, self.prev_span);\n             return Ok(respan(self.prev_span, VisibilityKind::Crate(CrateSugar::JustCrate)));\n         }\n "}, {"sha": "79be67528b904fbb9b8e5079ee41411ba2680e30", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "patch": "@@ -16,10 +16,10 @@ use crate::parse::token::{self, Token, TokenKind};\n use crate::print::pprust;\n use crate::ptr::P;\n use crate::source_map::{self, Span};\n-use crate::symbol::{kw, sym};\n use crate::util::parser::{AssocOp, Fixity, prec_let_scrutinee_needs_par};\n \n use errors::Applicability;\n+use syntax_pos::symbol::{kw, sym};\n use syntax_pos::Symbol;\n use std::mem;\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -252,7 +252,7 @@ impl<'a> Parser<'a> {\n                 self.last_type_ascription = Some((self.prev_span, maybe_path));\n \n                 lhs = self.parse_assoc_op_cast(lhs, lhs_span, ExprKind::Type)?;\n-                self.sess.gated_spans.type_ascription.borrow_mut().push(lhs.span);\n+                self.sess.gated_spans.gate(sym::type_ascription, lhs.span);\n                 continue\n             } else if op == AssocOp::DotDot || op == AssocOp::DotDotEq {\n                 // If we didn\u2019t have to handle `x..`/`x..=`, it would be pretty easy to\n@@ -455,7 +455,7 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 let span = lo.to(span);\n-                self.sess.gated_spans.box_syntax.borrow_mut().push(span);\n+                self.sess.gated_spans.gate(sym::box_syntax, span);\n                 (span, ExprKind::Box(e))\n             }\n             token::Ident(..) if self.token.is_ident_named(sym::not) => {\n@@ -1045,7 +1045,7 @@ impl<'a> Parser<'a> {\n                     }\n \n                     let span = lo.to(hi);\n-                    self.sess.gated_spans.yields.borrow_mut().push(span);\n+                    self.sess.gated_spans.gate(sym::generators, span);\n                 } else if self.eat_keyword(kw::Let) {\n                     return self.parse_let_expr(attrs);\n                 } else if is_span_rust_2018 && self.eat_keyword(kw::Await) {\n@@ -1264,7 +1264,7 @@ impl<'a> Parser<'a> {\n         outer_attrs: ThinVec<Attribute>,\n     ) -> PResult<'a, P<Expr>> {\n         if let Some(label) = opt_label {\n-            self.sess.gated_spans.label_break_value.borrow_mut().push(label.ident.span);\n+            self.sess.gated_spans.gate(sym::label_break_value, label.ident.span);\n         }\n \n         self.expect(&token::OpenDelim(token::Brace))?;\n@@ -1293,7 +1293,7 @@ impl<'a> Parser<'a> {\n         };\n         if asyncness.is_async() {\n             // Feature-gate `async ||` closures.\n-            self.sess.gated_spans.async_closure.borrow_mut().push(self.prev_span);\n+            self.sess.gated_spans.gate(sym::async_closure, self.prev_span);\n         }\n \n         let capture_clause = self.parse_capture_clause();\n@@ -1415,8 +1415,7 @@ impl<'a> Parser<'a> {\n \n         if let ExprKind::Let(..) = cond.kind {\n             // Remove the last feature gating of a `let` expression since it's stable.\n-            let last = self.sess.gated_spans.let_chains.borrow_mut().pop();\n-            debug_assert_eq!(cond.span, last.unwrap());\n+            self.sess.gated_spans.ungate_last(sym::let_chains, cond.span);\n         }\n \n         Ok(cond)\n@@ -1433,7 +1432,7 @@ impl<'a> Parser<'a> {\n             |this| this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         )?;\n         let span = lo.to(expr.span);\n-        self.sess.gated_spans.let_chains.borrow_mut().push(span);\n+        self.sess.gated_spans.gate(sym::let_chains, span);\n         Ok(self.mk_expr(span, ExprKind::Let(pat, expr), attrs))\n     }\n \n@@ -1654,7 +1653,7 @@ impl<'a> Parser<'a> {\n             Err(error)\n         } else {\n             let span = span_lo.to(body.span);\n-            self.sess.gated_spans.try_blocks.borrow_mut().push(span);\n+            self.sess.gated_spans.gate(sym::try_blocks, span);\n             Ok(self.mk_expr(span, ExprKind::TryBlock(body), attrs))\n         }\n     }"}, {"sha": "3c094750b4d98ee9901bb3d8638cb20543d88136", "filename": "src/libsyntax/parse/parser/generics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fgenerics.rs?ref=fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "patch": "@@ -3,7 +3,8 @@ use super::{Parser, PResult};\n use crate::ast::{self, WhereClause, GenericParam, GenericParamKind, GenericBounds, Attribute};\n use crate::parse::token;\n use crate::source_map::DUMMY_SP;\n-use crate::symbol::kw;\n+\n+use syntax_pos::symbol::{kw, sym};\n \n impl<'a> Parser<'a> {\n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n@@ -62,7 +63,7 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        self.sess.gated_spans.const_generics.borrow_mut().push(lo.to(self.prev_span));\n+        self.sess.gated_spans.gate(sym::const_generics, lo.to(self.prev_span));\n \n         Ok(GenericParam {\n             ident,"}, {"sha": "51e96b55c726c5a95112fa3ccd63a011120344cf", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "patch": "@@ -147,9 +147,7 @@ impl<'a> Parser<'a> {\n                 let unsafety = self.parse_unsafety();\n \n                 if self.check_keyword(kw::Extern) {\n-                    self.sess.gated_spans.const_extern_fn.borrow_mut().push(\n-                        lo.to(self.token.span)\n-                    );\n+                    self.sess.gated_spans.gate(sym::const_extern_fn, lo.to(self.token.span));\n                 }\n                 let abi = self.parse_extern_abi()?;\n                 self.bump(); // `fn`\n@@ -830,7 +828,7 @@ impl<'a> Parser<'a> {\n                     .emit();\n             }\n \n-            self.sess.gated_spans.trait_alias.borrow_mut().push(whole_span);\n+            self.sess.gated_spans.gate(sym::trait_alias, whole_span);\n \n             Ok((ident, ItemKind::TraitAlias(tps, bounds), None))\n         } else {\n@@ -1712,7 +1710,7 @@ impl<'a> Parser<'a> {\n         let span = lo.to(self.prev_span);\n \n         if !def.legacy {\n-            self.sess.gated_spans.decl_macro.borrow_mut().push(span);\n+            self.sess.gated_spans.gate(sym::decl_macro, span);\n         }\n \n         Ok(Some(self.mk_item(span, ident, ItemKind::MacroDef(def), vis.clone(), attrs.to_vec())))"}, {"sha": "cc8738edff7f50f088a53ab2432364ae18e1b251", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "patch": "@@ -8,9 +8,8 @@ use crate::mut_visit::{noop_visit_pat, noop_visit_mac, MutVisitor};\n use crate::parse::token::{self};\n use crate::print::pprust;\n use crate::source_map::{respan, Span, Spanned};\n-use crate::symbol::kw;\n use crate::ThinVec;\n-\n+use syntax_pos::symbol::{kw, sym};\n use errors::{Applicability, DiagnosticBuilder};\n \n type Expected = Option<&'static str>;\n@@ -52,11 +51,8 @@ impl<'a> Parser<'a> {\n         // and no other gated or-pattern has been parsed thus far,\n         // then we should really gate the leading `|`.\n         // This complicated procedure is done purely for diagnostics UX.\n-        if gated_leading_vert {\n-            let mut or_pattern_spans = self.sess.gated_spans.or_patterns.borrow_mut();\n-            if or_pattern_spans.is_empty() {\n-                or_pattern_spans.push(leading_vert_span);\n-            }\n+        if gated_leading_vert && self.sess.gated_spans.is_ungated(sym::or_patterns) {\n+            self.sess.gated_spans.gate(sym::or_patterns, leading_vert_span);\n         }\n \n         Ok(pat)\n@@ -117,7 +113,7 @@ impl<'a> Parser<'a> {\n \n         // Feature gate the or-pattern if instructed:\n         if gate_or == GateOr::Yes {\n-            self.sess.gated_spans.or_patterns.borrow_mut().push(or_pattern_span);\n+            self.sess.gated_spans.gate(sym::or_patterns, or_pattern_span);\n         }\n \n         Ok(self.mk_pat(or_pattern_span, PatKind::Or(pats)))\n@@ -325,7 +321,7 @@ impl<'a> Parser<'a> {\n             } else if self.eat_keyword(kw::Box) {\n                 // Parse `box pat`\n                 let pat = self.parse_pat_with_range_pat(false, None)?;\n-                self.sess.gated_spans.box_patterns.borrow_mut().push(lo.to(self.prev_span));\n+                self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_span));\n                 PatKind::Box(pat)\n             } else if self.can_be_ident_pat() {\n                 // Parse `ident @ pat`\n@@ -612,7 +608,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn excluded_range_end(&self, span: Span) -> RangeEnd {\n-        self.sess.gated_spans.exclusive_range_pattern.borrow_mut().push(span);\n+        self.sess.gated_spans.gate(sym::exclusive_range_pattern, span);\n         RangeEnd::Excluded\n     }\n "}, {"sha": "4438d61d9eedde05f130fb7170f513e59cf5c09f", "filename": "src/libsyntax/parse/parser/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "patch": "@@ -5,7 +5,7 @@ use crate::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, Angle\n use crate::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n use crate::parse::token::{self, Token};\n use crate::source_map::{Span, BytePos};\n-use crate::symbol::kw;\n+use syntax_pos::symbol::{kw, sym};\n \n use std::mem;\n use log::debug;\n@@ -426,7 +426,7 @@ impl<'a> Parser<'a> {\n \n                 // Gate associated type bounds, e.g., `Iterator<Item: Ord>`.\n                 if let AssocTyConstraintKind::Bound { .. } = kind {\n-                    self.sess.gated_spans.associated_type_bounds.borrow_mut().push(span);\n+                    self.sess.gated_spans.gate(sym::associated_type_bounds, span);\n                 }\n \n                 constraints.push(AssocTyConstraint {"}, {"sha": "f677d544bc38c402273f10577c4ea8da243f6cdd", "filename": "src/libsyntax/sess.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fsess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe95cd2f4b3a722e023dc7bba8ff65136be441ca/src%2Flibsyntax%2Fsess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsess.rs?ref=fe95cd2f4b3a722e023dc7bba8ff65136be441ca", "patch": "@@ -20,38 +20,43 @@ use std::str;\n /// used and should be feature gated accordingly in `check_crate`.\n #[derive(Default)]\n crate struct GatedSpans {\n-    /// Spans collected for gating `let_chains`, e.g. `if a && let b = c {}`.\n-    crate let_chains: Lock<Vec<Span>>,\n-    /// Spans collected for gating `async_closure`, e.g. `async || ..`.\n-    crate async_closure: Lock<Vec<Span>>,\n-    /// Spans collected for gating `yield e?` expressions (`generators` gate).\n-    crate yields: Lock<Vec<Span>>,\n-    /// Spans collected for gating `or_patterns`, e.g. `Some(Foo | Bar)`.\n-    crate or_patterns: Lock<Vec<Span>>,\n-    /// Spans collected for gating `const_extern_fn`, e.g. `const extern fn foo`.\n-    crate const_extern_fn: Lock<Vec<Span>>,\n-    /// Spans collected for gating `trait_alias`, e.g. `trait Foo = Ord + Eq;`.\n-    pub trait_alias: Lock<Vec<Span>>,\n-    /// Spans collected for gating `associated_type_bounds`, e.g. `Iterator<Item: Ord>`.\n-    pub associated_type_bounds: Lock<Vec<Span>>,\n-    /// Spans collected for gating `crate_visibility_modifier`, e.g. `crate fn`.\n-    pub crate_visibility_modifier: Lock<Vec<Span>>,\n-    /// Spans collected for gating `const_generics`, e.g. `const N: usize`.\n-    pub const_generics: Lock<Vec<Span>>,\n-    /// Spans collected for gating `decl_macro`, e.g. `macro m() {}`.\n-    pub decl_macro: Lock<Vec<Span>>,\n-    /// Spans collected for gating `box_patterns`, e.g. `box 0`.\n-    pub box_patterns: Lock<Vec<Span>>,\n-    /// Spans collected for gating `exclusive_range_pattern`, e.g. `0..2`.\n-    pub exclusive_range_pattern: Lock<Vec<Span>>,\n-    /// Spans collected for gating `try_blocks`, e.g. `try { a? + b? }`.\n-    pub try_blocks: Lock<Vec<Span>>,\n-    /// Spans collected for gating `label_break_value`, e.g. `'label: { ... }`.\n-    pub label_break_value: Lock<Vec<Span>>,\n-    /// Spans collected for gating `box_syntax`, e.g. `box $expr`.\n-    pub box_syntax: Lock<Vec<Span>>,\n-    /// Spans collected for gating `type_ascription`, e.g. `42: usize`.\n-    pub type_ascription: Lock<Vec<Span>>,\n+    crate spans: Lock<FxHashMap<Symbol, Vec<Span>>>,\n+}\n+\n+impl GatedSpans {\n+    /// Feature gate the given `span` under the given `feature`\n+    /// which is same `Symbol` used in `active.rs`.\n+    pub fn gate(&self, feature: Symbol, span: Span) {\n+        self.spans\n+            .borrow_mut()\n+            .entry(feature)\n+            .or_default()\n+            .push(span);\n+    }\n+\n+    /// Ungate the last span under the given `feature`.\n+    /// Panics if the given `span` wasn't the last one.\n+    ///\n+    /// Using this is discouraged unless you have a really good reason to.\n+    pub fn ungate_last(&self, feature: Symbol, span: Span) {\n+        let removed_span = self.spans\n+            .borrow_mut()\n+            .entry(feature)\n+            .or_default()\n+            .pop()\n+            .unwrap();\n+        debug_assert_eq!(span, removed_span);\n+    }\n+\n+    /// Is the provided `feature` gate ungated currently?\n+    ///\n+    /// Using this is discouraged unless you have a really good reason to.\n+    pub fn is_ungated(&self, feature: Symbol) -> bool {\n+        self.spans\n+            .borrow()\n+            .get(&feature)\n+            .map_or(true, |spans| spans.is_empty())\n+    }\n }\n \n /// Info about a parsing session."}]}