{"sha": "3403b3e7175936f694403767b93803df3e606fc0", "node_id": "C_kwDOAAsO6NoAKDM0MDNiM2U3MTc1OTM2ZjY5NDQwMzc2N2I5MzgwM2RmM2U2MDZmYzA", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-01T19:53:12Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-02-05T21:28:25Z"}, "message": "Add lint `transumte_undefined_repr`", "tree": {"sha": "015fe43fde81f41cbed6dbae35839402624c9888", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/015fe43fde81f41cbed6dbae35839402624c9888"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3403b3e7175936f694403767b93803df3e606fc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3403b3e7175936f694403767b93803df3e606fc0", "html_url": "https://github.com/rust-lang/rust/commit/3403b3e7175936f694403767b93803df3e606fc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3403b3e7175936f694403767b93803df3e606fc0/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ef87455b07e527dd636423751591910dac2e166", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef87455b07e527dd636423751591910dac2e166", "html_url": "https://github.com/rust-lang/rust/commit/8ef87455b07e527dd636423751591910dac2e166"}], "stats": {"total": 416, "additions": 415, "deletions": 1}, "files": [{"sha": "7fb31f6d2b28ce6595a3cba08d6912926297d940", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -3304,6 +3304,7 @@ Released 2018-09-13\n [`transmute_num_to_bytes`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_num_to_bytes\n [`transmute_ptr_to_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ptr\n [`transmute_ptr_to_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n+[`transmute_undefined_repr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_undefined_repr\n [`transmutes_expressible_as_ptr_casts`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmutes_expressible_as_ptr_casts\n [`transmuting_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmuting_null\n [`trivial_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivial_regex"}, {"sha": "d93e34e76b492bc9320fd4eb6aa6bf8ce4a3a151", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -277,6 +277,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::TRANSMUTE_INT_TO_FLOAT),\n     LintId::of(transmute::TRANSMUTE_NUM_TO_BYTES),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_REF),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "d013daa8e082a72eb316681fb421749cf455292c", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -58,6 +58,7 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n     LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n+    LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),"}, {"sha": "a80320a578f0e7ba609c90fad800c08ab7c8b456", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -473,6 +473,7 @@ store.register_lints(&[\n     transmute::TRANSMUTE_NUM_TO_BYTES,\n     transmute::TRANSMUTE_PTR_TO_PTR,\n     transmute::TRANSMUTE_PTR_TO_REF,\n+    transmute::TRANSMUTE_UNDEFINED_REPR,\n     transmute::UNSOUND_COLLECTION_TRANSMUTE,\n     transmute::USELESS_TRANSMUTE,\n     transmute::WRONG_TRANSMUTE,"}, {"sha": "0b07726519ecd35db54c71d2d16b35bcc9afb79b", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -5,6 +5,7 @@\n #![feature(control_flow_enum)]\n #![feature(drain_filter)]\n #![feature(iter_intersperse)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(once_cell)]\n #![feature(rustc_private)]"}, {"sha": "4c320deecc28b02b79a19f119be4e49cddb7a5f4", "filename": "clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -7,6 +7,7 @@ mod transmute_num_to_bytes;\n mod transmute_ptr_to_ptr;\n mod transmute_ptr_to_ref;\n mod transmute_ref_to_ref;\n+mod transmute_undefined_repr;\n mod transmutes_expressible_as_ptr_casts;\n mod unsound_collection_transmute;\n mod useless_transmute;\n@@ -355,6 +356,30 @@ declare_clippy_lint! {\n     \"transmute between collections of layout-incompatible types\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for transmutes either to or from a type which does not have a defined representation.\n+    ///\n+    /// ### Why is this bad?\n+    /// The results of such a transmute are not defined.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct Foo<T>(u32, T);\n+    /// let _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// #[repr(C)]\n+    /// struct Foo<T>(u32, T);\n+    /// let _ = unsafe { core::mem::transmute::<Foo<u32>, Foo<i32>>(Foo(0u32, 0u32)) };\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub TRANSMUTE_UNDEFINED_REPR,\n+    correctness,\n+    \"transmute to or from a type with an undefined representation\"\n+}\n+\n declare_lint_pass!(Transmute => [\n     CROSSPOINTER_TRANSMUTE,\n     TRANSMUTE_PTR_TO_REF,\n@@ -369,6 +394,7 @@ declare_lint_pass!(Transmute => [\n     TRANSMUTE_NUM_TO_BYTES,\n     UNSOUND_COLLECTION_TRANSMUTE,\n     TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+    TRANSMUTE_UNDEFINED_REPR,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Transmute {\n@@ -402,7 +428,10 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                     | transmute_int_to_float::check(cx, e, from_ty, to_ty, arg, const_context)\n                     | transmute_float_to_int::check(cx, e, from_ty, to_ty, arg, const_context)\n                     | transmute_num_to_bytes::check(cx, e, from_ty, to_ty, arg, const_context)\n-                    | unsound_collection_transmute::check(cx, e, from_ty, to_ty);\n+                    | (\n+                        unsound_collection_transmute::check(cx, e, from_ty, to_ty)\n+                        || transmute_undefined_repr::check(cx, e, from_ty, to_ty)\n+                    );\n \n                 if !linted {\n                     transmutes_expressible_as_ptr_casts::check(cx, e, from_ty, to_ty, arg);"}, {"sha": "4b7c493278f21918e081a16f25db4acf9ef95fab", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -0,0 +1,291 @@\n+use super::TRANSMUTE_UNDEFINED_REPR;\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::subst::{GenericArg, Subst};\n+use rustc_middle::ty::{self, Ty, TyS, TypeAndMut};\n+use rustc_span::Span;\n+\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty_orig: Ty<'tcx>,\n+    to_ty_orig: Ty<'tcx>,\n+) -> bool {\n+    let mut from_ty = cx.tcx.erase_regions(from_ty_orig);\n+    let mut to_ty = cx.tcx.erase_regions(to_ty_orig);\n+\n+    while !TyS::same_type(from_ty, to_ty) {\n+        match reduce_refs(cx, e.span, from_ty, to_ty) {\n+            ReducedTys::FromFatPtr { unsized_ty, .. } => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                    |diag| {\n+                        if !TyS::same_type(from_ty_orig.peel_refs(), unsized_ty) {\n+                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            ReducedTys::ToFatPtr { unsized_ty, .. } => {\n+                span_lint_and_then(\n+                    cx,\n+                    TRANSMUTE_UNDEFINED_REPR,\n+                    e.span,\n+                    &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                    |diag| {\n+                        if !TyS::same_type(to_ty_orig.peel_refs(), unsized_ty) {\n+                            diag.note(&format!(\"the contained type `&{}` has an undefined layout\", unsized_ty));\n+                        }\n+                    },\n+                );\n+                return true;\n+            },\n+            ReducedTys::ToPtr {\n+                from_ty: from_sub_ty,\n+                to_ty: to_sub_ty,\n+            } => match reduce_ty(cx, from_sub_ty) {\n+                ReducedTy::UnorderedFields(from_ty) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                        |diag| {\n+                            if !TyS::same_type(from_ty_orig.peel_refs(), from_ty) {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                ReducedTy::Ref(from_sub_ty) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                _ => break,\n+            },\n+            ReducedTys::FromPtr {\n+                from_ty: from_sub_ty,\n+                to_ty: to_sub_ty,\n+            } => match reduce_ty(cx, to_sub_ty) {\n+                ReducedTy::UnorderedFields(to_ty) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute to `{}` which has an undefined layout\", to_ty_orig),\n+                        |diag| {\n+                            if !TyS::same_type(to_ty_orig.peel_refs(), to_ty) {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                ReducedTy::Ref(to_sub_ty) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                _ => break,\n+            },\n+            ReducedTys::Other {\n+                from_ty: from_sub_ty,\n+                to_ty: to_sub_ty,\n+            } => match (reduce_ty(cx, from_sub_ty), reduce_ty(cx, to_sub_ty)) {\n+                (ReducedTy::IntArray, _) | (_, ReducedTy::IntArray) => return false,\n+                (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty))\n+                    if !TyS::same_type(from_ty, to_ty) =>\n+                {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\n+                            \"transmute from `{}` to `{}`, both of which have an undefined layout\",\n+                            from_ty_orig, to_ty_orig\n+                        ),\n+                        |diag| {\n+                            if let (Some(from_def), Some(to_def)) = (from_ty.ty_adt_def(), to_ty.ty_adt_def())\n+                                && from_def == to_def\n+                            {\n+                                diag.note(&format!(\n+                                    \"two instances of the same generic type (`{}`) may have different layouts\",\n+                                    cx.tcx.item_name(from_def.did)\n+                                ));\n+                            } else {\n+                                if !TyS::same_type(from_ty_orig.peel_refs(), from_ty) {\n+                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                                }\n+                                if !TyS::same_type(to_ty_orig.peel_refs(), to_ty) {\n+                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                                }\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                (\n+                    ReducedTy::UnorderedFields(from_ty),\n+                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n+                ) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute from `{}` which has an undefined layout\", from_ty_orig),\n+                        |diag| {\n+                            if !TyS::same_type(from_ty_orig.peel_refs(), from_ty) {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                (\n+                    ReducedTy::Other(_) | ReducedTy::OrderedFields(_) | ReducedTy::Ref(_),\n+                    ReducedTy::UnorderedFields(to_ty),\n+                ) => {\n+                    span_lint_and_then(\n+                        cx,\n+                        TRANSMUTE_UNDEFINED_REPR,\n+                        e.span,\n+                        &format!(\"transmute into `{}` which has an undefined layout\", to_ty_orig),\n+                        |diag| {\n+                            if !TyS::same_type(to_ty_orig.peel_refs(), to_ty) {\n+                                diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                            }\n+                        },\n+                    );\n+                    return true;\n+                },\n+                (ReducedTy::Ref(from_sub_ty), ReducedTy::Ref(to_sub_ty)) => {\n+                    from_ty = from_sub_ty;\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                },\n+                (\n+                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_),\n+                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_),\n+                )\n+                | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => break,\n+            },\n+        }\n+    }\n+\n+    false\n+}\n+\n+enum ReducedTys<'tcx> {\n+    FromFatPtr { unsized_ty: Ty<'tcx> },\n+    ToFatPtr { unsized_ty: Ty<'tcx> },\n+    ToPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+    FromPtr { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+    Other { from_ty: Ty<'tcx>, to_ty: Ty<'tcx> },\n+}\n+\n+fn reduce_refs<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    span: Span,\n+    mut from_ty: Ty<'tcx>,\n+    mut to_ty: Ty<'tcx>,\n+) -> ReducedTys<'tcx> {\n+    loop {\n+        return match (from_ty.kind(), to_ty.kind()) {\n+            (\n+                ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. }),\n+                ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. }),\n+            ) => {\n+                from_ty = from_sub_ty;\n+                to_ty = to_sub_ty;\n+                continue;\n+            },\n+            (ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n+                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+            {\n+                ReducedTys::FromFatPtr { unsized_ty }\n+            },\n+            (_, ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n+                if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n+            {\n+                ReducedTys::ToFatPtr { unsized_ty }\n+            },\n+            (ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n+                ReducedTys::FromPtr { from_ty, to_ty }\n+            },\n+            (_, ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. })) => {\n+                ReducedTys::ToPtr { from_ty, to_ty }\n+            },\n+            _ => ReducedTys::Other { from_ty, to_ty },\n+        };\n+    }\n+}\n+\n+enum ReducedTy<'tcx> {\n+    OrderedFields(Ty<'tcx>),\n+    UnorderedFields(Ty<'tcx>),\n+    Ref(Ty<'tcx>),\n+    Other(Ty<'tcx>),\n+    IntArray,\n+}\n+\n+fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx> {\n+    loop {\n+        ty = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty).unwrap_or(ty);\n+        return match *ty.kind() {\n+            ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => ReducedTy::IntArray,\n+            ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n+                ty = sub_ty;\n+                continue;\n+            },\n+            ty::Tuple(args) => {\n+                let mut iter = args.iter().map(GenericArg::expect_ty);\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                    return ReducedTy::OrderedFields(ty);\n+                };\n+                if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n+                    ty = sized_ty;\n+                    continue;\n+                }\n+                ReducedTy::UnorderedFields(ty)\n+            },\n+            ty::Adt(def, substs) if def.is_struct() => {\n+                if def.repr.inhibit_struct_field_reordering_opt() {\n+                    return ReducedTy::OrderedFields(ty);\n+                }\n+                let mut iter = def\n+                    .non_enum_variant()\n+                    .fields\n+                    .iter()\n+                    .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n+                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                    return ReducedTy::OrderedFields(ty);\n+                };\n+                if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n+                    ty = sized_ty;\n+                    continue;\n+                }\n+                ReducedTy::UnorderedFields(ty)\n+            },\n+            ty::Ref(..) | ty::RawPtr(_) => ReducedTy::Ref(ty),\n+            _ => ReducedTy::Other(ty),\n+        };\n+    }\n+}\n+\n+fn is_zero_sized_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    if let Ok(ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty)\n+        && let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty))\n+    {\n+        layout.layout.size.bytes() == 0\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "e0510d942c200843abd0432b756f60ab9002d265", "filename": "tests/ui/crashes/ice-4968.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/tests%2Fui%2Fcrashes%2Fice-4968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/tests%2Fui%2Fcrashes%2Fice-4968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-4968.rs?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -3,6 +3,7 @@\n // Test for https://github.com/rust-lang/rust-clippy/issues/4968\n \n #![warn(clippy::unsound_collection_transmute)]\n+#![allow(clippy::transmute_undefined_repr)]\n \n trait Trait {\n     type Assoc;"}, {"sha": "71539940fbf270e23d043b52d792f2e505c67906", "filename": "tests/ui/transmute_undefined_repr.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/tests%2Fui%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/tests%2Fui%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.rs?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -0,0 +1,44 @@\n+#![warn(clippy::transmute_undefined_repr)]\n+#![allow(clippy::unit_arg)]\n+\n+fn value<T>() -> T {\n+    unimplemented!()\n+}\n+\n+struct Empty;\n+struct Ty<T>(T);\n+struct Ty2<T, U>(T, U);\n+\n+#[repr(C)]\n+struct Ty2C<T, U>(T, U);\n+\n+fn main() {\n+    unsafe {\n+        let _: () = core::mem::transmute(value::<Empty>());\n+        let _: Empty = core::mem::transmute(value::<()>());\n+\n+        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n+        let _: Ty<u32> = core::mem::transmute(value::<u32>());\n+\n+        let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+\n+        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Ok, Ty2 types are the same\n+        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, Ty2 types are the same\n+\n+        let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: Ty<&()> = core::mem::transmute(value::<&()>());\n+        let _: &() = core::mem::transmute(value::<Ty<&()>>());\n+\n+        let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+        let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+\n+        let _: Ty<usize> = core::mem::transmute(value::<&Ty2<u32, i32>>()); // Ok, pointer to usize conversion\n+        let _: &Ty2<u32, i32> = core::mem::transmute(value::<Ty<usize>>()); // Ok, pointer to usize conversion\n+\n+        let _: Ty<[u8; 8]> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Ok, transmute to byte array\n+        let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty<[u8; 8]>>()); // Ok, transmute from byte array\n+    }\n+}"}, {"sha": "040c63c7afa625202d558097aec418e11a13a1b2", "filename": "tests/ui/transmute_undefined_repr.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3403b3e7175936f694403767b93803df3e606fc0/tests%2Fui%2Ftransmute_undefined_repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3403b3e7175936f694403767b93803df3e606fc0/tests%2Fui%2Ftransmute_undefined_repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_undefined_repr.stderr?ref=3403b3e7175936f694403767b93803df3e606fc0", "patch": "@@ -0,0 +1,44 @@\n+error: transmute from `Ty2<u32, i32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:23:33\n+   |\n+LL |         let _: Ty2C<u32, i32> = core::mem::transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::transmute-undefined-repr` implied by `-D warnings`\n+\n+error: transmute into `Ty2<u32, i32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:24:32\n+   |\n+LL |         let _: Ty2<u32, i32> = core::mem::transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `Ty<Ty2<u32, i32>>` to `Ty2<u32, f32>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:29:32\n+   |\n+LL |         let _: Ty2<u32, f32> = core::mem::transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute from `Ty2<u32, f32>` to `Ty<Ty2<u32, i32>>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:30:36\n+   |\n+LL |         let _: Ty<Ty2<u32, i32>> = core::mem::transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Ty2`) may have different layouts\n+\n+error: transmute to `&Ty2<u32, f32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:35:33\n+   |\n+LL |         let _: &Ty2<u32, f32> = core::mem::transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: transmute from `&Ty2<u32, f32>` which has an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:36:37\n+   |\n+LL |         let _: Ty<&Ty2<u32, i32>> = core::mem::transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}]}