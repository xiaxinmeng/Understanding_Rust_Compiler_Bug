{"sha": "665aa3e5bb77d13d641c1663aab78cfcc77707e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NWFhM2U1YmI3N2QxM2Q2NDFjMTY2M2FhYjc4Y2ZjYzc3NzA3ZTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-15T22:05:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-15T22:05:17Z"}, "message": "minor edits", "tree": {"sha": "074836cf02178b458fe3fb8d2471b494047a293b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/074836cf02178b458fe3fb8d2471b494047a293b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/665aa3e5bb77d13d641c1663aab78cfcc77707e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/665aa3e5bb77d13d641c1663aab78cfcc77707e5", "html_url": "https://github.com/rust-lang/rust/commit/665aa3e5bb77d13d641c1663aab78cfcc77707e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/665aa3e5bb77d13d641c1663aab78cfcc77707e5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c489636ce1236f0ff3f9b88d212f8f374e600c19", "url": "https://api.github.com/repos/rust-lang/rust/commits/c489636ce1236f0ff3f9b88d212f8f374e600c19", "html_url": "https://github.com/rust-lang/rust/commit/c489636ce1236f0ff3f9b88d212f8f374e600c19"}], "stats": {"total": 18, "additions": 9, "deletions": 9}, "files": [{"sha": "66da7c3fb3203264798d1b53a158950e4d54423f", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/665aa3e5bb77d13d641c1663aab78cfcc77707e5/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/665aa3e5bb77d13d641c1663aab78cfcc77707e5/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=665aa3e5bb77d13d641c1663aab78cfcc77707e5", "patch": "@@ -196,8 +196,8 @@\n //! type should that reference have? Is it `Pin<&mut Field>` or `&mut Field`?\n //! The same question arises with the fields of an enum, and also when considering\n //! container/wrapper types such as [`Vec<T>`], [`Box<T>`], or [`RefCell<T>`].\n-//! Also, this question arises for both mutable and shared references, we just\n-//! use the more common case of mutable references here for illustration.\n+//! (This question applies to both mutable and shared references, we just\n+//! use the more common case of mutable references here for illustration.)\n //!\n //! It turns out that it is actually up to the author of the data structure\n //! to decide whether the pinned projection for a particular field turns\n@@ -214,22 +214,22 @@\n //!\n //! ## Pinning *is not* structural for `field`\n //!\n-//! It may seem counter-intuitive that the field of a pinned struct is not pinned,\n+//! It may seem counter-intuitive that the field of a pinned struct might not be pinned,\n //! but that is actually the easiest choice: if a `Pin<&mut Field>` is never created,\n //! nothing can go wrong! So, if you decide that some field does not have structural pinning,\n //! all you have to ensure is that you never create a pinned reference to that field.\n //!\n-//! Then you may add a projection method that turns `Pin<&mut Struct>` into `Pin<&mut Field>`:\n+//! Then you may add a projection method that turns `Pin<&mut Struct>` into `&mut Field`:\n //! ```rust,ignore\n //! impl Struct {\n-//!     fn get_field<'a>(self: Pin<&'a mut Self>) -> &'a mut Field {\n+//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> &'a mut Field {\n //!         // This is okay because `field` is never considered pinned.\n //!         unsafe { &mut self.get_unchecked_mut().field }\n //!     }\n //! }\n //! ```\n //!\n-//! You may also make make `Struct: Unpin` *even if* the type of `field`\n+//! You may also `impl Unpin for Struct` *even if* the type of `field`\n //! is not `Unpin`.  What that type thinks about pinning is just not relevant\n //! when no `Pin<&mut Field>` is ever created.\n //!\n@@ -242,7 +242,7 @@\n //! witnessing that the field is pinned:\n //! ```rust,ignore\n //! impl Struct {\n-//!     fn get_field<'a>(self: Pin<&'a mut Self>) -> Pin<&'a mut Field> {\n+//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> Pin<&'a mut Field> {\n //!         // This is okay because `field` is pinned when `self` is.\n //!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n //!     }\n@@ -252,8 +252,8 @@\n //! However, structural pinning comes with a few extra requirements:\n //!\n //! 1.  The struct must only be [`Unpin`] if all the structural fields are\n-//!     `Unpin`. This is the default, but `Unpin` is a safe trait, so it is your\n-//!     responsibility as the author of the struct *not* to add something like\n+//!     `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n+//!     the struct it is your responsibility *not* to add something like\n //!     `impl<T> Unpin for Struct<T>`. (Notice that adding a projection operation\n //!     requires unsafe code, so the fact that `Unpin` is a safe trait does not break\n //!     the principle that you only have to worry about any of this if you use `unsafe`.)"}]}