{"sha": "eebf29ed377189c111afe457be920b645835296c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYmYyOWVkMzc3MTg5YzExMWFmZTQ1N2JlOTIwYjY0NTgzNTI5NmM=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-04-06T00:43:16Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-04-07T04:28:17Z"}, "message": "Impl cmp/num traits for BigUint, BigInt\n\nTotalEq, TotalOrd, FromStrRadix, ToStrRadix.", "tree": {"sha": "22f0233a10566eb4a84173ad13a54adbe2b74122", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22f0233a10566eb4a84173ad13a54adbe2b74122"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eebf29ed377189c111afe457be920b645835296c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eebf29ed377189c111afe457be920b645835296c", "html_url": "https://github.com/rust-lang/rust/commit/eebf29ed377189c111afe457be920b645835296c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eebf29ed377189c111afe457be920b645835296c/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44d4d6de762f3f9aae1fedcf454c66b79b3ad58d", "url": "https://api.github.com/repos/rust-lang/rust/commits/44d4d6de762f3f9aae1fedcf454c66b79b3ad58d", "html_url": "https://github.com/rust-lang/rust/commit/44d4d6de762f3f9aae1fedcf454c66b79b3ad58d"}], "stats": {"total": 332, "additions": 187, "deletions": 145}, "files": [{"sha": "f15632b1431eb07948a6eef8c6c3c67d7748ff7d", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 187, "deletions": 145, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/eebf29ed377189c111afe457be920b645835296c/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eebf29ed377189c111afe457be920b645835296c/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=eebf29ed377189c111afe457be920b645835296c", "patch": "@@ -16,8 +16,8 @@ A BigUint is represented as an array of BigDigits.\n A BigInt is a combination of BigUint and Sign.\n */\n \n-use core::cmp::{Eq, Ord};\n-use core::num::{IntConvertible, Zero, One};\n+use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n+use core::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix};\n use core::*;\n \n /**\n@@ -78,15 +78,46 @@ pub struct BigUint {\n }\n \n impl Eq for BigUint {\n-    fn eq(&self, other: &BigUint) -> bool { self.cmp(other) == 0 }\n-    fn ne(&self, other: &BigUint) -> bool { self.cmp(other) != 0 }\n+    fn eq(&self, other: &BigUint) -> bool { self.equals(other) }\n+    fn ne(&self, other: &BigUint) -> bool { !self.equals(other) }\n+}\n+\n+impl TotalEq for BigUint {\n+    fn equals(&self, other: &BigUint) -> bool {\n+        match self.cmp(other) { Equal => true, _ => false }\n+    }\n }\n \n impl Ord for BigUint {\n-    fn lt(&self, other: &BigUint) -> bool { self.cmp(other) <  0 }\n-    fn le(&self, other: &BigUint) -> bool { self.cmp(other) <= 0 }\n-    fn ge(&self, other: &BigUint) -> bool { self.cmp(other) >= 0 }\n-    fn gt(&self, other: &BigUint) -> bool { self.cmp(other) >  0 }\n+    fn lt(&self, other: &BigUint) -> bool {\n+        match self.cmp(other) { Less => true, _ => false}\n+    }\n+    fn le(&self, other: &BigUint) -> bool {\n+        match self.cmp(other) { Less | Equal => true, _ => false }\n+    }\n+    fn ge(&self, other: &BigUint) -> bool {\n+        match self.cmp(other) { Greater | Equal => true, _ => false }\n+    }\n+    fn gt(&self, other: &BigUint) -> bool {\n+        match self.cmp(other) { Greater => true, _ => false }\n+    }\n+}\n+\n+impl TotalOrd for BigUint {\n+    fn cmp(&self, other: &BigUint) -> Ordering {\n+        let s_len = self.data.len(), o_len = other.data.len();\n+        if s_len < o_len { return Less; }\n+        if s_len > o_len { return Greater;  }\n+\n+        for self.data.eachi_reverse |i, elm| {\n+            match (*elm, other.data[i]) {\n+                (l, r) if l < r => return Less,\n+                (l, r) if l > r => return Greater,\n+                _               => loop\n+            };\n+        }\n+        return Equal;\n+    }\n }\n \n impl ToStr for BigUint {\n@@ -95,7 +126,7 @@ impl ToStr for BigUint {\n \n impl from_str::FromStr for BigUint {\n     fn from_str(s: &str) -> Option<BigUint> {\n-        BigUint::from_str_radix(s, 10)\n+        FromStrRadix::from_str_radix(s, 10)\n     }\n }\n \n@@ -189,12 +220,10 @@ impl Mul<BigUint, BigUint> for BigUint {\n         let mm = {\n             let (s1, n1) = sub_sign(sHi, sLo);\n             let (s2, n2) = sub_sign(oHi, oLo);\n-            if s1 * s2 < 0 {\n-                hh + ll + (n1 * n2)\n-            } else if s1 * s2 > 0 {\n-                hh + ll - (n1 * n2)\n-            } else {\n-                hh + ll\n+            match (s1, s2) {\n+                (Equal, _) | (_, Equal) => hh + ll,\n+                (Less, Greater) | (Greater, Less) => hh + ll + (n1 * n2),\n+                (Less, Less) | (Greater, Greater) => hh + ll - (n1 * n2)\n             }\n         };\n \n@@ -223,11 +252,11 @@ impl Mul<BigUint, BigUint> for BigUint {\n                     BigUint::from_slice(vec::slice(a.data, 0, mid)));\n         }\n \n-        fn sub_sign(a: BigUint, b: BigUint) -> (int, BigUint) {\n+        fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) {\n             match a.cmp(&b) {\n-                s if s < 0 => (s, b - a),\n-                s if s > 0 => (s, a - b),\n-                _          => (0, Zero::zero())\n+                Less    => (Less,    b - a),\n+                Greater => (Greater, a - b),\n+                _       => (Equal,   Zero::zero())\n             }\n         }\n     }\n@@ -261,6 +290,49 @@ impl IntConvertible for BigUint {\n     }\n }\n \n+impl ToStrRadix for BigUint {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n+        assert!(1 < radix && radix <= 16);\n+        let (base, max_len) = get_radix_base(radix);\n+        if base == BigDigit::base {\n+            return fill_concat(self.data, radix, max_len)\n+        }\n+        return fill_concat(convert_base(copy *self, base), radix, max_len);\n+\n+        fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n+            let divider    = BigUint::from_uint(base);\n+            let mut result = ~[];\n+            let mut r      = n;\n+            while r > divider {\n+                let (d, r0) = r.divmod(&divider);\n+                result += [r0.to_uint() as BigDigit];\n+                r = d;\n+            }\n+            if r.is_not_zero() {\n+                result += [r.to_uint() as BigDigit];\n+            }\n+            return result;\n+        }\n+\n+        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n+            if v.is_empty() { return ~\"0\" }\n+            let s = str::concat(vec::reversed(v).map(|n| {\n+                let s = uint::to_str_radix(*n as uint, radix);\n+                str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n+            }));\n+            str::trim_left_chars(s, ['0']).to_owned()\n+        }\n+    }\n+}\n+\n+impl FromStrRadix for BigUint {\n+    /// Creates and initializes an BigUint.\n+    pub fn from_str_radix(s: &str, radix: uint)\n+        -> Option<BigUint> {\n+        BigUint::parse_bytes(str::to_bytes(s), radix)\n+    }\n+}\n+\n pub impl BigUint {\n     /// Creates and initializes an BigUint.\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n@@ -287,12 +359,6 @@ pub impl BigUint {\n         return BigUint::new(vec::from_slice(slice));\n     }\n \n-    /// Creates and initializes an BigUint.\n-    pub fn from_str_radix(s: &str, radix: uint)\n-        -> Option<BigUint> {\n-        BigUint::parse_bytes(str::to_bytes(s), radix)\n-    }\n-\n     /// Creates and initializes an BigUint.\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n@@ -318,31 +384,15 @@ pub impl BigUint {\n \n     fn abs(&self) -> BigUint { copy *self }\n \n-    /// Compare two BigUint value.\n-    fn cmp(&self, other: &BigUint) -> int {\n-        let s_len = self.data.len(), o_len = other.data.len();\n-        if s_len < o_len { return -1; }\n-        if s_len > o_len { return  1;  }\n-\n-        for self.data.eachi_reverse |i, elm| {\n-            match (*elm, other.data[i]) {\n-                (l, r) if l < r => return -1,\n-                (l, r) if l > r => return  1,\n-                _               => loop\n-            };\n-        }\n-        return 0;\n-    }\n-\n     fn divmod(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return (copy *self, Zero::zero()); }\n \n         match self.cmp(other) {\n-            s if s < 0 => return (Zero::zero(), copy *self),\n-            0          => return (One::one(), Zero::zero()),\n-            _          => {} // Do nothing\n+            Less    => return (Zero::zero(), copy *self),\n+            Equal   => return (One::one(), Zero::zero()),\n+            Greater => {} // Do nothing\n         }\n \n         let mut shift = 0;\n@@ -433,39 +483,6 @@ pub impl BigUint {\n         }\n     }\n \n-    fn to_str_radix(&self, radix: uint) -> ~str {\n-        assert!(1 < radix && radix <= 16);\n-        let (base, max_len) = get_radix_base(radix);\n-        if base == BigDigit::base {\n-            return fill_concat(self.data, radix, max_len)\n-        }\n-        return fill_concat(convert_base(copy *self, base), radix, max_len);\n-\n-        fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n-            let divider    = BigUint::from_uint(base);\n-            let mut result = ~[];\n-            let mut r      = n;\n-            while r > divider {\n-                let (d, r0) = r.divmod(&divider);\n-                result += [r0.to_uint() as BigDigit];\n-                r = d;\n-            }\n-            if r.is_not_zero() {\n-                result += [r.to_uint() as BigDigit];\n-            }\n-            return result;\n-        }\n-\n-        fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n-            if v.is_empty() { return ~\"0\" }\n-            let s = str::concat(vec::reversed(v).map(|n| {\n-                let s = uint::to_str_radix(*n as uint, radix);\n-                str::from_chars(vec::from_elem(l - s.len(), '0')) + s\n-            }));\n-            str::trim_left_chars(s, ['0']).to_owned()\n-        }\n-    }\n-\n     priv fn shl_unit(self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return self; }\n \n@@ -561,22 +578,31 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n pub enum Sign { Minus, Zero, Plus }\n \n impl Ord for Sign {\n-    fn lt(&self, other: &Sign) -> bool { self.cmp(other) <  0 }\n-    fn le(&self, other: &Sign) -> bool { self.cmp(other) <= 0 }\n-    fn ge(&self, other: &Sign) -> bool { self.cmp(other) >= 0 }\n-    fn gt(&self, other: &Sign) -> bool { self.cmp(other) >  0 }\n+    fn lt(&self, other: &Sign) -> bool {\n+        match self.cmp(other) { Less => true, _ => false}\n+    }\n+    fn le(&self, other: &Sign) -> bool {\n+        match self.cmp(other) { Less | Equal => true, _ => false }\n+    }\n+    fn ge(&self, other: &Sign) -> bool {\n+        match self.cmp(other) { Greater | Equal => true, _ => false }\n+    }\n+    fn gt(&self, other: &Sign) -> bool {\n+        match self.cmp(other) { Greater => true, _ => false }\n+    }\n }\n \n-pub impl Sign {\n-    /// Compare two Sign.\n-    fn cmp(&self, other: &Sign) -> int {\n+impl TotalOrd for Sign {\n+    fn cmp(&self, other: &Sign) -> Ordering {\n         match (*self, *other) {\n-          (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) =>  0,\n-          (Minus, Zero)  | (Minus, Plus) | (Zero, Plus) => -1,\n-          _                                             =>  1\n+          (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) => Equal,\n+          (Minus, Zero)  | (Minus, Plus) | (Zero, Plus) => Less,\n+          _                                             => Greater\n         }\n     }\n+}\n \n+impl Neg<Sign> for Sign {\n     /// Negate Sign value.\n     fn neg(&self) -> Sign {\n         match *self {\n@@ -594,15 +620,42 @@ pub struct BigInt {\n }\n \n impl Eq for BigInt {\n-    fn eq(&self, other: &BigInt) -> bool { self.cmp(other) == 0 }\n-    fn ne(&self, other: &BigInt) -> bool { self.cmp(other) != 0 }\n+    fn eq(&self, other: &BigInt) -> bool { self.equals(other) }\n+    fn ne(&self, other: &BigInt) -> bool { !self.equals(other) }\n+}\n+\n+impl TotalEq for BigInt {\n+    fn equals(&self, other: &BigInt) -> bool {\n+        match self.cmp(other) { Equal => true, _ => false }\n+    }\n }\n \n impl Ord for BigInt {\n-    fn lt(&self, other: &BigInt) -> bool { self.cmp(other) <  0 }\n-    fn le(&self, other: &BigInt) -> bool { self.cmp(other) <= 0 }\n-    fn ge(&self, other: &BigInt) -> bool { self.cmp(other) >= 0 }\n-    fn gt(&self, other: &BigInt) -> bool { self.cmp(other) >  0 }\n+    fn lt(&self, other: &BigInt) -> bool {\n+        match self.cmp(other) { Less => true, _ => false}\n+    }\n+    fn le(&self, other: &BigInt) -> bool {\n+        match self.cmp(other) { Less | Equal => true, _ => false }\n+    }\n+    fn ge(&self, other: &BigInt) -> bool {\n+        match self.cmp(other) { Greater | Equal => true, _ => false }\n+    }\n+    fn gt(&self, other: &BigInt) -> bool {\n+        match self.cmp(other) { Greater => true, _ => false }\n+    }\n+}\n+\n+impl TotalOrd for BigInt {\n+    fn cmp(&self, other: &BigInt) -> Ordering {\n+        let scmp = self.sign.cmp(&other.sign);\n+        if scmp != Equal { return scmp; }\n+\n+        match self.sign {\n+            Zero  => Equal,\n+            Plus  => self.data.cmp(&other.data),\n+            Minus => other.data.cmp(&self.data),\n+        }\n+    }\n }\n \n impl ToStr for BigInt {\n@@ -611,7 +664,7 @@ impl ToStr for BigInt {\n \n impl from_str::FromStr for BigInt {\n     fn from_str(s: &str) -> Option<BigInt> {\n-        BigInt::from_str_radix(s, 10)\n+        FromStrRadix::from_str_radix(s, 10)\n     }\n }\n \n@@ -659,12 +712,9 @@ impl Sub<BigInt, BigInt> for BigInt {\n             (Zero, _)    => -other,\n             (_,    Zero) => copy *self,\n             (Plus, Plus) => match self.data.cmp(&other.data) {\n-                s if s < 0 =>\n-                    BigInt::from_biguint(Minus, other.data - self.data),\n-                s if s > 0 =>\n-                    BigInt::from_biguint(Plus, self.data - other.data),\n-                _ =>\n-                    Zero::zero()\n+                Less    => BigInt::from_biguint(Minus, other.data - self.data),\n+                Greater => BigInt::from_biguint(Plus, self.data - other.data),\n+                Equal   => Zero::zero()\n             },\n             (Plus, Minus) => self + (-*other),\n             (Minus, Plus) => -((-self) + *other),\n@@ -730,6 +780,24 @@ impl IntConvertible for BigInt {\n     }\n }\n \n+impl ToStrRadix for BigInt {\n+    fn to_str_radix(&self, radix: uint) -> ~str {\n+        match self.sign {\n+            Plus  => self.data.to_str_radix(radix),\n+            Zero  => ~\"0\",\n+            Minus => ~\"-\" + self.data.to_str_radix(radix)\n+        }\n+    }\n+}\n+\n+impl FromStrRadix for BigInt {\n+    /// Creates and initializes an BigInt.\n+    pub fn from_str_radix(s: &str, radix: uint)\n+        -> Option<BigInt> {\n+        BigInt::parse_bytes(str::to_bytes(s), radix)\n+    }\n+}\n+\n pub impl BigInt {\n     /// Creates and initializes an BigInt.\n     pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n@@ -755,12 +823,6 @@ pub impl BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n-    /// Creates and initializes an BigInt.\n-    pub fn from_str_radix(s: &str, radix: uint)\n-        -> Option<BigInt> {\n-        BigInt::parse_bytes(str::to_bytes(s), radix)\n-    }\n-\n     /// Creates and initializes an BigInt.\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n@@ -779,19 +841,6 @@ pub impl BigInt {\n         BigInt::from_biguint(Plus, copy self.data)\n     }\n \n-    fn cmp(&self, other: &BigInt) -> int {\n-        let ss = self.sign, os = other.sign;\n-        if ss < os { return -1; }\n-        if ss > os { return  1; }\n-\n-        assert!(ss == os);\n-        match ss {\n-            Zero  => 0,\n-            Plus  => self.data.cmp(&other.data),\n-            Minus => self.data.cmp(&other.data).neg(),\n-        }\n-    }\n-\n     fn divmod(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n         let (d_ui, m_ui) = self.data.divmod(&other.data);\n@@ -851,21 +900,14 @@ pub impl BigInt {\n             Minus => 0\n         }\n     }\n-\n-    fn to_str_radix(&self, radix: uint) -> ~str {\n-        match self.sign {\n-            Plus  => self.data.to_str_radix(radix),\n-            Zero  => ~\"0\",\n-            Minus => ~\"-\" + self.data.to_str_radix(radix)\n-        }\n-    }\n }\n \n #[cfg(test)]\n mod biguint_tests {\n \n     use core::*;\n-    use core::num::{IntConvertible, Zero, One};\n+    use core::num::{IntConvertible, Zero, One, FromStrRadix};\n+    use core::cmp::{Less, Equal, Greater};\n     use super::{BigUint, BigDigit};\n \n     #[test]\n@@ -889,17 +931,17 @@ mod biguint_tests {\n             for vec::slice(data, i, data.len()).eachi |j0, nj| {\n                 let j = j0 + i;\n                 if i == j {\n-                    assert!(ni.cmp(nj) == 0);\n-                    assert!(nj.cmp(ni) == 0);\n+                    assert_eq!(ni.cmp(nj), Equal);\n+                    assert_eq!(nj.cmp(ni), Equal);\n                     assert!(ni == nj);\n                     assert!(!(ni != nj));\n                     assert!(ni <= nj);\n                     assert!(ni >= nj);\n                     assert!(!(ni < nj));\n                     assert!(!(ni > nj));\n                 } else {\n-                    assert!(ni.cmp(nj) < 0);\n-                    assert!(nj.cmp(ni) > 0);\n+                    assert_eq!(ni.cmp(nj), Less);\n+                    assert_eq!(nj.cmp(ni), Greater);\n \n                     assert!(!(ni == nj));\n                     assert!(ni != nj);\n@@ -1245,13 +1287,13 @@ mod biguint_tests {\n             let &(n, rs) = num_pair;\n             for rs.each |str_pair| {\n                 let &(radix, str) = str_pair;\n-                assert!(Some(n) == BigUint::from_str_radix(str, radix));\n+                assert_eq!(Some(n), FromStrRadix::from_str_radix(str, radix));\n             }\n         }\n \n-        assert!(BigUint::from_str_radix(~\"Z\", 10) == None);\n-        assert!(BigUint::from_str_radix(~\"_\", 2) == None);\n-        assert!(BigUint::from_str_radix(~\"-1\", 10) == None);\n+        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(~\"Z\", 10), None);\n+        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(~\"_\", 2), None);\n+        assert_eq!(FromStrRadix::from_str_radix::<BigUint>(~\"-1\", 10), None);\n     }\n \n     #[test]\n@@ -1266,7 +1308,7 @@ mod biguint_tests {\n \n         fn check(n: uint, s: &str) {\n             let n = factor(n);\n-            let ans = match BigUint::from_str_radix(s, 10) {\n+            let ans = match FromStrRadix::from_str_radix(s, 10) {\n                 Some(x) => x, None => fail!()\n             };\n             assert!(n == ans);\n@@ -1282,9 +1324,9 @@ mod biguint_tests {\n #[cfg(test)]\n mod bigint_tests {\n     use super::{BigInt, BigUint, BigDigit, Sign, Minus, Zero, Plus};\n-\n     use core::*;\n-    use core::num::{IntConvertible, Zero, One};\n+    use core::cmp::{Less, Equal, Greater};\n+    use core::num::{IntConvertible, Zero, One, FromStrRadix};\n \n     #[test]\n     fn test_from_biguint() {\n@@ -1311,17 +1353,17 @@ mod bigint_tests {\n             for vec::slice(nums, i, nums.len()).eachi |j0, nj| {\n                 let j = i + j0;\n                 if i == j {\n-                    assert!(ni.cmp(nj) == 0);\n-                    assert!(nj.cmp(ni) == 0);\n+                    assert_eq!(ni.cmp(nj), Equal);\n+                    assert_eq!(nj.cmp(ni), Equal);\n                     assert!(ni == nj);\n                     assert!(!(ni != nj));\n                     assert!(ni <= nj);\n                     assert!(ni >= nj);\n                     assert!(!(ni < nj));\n                     assert!(!(ni > nj));\n                 } else {\n-                    assert!(ni.cmp(nj) < 0);\n-                    assert!(nj.cmp(ni) > 0);\n+                    assert_eq!(ni.cmp(nj), Less);\n+                    assert_eq!(nj.cmp(ni), Greater);\n \n                     assert!(!(ni == nj));\n                     assert!(ni != nj);\n@@ -1623,8 +1665,8 @@ mod bigint_tests {\n     #[test]\n     fn test_from_str_radix() {\n         fn check(s: &str, ans: Option<int>) {\n-            let ans = ans.map(|&n| IntConvertible::from_int(n));\n-            assert!(BigInt::from_str_radix(s, 10) == ans);\n+            let ans = ans.map(|&n| IntConvertible::from_int::<BigInt>(n));\n+            assert!(FromStrRadix::from_str_radix(s, 10) == ans);\n         }\n         check(\"10\", Some(10));\n         check(\"1\", Some(1));"}]}