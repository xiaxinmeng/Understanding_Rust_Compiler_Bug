{"sha": "5344236715fafa2b8d27320839f44d0f4b5ca955", "node_id": "C_kwDOAAsO6NoAKDUzNDQyMzY3MTVmYWZhMmI4ZDI3MzIwODM5ZjQ0ZDBmNGI1Y2E5NTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-10T17:45:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-10T17:45:19Z"}, "message": "Auto merge of #8631 - Alexendoo:splitn-overlap, r=xFrednet\n\nRemove overlap between `manual_split_once` and `needless_splitn`\n\nchangelog: Remove overlap between [`manual_split_once`] and [`needless_splitn`]. Fixes some incorrect `rsplitn` suggestions for [`manual_split_once`]\n\nThings that can trigger `needless_splitn` no longer trigger `manual_split_once`, e.g.\n\n```rust\ns.[r]splitn(2, '=').next();\ns.[r]splitn(2, '=').nth(0);\ns.[r]splitn(3, '=').next_tuple();\n```\n\nFixes some suggestions:\n\n```rust\nlet s = \"should not match\";\n\ns.rsplitn(2, '.').nth(1);\n// old -> Some(\"should not match\")\nSome(s.rsplit_once('.').map_or(s, |x| x.0));\n// new -> None\ns.rsplit_once('.').map(|x| x.0);\n\ns.rsplitn(2, '.').nth(1)?;\n// old -> \"should not match\"\ns.rsplit_once('.').map_or(s, |x| x.0);\n// new -> early returns\ns.rsplit_once('.')?.0;\n```", "tree": {"sha": "ae232d0bf09cc55d2fc008cda914a37f35250d08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae232d0bf09cc55d2fc008cda914a37f35250d08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5344236715fafa2b8d27320839f44d0f4b5ca955", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5344236715fafa2b8d27320839f44d0f4b5ca955", "html_url": "https://github.com/rust-lang/rust/commit/5344236715fafa2b8d27320839f44d0f4b5ca955", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5344236715fafa2b8d27320839f44d0f4b5ca955/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7e68638431b2a6639fcbeb44de790619de3b9b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7e68638431b2a6639fcbeb44de790619de3b9b1", "html_url": "https://github.com/rust-lang/rust/commit/c7e68638431b2a6639fcbeb44de790619de3b9b1"}, {"sha": "6fba89751bfacf59109d37331ec79a8f87ee0aaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fba89751bfacf59109d37331ec79a8f87ee0aaf", "html_url": "https://github.com/rust-lang/rust/commit/6fba89751bfacf59109d37331ec79a8f87ee0aaf"}], "stats": {"total": 475, "additions": 216, "deletions": 259}, "files": [{"sha": "56a8782cee427348b069271341891e305b576c57", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5344236715fafa2b8d27320839f44d0f4b5ca955/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5344236715fafa2b8d27320839f44d0f4b5ca955/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=5344236715fafa2b8d27320839f44d0f4b5ca955", "patch": "@@ -2574,12 +2574,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                 if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                     suspicious_splitn::check(cx, name, expr, recv, count);\n-                    if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n-                        str_splitn::check_manual_split_once(cx, name, expr, recv, pat_arg);\n-                    }\n-                    if count >= 2 {\n-                        str_splitn::check_needless_splitn(cx, name, expr, recv, pat_arg, count);\n-                    }\n+                    str_splitn::check(cx, name, expr, recv, pat_arg, count, msrv);\n                 }\n             },\n             (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {"}, {"sha": "6eaa9eb2ef0ec0958eb96f78a9a596f5266732bf", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 76, "deletions": 170, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/5344236715fafa2b8d27320839f44d0f4b5ca955/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5344236715fafa2b8d27320839f44d0f4b5ca955/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=5344236715fafa2b8d27320839f44d0f4b5ca955", "patch": "@@ -1,36 +1,77 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_context;\n-use clippy_utils::{is_diag_item_method, match_def_path, paths};\n+use clippy_utils::{is_diag_item_method, match_def_path, meets_msrv, msrvs, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, HirId, LangItem, Node, QPath};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, adjustment::Adjust};\n+use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n use rustc_span::{symbol::sym, Span, SyntaxContext};\n \n-use super::MANUAL_SPLIT_ONCE;\n+use super::{MANUAL_SPLIT_ONCE, NEEDLESS_SPLITN};\n \n-pub(super) fn check_manual_split_once(\n+pub(super) fn check(\n     cx: &LateContext<'_>,\n     method_name: &str,\n     expr: &Expr<'_>,\n     self_arg: &Expr<'_>,\n     pat_arg: &Expr<'_>,\n+    count: u128,\n+    msrv: Option<&RustcVersion>,\n ) {\n-    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n+    if count < 2 || !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n         return;\n     }\n \n     let ctxt = expr.span.ctxt();\n-    let (method_name, msg, reverse) = if method_name == \"splitn\" {\n-        (\"split_once\", \"manual implementation of `split_once`\", false)\n-    } else {\n-        (\"rsplit_once\", \"manual implementation of `rsplit_once`\", true)\n+    let Some(usage) = parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id)) else { return };\n+\n+    let needless = match usage.kind {\n+        IterUsageKind::Nth(n) => count > n + 1,\n+        IterUsageKind::NextTuple => count > 2,\n     };\n-    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id), reverse) {\n-        Some(x) => x,\n-        None => return,\n+\n+    if needless {\n+        let mut app = Applicability::MachineApplicable;\n+        let (r, message) = if method_name == \"splitn\" {\n+            (\"\", \"unnecessary use of `splitn`\")\n+        } else {\n+            (\"r\", \"unnecessary use of `rsplitn`\")\n+        };\n+\n+        span_lint_and_sugg(\n+            cx,\n+            NEEDLESS_SPLITN,\n+            expr.span,\n+            message,\n+            \"try this\",\n+            format!(\n+                \"{}.{r}split({})\",\n+                snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0,\n+                snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0,\n+            ),\n+            app,\n+        );\n+    } else if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n+        check_manual_split_once(cx, method_name, expr, self_arg, pat_arg, &usage);\n+    }\n+}\n+\n+fn check_manual_split_once(\n+    cx: &LateContext<'_>,\n+    method_name: &str,\n+    expr: &Expr<'_>,\n+    self_arg: &Expr<'_>,\n+    pat_arg: &Expr<'_>,\n+    usage: &IterUsage,\n+) {\n+    let ctxt = expr.span.ctxt();\n+    let (msg, reverse) = if method_name == \"splitn\" {\n+        (\"manual implementation of `split_once`\", false)\n+    } else {\n+        (\"manual implementation of `rsplit_once`\", true)\n     };\n \n     let mut app = Applicability::MachineApplicable;\n@@ -39,77 +80,36 @@ pub(super) fn check_manual_split_once(\n \n     let sugg = match usage.kind {\n         IterUsageKind::NextTuple => {\n-            format!(\"{}.{}({})\", self_snip, method_name, pat_snip)\n-        },\n-        IterUsageKind::RNextTuple => format!(\"{}.{}({}).map(|(x, y)| (y, x))\", self_snip, method_name, pat_snip),\n-        IterUsageKind::Next | IterUsageKind::Second => {\n-            let self_deref = {\n-                let adjust = cx.typeck_results().expr_adjustments(self_arg);\n-                if adjust.len() < 2 {\n-                    String::new()\n-                } else if cx.typeck_results().expr_ty(self_arg).is_box()\n-                    || adjust\n-                        .iter()\n-                        .any(|a| matches!(a.kind, Adjust::Deref(Some(_))) || a.target.is_box())\n-                {\n-                    format!(\"&{}\", \"*\".repeat(adjust.len().saturating_sub(1)))\n-                } else {\n-                    \"*\".repeat(adjust.len().saturating_sub(2))\n-                }\n-            };\n-            if matches!(usage.kind, IterUsageKind::Next) {\n-                match usage.unwrap_kind {\n-                    Some(UnwrapKind::Unwrap) => {\n-                        if reverse {\n-                            format!(\"{}.{}({}).unwrap().0\", self_snip, method_name, pat_snip)\n-                        } else {\n-                            format!(\n-                                \"{}.{}({}).map_or({}{}, |x| x.0)\",\n-                                self_snip, method_name, pat_snip, self_deref, &self_snip\n-                            )\n-                        }\n-                    },\n-                    Some(UnwrapKind::QuestionMark) => {\n-                        format!(\n-                            \"{}.{}({}).map_or({}{}, |x| x.0)\",\n-                            self_snip, method_name, pat_snip, self_deref, &self_snip\n-                        )\n-                    },\n-                    None => {\n-                        format!(\n-                            \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n-                            &self_snip, method_name, pat_snip, self_deref, &self_snip\n-                        )\n-                    },\n-                }\n+            if reverse {\n+                format!(\"{self_snip}.rsplit_once({pat_snip}).map(|(x, y)| (y, x))\")\n             } else {\n-                match usage.unwrap_kind {\n-                    Some(UnwrapKind::Unwrap) => {\n-                        if reverse {\n-                            // In this case, no better suggestion is offered.\n-                            return;\n-                        }\n-                        format!(\"{}.{}({}).unwrap().1\", self_snip, method_name, pat_snip)\n-                    },\n-                    Some(UnwrapKind::QuestionMark) => {\n-                        format!(\"{}.{}({})?.1\", self_snip, method_name, pat_snip)\n-                    },\n-                    None => {\n-                        format!(\"{}.{}({}).map(|x| x.1)\", self_snip, method_name, pat_snip)\n-                    },\n-                }\n+                format!(\"{self_snip}.split_once({pat_snip})\")\n             }\n         },\n+        IterUsageKind::Nth(1) => {\n+            let (r, field) = if reverse { (\"r\", 0) } else { (\"\", 1) };\n+\n+            match usage.unwrap_kind {\n+                Some(UnwrapKind::Unwrap) => {\n+                    format!(\"{self_snip}.{r}split_once({pat_snip}).unwrap().{field}\")\n+                },\n+                Some(UnwrapKind::QuestionMark) => {\n+                    format!(\"{self_snip}.{r}split_once({pat_snip})?.{field}\")\n+                },\n+                None => {\n+                    format!(\"{self_snip}.{r}split_once({pat_snip}).map(|x| x.{field})\")\n+                },\n+            }\n+        },\n+        IterUsageKind::Nth(_) => return,\n     };\n \n     span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n }\n \n enum IterUsageKind {\n-    Next,\n-    Second,\n+    Nth(u128),\n     NextTuple,\n-    RNextTuple,\n }\n \n enum UnwrapKind {\n@@ -128,7 +128,6 @@ fn parse_iter_usage<'tcx>(\n     cx: &LateContext<'tcx>,\n     ctxt: SyntaxContext,\n     mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n-    reverse: bool,\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n@@ -141,13 +140,7 @@ fn parse_iter_usage<'tcx>(\n             let iter_id = cx.tcx.get_diagnostic_item(sym::Iterator)?;\n \n             match (name.ident.as_str(), args) {\n-                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                    if reverse {\n-                        (IterUsageKind::Second, e.span)\n-                    } else {\n-                        (IterUsageKind::Next, e.span)\n-                    }\n-                },\n+                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => (IterUsageKind::Nth(0), e.span),\n                 (\"next_tuple\", []) => {\n                     return if_chain! {\n                         if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n@@ -157,7 +150,7 @@ fn parse_iter_usage<'tcx>(\n                         if subs.len() == 2;\n                         then {\n                             Some(IterUsage {\n-                                kind: if reverse { IterUsageKind::RNextTuple } else { IterUsageKind::NextTuple },\n+                                kind: IterUsageKind::NextTuple,\n                                 span: e.span,\n                                 unwrap_kind: None\n                             })\n@@ -185,11 +178,7 @@ fn parse_iter_usage<'tcx>(\n                                 }\n                             }\n                         };\n-                        match if reverse { idx ^ 1 } else { idx } {\n-                            0 => (IterUsageKind::Next, span),\n-                            1 => (IterUsageKind::Second, span),\n-                            _ => return None,\n-                        }\n+                        (IterUsageKind::Nth(idx), span)\n                     } else {\n                         return None;\n                     }\n@@ -238,86 +227,3 @@ fn parse_iter_usage<'tcx>(\n         span,\n     })\n }\n-\n-use super::NEEDLESS_SPLITN;\n-\n-pub(super) fn check_needless_splitn(\n-    cx: &LateContext<'_>,\n-    method_name: &str,\n-    expr: &Expr<'_>,\n-    self_arg: &Expr<'_>,\n-    pat_arg: &Expr<'_>,\n-    count: u128,\n-) {\n-    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n-        return;\n-    }\n-    let ctxt = expr.span.ctxt();\n-    let mut app = Applicability::MachineApplicable;\n-    let (reverse, message) = if method_name == \"splitn\" {\n-        (false, \"unnecessary use of `splitn`\")\n-    } else {\n-        (true, \"unnecessary use of `rsplitn`\")\n-    };\n-    if_chain! {\n-        if count >= 2;\n-        if check_iter(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id), count);\n-        then {\n-            span_lint_and_sugg(\n-                cx,\n-                NEEDLESS_SPLITN,\n-                expr.span,\n-                message,\n-                \"try this\",\n-                format!(\n-                    \"{}.{}({})\",\n-                    snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0,\n-                    if reverse {\"rsplit\"} else {\"split\"},\n-                    snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0\n-                ),\n-                app,\n-            );\n-        }\n-    }\n-}\n-\n-fn check_iter<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    ctxt: SyntaxContext,\n-    mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n-    count: u128,\n-) -> bool {\n-    match iter.next() {\n-        Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n-            let (name, args) = if let ExprKind::MethodCall(name, [_, args @ ..], _) = e.kind {\n-                (name, args)\n-            } else {\n-                return false;\n-            };\n-            if_chain! {\n-                if let Some(did) = cx.typeck_results().type_dependent_def_id(e.hir_id);\n-                if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n-                then {\n-                    match (name.ident.as_str(), args) {\n-                        (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                            return true;\n-                        },\n-                        (\"next_tuple\", []) if count > 2 => {\n-                            return true;\n-                        },\n-                        (\"nth\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                            if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n-                                if count > idx + 1 {\n-                                    return true;\n-                                }\n-                            }\n-                        },\n-                        _ =>  return false,\n-                    }\n-                }\n-            }\n-        },\n-        _ => return false,\n-    };\n-    false\n-}"}, {"sha": "8ed8f3b3a0642f2bea6f9da9a5fd19c08ce850e0", "filename": "tests/ui/crashes/ice-8250.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fcrashes%2Fice-8250.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fcrashes%2Fice-8250.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-8250.stderr?ref=5344236715fafa2b8d27320839f44d0f4b5ca955", "patch": "@@ -1,11 +1,3 @@\n-error: manual implementation of `split_once`\n-  --> $DIR/ice-8250.rs:2:13\n-   |\n-LL |     let _ = s[1..].splitn(2, '.').next()?;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s[1..].split_once('.').map_or(s[1..], |x| x.0)`\n-   |\n-   = note: `-D clippy::manual-split-once` implied by `-D warnings`\n-\n error: unnecessary use of `splitn`\n   --> $DIR/ice-8250.rs:2:13\n    |\n@@ -14,5 +6,5 @@ LL |     let _ = s[1..].splitn(2, '.').next()?;\n    |\n    = note: `-D clippy::needless-splitn` implied by `-D warnings`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "bffc7b9b631b96513a9bf1d93e6f7a25a11a7ff0", "filename": "tests/ui/manual_split_once.fixed", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fmanual_split_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fmanual_split_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.fixed?ref=5344236715fafa2b8d27320839f44d0f4b5ca955", "patch": "@@ -2,46 +2,43 @@\n \n #![feature(custom_inner_attributes)]\n #![warn(clippy::manual_split_once)]\n-#![allow(clippy::iter_skip_next, clippy::iter_nth_zero, clippy::needless_splitn)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n \n extern crate itertools;\n \n #[allow(unused_imports)]\n use itertools::Itertools;\n \n fn main() {\n-    let _ = Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0));\n     let _ = \"key=value\".splitn(2, '=').nth(2);\n-    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n-    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n     let _ = \"key=value\".split_once('=').unwrap().1;\n     let _ = \"key=value\".split_once('=').unwrap().1;\n     let (_, _) = \"key=value\".split_once('=').unwrap();\n \n     let s = String::from(\"key=value\");\n-    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+    let _ = s.split_once('=').unwrap().1;\n \n     let s = Box::<str>::from(\"key=value\");\n-    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+    let _ = s.split_once('=').unwrap().1;\n \n     let s = &\"key=value\";\n-    let _ = s.split_once('=').map_or(*s, |x| x.0);\n+    let _ = s.split_once('=').unwrap().1;\n \n     fn _f(s: &str) -> Option<&str> {\n-        let _ = s.split_once(\"key=value\").map_or(s, |x| x.0);\n-        let _ = s.split_once(\"key=value\")?.1;\n-        let _ = s.split_once(\"key=value\")?.1;\n+        let _ = s.split_once('=')?.1;\n+        let _ = s.split_once('=')?.1;\n+        let _ = s.rsplit_once('=')?.0;\n+        let _ = s.rsplit_once('=')?.0;\n         None\n     }\n \n     // Don't lint, slices don't have `split_once`\n     let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n \n     // `rsplitn` gives the results in the reverse order of `rsplit_once`\n-    let _ = \"key=value\".rsplitn(2, '=').next().unwrap();\n     let _ = \"key=value\".rsplit_once('=').unwrap().0;\n-    let _ = \"key=value\".rsplit_once('=').map(|x| x.1);\n     let (_, _) = \"key=value\".rsplit_once('=').map(|(x, y)| (y, x)).unwrap();\n+    let _ = s.rsplit_once('=').map(|x| x.0);\n }\n \n fn _msrv_1_51() {"}, {"sha": "147be7c7ab1872daf2f8ead37021364b39a01a33", "filename": "tests/ui/manual_split_once.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.rs?ref=5344236715fafa2b8d27320839f44d0f4b5ca955", "patch": "@@ -2,46 +2,43 @@\n \n #![feature(custom_inner_attributes)]\n #![warn(clippy::manual_split_once)]\n-#![allow(clippy::iter_skip_next, clippy::iter_nth_zero, clippy::needless_splitn)]\n+#![allow(clippy::iter_skip_next, clippy::iter_nth_zero)]\n \n extern crate itertools;\n \n #[allow(unused_imports)]\n use itertools::Itertools;\n \n fn main() {\n-    let _ = \"key=value\".splitn(2, '=').next();\n     let _ = \"key=value\".splitn(2, '=').nth(2);\n-    let _ = \"key=value\".splitn(2, '=').next().unwrap();\n-    let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n     let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n     let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n \n     let s = String::from(\"key=value\");\n-    let _ = s.splitn(2, '=').next().unwrap();\n+    let _ = s.splitn(2, '=').nth(1).unwrap();\n \n     let s = Box::<str>::from(\"key=value\");\n-    let _ = s.splitn(2, '=').nth(0).unwrap();\n+    let _ = s.splitn(2, '=').nth(1).unwrap();\n \n     let s = &\"key=value\";\n-    let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+    let _ = s.splitn(2, '=').skip(1).next().unwrap();\n \n     fn _f(s: &str) -> Option<&str> {\n-        let _ = s.splitn(2, \"key=value\").next()?;\n-        let _ = s.splitn(2, \"key=value\").nth(1)?;\n-        let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+        let _ = s.splitn(2, '=').nth(1)?;\n+        let _ = s.splitn(2, '=').skip(1).next()?;\n+        let _ = s.rsplitn(2, '=').nth(1)?;\n+        let _ = s.rsplitn(2, '=').skip(1).next()?;\n         None\n     }\n \n     // Don't lint, slices don't have `split_once`\n     let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n \n     // `rsplitn` gives the results in the reverse order of `rsplit_once`\n-    let _ = \"key=value\".rsplitn(2, '=').next().unwrap();\n     let _ = \"key=value\".rsplitn(2, '=').nth(1).unwrap();\n-    let _ = \"key=value\".rsplitn(2, '=').nth(0);\n     let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n+    let _ = s.rsplitn(2, '=').nth(1);\n }\n \n fn _msrv_1_51() {"}, {"sha": "9635e6c5e4b46fd2e1b37ca4c9f253436a82c4e7", "filename": "tests/ui/manual_split_once.stderr", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fmanual_split_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fmanual_split_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.stderr?ref=5344236715fafa2b8d27320839f44d0f4b5ca955", "patch": "@@ -1,100 +1,88 @@\n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:13:13\n+  --> $DIR/manual_split_once.rs:14:13\n    |\n-LL |     let _ = \"key=value\".splitn(2, '=').next();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0))`\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n    |\n    = note: `-D clippy::manual-split-once` implied by `-D warnings`\n \n error: manual implementation of `split_once`\n   --> $DIR/manual_split_once.rs:15:13\n    |\n-LL |     let _ = \"key=value\".splitn(2, '=').next().unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n-\n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:16:13\n-   |\n-LL |     let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n-\n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:17:13\n-   |\n-LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n-\n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:18:13\n-   |\n LL |     let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n \n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:19:18\n+  --> $DIR/manual_split_once.rs:16:18\n    |\n LL |     let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=')`\n \n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:19:13\n+   |\n+LL |     let _ = s.splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').unwrap().1`\n+\n error: manual implementation of `split_once`\n   --> $DIR/manual_split_once.rs:22:13\n    |\n-LL |     let _ = s.splitn(2, '=').next().unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+LL |     let _ = s.splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').unwrap().1`\n \n error: manual implementation of `split_once`\n   --> $DIR/manual_split_once.rs:25:13\n    |\n-LL |     let _ = s.splitn(2, '=').nth(0).unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+LL |     let _ = s.splitn(2, '=').skip(1).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').unwrap().1`\n \n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:28:13\n+  --> $DIR/manual_split_once.rs:28:17\n    |\n-LL |     let _ = s.splitn(2, '=').skip(0).next().unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(*s, |x| x.0)`\n+LL |         let _ = s.splitn(2, '=').nth(1)?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=')?.1`\n \n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:31:17\n+  --> $DIR/manual_split_once.rs:29:17\n    |\n-LL |         let _ = s.splitn(2, \"key=value\").next()?;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\").map_or(s, |x| x.0)`\n+LL |         let _ = s.splitn(2, '=').skip(1).next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=')?.1`\n \n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:32:17\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:30:17\n    |\n-LL |         let _ = s.splitn(2, \"key=value\").nth(1)?;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+LL |         let _ = s.rsplitn(2, '=').nth(1)?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit_once('=')?.0`\n \n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:33:17\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:31:17\n    |\n-LL |         let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+LL |         let _ = s.rsplitn(2, '=').skip(1).next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit_once('=')?.0`\n \n error: manual implementation of `rsplit_once`\n-  --> $DIR/manual_split_once.rs:42:13\n+  --> $DIR/manual_split_once.rs:39:13\n    |\n LL |     let _ = \"key=value\".rsplitn(2, '=').nth(1).unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').unwrap().0`\n \n error: manual implementation of `rsplit_once`\n-  --> $DIR/manual_split_once.rs:43:13\n+  --> $DIR/manual_split_once.rs:40:18\n    |\n-LL |     let _ = \"key=value\".rsplitn(2, '=').nth(0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|x| x.1)`\n+LL |     let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|(x, y)| (y, x))`\n \n error: manual implementation of `rsplit_once`\n-  --> $DIR/manual_split_once.rs:44:18\n+  --> $DIR/manual_split_once.rs:41:13\n    |\n-LL |     let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|(x, y)| (y, x))`\n+LL |     let _ = s.rsplitn(2, '=').nth(1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit_once('=').map(|x| x.0)`\n \n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:55:13\n+  --> $DIR/manual_split_once.rs:52:13\n    |\n LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 14 previous errors\n "}, {"sha": "61f5fc4e679edafbb609cfa70dd550ff3df2e39e", "filename": "tests/ui/needless_splitn.fixed", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fneedless_splitn.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fneedless_splitn.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_splitn.fixed?ref=5344236715fafa2b8d27320839f44d0f4b5ca955", "patch": "@@ -24,4 +24,24 @@ fn main() {\n     let _ = str.rsplitn(2, '=').nth(1);\n     let (_, _) = str.rsplitn(2, '=').next_tuple().unwrap();\n     let (_, _) = str.rsplit('=').next_tuple().unwrap();\n+\n+    let _ = str.split('=').next();\n+    let _ = str.split('=').nth(3);\n+    let _ = str.splitn(5, '=').nth(4);\n+    let _ = str.splitn(5, '=').nth(5);\n+}\n+\n+fn _question_mark(s: &str) -> Option<()> {\n+    let _ = s.split('=').next()?;\n+    let _ = s.split('=').nth(0)?;\n+    let _ = s.rsplit('=').next()?;\n+    let _ = s.rsplit('=').nth(0)?;\n+\n+    Some(())\n+}\n+\n+fn _test_msrv() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `manual_split_once` MSRV shouldn't apply to `needless_splitn`\n+    let _ = \"key=value\".split('=').nth(0).unwrap();\n }"}, {"sha": "71d9a7077faa6f354e9475507b456d8e53e884e9", "filename": "tests/ui/needless_splitn.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fneedless_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fneedless_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_splitn.rs?ref=5344236715fafa2b8d27320839f44d0f4b5ca955", "patch": "@@ -24,4 +24,24 @@ fn main() {\n     let _ = str.rsplitn(2, '=').nth(1);\n     let (_, _) = str.rsplitn(2, '=').next_tuple().unwrap();\n     let (_, _) = str.rsplitn(3, '=').next_tuple().unwrap();\n+\n+    let _ = str.splitn(5, '=').next();\n+    let _ = str.splitn(5, '=').nth(3);\n+    let _ = str.splitn(5, '=').nth(4);\n+    let _ = str.splitn(5, '=').nth(5);\n+}\n+\n+fn _question_mark(s: &str) -> Option<()> {\n+    let _ = s.splitn(2, '=').next()?;\n+    let _ = s.splitn(2, '=').nth(0)?;\n+    let _ = s.rsplitn(2, '=').next()?;\n+    let _ = s.rsplitn(2, '=').nth(0)?;\n+\n+    Some(())\n+}\n+\n+fn _test_msrv() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `manual_split_once` MSRV shouldn't apply to `needless_splitn`\n+    let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n }"}, {"sha": "f112b29e7f2066ccb0751f049d479b45d5a79c58", "filename": "tests/ui/needless_splitn.stderr", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fneedless_splitn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5344236715fafa2b8d27320839f44d0f4b5ca955/tests%2Fui%2Fneedless_splitn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_splitn.stderr?ref=5344236715fafa2b8d27320839f44d0f4b5ca955", "patch": "@@ -36,5 +36,47 @@ error: unnecessary use of `rsplitn`\n LL |     let (_, _) = str.rsplitn(3, '=').next_tuple().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^ help: try this: `str.rsplit('=')`\n \n-error: aborting due to 6 previous errors\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:28:13\n+   |\n+LL |     let _ = str.splitn(5, '=').next();\n+   |             ^^^^^^^^^^^^^^^^^^ help: try this: `str.split('=')`\n+\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:29:13\n+   |\n+LL |     let _ = str.splitn(5, '=').nth(3);\n+   |             ^^^^^^^^^^^^^^^^^^ help: try this: `str.split('=')`\n+\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:35:13\n+   |\n+LL |     let _ = s.splitn(2, '=').next()?;\n+   |             ^^^^^^^^^^^^^^^^ help: try this: `s.split('=')`\n+\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:36:13\n+   |\n+LL |     let _ = s.splitn(2, '=').nth(0)?;\n+   |             ^^^^^^^^^^^^^^^^ help: try this: `s.split('=')`\n+\n+error: unnecessary use of `rsplitn`\n+  --> $DIR/needless_splitn.rs:37:13\n+   |\n+LL |     let _ = s.rsplitn(2, '=').next()?;\n+   |             ^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit('=')`\n+\n+error: unnecessary use of `rsplitn`\n+  --> $DIR/needless_splitn.rs:38:13\n+   |\n+LL |     let _ = s.rsplitn(2, '=').nth(0)?;\n+   |             ^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit('=')`\n+\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:46:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split('=')`\n+\n+error: aborting due to 13 previous errors\n "}]}