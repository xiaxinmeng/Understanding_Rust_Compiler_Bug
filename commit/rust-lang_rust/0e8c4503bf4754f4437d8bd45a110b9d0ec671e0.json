{"sha": "0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOGM0NTAzYmY0NzU0ZjQ0MzdkOGJkNDVhMTEwYjlkMGVjNjcxZTA=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-01T19:45:44Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-04-01T19:45:44Z"}, "message": "Don't recheck obligations if we have learned nothing new\n\nThis is just the most trivial check: If no inference variables have been\nupdated, and there are no new obligations, we can just skip trying to\nsolve them again. We could be smarter about it, but this already helps\nquite a bit, and I don't want to touch this too much before we replace\nthe inference table by Chalk's.\n\nFixes #8263 (well, improves it quite a bit).", "tree": {"sha": "0d09bc856ae7b8d5acc2dcc45226ea358dfa6412", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d09bc856ae7b8d5acc2dcc45226ea358dfa6412"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "html_url": "https://github.com/rust-lang/rust/commit/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25201b2dad7b4b0d41494e238ebf643ad7ad8cd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/25201b2dad7b4b0d41494e238ebf643ad7ad8cd6", "html_url": "https://github.com/rust-lang/rust/commit/25201b2dad7b4b0d41494e238ebf643ad7ad8cd6"}], "stats": {"total": 34, "additions": 26, "deletions": 8}, "files": [{"sha": "497a1beb7dc795082555a253eb9aeb917c75186b", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "patch": "@@ -210,6 +210,7 @@ struct InferenceContext<'a> {\n     table: unify::InferenceTable,\n     trait_env: Arc<TraitEnvironment>,\n     obligations: Vec<DomainGoal>,\n+    last_obligations_check: Option<u32>,\n     result: InferenceResult,\n     /// The return type of the function being inferred, or the closure if we're\n     /// currently within one.\n@@ -245,6 +246,7 @@ impl<'a> InferenceContext<'a> {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(),\n             obligations: Vec::default(),\n+            last_obligations_check: None,\n             return_ty: TyKind::Unknown.intern(&Interner), // set in collect_fn_signature\n             trait_env: owner\n                 .as_generic_def_id()\n@@ -334,6 +336,11 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_obligations_as_possible(&mut self) {\n+        if self.last_obligations_check == Some(self.table.revision) {\n+            // no change\n+            return;\n+        }\n+        self.last_obligations_check = Some(self.table.revision);\n         let obligations = mem::replace(&mut self.obligations, Vec::new());\n         for obligation in obligations {\n             let in_env = InEnvironment::new(self.trait_env.env.clone(), obligation.clone());\n@@ -360,6 +367,11 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    fn push_obligation(&mut self, o: DomainGoal) {\n+        self.obligations.push(o);\n+        self.last_obligations_check = None;\n+    }\n+\n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n         self.table.unify(ty1, ty2)\n     }\n@@ -408,8 +420,8 @@ impl<'a> InferenceContext<'a> {\n                     }),\n                     ty: ty.clone(),\n                 };\n-                self.obligations.push(trait_ref.cast(&Interner));\n-                self.obligations.push(alias_eq.cast(&Interner));\n+                self.push_obligation(trait_ref.cast(&Interner));\n+                self.push_obligation(alias_eq.cast(&Interner));\n                 self.resolve_ty_as_possible(ty)\n             }\n             None => self.err_ty(),\n@@ -436,7 +448,7 @@ impl<'a> InferenceContext<'a> {\n         let var = self.table.new_type_var();\n         let alias_eq = AliasEq { alias: AliasTy::Projection(proj_ty), ty: var.clone() };\n         let obligation = alias_eq.cast(&Interner);\n-        self.obligations.push(obligation);\n+        self.push_obligation(obligation);\n         var\n     }\n "}, {"sha": "25ab3ea4c1a623242c216615527b5b7b3993e1ca", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "patch": "@@ -99,7 +99,7 @@ impl<'a> InferenceContext<'a> {\n             environment: trait_env,\n         });\n         if self.db.trait_solve(krate, goal.value).is_some() {\n-            self.obligations.push(implements_fn_trait);\n+            self.push_obligation(implements_fn_trait);\n             let output_proj_ty = crate::ProjectionTy {\n                 associated_ty_id: to_assoc_type_id(output_assoc_type),\n                 substitution: substs,\n@@ -964,7 +964,7 @@ impl<'a> InferenceContext<'a> {\n                 let (predicate, binders) =\n                     predicate.clone().subst(parameters).into_value_and_skipped_binders();\n                 always!(binders == 0); // quantified where clauses not yet handled\n-                self.obligations.push(predicate.cast(&Interner));\n+                self.push_obligation(predicate.cast(&Interner));\n             }\n             // add obligation for trait implementation, if this is a trait method\n             match def {\n@@ -974,7 +974,7 @@ impl<'a> InferenceContext<'a> {\n                         // construct a TraitRef\n                         let substs =\n                             parameters.prefix(generics(self.db.upcast(), trait_.into()).len());\n-                        self.obligations.push(\n+                        self.push_obligation(\n                             TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs }\n                                 .cast(&Interner),\n                         );"}, {"sha": "717738789b9612f5c54c5de95417a06e3524088b", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "patch": "@@ -258,7 +258,7 @@ impl<'a> InferenceContext<'a> {\n                             .push(ty.clone())\n                             .fill(std::iter::repeat_with(|| self.table.new_type_var()))\n                             .build();\n-                        self.obligations.push(\n+                        self.push_obligation(\n                             TraitRef {\n                                 trait_id: to_chalk_trait_id(trait_),\n                                 substitution: trait_substs.clone(),"}, {"sha": "5ea4b7481ecfe645eb9b38dd100b041cc8a64d33", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e8c4503bf4754f4437d8bd45a110b9d0ec671e0/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=0e8c4503bf4754f4437d8bd45a110b9d0ec671e0", "patch": "@@ -231,13 +231,15 @@ pub(crate) struct TypeVariableData {\n pub(crate) struct InferenceTable {\n     pub(super) var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     pub(super) type_variable_table: TypeVariableTable,\n+    pub(super) revision: u32,\n }\n \n impl InferenceTable {\n     pub(crate) fn new() -> Self {\n         InferenceTable {\n             var_unification_table: InPlaceUnificationTable::new(),\n             type_variable_table: TypeVariableTable { inner: Vec::new() },\n+            revision: 0,\n         }\n     }\n \n@@ -360,7 +362,10 @@ impl InferenceTable {\n                 == self.type_variable_table.is_diverging(*tv2) =>\n             {\n                 // both type vars are unknown since we tried to resolve them\n-                self.var_unification_table.union(tv1.to_inner(), tv2.to_inner());\n+                if !self.var_unification_table.unioned(tv1.to_inner(), tv2.to_inner()) {\n+                    self.var_unification_table.union(tv1.to_inner(), tv2.to_inner());\n+                    self.revision += 1;\n+                }\n                 true\n             }\n \n@@ -398,6 +403,7 @@ impl InferenceTable {\n                     tv.to_inner(),\n                     TypeVarValue::Known(other.clone().intern(&Interner)),\n                 );\n+                self.revision += 1;\n                 true\n             }\n "}]}