{"sha": "a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "node_id": "C_kwDOAAsO6NoAKGEyMmNmMmFmMDUxMGIzZWM0Y2JiMTljM2RlMTFkM2Q4MjkxMzQ5ZDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-05T02:21:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-05T02:21:13Z"}, "message": "Auto merge of #95662 - Dylan-DPC:rollup-fo7jsr6, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #91873 (Mention implementers of unsatisfied trait)\n - #95588 (explicitly distinguish pointer::addr and pointer::expose_addr)\n - #95603 (Fix late-bound ICE in `dyn` return type suggestion)\n - #95620 (interpret: remove MemoryExtra in favor of giving access to the Machine)\n - #95630 (Update `NonNull` pointer provenance methods' documentation)\n - #95631 (Refactor: remove unnecessary nested blocks)\n - #95642 (`CandidateSource::XCandidate` -> `CandidateSource::X`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f25421eaab99b5865f839a5315b36a834c632c74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f25421eaab99b5865f839a5315b36a834c632c74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "html_url": "https://github.com/rust-lang/rust/commit/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60e50fc1cfe0bb693a5f4f93eb83ef70854531e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/60e50fc1cfe0bb693a5f4f93eb83ef70854531e3", "html_url": "https://github.com/rust-lang/rust/commit/60e50fc1cfe0bb693a5f4f93eb83ef70854531e3"}, {"sha": "b3c3eda7284b33e772f9ffe4e2ac1ebd18241601", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601", "html_url": "https://github.com/rust-lang/rust/commit/b3c3eda7284b33e772f9ffe4e2ac1ebd18241601"}], "stats": {"total": 2646, "additions": 1951, "deletions": 695}, "files": [{"sha": "b81a4bfe149dc3e03507e41ea53df7f44ef8a72e", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -1,4 +1,4 @@\n-use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr, MemoryExtra};\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n@@ -100,8 +100,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n         tcx,\n         root_span,\n         param_env,\n-        CompileTimeInterpreter::new(tcx.const_eval_limit()),\n-        MemoryExtra { can_access_statics },\n+        CompileTimeInterpreter::new(tcx.const_eval_limit(), can_access_statics),\n     )\n }\n \n@@ -285,10 +284,9 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         tcx,\n         tcx.def_span(def.did),\n         key.param_env,\n-        CompileTimeInterpreter::new(tcx.const_eval_limit()),\n         // Statics (and promoteds inside statics) may access other statics, because unlike consts\n         // they do not have to behave \"as if\" they were evaluated at runtime.\n-        MemoryExtra { can_access_statics: is_static },\n+        CompileTimeInterpreter::new(tcx.const_eval_limit(), /*can_access_statics:*/ is_static),\n     );\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);"}, {"sha": "5aae4a90960048f7f15796378ee03d29ae39f530", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -93,10 +93,7 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'mir, 'tcx, AllocId, ()>>,\n-}\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct MemoryExtra {\n     /// We need to make sure consts never point to anything mutable, even recursively. That is\n     /// relied on for pattern matching on consts with references.\n     /// To achieve this, two pieces have to work together:\n@@ -107,8 +104,12 @@ pub struct MemoryExtra {\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    pub(super) fn new(const_eval_limit: Limit) -> Self {\n-        CompileTimeInterpreter { steps_remaining: const_eval_limit.0, stack: Vec::new() }\n+    pub(super) fn new(const_eval_limit: Limit, can_access_statics: bool) -> Self {\n+        CompileTimeInterpreter {\n+            steps_remaining: const_eval_limit.0,\n+            stack: Vec::new(),\n+            can_access_statics,\n+        }\n     }\n }\n \n@@ -233,8 +234,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     type MemoryKind = MemoryKind;\n \n-    type MemoryExtra = MemoryExtra;\n-\n     const PANIC_ON_ALLOC_FAIL: bool = false; // will be raised as a proper error\n \n     fn load_mir(\n@@ -345,7 +344,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     Err(err) => throw_ub_format!(\"align has to be a power of 2, {}\", err),\n                 };\n \n-                let ptr = ecx.memory.allocate(\n+                let ptr = ecx.allocate_ptr(\n                     Size::from_bytes(size as u64),\n                     align,\n                     interpret::MemoryKind::Machine(MemoryKind::Heap),\n@@ -365,14 +364,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n                 // If an allocation is created in an another const,\n                 // we don't deallocate it.\n-                let (alloc_id, _, _) = ecx.memory.ptr_get_alloc(ptr)?;\n+                let (alloc_id, _, _) = ecx.ptr_get_alloc_id(ptr)?;\n                 let is_allocated_in_another_const = matches!(\n                     ecx.tcx.get_global_alloc(alloc_id),\n                     Some(interpret::GlobalAlloc::Memory(_))\n                 );\n \n                 if !is_allocated_in_another_const {\n-                    ecx.memory.deallocate(\n+                    ecx.deallocate_ptr(\n                         ptr,\n                         Some((size, align)),\n                         interpret::MemoryKind::Machine(MemoryKind::Heap),\n@@ -472,7 +471,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn before_access_global(\n-        memory_extra: &MemoryExtra,\n+        machine: &Self,\n         alloc_id: AllocId,\n         alloc: ConstAllocation<'tcx>,\n         static_def_id: Option<DefId>,\n@@ -488,7 +487,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             }\n         } else {\n             // Read access. These are usually allowed, with some exceptions.\n-            if memory_extra.can_access_statics {\n+            if machine.can_access_statics {\n                 // Machine configuration allows us read from anything (e.g., `static` initializer).\n                 Ok(())\n             } else if static_def_id.is_some() {"}, {"sha": "a244b79ed075406498e591469536ebb92f704b77", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         )\n                         .ok_or_else(|| err_inval!(TooGeneric))?;\n \n-                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n+                        let fn_ptr = self.create_fn_alloc_ptr(FnVal::Instance(instance));\n                         self.write_pointer(fn_ptr, dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"reify fn pointer on {:?}\", src.layout.ty),\n@@ -87,7 +87,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             substs,\n                             ty::ClosureKind::FnOnce,\n                         );\n-                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n+                        let fn_ptr = self.create_fn_alloc_ptr(FnVal::Instance(instance));\n                         self.write_pointer(fn_ptr, dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"closure fn pointer on {:?}\", src.layout.ty),\n@@ -153,8 +153,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok(**src);\n             } else {\n                 // Casting the metadata away from a fat ptr.\n-                assert_eq!(src.layout.size, 2 * self.memory.pointer_size());\n-                assert_eq!(dest_layout.size, self.memory.pointer_size());\n+                assert_eq!(src.layout.size, 2 * self.pointer_size());\n+                assert_eq!(dest_layout.size, self.pointer_size());\n                 assert!(src.layout.ty.is_unsafe_ptr());\n                 return match **src {\n                     Immediate::ScalarPair(data, _) => Ok(data.into()),"}, {"sha": "a2ea0f516bfa4dccda68c163bd66b9048d667d1d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 52, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -22,9 +22,9 @@ use rustc_span::{Pos, Span};\n use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n-    AllocCheck, AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine,\n-    MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer,\n-    PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit, StackPopJump,\n+    AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemPlace,\n+    MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n+    Scalar, ScalarMaybeUninit, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n \n@@ -413,13 +413,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         root_span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n-        memory_extra: M::MemoryExtra,\n     ) -> Self {\n         InterpCx {\n             machine,\n             tcx: tcx.at(root_span),\n             param_env,\n-            memory: Memory::new(tcx, memory_extra),\n+            memory: Memory::new(),\n             recursion_limit: tcx.recursion_limit(),\n         }\n     }\n@@ -433,49 +432,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .map_or(self.tcx.span, |f| f.current_span())\n     }\n \n-    #[inline(always)]\n-    pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n-        self.memory.scalar_to_ptr(scalar)\n-    }\n-\n-    /// Test if this value might be null.\n-    /// If the machine does not support ptr-to-int casts, this is conservative.\n-    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> bool {\n-        match scalar.try_to_int() {\n-            Ok(int) => int.is_null(),\n-            Err(_) => {\n-                // Can only happen during CTFE.\n-                let ptr = self.scalar_to_ptr(scalar);\n-                match self.memory.ptr_try_get_alloc(ptr) {\n-                    Ok((alloc_id, offset, _)) => {\n-                        let (size, _align) = self\n-                            .memory\n-                            .get_size_and_align(alloc_id, AllocCheck::MaybeDead)\n-                            .expect(\"alloc info with MaybeDead cannot fail\");\n-                        // If the pointer is out-of-bounds, it may be null.\n-                        // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n-                        offset > size\n-                    }\n-                    Err(_offset) => bug!(\"a non-int scalar is always a pointer\"),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n-    /// the machine pointer to the allocation.  Must never be used\n-    /// for any other pointers, nor for TLS statics.\n-    ///\n-    /// Using the resulting pointer represents a *direct* access to that memory\n-    /// (e.g. by directly using a `static`),\n-    /// as opposed to access through a pointer that was created by the program.\n-    ///\n-    /// This function can fail only if `ptr` points to an `extern static`.\n-    #[inline(always)]\n-    pub fn global_base_pointer(&self, ptr: Pointer) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        self.memory.global_base_pointer(ptr)\n-    }\n-\n     #[inline(always)]\n     pub(crate) fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n         M::stack(self)\n@@ -949,9 +905,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             trace!(\n                 \"deallocating local {:?}: {:?}\",\n                 local,\n-                self.memory.dump_alloc(ptr.provenance.unwrap().get_alloc_id())\n+                self.dump_alloc(ptr.provenance.unwrap().get_alloc_id())\n             );\n-            self.memory.deallocate(ptr, None, MemoryKind::Stack)?;\n+            self.deallocate_ptr(ptr, None, MemoryKind::Stack)?;\n         };\n         Ok(())\n     }\n@@ -1057,15 +1013,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                     }\n                 }\n \n-                write!(fmt, \": {:?}\", self.ecx.memory.dump_allocs(allocs))\n+                write!(fmt, \": {:?}\", self.ecx.dump_allocs(allocs))\n             }\n             Place::Ptr(mplace) => match mplace.ptr.provenance.map(Provenance::get_alloc_id) {\n                 Some(alloc_id) => write!(\n                     fmt,\n                     \"by align({}) ref {:?}: {:?}\",\n                     mplace.align.bytes(),\n                     mplace.ptr,\n-                    self.ecx.memory.dump_alloc(alloc_id)\n+                    self.ecx.dump_alloc(alloc_id)\n                 ),\n                 ptr => write!(fmt, \" integral by ref: {:?}\", ptr),\n             },"}, {"sha": "a956a478cef9ee63e6240694d5c2c701f8bfb230", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -318,7 +318,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // exception from the exception.)\n                 // This is the dual to the special exception for offset-by-0\n                 // in the inbounds pointer offset operation (see `ptr_offset_inbounds` below).\n-                match (self.memory.ptr_try_get_alloc(a), self.memory.ptr_try_get_alloc(b)) {\n+                match (self.ptr_try_get_alloc_id(a), self.ptr_try_get_alloc_id(b)) {\n                     (Err(a), Err(b)) if a == b && a != 0 => {\n                         // Both are the same non-null integer.\n                         self.write_scalar(Scalar::from_machine_isize(0, self), dest)?;\n@@ -335,13 +335,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             );\n                         }\n                         // And they must both be valid for zero-sized accesses (\"in-bounds or one past the end\").\n-                        self.memory.check_ptr_access_align(\n+                        self.check_ptr_access_align(\n                             a,\n                             Size::ZERO,\n                             Align::ONE,\n                             CheckInAllocMsg::OffsetFromTest,\n                         )?;\n-                        self.memory.check_ptr_access_align(\n+                        self.check_ptr_access_align(\n                             b,\n                             Size::ZERO,\n                             Align::ONE,\n@@ -545,7 +545,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let min_ptr = if offset_bytes >= 0 { ptr } else { offset_ptr };\n         let size = offset_bytes.unsigned_abs();\n         // This call handles checking for integer/null pointers.\n-        self.memory.check_ptr_access_align(\n+        self.check_ptr_access_align(\n             min_ptr,\n             Size::from_bytes(size),\n             Align::ONE,\n@@ -577,7 +577,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let src = self.read_pointer(&src)?;\n         let dst = self.read_pointer(&dst)?;\n \n-        self.memory.copy(src, align, dst, align, size, nonoverlapping)\n+        self.mem_copy(src, align, dst, align, size, nonoverlapping)\n     }\n \n     pub(crate) fn write_bytes_intrinsic(\n@@ -600,7 +600,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .ok_or_else(|| err_ub_format!(\"overflow computing total size of `write_bytes`\"))?;\n \n         let bytes = std::iter::repeat(byte).take(len.bytes_usize());\n-        self.memory.write_bytes(dst, bytes)\n+        self.write_bytes_ptr(dst, bytes)\n     }\n \n     pub(crate) fn raw_eq_intrinsic(\n@@ -613,8 +613,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let lhs = self.read_pointer(lhs)?;\n         let rhs = self.read_pointer(rhs)?;\n-        let lhs_bytes = self.memory.read_bytes(lhs, layout.size)?;\n-        let rhs_bytes = self.memory.read_bytes(rhs, layout.size)?;\n+        let lhs_bytes = self.read_bytes_ptr(lhs, layout.size)?;\n+        let rhs_bytes = self.read_bytes_ptr(rhs, layout.size)?;\n         Ok(Scalar::from_bool(lhs_bytes == rhs_bytes))\n     }\n }"}, {"sha": "39aec33819ce8411b1c9db9560296a343ea23fc1", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -14,7 +14,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar,\n+    LocalValue, MemPlace, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar,\n     StackPopUnwind,\n };\n \n@@ -96,11 +96,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Extra data stored in every call frame.\n     type FrameExtra;\n \n-    /// Extra data stored in memory. A reference to this is available when `AllocExtra`\n-    /// gets initialized, so you can e.g., have an `Rc` here if there is global state you\n-    /// need access to in the `AllocExtra` hooks.\n-    type MemoryExtra;\n-\n     /// Extra data stored in every allocation.\n     type AllocExtra: Debug + Clone + 'static;\n \n@@ -123,11 +118,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     const PANIC_ON_ALLOC_FAIL: bool;\n \n     /// Whether memory accesses should be alignment-checked.\n-    fn enforce_alignment(memory_extra: &Self::MemoryExtra) -> bool;\n+    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Whether, when checking alignment, we should `force_int` and thus support\n     /// custom alignment logic based on whatever the integer address happens to be.\n-    fn force_int_for_alignment_check(memory_extra: &Self::MemoryExtra) -> bool;\n+    fn force_int_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n@@ -251,7 +246,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// `def_id` is `Some` if this is the \"lazy\" allocation of a static.\n     #[inline]\n     fn before_access_global(\n-        _memory_extra: &Self::MemoryExtra,\n+        _machine: &Self,\n         _alloc_id: AllocId,\n         _allocation: ConstAllocation<'tcx>,\n         _static_def_id: Option<DefId>,\n@@ -270,7 +265,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n \n     /// Return the root pointer for the given `extern static`.\n     fn extern_static_base_pointer(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         def_id: DefId,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>>;\n \n@@ -279,19 +274,19 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ///\n     /// Not called on `extern` or thread-local statics (those use the methods above).\n     fn tag_alloc_base_pointer(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer,\n     ) -> Pointer<Self::PointerTag>;\n \n     /// \"Int-to-pointer cast\"\n     fn ptr_from_addr(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         addr: u64,\n     ) -> Pointer<Option<Self::PointerTag>>;\n \n     /// Convert a pointer with provenance into an allocation-offset pair.\n     fn ptr_get_alloc(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer<Self::PointerTag>,\n     ) -> (AllocId, Size);\n \n@@ -309,7 +304,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n     fn init_allocation_extra<'b>(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n@@ -322,7 +317,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// need to mutate.\n     #[inline(always)]\n     fn memory_read(\n-        _memory_extra: &Self::MemoryExtra,\n+        _machine: &Self,\n         _alloc_extra: &Self::AllocExtra,\n         _tag: Self::PointerTag,\n         _range: AllocRange,\n@@ -333,7 +328,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Hook for performing extra checks on a memory write access.\n     #[inline(always)]\n     fn memory_written(\n-        _memory_extra: &mut Self::MemoryExtra,\n+        _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n         _tag: Self::PointerTag,\n         _range: AllocRange,\n@@ -344,7 +339,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Hook for performing extra operations on a memory deallocation.\n     #[inline(always)]\n     fn memory_deallocated(\n-        _memory_extra: &mut Self::MemoryExtra,\n+        _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n         _tag: Self::PointerTag,\n         _range: AllocRange,\n@@ -408,14 +403,14 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type FrameExtra = ();\n \n     #[inline(always)]\n-    fn enforce_alignment(_memory_extra: &Self::MemoryExtra) -> bool {\n+    fn enforce_alignment(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n         // We do not check for alignment to avoid having to carry an `Align`\n         // in `ConstValue::ByRef`.\n         false\n     }\n \n     #[inline(always)]\n-    fn force_int_for_alignment_check(_memory_extra: &Self::MemoryExtra) -> bool {\n+    fn force_int_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n         // We do not support `force_int`.\n         false\n     }\n@@ -444,7 +439,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n \n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n-        _mem: &Memory<$mir, $tcx, Self>,\n+        _ecx: &InterpCx<$mir, $tcx, Self>,\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<Self::MemoryKind>>,\n@@ -454,28 +449,28 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     }\n \n     fn extern_static_base_pointer(\n-        mem: &Memory<$mir, $tcx, Self>,\n+        ecx: &InterpCx<$mir, $tcx, Self>,\n         def_id: DefId,\n     ) -> InterpResult<$tcx, Pointer> {\n         // Use the `AllocId` associated with the `DefId`. Any actual *access* will fail.\n-        Ok(Pointer::new(mem.tcx.create_static_alloc(def_id), Size::ZERO))\n+        Ok(Pointer::new(ecx.tcx.create_static_alloc(def_id), Size::ZERO))\n     }\n \n     #[inline(always)]\n     fn tag_alloc_base_pointer(\n-        _mem: &Memory<$mir, $tcx, Self>,\n+        _ecx: &InterpCx<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n     ) -> Pointer<AllocId> {\n         ptr\n     }\n \n     #[inline(always)]\n-    fn ptr_from_addr(_mem: &Memory<$mir, $tcx, Self>, addr: u64) -> Pointer<Option<AllocId>> {\n+    fn ptr_from_addr(_ecx: &InterpCx<$mir, $tcx, Self>, addr: u64) -> Pointer<Option<AllocId>> {\n         Pointer::new(None, Size::from_bytes(addr))\n     }\n \n     #[inline(always)]\n-    fn ptr_get_alloc(_mem: &Memory<$mir, $tcx, Self>, ptr: Pointer<AllocId>) -> (AllocId, Size) {\n+    fn ptr_get_alloc(_ecx: &InterpCx<$mir, $tcx, Self>, ptr: Pointer<AllocId>) -> (AllocId, Size) {\n         // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n         (alloc_id, offset)"}, {"sha": "fcfcd5d8989f5706523c81cc750b25f2412d57d9", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 116, "deletions": 105, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -17,10 +17,10 @@ use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::mir::display_allocation;\n use rustc_middle::ty::{Instance, ParamEnv, TyCtxt};\n-use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n-    alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc,\n+    alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n     InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n     ScalarMaybeUninit,\n };\n@@ -108,19 +108,6 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// that do not exist any more.\n     // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n-\n-    /// Extra data added by the machine.\n-    pub extra: M::MemoryExtra,\n-\n-    /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n-    #[inline]\n-    fn data_layout(&self) -> &TargetDataLayout {\n-        &self.tcx.data_layout\n-    }\n }\n \n /// A reference to some allocation that was already bounds-checked for the given region\n@@ -142,16 +129,21 @@ pub struct AllocRefMut<'a, 'tcx, Tag, Extra> {\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxt<'tcx>, extra: M::MemoryExtra) -> Self {\n+    pub fn new() -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n             extra_fn_ptr_map: FxHashMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n-            extra,\n-            tcx,\n         }\n     }\n \n+    /// This is used by [priroda](https://github.com/oli-obk/priroda)\n+    pub fn alloc_map(&self) -> &M::MemoryMap {\n+        &self.alloc_map\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n     /// the machine pointer to the allocation.  Must never be used\n     /// for any other pointers, nor for TLS statics.\n@@ -182,7 +174,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(M::tag_alloc_base_pointer(self, Pointer::new(alloc_id, offset)))\n     }\n \n-    pub fn create_fn_alloc(\n+    pub fn create_fn_alloc_ptr(\n         &mut self,\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n     ) -> Pointer<M::PointerTag> {\n@@ -191,7 +183,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             FnVal::Other(extra) => {\n                 // FIXME(RalfJung): Should we have a cache here?\n                 let id = self.tcx.reserve_alloc_id();\n-                let old = self.extra_fn_ptr_map.insert(id, extra);\n+                let old = self.memory.extra_fn_ptr_map.insert(id, extra);\n                 assert!(old.is_none());\n                 id\n             }\n@@ -201,28 +193,28 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.global_base_pointer(Pointer::from(id)).unwrap()\n     }\n \n-    pub fn allocate(\n+    pub fn allocate_ptr(\n         &mut self,\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'static, Pointer<M::PointerTag>> {\n         let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n-        Ok(self.allocate_with(alloc, kind))\n+        Ok(self.allocate_raw_ptr(alloc, kind))\n     }\n \n-    pub fn allocate_bytes(\n+    pub fn allocate_bytes_ptr(\n         &mut self,\n         bytes: &[u8],\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n         mutability: Mutability,\n     ) -> Pointer<M::PointerTag> {\n         let alloc = Allocation::from_bytes(bytes, align, mutability);\n-        self.allocate_with(alloc, kind)\n+        self.allocate_raw_ptr(alloc, kind)\n     }\n \n-    pub fn allocate_with(\n+    pub fn allocate_raw_ptr(\n         &mut self,\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKind>,\n@@ -234,19 +226,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             \"dynamically allocating global memory\"\n         );\n         let alloc = M::init_allocation_extra(self, id, Cow::Owned(alloc), Some(kind));\n-        self.alloc_map.insert(id, (kind, alloc.into_owned()));\n+        self.memory.alloc_map.insert(id, (kind, alloc.into_owned()));\n         M::tag_alloc_base_pointer(self, Pointer::from(id))\n     }\n \n-    pub fn reallocate(\n+    pub fn reallocate_ptr(\n         &mut self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         old_size_and_align: Option<(Size, Align)>,\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"reallocating {:?} which does not point to the beginning of an object\",\n@@ -256,33 +248,33 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n         // This happens so rarely, the perf advantage is outweighed by the maintenance cost.\n-        let new_ptr = self.allocate(new_size, new_align, kind)?;\n+        let new_ptr = self.allocate_ptr(new_size, new_align, kind)?;\n         let old_size = match old_size_and_align {\n             Some((size, _align)) => size,\n-            None => self.get_raw(alloc_id)?.size(),\n+            None => self.get_alloc_raw(alloc_id)?.size(),\n         };\n         // This will also call the access hooks.\n-        self.copy(\n+        self.mem_copy(\n             ptr.into(),\n             Align::ONE,\n             new_ptr.into(),\n             Align::ONE,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n         )?;\n-        self.deallocate(ptr.into(), old_size_and_align, kind)?;\n+        self.deallocate_ptr(ptr.into(), old_size_and_align, kind)?;\n \n         Ok(new_ptr)\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn deallocate(\n+    pub fn deallocate_ptr(\n         &mut self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n         trace!(\"deallocating: {}\", alloc_id);\n \n         if offset.bytes() != 0 {\n@@ -292,7 +284,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             );\n         }\n \n-        let Some((alloc_kind, mut alloc)) = self.alloc_map.remove(&alloc_id) else {\n+        let Some((alloc_kind, mut alloc)) = self.memory.alloc_map.remove(&alloc_id) else {\n             // Deallocating global memory -- always an error\n             return Err(match self.tcx.get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Function(..)) => {\n@@ -335,14 +327,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // Let the machine take some extra action\n         let size = alloc.size();\n         M::memory_deallocated(\n-            &mut self.extra,\n+            &mut self.machine,\n             &mut alloc.extra,\n             ptr.provenance,\n             alloc_range(Size::ZERO, size),\n         )?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n-        let old = self.dead_alloc_map.insert(alloc_id, (size, alloc.align));\n+        let old = self.memory.dead_alloc_map.insert(alloc_id, (size, alloc.align));\n         if old.is_some() {\n             bug!(\"Nothing can be deallocated twice\");\n         }\n@@ -358,15 +350,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<(AllocId, Size, Pointer<M::PointerTag>)>> {\n-        let align = M::enforce_alignment(&self.extra).then_some(align);\n+        let align = M::enforce_alignment(&self).then_some(align);\n         self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n             |alloc_id, offset, ptr| {\n                 let (size, align) =\n-                    self.get_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n+                    self.get_alloc_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n                 Ok((size, align, (alloc_id, offset, ptr)))\n             },\n         )\n@@ -392,7 +384,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 | CheckInAllocMsg::OffsetFromTest\n                 | CheckInAllocMsg::InboundsTest => AllocCheck::Live,\n             };\n-            let (size, align) = self.get_size_and_align(alloc_id, check)?;\n+            let (size, align) = self.get_alloc_size_and_align(alloc_id, check)?;\n             Ok((size, align, ()))\n         })?;\n         Ok(())\n@@ -427,7 +419,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n         }\n \n-        Ok(match self.ptr_try_get_alloc(ptr) {\n+        Ok(match self.ptr_try_get_alloc_id(ptr) {\n             Err(addr) => {\n                 // We couldn't get a proper allocation. This is only okay if the access size is 0,\n                 // and the address is not null.\n@@ -456,7 +448,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n-                    if M::force_int_for_alignment_check(&self.extra) {\n+                    if M::force_int_for_alignment_check(self) {\n                         let addr = Scalar::from_pointer(ptr, &self.tcx)\n                             .to_machine_usize(&self.tcx)\n                             .expect(\"ptr-to-int cast for align check should never fail\");\n@@ -479,7 +471,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n }\n \n /// Allocation accessors\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Helper function to obtain a global (tcx) allocation.\n     /// This attempts to return a reference to an existing allocation if\n     /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n@@ -517,7 +509,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 (self.tcx.eval_static_initializer(def_id)?, Some(def_id))\n             }\n         };\n-        M::before_access_global(&self.extra, id, alloc, def_id, is_write)?;\n+        M::before_access_global(&self.machine, id, alloc, def_id, is_write)?;\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n         let alloc = M::init_allocation_extra(\n             self,\n@@ -530,15 +522,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n-    fn get_raw(\n+    fn get_alloc_raw(\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n-        let a = self.alloc_map.get_or(id, || {\n+        let a = self.memory.alloc_map.get_or(id, || {\n             let alloc = self.get_global_alloc(id, /*is_write*/ false).map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n@@ -564,27 +556,27 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     /// \"Safe\" (bounds and align-checked) allocation access.\n-    pub fn get<'a>(\n+    pub fn get_ptr_alloc<'a>(\n         &'a self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n-        let align = M::enforce_alignment(&self.extra).then_some(align);\n+        let align = M::enforce_alignment(self).then_some(align);\n         let ptr_and_alloc = self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n             |alloc_id, offset, ptr| {\n-                let alloc = self.get_raw(alloc_id)?;\n+                let alloc = self.get_alloc_raw(alloc_id)?;\n                 Ok((alloc.size(), alloc.align, (alloc_id, offset, ptr, alloc)))\n             },\n         )?;\n         if let Some((alloc_id, offset, ptr, alloc)) = ptr_and_alloc {\n             let range = alloc_range(offset, size);\n-            M::memory_read(&self.extra, &alloc.extra, ptr.provenance, range)?;\n-            Ok(Some(AllocRef { alloc, range, tcx: self.tcx, alloc_id }))\n+            M::memory_read(&self.machine, &alloc.extra, ptr.provenance, range)?;\n+            Ok(Some(AllocRef { alloc, range, tcx: *self.tcx, alloc_id }))\n         } else {\n             // Even in this branch we have to be sure that we actually access the allocation, in\n             // order to ensure that `static FOO: Type = FOO;` causes a cycle error instead of\n@@ -596,56 +588,55 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     /// Return the `extra` field of the given allocation.\n     pub fn get_alloc_extra<'a>(&'a self, id: AllocId) -> InterpResult<'tcx, &'a M::AllocExtra> {\n-        Ok(&self.get_raw(id)?.extra)\n+        Ok(&self.get_alloc_raw(id)?.extra)\n     }\n \n     /// Gives raw mutable access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n     ///\n     /// Also returns a ptr to `self.extra` so that the caller can use it in parallel with the\n     /// allocation.\n-    fn get_raw_mut(\n+    fn get_alloc_raw_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, (&mut Allocation<M::PointerTag, M::AllocExtra>, &mut M::MemoryExtra)>\n-    {\n+    ) -> InterpResult<'tcx, (&mut Allocation<M::PointerTag, M::AllocExtra>, &mut M)> {\n         // We have \"NLL problem case #3\" here, which cannot be worked around without loss of\n         // efficiency even for the common case where the key is in the map.\n         // <https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions>\n         // (Cannot use `get_mut_or` since `get_global_alloc` needs `&self`.)\n-        if self.alloc_map.get_mut(id).is_none() {\n+        if self.memory.alloc_map.get_mut(id).is_none() {\n             // Slow path.\n             // Allocation not found locally, go look global.\n             let alloc = self.get_global_alloc(id, /*is_write*/ true)?;\n             let kind = M::GLOBAL_KIND.expect(\n                 \"I got a global allocation that I have to copy but the machine does \\\n                     not expect that to happen\",\n             );\n-            self.alloc_map.insert(id, (MemoryKind::Machine(kind), alloc.into_owned()));\n+            self.memory.alloc_map.insert(id, (MemoryKind::Machine(kind), alloc.into_owned()));\n         }\n \n-        let (_kind, alloc) = self.alloc_map.get_mut(id).unwrap();\n+        let (_kind, alloc) = self.memory.alloc_map.get_mut(id).unwrap();\n         if alloc.mutability == Mutability::Not {\n             throw_ub!(WriteToReadOnly(id))\n         }\n-        Ok((alloc, &mut self.extra))\n+        Ok((alloc, &mut self.machine))\n     }\n \n     /// \"Safe\" (bounds and align-checked) allocation access.\n-    pub fn get_mut<'a>(\n+    pub fn get_ptr_alloc_mut<'a>(\n         &'a mut self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n         if let Some((alloc_id, offset, ptr)) = parts {\n-            let tcx = self.tcx;\n+            let tcx = *self.tcx;\n             // FIXME: can we somehow avoid looking up the allocation twice here?\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n-            let (alloc, extra) = self.get_raw_mut(alloc_id)?;\n+            let (alloc, machine) = self.get_alloc_raw_mut(alloc_id)?;\n             let range = alloc_range(offset, size);\n-            M::memory_written(extra, &mut alloc.extra, ptr.provenance, range)?;\n+            M::memory_written(machine, &mut alloc.extra, ptr.provenance, range)?;\n             Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id }))\n         } else {\n             Ok(None)\n@@ -656,16 +647,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn get_alloc_extra_mut<'a>(\n         &'a mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, (&'a mut M::AllocExtra, &'a mut M::MemoryExtra)> {\n-        let (alloc, memory_extra) = self.get_raw_mut(id)?;\n-        Ok((&mut alloc.extra, memory_extra))\n+    ) -> InterpResult<'tcx, (&'a mut M::AllocExtra, &'a mut M)> {\n+        let (alloc, machine) = self.get_alloc_raw_mut(id)?;\n+        Ok((&mut alloc.extra, machine))\n     }\n \n     /// Obtain the size and alignment of an allocation, even if that allocation has\n     /// been deallocated.\n     ///\n     /// If `liveness` is `AllocCheck::MaybeDead`, this function always returns `Ok`.\n-    pub fn get_size_and_align(\n+    pub fn get_alloc_size_and_align(\n         &self,\n         id: AllocId,\n         liveness: AllocCheck,\n@@ -674,7 +665,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n         // b) duplicate a global's allocation in miri\n-        if let Some((_, alloc)) = self.alloc_map.get(id) {\n+        if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n             return Ok((alloc.size(), alloc.align));\n         }\n \n@@ -713,6 +704,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     // Deallocated pointers are allowed, we should be able to find\n                     // them in the map.\n                     Ok(*self\n+                        .memory\n                         .dead_alloc_map\n                         .get(&id)\n                         .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n@@ -724,7 +716,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     fn get_fn_alloc(&self, id: AllocId) -> Option<FnVal<'tcx, M::ExtraFnVal>> {\n-        if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n+        if let Some(extra) = self.memory.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n         } else {\n             match self.tcx.get_global_alloc(id) {\n@@ -734,21 +726,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_fn(\n+    pub fn get_ptr_fn(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"get_fn({:?})\", ptr);\n-        let (alloc_id, offset, _ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, _ptr) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n         }\n         self.get_fn_alloc(alloc_id)\n             .ok_or_else(|| err_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset))).into())\n     }\n \n-    pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n-        self.get_raw_mut(id)?.0.mutability = Mutability::Not;\n+    pub fn alloc_mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n+        self.get_alloc_raw_mut(id)?.0.mutability = Mutability::Not;\n         Ok(())\n     }\n \n@@ -765,7 +757,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn dump_allocs<'a>(&'a self, mut allocs: Vec<AllocId>) -> DumpAllocs<'a, 'mir, 'tcx, M> {\n         allocs.sort();\n         allocs.dedup();\n-        DumpAllocs { mem: self, allocs }\n+        DumpAllocs { ecx: self, allocs }\n     }\n \n     /// Print leaked memory. Allocations reachable from `static_roots` or a `Global` allocation\n@@ -775,14 +767,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let reachable = {\n             let mut reachable = FxHashSet::default();\n             let global_kind = M::GLOBAL_KIND.map(MemoryKind::Machine);\n-            let mut todo: Vec<_> = self.alloc_map.filter_map_collect(move |&id, &(kind, _)| {\n-                if Some(kind) == global_kind { Some(id) } else { None }\n-            });\n+            let mut todo: Vec<_> =\n+                self.memory.alloc_map.filter_map_collect(move |&id, &(kind, _)| {\n+                    if Some(kind) == global_kind { Some(id) } else { None }\n+                });\n             todo.extend(static_roots);\n             while let Some(id) = todo.pop() {\n                 if reachable.insert(id) {\n                     // This is a new allocation, add its relocations to `todo`.\n-                    if let Some((_, alloc)) = self.alloc_map.get(id) {\n+                    if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n                         todo.extend(alloc.relocations().values().map(|tag| tag.get_alloc_id()));\n                     }\n                 }\n@@ -791,7 +784,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         };\n \n         // All allocations that are *not* `reachable` and *not* `may_leak` are considered leaking.\n-        let leaks: Vec<_> = self.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n+        let leaks: Vec<_> = self.memory.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n             if kind.may_leak() || reachable.contains(&id) { None } else { Some(id) }\n         });\n         let n = leaks.len();\n@@ -800,17 +793,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n         n\n     }\n-\n-    /// This is used by [priroda](https://github.com/oli-obk/priroda)\n-    pub fn alloc_map(&self) -> &M::MemoryMap {\n-        &self.alloc_map\n-    }\n }\n \n #[doc(hidden)]\n /// There's no way to use this directly, it's just a helper struct for the `dump_alloc(s)` methods.\n pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n-    mem: &'a Memory<'mir, 'tcx, M>,\n+    ecx: &'a InterpCx<'mir, 'tcx, M>,\n     allocs: Vec<AllocId>,\n }\n \n@@ -840,25 +828,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n             }\n \n             write!(fmt, \"{}\", id)?;\n-            match self.mem.alloc_map.get(id) {\n+            match self.ecx.memory.alloc_map.get(id) {\n                 Some(&(kind, ref alloc)) => {\n                     // normal alloc\n                     write!(fmt, \" ({}, \", kind)?;\n                     write_allocation_track_relocs(\n                         &mut *fmt,\n-                        self.mem.tcx,\n+                        *self.ecx.tcx,\n                         &mut allocs_to_print,\n                         alloc,\n                     )?;\n                 }\n                 None => {\n                     // global alloc\n-                    match self.mem.tcx.get_global_alloc(id) {\n+                    match self.ecx.tcx.get_global_alloc(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             write!(fmt, \" (unchanged global, \")?;\n                             write_allocation_track_relocs(\n                                 &mut *fmt,\n-                                self.mem.tcx,\n+                                *self.ecx.tcx,\n                                 &mut allocs_to_print,\n                                 alloc.inner(),\n                             )?;\n@@ -867,7 +855,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                             write!(fmt, \" (fn: {})\", func)?;\n                         }\n                         Some(GlobalAlloc::Static(did)) => {\n-                            write!(fmt, \" (static: {})\", self.mem.tcx.def_path_str(did))?;\n+                            write!(fmt, \" (static: {})\", self.ecx.tcx.def_path_str(did))?;\n                         }\n                         None => {\n                             write!(fmt, \" (deallocated)\")?;\n@@ -923,16 +911,16 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Reads the given number of bytes from memory. Returns them as a slice.\n     ///\n     /// Performs appropriate bounds checks.\n-    pub fn read_bytes(\n+    pub fn read_bytes_ptr(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]> {\n-        let Some(alloc_ref) = self.get(ptr, size, Align::ONE)? else {\n+        let Some(alloc_ref) = self.get_ptr_alloc(ptr, size, Align::ONE)? else {\n             // zero-sized access\n             return Ok(&[]);\n         };\n@@ -947,7 +935,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Writes the given stream of bytes into memory.\n     ///\n     /// Performs appropriate bounds checks.\n-    pub fn write_bytes(\n+    pub fn write_bytes_ptr(\n         &mut self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         src: impl IntoIterator<Item = u8>,\n@@ -958,7 +946,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         assert_eq!(lower, len, \"can only write iterators with a precise length\");\n \n         let size = Size::from_bytes(len);\n-        let Some(alloc_ref) = self.get_mut(ptr, size, Align::ONE)? else {\n+        let Some(alloc_ref) = self.get_ptr_alloc_mut(ptr, size, Align::ONE)? else {\n             // zero-sized access\n             assert_matches!(\n                 src.next(),\n@@ -984,7 +972,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn copy(\n+    pub fn mem_copy(\n         &mut self,\n         src: Pointer<Option<M::PointerTag>>,\n         src_align: Align,\n@@ -993,10 +981,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         size: Size,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n+        self.mem_copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n     }\n \n-    pub fn copy_repeatedly(\n+    pub fn mem_copy_repeatedly(\n         &mut self,\n         src: Pointer<Option<M::PointerTag>>,\n         src_align: Align,\n@@ -1019,9 +1007,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n             return Ok(());\n         };\n-        let src_alloc = self.get_raw(src_alloc_id)?;\n+        let src_alloc = self.get_alloc_raw(src_alloc_id)?;\n         let src_range = alloc_range(src_offset, size);\n-        M::memory_read(&self.extra, &src_alloc.extra, src.provenance, src_range)?;\n+        M::memory_read(&self.machine, &src_alloc.extra, src.provenance, src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n         let Some((dest_alloc_id, dest_offset, dest)) = dest_parts else {\n@@ -1044,7 +1032,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let compressed = src_alloc.compress_uninit_range(src_range);\n \n         // Destination alloc preparations and access hooks.\n-        let (dest_alloc, extra) = self.get_raw_mut(dest_alloc_id)?;\n+        let (dest_alloc, extra) = self.get_alloc_raw_mut(dest_alloc_id)?;\n         let dest_range = alloc_range(dest_offset, size * num_copies);\n         M::memory_written(extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n         let dest_bytes = dest_alloc\n@@ -1112,7 +1100,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n }\n \n /// Machine pointer introspection.\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n         // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n         // call to force getting out a pointer.\n@@ -1129,9 +1117,32 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Test if this value might be null.\n+    /// If the machine does not support ptr-to-int casts, this is conservative.\n+    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> bool {\n+        match scalar.try_to_int() {\n+            Ok(int) => int.is_null(),\n+            Err(_) => {\n+                // Can only happen during CTFE.\n+                let ptr = self.scalar_to_ptr(scalar);\n+                match self.ptr_try_get_alloc_id(ptr) {\n+                    Ok((alloc_id, offset, _)) => {\n+                        let (size, _align) = self\n+                            .get_alloc_size_and_align(alloc_id, AllocCheck::MaybeDead)\n+                            .expect(\"alloc info with MaybeDead cannot fail\");\n+                        // If the pointer is out-of-bounds, it may be null.\n+                        // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n+                        offset > size\n+                    }\n+                    Err(_offset) => bug!(\"a non-int scalar is always a pointer\"),\n+                }\n+            }\n+        }\n+    }\n+\n     /// Turning a \"maybe pointer\" into a proper pointer (and some information\n     /// about where it points), or an absolute address.\n-    pub fn ptr_try_get_alloc(\n+    pub fn ptr_try_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> Result<(AllocId, Size, Pointer<M::PointerTag>), u64> {\n@@ -1146,11 +1157,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     /// Turning a \"maybe pointer\" into a proper pointer (and some information about where it points).\n     #[inline(always)]\n-    pub fn ptr_get_alloc(\n+    pub fn ptr_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, (AllocId, Size, Pointer<M::PointerTag>)> {\n-        self.ptr_try_get_alloc(ptr).map_err(|offset| {\n+        self.ptr_try_get_alloc_id(ptr).map_err(|offset| {\n             err_ub!(DanglingIntPointer(offset, CheckInAllocMsg::InboundsTest)).into()\n         })\n     }"}, {"sha": "3012f763b80c0c2e4f657fd8c7f18006f73ab4c5", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -257,7 +257,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(None);\n         }\n \n-        let Some(alloc) = self.get_alloc(mplace)? else {\n+        let Some(alloc) = self.get_place_alloc(mplace)? else {\n             return Ok(Some(ImmTy {\n                 // zero-sized type\n                 imm: Scalar::ZST.into(),\n@@ -340,7 +340,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n-        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n+        let bytes = self.read_bytes_ptr(mplace.ptr, Size::from_bytes(len))?;\n         let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n         Ok(str)\n     }"}, {"sha": "c37973bd1663c7a914db08aa29adf9155af4ff99", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -306,25 +306,25 @@ where\n     }\n \n     #[inline]\n-    pub(super) fn get_alloc(\n+    pub(super) fn get_place_alloc(\n         &self,\n         place: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         assert!(!place.layout.is_unsized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n-        self.memory.get(place.ptr, size, place.align)\n+        self.get_ptr_alloc(place.ptr, size, place.align)\n     }\n \n     #[inline]\n-    pub(super) fn get_alloc_mut(\n+    pub(super) fn get_place_alloc_mut(\n         &mut self,\n         place: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         assert!(!place.layout.is_unsized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n-        self.memory.get_mut(place.ptr, size, place.align)\n+        self.get_ptr_alloc_mut(place.ptr, size, place.align)\n     }\n \n     /// Check if this mplace is dereferenceable and sufficiently aligned.\n@@ -337,8 +337,8 @@ where\n             .size_and_align_of_mplace(&mplace)?\n             .unwrap_or((mplace.layout.size, mplace.layout.align.abi));\n         assert!(mplace.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n-        let align = M::enforce_alignment(&self.memory.extra).then_some(align);\n-        self.memory.check_ptr_access_align(mplace.ptr, size, align.unwrap_or(Align::ONE), msg)?;\n+        let align = M::enforce_alignment(self).then_some(align);\n+        self.check_ptr_access_align(mplace.ptr, size, align.unwrap_or(Align::ONE), msg)?;\n         Ok(())\n     }\n \n@@ -748,7 +748,7 @@ where\n \n         // Invalid places are a thing: the return place of a diverging function\n         let tcx = *self.tcx;\n-        let Some(mut alloc) = self.get_alloc_mut(dest)? else {\n+        let Some(mut alloc) = self.get_place_alloc_mut(dest)? else {\n             // zero-sized access\n             return Ok(());\n         };\n@@ -857,8 +857,7 @@ where\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n-        self.memory\n-            .copy(src.ptr, src.align, dest.ptr, dest.align, size, /*nonoverlapping*/ true)\n+        self.mem_copy(src.ptr, src.align, dest.ptr, dest.align, size, /*nonoverlapping*/ true)\n     }\n \n     /// Copies the data from an operand to a place. The layouts may disagree, but they must\n@@ -942,7 +941,7 @@ where\n                         let (size, align) = self\n                             .size_and_align_of(&meta, &local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n-                        let ptr = self.memory.allocate(size, align, MemoryKind::Stack)?;\n+                        let ptr = self.allocate_ptr(size, align, MemoryKind::Stack)?;\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n                         if let LocalValue::Live(Operand::Immediate(value)) = local_val {\n                             // Preserve old value.\n@@ -979,7 +978,7 @@ where\n         layout: TyAndLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'static, MPlaceTy<'tcx, M::PointerTag>> {\n-        let ptr = self.memory.allocate(layout.size, layout.align.abi, kind)?;\n+        let ptr = self.allocate_ptr(layout.size, layout.align.abi, kind)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr.into(), layout))\n     }\n \n@@ -990,7 +989,7 @@ where\n         kind: MemoryKind<M::MemoryKind>,\n         mutbl: Mutability,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n-        let ptr = self.memory.allocate_bytes(str.as_bytes(), Align::ONE, kind, mutbl);\n+        let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl);\n         let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n         let mplace =\n             MemPlace { ptr: ptr.into(), align: Align::ONE, meta: MemPlaceMeta::Meta(meta) };"}, {"sha": "84563daa0880d64446739a509a16f9d86a81155e", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -225,7 +225,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 if length == 0 {\n                     // Nothing to copy... but let's still make sure that `dest` as a place is valid.\n-                    self.get_alloc_mut(&dest)?;\n+                    self.get_place_alloc_mut(&dest)?;\n                 } else {\n                     // Write the src to the first element.\n                     let first = self.mplace_field(&dest, 0)?;\n@@ -241,7 +241,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // that place might be more aligned than its type mandates (a `u8` array could\n                     // be 4-aligned if it sits at the right spot in a struct). Instead we use\n                     // `first.layout.align`, i.e., the alignment given by the type.\n-                    self.memory.copy_repeatedly(\n+                    self.mem_copy_repeatedly(\n                         first_ptr,\n                         first.align,\n                         rest_ptr,"}, {"sha": "a7587652114bf92a520212ae1e18364a5d1f61d2", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -72,7 +72,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (fn_val, fn_abi, with_caller_location) = match *func.layout.ty.kind() {\n                     ty::FnPtr(_sig) => {\n                         let fn_ptr = self.read_pointer(&func)?;\n-                        let fn_val = self.memory.get_fn(fn_ptr)?;\n+                        let fn_val = self.get_ptr_fn(fn_ptr)?;\n                         (fn_val, self.fn_abi_of_fn_ptr(fn_sig_binder, extra_args)?, false)\n                     }\n                     ty::FnDef(def_id, substs) => {"}, {"sha": "5cf3807faaa6d10922e721cfe5c8509ca4be7792", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -32,7 +32,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let vtable_allocation = self.tcx.vtable_allocation((ty, poly_trait_ref));\n \n-        let vtable_ptr = self.memory.global_base_pointer(Pointer::from(vtable_allocation))?;\n+        let vtable_ptr = self.global_base_pointer(Pointer::from(vtable_allocation))?;\n \n         Ok(vtable_ptr.into())\n     }\n@@ -48,11 +48,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let ptr_size = self.pointer_size();\n         let vtable_slot = vtable.offset(ptr_size * idx, self)?;\n         let vtable_slot = self\n-            .memory\n-            .get(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n+            .get_ptr_alloc(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n         let fn_ptr = self.scalar_to_ptr(vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?);\n-        self.memory.get_fn(fn_ptr)\n+        self.get_ptr_fn(fn_ptr)\n     }\n \n     /// Returns the drop fn instance as well as the actual dynamic type.\n@@ -63,8 +62,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let pointer_size = self.pointer_size();\n         // We don't care about the pointee type; we just want a pointer.\n         let vtable = self\n-            .memory\n-            .get(\n+            .get_ptr_alloc(\n                 vtable,\n                 pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),\n                 self.tcx.data_layout.pointer_align.abi,\n@@ -77,7 +75,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .check_init()?;\n         // We *need* an instance here, no other kind of function value, to be able\n         // to determine the type.\n-        let drop_instance = self.memory.get_fn(self.scalar_to_ptr(drop_fn))?.as_instance()?;\n+        let drop_instance = self.get_ptr_fn(self.scalar_to_ptr(drop_fn))?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx, self.param_env).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig);\n@@ -99,8 +97,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // We check for `size = 3 * ptr_size`, which covers the drop fn (unused here),\n         // the size, and the align (which we read below).\n         let vtable = self\n-            .memory\n-            .get(\n+            .get_ptr_alloc(\n                 vtable,\n                 pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),\n                 self.tcx.data_layout.pointer_align.abi,\n@@ -132,8 +129,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let vtable_slot = vtable.offset(pointer_size * idx, self)?;\n         let new_vtable = self\n-            .memory\n-            .get(vtable_slot, pointer_size, self.tcx.data_layout.pointer_align.abi)?\n+            .get_ptr_alloc(vtable_slot, pointer_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n \n         let new_vtable = self.scalar_to_ptr(new_vtable.read_ptr_sized(Size::ZERO)?.check_init()?);"}, {"sha": "42ff7b1945918280878019cc1133c30e5ee5a360", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -315,7 +315,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta());\n                 // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n                 try_validation!(\n-                    self.ecx.memory.check_ptr_access_align(\n+                    self.ecx.check_ptr_access_align(\n                         vtable,\n                         3 * self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n                         self.ecx.tcx.data_layout.pointer_align.abi,\n@@ -403,7 +403,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n         // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n         try_validation!(\n-            self.ecx.memory.check_ptr_access_align(\n+            self.ecx.check_ptr_access_align(\n                 place.ptr,\n                 size,\n                 align,\n@@ -432,7 +432,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if let Some(ref mut ref_tracking) = self.ref_tracking {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n-            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.memory.ptr_try_get_alloc(place.ptr) {\n+            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n                 // Special handling for pointers to statics (irrespective of their type).\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n@@ -579,7 +579,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 if let Some(_) = self.ref_tracking {\n                     let ptr = self.ecx.scalar_to_ptr(value);\n                     let _fn = try_validation!(\n-                        self.ecx.memory.get_fn(ptr),\n+                        self.ecx.get_ptr_fn(ptr),\n                         self.path,\n                         err_ub!(DanglingIntPointer(0, _)) =>\n                             { \"a null function pointer\" },\n@@ -825,7 +825,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let mplace = op.assert_mem_place(); // strings are never immediate\n                 let len = mplace.len(self.ecx)?;\n                 try_validation!(\n-                    self.ecx.memory.read_bytes(mplace.ptr, Size::from_bytes(len)),\n+                    self.ecx.read_bytes_ptr(mplace.ptr, Size::from_bytes(len)),\n                     self.path,\n                     err_ub!(InvalidUninitBytes(..)) => { \"uninitialized data in `str`\" },\n                     err_unsup!(ReadPointerAsBytes) => { \"a pointer in `str`\" },\n@@ -861,7 +861,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept uninit, for consistency with the slow path.\n-                let Some(alloc) = self.ecx.memory.get(mplace.ptr, size, mplace.align)? else {\n+                let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, mplace.align)? else {\n                     // Size 0, nothing more to check.\n                     return Ok(());\n                 };"}, {"sha": "32c52a6a8a6d92069238e0725a1ed93b50654a54", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -378,6 +378,12 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Add a help message attached to this diagnostic with a customizable highlighted message.\n+    pub fn highlighted_help(&mut self, msg: Vec<(String, Style)>) -> &mut Self {\n+        self.sub_with_highlights(Level::Help, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n     /// Prints the span with some help above it.\n     /// This is like [`Diagnostic::help()`], but it gets its own span.\n     pub fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {"}, {"sha": "45a215354d08135b5a881358b85b292aca483f1b", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -41,7 +41,7 @@ use rustc_hir::Node;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::CrateStoreDyn;\n-use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::Align;\n \n@@ -2206,7 +2206,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.impl_trait_ref(def_id).map(|tr| tr.def_id)\n     }\n \n-    /// If the given defid describes a method belonging to an impl, returns the\n+    /// If the given `DefId` describes a method belonging to an impl, returns the\n     /// `DefId` of the impl that the method belongs to; otherwise, returns `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         self.opt_associated_item(def_id).and_then(|trait_item| match trait_item.container {\n@@ -2215,6 +2215,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n+    /// If the given `DefId` belongs to a trait that was automatically derived, returns `true`.\n+    pub fn is_builtin_derive(self, def_id: DefId) -> bool {\n+        self.has_attr(def_id, sym::automatically_derived)\n+    }\n+\n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {"}, {"sha": "4bf66cd4c9f2ece82f8888559918a94b8c94451b", "filename": "compiler/rustc_mir_transform/src/check_packed_ref.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_packed_ref.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -1,10 +1,9 @@\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::{PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_session::lint::builtin::UNALIGNED_REFERENCES;\n-use rustc_span::symbol::sym;\n \n use crate::util;\n use crate::MirLint;\n@@ -50,22 +49,6 @@ fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     });\n }\n \n-fn builtin_derive_def_id(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n-    debug!(\"builtin_derive_def_id({:?})\", def_id);\n-    if let Some(impl_def_id) = tcx.impl_of_method(def_id) {\n-        if tcx.has_attr(impl_def_id, sym::automatically_derived) {\n-            debug!(\"builtin_derive_def_id({:?}) - is {:?}\", def_id, impl_def_id);\n-            Some(impl_def_id)\n-        } else {\n-            debug!(\"builtin_derive_def_id({:?}) - not automatically derived\", def_id);\n-            None\n-        }\n-    } else {\n-        debug!(\"builtin_derive_def_id({:?}) - not a method\", def_id);\n-        None\n-    }\n-}\n-\n impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n         // Make sure we know where in the MIR we are.\n@@ -83,7 +66,11 @@ impl<'tcx> Visitor<'tcx> for PackedRefChecker<'_, 'tcx> {\n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n                 let def_id = self.body.source.instance.def_id();\n-                if let Some(impl_def_id) = builtin_derive_def_id(self.tcx, def_id) {\n+                if let Some(impl_def_id) = self\n+                    .tcx\n+                    .impl_of_method(def_id)\n+                    .filter(|&def_id| self.tcx.is_builtin_derive(def_id))\n+                {\n                     // If a method is defined in the local crate,\n                     // the impl containing that method should also be.\n                     self.tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id.expect_local());"}, {"sha": "49ebdd302545aa184d279b313138852af2648547", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -184,8 +184,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n \n     type MemoryKind = !;\n \n-    type MemoryExtra = ();\n-\n     fn load_mir(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::InstanceDef<'tcx>,\n@@ -267,7 +265,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     }\n \n     fn before_access_global(\n-        _memory_extra: &(),\n+        _machine: &Self,\n         _alloc_id: AllocId,\n         alloc: ConstAllocation<'tcx, Self::PointerTag, Self::AllocExtra>,\n         _static_def_id: Option<DefId>,\n@@ -377,7 +375,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             span,\n             param_env,\n             ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n-            (),\n         );\n \n         let ret = ecx"}, {"sha": "602aa14b9e6c66db0a6cb0a44858cedfa0ea6ab4", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -180,8 +180,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n \n     type MemoryKind = !;\n \n-    type MemoryExtra = ();\n-\n     fn load_mir(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::InstanceDef<'tcx>,\n@@ -263,7 +261,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     }\n \n     fn before_access_global(\n-        _memory_extra: &(),\n+        _machine: &Self,\n         _alloc_id: AllocId,\n         alloc: ConstAllocation<'tcx, Self::PointerTag, Self::AllocExtra>,\n         _static_def_id: Option<DefId>,\n@@ -374,7 +372,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             span,\n             param_env,\n             ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n-            (),\n         );\n \n         let ret = ecx"}, {"sha": "6fedabc816cff938087550a356adfb38f81119b8", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -2297,21 +2297,19 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let prev = self.diagnostic_metadata.current_block_could_be_bare_struct_literal.take();\n         if let (true, [Stmt { kind: StmtKind::Expr(expr), .. }]) =\n             (block.could_be_bare_literal, &block.stmts[..])\n+            && let ExprKind::Type(..) = expr.kind\n         {\n-            if let ExprKind::Type(..) = expr.kind {\n-                self.diagnostic_metadata.current_block_could_be_bare_struct_literal =\n-                    Some(block.span);\n-            }\n+            self.diagnostic_metadata.current_block_could_be_bare_struct_literal =\n+            Some(block.span);\n         }\n         // Descend into the block.\n         for stmt in &block.stmts {\n-            if let StmtKind::Item(ref item) = stmt.kind {\n-                if let ItemKind::MacroDef(..) = item.kind {\n-                    num_macro_definition_ribs += 1;\n-                    let res = self.r.local_def_id(item.id).to_def_id();\n-                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n-                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n-                }\n+            if let StmtKind::Item(ref item) = stmt.kind\n+                && let ItemKind::MacroDef(..) = item.kind {\n+                num_macro_definition_ribs += 1;\n+                let res = self.r.local_def_id(item.id).to_def_id();\n+                self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n+                self.label_ribs.push(Rib::new(MacroDefinition(res)));\n             }\n \n             self.visit_stmt(stmt);"}, {"sha": "f5803aaa0786e9d1769c9f497991f102cadadb7f", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -180,6 +180,9 @@ symbols! {\n         Error,\n         File,\n         FileType,\n+        Fn,\n+        FnMut,\n+        FnOnce,\n         FormatSpec,\n         Formatter,\n         From,\n@@ -248,6 +251,7 @@ symbols! {\n         RustcEncodable,\n         Send,\n         SeqCst,\n+        SliceIndex,\n         Some,\n         String,\n         StructuralEq,"}, {"sha": "27748eef8f20b47071d70b45eee914ce6e1e16ad", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 179, "deletions": 29, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -2,10 +2,11 @@ pub mod on_unimplemented;\n pub mod suggestions;\n \n use super::{\n-    EvaluationResult, FulfillmentContext, FulfillmentError, FulfillmentErrorCode,\n-    MismatchedProjectionTypes, Obligation, ObligationCause, ObligationCauseCode,\n-    OnUnimplementedDirective, OnUnimplementedNote, OutputTypeParameterMismatch, Overflow,\n-    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n+    DerivedObligationCause, EvaluationResult, FulfillmentContext, FulfillmentError,\n+    FulfillmentErrorCode, ImplDerivedObligationCause, MismatchedProjectionTypes, Obligation,\n+    ObligationCause, ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote,\n+    OutputTypeParameterMismatch, Overflow, PredicateObligation, SelectionContext, SelectionError,\n+    TraitNotObjectSafe,\n };\n \n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n@@ -14,6 +15,7 @@ use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n+    Style,\n };\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -28,7 +30,7 @@ use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::error::ExpectedFound;\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::{\n-    self, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable,\n+    self, SubtypePredicate, ToPolyTraitRef, ToPredicate, TraitRef, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{ExpnKind, MultiSpan, Span, DUMMY_SP};\n@@ -354,7 +356,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         let have_alt_message = message.is_some() || label.is_some();\n                         let is_try_conversion = self.is_try_conversion(span, trait_ref.def_id());\n                         let is_unsize =\n-                            { Some(trait_ref.def_id()) == self.tcx.lang_items().unsize_trait() };\n+                            Some(trait_ref.def_id()) == self.tcx.lang_items().unsize_trait();\n                         let (message, note, append_const_msg) = if is_try_conversion {\n                             (\n                                 Some(format!(\n@@ -363,7 +365,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 )),\n                                 Some(\n                                     \"the question mark operation (`?`) implicitly performs a \\\n-                                        conversion on the error value using the `From` trait\"\n+                                     conversion on the error value using the `From` trait\"\n                                         .to_owned(),\n                                 ),\n                                 Some(None),\n@@ -525,10 +527,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n \n                         self.suggest_floating_point_literal(&obligation, &mut err, &trait_ref);\n-                        self.suggest_dereferences(&obligation, &mut err, trait_predicate);\n-                        self.suggest_fn_call(&obligation, &mut err, trait_predicate);\n-                        self.suggest_remove_reference(&obligation, &mut err, trait_predicate);\n-                        self.suggest_semicolon_removal(\n+                        let mut suggested =\n+                            self.suggest_dereferences(&obligation, &mut err, trait_predicate);\n+                        suggested |= self.suggest_fn_call(&obligation, &mut err, trait_predicate);\n+                        suggested |=\n+                            self.suggest_remove_reference(&obligation, &mut err, trait_predicate);\n+                        suggested |= self.suggest_semicolon_removal(\n                             &obligation,\n                             &mut err,\n                             span,\n@@ -654,10 +658,80 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 trait_predicate,\n                                 obligation.cause.body_id,\n                             );\n-                        } else if !have_alt_message {\n+                        } else if !suggested {\n                             // Can't show anything else useful, try to find similar impls.\n                             let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n-                            self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            if !self.report_similar_impl_candidates(\n+                                impl_candidates,\n+                                trait_ref,\n+                                &mut err,\n+                            ) {\n+                                // This is *almost* equivalent to\n+                                // `obligation.cause.code().peel_derives()`, but it gives us the\n+                                // trait predicate for that corresponding root obligation. This\n+                                // lets us get a derived obligation from a type parameter, like\n+                                // when calling `string.strip_suffix(p)` where `p` is *not* an\n+                                // implementer of `Pattern<'_>`.\n+                                let mut code = obligation.cause.code();\n+                                let mut trait_pred = trait_predicate;\n+                                let mut peeled = false;\n+                                loop {\n+                                    match &*code {\n+                                        ObligationCauseCode::FunctionArgumentObligation {\n+                                            parent_code,\n+                                            ..\n+                                        } => {\n+                                            code = &parent_code;\n+                                        }\n+                                        ObligationCauseCode::ImplDerivedObligation(\n+                                            box ImplDerivedObligationCause {\n+                                                derived:\n+                                                    DerivedObligationCause {\n+                                                        parent_code,\n+                                                        parent_trait_pred,\n+                                                    },\n+                                                ..\n+                                            },\n+                                        )\n+                                        | ObligationCauseCode::BuiltinDerivedObligation(\n+                                            DerivedObligationCause {\n+                                                parent_code,\n+                                                parent_trait_pred,\n+                                            },\n+                                        )\n+                                        | ObligationCauseCode::DerivedObligation(\n+                                            DerivedObligationCause {\n+                                                parent_code,\n+                                                parent_trait_pred,\n+                                            },\n+                                        ) => {\n+                                            peeled = true;\n+                                            code = &parent_code;\n+                                            trait_pred = *parent_trait_pred;\n+                                        }\n+                                        _ => break,\n+                                    };\n+                                }\n+                                let def_id = trait_pred.def_id();\n+                                // Mention *all* the `impl`s for the *top most* obligation, the\n+                                // user might have meant to use one of them, if any found. We skip\n+                                // auto-traits or fundamental traits that might not be exactly what\n+                                // the user might expect to be presented with. Instead this is\n+                                // useful for less general traits.\n+                                if peeled\n+                                    && !self.tcx.trait_is_auto(def_id)\n+                                    && !self.tcx.lang_items().items().contains(&Some(def_id))\n+                                {\n+                                    let trait_ref = trait_pred.to_poly_trait_ref();\n+                                    let impl_candidates =\n+                                        self.find_similar_impl_candidates(trait_ref);\n+                                    self.report_similar_impl_candidates(\n+                                        impl_candidates,\n+                                        trait_ref,\n+                                        &mut err,\n+                                    );\n+                                }\n+                            }\n                         }\n \n                         // Changing mutability doesn't make a difference to whether we have\n@@ -682,7 +756,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             });\n                             let unit_obligation = obligation.with(predicate.to_predicate(tcx));\n                             if self.predicate_may_hold(&unit_obligation) {\n-                                err.note(\"this trait is implemented for `()`\");\n                                 err.note(\n                                     \"this error might have been caused by changes to \\\n                                     Rust's type-inference algorithm (see issue #48950 \\\n@@ -1307,8 +1380,9 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     fn report_similar_impl_candidates(\n         &self,\n         impl_candidates: Vec<ImplCandidate<'tcx>>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         err: &mut Diagnostic,\n-    );\n+    ) -> bool;\n \n     /// Gets the parent trait chain start\n     fn get_parent_trait_ref(\n@@ -1319,7 +1393,11 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n     /// with the same path as `trait_ref`, a help message about\n     /// a probable version mismatch is added to `err`\n-    fn note_version_mismatch(&self, err: &mut Diagnostic, trait_ref: &ty::PolyTraitRef<'tcx>);\n+    fn note_version_mismatch(\n+        &self,\n+        err: &mut Diagnostic,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) -> bool;\n \n     /// Creates a `PredicateObligation` with `new_self_ty` replacing the existing type in the\n     /// `trait_ref`.\n@@ -1681,24 +1759,92 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_similar_impl_candidates(\n         &self,\n         impl_candidates: Vec<ImplCandidate<'tcx>>,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n         err: &mut Diagnostic,\n-    ) {\n+    ) -> bool {\n+        let report = |mut candidates: Vec<TraitRef<'tcx>>, err: &mut Diagnostic| {\n+            candidates.sort();\n+            candidates.dedup();\n+            let len = candidates.len();\n+            if candidates.len() == 0 {\n+                return false;\n+            }\n+            if candidates.len() == 1 {\n+                err.highlighted_help(vec![\n+                    (\n+                        format!(\"the trait `{}` \", candidates[0].print_only_trait_path()),\n+                        Style::NoStyle,\n+                    ),\n+                    (\"is\".to_string(), Style::Highlight),\n+                    (\" implemented for `\".to_string(), Style::NoStyle),\n+                    (candidates[0].self_ty().to_string(), Style::Highlight),\n+                    (\"`\".to_string(), Style::NoStyle),\n+                ]);\n+                return true;\n+            }\n+            let trait_ref = TraitRef::identity(self.tcx, candidates[0].def_id);\n+            // Check if the trait is the same in all cases. If so, we'll only show the type.\n+            let mut traits: Vec<_> =\n+                candidates.iter().map(|c| c.print_only_trait_path().to_string()).collect();\n+            traits.sort();\n+            traits.dedup();\n+\n+            let mut candidates: Vec<String> = candidates\n+                .into_iter()\n+                .map(|c| {\n+                    if traits.len() == 1 {\n+                        format!(\"\\n  {}\", c.self_ty())\n+                    } else {\n+                        format!(\"\\n  {}\", c)\n+                    }\n+                })\n+                .collect();\n+\n+            candidates.sort();\n+            candidates.dedup();\n+            let end = if candidates.len() <= 9 { candidates.len() } else { 8 };\n+            err.help(&format!(\n+                \"the following other types implement trait `{}`:{}{}\",\n+                trait_ref.print_only_trait_path(),\n+                candidates[..end].join(\"\"),\n+                if len > 9 { format!(\"\\nand {} others\", len - 8) } else { String::new() }\n+            ));\n+            true\n+        };\n+\n+        let def_id = trait_ref.def_id();\n         if impl_candidates.is_empty() {\n-            return;\n+            if self.tcx.trait_is_auto(def_id)\n+                || self.tcx.lang_items().items().contains(&Some(def_id))\n+                || self.tcx.get_diagnostic_name(def_id).is_some()\n+            {\n+                // Mentioning implementers of `Copy`, `Debug` and friends is not useful.\n+                return false;\n+            }\n+            let normalized_impl_candidates: Vec<_> = self\n+                .tcx\n+                .all_impls(def_id)\n+                // Ignore automatically derived impls and `!Trait` impls.\n+                .filter(|&def_id| {\n+                    self.tcx.impl_polarity(def_id) != ty::ImplPolarity::Negative\n+                        || self.tcx.is_builtin_derive(def_id)\n+                })\n+                .filter_map(|def_id| self.tcx.impl_trait_ref(def_id))\n+                // Avoid mentioning type parameters.\n+                .filter(|trait_ref| !matches!(trait_ref.self_ty().kind(), ty::Param(_)))\n+                .collect();\n+            return report(normalized_impl_candidates, err);\n         }\n \n-        let len = impl_candidates.len();\n-        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n-\n         let normalize = |candidate| {\n             self.tcx.infer_ctxt().enter(|ref infcx| {\n                 let normalized = infcx\n                     .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n                     .normalize(candidate)\n                     .ok();\n                 match normalized {\n-                    Some(normalized) => format!(\"\\n  {}\", normalized.value),\n-                    None => format!(\"\\n  {}\", candidate),\n+                    Some(normalized) => normalized.value,\n+                    None => candidate,\n                 }\n             })\n         };\n@@ -1717,17 +1863,14 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             })\n             .collect::<Vec<_>>();\n         normalized_impl_candidates_and_similarities.sort();\n+        normalized_impl_candidates_and_similarities.dedup();\n \n         let normalized_impl_candidates = normalized_impl_candidates_and_similarities\n             .into_iter()\n             .map(|(_, normalized)| normalized)\n             .collect::<Vec<_>>();\n \n-        err.help(&format!(\n-            \"the following implementations were found:{}{}\",\n-            normalized_impl_candidates[..end].join(\"\"),\n-            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n-        ));\n+        report(normalized_impl_candidates, err)\n     }\n \n     /// Gets the parent trait chain start\n@@ -1758,7 +1901,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n     /// with the same path as `trait_ref`, a help message about\n     /// a probable version mismatch is added to `err`\n-    fn note_version_mismatch(&self, err: &mut Diagnostic, trait_ref: &ty::PolyTraitRef<'tcx>) {\n+    fn note_version_mismatch(\n+        &self,\n+        err: &mut Diagnostic,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) -> bool {\n         let get_trait_impl = |trait_def_id| {\n             self.tcx.find_map_relevant_impl(trait_def_id, trait_ref.skip_binder().self_ty(), Some)\n         };\n@@ -1769,6 +1916,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             .filter(|trait_def_id| *trait_def_id != trait_ref.def_id())\n             .filter(|trait_def_id| self.tcx.def_path_str(*trait_def_id) == required_trait_path)\n             .collect();\n+        let mut suggested = false;\n         for trait_with_same_path in traits_with_same_path {\n             if let Some(impl_def_id) = get_trait_impl(trait_with_same_path) {\n                 let impl_span = self.tcx.def_span(impl_def_id);\n@@ -1779,8 +1927,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                     trait_crate\n                 );\n                 err.note(&crate_msg);\n+                suggested = true;\n             }\n         }\n+        suggested\n     }\n \n     fn mk_trait_obligation_with_new_self_ty("}, {"sha": "c5324bf85a71dace4f2f28edf7878f5a25f03e52", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 172, "deletions": 109, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -1,6 +1,6 @@\n use super::{\n-    EvaluationResult, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation,\n-    SelectionContext,\n+    DerivedObligationCause, EvaluationResult, ImplDerivedObligationCause, Obligation,\n+    ObligationCause, ObligationCauseCode, PredicateObligation, SelectionContext,\n };\n \n use crate::autoderef::Autoderef;\n@@ -58,7 +58,7 @@ pub trait InferCtxtExt<'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    );\n+    ) -> bool;\n \n     fn get_closure_name(&self, def_id: DefId, err: &mut Diagnostic, msg: &str) -> Option<String>;\n \n@@ -67,7 +67,7 @@ pub trait InferCtxtExt<'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    );\n+    ) -> bool;\n \n     fn suggest_add_reference_to_arg(\n         &self,\n@@ -90,7 +90,7 @@ pub trait InferCtxtExt<'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    );\n+    ) -> bool;\n \n     fn suggest_remove_await(&self, obligation: &PredicateObligation<'tcx>, err: &mut Diagnostic);\n \n@@ -107,7 +107,7 @@ pub trait InferCtxtExt<'tcx> {\n         err: &mut Diagnostic,\n         span: Span,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    );\n+    ) -> bool;\n \n     fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span>;\n \n@@ -502,54 +502,87 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    ) {\n+    ) -> bool {\n         // It only make sense when suggesting dereferences for arguments\n-        let code = if let ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } =\n-            obligation.cause.code()\n-        {\n-            parent_code.clone()\n-        } else {\n-            return;\n+        let ObligationCauseCode::FunctionArgumentObligation { .. } = obligation.cause.code() else {\n+            return false;\n         };\n         let param_env = obligation.param_env;\n         let body_id = obligation.cause.body_id;\n         let span = obligation.cause.span;\n-        let real_trait_pred = match &*code {\n-            ObligationCauseCode::ImplDerivedObligation(cause) => cause.derived.parent_trait_pred,\n-            ObligationCauseCode::DerivedObligation(cause)\n-            | ObligationCauseCode::BuiltinDerivedObligation(cause) => cause.parent_trait_pred,\n-            _ => trait_pred,\n-        };\n-        let Some(real_ty) = real_trait_pred.self_ty().no_bound_vars() else {\n-            return;\n-        };\n+        let mut real_trait_pred = trait_pred;\n+        let mut code = obligation.cause.code();\n+        loop {\n+            match &code {\n+                ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } => {\n+                    code = &parent_code;\n+                }\n+                ObligationCauseCode::ImplDerivedObligation(box ImplDerivedObligationCause {\n+                    derived: DerivedObligationCause { parent_code, parent_trait_pred },\n+                    ..\n+                })\n+                | ObligationCauseCode::BuiltinDerivedObligation(DerivedObligationCause {\n+                    parent_code,\n+                    parent_trait_pred,\n+                })\n+                | ObligationCauseCode::DerivedObligation(DerivedObligationCause {\n+                    parent_code,\n+                    parent_trait_pred,\n+                }) => {\n+                    code = &parent_code;\n+                    real_trait_pred = *parent_trait_pred;\n+                }\n+                _ => break,\n+            };\n+            let Some(real_ty) = real_trait_pred.self_ty().no_bound_vars() else {\n+                continue;\n+            };\n \n-        if let ty::Ref(region, base_ty, mutbl) = *real_ty.kind() {\n-            let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty, span);\n-            if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n-                // Re-add the `&`\n-                let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n-                let obligation =\n-                    self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_pred, ty);\n-                Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n-            }) {\n-                if steps > 0 {\n-                    if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(span) {\n-                        // Don't care about `&mut` because `DerefMut` is used less\n-                        // often and user will not expect autoderef happens.\n-                        if src.starts_with('&') && !src.starts_with(\"&mut \") {\n-                            let derefs = \"*\".repeat(steps);\n-                            err.span_suggestion(\n-                                span,\n-                                \"consider adding dereference here\",\n-                                format!(\"&{}{}\", derefs, &src[1..]),\n-                                Applicability::MachineApplicable,\n-                            );\n+            if let ty::Ref(region, base_ty, mutbl) = *real_ty.kind() {\n+                let mut autoderef = Autoderef::new(self, param_env, body_id, span, base_ty, span);\n+                if let Some(steps) = autoderef.find_map(|(ty, steps)| {\n+                    // Re-add the `&`\n+                    let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n+                    let obligation =\n+                        self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_pred, ty);\n+                    Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n+                }) {\n+                    if steps > 0 {\n+                        if let Ok(src) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                            // Don't care about `&mut` because `DerefMut` is used less\n+                            // often and user will not expect autoderef happens.\n+                            if src.starts_with('&') && !src.starts_with(\"&mut \") {\n+                                let derefs = \"*\".repeat(steps);\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"consider dereferencing here\",\n+                                    format!(\"&{}{}\", derefs, &src[1..]),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                return true;\n+                            }\n                         }\n                     }\n+                } else if real_trait_pred != trait_pred {\n+                    // This branch addresses #87437.\n+                    let obligation = self.mk_trait_obligation_with_new_self_ty(\n+                        param_env,\n+                        real_trait_pred,\n+                        base_ty,\n+                    );\n+                    if self.predicate_may_hold(&obligation) {\n+                        err.span_suggestion_verbose(\n+                            span.shrink_to_lo(),\n+                            \"consider dereferencing here\",\n+                            \"*\".to_string(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        return true;\n+                    }\n                 }\n             }\n         }\n+        false\n     }\n \n     /// Given a closure's `DefId`, return the given name of the closure.\n@@ -592,22 +625,22 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    ) {\n+    ) -> bool {\n         let Some(self_ty) = trait_pred.self_ty().no_bound_vars() else {\n-            return;\n+            return false;\n         };\n \n         let (def_id, output_ty, callable) = match *self_ty.kind() {\n             ty::Closure(def_id, substs) => (def_id, substs.as_closure().sig().output(), \"closure\"),\n             ty::FnDef(def_id, _) => (def_id, self_ty.fn_sig(self.tcx).output(), \"function\"),\n-            _ => return,\n+            _ => return false,\n         };\n         let msg = format!(\"use parentheses to call the {}\", callable);\n \n         // `mk_trait_obligation_with_new_self_ty` only works for types with no escaping bound\n         // variables, so bail out if we have any.\n         let Some(output_ty) = output_ty.no_bound_vars() else {\n-            return;\n+            return false;\n         };\n \n         let new_obligation =\n@@ -619,7 +652,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 | EvaluationResult::EvaluatedToOkModuloRegions\n                 | EvaluationResult::EvaluatedToAmbig,\n             ) => {}\n-            _ => return,\n+            _ => return false,\n         }\n         let hir = self.tcx.hir();\n         // Get the name of the callable and the arguments to be used in the suggestion.\n@@ -630,7 +663,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             })) => {\n                 err.span_label(*span, \"consider calling this closure\");\n                 let Some(name) = self.get_closure_name(def_id, err, &msg) else {\n-                    return;\n+                    return false;\n                 };\n                 let args = decl.inputs.iter().map(|_| \"_\").collect::<Vec<_>>().join(\", \");\n                 let sugg = format!(\"({})\", args);\n@@ -658,7 +691,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let sugg = format!(\"({})\", args);\n                 (format!(\"{}{}\", ident, sugg), sugg)\n             }\n-            _ => return,\n+            _ => return false,\n         };\n         if matches!(obligation.cause.code(), ObligationCauseCode::FunctionArgumentObligation { .. })\n         {\n@@ -675,6 +708,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         } else {\n             err.help(&format!(\"{}: `{}`\", msg, snippet));\n         }\n+        true\n     }\n \n     fn suggest_add_reference_to_arg(\n@@ -845,19 +879,20 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    ) {\n+    ) -> bool {\n         let span = obligation.cause.span;\n \n+        let mut suggested = false;\n         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n             let refs_number =\n                 snippet.chars().filter(|c| !c.is_whitespace()).take_while(|c| *c == '&').count();\n             if let Some('\\'') = snippet.chars().filter(|c| !c.is_whitespace()).nth(refs_number) {\n                 // Do not suggest removal of borrow from type arguments.\n-                return;\n+                return false;\n             }\n \n             let Some(mut suggested_ty) = trait_pred.self_ty().no_bound_vars() else {\n-                return;\n+                return false;\n             };\n \n             for refs_remaining in 0..refs_number {\n@@ -893,10 +928,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         String::new(),\n                         Applicability::MachineApplicable,\n                     );\n+                    suggested = true;\n                     break;\n                 }\n             }\n         }\n+        suggested\n     }\n \n     fn suggest_remove_await(&self, obligation: &PredicateObligation<'tcx>, err: &mut Diagnostic) {\n@@ -1033,7 +1070,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut Diagnostic,\n         span: Span,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-    ) {\n+    ) -> bool {\n         let hir = self.tcx.hir();\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n         let node = hir.find(parent_node);\n@@ -1052,7 +1089,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         {\n             let sp = self.tcx.sess.source_map().end_point(stmt.span);\n             err.span_label(sp, \"consider removing this semicolon\");\n+            return true;\n         }\n+        false\n     }\n \n     fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span> {\n@@ -1082,8 +1121,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         let hir = self.tcx.hir();\n-        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n-        let node = hir.find(parent_node);\n+        let fn_hir_id = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(fn_hir_id);\n         let Some(hir::Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(sig, _, body_id),\n             ..\n@@ -1121,16 +1160,17 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         visitor.visit_body(&body);\n \n         let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n+        let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id) else { return false; };\n \n-        let mut ret_types = visitor\n+        let ret_types = visitor\n             .returns\n             .iter()\n-            .filter_map(|expr| typeck_results.node_type_opt(expr.hir_id))\n-            .map(|ty| self.resolve_vars_if_possible(ty));\n+            .filter_map(|expr| Some((expr.span, typeck_results.node_type_opt(expr.hir_id)?)))\n+            .map(|(expr_span, ty)| (expr_span, self.resolve_vars_if_possible(ty)));\n         let (last_ty, all_returns_have_same_type, only_never_return) = ret_types.clone().fold(\n             (None, true, true),\n             |(last_ty, mut same, only_never_return): (std::option::Option<Ty<'_>>, bool, bool),\n-             ty| {\n+             (_, ty)| {\n                 let ty = self.resolve_vars_if_possible(ty);\n                 same &=\n                     !matches!(ty.kind(), ty::Error(_))\n@@ -1151,39 +1191,60 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 (Some(ty), same, only_never_return && matches!(ty.kind(), ty::Never))\n             },\n         );\n-        let all_returns_conform_to_trait =\n-            if let Some(ty_ret_ty) = typeck_results.node_type_opt(ret_ty.hir_id) {\n-                match ty_ret_ty.kind() {\n-                    ty::Dynamic(predicates, _) => {\n-                        let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n-                        let param_env = ty::ParamEnv::empty();\n-                        only_never_return\n-                            || ret_types.all(|returned_ty| {\n-                                predicates.iter().all(|predicate| {\n-                                    let pred = predicate.with_self_ty(self.tcx, returned_ty);\n-                                    let obl = Obligation::new(cause.clone(), param_env, pred);\n-                                    self.predicate_may_hold(&obl)\n-                                })\n+        let mut spans_and_needs_box = vec![];\n+\n+        match liberated_sig.output().kind() {\n+            ty::Dynamic(predicates, _) => {\n+                let cause = ObligationCause::misc(ret_ty.span, fn_hir_id);\n+                let param_env = ty::ParamEnv::empty();\n+\n+                if !only_never_return {\n+                    for (expr_span, return_ty) in ret_types {\n+                        let self_ty_satisfies_dyn_predicates = |self_ty| {\n+                            predicates.iter().all(|predicate| {\n+                                let pred = predicate.with_self_ty(self.tcx, self_ty);\n+                                let obl = Obligation::new(cause.clone(), param_env, pred);\n+                                self.predicate_may_hold(&obl)\n                             })\n+                        };\n+\n+                        if let ty::Adt(def, substs) = return_ty.kind()\n+                            && def.is_box()\n+                            && self_ty_satisfies_dyn_predicates(substs.type_at(0))\n+                        {\n+                            spans_and_needs_box.push((expr_span, false));\n+                        } else if self_ty_satisfies_dyn_predicates(return_ty) {\n+                            spans_and_needs_box.push((expr_span, true));\n+                        } else {\n+                            return false;\n+                        }\n                     }\n-                    _ => false,\n                 }\n-            } else {\n-                true\n-            };\n+            }\n+            _ => return false,\n+        };\n \n         let sm = self.tcx.sess.source_map();\n-        let (true, hir::TyKind::TraitObject(..), Ok(snippet), true) = (\n-            // Verify that we're dealing with a return `dyn Trait`\n-            ret_ty.span.overlaps(span),\n-            &ret_ty.kind,\n-            sm.span_to_snippet(ret_ty.span),\n-            // If any of the return types does not conform to the trait, then we can't\n-            // suggest `impl Trait` nor trait objects: it is a type mismatch error.\n-            all_returns_conform_to_trait,\n-        ) else {\n+        if !ret_ty.span.overlaps(span) {\n             return false;\n+        }\n+        let snippet = if let hir::TyKind::TraitObject(..) = ret_ty.kind {\n+            if let Ok(snippet) = sm.span_to_snippet(ret_ty.span) {\n+                snippet\n+            } else {\n+                return false;\n+            }\n+        } else {\n+            // Substitute the type, so we can print a fixup given `type Alias = dyn Trait`\n+            let name = liberated_sig.output().to_string();\n+            let name =\n+                name.strip_prefix('(').and_then(|name| name.strip_suffix(')')).unwrap_or(&name);\n+            if !name.starts_with(\"dyn \") {\n+                return false;\n+            }\n+            name.to_owned()\n         };\n+\n         err.code(error_code!(E0746));\n         err.set_primary_message(\"return type cannot have an unboxed trait object\");\n         err.children.clear();\n@@ -1193,6 +1254,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let trait_obj_msg = \"for information on trait objects, see \\\n             <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n             #using-trait-objects-that-allow-for-values-of-different-types>\";\n+\n         let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n         let trait_obj = if has_dyn { &snippet[4..] } else { &snippet };\n         if only_never_return {\n@@ -1220,26 +1282,25 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         } else {\n             if is_object_safe {\n                 // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n-                // Get all the return values and collect their span and suggestion.\n-                let mut suggestions: Vec<_> = visitor\n-                    .returns\n-                    .iter()\n-                    .flat_map(|expr| {\n-                        [\n-                            (expr.span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                            (expr.span.shrink_to_hi(), \")\".to_string()),\n-                        ]\n-                        .into_iter()\n-                    })\n-                    .collect();\n-                if !suggestions.is_empty() {\n-                    // Add the suggestion for the return type.\n-                    suggestions.push((ret_ty.span, format!(\"Box<dyn {}>\", trait_obj)));\n-                    err.multipart_suggestion(\n-                        \"return a boxed trait object instead\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                err.multipart_suggestion(\n+                    \"return a boxed trait object instead\",\n+                    vec![\n+                        (ret_ty.span.shrink_to_lo(), \"Box<\".to_string()),\n+                        (span.shrink_to_hi(), \">\".to_string()),\n+                    ],\n+                    Applicability::MaybeIncorrect,\n+                );\n+                for (span, needs_box) in spans_and_needs_box {\n+                    if needs_box {\n+                        err.multipart_suggestion(\n+                            \"... and box this value\",\n+                            vec![\n+                                (span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                (span.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                 }\n             } else {\n                 // This is currently not possible to trigger because E0038 takes precedence, but\n@@ -2714,13 +2775,15 @@ fn suggest_trait_object_return_type_alternatives(\n         Applicability::MaybeIncorrect,\n     );\n     if is_object_safe {\n-        err.span_suggestion(\n-            ret_ty,\n+        err.multipart_suggestion(\n             &format!(\n                 \"use a boxed trait object if all return paths implement trait `{}`\",\n                 trait_obj,\n             ),\n-            format!(\"Box<dyn {}>\", trait_obj),\n+            vec![\n+                (ret_ty.shrink_to_lo(), \"Box<\".to_string()),\n+                (ret_ty.shrink_to_hi(), \">\".to_string()),\n+            ],\n             Applicability::MaybeIncorrect,\n         );\n     }"}, {"sha": "8137d7029218296500edc721d5101f0b9eabe51c", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -8,7 +8,6 @@ pub mod probe;\n mod suggest;\n \n pub use self::suggest::SelfSource;\n-pub use self::CandidateSource::*;\n pub use self::MethodError::*;\n \n use crate::check::FnCtxt;\n@@ -82,8 +81,8 @@ pub struct NoMatchData<'tcx> {\n // candidate can arise. Used for error reporting only.\n #[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n pub enum CandidateSource {\n-    ImplSource(DefId),\n-    TraitSource(DefId /* trait id */),\n+    Impl(DefId),\n+    Trait(DefId /* trait id */),\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -237,8 +236,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         match *source {\n                             // Note: this cannot come from an inherent impl,\n                             // because the first probing succeeded.\n-                            ImplSource(def) => self.tcx.trait_id_of_impl(def),\n-                            TraitSource(_) => None,\n+                            CandidateSource::Impl(def) => self.tcx.trait_id_of_impl(def),\n+                            CandidateSource::Trait(_) => None,\n                         }\n                     })\n                     .collect(),"}, {"sha": "83474bd7e72f7d377997b52a6016efc15fcf023d", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -1,7 +1,7 @@\n use super::suggest;\n+use super::CandidateSource;\n use super::MethodError;\n use super::NoMatchData;\n-use super::{CandidateSource, ImplSource, TraitSource};\n \n use crate::check::FnCtxt;\n use crate::errors::MethodCallOnUnknownType;\n@@ -694,7 +694,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         for item in self.impl_or_trait_item(impl_def_id) {\n             if !self.has_applicable_self(&item) {\n                 // No receiver declared. Not a candidate.\n-                self.record_static_candidate(ImplSource(impl_def_id));\n+                self.record_static_candidate(CandidateSource::Impl(impl_def_id));\n                 continue;\n             }\n \n@@ -848,7 +848,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             debug!(\"elaborate_bounds(bound_trait_ref={:?})\", bound_trait_ref);\n             for item in self.impl_or_trait_item(bound_trait_ref.def_id()) {\n                 if !self.has_applicable_self(&item) {\n-                    self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n+                    self.record_static_candidate(CandidateSource::Trait(bound_trait_ref.def_id()));\n                 } else {\n                     mk_cand(self, bound_trait_ref, item);\n                 }\n@@ -946,7 +946,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 // Check whether `trait_def_id` defines a method with suitable name.\n                 if !self.has_applicable_self(&item) {\n                     debug!(\"method has inapplicable self\");\n-                    self.record_static_candidate(TraitSource(trait_def_id));\n+                    self.record_static_candidate(CandidateSource::Trait(trait_def_id));\n                     continue;\n                 }\n \n@@ -1018,8 +1018,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             Some(Err(MethodError::Ambiguity(v))) => v\n                 .into_iter()\n                 .map(|source| match source {\n-                    TraitSource(id) => id,\n-                    ImplSource(impl_id) => match tcx.trait_id_of_impl(impl_id) {\n+                    CandidateSource::Trait(id) => id,\n+                    CandidateSource::Impl(impl_id) => match tcx.trait_id_of_impl(impl_id) {\n                         Some(id) => id,\n                         None => span_bug!(span, \"found inherent method when looking at traits\"),\n                     },\n@@ -1417,8 +1417,10 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n \n     fn candidate_source(&self, candidate: &Candidate<'tcx>, self_ty: Ty<'tcx>) -> CandidateSource {\n         match candidate.kind {\n-            InherentImplCandidate(..) => ImplSource(candidate.item.container.id()),\n-            ObjectCandidate | WhereClauseCandidate(_) => TraitSource(candidate.item.container.id()),\n+            InherentImplCandidate(..) => CandidateSource::Impl(candidate.item.container.id()),\n+            ObjectCandidate | WhereClauseCandidate(_) => {\n+                CandidateSource::Trait(candidate.item.container.id())\n+            }\n             TraitCandidate(trait_ref) => self.probe(|_| {\n                 let _ = self\n                     .at(&ObligationCause::dummy(), self.param_env)\n@@ -1428,9 +1430,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     Ok(Some(traits::ImplSource::UserDefined(ref impl_data))) => {\n                         // If only a single impl matches, make the error message point\n                         // to that impl.\n-                        ImplSource(impl_data.impl_def_id)\n+                        CandidateSource::Impl(impl_data.impl_def_id)\n                     }\n-                    _ => TraitSource(candidate.item.container.id()),\n+                    _ => CandidateSource::Trait(candidate.item.container.id()),\n                 }\n             }),\n         }"}, {"sha": "c2cb233f5b84cfa142a433db644762a95b1ba418", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             for (idx, source) in sources.iter().take(limit).enumerate() {\n                 match *source {\n-                    CandidateSource::ImplSource(impl_did) => {\n+                    CandidateSource::Impl(impl_did) => {\n                         // Provide the best span we can. Use the item, if local to crate, else\n                         // the impl, if local to crate (item may be defaulted), else nothing.\n                         let Some(item) = self.associated_value(impl_did, item_name).or_else(|| {\n@@ -193,7 +193,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    CandidateSource::TraitSource(trait_did) => {\n+                    CandidateSource::Trait(trait_did) => {\n                         let Some(item) = self.associated_value(trait_did, item_name) else { continue };\n                         let item_span = self\n                             .tcx\n@@ -515,23 +515,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_sources.len() == 1 {\n-                    let ty_str = if let Some(CandidateSource::ImplSource(impl_did)) =\n-                        static_sources.get(0)\n-                    {\n-                        // When the \"method\" is resolved through dereferencing, we really want the\n-                        // original type that has the associated function for accurate suggestions.\n-                        // (#61411)\n-                        let ty = tcx.at(span).type_of(*impl_did);\n-                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n-                            (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n-                                // Use `actual` as it will have more `substs` filled in.\n-                                self.ty_to_value_string(actual.peel_refs())\n+                    let ty_str =\n+                        if let Some(CandidateSource::Impl(impl_did)) = static_sources.get(0) {\n+                            // When the \"method\" is resolved through dereferencing, we really want the\n+                            // original type that has the associated function for accurate suggestions.\n+                            // (#61411)\n+                            let ty = tcx.at(span).type_of(*impl_did);\n+                            match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n+                                (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n+                                    // Use `actual` as it will have more `substs` filled in.\n+                                    self.ty_to_value_string(actual.peel_refs())\n+                                }\n+                                _ => self.ty_to_value_string(ty.peel_refs()),\n                             }\n-                            _ => self.ty_to_value_string(ty.peel_refs()),\n-                        }\n-                    } else {\n-                        self.ty_to_value_string(actual.peel_refs())\n-                    };\n+                        } else {\n+                            self.ty_to_value_string(actual.peel_refs())\n+                        };\n                     if let SelfSource::MethodCall(expr) = source {\n                         err.span_suggestion(\n                             expr.span.to(span),"}, {"sha": "8383f926435505fbe60b0a97f9ee84502d3833d6", "filename": "library/core/src/ops/function.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ffunction.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -53,6 +53,7 @@\n /// ```\n #[lang = \"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"Fn\"]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on(\n@@ -133,6 +134,7 @@ pub trait Fn<Args>: FnMut<Args> {\n /// ```\n #[lang = \"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"FnMut\"]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on(\n@@ -205,6 +207,7 @@ pub trait FnMut<Args>: FnOnce<Args> {\n /// ```\n #[lang = \"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"FnOnce\"]\n #[rustc_paren_sugar]\n #[rustc_on_unimplemented(\n     on("}, {"sha": "f862912432e56ddaa97b9bfbd6afea72469a6eb6", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -152,18 +152,27 @@ impl<T: ?Sized> *const T {\n \n     /// Gets the \"address\" portion of the pointer.\n     ///\n-    /// This is equivalent to `self as usize`, which semantically discards\n-    /// *provenance* and *address-space* information. To properly restore that information,\n-    /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    /// This is similar to `self as usize`, which semantically discards *provenance* and\n+    /// *address-space* information. However, unlike `self as usize`, casting the returned address\n+    /// back to a pointer yields [`invalid`][], which is undefined behavior to dereference. To\n+    /// properly restore the lost information and obtain a dereferencable pointer, use\n+    /// [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    ///\n+    /// If using those APIs is not possible because there is no way to preserve a pointer with the\n+    /// required provenance, use [`expose_addr`][pointer::expose_addr] and\n+    /// [`from_exposed_addr`][from_exposed_addr] instead. However, note that this makes\n+    /// your code less portable and less amenable to tools that check for compliance with the Rust\n+    /// memory model.\n     ///\n     /// On most platforms this will produce a value with the same bytes as the original\n     /// pointer, because all the bytes are dedicated to describing the address.\n     /// Platforms which need to store additional information in the pointer may\n     /// perform a change of representation to produce a value containing only the address\n     /// portion of the pointer. What that means is up to the platform to define.\n     ///\n-    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n-    /// see the [module documentation][crate::ptr] for details.\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment, and as such\n+    /// might change in the future (including possibly weakening this so it becomes wholly\n+    /// equivalent to `self as usize`). See the [module documentation][crate::ptr] for details.\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n@@ -175,6 +184,41 @@ impl<T: ?Sized> *const T {\n         self as usize\n     }\n \n+    /// Gets the \"address\" portion of the pointer, and 'exposes' the \"provenance\" part for future\n+    /// use in [`from_exposed_addr`][].\n+    ///\n+    /// This is equivalent to `self as usize`, which semantically discards *provenance* and\n+    /// *address-space* information. Furthermore, this (like the `as` cast) has the implicit\n+    /// side-effect of marking the provenance as 'exposed', so on platforms that support it you can\n+    /// later call [`from_exposed_addr`][] to reconstitute the original pointer including its\n+    /// provenance. (Reconstructing address space information, if required, is your responsibility.)\n+    ///\n+    /// Using this method means that code is *not* following Strict Provenance rules. Supporting\n+    /// [`from_exposed_addr`][] complicates specification and reasoning and may not be supported by\n+    /// tools that help you to stay conformant with the Rust memory model, so it is recommended to\n+    /// use [`addr`][pointer::addr] wherever possible.\n+    ///\n+    /// On most platforms this will produce a value with the same bytes as the original pointer,\n+    /// because all the bytes are dedicated to describing the address. Platforms which need to store\n+    /// additional information in the pointer may not support this operation, since the 'expose'\n+    /// side-effect which is required for [`from_exposed_addr`][] to work is typically not\n+    /// available.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n+    /// [module documentation][crate::ptr] for details.\n+    ///\n+    /// [`from_exposed_addr`]: from_exposed_addr\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn expose_addr(self) -> usize\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        self as usize\n+    }\n+\n     /// Creates a new pointer with the given address.\n     ///\n     /// This performs the same operation as an `addr as ptr` cast, but copies"}, {"sha": "ba8b0670147aeb69f2a57b26cb40026101f232bd", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 119, "deletions": 9, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -70,7 +70,7 @@\n //! interpretation of provenance. It's ok if your code doesn't strictly conform to it.**\n //!\n //! [Strict Provenance][] is an experimental set of APIs that help tools that try\n-//! to validate the memory-safety of your program's execution. Notably this includes [miri][]\n+//! to validate the memory-safety of your program's execution. Notably this includes [Miri][]\n //! and [CHERI][], which can detect when you access out of bounds memory or otherwise violate\n //! Rust's memory model.\n //!\n@@ -136,7 +136,7 @@\n //!\n //! The strict provenance experiment is mostly only interested in exploring stricter *spatial*\n //! provenance. In this sense it can be thought of as a subset of the more ambitious and\n-//! formal [Stacked Borrows][] research project, which is what tools like [miri][] are based on.\n+//! formal [Stacked Borrows][] research project, which is what tools like [Miri][] are based on.\n //! In particular, Stacked Borrows is necessary to properly describe what borrows are allowed\n //! to do and when they become invalidated. This necessarily involves much more complex\n //! *temporal* reasoning than simply identifying allocations. Adjusting APIs and code\n@@ -170,7 +170,8 @@\n //! Under Strict Provenance, a usize *cannot* accurately represent a pointer, and converting from\n //! a pointer to a usize is generally an operation which *only* extracts the address. It is\n //! therefore *impossible* to construct a valid pointer from a usize because there is no way\n-//! to restore the address-space and provenance.\n+//! to restore the address-space and provenance. In other words, pointer-integer-pointer\n+//! roundtrips are not possible (in the sense that the resulting pointer is not dereferencable).\n //!\n //! The key insight to making this model *at all* viable is the [`with_addr`][] method:\n //!\n@@ -194,10 +195,10 @@\n //! and then immediately converting back to a pointer. To make this use case more ergonomic,\n //! we provide the [`map_addr`][] method.\n //!\n-//! To help make it clear that code is \"following\" Strict Provenance semantics, we also\n-//! provide an [`addr`][] method which is currently equivalent to `ptr as usize`. In the\n-//! future we may provide a lint for pointer<->integer casts to help you audit if your\n-//! code conforms to strict provenance.\n+//! To help make it clear that code is \"following\" Strict Provenance semantics, we also provide an\n+//! [`addr`][] method which promises that the returned address is not part of a\n+//! pointer-usize-pointer roundtrip. In the future we may provide a lint for pointer<->integer\n+//! casts to help you audit if your code conforms to strict provenance.\n //!\n //!\n //! ## Using Strict Provenance\n@@ -310,6 +311,41 @@\n //!   For instance, ARM explicitly supports high-bit tagging, and so CHERI on ARM inherits\n //!   that and should support it.\n //!\n+//! ## Pointer-usize-pointer roundtrips and 'exposed' provenance\n+//!\n+//! **This section is *non-normative* and is part of the [Strict Provenance] experiment.**\n+//!\n+//! As discussed above, pointer-usize-pointer roundtrips are not possible under [Strict Provenance].\n+//! However, there exists legacy Rust code that is full of such roundtrips, and legacy platform APIs\n+//! regularly assume that `usize` can capture all the information that makes up a pointer. There\n+//! also might be code that cannot be ported to Strict Provenance (which is something we would [like\n+//! to hear about][Strict Provenance]).\n+//!\n+//! For situations like this, there is a fallback plan, a way to 'opt out' of Strict Provenance.\n+//! However, note that this makes your code a lot harder to specify, and the code will not work\n+//! (well) with tools like [Miri] and [CHERI].\n+//!\n+//! This fallback plan is provided by the [`expose_addr`] and [`from_exposed_addr`] methods (which\n+//! are equivalent to `as` casts between pointers and integers). [`expose_addr`] is a lot like\n+//! [`addr`], but additionally adds the provenance of the pointer to a global list of 'exposed'\n+//! provenances. (This list is purely conceptual, it exists for the purpose of specifying Rust but\n+//! is not materialized in actual executions, except in tools like [Miri].) [`from_exposed_addr`]\n+//! can be used to construct a pointer with one of these previously 'exposed' provenances.\n+//! [`from_exposed_addr`] takes only `addr: usize` as arguments, so unlike in [`with_addr`] there is\n+//! no indication of what the correct provenance for the returned pointer is -- and that is exactly\n+//! what makes pointer-usize-pointer roundtrips so tricky to rigorously specify! There is no\n+//! algorithm that decides which provenance will be used. You can think of this as \"guessing\" the\n+//! right provenance, and the guess will be \"maximally in your favor\", in the sense that if there is\n+//! any way to avoid undefined behavior, then that is the guess that will be taken. However, if\n+//! there is *no* previously 'exposed' provenance that justifies the way the returned pointer will\n+//! be used, the program has undefined behavior.\n+//!\n+//! Using [`expose_addr`] or [`from_exposed_addr`] (or the equivalent `as` casts) means that code is\n+//! *not* following Strict Provenance rules. The goal of the Strict Provenance experiment is to\n+//! determine whether it is possible to use Rust without [`expose_addr`] and [`from_exposed_addr`].\n+//! If this is successful, it would be a major win for avoiding specification complexity and to\n+//! facilitate adoption of tools like [CHERI] and [Miri] that can be a big help in increasing the\n+//! confidence in (unsafe) Rust code.\n //!\n //! [aliasing]: ../../nomicon/aliasing.html\n //! [book]: ../../book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer\n@@ -322,7 +358,9 @@\n //! [`map_addr`]: pointer::map_addr\n //! [`addr`]: pointer::addr\n //! [`ptr::invalid`]: core::ptr::invalid\n-//! [miri]: https://github.com/rust-lang/miri\n+//! [`expose_addr`]: pointer::expose_addr\n+//! [`from_exposed_addr`]: from_exposed_addr\n+//! [Miri]: https://github.com/rust-lang/miri\n //! [CHERI]: https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/\n //! [Strict Provenance]: https://github.com/rust-lang/rust/issues/95228\n //! [Stacked Borrows]: https://plv.mpi-sws.org/rustbelt/stacked-borrows/\n@@ -547,6 +585,78 @@ pub const fn invalid_mut<T>(addr: usize) -> *mut T {\n     addr as *mut T\n }\n \n+/// Convert an address back to a pointer, picking up a previously 'exposed' provenance.\n+///\n+/// This is equivalent to `addr as *const T`. The provenance of the returned pointer is that of *any*\n+/// pointer that was previously passed to [`expose_addr`][pointer::expose_addr] or a `ptr as usize`\n+/// cast. If there is no previously 'exposed' provenance that justifies the way this pointer will be\n+/// used, the program has undefined behavior. Note that there is no algorithm that decides which\n+/// provenance will be used. You can think of this as \"guessing\" the right provenance, and the guess\n+/// will be \"maximally in your favor\", in the sense that if there is any way to avoid undefined\n+/// behavior, then that is the guess that will be taken.\n+///\n+/// On platforms with multiple address spaces, it is your responsibility to ensure that the\n+/// address makes sense in the address space that this pointer will be used with.\n+///\n+/// Using this method means that code is *not* following strict provenance rules. \"Guessing\" a\n+/// suitable provenance complicates specification and reasoning and may not be supported by\n+/// tools that help you to stay conformant with the Rust memory model, so it is recommended to\n+/// use [`with_addr`][pointer::with_addr] wherever possible.\n+///\n+/// On most platforms this will produce a value with the same bytes as the address. Platforms\n+/// which need to store additional information in a pointer may not support this operation,\n+/// since it is generally not possible to actually *compute* which provenance the returned\n+/// pointer has to pick up.\n+///\n+/// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n+/// [module documentation][crate::ptr] for details.\n+#[must_use]\n+#[inline]\n+#[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+pub fn from_exposed_addr<T>(addr: usize) -> *const T\n+where\n+    T: Sized,\n+{\n+    // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+    addr as *const T\n+}\n+\n+/// Convert an address back to a mutable pointer, picking up a previously 'exposed' provenance.\n+///\n+/// This is equivalent to `addr as *mut T`. The provenance of the returned pointer is that of *any*\n+/// pointer that was previously passed to [`expose_addr`][pointer::expose_addr] or a `ptr as usize`\n+/// cast. If there is no previously 'exposed' provenance that justifies the way this pointer will be\n+/// used, the program has undefined behavior. Note that there is no algorithm that decides which\n+/// provenance will be used. You can think of this as \"guessing\" the right provenance, and the guess\n+/// will be \"maximally in your favor\", in the sense that if there is any way to avoid undefined\n+/// behavior, then that is the guess that will be taken.\n+///\n+/// On platforms with multiple address spaces, it is your responsibility to ensure that the\n+/// address makes sense in the address space that this pointer will be used with.\n+///\n+/// Using this method means that code is *not* following strict provenance rules. \"Guessing\" a\n+/// suitable provenance complicates specification and reasoning and may not be supported by\n+/// tools that help you to stay conformant with the Rust memory model, so it is recommended to\n+/// use [`with_addr`][pointer::with_addr] wherever possible.\n+///\n+/// On most platforms this will produce a value with the same bytes as the address. Platforms\n+/// which need to store additional information in a pointer may not support this operation,\n+/// since it is generally not possible to actually *compute* which provenance the returned\n+/// pointer has to pick up.\n+///\n+/// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n+/// [module documentation][crate::ptr] for details.\n+#[must_use]\n+#[inline]\n+#[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+pub fn from_exposed_addr_mut<T>(addr: usize) -> *mut T\n+where\n+    T: Sized,\n+{\n+    // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+    addr as *mut T\n+}\n+\n /// Forms a raw slice from a pointer and a length.\n ///\n /// The `len` argument is the number of **elements**, not the number of bytes.\n@@ -763,7 +873,7 @@ pub const unsafe fn swap_nonoverlapping<T>(x: *mut T, y: *mut T, count: usize) {\n         );\n     }\n \n-    // NOTE(scottmcm) MIRI is disabled here as reading in smaller units is a\n+    // NOTE(scottmcm) Miri is disabled here as reading in smaller units is a\n     // pessimization for it.  Also, if the type contains any unaligned pointers,\n     // copying those over multiple reads is difficult to support.\n     #[cfg(not(miri))]"}, {"sha": "5db9c3e941eb4946cbfc11d14e1027d2dd96bda6", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -156,18 +156,27 @@ impl<T: ?Sized> *mut T {\n \n     /// Gets the \"address\" portion of the pointer.\n     ///\n-    /// This is equivalent to `self as usize`, which semantically discards\n-    /// *provenance* and *address-space* information. To properly restore that information,\n-    /// use [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    /// This is similar to `self as usize`, which semantically discards *provenance* and\n+    /// *address-space* information. However, unlike `self as usize`, casting the returned address\n+    /// back to a pointer yields [`invalid`][], which is undefined behavior to dereference. To\n+    /// properly restore the lost information and obtain a dereferencable pointer, use\n+    /// [`with_addr`][pointer::with_addr] or [`map_addr`][pointer::map_addr].\n+    ///\n+    /// If using those APIs is not possible because there is no way to preserve a pointer with the\n+    /// required provenance, use [`expose_addr`][pointer::expose_addr] and\n+    /// [`from_exposed_addr_mut`][from_exposed_addr_mut] instead. However, note that this makes\n+    /// your code less portable and less amenable to tools that check for compliance with the Rust\n+    /// memory model.\n     ///\n     /// On most platforms this will produce a value with the same bytes as the original\n     /// pointer, because all the bytes are dedicated to describing the address.\n     /// Platforms which need to store additional information in the pointer may\n     /// perform a change of representation to produce a value containing only the address\n     /// portion of the pointer. What that means is up to the platform to define.\n     ///\n-    /// This API and its claimed semantics are part of the Strict Provenance experiment,\n-    /// see the [module documentation][crate::ptr] for details.\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment, and as such\n+    /// might change in the future (including possibly weakening this so it becomes wholly\n+    /// equivalent to `self as usize`). See the [module documentation][crate::ptr] for details.\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n@@ -179,6 +188,41 @@ impl<T: ?Sized> *mut T {\n         self as usize\n     }\n \n+    /// Gets the \"address\" portion of the pointer, and 'exposes' the \"provenance\" part for future\n+    /// use in [`from_exposed_addr`][].\n+    ///\n+    /// This is equivalent to `self as usize`, which semantically discards *provenance* and\n+    /// *address-space* information. Furthermore, this (like the `as` cast) has the implicit\n+    /// side-effect of marking the provenance as 'exposed', so on platforms that support it you can\n+    /// later call [`from_exposed_addr_mut`][] to reconstitute the original pointer including its\n+    /// provenance. (Reconstructing address space information, if required, is your responsibility.)\n+    ///\n+    /// Using this method means that code is *not* following Strict Provenance rules. Supporting\n+    /// [`from_exposed_addr_mut`][] complicates specification and reasoning and may not be supported\n+    /// by tools that help you to stay conformant with the Rust memory model, so it is recommended\n+    /// to use [`addr`][pointer::addr] wherever possible.\n+    ///\n+    /// On most platforms this will produce a value with the same bytes as the original pointer,\n+    /// because all the bytes are dedicated to describing the address. Platforms which need to store\n+    /// additional information in the pointer may not support this operation, since the 'expose'\n+    /// side-effect which is required for [`from_exposed_addr_mut`][] to work is typically not\n+    /// available.\n+    ///\n+    /// This API and its claimed semantics are part of the Strict Provenance experiment, see the\n+    /// [module documentation][crate::ptr] for details.\n+    ///\n+    /// [`from_exposed_addr_mut`]: from_exposed_addr_mut\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n+    pub fn expose_addr(self) -> usize\n+    where\n+        T: Sized,\n+    {\n+        // FIXME(strict_provenance_magic): I am magic and should be a compiler intrinsic.\n+        self as usize\n+    }\n+\n     /// Creates a new pointer with the given address.\n     ///\n     /// This performs the same operation as an `addr as ptr` cast, but copies"}, {"sha": "6f402924e75dfadec1cb0bb3acdf2ff0e8c40e6c", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -256,8 +256,10 @@ impl<T: ?Sized> NonNull<T> {\n \n     /// Gets the \"address\" portion of the pointer.\n     ///\n+    /// For more details see the equivalent method on a raw pointer, [`pointer::addr`].\n+    ///\n     /// This API and its claimed semantics are part of the Strict Provenance experiment,\n-    /// see the [module documentation][crate::ptr] for details.\n+    /// see the [`ptr` module documentation][crate::ptr].\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n@@ -272,8 +274,10 @@ impl<T: ?Sized> NonNull<T> {\n \n     /// Creates a new pointer with the given address.\n     ///\n+    /// For more details see the equivalent method on a raw pointer, [`pointer::with_addr`].\n+    ///\n     /// This API and its claimed semantics are part of the Strict Provenance experiment,\n-    /// see the [module documentation][crate::ptr] for details.\n+    /// see the [`ptr` module documentation][crate::ptr].\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]\n@@ -287,10 +291,10 @@ impl<T: ?Sized> NonNull<T> {\n \n     /// Creates a new pointer by mapping `self`'s address to a new one.\n     ///\n-    /// This is a convenience for [`with_addr`][Self::with_addr], see that method for details.\n+    /// For more details see the equivalent method on a raw pointer, [`pointer::map_addr`].\n     ///\n     /// This API and its claimed semantics are part of the Strict Provenance experiment,\n-    /// see the [module documentation][crate::ptr] for details.\n+    /// see the [`ptr` module documentation][crate::ptr].\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"strict_provenance\", issue = \"95228\")]"}, {"sha": "68de4e4e1f32a95ee9b52ac06e2deed82ee120c6", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -140,6 +140,7 @@ mod private_slice_index {\n /// Implementations of this trait have to promise that if the argument\n /// to `get_(mut_)unchecked` is a safe reference, then so is the result.\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+#[rustc_diagnostic_item = \"SliceIndex\"]\n #[rustc_on_unimplemented(\n     on(T = \"str\", label = \"string indices are ranges of `usize`\",),\n     on("}, {"sha": "4a538d4d0a0d8ec6a438cbc8e6dfeee7ce918957", "filename": "src/test/ui/allocator/not-an-allocator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fallocator%2Fnot-an-allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fallocator%2Fnot-an-allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fnot-an-allocator.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -1,8 +1,8 @@\n #[global_allocator]\n static A: usize = 0;\n-//~^ the trait bound `usize:\n-//~| the trait bound `usize:\n-//~| the trait bound `usize:\n-//~| the trait bound `usize:\n+//~^ ERROR E0277\n+//~| ERROR E0277\n+//~| ERROR E0277\n+//~| ERROR E0277\n \n fn main() {}"}, {"sha": "62bb0679f813a486c9e69a9e70e2dade47898390", "filename": "src/test/ui/allocator/not-an-allocator.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fallocator%2Fnot-an-allocator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fallocator%2Fnot-an-allocator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fnot-an-allocator.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,6 +6,7 @@ LL | #[global_allocator]\n LL | static A: usize = 0;\n    |           ^^^^^ the trait `GlobalAlloc` is not implemented for `usize`\n    |\n+   = help: the trait `GlobalAlloc` is implemented for `System`\n    = note: this error originates in the attribute macro `global_allocator` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `usize: GlobalAlloc` is not satisfied\n@@ -16,6 +17,7 @@ LL | #[global_allocator]\n LL | static A: usize = 0;\n    |           ^^^^^ the trait `GlobalAlloc` is not implemented for `usize`\n    |\n+   = help: the trait `GlobalAlloc` is implemented for `System`\n    = note: this error originates in the attribute macro `global_allocator` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `usize: GlobalAlloc` is not satisfied\n@@ -26,6 +28,7 @@ LL | #[global_allocator]\n LL | static A: usize = 0;\n    |           ^^^^^ the trait `GlobalAlloc` is not implemented for `usize`\n    |\n+   = help: the trait `GlobalAlloc` is implemented for `System`\n    = note: this error originates in the attribute macro `global_allocator` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: the trait bound `usize: GlobalAlloc` is not satisfied\n@@ -36,6 +39,7 @@ LL | #[global_allocator]\n LL | static A: usize = 0;\n    |           ^^^^^ the trait `GlobalAlloc` is not implemented for `usize`\n    |\n+   = help: the trait `GlobalAlloc` is implemented for `System`\n    = note: this error originates in the attribute macro `global_allocator` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors"}, {"sha": "2d8d513409d3a83dcc70f6343a05bc772a66272e", "filename": "src/test/ui/associated-types/associated-types-path-2.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-path-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-path-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-path-2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -15,8 +15,7 @@ error[E0277]: the trait bound `u32: Foo` is not satisfied\n LL |     f1(2u32, 4u32);\n    |     ^^ the trait `Foo` is not implemented for `u32`\n    |\n-   = help: the following implementations were found:\n-             <i32 as Foo>\n+   = help: the trait `Foo` is implemented for `i32`\n note: required by a bound in `f1`\n   --> $DIR/associated-types-path-2.rs:13:14\n    |\n@@ -29,8 +28,7 @@ error[E0277]: the trait bound `u32: Foo` is not satisfied\n LL |     f1(2u32, 4u32);\n    |              ^^^^ the trait `Foo` is not implemented for `u32`\n    |\n-   = help: the following implementations were found:\n-             <i32 as Foo>\n+   = help: the trait `Foo` is implemented for `i32`\n \n error[E0277]: the trait bound `u32: Foo` is not satisfied\n   --> $DIR/associated-types-path-2.rs:35:8\n@@ -40,8 +38,7 @@ LL |     f1(2u32, 4i32);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n-             <i32 as Foo>\n+   = help: the trait `Foo` is implemented for `i32`\n note: required by a bound in `f1`\n   --> $DIR/associated-types-path-2.rs:13:14\n    |\n@@ -54,8 +51,7 @@ error[E0277]: the trait bound `u32: Foo` is not satisfied\n LL |     f1(2u32, 4i32);\n    |              ^^^^ the trait `Foo` is not implemented for `u32`\n    |\n-   = help: the following implementations were found:\n-             <i32 as Foo>\n+   = help: the trait `Foo` is implemented for `i32`\n \n error[E0308]: mismatched types\n   --> $DIR/associated-types-path-2.rs:41:18"}, {"sha": "73b5e1053fb9d674b068209207eeec66eedcb170", "filename": "src/test/ui/associated-types/hr-associated-type-bound-1.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     type U = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `X`\n   --> $DIR/hr-associated-type-bound-1.rs:3:33\n    |"}, {"sha": "af2e616896a87f0d1890dfd0d22913359d7f1c3b", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-1.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     type V = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `Y`\n   --> $DIR/hr-associated-type-bound-param-1.rs:4:36\n    |"}, {"sha": "5809c407a5f7f826a819d5ecb95b62bb10301f67", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-2.stderr", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     T: Z<'a, u16>,\n    |        ^^^^^^^^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `Z`\n   --> $DIR/hr-associated-type-bound-param-2.rs:6:35\n    |\n@@ -21,8 +20,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     T: Z<'a, u16>,\n    |        ^^^^^^^^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `Z`\n   --> $DIR/hr-associated-type-bound-param-2.rs:6:35\n    |\n@@ -38,8 +36,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     type W = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `Z`\n   --> $DIR/hr-associated-type-bound-param-2.rs:6:35\n    |"}, {"sha": "84d5e0494cb693a25047d74df7cc8e125a5c75c0", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-3.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-3.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     type U = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `X`\n   --> $DIR/hr-associated-type-bound-param-3.rs:4:33\n    |"}, {"sha": "ee1d5d324954a5cabf081ee0006427d0b2c11e25", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-4.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-4.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     type U = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `X`\n   --> $DIR/hr-associated-type-bound-param-4.rs:4:36\n    |"}, {"sha": "ece3151ba978c31afc8059ee9719b20f8309f7ac", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-5.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     type U = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `X`\n   --> $DIR/hr-associated-type-bound-param-5.rs:17:45\n    |\n@@ -21,8 +20,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     type U = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `X`\n   --> $DIR/hr-associated-type-bound-param-5.rs:17:45\n    |"}, {"sha": "e468a1b3ba4842568b2b8443dc07f613af311c7c", "filename": "src/test/ui/associated-types/issue-65774-1.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,7 @@ error[E0277]: the trait bound `T: MyDisplay` is not satisfied\n LL |     type MpuConfig: MyDisplay = T;\n    |                                 ^ the trait `MyDisplay` is not implemented for `T`\n    |\n+   = help: the trait `MyDisplay` is implemented for `&'a mut T`\n note: required by a bound in `MPU::MpuConfig`\n   --> $DIR/issue-65774-1.rs:10:21\n    |\n@@ -16,6 +17,7 @@ error[E0277]: the trait bound `T: MyDisplay` is not satisfied\n LL |         let closure = |config: &mut <S as MPU>::MpuConfig| writer.my_write(&config);\n    |                                                                            ^^^^^^^ the trait `MyDisplay` is not implemented for `T`\n    |\n+   = help: the trait `MyDisplay` is implemented for `&'a mut T`\n note: required because of the requirements on the impl of `MyDisplay` for `&mut T`\n   --> $DIR/issue-65774-1.rs:5:24\n    |"}, {"sha": "4cef4db4698a711d278ae0d4c061127c1ca4c577", "filename": "src/test/ui/associated-types/issue-65774-2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-65774-2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,7 @@ error[E0277]: the trait bound `T: MyDisplay` is not satisfied\n LL |     type MpuConfig: MyDisplay = T;\n    |                                 ^ the trait `MyDisplay` is not implemented for `T`\n    |\n+   = help: the trait `MyDisplay` is implemented for `&'a mut T`\n note: required by a bound in `MPU::MpuConfig`\n   --> $DIR/issue-65774-2.rs:10:21\n    |\n@@ -16,6 +17,7 @@ error[E0277]: the trait bound `T: MyDisplay` is not satisfied\n LL |         writer.my_write(valref)\n    |                         ^^^^^^ the trait `MyDisplay` is not implemented for `T`\n    |\n+   = help: the trait `MyDisplay` is implemented for `&'a mut T`\n    = note: required for the cast to the object type `dyn MyDisplay`\n \n error: aborting due to 2 previous errors"}, {"sha": "985cdce1224dacd79354fda2aa35643771f418b8", "filename": "src/test/ui/auto-traits/typeck-default-trait-impl-precedence.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fauto-traits%2Ftypeck-default-trait-impl-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fauto-traits%2Ftypeck-default-trait-impl-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Ftypeck-default-trait-impl-precedence.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `u32: Signed` is not satisfied\n LL |     is_defaulted::<&'static u32>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Signed` is not implemented for `u32`\n    |\n-   = help: the following implementations were found:\n-             <i32 as Signed>\n+   = help: the trait `Signed` is implemented for `i32`\n note: required because of the requirements on the impl of `Defaulted` for `&'static u32`\n   --> $DIR/typeck-default-trait-impl-precedence.rs:10:19\n    |"}, {"sha": "21c490965b14740a4e3b5cd08bc093ca7fc37b98", "filename": "src/test/ui/binop/binop-mul-i32-f32.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-i32-f32.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-i32-f32.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-mul-i32-f32.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     x * y\n    |       ^ no implementation for `i32 * f32`\n    |\n    = help: the trait `Mul<f32>` is not implemented for `i32`\n+   = help: the following other types implement trait `Mul<Rhs>`:\n+             <&'a f32 as Mul<f32>>\n+             <&'a f64 as Mul<f64>>\n+             <&'a i128 as Mul<i128>>\n+             <&'a i16 as Mul<i16>>\n+             <&'a i32 as Mul<i32>>\n+             <&'a i64 as Mul<i64>>\n+             <&'a i8 as Mul<i8>>\n+             <&'a isize as Mul<isize>>\n+           and 49 others\n \n error: aborting due to previous error\n "}, {"sha": "95ee51a88261aaefc28eb8ddc293de1a00a2bc33", "filename": "src/test/ui/binop/issue-77910-1.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -16,6 +16,16 @@ LL |     assert_eq!(foo, y);\n    |     ^^^^^^^^^^^^^^^^^^ `for<'r> fn(&'r i32) -> &'r i32 {foo}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for `for<'r> fn(&'r i32) -> &'r i32 {foo}`\n+   = help: the following other types implement trait `Debug`:\n+             extern \"C\" fn() -> Ret\n+             extern \"C\" fn(A) -> Ret\n+             extern \"C\" fn(A, ...) -> Ret\n+             extern \"C\" fn(A, B) -> Ret\n+             extern \"C\" fn(A, B, ...) -> Ret\n+             extern \"C\" fn(A, B, C) -> Ret\n+             extern \"C\" fn(A, B, C, ...) -> Ret\n+             extern \"C\" fn(A, B, C, D) -> Ret\n+           and 68 others\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "38db66f86b46115c20d1e8e20a7b966888bf53ed", "filename": "src/test/ui/binop/shift-various-bad-types.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fbinop%2Fshift-various-bad-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fbinop%2Fshift-various-bad-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fshift-various-bad-types.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     22 >> p.char;\n    |        ^^ no implementation for `{integer} >> char`\n    |\n    = help: the trait `Shr<char>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `Shr<Rhs>`:\n+             <&'a i128 as Shr<i128>>\n+             <&'a i128 as Shr<i16>>\n+             <&'a i128 as Shr<i32>>\n+             <&'a i128 as Shr<i64>>\n+             <&'a i128 as Shr<i8>>\n+             <&'a i128 as Shr<isize>>\n+             <&'a i128 as Shr<u128>>\n+             <&'a i128 as Shr<u16>>\n+           and 568 others\n \n error[E0277]: no implementation for `{integer} >> &str`\n   --> $DIR/shift-various-bad-types.rs:12:8\n@@ -13,6 +23,16 @@ LL |     22 >> p.str;\n    |        ^^ no implementation for `{integer} >> &str`\n    |\n    = help: the trait `Shr<&str>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `Shr<Rhs>`:\n+             <&'a i128 as Shr<i128>>\n+             <&'a i128 as Shr<i16>>\n+             <&'a i128 as Shr<i32>>\n+             <&'a i128 as Shr<i64>>\n+             <&'a i128 as Shr<i8>>\n+             <&'a i128 as Shr<isize>>\n+             <&'a i128 as Shr<u128>>\n+             <&'a i128 as Shr<u16>>\n+           and 568 others\n \n error[E0277]: no implementation for `{integer} >> &Panolpy`\n   --> $DIR/shift-various-bad-types.rs:15:8\n@@ -21,6 +41,16 @@ LL |     22 >> p;\n    |        ^^ no implementation for `{integer} >> &Panolpy`\n    |\n    = help: the trait `Shr<&Panolpy>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `Shr<Rhs>`:\n+             <&'a i128 as Shr<i128>>\n+             <&'a i128 as Shr<i16>>\n+             <&'a i128 as Shr<i32>>\n+             <&'a i128 as Shr<i64>>\n+             <&'a i128 as Shr<i8>>\n+             <&'a i128 as Shr<isize>>\n+             <&'a i128 as Shr<u128>>\n+             <&'a i128 as Shr<u16>>\n+           and 568 others\n \n error[E0308]: mismatched types\n   --> $DIR/shift-various-bad-types.rs:25:18"}, {"sha": "31663e8e84d7229503233f45f2db44b88232920f", "filename": "src/test/ui/block-result/issue-22645.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fblock-result%2Fissue-22645.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fblock-result%2Fissue-22645.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-22645.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `{integer}: Scalar` is not satisfied\n LL |   b + 3\n    |     ^ the trait `Scalar` is not implemented for `{integer}`\n    |\n-   = help: the following implementations were found:\n-             <f64 as Scalar>\n+   = help: the trait `Scalar` is implemented for `f64`\n note: required because of the requirements on the impl of `Add<{integer}>` for `Bob`\n   --> $DIR/issue-22645.rs:8:19\n    |"}, {"sha": "343c0a31862b9969ad97657e95664f3173389868", "filename": "src/test/ui/chalkify/chalk_initial_program.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fchalk_initial_program.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,9 +4,9 @@ error[E0277]: the trait bound `f32: Foo` is not satisfied\n LL |     gimme::<f32>();\n    |             ^^^ the trait `Foo` is not implemented for `f32`\n    |\n-   = help: the following implementations were found:\n-             <i32 as Foo>\n-             <u32 as Foo>\n+   = help: the following other types implement trait `Foo`:\n+             i32\n+             u32\n note: required by a bound in `gimme`\n   --> $DIR/chalk_initial_program.rs:9:13\n    |"}, {"sha": "d4a8354d3fc801b1fd604a80260af2e6fad51b60", "filename": "src/test/ui/chalkify/generic_impls.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fgeneric_impls.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `(Option<T>, f32): Foo` is not satisfied\n LL |     gimme::<(Option<T>, f32)>();\n    |             ^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `(Option<T>, f32)`\n    |\n-   = help: the following implementations were found:\n-             <(T, u32) as Foo>\n+   = help: the trait `Foo` is implemented for `(T, u32)`\n note: required by a bound in `gimme`\n   --> $DIR/generic_impls.rs:7:13\n    |\n@@ -18,8 +17,7 @@ error[E0277]: the trait bound `(i32, f32): Foo` is not satisfied\n LL |     gimme::<(i32, f32)>();\n    |             ^^^^^^^^^^ the trait `Foo` is not implemented for `(i32, f32)`\n    |\n-   = help: the following implementations were found:\n-             <(T, u32) as Foo>\n+   = help: the trait `Foo` is implemented for `(T, u32)`\n note: required by a bound in `gimme`\n   --> $DIR/generic_impls.rs:7:13\n    |"}, {"sha": "a142459bcb4a5e2c4d20f5c481aee7516ac20560", "filename": "src/test/ui/chalkify/impl_wf.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -17,8 +17,7 @@ error[E0277]: the trait bound `f32: Foo` is not satisfied\n LL | impl Baz<f32> for f32 { }\n    |      ^^^^^^^^ the trait `Foo` is not implemented for `f32`\n    |\n-   = help: the following implementations were found:\n-             <i32 as Foo>\n+   = help: the trait `Foo` is implemented for `i32`\n note: required by a bound in `Baz`\n   --> $DIR/impl_wf.rs:18:31\n    |"}, {"sha": "1c1df644b06103fd44aa65177391af76dbd77d8e", "filename": "src/test/ui/chalkify/impl_wf_2.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf_2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf_2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fimpl_wf_2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `f32: Foo` is not satisfied\n LL |     type Item = f32;\n    |                 ^^^ the trait `Foo` is not implemented for `f32`\n    |\n-   = help: the following implementations were found:\n-             <i32 as Foo>\n+   = help: the trait `Foo` is implemented for `i32`\n note: required by a bound in `Bar::Item`\n   --> $DIR/impl_wf_2.rs:8:16\n    |"}, {"sha": "508a6dd1388cbb08463d1f034d3cc3d7f27429f7", "filename": "src/test/ui/chalkify/type_inference.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_inference.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,9 +6,9 @@ LL |     only_bar(x);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n-             <i32 as Bar>\n-             <u32 as Bar>\n+   = help: the following other types implement trait `Bar`:\n+             i32\n+             u32\n note: required by a bound in `only_bar`\n   --> $DIR/type_inference.rs:12:16\n    |"}, {"sha": "7f8566082cd262a4afa3510c67e6997cc64f9832", "filename": "src/test/ui/chalkify/type_wf.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftype_wf.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `{float}: Foo` is not satisfied\n LL |     let s = S {\n    |             ^ the trait `Foo` is not implemented for `{float}`\n    |\n-   = help: the following implementations were found:\n-             <i32 as Foo>\n+   = help: the trait `Foo` is implemented for `i32`\n note: required by a bound in `S`\n   --> $DIR/type_wf.rs:6:13\n    |"}, {"sha": "a4b10a4c339f90214e9c239d93f1e288184c660a", "filename": "src/test/ui/coercion/coerce-issue-49593-box-never.nofallback.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoercion%2Fcoerce-issue-49593-box-never.nofallback.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,16 @@ error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n LL |     /* *mut $0 is coerced to Box<dyn Error> here */ Box::<_ /* ! */>::new(x)\n    |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n    |\n+   = help: the following other types implement trait `std::error::Error`:\n+             !\n+             &'a T\n+             AccessError\n+             AddrParseError\n+             Arc<T>\n+             BorrowError\n+             BorrowMutError\n+             Box<T>\n+           and 42 others\n    = note: required for the cast to the object type `dyn std::error::Error`\n \n error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n@@ -12,6 +22,16 @@ error[E0277]: the trait bound `(): std::error::Error` is not satisfied\n LL |     /* *mut $0 is coerced to *mut Error here */ raw_ptr_box::<_ /* ! */>(x)\n    |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::error::Error` is not implemented for `()`\n    |\n+   = help: the following other types implement trait `std::error::Error`:\n+             !\n+             &'a T\n+             AccessError\n+             AddrParseError\n+             Arc<T>\n+             BorrowError\n+             BorrowMutError\n+             Box<T>\n+           and 42 others\n    = note: required for the cast to the object type `(dyn std::error::Error + 'static)`\n \n error: aborting due to 2 previous errors"}, {"sha": "da2558229a758881776fa3856083c37a57244b1e", "filename": "src/test/ui/const-generics/associated-type-bound-fail.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fassociated-type-bound-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fassociated-type-bound-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fassociated-type-bound-fail.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `u16: Bar<N>` is not satisfied\n LL |     type Assoc = u16;\n    |                  ^^^ the trait `Bar<N>` is not implemented for `u16`\n    |\n-   = help: the following implementations were found:\n-             <u16 as Bar<3_usize>>\n+   = help: the trait `Bar<3_usize>` is implemented for `u16`\n note: required by a bound in `Foo::Assoc`\n   --> $DIR/associated-type-bound-fail.rs:4:17\n    |"}, {"sha": "48c61c22e7a32d51b4e49aa331379356d718a611", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.stderr", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n LL | fn rawr() -> impl Trait {\n    |              ^^^^^^^^^^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n    |\n-   = help: the following implementations were found:\n-             <Uwu<N> as Trait>\n+   = help: the trait `Trait` is implemented for `Uwu<N>`\n \n error[E0277]: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n   --> $DIR/rp_impl_trait_fail.rs:6:25\n@@ -18,16 +17,15 @@ LL | |     Uwu::<10, 12>\n LL | | }\n    | |_^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n    |\n-   = help: the following implementations were found:\n-             <Uwu<N> as Trait>\n+   = help: the trait `Trait` is implemented for `Uwu<N>`\n \n error[E0277]: the trait bound `u32: Traitor<N, N>` is not satisfied\n   --> $DIR/rp_impl_trait_fail.rs:18:26\n    |\n LL | fn uwu<const N: u8>() -> impl Traitor<N> {\n    |                          ^^^^^^^^^^^^^^^ the trait `Traitor<N, N>` is not implemented for `u32`\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Traitor<N, M>`:\n              <u32 as Traitor<N, 2_u8>>\n              <u64 as Traitor<1_u8, 2_u8>>\n \n@@ -42,7 +40,7 @@ LL | |     1_u32\n LL | | }\n    | |_^ the trait `Traitor<N, N>` is not implemented for `u32`\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Traitor<N, M>`:\n              <u32 as Traitor<N, 2_u8>>\n              <u64 as Traitor<1_u8, 2_u8>>\n \n@@ -52,9 +50,9 @@ error[E0277]: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n LL | fn owo() -> impl Traitor {\n    |             ^^^^^^^^^^^^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n    |\n-   = help: the following implementations were found:\n-             <u64 as Traitor<1_u8, 2_u8>>\n+   = help: the following other types implement trait `Traitor<N, M>`:\n              <u32 as Traitor<N, 2_u8>>\n+             <u64 as Traitor<1_u8, 2_u8>>\n \n error[E0277]: the trait bound `u64: Traitor<1_u8, 1_u8>` is not satisfied\n   --> $DIR/rp_impl_trait_fail.rs:24:26\n@@ -67,9 +65,9 @@ LL | |     1_u64\n LL | | }\n    | |_^ the trait `Traitor<1_u8, 1_u8>` is not implemented for `u64`\n    |\n-   = help: the following implementations were found:\n-             <u64 as Traitor<1_u8, 2_u8>>\n+   = help: the following other types implement trait `Traitor<N, M>`:\n              <u32 as Traitor<N, 2_u8>>\n+             <u64 as Traitor<1_u8, 2_u8>>\n \n error: aborting due to 6 previous errors\n "}, {"sha": "7f8a1f742d8403876b7ccb78ebfc134bc586b2b2", "filename": "src/test/ui/const-generics/defaults/trait_objects_fail.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,8 +6,7 @@ LL |     foo(&10_u32);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n-             <u32 as Trait<2_u8>>\n+   = help: the trait `Trait<2_u8>` is implemented for `u32`\n    = note: required for the cast to the object type `dyn Trait`\n \n error[E0277]: the trait bound `bool: Traitor<{_: u8}, {_: u8}>` is not satisfied\n@@ -18,8 +17,7 @@ LL |     bar(&true);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n-             <bool as Traitor<2_u8, 3_u8>>\n+   = help: the trait `Traitor<2_u8, 3_u8>` is implemented for `bool`\n    = note: required for the cast to the object type `dyn Traitor<{_: u8}, {_: u8}>`\n \n error: aborting due to 2 previous errors"}, {"sha": "8b405d6753e5620d1537599b0b76935baac52b6e", "filename": "src/test/ui/const-generics/defaults/wfness.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwfness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwfness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwfness.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -10,17 +10,15 @@ error[E0277]: the trait bound `(): Trait<2_u8>` is not satisfied\n LL | struct WhereClause<const N: u8 = 2> where (): Trait<N>;\n    |                                               ^^^^^^^^ the trait `Trait<2_u8>` is not implemented for `()`\n    |\n-   = help: the following implementations were found:\n-             <() as Trait<3_u8>>\n+   = help: the trait `Trait<3_u8>` is implemented for `()`\n \n error[E0277]: the trait bound `(): Trait<1_u8>` is not satisfied\n   --> $DIR/wfness.rs:14:13\n    |\n LL | fn foo() -> DependentDefaultWfness {\n    |             ^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<1_u8>` is not implemented for `()`\n    |\n-   = help: the following implementations were found:\n-             <() as Trait<3_u8>>\n+   = help: the trait `Trait<3_u8>` is implemented for `()`\n note: required by a bound in `WhereClause`\n   --> $DIR/wfness.rs:6:47\n    |"}, {"sha": "9c1b086f4da9ae8c9140ba295d93610ca4f3d16d", "filename": "src/test/ui/const-generics/exhaustive-value.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fexhaustive-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fexhaustive-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fexhaustive-value.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,12 +4,16 @@ error[E0277]: the trait bound `(): Foo<N>` is not satisfied\n LL |     <() as Foo<N>>::test()\n    |     ^^^^^^^^^^^^^^^^^^^^ the trait `Foo<N>` is not implemented for `()`\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Foo<N>`:\n              <() as Foo<0_u8>>\n              <() as Foo<100_u8>>\n              <() as Foo<101_u8>>\n              <() as Foo<102_u8>>\n-           and 252 others\n+             <() as Foo<103_u8>>\n+             <() as Foo<104_u8>>\n+             <() as Foo<105_u8>>\n+             <() as Foo<106_u8>>\n+           and 248 others\n \n error: aborting due to previous error\n "}, {"sha": "27f5dce9fb266f619ccd89e30fd593ac4b8e7139", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-85848.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-85848.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-85848.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-85848.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,6 +6,7 @@ LL |     writes_to_specific_path(&cap);\n    |     |\n    |     required by a bound introduced by this call\n    |\n+   = help: the trait `Delegates<U>` is implemented for `T`\n note: required because of the requirements on the impl of `Contains<(), true>` for `&C`\n   --> $DIR/issue-85848.rs:21:12\n    |"}, {"sha": "c7be8e14a10d5889b440a92fb47a3b02c11fbe13", "filename": "src/test/ui/const-generics/issues/issue-67185-2.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67185-2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,9 +4,9 @@ error[E0277]: the trait bound `[u16; 3]: Bar` is not satisfied\n LL |     <u8 as Baz>::Quaks: Bar,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `[u16; 3]`\n    |\n-   = help: the following implementations were found:\n-             <[[u16; 3]; 3] as Bar>\n-             <[u16; 4] as Bar>\n+   = help: the following other types implement trait `Bar`:\n+             [[u16; 3]; 3]\n+             [u16; 4]\n    = help: see issue #48214\n    = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n \n@@ -16,9 +16,9 @@ error[E0277]: the trait bound `[[u16; 3]; 2]: Bar` is not satisfied\n LL |     [<u8 as Baz>::Quaks; 2]: Bar,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Bar` is not implemented for `[[u16; 3]; 2]`\n    |\n-   = help: the following implementations were found:\n-             <[[u16; 3]; 3] as Bar>\n-             <[u16; 4] as Bar>\n+   = help: the following other types implement trait `Bar`:\n+             [[u16; 3]; 3]\n+             [u16; 4]\n    = help: see issue #48214\n    = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n \n@@ -28,9 +28,9 @@ error[E0277]: the trait bound `[u16; 3]: Bar` is not satisfied\n LL | impl Foo for FooImpl {}\n    |      ^^^ the trait `Bar` is not implemented for `[u16; 3]`\n    |\n-   = help: the following implementations were found:\n-             <[[u16; 3]; 3] as Bar>\n-             <[u16; 4] as Bar>\n+   = help: the following other types implement trait `Bar`:\n+             [[u16; 3]; 3]\n+             [u16; 4]\n note: required by a bound in `Foo`\n   --> $DIR/issue-67185-2.rs:15:25\n    |\n@@ -46,9 +46,9 @@ error[E0277]: the trait bound `[[u16; 3]; 2]: Bar` is not satisfied\n LL | impl Foo for FooImpl {}\n    |      ^^^ the trait `Bar` is not implemented for `[[u16; 3]; 2]`\n    |\n-   = help: the following implementations were found:\n-             <[[u16; 3]; 3] as Bar>\n-             <[u16; 4] as Bar>\n+   = help: the following other types implement trait `Bar`:\n+             [[u16; 3]; 3]\n+             [u16; 4]\n note: required by a bound in `Foo`\n   --> $DIR/issue-67185-2.rs:14:30\n    |\n@@ -64,9 +64,9 @@ error[E0277]: the trait bound `[[u16; 3]; 2]: Bar` is not satisfied\n LL | fn f(_: impl Foo) {}\n    |              ^^^ the trait `Bar` is not implemented for `[[u16; 3]; 2]`\n    |\n-   = help: the following implementations were found:\n-             <[[u16; 3]; 3] as Bar>\n-             <[u16; 4] as Bar>\n+   = help: the following other types implement trait `Bar`:\n+             [[u16; 3]; 3]\n+             [u16; 4]\n note: required by a bound in `Foo`\n   --> $DIR/issue-67185-2.rs:14:30\n    |\n@@ -82,9 +82,9 @@ error[E0277]: the trait bound `[u16; 3]: Bar` is not satisfied\n LL | fn f(_: impl Foo) {}\n    |              ^^^ the trait `Bar` is not implemented for `[u16; 3]`\n    |\n-   = help: the following implementations were found:\n-             <[[u16; 3]; 3] as Bar>\n-             <[u16; 4] as Bar>\n+   = help: the following other types implement trait `Bar`:\n+             [[u16; 3]; 3]\n+             [u16; 4]\n note: required by a bound in `Foo`\n   --> $DIR/issue-67185-2.rs:15:25\n    |"}, {"sha": "8431d989278bafb57889ca9247c0a0d0793c9e3a", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-1.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `A<{_: usize}>: Bar<{_: usize}>` is not satisfied\n LL |     let _ = A;\n    |             ^ the trait `Bar<{_: usize}>` is not implemented for `A<{_: usize}>`\n    |\n-   = help: the following implementations were found:\n-             <A<7_usize> as Bar<N>>\n+   = help: the trait `Bar<N>` is implemented for `A<7_usize>`\n note: required by a bound in `A`\n   --> $DIR/unused-substs-1.rs:9:11\n    |"}, {"sha": "52a1669e330027e56e722269184fef8e5f0f8ee9", "filename": "src/test/ui/consts/const-blocks/fn-call-in-non-const.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-non-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-non-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ffn-call-in-non-const.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n LL |     let _: [Option<Bar>; 2] = [no_copy(); 2];\n    |                               ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`\n    |\n-   = help: the following implementations were found:\n-             <Option<T> as Copy>\n+   = help: the trait `Copy` is implemented for `Option<T>`\n    = note: the `Copy` trait is required because the repeated element will be copied\n    = help: consider creating a new `const` item and initializing it with the result of the function call to be used in the repeat position, like `const VAL: Type = const_fn();` and `let x = [VAL; 42];`\n    = help: create an inline `const` block, see RFC #2920 <https://github.com/rust-lang/rfcs/pull/2920> for more information"}, {"sha": "318fec60290ee974aec2ec7e45f755c76706e42e", "filename": "src/test/ui/consts/const-blocks/migrate-fail.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fmigrate-fail.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    |                                     ^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`\n    |\n-   = help: the following implementations were found:\n-             <Option<T> as Copy>\n+   = help: the trait `Copy` is implemented for `Option<T>`\n    = note: the `Copy` trait is required because the repeated element will be copied\n \n error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n@@ -14,8 +13,7 @@ error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    |                                     ^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`\n    |\n-   = help: the following implementations were found:\n-             <Option<T> as Copy>\n+   = help: the trait `Copy` is implemented for `Option<T>`\n    = note: the `Copy` trait is required because the repeated element will be copied\n \n error: aborting due to 2 previous errors"}, {"sha": "5a34361aa83b68193e129314be994fa88966a639", "filename": "src/test/ui/consts/const-blocks/nll-fail.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Fnll-fail.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    |                                     ^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`\n    |\n-   = help: the following implementations were found:\n-             <Option<T> as Copy>\n+   = help: the trait `Copy` is implemented for `Option<T>`\n    = note: the `Copy` trait is required because the repeated element will be copied\n \n error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n@@ -14,8 +13,7 @@ error[E0277]: the trait bound `Option<Bar>: Copy` is not satisfied\n LL |         let arr: [Option<Bar>; 2] = [x; 2];\n    |                                     ^^^^^^ the trait `Copy` is not implemented for `Option<Bar>`\n    |\n-   = help: the following implementations were found:\n-             <Option<T> as Copy>\n+   = help: the trait `Copy` is implemented for `Option<T>`\n    = note: the `Copy` trait is required because the repeated element will be copied\n \n error: aborting due to 2 previous errors"}, {"sha": "6979ff36176cdfec5a544055609cc3afdb77dc8b", "filename": "src/test/ui/consts/const-blocks/trait-error.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ftrait-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ftrait-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-blocks%2Ftrait-error.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `Foo<String>: Copy` is not satisfied\n LL |     [Foo(String::new()); 4];\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Foo<String>`\n    |\n-   = help: the following implementations were found:\n-             <Foo<T> as Copy>\n+   = help: the trait `Copy` is implemented for `Foo<T>`\n    = note: the `Copy` trait is required because the repeated element will be copied\n \n error: aborting due to previous error"}, {"sha": "0e6be6d01ed69f3883a7725098d501a94b86d09f", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3b.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -11,6 +11,16 @@ LL |     = [0; (i8::MAX + 1u8) as usize];\n    |                    ^ no implementation for `i8 + u8`\n    |\n    = help: the trait `Add<u8>` is not implemented for `i8`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4fa017e04e97b1c098549265ddaaac8756399ba2", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-4b.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-4b.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -11,6 +11,16 @@ LL |     : [u32; (i8::MAX as i8 + 1u8) as usize]\n    |                            ^ no implementation for `i8 + u8`\n    |\n    = help: the trait `Add<u8>` is not implemented for `i8`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error[E0604]: only `u8` can be cast as `char`, not `i8`\n   --> $DIR/const-eval-overflow-4b.rs:22:13"}, {"sha": "8de61fcfb7330cc36fc1039076f90bdb18278435", "filename": "src/test/ui/consts/too_generic_eval_ice.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -21,6 +21,16 @@ LL |         [5; Self::HOST_SIZE] == [6; 0]\n    |                              ^^ no implementation for `[{integer}; _] == [{integer}; 0]`\n    |\n    = help: the trait `PartialEq<[{integer}; 0]>` is not implemented for `[{integer}; _]`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             <&[B] as PartialEq<[A; N]>>\n+             <&[T] as PartialEq<Vec<U, A>>>\n+             <&mut [B] as PartialEq<[A; N]>>\n+             <&mut [T] as PartialEq<Vec<U, A>>>\n+             <[A; N] as PartialEq<&[B]>>\n+             <[A; N] as PartialEq<&mut [B]>>\n+             <[A; N] as PartialEq<[B; N]>>\n+             <[A; N] as PartialEq<[B]>>\n+           and 3 others\n \n error: aborting due to 3 previous errors\n "}, {"sha": "26764bc0ee5cca431355fc6856b5780d298de731", "filename": "src/test/ui/did_you_mean/issue-21659-show-relevant-trait-impls-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-21659-show-relevant-trait-impls-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-21659-show-relevant-trait-impls-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-21659-show-relevant-trait-impls-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the trait bound `Bar: Foo<usize>` is not satisfied\n LL |     f1.foo(1usize);\n    |        ^^^ the trait `Foo<usize>` is not implemented for `Bar`\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Foo<A>`:\n              <Bar as Foo<i32>>\n              <Bar as Foo<u8>>\n "}, {"sha": "bb175367e1f9e0772ad8d07bfe4520285a1a3733", "filename": "src/test/ui/did_you_mean/issue-21659-show-relevant-trait-impls-2.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-21659-show-relevant-trait-impls-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-21659-show-relevant-trait-impls-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-21659-show-relevant-trait-impls-2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,12 +4,13 @@ error[E0277]: the trait bound `Bar: Foo<usize>` is not satisfied\n LL |     f1.foo(1usize);\n    |        ^^^ the trait `Foo<usize>` is not implemented for `Bar`\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Foo<A>`:\n              <Bar as Foo<i16>>\n              <Bar as Foo<i32>>\n              <Bar as Foo<i8>>\n              <Bar as Foo<u16>>\n-           and 2 others\n+             <Bar as Foo<u32>>\n+             <Bar as Foo<u8>>\n \n error: aborting due to previous error\n "}, {"sha": "d27b05fe7f7df721b5a41733fc2f7cbf6e49ec87", "filename": "src/test/ui/did_you_mean/issue-39802-show-5-trait-impls.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39802-show-5-trait-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39802-show-5-trait-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39802-show-5-trait-impls.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,12 +6,16 @@ LL |     Foo::<i32>::bar(&1i8);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Foo<B>`:\n              <i8 as Foo<bool>>\n              <i8 as Foo<u16>>\n              <i8 as Foo<u32>>\n              <i8 as Foo<u64>>\n-           and 5 others\n+             <i8 as Foo<u8>>\n+             <u8 as Foo<bool>>\n+             <u8 as Foo<u16>>\n+             <u8 as Foo<u32>>\n+             <u8 as Foo<u64>>\n \n error[E0277]: the trait bound `u8: Foo<i32>` is not satisfied\n   --> $DIR/issue-39802-show-5-trait-impls.rs:25:21\n@@ -21,12 +25,16 @@ LL |     Foo::<i32>::bar(&1u8);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Foo<B>`:\n+             <i8 as Foo<bool>>\n+             <i8 as Foo<u16>>\n+             <i8 as Foo<u32>>\n+             <i8 as Foo<u64>>\n+             <i8 as Foo<u8>>\n              <u8 as Foo<bool>>\n              <u8 as Foo<u16>>\n              <u8 as Foo<u32>>\n              <u8 as Foo<u64>>\n-           and 5 others\n \n error[E0277]: the trait bound `bool: Foo<i32>` is not satisfied\n   --> $DIR/issue-39802-show-5-trait-impls.rs:26:21\n@@ -36,12 +44,13 @@ LL |     Foo::<i32>::bar(&true);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Foo<B>`:\n              <bool as Foo<bool>>\n              <bool as Foo<i8>>\n              <bool as Foo<u16>>\n              <bool as Foo<u32>>\n-           and 2 others\n+             <bool as Foo<u64>>\n+             <bool as Foo<u8>>\n \n error: aborting due to 3 previous errors\n "}, {"sha": "26986684f0c0a0a2d19f5df67e1b528b6957f532", "filename": "src/test/ui/did_you_mean/issue-49746-unicode-confusable-in-float-literal-expt.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-49746-unicode-confusable-in-float-literal-expt.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -22,6 +22,16 @@ LL | const UNIVERSAL_GRAVITATIONAL_CONSTANT: f64 = 6.674e\u221211; // m\u00b3\u22c5kg\u207b\u00b9\n    |                                                     ^ no implementation for `{float} - {integer}`\n    |\n    = help: the trait `Sub<{integer}>` is not implemented for `{float}`\n+   = help: the following other types implement trait `Sub<Rhs>`:\n+             <&'a f32 as Sub<f32>>\n+             <&'a f64 as Sub<f64>>\n+             <&'a i128 as Sub<i128>>\n+             <&'a i16 as Sub<i16>>\n+             <&'a i32 as Sub<i32>>\n+             <&'a i64 as Sub<i64>>\n+             <&'a i8 as Sub<i8>>\n+             <&'a isize as Sub<isize>>\n+           and 48 others\n \n error: aborting due to 3 previous errors\n "}, {"sha": "1b87ebd9f20ce991f8aaa966ad998684f212c102", "filename": "src/test/ui/feature-gates/feature-gate-trivial_bounds.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trivial_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trivial_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trivial_bounds.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,7 @@ error[E0277]: the trait bound `i32: Foo` is not satisfied\n LL | enum E where i32: Foo { V }\n    |              ^^^^^^^^ the trait `Foo` is not implemented for `i32`\n    |\n+   = help: the trait `Foo` is implemented for `()`\n    = help: see issue #48214\n    = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n \n@@ -13,6 +14,7 @@ error[E0277]: the trait bound `i32: Foo` is not satisfied\n LL | struct S where i32: Foo;\n    |                ^^^^^^^^ the trait `Foo` is not implemented for `i32`\n    |\n+   = help: the trait `Foo` is implemented for `()`\n    = help: see issue #48214\n    = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n \n@@ -22,6 +24,7 @@ error[E0277]: the trait bound `i32: Foo` is not satisfied\n LL | trait T where i32: Foo {}\n    |               ^^^^^^^^ the trait `Foo` is not implemented for `i32`\n    |\n+   = help: the trait `Foo` is implemented for `()`\n    = help: see issue #48214\n    = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n \n@@ -31,6 +34,7 @@ error[E0277]: the trait bound `i32: Foo` is not satisfied\n LL | union U where i32: Foo { f: i32 }\n    |               ^^^^^^^^ the trait `Foo` is not implemented for `i32`\n    |\n+   = help: the trait `Foo` is implemented for `()`\n    = help: see issue #48214\n    = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n \n@@ -40,6 +44,7 @@ error[E0277]: the trait bound `i32: Foo` is not satisfied\n LL | impl Foo for () where i32: Foo {\n    |                       ^^^^^^^^ the trait `Foo` is not implemented for `i32`\n    |\n+   = help: the trait `Foo` is implemented for `()`\n    = help: see issue #48214\n    = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n \n@@ -49,6 +54,7 @@ error[E0277]: the trait bound `i32: Foo` is not satisfied\n LL | fn f() where i32: Foo\n    |              ^^^^^^^^ the trait `Foo` is not implemented for `i32`\n    |\n+   = help: the trait `Foo` is implemented for `()`\n    = help: see issue #48214\n    = help: add `#![feature(trivial_bounds)]` to the crate attributes to enable\n "}, {"sha": "5204afa4e6bc559ccfa5cd3ed7232c85855b832a", "filename": "src/test/ui/fmt/ifmt-unimpl.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ffmt%2Fifmt-unimpl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fifmt-unimpl.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,16 @@ error[E0277]: the trait bound `str: UpperHex` is not satisfied\n LL |     format!(\"{:X}\", \"3\");\n    |                     ^^^ the trait `UpperHex` is not implemented for `str`\n    |\n+   = help: the following other types implement trait `UpperHex`:\n+             &T\n+             &mut T\n+             NonZeroI128\n+             NonZeroI16\n+             NonZeroI32\n+             NonZeroI64\n+             NonZeroI8\n+             NonZeroIsize\n+           and 21 others\n    = note: required because of the requirements on the impl of `UpperHex` for `&str`\n note: required by a bound in `ArgumentV1::<'a>::new_upper_hex`\n   --> $SRC_DIR/core/src/fmt/mod.rs:LL:COL"}, {"sha": "98c304cc90b53a02554e57c8c7591000d6784739", "filename": "src/test/ui/generic-associated-types/bugs/issue-88460.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-88460.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-88460.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fbugs%2Fissue-88460.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,7 @@ error[E0277]: the trait bound `for<'a> <_ as Trait>::Assoc<'a>: Marker` is not s\n LL |     test(Foo);\n    |     ^^^^ the trait `for<'a> Marker` is not implemented for `<_ as Trait>::Assoc<'a>`\n    |\n+   = help: the trait `Marker` is implemented for `()`\n note: required by a bound in `test`\n   --> $DIR/issue-88460.rs:17:27\n    |"}, {"sha": "d458c7be783d59ae1ec5b8a0fdf35daf8090d6ef", "filename": "src/test/ui/impl-trait/cross-return-site-inference.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fcross-return-site-inference.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -7,6 +7,7 @@ LL |     Err(\"whoops\")?;\n    |                  ^ the trait `From<&str>` is not implemented for `impl Debug`\n    |\n    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\n+   = help: the trait `FromResidual<Result<Infallible, E>>` is implemented for `Result<T, F>`\n    = note: required because of the requirements on the impl of `FromResidual<Result<Infallible, &str>>` for `Result<(), impl Debug>`\n \n error[E0277]: the trait bound `impl Debug: From<&str>` is not satisfied"}, {"sha": "f90399b6b945888bad12c687d671387595b81093", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -81,7 +81,7 @@ LL | fn bak() -> impl Trait { unimplemented!() }\n help: use a boxed trait object if all return paths implement trait `Trait`\n    |\n LL | fn bak() -> Box<dyn Trait> { unimplemented!() }\n-   |             ~~~~~~~~~~~~~~\n+   |             ++++         +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:19:13\n@@ -95,12 +95,16 @@ LL | fn bal() -> dyn Trait {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn bal() -> Box<dyn Trait> {\n-LL |     if true {\n-LL ~         return Box::new(Struct);\n-LL |     }\n-LL ~     Box::new(42)\n+LL | fn bal() -> Box<dyn Trait> {\n+   |             ++++         +\n+help: ... and box this value\n+   |\n+LL |         return Box::new(Struct);\n+   |                +++++++++      +\n+help: ... and box this value\n    |\n+LL |     Box::new(42)\n+   |     +++++++++  +\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:29:9\n@@ -126,12 +130,16 @@ LL | fn bax() -> dyn Trait {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn bax() -> Box<dyn Trait> {\n-LL |     if true {\n-LL ~         Box::new(Struct)\n-LL |     } else {\n-LL ~         Box::new(42)\n+LL | fn bax() -> Box<dyn Trait> {\n+   |             ++++         +\n+help: ... and box this value\n+   |\n+LL |         Box::new(Struct)\n+   |         +++++++++      +\n+help: ... and box this value\n    |\n+LL |         Box::new(42)\n+   |         +++++++++  +\n \n error[E0308]: mismatched types\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:34:16"}, {"sha": "f14b447b077300d58756493fece8e5223610e492", "filename": "src/test/ui/impl-trait/equality.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequality.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -24,6 +24,16 @@ LL |         n + sum_to(n - 1)\n    |           ^ no implementation for `u32 + impl Foo`\n    |\n    = help: the trait `Add<impl Foo>` is not implemented for `u32`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error: aborting due to 2 previous errors; 1 warning emitted\n "}, {"sha": "70d693b8bee957a4460ccec9d662400822a000ca", "filename": "src/test/ui/impl-trait/issues/issue-62742.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-62742.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `RawImpl<_>: Raw<_>` is not satisfied\n LL |     WrongImpl::foo(0i32);\n    |     ^^^^^^^^^ the trait `Raw<_>` is not implemented for `RawImpl<_>`\n    |\n-   = help: the following implementations were found:\n-             <RawImpl<T> as Raw<[T]>>\n+   = help: the trait `Raw<[T]>` is implemented for `RawImpl<T>`\n note: required by a bound in `SafeImpl`\n   --> $DIR/issue-62742.rs:26:35\n    |\n@@ -40,8 +39,7 @@ error[E0277]: the trait bound `RawImpl<()>: Raw<()>` is not satisfied\n LL |     WrongImpl::<()>::foo(0i32);\n    |     ^^^^^^^^^^^^^^^ the trait `Raw<()>` is not implemented for `RawImpl<()>`\n    |\n-   = help: the following implementations were found:\n-             <RawImpl<T> as Raw<[T]>>\n+   = help: the trait `Raw<[T]>` is implemented for `RawImpl<T>`\n note: required by a bound in `SafeImpl`\n   --> $DIR/issue-62742.rs:26:35\n    |"}, {"sha": "81a75e39c9177a29145510d863a40a3ef86c64d9", "filename": "src/test/ui/impl-trait/nested-return-type2-tait.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,7 @@ error[E0277]: the trait bound `Sendable: Duh` is not satisfied\n LL | fn foo() -> impl Trait<Assoc = Sendable> {\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Duh` is not implemented for `Sendable`\n    |\n+   = help: the trait `Duh` is implemented for `i32`\n note: required because of the requirements on the impl of `Trait` for `[closure@$DIR/nested-return-type2-tait.rs:28:5: 28:10]`\n   --> $DIR/nested-return-type2-tait.rs:14:31\n    |\n@@ -21,6 +22,7 @@ LL | |     || 42\n LL | | }\n    | |_^ the trait `Duh` is not implemented for `Sendable`\n    |\n+   = help: the trait `Duh` is implemented for `i32`\n note: required because of the requirements on the impl of `Trait` for `[closure@$DIR/nested-return-type2-tait.rs:28:5: 28:10]`\n   --> $DIR/nested-return-type2-tait.rs:14:31\n    |"}, {"sha": "42e65e692488d6290271b4bce98ea0d59d32dfd9", "filename": "src/test/ui/impl-trait/nested-return-type2-tait2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,7 @@ error[E0277]: the trait bound `Sendable: Duh` is not satisfied\n LL |     || 42\n    |     ^^^^^ the trait `Duh` is not implemented for `Sendable`\n    |\n+   = help: the trait `Duh` is implemented for `i32`\n note: required because of the requirements on the impl of `Trait` for `[closure@$DIR/nested-return-type2-tait2.rs:27:5: 27:10]`\n   --> $DIR/nested-return-type2-tait2.rs:14:31\n    |"}, {"sha": "4d3691d0e07fae3d213e25213eeded92c56d1fbe", "filename": "src/test/ui/impl-trait/nested-return-type2-tait3.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type2-tait3.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,7 @@ error[E0277]: the trait bound `impl Send: Duh` is not satisfied\n LL |     || 42\n    |     ^^^^^ the trait `Duh` is not implemented for `impl Send`\n    |\n+   = help: the trait `Duh` is implemented for `i32`\n note: required because of the requirements on the impl of `Trait` for `[closure@$DIR/nested-return-type2-tait3.rs:26:5: 26:10]`\n   --> $DIR/nested-return-type2-tait3.rs:14:31\n    |"}, {"sha": "bb4ae5e82825488270cc66960739c19bbb27890b", "filename": "src/test/ui/impl-trait/nested_impl_trait.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested_impl_trait.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -52,6 +52,7 @@ error[E0277]: the trait bound `impl Debug: From<impl Into<u32>>` is not satisfie\n LL | fn bad_in_ret_position(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                              ^^^^^^^^^^^^^^^^^^^^^ the trait `From<impl Into<u32>>` is not implemented for `impl Debug`\n    |\n+   = help: the trait `Into<U>` is implemented for `T`\n    = note: required because of the requirements on the impl of `Into<impl Debug>` for `impl Into<u32>`\n \n error[E0277]: the trait bound `impl Debug: From<impl Into<u32>>` is not satisfied\n@@ -60,6 +61,7 @@ error[E0277]: the trait bound `impl Debug: From<impl Into<u32>>` is not satisfie\n LL |     fn bad(x: impl Into<u32>) -> impl Into<impl Debug> { x }\n    |                                  ^^^^^^^^^^^^^^^^^^^^^ the trait `From<impl Into<u32>>` is not implemented for `impl Debug`\n    |\n+   = help: the trait `Into<U>` is implemented for `T`\n    = note: required because of the requirements on the impl of `Into<impl Debug>` for `impl Into<u32>`\n \n error: aborting due to 8 previous errors"}, {"sha": "10510c1754eda5ca842c6d8f0d4fac312ed4b5ee", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -103,13 +103,16 @@ LL | fn hat() -> dyn std::fmt::Display {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn hat() -> Box<dyn std::fmt::Display> {\n-LL |     match 13 {\n-LL |         0 => {\n-LL ~             return Box::new(0i32);\n-LL |         }\n-LL |         _ => {\n- ...\n+LL | fn hat() -> Box<dyn std::fmt::Display> {\n+   |             ++++                     +\n+help: ... and box this value\n+   |\n+LL |             return Box::new(0i32);\n+   |                    +++++++++    +\n+help: ... and box this value\n+   |\n+LL |             Box::new(1u32)\n+   |             +++++++++    +\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:80:14\n@@ -135,12 +138,20 @@ LL | fn pug() -> dyn std::fmt::Display {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn pug() -> Box<dyn std::fmt::Display> {\n-LL |     match 13 {\n-LL ~         0 => Box::new(0i32),\n-LL ~         1 => Box::new(1u32),\n-LL ~         _ => Box::new(2u32),\n+LL | fn pug() -> Box<dyn std::fmt::Display> {\n+   |             ++++                     +\n+help: ... and box this value\n+   |\n+LL |         0 => Box::new(0i32),\n+   |              +++++++++    +\n+help: ... and box this value\n    |\n+LL |         1 => Box::new(1u32),\n+   |              +++++++++    +\n+help: ... and box this value\n+   |\n+LL |         _ => Box::new(2u32),\n+   |              +++++++++    +\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:89:9\n@@ -166,12 +177,16 @@ LL | fn man() -> dyn std::fmt::Display {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn man() -> Box<dyn std::fmt::Display> {\n-LL |     if false {\n-LL ~         Box::new(0i32)\n-LL |     } else {\n-LL ~         Box::new(1u32)\n+LL | fn man() -> Box<dyn std::fmt::Display> {\n+   |             ++++                     +\n+help: ... and box this value\n+   |\n+LL |         Box::new(0i32)\n+   |         +++++++++    +\n+help: ... and box this value\n    |\n+LL |         Box::new(1u32)\n+   |         +++++++++    +\n \n error: aborting due to 14 previous errors\n "}, {"sha": "6cd63db44fa0701dae72eece4d969de48bdfa0a4", "filename": "src/test/ui/impl-trait/recursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-type-alias-impl-trait-declaration-too-subtle-2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,7 @@ LL |     Bar\n    |     ^^^ no implementation for `Bar == (Bar, i32)`\n    |\n    = help: the trait `PartialEq<(Bar, i32)>` is not implemented for `Bar`\n+   = help: the trait `PartialEq<(Foo, i32)>` is implemented for `Bar`\n \n error: aborting due to previous error\n "}, {"sha": "7f51a48111b78705e6737853371033794f08c2eb", "filename": "src/test/ui/index-help.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Findex-help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Findex-help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Findex-help.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,7 @@ LL |     x[0i32];\n    |     ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[{integer}]>` is not implemented for `i32`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<{integer}>`\n \n error: aborting due to previous error"}, {"sha": "dae11a702fb73aa62d3ff5a8aef4960c7ebd8684", "filename": "src/test/ui/indexing-requires-a-uint.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Findexing-requires-a-uint.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,7 @@ LL |     [0][0u8];\n    |     ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[{integer}]>` is not implemented for `u8`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<u8>` for `[{integer}]`\n \n error[E0308]: mismatched types"}, {"sha": "be3398552dc0af68e44e930b13eda6244f4dfa8d", "filename": "src/test/ui/integral-indexing.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fintegral-indexing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fintegral-indexing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintegral-indexing.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,7 @@ LL |     v[3u8];\n    |     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[isize]>` is not implemented for `u8`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<u8>` for `Vec<isize>`\n \n error[E0277]: the type `[isize]` cannot be indexed by `i8`\n@@ -14,6 +15,7 @@ LL |     v[3i8];\n    |     ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[isize]>` is not implemented for `i8`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<i8>` for `Vec<isize>`\n \n error[E0277]: the type `[isize]` cannot be indexed by `u32`\n@@ -23,6 +25,7 @@ LL |     v[3u32];\n    |     ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[isize]>` is not implemented for `u32`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<u32>` for `Vec<isize>`\n \n error[E0277]: the type `[isize]` cannot be indexed by `i32`\n@@ -32,6 +35,7 @@ LL |     v[3i32];\n    |     ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[isize]>` is not implemented for `i32`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<i32>` for `Vec<isize>`\n \n error[E0277]: the type `[u8]` cannot be indexed by `u8`\n@@ -41,6 +45,7 @@ LL |     s.as_bytes()[3u8];\n    |     ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[u8]>` is not implemented for `u8`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<u8>` for `[u8]`\n \n error[E0277]: the type `[u8]` cannot be indexed by `i8`\n@@ -50,6 +55,7 @@ LL |     s.as_bytes()[3i8];\n    |     ^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[u8]>` is not implemented for `i8`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<i8>` for `[u8]`\n \n error[E0277]: the type `[u8]` cannot be indexed by `u32`\n@@ -59,6 +65,7 @@ LL |     s.as_bytes()[3u32];\n    |     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[u8]>` is not implemented for `u32`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<u32>` for `[u8]`\n \n error[E0277]: the type `[u8]` cannot be indexed by `i32`\n@@ -68,6 +75,7 @@ LL |     s.as_bytes()[3i32];\n    |     ^^^^^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[u8]>` is not implemented for `i32`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<i32>` for `[u8]`\n \n error: aborting due to 8 previous errors"}, {"sha": "161fce4b0315c9dc8ad998ea636bcc66c6ff40e2", "filename": "src/test/ui/issues/issue-11771.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-11771.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-11771.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11771.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     1 +\n    |       ^ no implementation for `{integer} + ()`\n    |\n    = help: the trait `Add<()>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error[E0277]: cannot add `()` to `{integer}`\n   --> $DIR/issue-11771.rs:8:7\n@@ -13,6 +23,16 @@ LL |     1 +\n    |       ^ no implementation for `{integer} + ()`\n    |\n    = help: the trait `Add<()>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error: aborting due to 2 previous errors\n "}, {"sha": "28478457b296db68779f5227322583c657f518b9", "filename": "src/test/ui/issues/issue-18107.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -15,7 +15,7 @@ LL |     impl AbstractRenderer\n help: use a boxed trait object if all return paths implement trait `AbstractRenderer`\n    |\n LL |     Box<dyn AbstractRenderer>\n-   |\n+   |     ++++                    +\n \n error: aborting due to previous error\n "}, {"sha": "118f37f6971eff4856d69a966797b6d169059f67", "filename": "src/test/ui/issues/issue-24352.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-24352.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-24352.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24352.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     1.0f64 - 1\n    |            ^ no implementation for `f64 - {integer}`\n    |\n    = help: the trait `Sub<{integer}>` is not implemented for `f64`\n+   = help: the following other types implement trait `Sub<Rhs>`:\n+             <&'a f32 as Sub<f32>>\n+             <&'a f64 as Sub<f64>>\n+             <&'a i128 as Sub<i128>>\n+             <&'a i16 as Sub<i16>>\n+             <&'a i32 as Sub<i32>>\n+             <&'a i64 as Sub<i64>>\n+             <&'a i8 as Sub<i8>>\n+             <&'a isize as Sub<isize>>\n+           and 48 others\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     1.0f64 - 1.0"}, {"sha": "ed5addcbec5170497bc1577e716ad9138c0c5e75", "filename": "src/test/ui/issues/issue-32709.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-32709.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-32709.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-32709.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -7,6 +7,7 @@ LL |     Err(5)?;\n    |           ^ the trait `From<{integer}>` is not implemented for `()`\n    |\n    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\n+   = help: the trait `FromResidual<Result<Infallible, E>>` is implemented for `Result<T, F>`\n    = note: required because of the requirements on the impl of `FromResidual<Result<Infallible, {integer}>>` for `Result<i32, ()>`\n \n error: aborting due to previous error"}, {"sha": "48ae2df691c3d66ef17bafb381ba1e72b6b0ba15", "filename": "src/test/ui/issues/issue-34334.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34334.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -19,6 +19,7 @@ LL |     let sr2: Vec<(u32, _, _)> = sr.iter().map(|(faction, th_sender, th_rece\n    |                                                                                       ^^^^^^^ value of type `Vec<(u32, _, _)>` cannot be built from `std::iter::Iterator<Item=()>`\n    |\n    = help: the trait `FromIterator<()>` is not implemented for `Vec<(u32, _, _)>`\n+   = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "8967f49df02a52219cefa8339d8ef4957b0f8789", "filename": "src/test/ui/issues/issue-45801.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-45801.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-45801.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45801.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `Params: Plugin<i32>` is not satisfied\n LL |     req.get_ref::<Params>();\n    |         ^^^^^^^ the trait `Plugin<i32>` is not implemented for `Params`\n    |\n-   = help: the following implementations were found:\n-             <Params as Plugin<Foo>>\n+   = help: the trait `Plugin<Foo>` is implemented for `Params`\n \n error: aborting due to previous error\n "}, {"sha": "3d527eb6b4e4a56ec09a7536af60d3cf364bda5b", "filename": "src/test/ui/issues/issue-50582.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-50582.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-50582.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-50582.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -14,6 +14,16 @@ LL |     Vec::<[(); 1 + for x in 0..1 {}]>::new();\n    |                  ^ no implementation for `{integer} + ()`\n    |\n    = help: the trait `Add<()>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error: aborting due to 2 previous errors\n "}, {"sha": "76a47c49bbafb40be760823fffec771f98d4fc3d", "filename": "src/test/ui/issues/issue-59488.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -94,6 +94,16 @@ LL |     assert_eq!(Foo::Bar, i);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ `fn(usize) -> Foo {Foo::Bar}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for `fn(usize) -> Foo {Foo::Bar}`\n+   = help: the following other types implement trait `Debug`:\n+             extern \"C\" fn() -> Ret\n+             extern \"C\" fn(A) -> Ret\n+             extern \"C\" fn(A, ...) -> Ret\n+             extern \"C\" fn(A, B) -> Ret\n+             extern \"C\" fn(A, B, ...) -> Ret\n+             extern \"C\" fn(A, B, C) -> Ret\n+             extern \"C\" fn(A, B, C, ...) -> Ret\n+             extern \"C\" fn(A, B, C, D) -> Ret\n+           and 68 others\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 9 previous errors"}, {"sha": "d6e39251632ba70c00a626d13bbe99db5660061d", "filename": "src/test/ui/issues/issue-66923-show-error-for-correct-call.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66923-show-error-for-correct-call.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,7 @@ LL |     let x2: Vec<f64> = x1.into_iter().collect();\n    |                                       ^^^^^^^ value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n+   = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |\n@@ -18,6 +19,7 @@ LL |     let x3 = x1.into_iter().collect::<Vec<f64>>();\n    |                             ^^^^^^^ value of type `Vec<f64>` cannot be built from `std::iter::Iterator<Item=&f64>`\n    |\n    = help: the trait `FromIterator<&f64>` is not implemented for `Vec<f64>`\n+   = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n note: required by a bound in `collect`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n    |"}, {"sha": "1c61c85368be9e9f5626eb784e40d22ef52bf470", "filename": "src/test/ui/kindck/kindck-copy.stderr", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fkindck%2Fkindck-copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fkindck%2Fkindck-copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-copy.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,12 +4,16 @@ error[E0277]: the trait bound `&'static mut isize: Copy` is not satisfied\n LL |     assert_copy::<&'static mut isize>();\n    |                   ^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `&'static mut isize`\n    |\n-   = help: the following implementations were found:\n-             <isize as Copy>\n-             <f32 as Copy>\n-             <f64 as Copy>\n-             <i128 as Copy>\n-           and 10 others\n+   = help: the following other types implement trait `Copy`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n note: required by a bound in `assert_copy`\n   --> $DIR/kindck-copy.rs:5:18\n    |\n@@ -22,12 +26,16 @@ error[E0277]: the trait bound `&'a mut isize: Copy` is not satisfied\n LL |     assert_copy::<&'a mut isize>();\n    |                   ^^^^^^^^^^^^^ the trait `Copy` is not implemented for `&'a mut isize`\n    |\n-   = help: the following implementations were found:\n-             <isize as Copy>\n-             <f32 as Copy>\n-             <f64 as Copy>\n-             <i128 as Copy>\n-           and 10 others\n+   = help: the following other types implement trait `Copy`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n note: required by a bound in `assert_copy`\n   --> $DIR/kindck-copy.rs:5:18\n    |"}, {"sha": "94f802620a302856f2ae25cea7c3b12079f601ad", "filename": "src/test/ui/kindck/kindck-impl-type-params.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.nll.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -72,6 +72,7 @@ error[E0277]: the trait bound `String: Copy` is not satisfied\n LL |     let a = t as Box<dyn Gettable<String>>;\n    |             ^ the trait `Copy` is not implemented for `String`\n    |\n+   = help: the trait `Gettable<T>` is implemented for `S<T>`\n note: required because of the requirements on the impl of `Gettable<String>` for `S<String>`\n   --> $DIR/kindck-impl-type-params.rs:14:32\n    |\n@@ -85,6 +86,7 @@ error[E0277]: the trait bound `Foo: Copy` is not satisfied\n LL |     let a: Box<dyn Gettable<Foo>> = t;\n    |                                     ^ the trait `Copy` is not implemented for `Foo`\n    |\n+   = help: the trait `Gettable<T>` is implemented for `S<T>`\n note: required because of the requirements on the impl of `Gettable<Foo>` for `S<Foo>`\n   --> $DIR/kindck-impl-type-params.rs:14:32\n    |"}, {"sha": "64bbc841b330f7dde52328808923eda531321fb9", "filename": "src/test/ui/kindck/kindck-impl-type-params.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fkindck%2Fkindck-impl-type-params.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -80,6 +80,7 @@ error[E0277]: the trait bound `String: Copy` is not satisfied\n LL |     let a = t as Box<dyn Gettable<String>>;\n    |             ^ the trait `Copy` is not implemented for `String`\n    |\n+   = help: the trait `Gettable<T>` is implemented for `S<T>`\n note: required because of the requirements on the impl of `Gettable<String>` for `S<String>`\n   --> $DIR/kindck-impl-type-params.rs:14:32\n    |\n@@ -93,6 +94,7 @@ error[E0277]: the trait bound `Foo: Copy` is not satisfied\n LL |     let a: Box<dyn Gettable<Foo>> = t;\n    |                                     ^ the trait `Copy` is not implemented for `Foo`\n    |\n+   = help: the trait `Gettable<T>` is implemented for `S<T>`\n note: required because of the requirements on the impl of `Gettable<Foo>` for `S<Foo>`\n   --> $DIR/kindck-impl-type-params.rs:14:32\n    |"}, {"sha": "afef0cb603485712c74f5c556b68508b2ecd3da9", "filename": "src/test/ui/lexer/lex-bad-char-literals-6.stderr", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Flexer%2Flex-bad-char-literals-6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Flexer%2Flex-bad-char-literals-6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flexer%2Flex-bad-char-literals-6.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -38,6 +38,16 @@ LL |     if x == y {}\n    |          ^^ no implementation for `&str == char`\n    |\n    = help: the trait `PartialEq<char>` is not implemented for `&str`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             <&'a str as PartialEq<OsString>>\n+             <&'a str as PartialEq<String>>\n+             <&'b str as PartialEq<Cow<'a, str>>>\n+             <String as PartialEq<&'a str>>\n+             <String as PartialEq<Cow<'a, str>>>\n+             <String as PartialEq<str>>\n+             <String as PartialEq>\n+             <str as PartialEq<Cow<'a, str>>>\n+           and 4 others\n \n error[E0308]: mismatched types\n   --> $DIR/lex-bad-char-literals-6.rs:15:20\n@@ -54,6 +64,16 @@ LL |     if x == z {}\n    |          ^^ no implementation for `&str == char`\n    |\n    = help: the trait `PartialEq<char>` is not implemented for `&str`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             <&'a str as PartialEq<OsString>>\n+             <&'a str as PartialEq<String>>\n+             <&'b str as PartialEq<Cow<'a, str>>>\n+             <String as PartialEq<&'a str>>\n+             <String as PartialEq<Cow<'a, str>>>\n+             <String as PartialEq<str>>\n+             <String as PartialEq>\n+             <str as PartialEq<Cow<'a, str>>>\n+           and 4 others\n \n error: aborting due to 6 previous errors\n "}, {"sha": "3de652d87ec543e27b11ffc2fb7a8e0b35667d0b", "filename": "src/test/ui/mismatched_types/binops.stderr", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fbinops.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     1 + Some(1);\n    |       ^ no implementation for `{integer} + Option<{integer}>`\n    |\n    = help: the trait `Add<Option<{integer}>>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error[E0277]: cannot subtract `Option<{integer}>` from `usize`\n   --> $DIR/binops.rs:3:16\n@@ -13,6 +23,16 @@ LL |     2 as usize - Some(1);\n    |                ^ no implementation for `usize - Option<{integer}>`\n    |\n    = help: the trait `Sub<Option<{integer}>>` is not implemented for `usize`\n+   = help: the following other types implement trait `Sub<Rhs>`:\n+             <&'a f32 as Sub<f32>>\n+             <&'a f64 as Sub<f64>>\n+             <&'a i128 as Sub<i128>>\n+             <&'a i16 as Sub<i16>>\n+             <&'a i32 as Sub<i32>>\n+             <&'a i64 as Sub<i64>>\n+             <&'a i8 as Sub<i8>>\n+             <&'a isize as Sub<isize>>\n+           and 48 others\n \n error[E0277]: cannot multiply `{integer}` by `()`\n   --> $DIR/binops.rs:4:7\n@@ -21,6 +41,16 @@ LL |     3 * ();\n    |       ^ no implementation for `{integer} * ()`\n    |\n    = help: the trait `Mul<()>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `Mul<Rhs>`:\n+             <&'a f32 as Mul<f32>>\n+             <&'a f64 as Mul<f64>>\n+             <&'a i128 as Mul<i128>>\n+             <&'a i16 as Mul<i16>>\n+             <&'a i32 as Mul<i32>>\n+             <&'a i64 as Mul<i64>>\n+             <&'a i8 as Mul<i8>>\n+             <&'a isize as Mul<isize>>\n+           and 49 others\n \n error[E0277]: cannot divide `{integer}` by `&str`\n   --> $DIR/binops.rs:5:7\n@@ -29,6 +59,16 @@ LL |     4 / \"\";\n    |       ^ no implementation for `{integer} / &str`\n    |\n    = help: the trait `Div<&str>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `Div<Rhs>`:\n+             <&'a f32 as Div<f32>>\n+             <&'a f64 as Div<f64>>\n+             <&'a i128 as Div<i128>>\n+             <&'a i16 as Div<i16>>\n+             <&'a i32 as Div<i32>>\n+             <&'a i64 as Div<i64>>\n+             <&'a i8 as Div<i8>>\n+             <&'a isize as Div<isize>>\n+           and 54 others\n \n error[E0277]: can't compare `{integer}` with `String`\n   --> $DIR/binops.rs:6:7\n@@ -37,6 +77,16 @@ LL |     5 < String::new();\n    |       ^ no implementation for `{integer} < String` and `{integer} > String`\n    |\n    = help: the trait `PartialOrd<String>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `PartialOrd<Rhs>`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n \n error[E0277]: can't compare `{integer}` with `Result<{integer}, _>`\n   --> $DIR/binops.rs:7:7\n@@ -45,6 +95,16 @@ LL |     6 == Ok(1);\n    |       ^^ no implementation for `{integer} == Result<{integer}, _>`\n    |\n    = help: the trait `PartialEq<Result<{integer}, _>>` is not implemented for `{integer}`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n \n error: aborting due to 6 previous errors\n "}, {"sha": "4c8b492247352ef5d690c79d29e3913696d93b61", "filename": "src/test/ui/never_type/defaulted-never-note.fallback.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.fallback.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the trait bound `!: ImplementedForUnitButNotNever` is not satisfie\n LL |     foo(_x);\n    |     ^^^ the trait `ImplementedForUnitButNotNever` is not implemented for `!`\n    |\n-   = note: this trait is implemented for `()`\n+   = help: the trait `ImplementedForUnitButNotNever` is implemented for `()`\n    = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information)\n    = help: did you intend to use the type `()` here instead?\n note: required by a bound in `foo`"}, {"sha": "aefc739a0a0b0a41d8233e8cf6adcc4452d4db34", "filename": "src/test/ui/never_type/defaulted-never-note.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdefaulted-never-note.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -30,7 +30,7 @@ fn smeg() {\n     foo(_x);\n     //[fallback]~^ ERROR the trait bound\n     //[fallback]~| NOTE the trait `ImplementedForUnitButNotNever` is not implemented\n-    //[fallback]~| NOTE this trait is implemented for `()`\n+    //[fallback]~| HELP trait `ImplementedForUnitButNotNever` is implemented for `()`\n     //[fallback]~| NOTE this error might have been caused\n     //[fallback]~| HELP did you intend\n }"}, {"sha": "dee2b1d704b8663c8bd37f1c3a694c948c7145bb", "filename": "src/test/ui/never_type/diverging-fallback-no-leak.fallback.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fdiverging-fallback-no-leak.fallback.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,7 +4,9 @@ error[E0277]: the trait bound `!: Test` is not satisfied\n LL |     unconstrained_arg(return);\n    |     ^^^^^^^^^^^^^^^^^ the trait `Test` is not implemented for `!`\n    |\n-   = note: this trait is implemented for `()`\n+   = help: the following other types implement trait `Test`:\n+             ()\n+             i32\n    = note: this error might have been caused by changes to Rust's type-inference algorithm (see issue #48950 <https://github.com/rust-lang/rust/issues/48950> for more information)\n    = help: did you intend to use the type `()` here instead?\n note: required by a bound in `unconstrained_arg`"}, {"sha": "4a78e73e5f6d593f592de93010ac814907c0231d", "filename": "src/test/ui/never_type/impl_trait_fallback2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fimpl_trait_fallback2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -3,6 +3,8 @@ error[E0277]: the trait bound `(): T` is not satisfied\n    |\n LL | fn should_ret_unit() -> impl T {\n    |                         ^^^^^^ the trait `T` is not implemented for `()`\n+   |\n+   = help: the trait `T` is implemented for `i32`\n \n error: aborting due to previous error\n "}, {"sha": "fed780e68957f903a1ca1cb77e8308e627354620", "filename": "src/test/ui/never_type/issue-13352.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fissue-13352.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fissue-13352.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-13352.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     2_usize + (loop {});\n    |             ^ no implementation for `usize + ()`\n    |\n    = help: the trait `Add<()>` is not implemented for `usize`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error: aborting due to previous error\n "}, {"sha": "e2045591390e1717ef21c0a9c923282048375fa9", "filename": "src/test/ui/never_type/never-value-fallback-issue-66757.nofallback.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.nofallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.nofallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-value-fallback-issue-66757.nofallback.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `E: From<()>` is not satisfied\n LL |     <E as From<_>>::from(never);\n    |     ^^^^^^^^^^^^^^^^^^^^ the trait `From<()>` is not implemented for `E`\n    |\n-   = help: the following implementations were found:\n-             <E as From<!>>\n+   = help: the trait `From<!>` is implemented for `E`\n \n error: aborting due to previous error\n "}, {"sha": "6aa1ad8dd899f906dbcc5d85ae64b0f299b1b3c3", "filename": "src/test/ui/numbers-arithmetic/not-suggest-float-literal.stderr", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnot-suggest-float-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnot-suggest-float-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fnot-suggest-float-literal.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     x + 100.0\n    |       ^ no implementation for `u8 + {float}`\n    |\n    = help: the trait `Add<{float}>` is not implemented for `u8`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error[E0277]: cannot add `&str` to `f64`\n   --> $DIR/not-suggest-float-literal.rs:6:7\n@@ -13,6 +23,16 @@ LL |     x + \"foo\"\n    |       ^ no implementation for `f64 + &str`\n    |\n    = help: the trait `Add<&str>` is not implemented for `f64`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error[E0277]: cannot add `{integer}` to `f64`\n   --> $DIR/not-suggest-float-literal.rs:11:7\n@@ -21,6 +41,16 @@ LL |     x + y\n    |       ^ no implementation for `f64 + {integer}`\n    |\n    = help: the trait `Add<{integer}>` is not implemented for `f64`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error[E0277]: cannot subtract `{float}` from `u8`\n   --> $DIR/not-suggest-float-literal.rs:15:7\n@@ -29,6 +59,16 @@ LL |     x - 100.0\n    |       ^ no implementation for `u8 - {float}`\n    |\n    = help: the trait `Sub<{float}>` is not implemented for `u8`\n+   = help: the following other types implement trait `Sub<Rhs>`:\n+             <&'a f32 as Sub<f32>>\n+             <&'a f64 as Sub<f64>>\n+             <&'a i128 as Sub<i128>>\n+             <&'a i16 as Sub<i16>>\n+             <&'a i32 as Sub<i32>>\n+             <&'a i64 as Sub<i64>>\n+             <&'a i8 as Sub<i8>>\n+             <&'a isize as Sub<isize>>\n+           and 48 others\n \n error[E0277]: cannot subtract `&str` from `f64`\n   --> $DIR/not-suggest-float-literal.rs:19:7\n@@ -37,6 +77,16 @@ LL |     x - \"foo\"\n    |       ^ no implementation for `f64 - &str`\n    |\n    = help: the trait `Sub<&str>` is not implemented for `f64`\n+   = help: the following other types implement trait `Sub<Rhs>`:\n+             <&'a f32 as Sub<f32>>\n+             <&'a f64 as Sub<f64>>\n+             <&'a i128 as Sub<i128>>\n+             <&'a i16 as Sub<i16>>\n+             <&'a i32 as Sub<i32>>\n+             <&'a i64 as Sub<i64>>\n+             <&'a i8 as Sub<i8>>\n+             <&'a isize as Sub<isize>>\n+           and 48 others\n \n error[E0277]: cannot subtract `{integer}` from `f64`\n   --> $DIR/not-suggest-float-literal.rs:24:7\n@@ -45,6 +95,16 @@ LL |     x - y\n    |       ^ no implementation for `f64 - {integer}`\n    |\n    = help: the trait `Sub<{integer}>` is not implemented for `f64`\n+   = help: the following other types implement trait `Sub<Rhs>`:\n+             <&'a f32 as Sub<f32>>\n+             <&'a f64 as Sub<f64>>\n+             <&'a i128 as Sub<i128>>\n+             <&'a i16 as Sub<i16>>\n+             <&'a i32 as Sub<i32>>\n+             <&'a i64 as Sub<i64>>\n+             <&'a i8 as Sub<i8>>\n+             <&'a isize as Sub<isize>>\n+           and 48 others\n \n error[E0277]: cannot multiply `u8` by `{float}`\n   --> $DIR/not-suggest-float-literal.rs:28:7\n@@ -53,6 +113,16 @@ LL |     x * 100.0\n    |       ^ no implementation for `u8 * {float}`\n    |\n    = help: the trait `Mul<{float}>` is not implemented for `u8`\n+   = help: the following other types implement trait `Mul<Rhs>`:\n+             <&'a f32 as Mul<f32>>\n+             <&'a f64 as Mul<f64>>\n+             <&'a i128 as Mul<i128>>\n+             <&'a i16 as Mul<i16>>\n+             <&'a i32 as Mul<i32>>\n+             <&'a i64 as Mul<i64>>\n+             <&'a i8 as Mul<i8>>\n+             <&'a isize as Mul<isize>>\n+           and 49 others\n \n error[E0277]: cannot multiply `f64` by `&str`\n   --> $DIR/not-suggest-float-literal.rs:32:7\n@@ -61,6 +131,16 @@ LL |     x * \"foo\"\n    |       ^ no implementation for `f64 * &str`\n    |\n    = help: the trait `Mul<&str>` is not implemented for `f64`\n+   = help: the following other types implement trait `Mul<Rhs>`:\n+             <&'a f32 as Mul<f32>>\n+             <&'a f64 as Mul<f64>>\n+             <&'a i128 as Mul<i128>>\n+             <&'a i16 as Mul<i16>>\n+             <&'a i32 as Mul<i32>>\n+             <&'a i64 as Mul<i64>>\n+             <&'a i8 as Mul<i8>>\n+             <&'a isize as Mul<isize>>\n+           and 49 others\n \n error[E0277]: cannot multiply `f64` by `{integer}`\n   --> $DIR/not-suggest-float-literal.rs:37:7\n@@ -69,6 +149,16 @@ LL |     x * y\n    |       ^ no implementation for `f64 * {integer}`\n    |\n    = help: the trait `Mul<{integer}>` is not implemented for `f64`\n+   = help: the following other types implement trait `Mul<Rhs>`:\n+             <&'a f32 as Mul<f32>>\n+             <&'a f64 as Mul<f64>>\n+             <&'a i128 as Mul<i128>>\n+             <&'a i16 as Mul<i16>>\n+             <&'a i32 as Mul<i32>>\n+             <&'a i64 as Mul<i64>>\n+             <&'a i8 as Mul<i8>>\n+             <&'a isize as Mul<isize>>\n+           and 49 others\n \n error[E0277]: cannot divide `u8` by `{float}`\n   --> $DIR/not-suggest-float-literal.rs:41:7\n@@ -77,6 +167,16 @@ LL |     x / 100.0\n    |       ^ no implementation for `u8 / {float}`\n    |\n    = help: the trait `Div<{float}>` is not implemented for `u8`\n+   = help: the following other types implement trait `Div<Rhs>`:\n+             <&'a f32 as Div<f32>>\n+             <&'a f64 as Div<f64>>\n+             <&'a i128 as Div<i128>>\n+             <&'a i16 as Div<i16>>\n+             <&'a i32 as Div<i32>>\n+             <&'a i64 as Div<i64>>\n+             <&'a i8 as Div<i8>>\n+             <&'a isize as Div<isize>>\n+           and 54 others\n \n error[E0277]: cannot divide `f64` by `&str`\n   --> $DIR/not-suggest-float-literal.rs:45:7\n@@ -85,6 +185,16 @@ LL |     x / \"foo\"\n    |       ^ no implementation for `f64 / &str`\n    |\n    = help: the trait `Div<&str>` is not implemented for `f64`\n+   = help: the following other types implement trait `Div<Rhs>`:\n+             <&'a f32 as Div<f32>>\n+             <&'a f64 as Div<f64>>\n+             <&'a i128 as Div<i128>>\n+             <&'a i16 as Div<i16>>\n+             <&'a i32 as Div<i32>>\n+             <&'a i64 as Div<i64>>\n+             <&'a i8 as Div<i8>>\n+             <&'a isize as Div<isize>>\n+           and 54 others\n \n error[E0277]: cannot divide `f64` by `{integer}`\n   --> $DIR/not-suggest-float-literal.rs:50:7\n@@ -93,6 +203,16 @@ LL |     x / y\n    |       ^ no implementation for `f64 / {integer}`\n    |\n    = help: the trait `Div<{integer}>` is not implemented for `f64`\n+   = help: the following other types implement trait `Div<Rhs>`:\n+             <&'a f32 as Div<f32>>\n+             <&'a f64 as Div<f64>>\n+             <&'a i128 as Div<i128>>\n+             <&'a i16 as Div<i16>>\n+             <&'a i32 as Div<i32>>\n+             <&'a i64 as Div<i64>>\n+             <&'a i8 as Div<i8>>\n+             <&'a isize as Div<isize>>\n+           and 54 others\n \n error: aborting due to 12 previous errors\n "}, {"sha": "988379e582a3476779d295890e952c1eca0c752a", "filename": "src/test/ui/numbers-arithmetic/suggest-float-literal.stderr", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsuggest-float-literal.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     x + 100\n    |       ^ no implementation for `f32 + {integer}`\n    |\n    = help: the trait `Add<{integer}>` is not implemented for `f32`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     x + 100.0\n@@ -17,6 +27,16 @@ LL |     x + 100\n    |       ^ no implementation for `f64 + {integer}`\n    |\n    = help: the trait `Add<{integer}>` is not implemented for `f64`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     x + 100.0\n@@ -29,6 +49,16 @@ LL |     x - 100\n    |       ^ no implementation for `f32 - {integer}`\n    |\n    = help: the trait `Sub<{integer}>` is not implemented for `f32`\n+   = help: the following other types implement trait `Sub<Rhs>`:\n+             <&'a f32 as Sub<f32>>\n+             <&'a f64 as Sub<f64>>\n+             <&'a i128 as Sub<i128>>\n+             <&'a i16 as Sub<i16>>\n+             <&'a i32 as Sub<i32>>\n+             <&'a i64 as Sub<i64>>\n+             <&'a i8 as Sub<i8>>\n+             <&'a isize as Sub<isize>>\n+           and 48 others\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     x - 100.0\n@@ -41,6 +71,16 @@ LL |     x - 100\n    |       ^ no implementation for `f64 - {integer}`\n    |\n    = help: the trait `Sub<{integer}>` is not implemented for `f64`\n+   = help: the following other types implement trait `Sub<Rhs>`:\n+             <&'a f32 as Sub<f32>>\n+             <&'a f64 as Sub<f64>>\n+             <&'a i128 as Sub<i128>>\n+             <&'a i16 as Sub<i16>>\n+             <&'a i32 as Sub<i32>>\n+             <&'a i64 as Sub<i64>>\n+             <&'a i8 as Sub<i8>>\n+             <&'a isize as Sub<isize>>\n+           and 48 others\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     x - 100.0\n@@ -53,6 +93,16 @@ LL |     x * 100\n    |       ^ no implementation for `f32 * {integer}`\n    |\n    = help: the trait `Mul<{integer}>` is not implemented for `f32`\n+   = help: the following other types implement trait `Mul<Rhs>`:\n+             <&'a f32 as Mul<f32>>\n+             <&'a f64 as Mul<f64>>\n+             <&'a i128 as Mul<i128>>\n+             <&'a i16 as Mul<i16>>\n+             <&'a i32 as Mul<i32>>\n+             <&'a i64 as Mul<i64>>\n+             <&'a i8 as Mul<i8>>\n+             <&'a isize as Mul<isize>>\n+           and 49 others\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     x * 100.0\n@@ -65,6 +115,16 @@ LL |     x * 100\n    |       ^ no implementation for `f64 * {integer}`\n    |\n    = help: the trait `Mul<{integer}>` is not implemented for `f64`\n+   = help: the following other types implement trait `Mul<Rhs>`:\n+             <&'a f32 as Mul<f32>>\n+             <&'a f64 as Mul<f64>>\n+             <&'a i128 as Mul<i128>>\n+             <&'a i16 as Mul<i16>>\n+             <&'a i32 as Mul<i32>>\n+             <&'a i64 as Mul<i64>>\n+             <&'a i8 as Mul<i8>>\n+             <&'a isize as Mul<isize>>\n+           and 49 others\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     x * 100.0\n@@ -77,6 +137,16 @@ LL |     x / 100\n    |       ^ no implementation for `f32 / {integer}`\n    |\n    = help: the trait `Div<{integer}>` is not implemented for `f32`\n+   = help: the following other types implement trait `Div<Rhs>`:\n+             <&'a f32 as Div<f32>>\n+             <&'a f64 as Div<f64>>\n+             <&'a i128 as Div<i128>>\n+             <&'a i16 as Div<i16>>\n+             <&'a i32 as Div<i32>>\n+             <&'a i64 as Div<i64>>\n+             <&'a i8 as Div<i8>>\n+             <&'a isize as Div<isize>>\n+           and 54 others\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     x / 100.0\n@@ -89,6 +159,16 @@ LL |     x / 100\n    |       ^ no implementation for `f64 / {integer}`\n    |\n    = help: the trait `Div<{integer}>` is not implemented for `f64`\n+   = help: the following other types implement trait `Div<Rhs>`:\n+             <&'a f32 as Div<f32>>\n+             <&'a f64 as Div<f64>>\n+             <&'a i128 as Div<i128>>\n+             <&'a i16 as Div<i16>>\n+             <&'a i32 as Div<i32>>\n+             <&'a i64 as Div<i64>>\n+             <&'a i8 as Div<i8>>\n+             <&'a isize as Div<isize>>\n+           and 54 others\n help: consider using a floating-point literal by writing it with `.0`\n    |\n LL |     x / 100.0"}, {"sha": "a0fad0acd0b5ceb10428e9e8982c2aeb30670d39", "filename": "src/test/ui/on-unimplemented/impl-substs.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fon-unimplemented%2Fimpl-substs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fon-unimplemented%2Fimpl-substs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fimpl-substs.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -7,6 +7,7 @@ LL |     Foo::<usize>::foo((1i32, 1i32, 1i32));\n    |     required by a bound introduced by this call\n    |\n    = help: the trait `Foo<usize>` is not implemented for `(i32, i32, i32)`\n+   = help: the trait `Foo<A>` is implemented for `(A, B, C)`\n \n error: aborting due to previous error\n "}, {"sha": "06e1a222af88135cf3ea809c22ad22c2e73c2a86", "filename": "src/test/ui/on-unimplemented/multiple-impls.stderr", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fon-unimplemented%2Fmultiple-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fon-unimplemented%2Fmultiple-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fmultiple-impls.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -7,6 +7,9 @@ LL |     Index::index(&[] as &[i32], 2u32);\n    |     required by a bound introduced by this call\n    |\n    = help: the trait `Index<u32>` is not implemented for `[i32]`\n+   = help: the following other types implement trait `Index<Idx>`:\n+             <[i32] as Index<Bar<usize>>>\n+             <[i32] as Index<Foo<usize>>>\n \n error[E0277]: the trait bound `[i32]: Index<Foo<u32>>` is not satisfied\n   --> $DIR/multiple-impls.rs:36:18\n@@ -17,6 +20,9 @@ LL |     Index::index(&[] as &[i32], Foo(2u32));\n    |     required by a bound introduced by this call\n    |\n    = help: the trait `Index<Foo<u32>>` is not implemented for `[i32]`\n+   = help: the following other types implement trait `Index<Idx>`:\n+             <[i32] as Index<Bar<usize>>>\n+             <[i32] as Index<Foo<usize>>>\n \n error[E0277]: the trait bound `[i32]: Index<Bar<u32>>` is not satisfied\n   --> $DIR/multiple-impls.rs:39:18\n@@ -27,6 +33,9 @@ LL |     Index::index(&[] as &[i32], Bar(2u32));\n    |     required by a bound introduced by this call\n    |\n    = help: the trait `Index<Bar<u32>>` is not implemented for `[i32]`\n+   = help: the following other types implement trait `Index<Idx>`:\n+             <[i32] as Index<Bar<usize>>>\n+             <[i32] as Index<Foo<usize>>>\n \n error[E0277]: the trait bound `[i32]: Index<u32>` is not satisfied\n   --> $DIR/multiple-impls.rs:33:5\n@@ -35,6 +44,9 @@ LL |     Index::index(&[] as &[i32], 2u32);\n    |     ^^^^^^^^^^^^ trait message\n    |\n    = help: the trait `Index<u32>` is not implemented for `[i32]`\n+   = help: the following other types implement trait `Index<Idx>`:\n+             <[i32] as Index<Bar<usize>>>\n+             <[i32] as Index<Foo<usize>>>\n \n error[E0277]: the trait bound `[i32]: Index<Foo<u32>>` is not satisfied\n   --> $DIR/multiple-impls.rs:36:5\n@@ -43,6 +55,9 @@ LL |     Index::index(&[] as &[i32], Foo(2u32));\n    |     ^^^^^^^^^^^^ on impl for Foo\n    |\n    = help: the trait `Index<Foo<u32>>` is not implemented for `[i32]`\n+   = help: the following other types implement trait `Index<Idx>`:\n+             <[i32] as Index<Bar<usize>>>\n+             <[i32] as Index<Foo<usize>>>\n \n error[E0277]: the trait bound `[i32]: Index<Bar<u32>>` is not satisfied\n   --> $DIR/multiple-impls.rs:39:5\n@@ -51,6 +66,9 @@ LL |     Index::index(&[] as &[i32], Bar(2u32));\n    |     ^^^^^^^^^^^^ on impl for Bar\n    |\n    = help: the trait `Index<Bar<u32>>` is not implemented for `[i32]`\n+   = help: the following other types implement trait `Index<Idx>`:\n+             <[i32] as Index<Bar<usize>>>\n+             <[i32] as Index<Foo<usize>>>\n \n error: aborting due to 6 previous errors\n "}, {"sha": "769a3d77a5726bcd9e78429a7aa17ac5719c7410", "filename": "src/test/ui/on-unimplemented/on-impl.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fon-impl.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -7,6 +7,7 @@ LL |     Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32);\n    |     required by a bound introduced by this call\n    |\n    = help: the trait `Index<u32>` is not implemented for `[i32]`\n+   = help: the trait `Index<usize>` is implemented for `[i32]`\n \n error[E0277]: the trait bound `[i32]: Index<u32>` is not satisfied\n   --> $DIR/on-impl.rs:22:5\n@@ -15,6 +16,7 @@ LL |     Index::<u32>::index(&[1, 2, 3] as &[i32], 2u32);\n    |     ^^^^^^^^^^^^^^^^^^^ a usize is required to index into a slice\n    |\n    = help: the trait `Index<u32>` is not implemented for `[i32]`\n+   = help: the trait `Index<usize>` is implemented for `[i32]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ae7d2e1d8239330fd53b61f7f63a89b82366d4a6", "filename": "src/test/ui/on-unimplemented/slice-index.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fon-unimplemented%2Fslice-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fon-unimplemented%2Fslice-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fslice-index.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,7 @@ LL |     x[1i32];\n    |     ^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `i32`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<i32>` for `[i32]`\n \n error[E0277]: the type `[i32]` cannot be indexed by `RangeTo<i32>`\n@@ -14,6 +15,9 @@ LL |     x[..1i32];\n    |     ^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |\n    = help: the trait `SliceIndex<[i32]>` is not implemented for `RangeTo<i32>`\n+   = help: the following other types implement trait `SliceIndex<T>`:\n+             <RangeTo<usize> as SliceIndex<[T]>>\n+             <RangeTo<usize> as SliceIndex<str>>\n    = note: required because of the requirements on the impl of `Index<RangeTo<i32>>` for `[i32]`\n \n error: aborting due to 2 previous errors"}, {"sha": "0bbed8704243fa735da45fb8064a1635e95c2cc9", "filename": "src/test/ui/range/range-1.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Frange%2Frange-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange%2Frange-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -10,6 +10,16 @@ error[E0277]: the trait bound `bool: Step` is not satisfied\n LL |     for i in false..true {}\n    |              ^^^^^^^^^^^ the trait `Step` is not implemented for `bool`\n    |\n+   = help: the following other types implement trait `Step`:\n+             char\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+             u128\n+           and 5 others\n    = note: required because of the requirements on the impl of `Iterator` for `std::ops::Range<bool>`\n    = note: required because of the requirements on the impl of `IntoIterator` for `std::ops::Range<bool>`\n "}, {"sha": "96a899ecca581c929ca1d7fa19837e99d7acf6bc", "filename": "src/test/ui/rfc-1937-termination-trait/termination-trait-test-wrong-type.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -9,6 +9,10 @@ LL | | }\n    | |_^ `main` can only return types that implement `Termination`\n    |\n    = help: the trait `Termination` is not implemented for `Result<f32, ParseFloatError>`\n+   = help: the following other types implement trait `Termination`:\n+             Result<!, E>\n+             Result<(), E>\n+             Result<Infallible, E>\n note: required by a bound in `assert_test_result`\n   --> $SRC_DIR/test/src/lib.rs:LL:COL\n    |"}, {"sha": "c0d9a8634e487db79f1e17eadda101baae793f1a", "filename": "src/test/ui/span/multiline-span-simple.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmultiline-span-simple.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     foo(1 as u32 +\n    |                  ^ no implementation for `u32 + ()`\n    |\n    = help: the trait `Add<()>` is not implemented for `u32`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error: aborting due to previous error\n "}, {"sha": "af9f2f7c2e9a694d83839026be304af1e1486457", "filename": "src/test/ui/specialization/default-associated-type-bound-1.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -14,8 +14,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     default type U = str;\n    |                      ^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `X::U`\n   --> $DIR/default-associated-type-bound-1.rs:8:13\n    |"}, {"sha": "45450788b9cbd32084b84ba72a025b787a2a339c", "filename": "src/test/ui/str/str-idx.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-idx.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -7,6 +7,7 @@ LL |     let _: u8 = s[4];\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<{integer}>` for `str`\n \n error[E0277]: the type `str` cannot be indexed by `{integer}`\n@@ -20,6 +21,7 @@ LL |     let _ = s.get(4);\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n note: required by a bound in `core::str::<impl str>::get`\n   --> $SRC_DIR/core/src/str/mod.rs:LL:COL\n    |\n@@ -37,6 +39,7 @@ LL |     let _ = s.get_unchecked(4);\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n note: required by a bound in `core::str::<impl str>::get_unchecked`\n   --> $SRC_DIR/core/src/str/mod.rs:LL:COL\n    |"}, {"sha": "9ae085630279ec9e69b3720db0e298c79f1c0291", "filename": "src/test/ui/str/str-mut-idx.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstr%2Fstr-mut-idx.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -31,6 +31,7 @@ LL |     s[1usize] = bot();\n    |     ^^^^^^^^^ string indices are ranges of `usize`\n    |\n    = help: the trait `SliceIndex<str>` is not implemented for `usize`\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n    = note: required because of the requirements on the impl of `Index<usize>` for `str`\n \n error[E0277]: the type `str` cannot be indexed by `{integer}`\n@@ -44,6 +45,7 @@ LL |     s.get_mut(1);\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n note: required by a bound in `core::str::<impl str>::get_mut`\n   --> $SRC_DIR/core/src/str/mod.rs:LL:COL\n    |\n@@ -61,6 +63,7 @@ LL |     s.get_unchecked_mut(1);\n    = help: the trait `SliceIndex<str>` is not implemented for `{integer}`\n    = note: you can use `.chars().nth()` or `.bytes().nth()`\n            for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n+   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n note: required by a bound in `core::str::<impl str>::get_unchecked_mut`\n   --> $SRC_DIR/core/src/str/mod.rs:LL:COL\n    |"}, {"sha": "0783f04dc9bd3c5583c1f851548f5996e6d5e5aa", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal-bound-regions.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal-bound-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal-bound-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal-bound-regions.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `for<'b> &'b S: Trait` is not satisfied\n LL |     foo::<S>(s);\n    |     ^^^^^^^^ the trait `for<'b> Trait` is not implemented for `&'b S`\n    |\n-   = help: the following implementations were found:\n-             <&'a mut S as Trait>\n+   = help: the trait `Trait` is implemented for `&'a mut S`\n note: required by a bound in `foo`\n   --> $DIR/imm-ref-trait-object-literal-bound-regions.rs:11:20\n    |"}, {"sha": "5f3f62a7b7570b4107e5c7ce7569ca5d2d036468", "filename": "src/test/ui/suggestions/imm-ref-trait-object-literal.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimm-ref-trait-object-literal.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,8 +6,7 @@ LL |   foo(&s);\n    |   |\n    |   required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n-             <&'a mut S as Trait>\n+   = help: the trait `Trait` is implemented for `&'a mut S`\n note: required by a bound in `foo`\n   --> $DIR/imm-ref-trait-object-literal.rs:7:11\n    |"}, {"sha": "0de765588e5b77dfe3b757681bda6d7d9932f6e3", "filename": "src/test/ui/suggestions/impl-trait-return-trailing-semicolon.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fimpl-trait-return-trailing-semicolon.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -15,6 +15,8 @@ LL | |     5;\n LL | |\n LL | | }\n    | |_^ the trait `Bar` is not implemented for `()`\n+   |\n+   = help: the trait `Bar` is implemented for `u8`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8ae5c84794734d1d2adf00f8a7b1d3a54ed51937", "filename": "src/test/ui/suggestions/into-str.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finto-str.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -7,12 +7,13 @@ LL |     foo(String::new());\n    |     required by a bound introduced by this call\n    |\n    = note: to coerce a `String` into a `&str`, use `&*` as a prefix\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `From<T>`:\n              <String as From<&String>>\n              <String as From<&mut str>>\n              <String as From<&str>>\n              <String as From<Box<str>>>\n-           and 2 others\n+             <String as From<Cow<'a, str>>>\n+             <String as From<char>>\n    = note: required because of the requirements on the impl of `Into<&str>` for `String`\n note: required by a bound in `foo`\n   --> $DIR/into-str.rs:1:31"}, {"sha": "383f40d47fa44ebf04de0947723d6bd43397e724", "filename": "src/test/ui/suggestions/issue-71394-no-from-impl.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-71394-no-from-impl.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the trait bound `&[i8]: From<&[u8]>` is not satisfied\n LL |     let _: &[i8] = data.into();\n    |                         ^^^^ the trait `From<&[u8]>` is not implemented for `&[i8]`\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `From<T>`:\n              <[T; LANES] as From<Simd<T, LANES>>>\n              <[bool; LANES] as From<Mask<T, LANES>>>\n    = note: required because of the requirements on the impl of `Into<&[i8]>` for `&[u8]`"}, {"sha": "15559d4ae2c2f68893e928acc390ece02510ab6d", "filename": "src/test/ui/suggestions/issue-84973-negative.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-84973-negative.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,8 +6,7 @@ LL |     bar(a);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n-             <&f32 as Tr>\n+   = help: the trait `Tr` is implemented for `&f32`\n note: required by a bound in `bar`\n   --> $DIR/issue-84973-negative.rs:5:11\n    |"}, {"sha": "bfbbe7fd25702b137c24df2c62af1f7998f793ef", "filename": "src/test/ui/traits/associated_type_bound/check-trait-object-bounds-1.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     f::<dyn X<Y = str>>();\n    |     ^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `f`\n   --> $DIR/check-trait-object-bounds-1.rs:7:9\n    |"}, {"sha": "3ca36d5d2ff197e0439b37dc92e558b16809939a", "filename": "src/test/ui/traits/associated_type_bound/check-trait-object-bounds-4.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fassociated_type_bound%2Fcheck-trait-object-bounds-4.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `str: Clone` is not satisfied\n LL |     f::<dyn X<Y = str>>();\n    |     ^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `str`\n    |\n-   = help: the following implementations were found:\n-             <String as Clone>\n+   = help: the trait `Clone` is implemented for `String`\n note: required by a bound in `f`\n   --> $DIR/check-trait-object-bounds-4.rs:10:9\n    |"}, {"sha": "1d234518056fd309e8650f8e0ee568381887e604", "filename": "src/test/ui/traits/bound/assoc-fn-bound-root-obligation.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fassoc-fn-bound-root-obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fassoc-fn-bound-root-obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fassoc-fn-bound-root-obligation.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,12 @@\n+fn strip_lf(s: &str) -> &str {\n+    s.strip_suffix(b'\\n').unwrap_or(s)\n+    //~^ ERROR expected a `FnMut<(char,)>` closure, found `u8`\n+    //~| NOTE expected an `FnMut<(char,)>` closure, found `u8`\n+    //~| NOTE required by a bound introduced by this call\n+    //~| HELP the trait `FnMut<(char,)>` is not implemented for `u8`\n+    //~| HELP the following other types implement trait `Pattern<'a>`:\n+    //~| NOTE required because of the requirements on the impl of `Pattern<'_>` for `u8`\n+\n+}\n+\n+fn main() {}"}, {"sha": "115539a6dc28d9cd083bee7f273f94d865436637", "filename": "src/test/ui/traits/bound/assoc-fn-bound-root-obligation.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fassoc-fn-bound-root-obligation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fassoc-fn-bound-root-obligation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fassoc-fn-bound-root-obligation.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,23 @@\n+error[E0277]: expected a `FnMut<(char,)>` closure, found `u8`\n+  --> $DIR/assoc-fn-bound-root-obligation.rs:2:20\n+   |\n+LL |     s.strip_suffix(b'\\n').unwrap_or(s)\n+   |       ------------ ^^^^^ expected an `FnMut<(char,)>` closure, found `u8`\n+   |       |\n+   |       required by a bound introduced by this call\n+   |\n+   = help: the trait `FnMut<(char,)>` is not implemented for `u8`\n+   = help: the following other types implement trait `Pattern<'a>`:\n+             &'b String\n+             &'b [char; N]\n+             &'b [char]\n+             &'b str\n+             &'c &'b str\n+             [char; N]\n+             char\n+             pattern::MultiCharEqPattern<C>\n+   = note: required because of the requirements on the impl of `Pattern<'_>` for `u8`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8d646a414599c1264922f3b951128d22ff7f5725", "filename": "src/test/ui/traits/bound/same-crate-name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fsame-crate-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fsame-crate-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fsame-crate-name.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -50,6 +50,6 @@ fn main() {\n         // impls for the correct trait where the path is not misleading.\n         a::try_foo(other_variant_implements_correct_trait);\n         //~^ ERROR E0277\n-        //~| the following implementations were found:\n+        //~| the trait `main::a::Bar` is implemented for `ImplementsTraitForUsize<usize>`\n     }\n }"}, {"sha": "ef39a70066db622077178a7e123dc96756681397", "filename": "src/test/ui/traits/bound/same-crate-name.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fsame-crate-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fsame-crate-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fbound%2Fsame-crate-name.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -12,6 +12,7 @@ help: trait impl with same name found\n LL | impl Bar for Foo {}\n    | ^^^^^^^^^^^^^^^^^^^\n    = note: perhaps two different versions of crate `crate_a2` are being used?\n+   = help: the trait `main::a::Bar` is implemented for `ImplementsTraitForUsize<usize>`\n note: required by a bound in `try_foo`\n   --> $DIR/auxiliary/crate_a1.rs:3:24\n    |\n@@ -26,6 +27,7 @@ LL |         a::try_foo(implements_no_traits);\n    |         |\n    |         required by a bound introduced by this call\n    |\n+   = help: the trait `main::a::Bar` is implemented for `ImplementsTraitForUsize<usize>`\n note: required by a bound in `try_foo`\n   --> $DIR/auxiliary/crate_a1.rs:3:24\n    |\n@@ -46,6 +48,7 @@ help: trait impl with same name found\n LL | impl Bar for ImplementsWrongTraitConditionally<isize> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: perhaps two different versions of crate `crate_a2` are being used?\n+   = help: the trait `main::a::Bar` is implemented for `ImplementsTraitForUsize<usize>`\n note: required by a bound in `try_foo`\n   --> $DIR/auxiliary/crate_a1.rs:3:24\n    |\n@@ -60,8 +63,7 @@ LL |         a::try_foo(other_variant_implements_correct_trait);\n    |         |\n    |         required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n-             <ImplementsTraitForUsize<usize> as main::a::Bar>\n+   = help: the trait `main::a::Bar` is implemented for `ImplementsTraitForUsize<usize>`\n note: required by a bound in `try_foo`\n   --> $DIR/auxiliary/crate_a1.rs:3:24\n    |"}, {"sha": "b213ee635df59f6c2be7048ee89dffcaa230ff57", "filename": "src/test/ui/traits/coercion-generic-bad.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fcoercion-generic-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fcoercion-generic-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fcoercion-generic-bad.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `Struct: Trait<isize>` is not satisfied\n LL |     let s: Box<dyn Trait<isize>> = Box::new(Struct { person: \"Fred\" });\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<isize>` is not implemented for `Struct`\n    |\n-   = help: the following implementations were found:\n-             <Struct as Trait<&'static str>>\n+   = help: the trait `Trait<&'static str>` is implemented for `Struct`\n    = note: required for the cast to the object type `dyn Trait<isize>`\n \n error: aborting due to previous error"}, {"sha": "cab0ccdf710da0c6af89c23b9d5ba1f08a0c36f7", "filename": "src/test/ui/traits/inheritance/repeated-supertrait-ambig.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Finheritance%2Frepeated-supertrait-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Finheritance%2Frepeated-supertrait-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Finheritance%2Frepeated-supertrait-ambig.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -3,6 +3,10 @@ error[E0277]: the trait bound `dyn CompareToInts: CompareTo<i32>` is not satisfi\n    |\n LL |     c.same_as(22)\n    |       ^^^^^^^ the trait `CompareTo<i32>` is not implemented for `dyn CompareToInts`\n+   |\n+   = help: the following other types implement trait `CompareTo<T>`:\n+             <i64 as CompareTo<i64>>\n+             <i64 as CompareTo<u64>>\n \n error[E0277]: the trait bound `C: CompareTo<i32>` is not satisfied\n   --> $DIR/repeated-supertrait-ambig.rs:30:7\n@@ -20,6 +24,10 @@ error[E0277]: the trait bound `dyn CompareToInts: CompareTo<i32>` is not satisfi\n    |\n LL |     <dyn CompareToInts>::same_as(c, 22)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `CompareTo<i32>` is not implemented for `dyn CompareToInts`\n+   |\n+   = help: the following other types implement trait `CompareTo<T>`:\n+             <i64 as CompareTo<i64>>\n+             <i64 as CompareTo<u64>>\n \n error[E0277]: the trait bound `C: CompareTo<i32>` is not satisfied\n   --> $DIR/repeated-supertrait-ambig.rs:38:5\n@@ -38,7 +46,7 @@ error[E0277]: the trait bound `i64: CompareTo<i32>` is not satisfied\n LL |     assert_eq!(22_i64.same_as(22), true);\n    |                       ^^^^^^^ the trait `CompareTo<i32>` is not implemented for `i64`\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `CompareTo<T>`:\n              <i64 as CompareTo<i64>>\n              <i64 as CompareTo<u64>>\n "}, {"sha": "cf2e4edf9f0a9081e113ee2fec115b9c74ba6d07", "filename": "src/test/ui/traits/issue-79458.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fissue-79458.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fissue-79458.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-79458.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -7,10 +7,10 @@ LL | struct Foo<'a, T> {\n LL |     bar: &'a mut T\n    |     ^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `&mut T`\n    |\n-   = help: the following implementations were found:\n-             <&T as Clone>\n-             <*const T as Clone>\n-             <*mut T as Clone>\n+   = help: the following other types implement trait `Clone`:\n+             &T\n+             *const T\n+             *mut T\n    = note: `Clone` is implemented for `&T`, but not for `&mut T`\n    = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n "}, {"sha": "f2b3de13beb9e7a4b0995fbbef0e94f4dab4f11e", "filename": "src/test/ui/traits/issue-91594.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fissue-91594.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fissue-91594.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-91594.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `Foo: HasComponent<()>` is not satisfied\n LL | impl HasComponent<<Foo as Component<Foo>>::Interface> for Foo {}\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `HasComponent<()>` is not implemented for `Foo`\n    |\n-   = help: the following implementations were found:\n-             <Foo as HasComponent<<Foo as Component<Foo>>::Interface>>\n+   = help: the trait `HasComponent<<Foo as Component<Foo>>::Interface>` is implemented for `Foo`\n note: required because of the requirements on the impl of `Component<Foo>` for `Foo`\n   --> $DIR/issue-91594.rs:13:27\n    |"}, {"sha": "a4686edb7175745ecab4d93a0ce30c3d60fb045c", "filename": "src/test/ui/traits/map-types.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fmap-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fmap-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fmap-types.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,6 +4,7 @@ error[E0277]: the trait bound `Box<dyn Map<isize, isize>>: Map<usize, isize>` is\n LL |     let y: Box<dyn Map<usize, isize>> = Box::new(x);\n    |                                         ^^^^^^^^^^^ the trait `Map<usize, isize>` is not implemented for `Box<dyn Map<isize, isize>>`\n    |\n+   = help: the trait `Map<K, V>` is implemented for `HashMap<K, V>`\n    = note: required for the cast to the object type `dyn Map<usize, isize>`\n \n error: aborting due to previous error"}, {"sha": "cefb2a8792f17f14a9a9915a293b66a8f591b0b0", "filename": "src/test/ui/traits/reservation-impl/no-use.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Freservation-impl%2Fno-use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Freservation-impl%2Fno-use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Freservation-impl%2Fno-use.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,8 +6,7 @@ LL |     <() as MyTrait>::foo(&());\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n-             <() as MyTrait>\n+   = help: the trait `MyTrait` is implemented for `()`\n \n error: aborting due to previous error\n "}, {"sha": "5c324cd38a3abd085a68cbb828730195411e2aba", "filename": "src/test/ui/traits/suggest-deferences/issue-39029.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-39029.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,7 +5,7 @@ LL |     let _errors = TcpListener::bind(&bad);\n    |                   ----------------- ^^^^\n    |                   |                 |\n    |                   |                 the trait `ToSocketAddrs` is not implemented for `NoToSocketAddrs`\n-   |                   |                 help: consider adding dereference here: `&*bad`\n+   |                   |                 help: consider dereferencing here: `&*bad`\n    |                   required by a bound introduced by this call\n    |\n    = note: required because of the requirements on the impl of `ToSocketAddrs` for `&NoToSocketAddrs`"}, {"sha": "d129328dae8efc60655712be4a735571b5640145", "filename": "src/test/ui/traits/suggest-deferences/issue-62530.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-62530.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-62530.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fissue-62530.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,11 +5,9 @@ LL |     takes_type_parameter(&string);  // Error\n    |     -------------------- ^^^^^^^\n    |     |                    |\n    |     |                    the trait `SomeTrait` is not implemented for `&String`\n-   |     |                    help: consider adding dereference here: `&*string`\n+   |     |                    help: consider dereferencing here: `&*string`\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n-             <&str as SomeTrait>\n note: required by a bound in `takes_type_parameter`\n   --> $DIR/issue-62530.rs:4:44\n    |"}, {"sha": "efb3c7d123f70f2e8a613d5989a4f466c2020274", "filename": "src/test/ui/traits/suggest-deferences/multiple-0.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fmultiple-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fmultiple-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fmultiple-0.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,7 +5,7 @@ LL |     foo(&baz);\n    |     --- ^^^^\n    |     |   |\n    |     |   the trait `Happy` is not implemented for `&Baz`\n-   |     |   help: consider adding dereference here: `&***baz`\n+   |     |   help: consider dereferencing here: `&***baz`\n    |     required by a bound introduced by this call\n    |\n note: required by a bound in `foo`"}, {"sha": "6e12321c2333b40ce4087a602a5455bdf94f8671", "filename": "src/test/ui/traits/suggest-deferences/multiple-1.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fmultiple-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fmultiple-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Fmultiple-1.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,6 +6,7 @@ LL |     foo(&mut baz);\n    |     |\n    |     required by a bound introduced by this call\n    |\n+   = help: the trait `Happy` is implemented for `&mut LDM`\n note: required by a bound in `foo`\n   --> $DIR/multiple-1.rs:45:26\n    |"}, {"sha": "7a8433f90572e027dfb1fae29923ea318cb9a090", "filename": "src/test/ui/traits/suggest-deferences/root-obligation.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Froot-obligation.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Froot-obligation.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Froot-obligation.fixed?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+\n+fn get_vowel_count(string: &str) -> usize {\n+    string\n+        .chars()\n+        .filter(|c| \"aeiou\".contains(*c))\n+        //~^ ERROR expected a `Fn<(char,)>` closure, found `char`\n+        .count()\n+}\n+\n+fn main() {\n+    let _ = get_vowel_count(\"asdf\");\n+}"}, {"sha": "51bac2107e3b4cacc74afdfa1c0ad0af3030e124", "filename": "src/test/ui/traits/suggest-deferences/root-obligation.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Froot-obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Froot-obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Froot-obligation.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+\n+fn get_vowel_count(string: &str) -> usize {\n+    string\n+        .chars()\n+        .filter(|c| \"aeiou\".contains(c))\n+        //~^ ERROR expected a `Fn<(char,)>` closure, found `char`\n+        .count()\n+}\n+\n+fn main() {\n+    let _ = get_vowel_count(\"asdf\");\n+}"}, {"sha": "16e03e79c757111bd0eb904c368c2660bd8437d5", "filename": "src/test/ui/traits/suggest-deferences/root-obligation.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Froot-obligation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Froot-obligation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsuggest-deferences%2Froot-obligation.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n+  --> $DIR/root-obligation.rs:6:38\n+   |\n+LL |         .filter(|c| \"aeiou\".contains(c))\n+   |                             -------- ^ expected an `Fn<(char,)>` closure, found `char`\n+   |                             |\n+   |                             required by a bound introduced by this call\n+   |\n+   = help: the trait `Fn<(char,)>` is not implemented for `char`\n+   = note: required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n+   = note: required because of the requirements on the impl of `Pattern<'_>` for `&char`\n+note: required by a bound in `core::str::<impl str>::contains`\n+  --> $SRC_DIR/core/src/str/mod.rs:LL:COL\n+   |\n+LL |     pub fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+   |                            ^^^^^^^^^^^ required by this bound in `core::str::<impl str>::contains`\n+help: consider dereferencing here\n+   |\n+LL |         .filter(|c| \"aeiou\".contains(*c))\n+   |                                      +\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "f9906713f84274d12d7a34399dcbba43de2853a0", "filename": "src/test/ui/try-block/try-block-bad-type.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-bad-type.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,8 +5,7 @@ LL |         Err(\"\")?;\n    |                ^ the trait `From<&str>` is not implemented for `TryFromSliceError`\n    |\n    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\n-   = help: the following implementations were found:\n-             <TryFromSliceError as From<Infallible>>\n+   = help: the trait `From<Infallible>` is implemented for `TryFromSliceError`\n    = note: required because of the requirements on the impl of `FromResidual<Result<Infallible, &str>>` for `Result<u32, TryFromSliceError>`\n \n error[E0271]: type mismatch resolving `<Result<i32, i32> as Try>::Output == &str`"}, {"sha": "1a4105231dc7501664eee87d446a7e2ac920c0bd", "filename": "src/test/ui/try-trait/bad-interconversion.stderr", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftry-trait%2Fbad-interconversion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftry-trait%2Fbad-interconversion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-trait%2Fbad-interconversion.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -7,12 +7,16 @@ LL |     Ok(Err(123_i32)?)\n    |                    ^ the trait `From<i32>` is not implemented for `u8`\n    |\n    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait\n-   = help: the following implementations were found:\n-             <u8 as From<NonZeroU8>>\n-             <u8 as From<bool>>\n+   = help: the following other types implement trait `From<T>`:\n              <f32 as From<i16>>\n              <f32 as From<i8>>\n-           and 71 others\n+             <f32 as From<u16>>\n+             <f32 as From<u8>>\n+             <f64 as From<f32>>\n+             <f64 as From<i16>>\n+             <f64 as From<i32>>\n+             <f64 as From<i8>>\n+           and 67 others\n    = note: required because of the requirements on the impl of `FromResidual<Result<Infallible, i32>>` for `Result<u64, u8>`\n \n error[E0277]: the `?` operator can only be used on `Result`s, not `Option`s, in a function that returns `Result`\n@@ -27,6 +31,7 @@ LL | | }\n    | |_- this function returns a `Result`\n    |\n    = help: the trait `FromResidual<Option<Infallible>>` is not implemented for `Result<u64, String>`\n+   = help: the trait `FromResidual<Result<Infallible, E>>` is implemented for `Result<T, F>`\n \n error[E0277]: the `?` operator can only be used on `Result`s in a function that returns `Result`\n   --> $DIR/bad-interconversion.rs:17:31\n@@ -39,6 +44,7 @@ LL | | }\n    | |_- this function returns a `Result`\n    |\n    = help: the trait `FromResidual<ControlFlow<{integer}, Infallible>>` is not implemented for `Result<u64, String>`\n+   = help: the trait `FromResidual<Result<Infallible, E>>` is implemented for `Result<T, F>`\n \n error[E0277]: the `?` operator can only be used on `Option`s, not `Result`s, in a function that returns `Option`\n   --> $DIR/bad-interconversion.rs:22:22\n@@ -51,6 +57,7 @@ LL | | }\n    | |_- this function returns an `Option`\n    |\n    = help: the trait `FromResidual<Result<Infallible, &str>>` is not implemented for `Option<u16>`\n+   = help: the trait `FromResidual` is implemented for `Option<T>`\n \n error[E0277]: the `?` operator can only be used on `Option`s in a function that returns `Option`\n   --> $DIR/bad-interconversion.rs:27:33\n@@ -63,6 +70,7 @@ LL | | }\n    | |_- this function returns an `Option`\n    |\n    = help: the trait `FromResidual<ControlFlow<{integer}, Infallible>>` is not implemented for `Option<u64>`\n+   = help: the trait `FromResidual` is implemented for `Option<T>`\n \n error[E0277]: the `?` operator can only be used on `ControlFlow`s in a function that returns `ControlFlow`\n   --> $DIR/bad-interconversion.rs:32:39\n@@ -75,6 +83,7 @@ LL | | }\n    | |_- this function returns a `ControlFlow`\n    |\n    = help: the trait `FromResidual<Result<Infallible, &str>>` is not implemented for `ControlFlow<String>`\n+   = help: the trait `FromResidual` is implemented for `ControlFlow<B, C>`\n \n error[E0277]: the `?` operator can only be used on `ControlFlow`s in a function that returns `ControlFlow`\n   --> $DIR/bad-interconversion.rs:37:12\n@@ -88,6 +97,7 @@ LL | | }\n    | |_- this function returns a `ControlFlow`\n    |\n    = help: the trait `FromResidual<Option<Infallible>>` is not implemented for `ControlFlow<u64>`\n+   = help: the trait `FromResidual` is implemented for `ControlFlow<B, C>`\n \n error[E0277]: the `?` operator in a function that returns `ControlFlow<B, _>` can only be used on other `ControlFlow<B, _>`s (with the same Break type)\n   --> $DIR/bad-interconversion.rs:43:29\n@@ -102,6 +112,7 @@ LL | | }\n    |\n    = help: the trait `FromResidual<ControlFlow<u8, Infallible>>` is not implemented for `ControlFlow<i64>`\n    = note: unlike `Result`, there's no `From`-conversion performed for `ControlFlow`\n+   = help: the trait `FromResidual` is implemented for `ControlFlow<B, C>`\n \n error: aborting due to 8 previous errors\n "}, {"sha": "b0e4de8cb4bf59223fe8add972f19d2d8c543b01", "filename": "src/test/ui/try-trait/option-to-result.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftry-trait%2Foption-to-result.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftry-trait%2Foption-to-result.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-trait%2Foption-to-result.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -10,6 +10,7 @@ LL | | }\n    | |_- this function returns a `Result`\n    |\n    = help: the trait `FromResidual<Option<Infallible>>` is not implemented for `Result<(), ()>`\n+   = help: the trait `FromResidual<Result<Infallible, E>>` is implemented for `Result<T, F>`\n \n error[E0277]: the `?` operator can only be used on `Option`s, not `Result`s, in a function that returns `Option`\n   --> $DIR/option-to-result.rs:11:6\n@@ -23,6 +24,7 @@ LL | | }\n    | |_- this function returns an `Option`\n    |\n    = help: the trait `FromResidual<Result<Infallible, i32>>` is not implemented for `Option<i32>`\n+   = help: the trait `FromResidual` is implemented for `Option<T>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7b2a9a16f900b258ff5a1e80f9cb4dc203a5f721", "filename": "src/test/ui/try-trait/try-on-option.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftry-trait%2Ftry-on-option.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftry-trait%2Ftry-on-option.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-trait%2Ftry-on-option.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -10,6 +10,7 @@ LL | | }\n    | |_- this function returns a `Result`\n    |\n    = help: the trait `FromResidual<Option<Infallible>>` is not implemented for `Result<u32, ()>`\n+   = help: the trait `FromResidual<Result<Infallible, E>>` is implemented for `Result<T, F>`\n \n error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n   --> $DIR/try-on-option.rs:11:6"}, {"sha": "d0c04371bd793faa8926a8a7404c1a8126a3e321", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -13,8 +13,7 @@ error[E0277]: the trait bound `(): Bug` is not satisfied\n LL |     const FUN: fn() -> Self::Item = || ();\n    |                                        ^^ the trait `Bug` is not implemented for `()`\n    |\n-   = help: the following implementations were found:\n-             <&() as Bug>\n+   = help: the trait `Bug` is implemented for `&()`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "0df2b57d373b6435c796feff2b7817c768578861", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `(): Foo<FooX>` is not satisfied\n LL | fn foo() -> impl Foo<FooX> {\n    |             ^^^^^^^^^^^^^^ the trait `Foo<FooX>` is not implemented for `()`\n    |\n-   = help: the following implementations were found:\n-             <() as Foo<()>>\n+   = help: the trait `Foo<()>` is implemented for `()`\n \n error[E0277]: the trait bound `(): Foo<FooX>` is not satisfied\n   --> $DIR/nested-tait-inference.rs:12:28\n@@ -19,8 +18,7 @@ LL | |     ()\n LL | | }\n    | |_^ the trait `Foo<FooX>` is not implemented for `()`\n    |\n-   = help: the following implementations were found:\n-             <() as Foo<()>>\n+   = help: the trait `Foo<()>` is implemented for `()`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "264e8024fac3a445fab636c6745c74568ee01a47", "filename": "src/test/ui/type-alias-impl-trait/nested-tait-inference2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fnested-tait-inference2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the trait bound `(): Foo<FooX>` is not satisfied\n LL | fn foo() -> impl Foo<FooX> {\n    |             ^^^^^^^^^^^^^^ the trait `Foo<FooX>` is not implemented for `()`\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Foo<A>`:\n              <() as Foo<()>>\n              <() as Foo<u32>>\n \n@@ -19,7 +19,7 @@ LL | |     ()\n LL | | }\n    | |_^ the trait `Foo<FooX>` is not implemented for `()`\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `Foo<A>`:\n              <() as Foo<()>>\n              <() as Foo<u32>>\n "}, {"sha": "348696f25e3b5aaecdc0848204e61354810b897b", "filename": "src/test/ui/type-alias-impl-trait/self-referential-2.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself-referential-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself-referential-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself-referential-2.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     42_i32\n    |     ^^^^^^ no implementation for `i32 == Foo`\n    |\n    = help: the trait `PartialEq<Foo>` is not implemented for `i32`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n \n error: aborting due to previous error\n "}, {"sha": "838264794194cdc252150201549e907c7850c339", "filename": "src/test/ui/type-alias-impl-trait/self-referential-4.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself-referential-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself-referential-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself-referential-4.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     i\n    |     ^ no implementation for `&i32 == Bar<'b, 'static>`\n    |\n    = help: the trait `PartialEq<Bar<'b, 'static>>` is not implemented for `&i32`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n \n error[E0277]: can't compare `&i32` with `Foo<'static, 'b>`\n   --> $DIR/self-referential-4.rs:12:5\n@@ -13,6 +23,16 @@ LL |     i\n    |     ^ no implementation for `&i32 == Foo<'static, 'b>`\n    |\n    = help: the trait `PartialEq<Foo<'static, 'b>>` is not implemented for `&i32`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n \n error[E0277]: can't compare `&i32` with `Moo<'static, 'a>`\n   --> $DIR/self-referential-4.rs:18:5\n@@ -21,6 +41,16 @@ LL |     i\n    |     ^ no implementation for `&i32 == Moo<'static, 'a>`\n    |\n    = help: the trait `PartialEq<Moo<'static, 'a>>` is not implemented for `&i32`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2ebb15b88030811ee6b3a877b99ccdc670987086", "filename": "src/test/ui/type-alias-impl-trait/self-referential.stderr", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself-referential.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself-referential.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fself-referential.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     i\n    |     ^ no implementation for `&i32 == Bar<'b, 'a>`\n    |\n    = help: the trait `PartialEq<Bar<'b, 'a>>` is not implemented for `&i32`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n \n error[E0277]: can't compare `&i32` with `(i32, &i32)`\n   --> $DIR/self-referential.rs:12:10\n@@ -13,6 +23,16 @@ LL |     (42, i)\n    |          ^ no implementation for `&i32 == (i32, &i32)`\n    |\n    = help: the trait `PartialEq<(i32, &i32)>` is not implemented for `&i32`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n \n error[E0277]: can't compare `&i32` with `(i32, Moo<'b, 'a>::{opaque#0})`\n   --> $DIR/self-referential.rs:18:10\n@@ -21,6 +41,16 @@ LL |     (42, i)\n    |          ^ no implementation for `&i32 == (i32, Moo<'b, 'a>::{opaque#0})`\n    |\n    = help: the trait `PartialEq<(i32, Moo<'b, 'a>::{opaque#0})>` is not implemented for `&i32`\n+   = help: the following other types implement trait `PartialEq<Rhs>`:\n+             f32\n+             f64\n+             i128\n+             i16\n+             i32\n+             i64\n+             i8\n+             isize\n+           and 6 others\n \n error: aborting due to 3 previous errors\n "}, {"sha": "f292877f30ea2a9d6f0dbcedf4ad608baec9f320", "filename": "src/test/ui/type/type-check-defaults.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check-defaults.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -65,6 +65,16 @@ LL | trait ProjectionPred<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n    |                                                                  ^^^^^^^ no implementation for `i32 + u8`\n    |\n    = help: the trait `Add<u8>` is not implemented for `i32`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error: aborting due to 7 previous errors\n "}, {"sha": "9658288ac8b28df9abe531e7d20220a8bcd7708a", "filename": "src/test/ui/typeck/issue-81293.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftypeck%2Fissue-81293.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftypeck%2Fissue-81293.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-81293.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -20,6 +20,16 @@ LL |     a = c + b * 5;\n    |           ^ no implementation for `usize + u16`\n    |\n    = help: the trait `Add<u16>` is not implemented for `usize`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error: aborting due to 3 previous errors\n "}, {"sha": "ab9a72edfe98df74e042af7a6c71f5cc3791b8de", "filename": "src/test/ui/typeck/issue-90101.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftypeck%2Fissue-90101.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Ftypeck%2Fissue-90101.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-90101.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -6,7 +6,7 @@ LL |     func(Path::new(\"hello\").to_path_buf().to_string_lossy(), \"world\")\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the following implementations were found:\n+   = help: the following other types implement trait `From<T>`:\n              <PathBuf as From<&T>>\n              <PathBuf as From<Box<Path>>>\n              <PathBuf as From<Cow<'a, Path>>>"}, {"sha": "74766d9fdd1b12559e50bda4cf02579761cddc48", "filename": "src/test/ui/ufcs/ufcs-qpath-self-mismatch.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-self-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-self-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fufcs%2Fufcs-qpath-self-mismatch.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,16 @@ LL |     <i32 as Add<u32>>::add(1, 2);\n    |     ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `i32 + u32`\n    |\n    = help: the trait `Add<u32>` is not implemented for `i32`\n+   = help: the following other types implement trait `Add<Rhs>`:\n+             <&'a f32 as Add<f32>>\n+             <&'a f64 as Add<f64>>\n+             <&'a i128 as Add<i128>>\n+             <&'a i16 as Add<i16>>\n+             <&'a i32 as Add<i32>>\n+             <&'a i64 as Add<i64>>\n+             <&'a i8 as Add<i8>>\n+             <&'a isize as Add<isize>>\n+           and 48 others\n \n error[E0308]: mismatched types\n   --> $DIR/ufcs-qpath-self-mismatch.rs:6:28"}, {"sha": "5e67b2c44f2be0de83492ccaffd443e097f00b6d", "filename": "src/test/ui/unevaluated_fixed_size_array_len.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funevaluated_fixed_size_array_len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funevaluated_fixed_size_array_len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funevaluated_fixed_size_array_len.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -4,8 +4,7 @@ error[E0277]: the trait bound `[(); 0]: Foo` is not satisfied\n LL |     <[(); 0] as Foo>::foo()\n    |     ^^^^^^^^^^^^^^^^^^^^^ the trait `Foo` is not implemented for `[(); 0]`\n    |\n-   = help: the following implementations were found:\n-             <[(); 1] as Foo>\n+   = help: the trait `Foo` is implemented for `[(); 1]`\n \n error: aborting due to previous error\n "}, {"sha": "2fa741bc1c50be20cfe238326de0a362e84f8e1b", "filename": "src/test/ui/unsized/box-instead-of-dyn-fn.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,15 @@\n+use std::fmt::Debug;\n+\n+// Test to suggest boxing the return type, and the closure branch of the `if`\n+\n+fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> dyn Fn() + 'a {\n+    //~^ ERROR return type cannot have an unboxed trait object\n+    if a % 2 == 0 {\n+        move || println!(\"{a}\")\n+    } else {\n+        Box::new(move || println!(\"{}\", b))\n+        //~^ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "80f61cb3eae11724071bdedda531f4dd80d706e9", "filename": "src/test/ui/unsized/box-instead-of-dyn-fn.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,39 @@\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/box-instead-of-dyn-fn.rs:10:9\n+   |\n+LL | /     if a % 2 == 0 {\n+LL | |         move || println!(\"{a}\")\n+   | |         ----------------------- expected because of this\n+LL | |     } else {\n+LL | |         Box::new(move || println!(\"{}\", b))\n+   | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found struct `Box`\n+LL | |\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+   |\n+   = note: expected type `[closure@$DIR/box-instead-of-dyn-fn.rs:8:9: 8:32]`\n+            found struct `Box<[closure@$DIR/box-instead-of-dyn-fn.rs:10:18: 10:43]>`\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/box-instead-of-dyn-fn.rs:5:56\n+   |\n+LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> dyn Fn() + 'a {\n+   |                                                        ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl Fn() + 'a` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> Box<dyn Fn() + 'a> {\n+   |                                                        ++++             +\n+help: ... and box this value\n+   |\n+LL |         Box::new(move || println!(\"{a}\"))\n+   |         +++++++++                       +\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0746.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "096b1a93574fc81dbbfda6bb2f51efefc249a798", "filename": "src/test/ui/unsized/issue-91801.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fissue-91801.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fissue-91801.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-91801.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,19 @@\n+pub struct Something;\n+\n+type Validator<'a> = dyn 'a + Send + Sync + Fn(&'a Something) -> Result<(), ()>;\n+\n+pub static ALL_VALIDATORS: &[(&'static str, &'static Validator)] =\n+    &[(\"validate that credits and debits balance\", &validate_something)];\n+\n+fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> Validator<'a> {\n+    //~^ ERROR return type cannot have an unboxed trait object\n+    return Box::new(move |something: &'_ Something| -> Result<(), ()> {\n+        first(something).or_else(|_| second(something))\n+    });\n+}\n+\n+fn validate_something(_: &Something) -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+fn main() {}"}, {"sha": "e854514958629fb4a988eaac5cb27e9879fdc0ba", "filename": "src/test/ui/unsized/issue-91801.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fissue-91801.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fissue-91801.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-91801.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,15 @@\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/issue-91801.rs:8:77\n+   |\n+LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> Validator<'a> {\n+   |                                                                             ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: use `impl Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a` as the return type, as all return paths are of type `Box<[closure@$DIR/issue-91801.rs:10:21: 12:6]>`, which implements `Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a`\n+   |\n+LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> impl Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a {\n+   |                                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0746`."}, {"sha": "c74897cc4bc501a70b1ff5a33d1c009464c10fc5", "filename": "src/test/ui/unsized/issue-91803.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fissue-91803.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fissue-91803.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-91803.rs?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,8 @@\n+trait Foo<'a> {}\n+\n+fn or<'a>(first: &'static dyn Foo<'a>) -> dyn Foo<'a> {\n+    //~^ ERROR return type cannot have an unboxed trait object\n+    return Box::new(panic!());\n+}\n+\n+fn main() {}"}, {"sha": "2dad9e8929421befe3407081974920bc686cfabf", "filename": "src/test/ui/unsized/issue-91803.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fissue-91803.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Funsized%2Fissue-91803.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-91803.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -0,0 +1,15 @@\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/issue-91803.rs:3:43\n+   |\n+LL | fn or<'a>(first: &'static dyn Foo<'a>) -> dyn Foo<'a> {\n+   |                                           ^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: use `impl Foo<'a>` as the return type, as all return paths are of type `Box<_>`, which implements `Foo<'a>`\n+   |\n+LL | fn or<'a>(first: &'static dyn Foo<'a>) -> impl Foo<'a> {\n+   |                                           ~~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0746`."}, {"sha": "037f8b9f3377018989a3dba9cd266259e004d0d9", "filename": "src/test/ui/wf/hir-wf-check-erase-regions.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a22cf2af0510b3ec4cbb19c3de11d3d8291349d9/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr?ref=a22cf2af0510b3ec4cbb19c3de11d3d8291349d9", "patch": "@@ -5,6 +5,7 @@ LL |     type IntoIter = std::iter::Flatten<std::slice::Iter<'a, T>>;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `&T` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&T`\n+   = help: the trait `Iterator` is implemented for `&mut I`\n    = note: required because of the requirements on the impl of `IntoIterator` for `&T`\n note: required by a bound in `Flatten`\n   --> $SRC_DIR/core/src/iter/adapters/flatten.rs:LL:COL\n@@ -19,6 +20,7 @@ LL |     fn into_iter(self) -> Self::IntoIter {\n    |                           ^^^^^^^^^^^^^^ `&T` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&T`\n+   = help: the trait `Iterator` is implemented for `&mut I`\n    = note: required because of the requirements on the impl of `IntoIterator` for `&T`\n note: required by a bound in `Flatten`\n   --> $SRC_DIR/core/src/iter/adapters/flatten.rs:LL:COL"}]}