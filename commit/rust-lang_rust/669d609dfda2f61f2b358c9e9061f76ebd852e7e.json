{"sha": "669d609dfda2f61f2b358c9e9061f76ebd852e7e", "node_id": "C_kwDOAAsO6NoAKDY2OWQ2MDlkZmRhMmY2MWYyYjM1OGM5ZTkwNjFmNzZlYmQ4NTJlN2U", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-06-09T14:04:41Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-06-09T14:04:41Z"}, "message": "extract opaque type wf check into separate fn", "tree": {"sha": "68c3ed1d3890540a2fd951fef996ce57b46dc797", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68c3ed1d3890540a2fd951fef996ce57b46dc797"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/669d609dfda2f61f2b358c9e9061f76ebd852e7e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/669d609dfda2f61f2b358c9e9061f76ebd852e7e", "html_url": "https://github.com/rust-lang/rust/commit/669d609dfda2f61f2b358c9e9061f76ebd852e7e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/669d609dfda2f61f2b358c9e9061f76ebd852e7e/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22783658890baa33d468b4d98f21c123ed4bc24c", "url": "https://api.github.com/repos/rust-lang/rust/commits/22783658890baa33d468b4d98f21c123ed4bc24c", "html_url": "https://github.com/rust-lang/rust/commit/22783658890baa33d468b4d98f21c123ed4bc24c"}], "stats": {"total": 139, "additions": 74, "deletions": 65}, "files": [{"sha": "b5d5071dc05360716328fe72802b7e0e6ddde089", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 74, "deletions": 65, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/669d609dfda2f61f2b358c9e9061f76ebd852e7e/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669d609dfda2f61f2b358c9e9061f76ebd852e7e/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=669d609dfda2f61f2b358c9e9061f76ebd852e7e", "patch": "@@ -251,91 +251,100 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n             return self.tcx.ty_error(e);\n         }\n \n-        let definition_ty = instantiated_ty\n-            .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false)\n-            .ty;\n-\n         if let Err(guar) =\n             check_opaque_type_parameter_valid(self.tcx, opaque_type_key, instantiated_ty.span)\n         {\n             return self.tcx.ty_error(guar);\n         }\n \n-        // Only check this for TAIT. RPIT already supports `tests/ui/impl-trait/nested-return-type2.rs`\n-        // on stable and we'd break that.\n-        let opaque_ty_hir = self.tcx.hir().expect_item(opaque_type_key.def_id);\n-        let OpaqueTyOrigin::TyAlias { .. } = opaque_ty_hir.expect_opaque_ty().origin else {\n-            return definition_ty;\n-        };\n-        let def_id = opaque_type_key.def_id;\n-        // This logic duplicates most of `check_opaque_meets_bounds`.\n-        // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n-        let param_env = self.tcx.param_env(def_id);\n-        // HACK This bubble is required for this tests to pass:\n-        // nested-return-type2-tait2.rs\n-        // nested-return-type2-tait3.rs\n-        // FIXME(-Ztrait-solver=next): We probably should use `DefiningAnchor::Error`\n-        // and prepopulate this `InferCtxt` with known opaque values, rather than\n-        // using the `Bind` anchor here. For now it's fine.\n-        let infcx = self\n-            .tcx\n-            .infer_ctxt()\n-            .with_opaque_type_inference(if self.next_trait_solver() {\n-                DefiningAnchor::Bind(def_id)\n-            } else {\n-                DefiningAnchor::Bubble\n-            })\n-            .build();\n-        let ocx = ObligationCtxt::new(&infcx);\n-        // Require the hidden type to be well-formed with only the generics of the opaque type.\n-        // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-        // hidden type is well formed even without those bounds.\n-        let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()));\n-\n-        let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n+        let definition_ty = instantiated_ty\n+            .remap_generic_params_to_declaration_params(opaque_type_key, self.tcx, false)\n+            .ty;\n \n-        // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-        // the bounds that the function supplies.\n-        let opaque_ty = self.tcx.mk_opaque(def_id.to_def_id(), id_substs);\n-        if let Err(err) = ocx.eq(\n-            &ObligationCause::misc(instantiated_ty.span, def_id),\n-            param_env,\n-            opaque_ty,\n+        // `definition_ty` does not live in of the current inference context,\n+        // so lets make sure that we don't accidentally misuse our current `infcx`.\n+        match check_opaque_type_well_formed(\n+            self.tcx,\n+            self.next_trait_solver(),\n+            opaque_type_key.def_id,\n+            instantiated_ty.span,\n             definition_ty,\n         ) {\n+            Ok(hidden_ty) => hidden_ty,\n+            Err(guar) => self.tcx.ty_error(guar),\n+        }\n+    }\n+}\n+\n+/// This logic duplicates most of `check_opaque_meets_bounds`.\n+/// FIXME(oli-obk): Also do region checks here and then consider removing\n+/// `check_opaque_meets_bounds` entirely.\n+fn check_opaque_type_well_formed<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    next_trait_solver: bool,\n+    def_id: LocalDefId,\n+    definition_span: Span,\n+    definition_ty: Ty<'tcx>,\n+) -> Result<Ty<'tcx>, ErrorGuaranteed> {\n+    // Only check this for TAIT. RPIT already supports `tests/ui/impl-trait/nested-return-type2.rs`\n+    // on stable and we'd break that.\n+    let opaque_ty_hir = tcx.hir().expect_item(def_id);\n+    let OpaqueTyOrigin::TyAlias { .. } = opaque_ty_hir.expect_opaque_ty().origin else {\n+        return Ok(definition_ty);\n+    };\n+    let param_env = tcx.param_env(def_id);\n+    // HACK This bubble is required for this tests to pass:\n+    // nested-return-type2-tait2.rs\n+    // nested-return-type2-tait3.rs\n+    // FIXME(-Ztrait-solver=next): We probably should use `DefiningAnchor::Error`\n+    // and prepopulate this `InferCtxt` with known opaque values, rather than\n+    // using the `Bind` anchor here. For now it's fine.\n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_next_trait_solver(next_trait_solver)\n+        .with_opaque_type_inference(if next_trait_solver {\n+            DefiningAnchor::Bind(def_id)\n+        } else {\n+            DefiningAnchor::Bubble\n+        })\n+        .build();\n+    let ocx = ObligationCtxt::new(&infcx);\n+    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n+\n+    // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+    // the bounds that the function supplies.\n+    let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), identity_substs);\n+    ocx.eq(&ObligationCause::misc(definition_span, def_id), param_env, opaque_ty, definition_ty)\n+        .map_err(|err| {\n             infcx\n                 .err_ctxt()\n                 .report_mismatched_types(\n-                    &ObligationCause::misc(instantiated_ty.span, def_id),\n+                    &ObligationCause::misc(definition_span, def_id),\n                     opaque_ty,\n                     definition_ty,\n                     err,\n                 )\n-                .emit();\n-        }\n+                .emit()\n+        })?;\n \n-        ocx.register_obligation(Obligation::misc(\n-            infcx.tcx,\n-            instantiated_ty.span,\n-            def_id,\n-            param_env,\n-            predicate,\n-        ));\n+    // Require the hidden type to be well-formed with only the generics of the opaque type.\n+    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+    // hidden type is well formed even without those bounds.\n+    let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()));\n+    ocx.register_obligation(Obligation::misc(tcx, definition_span, def_id, param_env, predicate));\n \n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n+    let errors = ocx.select_all_or_error();\n \n-        // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n-        // tests to pass\n-        let _ = infcx.take_opaque_types();\n+    // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n+    // tests to pass\n+    let _ = infcx.take_opaque_types();\n \n-        if errors.is_empty() {\n-            definition_ty\n-        } else {\n-            let reported = infcx.err_ctxt().report_fulfillment_errors(&errors);\n-            self.tcx.ty_error(reported)\n-        }\n+    if errors.is_empty() {\n+        Ok(definition_ty)\n+    } else {\n+        Err(infcx.err_ctxt().report_fulfillment_errors(&errors))\n     }\n }\n "}]}