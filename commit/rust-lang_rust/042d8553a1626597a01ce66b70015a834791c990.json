{"sha": "042d8553a1626597a01ce66b70015a834791c990", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MmQ4NTUzYTE2MjY1OTdhMDFjZTY2YjcwMDE1YTgzNDc5MWM5OTA=", "commit": {"author": {"name": "Tommaso Bianchi", "email": "tommaso4.bianchi@mail.polimi.it", "date": "2019-12-16T16:27:28Z"}, "committer": {"name": "Tommaso Bianchi", "email": "tommaso4.bianchi@mail.polimi.it", "date": "2019-12-16T16:27:28Z"}, "message": "Fix too restrictive checks on Drop impls", "tree": {"sha": "26bdfc2c0dd220a3137b19a828a7df7a991eaa41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26bdfc2c0dd220a3137b19a828a7df7a991eaa41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/042d8553a1626597a01ce66b70015a834791c990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/042d8553a1626597a01ce66b70015a834791c990", "html_url": "https://github.com/rust-lang/rust/commit/042d8553a1626597a01ce66b70015a834791c990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/042d8553a1626597a01ce66b70015a834791c990/comments", "author": {"login": "TommasoBianchi", "id": 10757509, "node_id": "MDQ6VXNlcjEwNzU3NTA5", "avatar_url": "https://avatars.githubusercontent.com/u/10757509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TommasoBianchi", "html_url": "https://github.com/TommasoBianchi", "followers_url": "https://api.github.com/users/TommasoBianchi/followers", "following_url": "https://api.github.com/users/TommasoBianchi/following{/other_user}", "gists_url": "https://api.github.com/users/TommasoBianchi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TommasoBianchi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TommasoBianchi/subscriptions", "organizations_url": "https://api.github.com/users/TommasoBianchi/orgs", "repos_url": "https://api.github.com/users/TommasoBianchi/repos", "events_url": "https://api.github.com/users/TommasoBianchi/events{/privacy}", "received_events_url": "https://api.github.com/users/TommasoBianchi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TommasoBianchi", "id": 10757509, "node_id": "MDQ6VXNlcjEwNzU3NTA5", "avatar_url": "https://avatars.githubusercontent.com/u/10757509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TommasoBianchi", "html_url": "https://github.com/TommasoBianchi", "followers_url": "https://api.github.com/users/TommasoBianchi/followers", "following_url": "https://api.github.com/users/TommasoBianchi/following{/other_user}", "gists_url": "https://api.github.com/users/TommasoBianchi/gists{/gist_id}", "starred_url": "https://api.github.com/users/TommasoBianchi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TommasoBianchi/subscriptions", "organizations_url": "https://api.github.com/users/TommasoBianchi/orgs", "repos_url": "https://api.github.com/users/TommasoBianchi/repos", "events_url": "https://api.github.com/users/TommasoBianchi/events{/privacy}", "received_events_url": "https://api.github.com/users/TommasoBianchi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bd28d9d58abb9e71c1ad725ec246839cfca0b0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bd28d9d58abb9e71c1ad725ec246839cfca0b0a", "html_url": "https://github.com/rust-lang/rust/commit/2bd28d9d58abb9e71c1ad725ec246839cfca0b0a"}], "stats": {"total": 135, "additions": 128, "deletions": 7}, "files": [{"sha": "6fcb839fa0b89a7295adccf86a64c54cdccedefa", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 128, "deletions": 7, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/042d8553a1626597a01ce66b70015a834791c990/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/042d8553a1626597a01ce66b70015a834791c990/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=042d8553a1626597a01ce66b70015a834791c990", "patch": "@@ -2,13 +2,15 @@ use crate::check::regionck::RegionCtxt;\n \n use crate::hir;\n use crate::hir::def_id::DefId;\n+use crate::util::common::ErrorReported;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc::ty::error::TypeError;\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::{Subst, SubstsRef};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use crate::util::common::ErrorReported;\n+use rustc::ty::{self, Predicate, Ty, TyCtxt};\n \n use syntax_pos::Span;\n \n@@ -192,6 +194,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n \n+    let self_param_env = tcx.param_env(self_type_did);\n+\n     // An earlier version of this code attempted to do this checking\n     // via the traits::fulfill machinery. However, it ran into trouble\n     // since the fulfill machinery merely turns outlives-predicates\n@@ -205,14 +209,35 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // to take on a structure that is roughly an alpha-renaming of\n         // the generic parameters of the item definition.)\n \n-        // This path now just checks *all* predicates via the direct\n-        // lookup, rather than using fulfill machinery.\n+        // This path now just checks *all* predicates via an instantiation of\n+        // the `SimpleEqRelation`, which simply forwards to the `relate` machinery\n+        // after taking care of anonymizing late bound regions.\n         //\n         // However, it may be more efficient in the future to batch\n-        // the analysis together via the fulfill , rather than the\n-        // repeated `contains` calls.\n+        // the analysis together via the fulfill (see comment above regarding\n+        // the usage of the fulfill machinery), rather than the\n+        // repeated `.iter().any(..)` calls.\n+\n+        // This closure is a more robust way to check `Predicate` equality\n+        // than simple `==` checks (which were the previous implementation).\n+        // It relies on `ty::relate` for `TraitPredicate` and `ProjectionPredicate`\n+        // (which implement the Relate trait), while delegating on simple equality\n+        // for the other `Predicate`.\n+        // This implementation solves (Issue #59497) and (Issue #58311).\n+        // It is unclear to me at the moment whether the approach based on `relate`\n+        // could be extended easily also to the other `Predicate`.\n+        let predicate_matches_closure = |p: &'_ Predicate<'tcx>| {\n+            let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n+            match (predicate, p) {\n+                (Predicate::Trait(a), Predicate::Trait(b)) => relator.relate(a, b).is_ok(),\n+                (Predicate::Projection(a), Predicate::Projection(b)) => {\n+                    relator.relate(a, b).is_ok()\n+                }\n+                _ => predicate == p,\n+            }\n+        };\n \n-        if !assumptions_in_impl_context.contains(&predicate) {\n+        if !assumptions_in_impl_context.iter().any(predicate_matches_closure) {\n             let item_span = tcx.hir().span(self_type_hir_id);\n             struct_span_err!(\n                 tcx.sess,\n@@ -251,3 +276,99 @@ crate fn check_drop_obligations<'a, 'tcx>(\n \n     Ok(())\n }\n+\n+// This is an implementation of the TypeRelation trait with the\n+// aim of simply comparing for equality (without side-effects).\n+// It is not intended to be used anywhere else other than here.\n+crate struct SimpleEqRelation<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> SimpleEqRelation<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> SimpleEqRelation<'tcx> {\n+        SimpleEqRelation { tcx, param_env }\n+    }\n+}\n+\n+impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"dropck::SimpleEqRelation\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        // Here we ignore variance because we require drop impl's types\n+        // to be *exactly* the same as to the ones in the struct definition.\n+        self.relate(a, b)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"SimpleEqRelation::tys(a={:?}, b={:?})\", a, b);\n+        ty::relate::super_relate_tys(self, a, b)\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"SimpleEqRelation::regions(a={:?}, b={:?})\", a, b);\n+\n+        // We can just equate the regions because LBRs have been\n+        // already anonymized.\n+        if a == b {\n+            Ok(a)\n+        } else {\n+            // I'm not sure is this `TypeError` is the right one, but\n+            // it should not matter as it won't be checked (the dropck\n+            // will emit its own, more informative and higher-level errors\n+            // in case anything goes wrong).\n+            Err(TypeError::RegionsPlaceholderMismatch)\n+        }\n+    }\n+\n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug!(\"SimpleEqRelation::consts(a={:?}, b={:?})\", a, b);\n+        ty::relate::super_relate_consts(self, a, b)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        debug!(\"SimpleEqRelation::binders({:?}: {:?}\", a, b);\n+\n+        // Anonymizing the LBRs is necessary to solve (Issue #59497).\n+        // After we do so, it should be totally fine to skip the binders.\n+        let anon_a = self.tcx.anonymize_late_bound_regions(a);\n+        let anon_b = self.tcx.anonymize_late_bound_regions(b);\n+        self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n+\n+        Ok(a.clone())\n+    }\n+}"}]}