{"sha": "90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwYzgxM2EwZjBiNTA0MmEyYmJmMmQ5ZWJmMjdmMjFhY2RiYzlmNzc=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-04T09:06:21Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-26T05:20:53Z"}, "message": "Move utf-8 validating helpers to new mod", "tree": {"sha": "f7cd58df60d04ab571c7fd4977bba19820eca858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7cd58df60d04ab571c7fd4977bba19820eca858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "html_url": "https://github.com/rust-lang/rust/commit/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f0d724e298ee4e19bef4e863c176dd87ef6400f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f0d724e298ee4e19bef4e863c176dd87ef6400f", "html_url": "https://github.com/rust-lang/rust/commit/5f0d724e298ee4e19bef4e863c176dd87ef6400f"}], "stats": {"total": 567, "additions": 288, "deletions": 279}, "files": [{"sha": "27a67e2b22f236a9d0c4197a3fded47cb1a5ca74", "filename": "library/core/src/str/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs?ref=90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "patch": "@@ -12,8 +12,8 @@ use crate::slice::{self, Split as SliceSplit};\n use super::from_utf8_unchecked;\n use super::pattern::Pattern;\n use super::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n+use super::validations::{next_code_point, next_code_point_reverse, utf8_is_cont_byte};\n use super::LinesAnyMap;\n-use super::{next_code_point, next_code_point_reverse, utf8_is_cont_byte};\n use super::{BytesIsNotEmpty, UnsafeBytesToStr};\n use super::{CharEscapeDebugContinue, CharEscapeDefault, CharEscapeUnicode};\n use super::{IsAsciiWhitespace, IsNotEmpty, IsWhitespace};"}, {"sha": "720a35bbc8f2cf662039b774395ee78709ab022d", "filename": "library/core/src/str/lossy.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Flossy.rs?ref=90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "patch": "@@ -1,7 +1,9 @@\n use crate::char;\n use crate::fmt::{self, Write};\n use crate::mem;\n-use crate::str as core_str;\n+\n+use super::from_utf8_unchecked;\n+use super::validations::utf8_char_width;\n \n /// Lossy UTF-8 string.\n #[unstable(feature = \"str_internals\", issue = \"none\")]\n@@ -66,14 +68,14 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n             if byte < 128 {\n             } else {\n-                let w = core_str::utf8_char_width(byte);\n+                let w = utf8_char_width(byte);\n \n                 macro_rules! error {\n                     () => {{\n                         // SAFETY: We have checked up to `i` that source is valid UTF-8.\n                         unsafe {\n                             let r = Utf8LossyChunk {\n-                                valid: core_str::from_utf8_unchecked(&self.source[0..i_]),\n+                                valid: from_utf8_unchecked(&self.source[0..i_]),\n                                 broken: &self.source[i_..i],\n                             };\n                             self.source = &self.source[i..];\n@@ -133,7 +135,7 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n         let r = Utf8LossyChunk {\n             // SAFETY: We have checked that the entire source is valid UTF-8.\n-            valid: unsafe { core_str::from_utf8_unchecked(self.source) },\n+            valid: unsafe { from_utf8_unchecked(self.source) },\n             broken: &[],\n         };\n         self.source = &[];"}, {"sha": "ab9bec2fd2dda3cb2041fc5a8f197ea732c062a1", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 6, "deletions": 274, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "patch": "@@ -11,6 +11,7 @@\n mod error;\n mod iter;\n mod traits;\n+mod validations;\n \n use self::pattern::Pattern;\n use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n@@ -62,10 +63,15 @@ pub use iter::SplitAsciiWhitespace;\n #[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n use iter::SplitInclusive;\n \n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+pub use validations::next_code_point;\n+\n use iter::MatchIndicesInternal;\n use iter::SplitInternal;\n use iter::{MatchesInternal, SplitNInternal};\n \n+use validations::{run_utf8_validation, truncate_to_char_boundary};\n+\n /*\n Section: Creating a string\n */\n@@ -257,102 +263,6 @@ pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n     unsafe { &mut *(v as *mut [u8] as *mut str) }\n }\n \n-/// Returns the initial codepoint accumulator for the first byte.\n-/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-/// for width 3, and 3 bits for width 4.\n-#[inline]\n-fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n-    (byte & (0x7F >> width)) as u32\n-}\n-\n-/// Returns the value of `ch` updated with continuation byte `byte`.\n-#[inline]\n-fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n-    (ch << 6) | (byte & CONT_MASK) as u32\n-}\n-\n-/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n-/// bits `10`).\n-#[inline]\n-fn utf8_is_cont_byte(byte: u8) -> bool {\n-    (byte & !CONT_MASK) == TAG_CONT_U8\n-}\n-\n-#[inline]\n-fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n-    match opt {\n-        Some(&byte) => byte,\n-        None => 0,\n-    }\n-}\n-\n-/// Reads the next code point out of a byte iterator (assuming a\n-/// UTF-8-like encoding).\n-#[unstable(feature = \"str_internals\", issue = \"none\")]\n-#[inline]\n-pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n-    // Decode UTF-8\n-    let x = *bytes.next()?;\n-    if x < 128 {\n-        return Some(x as u32);\n-    }\n-\n-    // Multibyte case follows\n-    // Decode from a byte combination out of: [[[x y] z] w]\n-    // NOTE: Performance is sensitive to the exact formulation here\n-    let init = utf8_first_byte(x, 2);\n-    let y = unwrap_or_0(bytes.next());\n-    let mut ch = utf8_acc_cont_byte(init, y);\n-    if x >= 0xE0 {\n-        // [[x y z] w] case\n-        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n-        let z = unwrap_or_0(bytes.next());\n-        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n-        ch = init << 12 | y_z;\n-        if x >= 0xF0 {\n-            // [x y z w] case\n-            // use only the lower 3 bits of `init`\n-            let w = unwrap_or_0(bytes.next());\n-            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n-        }\n-    }\n-\n-    Some(ch)\n-}\n-\n-/// Reads the last code point out of a byte iterator (assuming a\n-/// UTF-8-like encoding).\n-#[inline]\n-fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\n-where\n-    I: DoubleEndedIterator<Item = &'a u8>,\n-{\n-    // Decode UTF-8\n-    let w = match *bytes.next_back()? {\n-        next_byte if next_byte < 128 => return Some(next_byte as u32),\n-        back_byte => back_byte,\n-    };\n-\n-    // Multibyte case follows\n-    // Decode from a byte combination out of: [x [y [z w]]]\n-    let mut ch;\n-    let z = unwrap_or_0(bytes.next_back());\n-    ch = utf8_first_byte(z, 2);\n-    if utf8_is_cont_byte(z) {\n-        let y = unwrap_or_0(bytes.next_back());\n-        ch = utf8_first_byte(y, 3);\n-        if utf8_is_cont_byte(y) {\n-            let x = unwrap_or_0(bytes.next_back());\n-            ch = utf8_first_byte(x, 4);\n-            ch = utf8_acc_cont_byte(ch, y);\n-        }\n-        ch = utf8_acc_cont_byte(ch, z);\n-    }\n-    ch = utf8_acc_cont_byte(ch, w);\n-\n-    Some(ch)\n-}\n-\n impl_fn_for_zst! {\n     /// A nameable, cloneable fn type\n     #[derive(Clone)]\n@@ -363,184 +273,6 @@ impl_fn_for_zst! {\n     };\n }\n \n-/*\n-Section: UTF-8 validation\n-*/\n-\n-// use truncation to fit u64 into usize\n-const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n-\n-/// Returns `true` if any byte in the word `x` is nonascii (>= 128).\n-#[inline]\n-fn contains_nonascii(x: usize) -> bool {\n-    (x & NONASCII_MASK) != 0\n-}\n-\n-/// Walks through `v` checking that it's a valid UTF-8 sequence,\n-/// returning `Ok(())` in that case, or, if it is invalid, `Err(err)`.\n-#[inline(always)]\n-fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n-    let mut index = 0;\n-    let len = v.len();\n-\n-    let usize_bytes = mem::size_of::<usize>();\n-    let ascii_block_size = 2 * usize_bytes;\n-    let blocks_end = if len >= ascii_block_size { len - ascii_block_size + 1 } else { 0 };\n-    let align = v.as_ptr().align_offset(usize_bytes);\n-\n-    while index < len {\n-        let old_offset = index;\n-        macro_rules! err {\n-            ($error_len: expr) => {\n-                return Err(Utf8Error { valid_up_to: old_offset, error_len: $error_len });\n-            };\n-        }\n-\n-        macro_rules! next {\n-            () => {{\n-                index += 1;\n-                // we needed data, but there was none: error!\n-                if index >= len {\n-                    err!(None)\n-                }\n-                v[index]\n-            }};\n-        }\n-\n-        let first = v[index];\n-        if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as usize];\n-            // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n-            //        first  C2 80        last DF BF\n-            // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n-            //        first  E0 A0 80     last EF BF BF\n-            //   excluding surrogates codepoints  \\u{d800} to  \\u{dfff}\n-            //               ED A0 80 to       ED BF BF\n-            // 4-byte encoding is for codepoints \\u{1000}0 to \\u{10ff}ff\n-            //        first  F0 90 80 80  last F4 8F BF BF\n-            //\n-            // Use the UTF-8 syntax from the RFC\n-            //\n-            // https://tools.ietf.org/html/rfc3629\n-            // UTF8-1      = %x00-7F\n-            // UTF8-2      = %xC2-DF UTF8-tail\n-            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n-            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n-            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n-            //               %xF4 %x80-8F 2( UTF8-tail )\n-            match w {\n-                2 => {\n-                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n-                        err!(Some(1))\n-                    }\n-                }\n-                3 => {\n-                    match (first, next!()) {\n-                        (0xE0, 0xA0..=0xBF)\n-                        | (0xE1..=0xEC, 0x80..=0xBF)\n-                        | (0xED, 0x80..=0x9F)\n-                        | (0xEE..=0xEF, 0x80..=0xBF) => {}\n-                        _ => err!(Some(1)),\n-                    }\n-                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n-                        err!(Some(2))\n-                    }\n-                }\n-                4 => {\n-                    match (first, next!()) {\n-                        (0xF0, 0x90..=0xBF) | (0xF1..=0xF3, 0x80..=0xBF) | (0xF4, 0x80..=0x8F) => {}\n-                        _ => err!(Some(1)),\n-                    }\n-                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n-                        err!(Some(2))\n-                    }\n-                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n-                        err!(Some(3))\n-                    }\n-                }\n-                _ => err!(Some(1)),\n-            }\n-            index += 1;\n-        } else {\n-            // Ascii case, try to skip forward quickly.\n-            // When the pointer is aligned, read 2 words of data per iteration\n-            // until we find a word containing a non-ascii byte.\n-            if align != usize::MAX && align.wrapping_sub(index) % usize_bytes == 0 {\n-                let ptr = v.as_ptr();\n-                while index < blocks_end {\n-                    // SAFETY: since `align - index` and `ascii_block_size` are\n-                    // multiples of `usize_bytes`, `block = ptr.add(index)` is\n-                    // always aligned with a `usize` so it's safe to dereference\n-                    // both `block` and `block.offset(1)`.\n-                    unsafe {\n-                        let block = ptr.add(index) as *const usize;\n-                        // break if there is a nonascii byte\n-                        let zu = contains_nonascii(*block);\n-                        let zv = contains_nonascii(*block.offset(1));\n-                        if zu | zv {\n-                            break;\n-                        }\n-                    }\n-                    index += ascii_block_size;\n-                }\n-                // step from the point where the wordwise loop stopped\n-                while index < len && v[index] < 128 {\n-                    index += 1;\n-                }\n-            } else {\n-                index += 1;\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-// https://tools.ietf.org/html/rfc3629\n-static UTF8_CHAR_WIDTH: [u8; 256] = [\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-    1, // 0x1F\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-    1, // 0x3F\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-    1, // 0x5F\n-    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-    1, // 0x7F\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-    0, // 0x9F\n-    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n-    0, // 0xBF\n-    0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-    2, // 0xDF\n-    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, // 0xEF\n-    4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0xFF\n-];\n-\n-/// Given a first byte, determines how many bytes are in this UTF-8 character.\n-#[unstable(feature = \"str_internals\", issue = \"none\")]\n-#[inline]\n-pub fn utf8_char_width(b: u8) -> usize {\n-    UTF8_CHAR_WIDTH[b as usize] as usize\n-}\n-\n-/// Mask of the value bits of a continuation byte.\n-const CONT_MASK: u8 = 0b0011_1111;\n-/// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte.\n-const TAG_CONT_U8: u8 = 0b1000_0000;\n-\n-// truncate `&str` to length at most equal to `max`\n-// return `true` if it were truncated, and the new str.\n-fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n-    if max >= s.len() {\n-        (false, s)\n-    } else {\n-        while !s.is_char_boundary(max) {\n-            max -= 1;\n-        }\n-        (true, &s[..max])\n-    }\n-}\n-\n #[inline(never)]\n #[cold]\n #[track_caller]"}, {"sha": "10cf1e172e6e403b29dc85003119aea9b3c6c6b6", "filename": "library/core/src/str/validations.rs", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fvalidations.rs?ref=90c813a0f0b5042a2bbf2d9ebf27f21acdbc9f77", "patch": "@@ -0,0 +1,275 @@\n+//! Operations related to UTF-8 validation.\n+\n+use crate::mem;\n+\n+use super::Utf8Error;\n+\n+/// Returns the initial codepoint accumulator for the first byte.\n+/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+/// for width 3, and 3 bits for width 4.\n+#[inline]\n+fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n+    (byte & (0x7F >> width)) as u32\n+}\n+\n+/// Returns the value of `ch` updated with continuation byte `byte`.\n+#[inline]\n+fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n+    (ch << 6) | (byte & CONT_MASK) as u32\n+}\n+\n+/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n+/// bits `10`).\n+#[inline]\n+pub(super) fn utf8_is_cont_byte(byte: u8) -> bool {\n+    (byte & !CONT_MASK) == TAG_CONT_U8\n+}\n+\n+#[inline]\n+fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n+    match opt {\n+        Some(&byte) => byte,\n+        None => 0,\n+    }\n+}\n+\n+/// Reads the next code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+#[inline]\n+pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n+    // Decode UTF-8\n+    let x = *bytes.next()?;\n+    if x < 128 {\n+        return Some(x as u32);\n+    }\n+\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [[[x y] z] w]\n+    // NOTE: Performance is sensitive to the exact formulation here\n+    let init = utf8_first_byte(x, 2);\n+    let y = unwrap_or_0(bytes.next());\n+    let mut ch = utf8_acc_cont_byte(init, y);\n+    if x >= 0xE0 {\n+        // [[x y z] w] case\n+        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n+        let z = unwrap_or_0(bytes.next());\n+        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n+        ch = init << 12 | y_z;\n+        if x >= 0xF0 {\n+            // [x y z w] case\n+            // use only the lower 3 bits of `init`\n+            let w = unwrap_or_0(bytes.next());\n+            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n+        }\n+    }\n+\n+    Some(ch)\n+}\n+\n+/// Reads the last code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[inline]\n+pub(super) fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\n+where\n+    I: DoubleEndedIterator<Item = &'a u8>,\n+{\n+    // Decode UTF-8\n+    let w = match *bytes.next_back()? {\n+        next_byte if next_byte < 128 => return Some(next_byte as u32),\n+        back_byte => back_byte,\n+    };\n+\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [x [y [z w]]]\n+    let mut ch;\n+    let z = unwrap_or_0(bytes.next_back());\n+    ch = utf8_first_byte(z, 2);\n+    if utf8_is_cont_byte(z) {\n+        let y = unwrap_or_0(bytes.next_back());\n+        ch = utf8_first_byte(y, 3);\n+        if utf8_is_cont_byte(y) {\n+            let x = unwrap_or_0(bytes.next_back());\n+            ch = utf8_first_byte(x, 4);\n+            ch = utf8_acc_cont_byte(ch, y);\n+        }\n+        ch = utf8_acc_cont_byte(ch, z);\n+    }\n+    ch = utf8_acc_cont_byte(ch, w);\n+\n+    Some(ch)\n+}\n+\n+// use truncation to fit u64 into usize\n+const NONASCII_MASK: usize = 0x80808080_80808080u64 as usize;\n+\n+/// Returns `true` if any byte in the word `x` is nonascii (>= 128).\n+#[inline]\n+fn contains_nonascii(x: usize) -> bool {\n+    (x & NONASCII_MASK) != 0\n+}\n+\n+/// Walks through `v` checking that it's a valid UTF-8 sequence,\n+/// returning `Ok(())` in that case, or, if it is invalid, `Err(err)`.\n+#[inline(always)]\n+pub(super) fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n+    let mut index = 0;\n+    let len = v.len();\n+\n+    let usize_bytes = mem::size_of::<usize>();\n+    let ascii_block_size = 2 * usize_bytes;\n+    let blocks_end = if len >= ascii_block_size { len - ascii_block_size + 1 } else { 0 };\n+    let align = v.as_ptr().align_offset(usize_bytes);\n+\n+    while index < len {\n+        let old_offset = index;\n+        macro_rules! err {\n+            ($error_len: expr) => {\n+                return Err(Utf8Error { valid_up_to: old_offset, error_len: $error_len });\n+            };\n+        }\n+\n+        macro_rules! next {\n+            () => {{\n+                index += 1;\n+                // we needed data, but there was none: error!\n+                if index >= len {\n+                    err!(None)\n+                }\n+                v[index]\n+            }};\n+        }\n+\n+        let first = v[index];\n+        if first >= 128 {\n+            let w = UTF8_CHAR_WIDTH[first as usize];\n+            // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n+            //        first  C2 80        last DF BF\n+            // 3-byte encoding is for codepoints  \\u{0800} to  \\u{ffff}\n+            //        first  E0 A0 80     last EF BF BF\n+            //   excluding surrogates codepoints  \\u{d800} to  \\u{dfff}\n+            //               ED A0 80 to       ED BF BF\n+            // 4-byte encoding is for codepoints \\u{1000}0 to \\u{10ff}ff\n+            //        first  F0 90 80 80  last F4 8F BF BF\n+            //\n+            // Use the UTF-8 syntax from the RFC\n+            //\n+            // https://tools.ietf.org/html/rfc3629\n+            // UTF8-1      = %x00-7F\n+            // UTF8-2      = %xC2-DF UTF8-tail\n+            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n+            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n+            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n+            //               %xF4 %x80-8F 2( UTF8-tail )\n+            match w {\n+                2 => {\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(1))\n+                    }\n+                }\n+                3 => {\n+                    match (first, next!()) {\n+                        (0xE0, 0xA0..=0xBF)\n+                        | (0xE1..=0xEC, 0x80..=0xBF)\n+                        | (0xED, 0x80..=0x9F)\n+                        | (0xEE..=0xEF, 0x80..=0xBF) => {}\n+                        _ => err!(Some(1)),\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n+                    }\n+                }\n+                4 => {\n+                    match (first, next!()) {\n+                        (0xF0, 0x90..=0xBF) | (0xF1..=0xF3, 0x80..=0xBF) | (0xF4, 0x80..=0x8F) => {}\n+                        _ => err!(Some(1)),\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(2))\n+                    }\n+                    if next!() & !CONT_MASK != TAG_CONT_U8 {\n+                        err!(Some(3))\n+                    }\n+                }\n+                _ => err!(Some(1)),\n+            }\n+            index += 1;\n+        } else {\n+            // Ascii case, try to skip forward quickly.\n+            // When the pointer is aligned, read 2 words of data per iteration\n+            // until we find a word containing a non-ascii byte.\n+            if align != usize::MAX && align.wrapping_sub(index) % usize_bytes == 0 {\n+                let ptr = v.as_ptr();\n+                while index < blocks_end {\n+                    // SAFETY: since `align - index` and `ascii_block_size` are\n+                    // multiples of `usize_bytes`, `block = ptr.add(index)` is\n+                    // always aligned with a `usize` so it's safe to dereference\n+                    // both `block` and `block.offset(1)`.\n+                    unsafe {\n+                        let block = ptr.add(index) as *const usize;\n+                        // break if there is a nonascii byte\n+                        let zu = contains_nonascii(*block);\n+                        let zv = contains_nonascii(*block.offset(1));\n+                        if zu | zv {\n+                            break;\n+                        }\n+                    }\n+                    index += ascii_block_size;\n+                }\n+                // step from the point where the wordwise loop stopped\n+                while index < len && v[index] < 128 {\n+                    index += 1;\n+                }\n+            } else {\n+                index += 1;\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+// https://tools.ietf.org/html/rfc3629\n+static UTF8_CHAR_WIDTH: [u8; 256] = [\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, // 0x1F\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, // 0x3F\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, // 0x5F\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, // 0x7F\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, // 0x9F\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, // 0xBF\n+    0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n+    2, // 0xDF\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, // 0xEF\n+    4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0xFF\n+];\n+\n+/// Given a first byte, determines how many bytes are in this UTF-8 character.\n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+#[inline]\n+pub fn utf8_char_width(b: u8) -> usize {\n+    UTF8_CHAR_WIDTH[b as usize] as usize\n+}\n+\n+/// Mask of the value bits of a continuation byte.\n+const CONT_MASK: u8 = 0b0011_1111;\n+/// Value of the tag bits (tag mask is !CONT_MASK) of a continuation byte.\n+const TAG_CONT_U8: u8 = 0b1000_0000;\n+\n+// truncate `&str` to length at most equal to `max`\n+// return `true` if it were truncated, and the new str.\n+pub(super) fn truncate_to_char_boundary(s: &str, mut max: usize) -> (bool, &str) {\n+    if max >= s.len() {\n+        (false, s)\n+    } else {\n+        while !s.is_char_boundary(max) {\n+            max -= 1;\n+        }\n+        (true, &s[..max])\n+    }\n+}"}]}