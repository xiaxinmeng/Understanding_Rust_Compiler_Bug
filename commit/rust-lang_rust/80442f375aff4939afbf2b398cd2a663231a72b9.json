{"sha": "80442f375aff4939afbf2b398cd2a663231a72b9", "node_id": "C_kwDOAAsO6NoAKDgwNDQyZjM3NWFmZjQ5MzlhZmJmMmIzOThjZDJhNjYzMjMxYTcyYjk", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2022-08-24T14:14:51Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2022-08-24T14:35:51Z"}, "message": "error::Error: rename the chain method to sources\n\nSigned-off-by: Nick Cameron <nrc@ncameron.org>", "tree": {"sha": "0149f1141e4662019cb75a91c8efe684878ec078", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0149f1141e4662019cb75a91c8efe684878ec078"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80442f375aff4939afbf2b398cd2a663231a72b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80442f375aff4939afbf2b398cd2a663231a72b9", "html_url": "https://github.com/rust-lang/rust/commit/80442f375aff4939afbf2b398cd2a663231a72b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80442f375aff4939afbf2b398cd2a663231a72b9/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a24f08ba43166cfee86d868b3fe8612aec6faca", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a24f08ba43166cfee86d868b3fe8612aec6faca", "html_url": "https://github.com/rust-lang/rust/commit/4a24f08ba43166cfee86d868b3fe8612aec6faca"}], "stats": {"total": 70, "additions": 50, "deletions": 20}, "files": [{"sha": "37bd19c6f03c406d2014f3cfb6f092aa98b9d90c", "filename": "library/core/src/error.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/80442f375aff4939afbf2b398cd2a663231a72b9/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80442f375aff4939afbf2b398cd2a663231a72b9/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=80442f375aff4939afbf2b398cd2a663231a72b9", "patch": "@@ -30,12 +30,12 @@ use crate::fmt::{Debug, Display};\n /// assert_eq!(err.to_string(), \"invalid digit found in string\");\n /// ```\n ///\n-/// Errors may provide cause chain information. [`Error::source()`] is generally\n+/// Errors may provide cause information. [`Error::source()`] is generally\n /// used when errors cross \"abstraction boundaries\". If one module must report\n /// an error that is caused by an error from a lower-level module, it can allow\n /// accessing that error via [`Error::source()`]. This makes it possible for the\n /// high-level module to provide its own errors while also revealing some of the\n-/// implementation for debugging via `source` chains.\n+/// implementation for debugging.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Error\")]\n #[rustc_has_incoherent_inherent_impls]\n@@ -397,7 +397,7 @@ impl dyn Error {\n     /// // let err : Box<Error> = b.into(); // or\n     /// let err = &b as &(dyn Error);\n     ///\n-    /// let mut iter = err.chain();\n+    /// let mut iter = err.sources();\n     ///\n     /// assert_eq!(\"B\".to_string(), iter.next().unwrap().to_string());\n     /// assert_eq!(\"A\".to_string(), iter.next().unwrap().to_string());\n@@ -406,8 +406,23 @@ impl dyn Error {\n     /// ```\n     #[unstable(feature = \"error_iter\", issue = \"58520\")]\n     #[inline]\n-    pub fn chain(&self) -> Chain<'_> {\n-        Chain { current: Some(self) }\n+    pub fn sources(&self) -> Source<'_> {\n+        // You may think this method would be better in the Error trait, and you'd be right.\n+        // Unfortunately that doesn't work, not because of the object safety rules but because we\n+        // save a reference to self in Sources below as a trait object. If this method was\n+        // declared in Error, then self would have the type &T where T is some concrete type which\n+        // implements Error. We would need to coerce self to have type &dyn Error, but that requires\n+        // that Self has a known size (i.e., Self: Sized). We can't put that bound on Error\n+        // since that would forbid Error trait objects, and we can't put that bound on the method\n+        // because that means the method can't be called on trait objects (we'd also need the\n+        // 'static bound, but that isn't allowed because methods with bounds on Self other than\n+        // Sized are not object-safe). Requiring an Unsize bound is not backwards compatible.\n+        //\n+        // Two possible solutions are to start the iterator at self.source() instead of self (see\n+        // discussion on the tracking issue), or to wait for dyn* to exist (which would then permit\n+        // the coercion).\n+\n+        Source { current: Some(self) }\n     }\n }\n \n@@ -417,12 +432,12 @@ impl dyn Error {\n /// its sources, use `skip(1)`.\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n #[derive(Clone, Debug)]\n-pub struct Chain<'a> {\n+pub struct Source<'a> {\n     current: Option<&'a (dyn Error + 'static)>,\n }\n \n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n-impl<'a> Iterator for Chain<'a> {\n+impl<'a> Iterator for Source<'a> {\n     type Item = &'a (dyn Error + 'static);\n \n     fn next(&mut self) -> Option<Self::Item> {"}, {"sha": "70eeec557b1cbac104bda44ef23857281a3b7f34", "filename": "library/std/src/error.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/80442f375aff4939afbf2b398cd2a663231a72b9/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80442f375aff4939afbf2b398cd2a663231a72b9/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=80442f375aff4939afbf2b398cd2a663231a72b9", "patch": "@@ -69,12 +69,12 @@ pub use core::error::Error;\n /// assert_eq!(err.to_string(), \"invalid digit found in string\");\n /// ```\n ///\n-/// Errors may provide cause chain information. [`Error::source()`] is generally\n+/// Errors may provide cause information. [`Error::source()`] is generally\n /// used when errors cross \"abstraction boundaries\". If one module must report\n /// an error that is caused by an error from a lower-level module, it can allow\n /// accessing that error via [`Error::source()`]. This makes it possible for the\n /// high-level module to provide its own errors while also revealing some of the\n-/// implementation for debugging via `source` chains.\n+/// implementation for debugging.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Error\")]\n #[cfg(bootstrap)]\n@@ -976,7 +976,7 @@ impl dyn Error {\n     /// // let err : Box<Error> = b.into(); // or\n     /// let err = &b as &(dyn Error);\n     ///\n-    /// let mut iter = err.chain();\n+    /// let mut iter = err.sources();\n     ///\n     /// assert_eq!(\"B\".to_string(), iter.next().unwrap().to_string());\n     /// assert_eq!(\"A\".to_string(), iter.next().unwrap().to_string());\n@@ -985,8 +985,23 @@ impl dyn Error {\n     /// ```\n     #[unstable(feature = \"error_iter\", issue = \"58520\")]\n     #[inline]\n-    pub fn chain(&self) -> Chain<'_> {\n-        Chain { current: Some(self) }\n+    pub fn sources(&self) -> Sources<'_> {\n+        // You may think this method would be better in the Error trait, and you'd be right.\n+        // Unfortunately that doesn't work, not because of the object safety rules but because we\n+        // save a reference to self in Sources below as a trait object. If this method was\n+        // declared in Error, then self would have the type &T where T is some concrete type which\n+        // implements Error. We would need to coerce self to have type &dyn Error, but that requires\n+        // that Self has a known size (i.e., Self: Sized). We can't put that bound on Error\n+        // since that would forbid Error trait objects, and we can't put that bound on the method\n+        // because that means the method can't be called on trait objects (we'd also need the\n+        // 'static bound, but that isn't allowed because methods with bounds on Self other than\n+        // Sized are not object-safe). Requiring an Unsize bound is not backwards compatible.\n+        //\n+        // Two possible solutions are to start the iterator at self.source() instead of self (see\n+        // discussion on the tracking issue), or to wait for dyn* to exist (which would then permit\n+        // the coercion).\n+\n+        Sources { current: Some(self) }\n     }\n }\n \n@@ -997,13 +1012,13 @@ impl dyn Error {\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n #[derive(Clone, Debug)]\n #[cfg(bootstrap)]\n-pub struct Chain<'a> {\n+pub struct Sources<'a> {\n     current: Option<&'a (dyn Error + 'static)>,\n }\n \n #[cfg(bootstrap)]\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n-impl<'a> Iterator for Chain<'a> {\n+impl<'a> Iterator for Sources<'a> {\n     type Item = &'a (dyn Error + 'static);\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -1043,8 +1058,8 @@ impl dyn Error + Send + Sync {\n \n /// An error reporter that prints an error and its sources.\n ///\n-/// Report also exposes configuration options for formatting the error chain, either entirely on a\n-/// single line, or in multi-line format with each cause in the error chain on a new line.\n+/// Report also exposes configuration options for formatting the error sources, either entirely on a\n+/// single line, or in multi-line format with each source on a new line.\n ///\n /// `Report` only requires that the wrapped error implement `Error`. It doesn't require that the\n /// wrapped error be `Send`, `Sync`, or `'static`.\n@@ -1389,7 +1404,7 @@ impl<E> Report<E> {\n     ///\n     /// **Note**: Report will search for the first `Backtrace` it can find starting from the\n     /// outermost error. In this example it will display the backtrace from the second error in the\n-    /// chain, `SuperErrorSideKick`.\n+    /// sources, `SuperErrorSideKick`.\n     ///\n     /// ```rust\n     /// #![feature(error_reporter)]\n@@ -1486,7 +1501,7 @@ where\n         let backtrace = backtrace.or_else(|| {\n             self.error\n                 .source()\n-                .map(|source| source.chain().find_map(|source| source.request_ref()))\n+                .map(|source| source.sources().find_map(|source| source.request_ref()))\n                 .flatten()\n         });\n         backtrace\n@@ -1497,7 +1512,7 @@ where\n     fn fmt_singleline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.error)?;\n \n-        let sources = self.error.source().into_iter().flat_map(<dyn Error>::chain);\n+        let sources = self.error.source().into_iter().flat_map(<dyn Error>::sources);\n \n         for cause in sources {\n             write!(f, \": {cause}\")?;\n@@ -1518,7 +1533,7 @@ where\n \n             let multiple = cause.source().is_some();\n \n-            for (ind, error) in cause.chain().enumerate() {\n+            for (ind, error) in cause.sources().enumerate() {\n                 writeln!(f)?;\n                 let mut indented = Indented { inner: f };\n                 if multiple {"}]}