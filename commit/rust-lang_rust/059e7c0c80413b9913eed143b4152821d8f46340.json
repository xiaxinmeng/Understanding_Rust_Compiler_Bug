{"sha": "059e7c0c80413b9913eed143b4152821d8f46340", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1OWU3YzBjODA0MTNiOTkxM2VlZDE0M2I0MTUyODIxZDhmNDYzNDA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-07T17:01:49Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-08T09:39:48Z"}, "message": "rename EvalSnapshot -> InterpSnapshot", "tree": {"sha": "2a94ea1efab6c324c948b93c64cd65b4e533e026", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a94ea1efab6c324c948b93c64cd65b4e533e026"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/059e7c0c80413b9913eed143b4152821d8f46340", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/059e7c0c80413b9913eed143b4152821d8f46340", "html_url": "https://github.com/rust-lang/rust/commit/059e7c0c80413b9913eed143b4152821d8f46340", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/059e7c0c80413b9913eed143b4152821d8f46340/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f05ff3e33d8a21feaad1b72a8858475e305d84d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f05ff3e33d8a21feaad1b72a8858475e305d84d", "html_url": "https://github.com/rust-lang/rust/commit/8f05ff3e33d8a21feaad1b72a8858475e305d84d"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "ae09ae0a19836f7dee947a01fe380ed726e15d9b", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/059e7c0c80413b9913eed143b4152821d8f46340/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/059e7c0c80413b9913eed143b4152821d8f46340/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=059e7c0c80413b9913eed143b4152821d8f46340", "patch": "@@ -29,18 +29,18 @@ use crate::const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n pub(crate) struct InfiniteLoopDetector<'a, 'mir, 'tcx: 'a + 'mir> {\n-    /// The set of all `EvalSnapshot` *hashes* observed by this detector.\n+    /// The set of all `InterpSnapshot` *hashes* observed by this detector.\n     ///\n     /// When a collision occurs in this table, we store the full snapshot in\n     /// `snapshots`.\n     hashes: FxHashSet<u64>,\n \n-    /// The set of all `EvalSnapshot`s observed by this detector.\n+    /// The set of all `InterpSnapshot`s observed by this detector.\n     ///\n-    /// An `EvalSnapshot` will only be fully cloned once it has caused a\n+    /// An `InterpSnapshot` will only be fully cloned once it has caused a\n     /// collision in `hashes`. As a result, the detector must observe at least\n     /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<EvalSnapshot<'a, 'mir, 'tcx>>,\n+    snapshots: FxHashSet<InterpSnapshot<'a, 'mir, 'tcx>>,\n }\n \n impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n@@ -72,7 +72,7 @@ impl<'a, 'mir, 'tcx> InfiniteLoopDetector<'a, 'mir, 'tcx>\n         // We need to make a full copy. NOW things that to get really expensive.\n         info!(\"snapshotting the state of the interpreter\");\n \n-        if self.snapshots.insert(EvalSnapshot::new(memory, stack)) {\n+        if self.snapshots.insert(InterpSnapshot::new(memory, stack)) {\n             // Spurious collision or first cycle\n             return Ok(())\n         }\n@@ -384,18 +384,18 @@ impl<'a, 'b, 'mir, 'tcx: 'a+'mir> SnapshotContext<'b>\n /// The virtual machine state during const-evaluation at a given point in time.\n /// We assume the `CompileTimeInterpreter` has no interesting extra state that\n /// is worth considering here.\n-struct EvalSnapshot<'a, 'mir, 'tcx: 'a + 'mir> {\n+struct InterpSnapshot<'a, 'mir, 'tcx: 'a + 'mir> {\n     memory: Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n     stack: Vec<Frame<'mir, 'tcx>>,\n }\n \n-impl<'a, 'mir, 'tcx: 'a + 'mir> EvalSnapshot<'a, 'mir, 'tcx>\n+impl<'a, 'mir, 'tcx: 'a + 'mir> InterpSnapshot<'a, 'mir, 'tcx>\n {\n     fn new(\n         memory: &Memory<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n         stack: &[Frame<'mir, 'tcx>]\n     ) -> Self {\n-        EvalSnapshot {\n+        InterpSnapshot {\n             memory: memory.clone(),\n             stack: stack.into(),\n         }\n@@ -411,7 +411,7 @@ impl<'a, 'mir, 'tcx: 'a + 'mir> EvalSnapshot<'a, 'mir, 'tcx>\n \n }\n \n-impl<'a, 'mir, 'tcx> Hash for EvalSnapshot<'a, 'mir, 'tcx>\n+impl<'a, 'mir, 'tcx> Hash for InterpSnapshot<'a, 'mir, 'tcx>\n {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n         // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n@@ -422,16 +422,16 @@ impl<'a, 'mir, 'tcx> Hash for EvalSnapshot<'a, 'mir, 'tcx>\n     }\n }\n \n-impl_stable_hash_for!(impl<'tcx, 'b, 'mir> for struct EvalSnapshot<'b, 'mir, 'tcx> {\n+impl_stable_hash_for!(impl<'tcx, 'b, 'mir> for struct InterpSnapshot<'b, 'mir, 'tcx> {\n     // Not hashing memory: Avoid hashing memory all the time during execution\n     memory -> _,\n     stack,\n });\n \n-impl<'a, 'mir, 'tcx> Eq for EvalSnapshot<'a, 'mir, 'tcx>\n+impl<'a, 'mir, 'tcx> Eq for InterpSnapshot<'a, 'mir, 'tcx>\n {}\n \n-impl<'a, 'mir, 'tcx> PartialEq for EvalSnapshot<'a, 'mir, 'tcx>\n+impl<'a, 'mir, 'tcx> PartialEq for InterpSnapshot<'a, 'mir, 'tcx>\n {\n     fn eq(&self, other: &Self) -> bool {\n         // FIXME: This looks to be a *ridiculously expensive* comparison operation."}]}