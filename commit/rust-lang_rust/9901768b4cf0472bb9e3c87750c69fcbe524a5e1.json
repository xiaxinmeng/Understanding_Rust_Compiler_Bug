{"sha": "9901768b4cf0472bb9e3c87750c69fcbe524a5e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MDE3NjhiNGNmMDQ3MmJiOWUzYzg3NzUwYzY5ZmNiZTUyNGE1ZTE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-15T12:57:02Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-03-21T17:36:23Z"}, "message": "dont create MovePathIndex's for individual statics.\n\nInstead, create a single MovePathIndex that represents all statics.\n\n(An alternative here would be to disallow representing statics at all.\nI am hesitant to do that right now, in part because it could impose a\nrequirement that I thread checks for static data into the calling\ncode, either as pre- or post-invocation of `fn move_path_for`.)", "tree": {"sha": "1367325492c17511f97afeac2ff0102b1947b7a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1367325492c17511f97afeac2ff0102b1947b7a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9901768b4cf0472bb9e3c87750c69fcbe524a5e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9901768b4cf0472bb9e3c87750c69fcbe524a5e1", "html_url": "https://github.com/rust-lang/rust/commit/9901768b4cf0472bb9e3c87750c69fcbe524a5e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9901768b4cf0472bb9e3c87750c69fcbe524a5e1/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b67d099f50aca92c788d2e5b63b3efe02ea7951", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b67d099f50aca92c788d2e5b63b3efe02ea7951", "html_url": "https://github.com/rust-lang/rust/commit/9b67d099f50aca92c788d2e5b63b3efe02ea7951"}], "stats": {"total": 92, "additions": 63, "deletions": 29}, "files": [{"sha": "309efeba3205de1b22061fdcf7a4dfaf90de9e42", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 63, "deletions": 29, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/9901768b4cf0472bb9e3c87750c69fcbe524a5e1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9901768b4cf0472bb9e3c87750c69fcbe524a5e1/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=9901768b4cf0472bb9e3c87750c69fcbe524a5e1", "patch": "@@ -10,7 +10,6 @@\n \n \n use rustc::middle::ty;\n-use rustc::middle::def_id::DefId;\n use rustc::mir::repr::{self, Mir, BasicBlock, Lvalue, Rvalue};\n use rustc::mir::repr::{StatementKind, Terminator};\n use rustc::util::nodemap::FnvHashMap;\n@@ -75,7 +74,18 @@ pub struct MovePath<'tcx> {\n     pub next_sibling: Option<MovePathIndex>,\n     pub first_child: Option<MovePathIndex>,\n     pub parent: Option<MovePathIndex>,\n-    pub lvalue: Lvalue<'tcx>,\n+    pub content: MovePathContent<'tcx>,\n+}\n+\n+/// MovePaths usually represent a single l-value. The exceptions are\n+/// forms that arise due to erroneous input code: static data holds\n+/// l-values that we cannot actually move out of. Therefore we map\n+/// statics to a special marker value (`MovePathContent::Static`)\n+/// representing an invalid origin.\n+#[derive(Clone, Debug)]\n+pub enum MovePathContent<'tcx> {\n+    Lvalue(Lvalue<'tcx>),\n+    Static,\n }\n \n /// During construction of the MovePath's, we use PreMovePath to\n@@ -86,15 +96,15 @@ struct PreMovePath<'tcx> {\n     pub next_sibling: Option<MovePathIndex>,\n     pub first_child: Cell<Option<MovePathIndex>>,\n     pub parent: Option<MovePathIndex>,\n-    pub lvalue: Lvalue<'tcx>,\n+    pub content: MovePathContent<'tcx>,\n }\n \n impl<'tcx> PreMovePath<'tcx> {\n     fn into_move_path(self) -> MovePath<'tcx> {\n         MovePath {\n             next_sibling: self.next_sibling,\n             parent: self.parent,\n-            lvalue: self.lvalue,\n+            content: self.content,\n             first_child: self.first_child.get(),\n         }\n     }\n@@ -112,7 +122,7 @@ impl<'tcx> fmt::Debug for MovePath<'tcx> {\n         if let Some(next_sibling) = self.next_sibling {\n             try!(write!(w, \" next_sibling: {:?}\", next_sibling));\n         }\n-        write!(w, \" lvalue: {:?} }}\", self.lvalue)\n+        write!(w, \" content: {:?} }}\", self.content)\n     }\n }\n \n@@ -219,13 +229,19 @@ pub struct MovePathLookup<'tcx> {\n     vars: MovePathInverseMap,\n     temps: MovePathInverseMap,\n     args: MovePathInverseMap,\n-    statics: FnvHashMap<DefId, MovePathIndex>,\n+\n+    /// The move path representing the return value is constructed\n+    /// lazily when we first encounter it in the input MIR.\n     return_ptr: Option<MovePathIndex>,\n \n-    /// This is the only non-trivial lookup to explain: projections\n-    /// are made from a base-lvalue and a projection elem. The\n-    /// base-lvalue will have a unique MovePathIndex; we use the\n-    /// latter as the index into the outer vector (narrowing\n+    /// A single move path (representing any static data referenced)\n+    /// is constructed lazily when we first encounter statics in the\n+    /// input MIR.\n+    statics: Option<MovePathIndex>,\n+\n+    /// projections are made from a base-lvalue and a projection\n+    /// elem. The base-lvalue will have a unique MovePathIndex; we use\n+    /// the latter as the index into the outer vector (narrowing\n     /// subsequent search so that it is solely relative to that\n     /// base-lvalue). For the remaining lookup, we map the projection\n     /// elem to the associated MovePathIndex.\n@@ -269,7 +285,7 @@ impl<'tcx> MovePathLookup<'tcx> {\n             vars: vec![],\n             temps: vec![],\n             args: vec![],\n-            statics: Default::default(),\n+            statics: None,\n             return_ptr: None,\n             projections: vec![],\n             next_index: MovePathIndex::new(0),\n@@ -318,16 +334,14 @@ impl<'tcx> MovePathLookup<'tcx> {\n                                  &mut self.next_index)\n     }\n \n-    fn lookup_static(&mut self, static_id: DefId) -> Lookup<MovePathIndex> {\n-        let &mut MovePathLookup { ref mut statics,\n-                                  ref mut next_index, .. } = self;\n-        match statics.entry(static_id.clone()) {\n-            Entry::Occupied(ent) => {\n-                Lookup(LookupKind::Reuse, *ent.get())\n+    fn lookup_static(&mut self) -> Lookup<MovePathIndex> {\n+        match self.statics {\n+            Some(mpi) => {\n+                Lookup(LookupKind::Reuse, mpi)\n             }\n-            Entry::Vacant(ent) => {\n-                let mpi = Self::next_index(next_index);\n-                ent.insert(mpi);\n+            ref mut ret @ None => {\n+                let mpi = Self::next_index(&mut self.next_index);\n+                *ret = Some(mpi);\n                 Lookup(LookupKind::Generate, mpi)\n             }\n         }\n@@ -374,7 +388,7 @@ impl<'tcx> MovePathLookup<'tcx> {\n             Lvalue::Var(var_idx) => self.vars[var_idx as usize].unwrap(),\n             Lvalue::Temp(temp_idx) => self.temps[temp_idx as usize].unwrap(),\n             Lvalue::Arg(arg_idx) => self.args[arg_idx as usize].unwrap(),\n-            Lvalue::Static(ref def_id) => self.statics[def_id],\n+            Lvalue::Static(ref _def_id) => self.statics.unwrap(),\n             Lvalue::ReturnPointer => self.return_ptr.unwrap(),\n             Lvalue::Projection(ref proj) => {\n                 let base_index = self.find(&proj.base);\n@@ -394,11 +408,16 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n         let lookup = {\n             let mut rev_lookup = self.rev_lookup.borrow_mut();\n             match *lval {\n-                Lvalue::Var(var_idx) => rev_lookup.lookup_var(var_idx),\n-                Lvalue::Temp(temp_idx) => rev_lookup.lookup_temp(temp_idx),\n-                Lvalue::Arg(arg_idx) => rev_lookup.lookup_arg(arg_idx),\n-                Lvalue::Static(def_id) => rev_lookup.lookup_static(def_id),\n-                Lvalue::ReturnPointer => rev_lookup.lookup_return_pointer(),\n+                Lvalue::Var(var_idx) =>\n+                    rev_lookup.lookup_var(var_idx),\n+                Lvalue::Temp(temp_idx) =>\n+                    rev_lookup.lookup_temp(temp_idx),\n+                Lvalue::Arg(arg_idx) =>\n+                    rev_lookup.lookup_arg(arg_idx),\n+                Lvalue::Static(_def_id) =>\n+                    rev_lookup.lookup_static(),\n+                Lvalue::ReturnPointer =>\n+                    rev_lookup.lookup_return_pointer(),\n                 Lvalue::Projection(ref proj) => {\n                     // Manually drop the rev_lookup ...\n                     drop(rev_lookup);\n@@ -423,16 +442,26 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n         if let Lookup(LookupKind::Generate, mpi) = lookup {\n             let parent;\n             let sibling;\n+            // tracks whether content is Some non-static; statics map to None.\n+            let content: Option<&Lvalue<'tcx>>;\n \n             match *lval {\n+                Lvalue::Static(_) => {\n+                    content = None;\n+                    sibling = None;\n+                    parent = None;\n+                }\n+\n                 Lvalue::Var(_) | Lvalue::Temp(_) | Lvalue::Arg(_) |\n-                Lvalue::Static(_) | Lvalue::ReturnPointer => {\n+                Lvalue::ReturnPointer => {\n+                    content = Some(lval);\n                     sibling = None;\n                     parent = None;\n                 }\n                 Lvalue::Projection(ref proj) => {\n-                    // Here, install new MovePath as new first_child.\n+                    content = Some(lval);\n \n+                    // Here, install new MovePath as new first_child.\n                     drop(pre_move_paths);\n \n                     // Note: `parent` previously allocated (Projection\n@@ -449,10 +478,15 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n                 }\n             };\n \n+            let content = match content {\n+                Some(lval) => MovePathContent::Lvalue(lval.clone()),\n+                None => MovePathContent::Static,\n+            };\n+\n             let move_path = PreMovePath {\n                 next_sibling: sibling,\n                 parent: parent,\n-                lvalue: lval.clone(),\n+                content: content,\n                 first_child: Cell::new(None),\n             };\n "}]}