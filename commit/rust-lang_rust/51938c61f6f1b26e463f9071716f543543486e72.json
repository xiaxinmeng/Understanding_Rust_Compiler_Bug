{"sha": "51938c61f6f1b26e463f9071716f543543486e72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOTM4YzYxZjZmMWIyNmU0NjNmOTA3MTcxNmY1NDM1NDM0ODZlNzI=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-12-08T19:30:23Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-10T03:49:45Z"}, "message": "Make the rustc driver and interface demand driven", "tree": {"sha": "f2e5517038528b1912c1c4a19da50a140f4b1c61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2e5517038528b1912c1c4a19da50a140f4b1c61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51938c61f6f1b26e463f9071716f543543486e72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51938c61f6f1b26e463f9071716f543543486e72", "html_url": "https://github.com/rust-lang/rust/commit/51938c61f6f1b26e463f9071716f543543486e72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51938c61f6f1b26e463f9071716f543543486e72/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26b4cb48484382032522384318e70ceb0fbc4a41", "url": "https://api.github.com/repos/rust-lang/rust/commits/26b4cb48484382032522384318e70ceb0fbc4a41", "html_url": "https://github.com/rust-lang/rust/commit/26b4cb48484382032522384318e70ceb0fbc4a41"}], "stats": {"total": 5256, "additions": 2511, "deletions": 2745}, "files": [{"sha": "7e0abf752303153c5dda122f546fd780f4a06c88", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -946,11 +946,6 @@ impl_stable_hash_for!(struct ty::CrateInherentImpls {\n     inherent_impls\n });\n \n-impl_stable_hash_for!(enum crate::session::CompileIncomplete {\n-    Stopped,\n-    Errored(error_reported)\n-});\n-\n impl_stable_hash_for!(struct crate::util::common::ErrorReported {});\n \n impl_stable_hash_for!(tuple_struct crate::middle::reachable::ReachableSet {"}, {"sha": "55c4b0e54b8223f4061f23f125aed699f3d0d31b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -11,6 +11,7 @@ use rustc_target::spec::{Target, TargetTriple};\n use crate::lint;\n use crate::middle::cstore;\n \n+use syntax;\n use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n@@ -1494,6 +1495,15 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     ret\n }\n \n+/// Converts the crate cfg! configuration from String to Symbol.\n+/// `rustc_interface::interface::Config` accepts this in the compiler configuration,\n+/// but the symbol interner is not yet set up then, so we must convert it later.\n+pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> ast::CrateConfig {\n+    cfg.into_iter()\n+       .map(|(a, b)| (Symbol::intern(&a), b.map(|b| Symbol::intern(&b))))\n+       .collect()\n+}\n+\n pub fn build_configuration(sess: &Session, mut user_cfg: ast::CrateConfig) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n@@ -1800,10 +1810,9 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n-    cfgspecs\n-        .into_iter()\n-        .map(|s| {\n+pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n+    syntax::with_globals(move || {\n+        let cfg = cfgspecs.into_iter().map(|s| {\n             let sess = parse::ParseSess::new(FilePathMapping::empty());\n             let filename = FileName::cfg_spec_source_code(&s);\n             let mut parser = parse::new_parser_from_source_str(&sess, filename, s.to_string());\n@@ -1835,8 +1844,11 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n             }\n \n             error!(r#\"expected `key` or `key=\"value\"`\"#);\n-        })\n-        .collect::<ast::CrateConfig>()\n+        }).collect::<ast::CrateConfig>();\n+        cfg.into_iter().map(|(a, b)| {\n+            (a.to_string(), b.map(|b| b.to_string()))\n+        }).collect()\n+    })\n }\n \n pub fn get_cmd_lint_options(matches: &getopts::Matches,\n@@ -1864,7 +1876,7 @@ pub fn get_cmd_lint_options(matches: &getopts::Matches,\n \n pub fn build_session_options_and_crate_config(\n     matches: &getopts::Matches,\n-) -> (Options, ast::CrateConfig) {\n+) -> (Options, FxHashSet<(String, Option<String>)>) {\n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n         Some(\"auto\") => ColorConfig::Auto,\n         Some(\"always\") => ColorConfig::Always,\n@@ -2590,7 +2602,11 @@ mod tests {\n     use getopts;\n     use crate::lint;\n     use crate::middle::cstore;\n-    use crate::session::config::{build_configuration, build_session_options_and_crate_config};\n+    use crate::session::config::{\n+        build_configuration,\n+        build_session_options_and_crate_config,\n+        to_crate_config\n+    };\n     use crate::session::config::{LtoCli, LinkerPluginLto};\n     use crate::session::build_session;\n     use crate::session::search_paths::SearchPath;\n@@ -2631,7 +2647,7 @@ mod tests {\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n             let sess = build_session(sessopts, None, registry);\n-            let cfg = build_configuration(&sess, cfg);\n+            let cfg = build_configuration(&sess, to_crate_config(cfg));\n             assert!(cfg.contains(&(Symbol::intern(\"test\"), None)));\n         });\n     }\n@@ -2649,7 +2665,7 @@ mod tests {\n             let registry = errors::registry::Registry::new(&[]);\n             let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n             let sess = build_session(sessopts, None, registry);\n-            let cfg = build_configuration(&sess, cfg);\n+            let cfg = build_configuration(&sess, to_crate_config(cfg));\n             let mut test_items = cfg.iter().filter(|&&(name, _)| name == \"test\");\n             assert!(test_items.next().is_some());\n             assert!(test_items.next().is_none());"}, {"sha": "75a0a8195bc2ef1dcd5b114e92eeecf36d5e3eac", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -311,7 +311,7 @@ impl Session {\n     pub fn abort_if_errors(&self) {\n         self.diagnostic().abort_if_errors();\n     }\n-    pub fn compile_status(&self) -> Result<(), CompileIncomplete> {\n+    pub fn compile_status(&self) -> Result<(), ErrorReported> {\n         compile_result_from_err_count(self.err_count())\n     }\n     pub fn track_errors<F, T>(&self, f: F) -> Result<T, ErrorReported>\n@@ -1124,7 +1124,7 @@ pub fn build_session_with_source_map(\n     build_session_(sopts, local_crate_source_file, diagnostic_handler, source_map, lint_caps)\n }\n \n-pub fn build_session_(\n+fn build_session_(\n     sopts: config::Options,\n     local_crate_source_file: Option<PathBuf>,\n     span_diagnostic: errors::Handler,\n@@ -1334,22 +1334,12 @@ pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     handler.emit(&MultiSpan::new(), msg, errors::Level::Warning);\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum CompileIncomplete {\n-    Stopped,\n-    Errored(ErrorReported),\n-}\n-impl From<ErrorReported> for CompileIncomplete {\n-    fn from(err: ErrorReported) -> CompileIncomplete {\n-        CompileIncomplete::Errored(err)\n-    }\n-}\n-pub type CompileResult = Result<(), CompileIncomplete>;\n+pub type CompileResult = Result<(), ErrorReported>;\n \n pub fn compile_result_from_err_count(err_count: usize) -> CompileResult {\n     if err_count == 0 {\n         Ok(())\n     } else {\n-        Err(CompileIncomplete::Errored(ErrorReported))\n+        Err(ErrorReported)\n     }\n }"}, {"sha": "b705968ce8aeded42ac39e98f0f190d38a15942e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 37, "deletions": 50, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -78,15 +78,13 @@ use crate::hir;\n pub struct AllArenas<'tcx> {\n     pub global: WorkerLocal<GlobalArenas<'tcx>>,\n     pub interner: SyncDroplessArena,\n-    global_ctxt: Option<GlobalCtxt<'tcx>>,\n }\n \n impl<'tcx> AllArenas<'tcx> {\n     pub fn new() -> Self {\n         AllArenas {\n             global: WorkerLocal::new(|_| GlobalArenas::default()),\n             interner: SyncDroplessArena::default(),\n-            global_ctxt: None,\n         }\n     }\n }\n@@ -1182,20 +1180,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n-    pub fn create_and_enter<F, R>(s: &'tcx Session,\n-                                  cstore: &'tcx CrateStoreDyn,\n-                                  local_providers: ty::query::Providers<'tcx>,\n-                                  extern_providers: ty::query::Providers<'tcx>,\n-                                  arenas: &'tcx mut AllArenas<'tcx>,\n-                                  resolutions: ty::Resolutions,\n-                                  hir: hir_map::Map<'tcx>,\n-                                  on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n-                                  crate_name: &str,\n-                                  tx: mpsc::Sender<Box<dyn Any + Send>>,\n-                                  output_filenames: &OutputFilenames,\n-                                  f: F) -> R\n-                                  where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n-    {\n+    pub fn create_global_ctxt(\n+        s: &'tcx Session,\n+        cstore: &'tcx CrateStoreDyn,\n+        local_providers: ty::query::Providers<'tcx>,\n+        extern_providers: ty::query::Providers<'tcx>,\n+        arenas: &'tcx AllArenas<'tcx>,\n+        resolutions: ty::Resolutions,\n+        hir: hir_map::Map<'tcx>,\n+        on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n+        crate_name: &str,\n+        tx: mpsc::Sender<Box<dyn Any + Send>>,\n+        output_filenames: &OutputFilenames,\n+    ) -> GlobalCtxt<'tcx> {\n         let data_layout = TargetDataLayout::parse(&s.target.target).unwrap_or_else(|err| {\n             s.fatal(&err);\n         });\n@@ -1247,7 +1244,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                      Lrc::new(StableVec::new(v)));\n         }\n \n-        arenas.global_ctxt = Some(GlobalCtxt {\n+        GlobalCtxt {\n             sess: s,\n             cstore,\n             global_arenas: &arenas.global,\n@@ -1293,15 +1290,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             tx_to_llvm_workers: Lock::new(tx),\n             output_filenames: Arc::new(output_filenames.clone()),\n-        });\n-\n-        let gcx = arenas.global_ctxt.as_ref().unwrap();\n-\n-        let r = tls::enter_global(gcx, f);\n-\n-        gcx.queries.record_computed_queries(s);\n-\n-        r\n+        }\n     }\n \n     pub fn consider_optimizing<T: Fn() -> String>(&self, msg: T) -> bool {\n@@ -1985,31 +1974,29 @@ pub mod tls {\n     pub fn enter_global<'gcx, F, R>(gcx: &'gcx GlobalCtxt<'gcx>, f: F) -> R\n         where F: FnOnce(TyCtxt<'gcx, 'gcx, 'gcx>) -> R\n     {\n-        with_thread_locals(|| {\n-            // Update GCX_PTR to indicate there's a GlobalCtxt available\n-            GCX_PTR.with(|lock| {\n-                *lock.lock() = gcx as *const _ as usize;\n-            });\n-            // Set GCX_PTR back to 0 when we exit\n-            let _on_drop = OnDrop(move || {\n-                GCX_PTR.with(|lock| *lock.lock() = 0);\n-            });\n+        // Update GCX_PTR to indicate there's a GlobalCtxt available\n+        GCX_PTR.with(|lock| {\n+            *lock.lock() = gcx as *const _ as usize;\n+        });\n+        // Set GCX_PTR back to 0 when we exit\n+        let _on_drop = OnDrop(move || {\n+            GCX_PTR.with(|lock| *lock.lock() = 0);\n+        });\n \n-            let tcx = TyCtxt {\n-                gcx,\n-                interners: &gcx.global_interners,\n-                dummy: PhantomData,\n-            };\n-            let icx = ImplicitCtxt {\n-                tcx,\n-                query: None,\n-                diagnostics: None,\n-                layout_depth: 0,\n-                task_deps: None,\n-            };\n-            enter_context(&icx, |_| {\n-                f(tcx)\n-            })\n+        let tcx = TyCtxt {\n+            gcx,\n+            interners: &gcx.global_interners,\n+            dummy: PhantomData,\n+        };\n+        let icx = ImplicitCtxt {\n+            tcx,\n+            query: None,\n+            diagnostics: None,\n+            layout_depth: 0,\n+            task_deps: None,\n+        };\n+        enter_context(&icx, |_| {\n+            f(tcx)\n         })\n     }\n "}, {"sha": "1a44dbdbb61aeffa1b6f709e77cdcb618887fae3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -71,7 +71,7 @@ pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, FreeRegionInfo, GlobalArenas, AllArenas, tls, keep_local};\n-pub use self::context::{Lift, TypeckTables, CtxtInterners};\n+pub use self::context::{Lift, TypeckTables, CtxtInterners, GlobalCtxt};\n pub use self::context::{\n     UserTypeAnnotationIndex, UserType, CanonicalUserType,\n     CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, ResolvedOpaqueTy,"}, {"sha": "7b2b9ec24ea0f2d964b43e9d17e05b785d3a9907", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -63,11 +63,12 @@ use std::sync::{mpsc, Arc};\n use rustc::dep_graph::DepGraph;\n use rustc::middle::allocator::AllocatorKind;\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n-use rustc::session::{Session, CompileIncomplete};\n+use rustc::session::Session;\n use rustc::session::config::{OutputFilenames, OutputType, PrintRequest, OptLevel};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::time_graph;\n use rustc::util::profiling::ProfileCategory;\n+use rustc::util::common::ErrorReported;\n use rustc_mir::monomorphize;\n use rustc_codegen_ssa::ModuleCodegen;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n@@ -311,7 +312,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n         sess: &Session,\n         dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n-    ) -> Result<(), CompileIncomplete>{\n+    ) -> Result<(), ErrorReported>{\n         use rustc::util::common::time;\n         let (codegen_results, work_products) =\n             ongoing_codegen.downcast::"}, {"sha": "29bcb4f2e6446d0f0fcba81296a7a36a09d3443a", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -21,7 +21,8 @@ use flate2::write::DeflateEncoder;\n \n use syntax::symbol::Symbol;\n use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::session::{Session, CompileIncomplete};\n+use rustc::session::Session;\n+use rustc::util::common::ErrorReported;\n use rustc::session::config::{CrateType, OutputFilenames, PrintRequest};\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n@@ -61,7 +62,7 @@ pub trait CodegenBackend {\n         sess: &Session,\n         dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n-    ) -> Result<(), CompileIncomplete>;\n+    ) -> Result<(), ErrorReported>;\n }\n \n pub struct NoLlvmMetadataLoader;\n@@ -163,7 +164,7 @@ impl CodegenBackend for MetadataOnlyCodegenBackend {\n         sess: &Session,\n         _dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n-    ) -> Result<(), CompileIncomplete> {\n+    ) -> Result<(), ErrorReported> {\n         let ongoing_codegen = ongoing_codegen.downcast::<OngoingCodegen>()\n             .expect(\"Expected MetadataOnlyCodegenBackend's OngoingCodegen, found Box<dyn Any>\");\n         for &crate_type in sess.opts.crate_types.iter() {"}, {"sha": "278dcdf2bee42a49b830690e37bc00fa493388b2", "filename": "src/librustc_data_structures/box_region.rs", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_data_structures%2Fbox_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_data_structures%2Fbox_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbox_region.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -0,0 +1,172 @@\n+use std::cell::Cell;\n+use std::marker::PhantomData;\n+use std::pin::Pin;\n+use std::ops::{Generator, GeneratorState};\n+\n+#[derive(Copy, Clone)]\n+pub struct AccessAction(*mut dyn FnMut());\n+\n+impl AccessAction {\n+    pub fn get(self) -> *mut dyn FnMut() {\n+        self.0\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum Action {\n+    Access(AccessAction),\n+    Complete,\n+}\n+\n+thread_local!(pub static BOX_REGION_ARG: Cell<Action> = Cell::new(Action::Complete));\n+\n+pub struct PinnedGenerator<I, A, R> {\n+    generator: Pin<Box<dyn Generator<Yield = YieldType<I, A>, Return = R>>>\n+}\n+\n+impl<I, A, R> PinnedGenerator<I, A, R> {\n+    pub fn new<\n+        T: Generator<Yield = YieldType<I, A>, Return = R> + 'static\n+    >(generator: T) -> (I, Self) {\n+        let mut result = PinnedGenerator {\n+            generator: Box::pin(generator)\n+        };\n+\n+        // Run it to the first yield to set it up\n+        let init = match Pin::new(&mut result.generator).resume() {\n+            GeneratorState::Yielded(\n+                YieldType::Initial(y)\n+            ) => y,\n+            _ => panic!()\n+        };\n+\n+        (init, result)\n+    }\n+\n+    pub unsafe fn access(&mut self, closure: *mut dyn FnMut()) {\n+        BOX_REGION_ARG.with(|i| {\n+            i.set(Action::Access(AccessAction(closure)));\n+        });\n+\n+        // Call the generator, which in turn will call the closure in BOX_REGION_ARG\n+        if let GeneratorState::Complete(_) = Pin::new(&mut self.generator).resume() {\n+            panic!()\n+        }\n+    }\n+\n+    pub fn complete(&mut self) -> R {\n+        // Tell the generator we want it to complete, consuming it and yielding a result\n+        BOX_REGION_ARG.with(|i| {\n+            i.set(Action::Complete)\n+        });\n+\n+        let result = Pin::new(&mut self.generator).resume();\n+        if let GeneratorState::Complete(r) = result {\n+            r\n+        } else {\n+            panic!()\n+        }\n+    }\n+}\n+\n+#[derive(PartialEq)]\n+pub struct Marker<T>(PhantomData<T>);\n+\n+impl<T> Marker<T> {\n+    pub unsafe fn new() -> Self {\n+        Marker(PhantomData)\n+    }\n+}\n+\n+pub enum YieldType<I, A> {\n+    Initial(I),\n+    Accessor(Marker<A>),\n+}\n+\n+#[macro_export]\n+#[allow_internal_unstable(fn_traits)]\n+macro_rules! declare_box_region_type {\n+    (impl $v:vis\n+     $name: ident,\n+     $yield_type:ty,\n+     for($($lifetimes:tt)*),\n+     ($($args:ty),*) -> ($reti:ty, $retc:ty)\n+    ) => {\n+        $v struct $name($crate::box_region::PinnedGenerator<\n+            $reti,\n+            for<$($lifetimes)*> fn(($($args,)*)),\n+            $retc\n+        >);\n+\n+        impl $name {\n+            fn new<T: ::std::ops::Generator<Yield = $yield_type, Return = $retc> + 'static>(\n+                generator: T\n+            ) -> ($reti, Self) {\n+                let (initial, pinned) = $crate::box_region::PinnedGenerator::new(generator);\n+                (initial, $name(pinned))\n+            }\n+\n+            $v fn access<F: for<$($lifetimes)*> FnOnce($($args,)*) -> R, R>(&mut self, f: F) -> R {\n+                // Turn the FnOnce closure into *mut dyn FnMut()\n+                // so we can pass it in to the generator using the BOX_REGION_ARG thread local\n+                let mut r = None;\n+                let mut f = Some(f);\n+                let mut_f: &mut dyn for<$($lifetimes)*> FnMut(($($args,)*)) =\n+                    &mut |args| {\n+                        let f = f.take().unwrap();\n+                        r = Some(FnOnce::call_once(f, args));\n+                };\n+                let mut_f = mut_f as *mut dyn for<$($lifetimes)*> FnMut(($($args,)*));\n+\n+                // Get the generator to call our closure\n+                unsafe {\n+                    self.0.access(::std::mem::transmute(mut_f));\n+                }\n+\n+                // Unwrap the result\n+                r.unwrap()\n+            }\n+\n+            $v fn complete(mut self) -> $retc {\n+                self.0.complete()\n+            }\n+\n+            fn initial_yield(value: $reti) -> $yield_type {\n+                $crate::box_region::YieldType::Initial(value)\n+            }\n+        }\n+    };\n+\n+    ($v:vis $name: ident, for($($lifetimes:tt)*), ($($args:ty),*) -> ($reti:ty, $retc:ty)) => {\n+        declare_box_region_type!(\n+            impl $v $name,\n+            $crate::box_region::YieldType<$reti, for<$($lifetimes)*> fn(($($args,)*))>,\n+            for($($lifetimes)*),\n+            ($($args),*) -> ($reti, $retc)\n+        );\n+    };\n+}\n+\n+#[macro_export]\n+#[allow_internal_unstable(fn_traits)]\n+macro_rules! box_region_allow_access {\n+    (for($($lifetimes:tt)*), ($($args:ty),*), ($($exprs:expr),*) ) => {\n+        loop {\n+            match $crate::box_region::BOX_REGION_ARG.with(|i| i.get()) {\n+                $crate::box_region::Action::Access(accessor) => {\n+                    let accessor: &mut dyn for<$($lifetimes)*> FnMut($($args),*) = unsafe {\n+                        ::std::mem::transmute(accessor.get())\n+                    };\n+                    (*accessor)(($($exprs),*));\n+                    unsafe {\n+                        let marker = $crate::box_region::Marker::<\n+                            for<$($lifetimes)*> fn(($($args,)*))\n+                        >::new();\n+                        yield $crate::box_region::YieldType::Accessor(marker)\n+                    };\n+                }\n+                $crate::box_region::Action::Complete => break,\n+            }\n+        }\n+    }\n+}"}, {"sha": "a1d7ab8856daa4606e023dcabb62b136737a3511", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -10,6 +10,8 @@\n \n #![feature(in_band_lifetimes)]\n #![feature(unboxed_closures)]\n+#![feature(generators)]\n+#![feature(generator_trait)]\n #![feature(fn_traits)]\n #![feature(unsize)]\n #![feature(specialization)]\n@@ -71,6 +73,7 @@ pub mod macros;\n pub mod svh;\n pub mod base_n;\n pub mod bit_set;\n+pub mod box_region;\n pub mod const_cstr;\n pub mod flock;\n pub mod fx;"}, {"sha": "d3e295607c2b395b40dd1f222a8286f705bde98b", "filename": "src/librustc_driver/driver.rs", "status": "removed", "additions": 0, "deletions": 1244, "changes": 1244, "blob_url": "https://github.com/rust-lang/rust/blob/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26b4cb48484382032522384318e70ceb0fbc4a41/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=26b4cb48484382032522384318e70ceb0fbc4a41", "patch": "@@ -1,1244 +0,0 @@\n-use rustc::dep_graph::DepGraph;\n-use rustc::hir;\n-use rustc::hir::lowering::lower_crate;\n-use rustc::hir::map as hir_map;\n-use rustc::hir::def_id::LOCAL_CRATE;\n-use rustc::lint;\n-use rustc::middle::{self, reachable, resolve_lifetime, stability};\n-use rustc::ty::{self, AllArenas, Resolutions, TyCtxt};\n-use rustc::traits;\n-use rustc::util::common::{install_panic_hook, time, ErrorReported};\n-use rustc::util::profiling::ProfileCategory;\n-use rustc::session::{CompileResult, Session};\n-use rustc::session::CompileIncomplete;\n-use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n-use rustc::session::search_paths::PathKind;\n-use rustc_allocator as allocator;\n-use rustc_borrowck as borrowck;\n-use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-use rustc_data_structures::sync::{self, Lock};\n-#[cfg(parallel_compiler)]\n-use rustc_data_structures::jobserver;\n-use rustc_incremental;\n-use rustc_metadata::creader::CrateLoader;\n-use rustc_metadata::cstore::{self, CStore};\n-use rustc_mir as mir;\n-use rustc_passes::{self, ast_validation, hir_stats};\n-use rustc_plugin as plugin;\n-use rustc_plugin::registry::Registry;\n-use rustc_privacy;\n-use rustc_resolve::{Resolver, ResolverArenas};\n-use rustc_traits;\n-use rustc_typeck as typeck;\n-use syntax::{self, ast, diagnostics, visit};\n-use syntax::early_buffered_lints::BufferedEarlyLint;\n-use syntax::ext::base::ExtCtxt;\n-use syntax::mut_visit::MutVisitor;\n-use syntax::parse::{self, PResult};\n-use syntax::util::node_count::NodeCounter;\n-use syntax_pos::hygiene;\n-use syntax_ext;\n-\n-use serialize::json;\n-\n-use std::any::Any;\n-use std::env;\n-use std::ffi::OsString;\n-use std::fs;\n-use std::iter;\n-use std::path::{Path, PathBuf};\n-use std::sync::mpsc;\n-\n-use rustc_interface::{util, profile, passes};\n-use super::Compilation;\n-\n-#[cfg(not(parallel_compiler))]\n-pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::Send>(\n-    opts: config::Options,\n-    f: F\n-) -> R {\n-    ty::tls::GCX_PTR.set(&Lock::new(0), || {\n-        f(opts)\n-    })\n-}\n-\n-#[cfg(parallel_compiler)]\n-pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::Send>(\n-    opts: config::Options,\n-    f: F\n-) -> R {\n-    use syntax;\n-    use syntax_pos;\n-    use rayon::{ThreadPoolBuilder, ThreadPool};\n-\n-    let gcx_ptr = &Lock::new(0);\n-\n-    let config = ThreadPoolBuilder::new()\n-        .acquire_thread_handler(jobserver::acquire_thread)\n-        .release_thread_handler(jobserver::release_thread)\n-        .num_threads(Session::threads_from_count(opts.debugging_opts.threads))\n-        .deadlock_handler(|| unsafe { ty::query::handle_deadlock() })\n-        .stack_size(::STACK_SIZE);\n-\n-    let with_pool = move |pool: &ThreadPool| {\n-        pool.install(move || f(opts))\n-    };\n-\n-    syntax::GLOBALS.with(|syntax_globals| {\n-        syntax_pos::GLOBALS.with(|syntax_pos_globals| {\n-            // The main handler run for each Rayon worker thread and sets up\n-            // the thread local rustc uses. syntax_globals and syntax_pos_globals are\n-            // captured and set on the new threads. ty::tls::with_thread_locals sets up\n-            // thread local callbacks from libsyntax\n-            let main_handler = move |worker: &mut dyn FnMut()| {\n-                syntax::GLOBALS.set(syntax_globals, || {\n-                    syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n-                        ty::tls::with_thread_locals(|| {\n-                            ty::tls::GCX_PTR.set(gcx_ptr, || {\n-                                worker()\n-                            })\n-                        })\n-                    })\n-                })\n-            };\n-\n-            ThreadPool::scoped_pool(config, main_handler, with_pool).unwrap()\n-        })\n-    })\n-}\n-\n-pub fn compile_input(\n-    codegen_backend: Box<dyn CodegenBackend>,\n-    sess: &Session,\n-    cstore: &CStore,\n-    input_path: &Option<PathBuf>,\n-    input: &Input,\n-    outdir: &Option<PathBuf>,\n-    output: &Option<PathBuf>,\n-    addl_plugins: Option<Vec<String>>,\n-    control: &CompileController,\n-) -> CompileResult {\n-    macro_rules! controller_entry_point {\n-        ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n-            let state = &mut $make_state;\n-            let phase_result: &CompileResult = &$phase_result;\n-            if phase_result.is_ok() || control.$point.run_callback_on_error {\n-                (control.$point.callback)(state);\n-            }\n-\n-            if control.$point.stop == Compilation::Stop {\n-                // FIXME: shouldn't this return Err(CompileIncomplete::Stopped)\n-                // if there are no errors?\n-                return $tsess.compile_status();\n-            }\n-        }}\n-    }\n-\n-    if sess.profile_queries() {\n-        profile::begin(sess);\n-    }\n-\n-    // We need nested scopes here, because the intermediate results can keep\n-    // large chunks of memory alive and we want to free them as soon as\n-    // possible to keep the peak memory usage low\n-    let (outputs, ongoing_codegen, dep_graph) = {\n-        let krate = match phase_1_parse_input(control, sess, input) {\n-            Ok(krate) => krate,\n-            Err(mut parse_error) => {\n-                parse_error.emit();\n-                return Err(CompileIncomplete::Errored(ErrorReported));\n-            }\n-        };\n-\n-        let (krate, registry) = {\n-            let mut compile_state =\n-                CompileState::state_after_parse(input, sess, outdir, output, krate, &cstore);\n-            controller_entry_point!(after_parse, sess, compile_state, Ok(()));\n-\n-            (compile_state.krate.unwrap(), compile_state.registry)\n-        };\n-\n-        let outputs = util::build_output_filenames(input, outdir, output, &krate.attrs, sess);\n-        let crate_name =\n-            ::rustc_codegen_utils::link::find_crate_name(Some(sess), &krate.attrs, input);\n-        install_panic_hook();\n-\n-        let ExpansionResult {\n-            expanded_crate,\n-            defs,\n-            resolutions,\n-            mut hir_forest,\n-        } = {\n-            phase_2_configure_and_expand(\n-                sess,\n-                &cstore,\n-                krate,\n-                registry,\n-                &crate_name,\n-                addl_plugins,\n-                |expanded_crate| {\n-                    let mut state = CompileState::state_after_expand(\n-                        input,\n-                        sess,\n-                        outdir,\n-                        output,\n-                        &cstore,\n-                        expanded_crate,\n-                        &crate_name,\n-                    );\n-                    controller_entry_point!(after_expand, sess, state, Ok(()));\n-                    Ok(())\n-                },\n-            )?\n-        };\n-\n-        let output_paths = passes::generated_output_paths(\n-            sess,\n-            &outputs,\n-            output.is_some(),\n-            &crate_name\n-        );\n-\n-        // Ensure the source file isn't accidentally overwritten during compilation.\n-        if let Some(ref input_path) = *input_path {\n-            if sess.opts.will_create_output_file() {\n-                if passes::output_contains_path(&output_paths, input_path) {\n-                    sess.err(&format!(\n-                        \"the input file \\\"{}\\\" would be overwritten by the generated \\\n-                         executable\",\n-                        input_path.display()\n-                    ));\n-                    return Err(CompileIncomplete::Stopped);\n-                }\n-                if let Some(dir_path) = passes::output_conflicts_with_dir(&output_paths) {\n-                    sess.err(&format!(\n-                        \"the generated executable for the input file \\\"{}\\\" conflicts with the \\\n-                         existing directory \\\"{}\\\"\",\n-                        input_path.display(),\n-                        dir_path.display()\n-                    ));\n-                    return Err(CompileIncomplete::Stopped);\n-                }\n-            }\n-        }\n-\n-        passes::write_out_deps(sess, &outputs, &output_paths);\n-        if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n-            && sess.opts.output_types.len() == 1\n-        {\n-            return Ok(());\n-        }\n-\n-        if let &Some(ref dir) = outdir {\n-            if fs::create_dir_all(dir).is_err() {\n-                sess.err(\"failed to find or create the directory specified by --out-dir\");\n-                return Err(CompileIncomplete::Stopped);\n-            }\n-        }\n-\n-        // Construct the HIR map\n-        let hir_map = time(sess, \"indexing hir\", || {\n-            hir_map::map_crate(sess, cstore, &mut hir_forest, &defs)\n-        });\n-\n-        {\n-            hir_map.dep_graph.assert_ignored();\n-            controller_entry_point!(\n-                after_hir_lowering,\n-                sess,\n-                CompileState::state_after_hir_lowering(\n-                    input,\n-                    sess,\n-                    outdir,\n-                    output,\n-                    &cstore,\n-                    &hir_map,\n-                    &resolutions,\n-                    &expanded_crate,\n-                    &hir_map.krate(),\n-                    &outputs,\n-                    &crate_name\n-                ),\n-                Ok(())\n-            );\n-        }\n-\n-        let opt_crate = if control.keep_ast {\n-            Some(&expanded_crate)\n-        } else {\n-            drop(expanded_crate);\n-            None\n-        };\n-\n-        let mut arenas = AllArenas::new();\n-\n-        phase_3_run_analysis_passes(\n-            &*codegen_backend,\n-            control,\n-            sess,\n-            cstore,\n-            hir_map,\n-            resolutions,\n-            &mut arenas,\n-            &crate_name,\n-            &outputs,\n-            |tcx, rx, result| {\n-                {\n-                    // Eventually, we will want to track plugins.\n-                    tcx.dep_graph.with_ignore(|| {\n-                        let mut state = CompileState::state_after_analysis(\n-                            input,\n-                            sess,\n-                            outdir,\n-                            output,\n-                            opt_crate,\n-                            tcx.hir().krate(),\n-                            tcx,\n-                            &crate_name,\n-                        );\n-                        (control.after_analysis.callback)(&mut state);\n-                    });\n-\n-                    // Plugins like clippy and rust-semverver stop the analysis early,\n-                    // but want to still return an error if errors during the analysis\n-                    // happened:\n-                    tcx.sess.compile_status()?;\n-\n-                    if control.after_analysis.stop == Compilation::Stop {\n-                        return result.and_then(|_| Err(CompileIncomplete::Stopped));\n-                    }\n-                }\n-\n-                result?;\n-\n-                if log_enabled!(::log::Level::Info) {\n-                    println!(\"Pre-codegen\");\n-                    tcx.print_debug_stats();\n-                }\n-\n-                let ongoing_codegen = phase_4_codegen(&*codegen_backend, tcx, rx);\n-\n-                if log_enabled!(::log::Level::Info) {\n-                    println!(\"Post-codegen\");\n-                    tcx.print_debug_stats();\n-                }\n-\n-                if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n-                    if let Err(e) = mir::transform::dump_mir::emit_mir(tcx, &outputs) {\n-                        sess.err(&format!(\"could not emit MIR: {}\", e));\n-                        sess.abort_if_errors();\n-                    }\n-                }\n-\n-                if tcx.sess.opts.debugging_opts.query_stats {\n-                    tcx.queries.print_stats();\n-                }\n-\n-                Ok((outputs.clone(), ongoing_codegen, tcx.dep_graph.clone()))\n-            },\n-        )?\n-    };\n-\n-    if sess.opts.debugging_opts.print_type_sizes {\n-        sess.code_stats.borrow().print_type_sizes();\n-    }\n-\n-    codegen_backend.join_codegen_and_link(ongoing_codegen, sess, &dep_graph, &outputs)?;\n-\n-    if sess.opts.debugging_opts.perf_stats {\n-        sess.print_perf_stats();\n-    }\n-\n-    controller_entry_point!(\n-        compilation_done,\n-        sess,\n-        CompileState::state_when_compilation_done(input, sess, outdir, output),\n-        Ok(())\n-    );\n-\n-    Ok(())\n-}\n-\n-/// CompileController is used to customize compilation, it allows compilation to\n-/// be stopped and/or to call arbitrary code at various points in compilation.\n-/// It also allows for various flags to be set to influence what information gets\n-/// collected during compilation.\n-///\n-/// This is a somewhat higher level controller than a Session - the Session\n-/// controls what happens in each phase, whereas the CompileController controls\n-/// whether a phase is run at all and whether other code (from outside the\n-/// compiler) is run between phases.\n-///\n-/// Note that if compilation is set to stop and a callback is provided for a\n-/// given entry point, the callback is called before compilation is stopped.\n-///\n-/// Expect more entry points to be added in the future.\n-pub struct CompileController<'a> {\n-    pub after_parse: PhaseController<'a>,\n-    pub after_expand: PhaseController<'a>,\n-    pub after_hir_lowering: PhaseController<'a>,\n-    pub after_analysis: PhaseController<'a>,\n-    pub compilation_done: PhaseController<'a>,\n-\n-    // FIXME we probably want to group the below options together and offer a\n-    // better API, rather than this ad-hoc approach.\n-    // Whether the compiler should keep the ast beyond parsing.\n-    pub keep_ast: bool,\n-    // -Zcontinue-parse-after-error\n-    pub continue_parse_after_error: bool,\n-\n-    /// Allows overriding default rustc query providers,\n-    /// after `default_provide` has installed them.\n-    pub provide: Box<dyn Fn(&mut ty::query::Providers) + 'a + sync::Send>,\n-    /// Same as `provide`, but only for non-local crates,\n-    /// applied after `default_provide_extern`.\n-    pub provide_extern: Box<dyn Fn(&mut ty::query::Providers) + 'a + sync::Send>,\n-}\n-\n-impl<'a> CompileController<'a> {\n-    pub fn basic() -> CompileController<'a> {\n-        sync::assert_send::<Self>();\n-        CompileController {\n-            after_parse: PhaseController::basic(),\n-            after_expand: PhaseController::basic(),\n-            after_hir_lowering: PhaseController::basic(),\n-            after_analysis: PhaseController::basic(),\n-            compilation_done: PhaseController::basic(),\n-            keep_ast: false,\n-            continue_parse_after_error: false,\n-            provide: box |_| {},\n-            provide_extern: box |_| {},\n-        }\n-    }\n-}\n-\n-/// This implementation makes it easier to create a custom driver when you only want to hook\n-/// into callbacks from `CompileController`.\n-///\n-/// # Example\n-///\n-/// ```no_run\n-/// # extern crate rustc_driver;\n-/// # use rustc_driver::driver::CompileController;\n-/// let mut controller = CompileController::basic();\n-/// controller.after_analysis.callback = Box::new(move |_state| {});\n-/// rustc_driver::run_compiler(&[], Box::new(controller), None, None);\n-/// ```\n-impl<'a> ::CompilerCalls<'a> for CompileController<'a> {\n-    fn early_callback(\n-        &mut self,\n-        matches: &::getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        descriptions: &::errors::registry::Registry,\n-        output: ::ErrorOutputType,\n-    ) -> Compilation {\n-        ::RustcDefaultCalls.early_callback(\n-            matches,\n-            sopts,\n-            cfg,\n-            descriptions,\n-            output,\n-        )\n-    }\n-    fn no_input(\n-        &mut self,\n-        matches: &::getopts::Matches,\n-        sopts: &config::Options,\n-        cfg: &ast::CrateConfig,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        descriptions: &::errors::registry::Registry,\n-    ) -> Option<(Input, Option<PathBuf>)> {\n-        ::RustcDefaultCalls.no_input(\n-            matches,\n-            sopts,\n-            cfg,\n-            odir,\n-            ofile,\n-            descriptions,\n-        )\n-    }\n-    fn late_callback(\n-        &mut self,\n-        codegen_backend: &dyn (::CodegenBackend),\n-        matches: &::getopts::Matches,\n-        sess: &Session,\n-        cstore: &CStore,\n-        input: &Input,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-    ) -> Compilation {\n-        ::RustcDefaultCalls\n-            .late_callback(codegen_backend, matches, sess, cstore, input, odir, ofile)\n-    }\n-    fn build_controller(\n-        self: Box<Self>,\n-        _: &Session,\n-        _: &::getopts::Matches\n-    ) -> CompileController<'a> {\n-        *self\n-    }\n-}\n-\n-pub struct PhaseController<'a> {\n-    pub stop: Compilation,\n-    // If true then the compiler will try to run the callback even if the phase\n-    // ends with an error. Note that this is not always possible.\n-    pub run_callback_on_error: bool,\n-    pub callback: Box<dyn Fn(&mut CompileState) + 'a + sync::Send>,\n-}\n-\n-impl<'a> PhaseController<'a> {\n-    pub fn basic() -> PhaseController<'a> {\n-        PhaseController {\n-            stop: Compilation::Continue,\n-            run_callback_on_error: false,\n-            callback: box |_| {},\n-        }\n-    }\n-}\n-\n-/// State that is passed to a callback. What state is available depends on when\n-/// during compilation the callback is made. See the various constructor methods\n-/// (`state_*`) in the impl to see which data is provided for any given entry point.\n-pub struct CompileState<'a, 'tcx: 'a> {\n-    pub input: &'a Input,\n-    pub session: &'tcx Session,\n-    pub krate: Option<ast::Crate>,\n-    pub registry: Option<Registry<'a>>,\n-    pub cstore: Option<&'tcx CStore>,\n-    pub crate_name: Option<&'a str>,\n-    pub output_filenames: Option<&'a OutputFilenames>,\n-    pub out_dir: Option<&'a Path>,\n-    pub out_file: Option<&'a Path>,\n-    pub expanded_crate: Option<&'a ast::Crate>,\n-    pub hir_crate: Option<&'a hir::Crate>,\n-    pub hir_map: Option<&'a hir_map::Map<'tcx>>,\n-    pub resolutions: Option<&'a Resolutions>,\n-    pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n-}\n-\n-impl<'a, 'tcx> CompileState<'a, 'tcx> {\n-    fn empty(input: &'a Input, session: &'tcx Session, out_dir: &'a Option<PathBuf>) -> Self {\n-        CompileState {\n-            input,\n-            session,\n-            out_dir: out_dir.as_ref().map(|s| &**s),\n-            out_file: None,\n-            krate: None,\n-            registry: None,\n-            cstore: None,\n-            crate_name: None,\n-            output_filenames: None,\n-            expanded_crate: None,\n-            hir_crate: None,\n-            hir_map: None,\n-            resolutions: None,\n-            tcx: None,\n-        }\n-    }\n-\n-    fn state_after_parse(\n-        input: &'a Input,\n-        session: &'tcx Session,\n-        out_dir: &'a Option<PathBuf>,\n-        out_file: &'a Option<PathBuf>,\n-        krate: ast::Crate,\n-        cstore: &'tcx CStore,\n-    ) -> Self {\n-        CompileState {\n-            // Initialize the registry before moving `krate`\n-            registry: Some(Registry::new(&session, krate.span)),\n-            krate: Some(krate),\n-            cstore: Some(cstore),\n-            out_file: out_file.as_ref().map(|s| &**s),\n-            ..CompileState::empty(input, session, out_dir)\n-        }\n-    }\n-\n-    fn state_after_expand(\n-        input: &'a Input,\n-        session: &'tcx Session,\n-        out_dir: &'a Option<PathBuf>,\n-        out_file: &'a Option<PathBuf>,\n-        cstore: &'tcx CStore,\n-        expanded_crate: &'a ast::Crate,\n-        crate_name: &'a str,\n-    ) -> Self {\n-        CompileState {\n-            crate_name: Some(crate_name),\n-            cstore: Some(cstore),\n-            expanded_crate: Some(expanded_crate),\n-            out_file: out_file.as_ref().map(|s| &**s),\n-            ..CompileState::empty(input, session, out_dir)\n-        }\n-    }\n-\n-    fn state_after_hir_lowering(\n-        input: &'a Input,\n-        session: &'tcx Session,\n-        out_dir: &'a Option<PathBuf>,\n-        out_file: &'a Option<PathBuf>,\n-        cstore: &'tcx CStore,\n-        hir_map: &'a hir_map::Map<'tcx>,\n-        resolutions: &'a Resolutions,\n-        krate: &'a ast::Crate,\n-        hir_crate: &'a hir::Crate,\n-        output_filenames: &'a OutputFilenames,\n-        crate_name: &'a str,\n-    ) -> Self {\n-        CompileState {\n-            crate_name: Some(crate_name),\n-            cstore: Some(cstore),\n-            hir_map: Some(hir_map),\n-            resolutions: Some(resolutions),\n-            expanded_crate: Some(krate),\n-            hir_crate: Some(hir_crate),\n-            output_filenames: Some(output_filenames),\n-            out_file: out_file.as_ref().map(|s| &**s),\n-            ..CompileState::empty(input, session, out_dir)\n-        }\n-    }\n-\n-    fn state_after_analysis(\n-        input: &'a Input,\n-        session: &'tcx Session,\n-        out_dir: &'a Option<PathBuf>,\n-        out_file: &'a Option<PathBuf>,\n-        krate: Option<&'a ast::Crate>,\n-        hir_crate: &'a hir::Crate,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        crate_name: &'a str,\n-    ) -> Self {\n-        CompileState {\n-            tcx: Some(tcx),\n-            expanded_crate: krate,\n-            hir_crate: Some(hir_crate),\n-            crate_name: Some(crate_name),\n-            out_file: out_file.as_ref().map(|s| &**s),\n-            ..CompileState::empty(input, session, out_dir)\n-        }\n-    }\n-\n-    fn state_when_compilation_done(\n-        input: &'a Input,\n-        session: &'tcx Session,\n-        out_dir: &'a Option<PathBuf>,\n-        out_file: &'a Option<PathBuf>,\n-    ) -> Self {\n-        CompileState {\n-            out_file: out_file.as_ref().map(|s| &**s),\n-            ..CompileState::empty(input, session, out_dir)\n-        }\n-    }\n-}\n-\n-pub fn phase_1_parse_input<'a>(\n-    control: &CompileController,\n-    sess: &'a Session,\n-    input: &Input,\n-) -> PResult<'a, ast::Crate> {\n-    sess.diagnostic()\n-        .set_continue_after_error(control.continue_parse_after_error);\n-    hygiene::set_default_edition(sess.edition());\n-\n-    if sess.profile_queries() {\n-        profile::begin(sess);\n-    }\n-\n-    sess.profiler(|p| p.start_activity(ProfileCategory::Parsing));\n-    let krate = time(sess, \"parsing\", || match *input {\n-        Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n-        Input::Str {\n-            ref input,\n-            ref name,\n-        } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n-    })?;\n-    sess.profiler(|p| p.end_activity(ProfileCategory::Parsing));\n-\n-    sess.diagnostic().set_continue_after_error(true);\n-\n-    if sess.opts.debugging_opts.ast_json_noexpand {\n-        println!(\"{}\", json::as_json(&krate));\n-    }\n-\n-    if sess.opts.debugging_opts.input_stats {\n-        println!(\n-            \"Lines of code:             {}\",\n-            sess.source_map().count_lines()\n-        );\n-        println!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n-    }\n-\n-    if let Some(ref s) = sess.opts.debugging_opts.show_span {\n-        syntax::show_span::run(sess.diagnostic(), s, &krate);\n-    }\n-\n-    if sess.opts.debugging_opts.hir_stats {\n-        hir_stats::print_ast_stats(&krate, \"PRE EXPANSION AST STATS\");\n-    }\n-\n-    Ok(krate)\n-}\n-\n-fn count_nodes(krate: &ast::Crate) -> usize {\n-    let mut counter = NodeCounter::new();\n-    visit::walk_crate(&mut counter, krate);\n-    counter.count\n-}\n-\n-// For continuing compilation after a parsed crate has been\n-// modified\n-\n-pub struct ExpansionResult {\n-    pub expanded_crate: ast::Crate,\n-    pub defs: hir_map::Definitions,\n-    pub resolutions: Resolutions,\n-    pub hir_forest: hir_map::Forest,\n-}\n-\n-pub struct InnerExpansionResult<'a> {\n-    pub expanded_crate: ast::Crate,\n-    pub resolver: Resolver<'a>,\n-    pub hir_forest: hir_map::Forest,\n-}\n-\n-/// Runs the \"early phases\" of the compiler: initial `cfg` processing,\n-/// loading compiler plugins (including those from `addl_plugins`),\n-/// syntax expansion, secondary `cfg` expansion, synthesis of a test\n-/// harness if one is to be provided, injection of a dependency on the\n-/// standard library and prelude, and name resolution.\n-///\n-/// Returns `None` if we're aborting after handling -W help.\n-pub fn phase_2_configure_and_expand<F>(\n-    sess: &Session,\n-    cstore: &CStore,\n-    krate: ast::Crate,\n-    registry: Option<Registry>,\n-    crate_name: &str,\n-    addl_plugins: Option<Vec<String>>,\n-    after_expand: F,\n-) -> Result<ExpansionResult, CompileIncomplete>\n-where\n-    F: FnOnce(&ast::Crate) -> CompileResult,\n-{\n-    // Currently, we ignore the name resolution data structures for the purposes of dependency\n-    // tracking. Instead we will run name resolution and include its output in the hash of each\n-    // item, much like we do for macro expansion. In other words, the hash reflects not just\n-    // its contents but the results of name resolution on those contents. Hopefully we'll push\n-    // this back at some point.\n-    let mut crate_loader = CrateLoader::new(sess, &cstore, &crate_name);\n-    let resolver_arenas = Resolver::arenas();\n-    let result = phase_2_configure_and_expand_inner(\n-        sess,\n-        cstore,\n-        krate,\n-        registry,\n-        crate_name,\n-        addl_plugins,\n-        &resolver_arenas,\n-        &mut crate_loader,\n-        after_expand,\n-    );\n-    match result {\n-        Ok(InnerExpansionResult {\n-            expanded_crate,\n-            resolver,\n-            hir_forest,\n-        }) => Ok(ExpansionResult {\n-            expanded_crate,\n-            defs: resolver.definitions,\n-            hir_forest,\n-            resolutions: Resolutions {\n-                freevars: resolver.freevars,\n-                export_map: resolver.export_map,\n-                trait_map: resolver.trait_map,\n-                glob_map: resolver.glob_map,\n-                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n-                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n-                extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n-                    (ident.name, entry.introduced_by_item)\n-                }).collect(),\n-            },\n-        }),\n-        Err(x) => Err(x),\n-    }\n-}\n-\n-/// Same as phase_2_configure_and_expand, but doesn't let you keep the resolver\n-/// around\n-pub fn phase_2_configure_and_expand_inner<'a, F>(\n-    sess: &'a Session,\n-    cstore: &'a CStore,\n-    mut krate: ast::Crate,\n-    registry: Option<Registry>,\n-    crate_name: &str,\n-    addl_plugins: Option<Vec<String>>,\n-    resolver_arenas: &'a ResolverArenas<'a>,\n-    crate_loader: &'a mut CrateLoader<'a>,\n-    after_expand: F,\n-) -> Result<InnerExpansionResult<'a>, CompileIncomplete>\n-where\n-    F: FnOnce(&ast::Crate) -> CompileResult,\n-{\n-    krate = time(sess, \"attributes injection\", || {\n-        syntax::attr::inject(krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr)\n-    });\n-\n-    let (mut krate, features) = syntax::config::features(\n-        krate,\n-        &sess.parse_sess,\n-        sess.edition(),\n-    );\n-    // these need to be set \"early\" so that expansion sees `quote` if enabled.\n-    sess.init_features(features);\n-\n-    let crate_types = util::collect_crate_types(sess, &krate.attrs);\n-    sess.crate_types.set(crate_types);\n-\n-    let disambiguator = util::compute_crate_disambiguator(sess);\n-    sess.crate_disambiguator.set(disambiguator);\n-    rustc_incremental::prepare_session_directory(sess, &crate_name, disambiguator);\n-\n-    if sess.opts.incremental.is_some() {\n-        time(sess, \"garbage collect incremental cache directory\", || {\n-            if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n-                warn!(\n-                    \"Error while trying to garbage collect incremental \\\n-                     compilation cache directory: {}\",\n-                    e\n-                );\n-            }\n-        });\n-    }\n-\n-    // If necessary, compute the dependency graph (in the background).\n-    let future_dep_graph = if sess.opts.build_dep_graph() {\n-        Some(rustc_incremental::load_dep_graph(sess))\n-    } else {\n-        None\n-    };\n-\n-    time(sess, \"recursion limit\", || {\n-        middle::recursion_limit::update_limits(sess, &krate);\n-    });\n-\n-    krate = time(sess, \"crate injection\", || {\n-        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n-        syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name, sess.edition())\n-    });\n-\n-    let mut addl_plugins = Some(addl_plugins);\n-    let registrars = time(sess, \"plugin loading\", || {\n-        plugin::load::load_plugins(\n-            sess,\n-            &cstore,\n-            &krate,\n-            crate_name,\n-            addl_plugins.take().unwrap(),\n-        )\n-    });\n-\n-    let mut registry = registry.unwrap_or_else(|| Registry::new(sess, krate.span));\n-\n-    time(sess, \"plugin registration\", || {\n-        if sess.features_untracked().rustc_diagnostic_macros {\n-            registry.register_macro(\n-                \"__diagnostic_used\",\n-                diagnostics::plugin::expand_diagnostic_used,\n-            );\n-            registry.register_macro(\n-                \"__register_diagnostic\",\n-                diagnostics::plugin::expand_register_diagnostic,\n-            );\n-            registry.register_macro(\n-                \"__build_diagnostic_array\",\n-                diagnostics::plugin::expand_build_diagnostic_array,\n-            );\n-        }\n-\n-        for registrar in registrars {\n-            registry.args_hidden = Some(registrar.args);\n-            (registrar.fun)(&mut registry);\n-        }\n-    });\n-\n-    let Registry {\n-        syntax_exts,\n-        early_lint_passes,\n-        late_lint_passes,\n-        lint_groups,\n-        llvm_passes,\n-        attributes,\n-        ..\n-    } = registry;\n-\n-    sess.track_errors(|| {\n-        let mut ls = sess.lint_store.borrow_mut();\n-        for pass in early_lint_passes {\n-            ls.register_early_pass(Some(sess), true, false, pass);\n-        }\n-        for pass in late_lint_passes {\n-            ls.register_late_pass(Some(sess), true, pass);\n-        }\n-\n-        for (name, (to, deprecated_name)) in lint_groups {\n-            ls.register_group(Some(sess), true, name, deprecated_name, to);\n-        }\n-\n-        *sess.plugin_llvm_passes.borrow_mut() = llvm_passes;\n-        *sess.plugin_attributes.borrow_mut() = attributes.clone();\n-    })?;\n-\n-    // Lint plugins are registered; now we can process command line flags.\n-    if sess.opts.describe_lints {\n-        super::describe_lints(&sess, &sess.lint_store.borrow(), true);\n-        return Err(CompileIncomplete::Stopped);\n-    }\n-\n-    time(sess, \"pre ast expansion lint checks\", || {\n-        lint::check_ast_crate(\n-            sess,\n-            &krate,\n-            true,\n-            rustc_lint::BuiltinCombinedPreExpansionLintPass::new());\n-    });\n-\n-    let mut resolver = Resolver::new(\n-        sess,\n-        cstore,\n-        &krate,\n-        crate_name,\n-        crate_loader,\n-        &resolver_arenas,\n-    );\n-    syntax_ext::register_builtins(&mut resolver, syntax_exts);\n-\n-    // Expand all macros\n-    sess.profiler(|p| p.start_activity(ProfileCategory::Expansion));\n-    krate = time(sess, \"expansion\", || {\n-        // Windows dlls do not have rpaths, so they don't know how to find their\n-        // dependencies. It's up to us to tell the system where to find all the\n-        // dependent dlls. Note that this uses cfg!(windows) as opposed to\n-        // targ_cfg because syntax extensions are always loaded for the host\n-        // compiler, not for the target.\n-        //\n-        // This is somewhat of an inherently racy operation, however, as\n-        // multiple threads calling this function could possibly continue\n-        // extending PATH far beyond what it should. To solve this for now we\n-        // just don't add any new elements to PATH which are already there\n-        // within PATH. This is basically a targeted fix at #17360 for rustdoc\n-        // which runs rustc in parallel but has been seen (#33844) to cause\n-        // problems with PATH becoming too long.\n-        let mut old_path = OsString::new();\n-        if cfg!(windows) {\n-            old_path = env::var_os(\"PATH\").unwrap_or(old_path);\n-            let mut new_path = sess.host_filesearch(PathKind::All).search_path_dirs();\n-            for path in env::split_paths(&old_path) {\n-                if !new_path.contains(&path) {\n-                    new_path.push(path);\n-                }\n-            }\n-            env::set_var(\n-                \"PATH\",\n-                &env::join_paths(\n-                    new_path\n-                        .iter()\n-                        .filter(|p| env::join_paths(iter::once(p)).is_ok()),\n-                ).unwrap(),\n-            );\n-        }\n-\n-        // Create the config for macro expansion\n-        let features = sess.features_untracked();\n-        let cfg = syntax::ext::expand::ExpansionConfig {\n-            features: Some(&features),\n-            recursion_limit: *sess.recursion_limit.get(),\n-            trace_mac: sess.opts.debugging_opts.trace_macros,\n-            should_test: sess.opts.test,\n-            ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n-        };\n-\n-        let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n-\n-        // Expand macros now!\n-        let krate = time(sess, \"expand crate\", || {\n-            ecx.monotonic_expander().expand_crate(krate)\n-        });\n-\n-        // The rest is error reporting\n-\n-        time(sess, \"check unused macros\", || {\n-            ecx.check_unused_macros();\n-        });\n-\n-        let mut missing_fragment_specifiers: Vec<_> = ecx.parse_sess\n-            .missing_fragment_specifiers\n-            .borrow()\n-            .iter()\n-            .cloned()\n-            .collect();\n-        missing_fragment_specifiers.sort();\n-\n-        for span in missing_fragment_specifiers {\n-            let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n-            let msg = \"missing fragment specifier\";\n-            sess.buffer_lint(lint, ast::CRATE_NODE_ID, span, msg);\n-        }\n-        if cfg!(windows) {\n-            env::set_var(\"PATH\", &old_path);\n-        }\n-        krate\n-    });\n-    sess.profiler(|p| p.end_activity(ProfileCategory::Expansion));\n-\n-    time(sess, \"maybe building test harness\", || {\n-        syntax::test::modify_for_testing(\n-            &sess.parse_sess,\n-            &mut resolver,\n-            sess.opts.test,\n-            &mut krate,\n-            sess.diagnostic(),\n-            &sess.features_untracked(),\n-        )\n-    });\n-\n-    // If we're actually rustdoc then there's no need to actually compile\n-    // anything, so switch everything to just looping\n-    if sess.opts.actually_rustdoc {\n-        util::ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n-    }\n-\n-    let (has_proc_macro_decls, has_global_allocator) = time(sess, \"AST validation\", || {\n-        ast_validation::check_crate(sess, &krate)\n-    });\n-\n-    // If we're in rustdoc we're always compiling as an rlib, but that'll trip a\n-    // bunch of checks in the `modify` function below. For now just skip this\n-    // step entirely if we're rustdoc as it's not too useful anyway.\n-    if !sess.opts.actually_rustdoc {\n-        krate = time(sess, \"maybe creating a macro crate\", || {\n-            let crate_types = sess.crate_types.borrow();\n-            let num_crate_types = crate_types.len();\n-            let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n-            let is_test_crate = sess.opts.test;\n-            syntax_ext::proc_macro_decls::modify(\n-                &sess.parse_sess,\n-                &mut resolver,\n-                krate,\n-                is_proc_macro_crate,\n-                has_proc_macro_decls,\n-                is_test_crate,\n-                num_crate_types,\n-                sess.diagnostic(),\n-            )\n-        });\n-    }\n-\n-    if has_global_allocator {\n-        // Expand global allocators, which are treated as an in-tree proc macro\n-        time(sess, \"creating allocators\", || {\n-            allocator::expand::modify(\n-                &sess.parse_sess,\n-                &mut resolver,\n-                &mut krate,\n-                crate_name.to_string(),\n-                sess.diagnostic(),\n-            )\n-        });\n-    }\n-\n-    // Done with macro expansion!\n-\n-    after_expand(&krate)?;\n-\n-    if sess.opts.debugging_opts.input_stats {\n-        println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n-    }\n-\n-    if sess.opts.debugging_opts.hir_stats {\n-        hir_stats::print_ast_stats(&krate, \"POST EXPANSION AST STATS\");\n-    }\n-\n-    if sess.opts.debugging_opts.ast_json {\n-        println!(\"{}\", json::as_json(&krate));\n-    }\n-\n-    time(sess, \"name resolution\", || {\n-        resolver.resolve_crate(&krate);\n-    });\n-\n-    // Needs to go *after* expansion to be able to check the results of macro expansion.\n-    time(sess, \"complete gated feature checking\", || {\n-        syntax::feature_gate::check_crate(\n-            &krate,\n-            &sess.parse_sess,\n-            &sess.features_untracked(),\n-            &attributes,\n-            sess.opts.unstable_features,\n-        );\n-    });\n-\n-    // Add all buffered lints from the `ParseSess` to the `Session`.\n-    sess.parse_sess.buffered_lints.with_lock(|buffered_lints| {\n-        info!(\"{} parse sess buffered_lints\", buffered_lints.len());\n-        for BufferedEarlyLint{id, span, msg, lint_id} in buffered_lints.drain(..) {\n-            let lint = lint::Lint::from_parser_lint_id(lint_id);\n-            sess.buffer_lint(lint, id, span, &msg);\n-        }\n-    });\n-\n-    // Lower ast -> hir.\n-    // First, we need to collect the dep_graph.\n-    let dep_graph = match future_dep_graph {\n-        None => DepGraph::new_disabled(),\n-        Some(future) => {\n-            let (prev_graph, prev_work_products) =\n-                time(sess, \"blocked while dep-graph loading finishes\", || {\n-                    future\n-                        .open()\n-                        .unwrap_or_else(|e| rustc_incremental::LoadResult::Error {\n-                            message: format!(\"could not decode incremental cache: {:?}\", e),\n-                        })\n-                        .open(sess)\n-                });\n-            DepGraph::new(prev_graph, prev_work_products)\n-        }\n-    };\n-    let hir_forest = time(sess, \"lowering ast -> hir\", || {\n-        let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, &mut resolver);\n-\n-        if sess.opts.debugging_opts.hir_stats {\n-            hir_stats::print_hir_stats(&hir_crate);\n-        }\n-\n-        hir_map::Forest::new(hir_crate, &dep_graph)\n-    });\n-\n-    time(sess, \"early lint checks\", || {\n-        lint::check_ast_crate(sess, &krate, false, rustc_lint::BuiltinCombinedEarlyLintPass::new())\n-    });\n-\n-    // Discard hygiene data, which isn't required after lowering to HIR.\n-    if !sess.opts.debugging_opts.keep_hygiene_data {\n-        syntax::ext::hygiene::clear_markings();\n-    }\n-\n-    Ok(InnerExpansionResult {\n-        expanded_crate: krate,\n-        resolver,\n-        hir_forest,\n-    })\n-}\n-\n-pub fn default_provide(providers: &mut ty::query::Providers) {\n-    rustc_interface::passes::provide(providers);\n-    plugin::build::provide(providers);\n-    hir::provide(providers);\n-    borrowck::provide(providers);\n-    mir::provide(providers);\n-    reachable::provide(providers);\n-    resolve_lifetime::provide(providers);\n-    rustc_privacy::provide(providers);\n-    typeck::provide(providers);\n-    ty::provide(providers);\n-    traits::provide(providers);\n-    stability::provide(providers);\n-    middle::intrinsicck::provide(providers);\n-    middle::liveness::provide(providers);\n-    reachable::provide(providers);\n-    rustc_passes::provide(providers);\n-    rustc_traits::provide(providers);\n-    middle::region::provide(providers);\n-    middle::entry::provide(providers);\n-    cstore::provide(providers);\n-    lint::provide(providers);\n-}\n-\n-pub fn default_provide_extern(providers: &mut ty::query::Providers) {\n-    cstore::provide_extern(providers);\n-}\n-\n-/// Runs the resolution, type-checking, region checking and other\n-/// miscellaneous analysis passes on the crate. Return various\n-/// structures carrying the results of the analysis.\n-pub fn phase_3_run_analysis_passes<'tcx, F, R>(\n-    codegen_backend: &dyn CodegenBackend,\n-    control: &CompileController,\n-    sess: &'tcx Session,\n-    cstore: &'tcx CStore,\n-    hir_map: hir_map::Map<'tcx>,\n-    resolutions: Resolutions,\n-    arenas: &'tcx mut AllArenas<'tcx>,\n-    name: &str,\n-    output_filenames: &OutputFilenames,\n-    f: F,\n-) -> R\n-where\n-    F: for<'a> FnOnce(\n-        TyCtxt<'a, 'tcx, 'tcx>,\n-        mpsc::Receiver<Box<dyn Any + Send>>,\n-        CompileResult,\n-    ) -> R,\n-{\n-    let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n-        rustc_incremental::load_query_result_cache(sess)\n-    });\n-\n-    let mut local_providers = ty::query::Providers::default();\n-    default_provide(&mut local_providers);\n-    codegen_backend.provide(&mut local_providers);\n-    (control.provide)(&mut local_providers);\n-\n-    let mut extern_providers = local_providers;\n-    default_provide_extern(&mut extern_providers);\n-    codegen_backend.provide_extern(&mut extern_providers);\n-    (control.provide_extern)(&mut extern_providers);\n-\n-    let (tx, rx) = mpsc::channel();\n-\n-    TyCtxt::create_and_enter(\n-        sess,\n-        cstore,\n-        local_providers,\n-        extern_providers,\n-        arenas,\n-        resolutions,\n-        hir_map,\n-        query_result_on_disk_cache,\n-        name,\n-        tx,\n-        output_filenames,\n-        |tcx| {\n-            // Do some initialization of the DepGraph that can only be done with the\n-            // tcx available.\n-            time(sess, \"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n-\n-            tcx.analysis(LOCAL_CRATE).ok();\n-\n-            f(tcx, rx, tcx.sess.compile_status())\n-        },\n-    )\n-}\n-\n-/// Runs the codegen backend, after which the AST and analysis can\n-/// be discarded.\n-pub fn phase_4_codegen<'a, 'tcx>(\n-    codegen_backend: &dyn CodegenBackend,\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    rx: mpsc::Receiver<Box<dyn Any + Send>>,\n-) -> Box<dyn Any> {\n-    time(tcx.sess, \"resolving dependency formats\", || {\n-        ::rustc::middle::dependency_format::calculate(tcx)\n-    });\n-\n-    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n-    let codegen = time(tcx.sess, \"codegen\", move || codegen_backend.codegen_crate(tcx, rx));\n-    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n-    if tcx.sess.profile_queries() {\n-        profile::dump(&tcx.sess, \"profile_queries\".to_string())\n-    }\n-\n-    codegen\n-}"}, {"sha": "2b75a607f1681db360d8734cef1644d95ebc4c49", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 265, "deletions": 464, "changes": 729, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -51,60 +51,56 @@ extern crate syntax;\n extern crate syntax_ext;\n extern crate syntax_pos;\n \n-use driver::CompileController;\n use pretty::{PpMode, UserIdentifiedItem};\n \n+//use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-use rustc_data_structures::sync::{self, Lrc, Ordering::SeqCst};\n-use rustc_data_structures::OnDrop;\n-use rustc::session::{self, config, Session, build_session, CompileResult, DiagnosticOutput};\n-use rustc::session::CompileIncomplete;\n-use rustc::session::config::{Input, PrintRequest, ErrorOutputType};\n+use rustc::session::{config, Session, DiagnosticOutput};\n+use rustc::session::config::{Input, PrintRequest, ErrorOutputType, OutputType};\n use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n+use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::util::common::{time, ErrorReported, install_panic_hook};\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n-use rustc::util::common::{time, ErrorReported};\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-use rustc_interface::util::{self, get_codegen_sysroot};\n+use rustc_interface::interface;\n+use rustc_interface::util::get_codegen_sysroot;\n+use rustc_data_structures::sync::SeqCst;\n \n use serialize::json::ToJson;\n \n-use std::any::Any;\n use std::borrow::Cow;\n use std::cmp::max;\n use std::default::Default;\n use std::env;\n-use std::error::Error;\n use std::ffi::OsString;\n-use std::fmt::{self, Display};\n use std::io::{self, Read, Write};\n-use std::panic;\n+use std::panic::{self, catch_unwind};\n use std::path::PathBuf;\n use std::process::{self, Command, Stdio};\n use std::str;\n-use std::thread;\n+use std::mem;\n \n use syntax::ast;\n-use syntax::source_map::{SourceMap, FileLoader, RealFileLoader};\n+use syntax::source_map::FileLoader;\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n #[cfg(test)]\n mod test;\n \n-pub mod driver;\n pub mod pretty;\n \n /// Exit status code used for successful compilation and help output.\n-pub const EXIT_SUCCESS: isize = 0;\n+pub const EXIT_SUCCESS: i32 = 0;\n \n /// Exit status code used for compilation failures and  invalid flags.\n-pub const EXIT_FAILURE: isize = 1;\n+pub const EXIT_FAILURE: i32 = 1;\n \n const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n                               md#bug-reports\";\n@@ -115,172 +111,290 @@ const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &[&str] = &[\"metadata\", \"extra-filename\n \n const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &[&str] = &[\"incremental\"];\n \n-pub fn abort_on_err<T>(result: Result<T, CompileIncomplete>, sess: &Session) -> T {\n+pub fn source_name(input: &Input) -> FileName {\n+    match *input {\n+        Input::File(ref ifile) => ifile.clone().into(),\n+        Input::Str { ref name, .. } => name.clone(),\n+    }\n+}\n+\n+pub fn abort_on_err<T>(result: Result<T, ErrorReported>, sess: &Session) -> T {\n     match result {\n-        Err(CompileIncomplete::Errored(ErrorReported)) => {\n+        Err(..) => {\n             sess.abort_if_errors();\n             panic!(\"error reported but abort_if_errors didn't abort???\");\n         }\n-        Err(CompileIncomplete::Stopped) => {\n-            sess.fatal(\"compilation terminated\");\n-        }\n         Ok(x) => x,\n     }\n }\n \n-pub fn run<F>(run_compiler: F) -> isize\n-    where F: FnOnce() -> (CompileResult, Option<Session>) + Send + 'static\n-{\n-    let result = monitor(move || {\n-        syntax::with_globals(|| {\n-            let (result, session) = run_compiler();\n-            if let Err(CompileIncomplete::Errored(_)) = result {\n-                match session {\n-                    Some(sess) => {\n-                        sess.abort_if_errors();\n-                        panic!(\"error reported but abort_if_errors didn't abort???\");\n-                    }\n-                    None => {\n-                        let emitter =\n-                            errors::emitter::EmitterWriter::stderr(\n-                                errors::ColorConfig::Auto,\n-                                None,\n-                                true,\n-                                false\n-                            );\n-                        let handler = errors::Handler::with_emitter(true, None, Box::new(emitter));\n-                        handler.emit(&MultiSpan::new(),\n-                                     \"aborting due to previous error(s)\",\n-                                     errors::Level::Fatal);\n-                        panic::resume_unwind(Box::new(errors::FatalErrorMarker));\n-                    }\n-                }\n-            }\n-        });\n-    });\n-\n-    match result {\n-        Ok(()) => EXIT_SUCCESS,\n-        Err(_) => EXIT_FAILURE,\n+pub trait Callbacks {\n+    /// Called before creating the compiler instance\n+    fn config(&mut self, _config: &mut interface::Config) {}\n+    /// Called after parsing and returns true to continue execution\n+    fn after_parsing(&mut self, _compiler: &interface::Compiler) -> bool {\n+        true\n+    }\n+    /// Called after analysis and returns true to continue execution\n+    fn after_analysis(&mut self, _compiler: &interface::Compiler) -> bool {\n+        true\n     }\n }\n \n+pub struct DefaultCallbacks;\n+\n+impl Callbacks for DefaultCallbacks {}\n+\n // Parse args and run the compiler. This is the primary entry point for rustc.\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n-pub fn run_compiler<'a>(args: &[String],\n-                        callbacks: Box<dyn CompilerCalls<'a> + sync::Send + 'a>,\n-                        file_loader: Option<Box<dyn FileLoader + Send + Sync + 'static>>,\n-                        emitter_dest: Option<Box<dyn Write + Send>>)\n-                        -> (CompileResult, Option<Session>)\n-{\n+pub fn run_compiler(\n+    args: &[String],\n+    callbacks: &mut (dyn Callbacks + Send),\n+    file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    emitter: Option<Box<dyn Write + Send>>\n+) -> interface::Result<()> {\n+    let diagnostic_output = emitter.map(|emitter| DiagnosticOutput::Raw(emitter))\n+                                   .unwrap_or(DiagnosticOutput::Default);\n     let matches = match handle_options(args) {\n         Some(matches) => matches,\n-        None => return (Ok(()), None),\n+        None => return Ok(()),\n     };\n \n-    let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n-\n-    driver::spawn_thread_pool(sopts, |sopts| {\n-        run_compiler_with_pool(matches, sopts, cfg, callbacks, file_loader, emitter_dest)\n-    })\n-}\n+    install_panic_hook();\n \n-fn run_compiler_with_pool<'a>(\n-    matches: getopts::Matches,\n-    sopts: config::Options,\n-    cfg: ast::CrateConfig,\n-    mut callbacks: Box<dyn CompilerCalls<'a> + sync::Send + 'a>,\n-    file_loader: Option<Box<dyn FileLoader + Send + Sync + 'static>>,\n-    emitter_dest: Option<Box<dyn Write + Send>>\n-) -> (CompileResult, Option<Session>) {\n-    macro_rules! do_or_return {($expr: expr, $sess: expr) => {\n-        match $expr {\n-            Compilation::Stop => return (Ok(()), $sess),\n-            Compilation::Continue => {}\n-        }\n-    }}\n+    let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n-    let descriptions = diagnostics_registry();\n+    let mut dummy_config = |sopts, cfg, diagnostic_output| {\n+        let mut config = interface::Config {\n+            opts: sopts,\n+            crate_cfg: cfg,\n+            input: Input::File(PathBuf::new()),\n+            input_path: None,\n+            output_file: None,\n+            output_dir: None,\n+            file_loader: None,\n+            diagnostic_output,\n+            stderr: None,\n+            crate_name: None,\n+            lint_caps: Default::default(),\n+        };\n+        callbacks.config(&mut config);\n+        config\n+    };\n \n-    do_or_return!(callbacks.early_callback(&matches,\n-                                           &sopts,\n-                                           &cfg,\n-                                           &descriptions,\n-                                           sopts.error_format),\n-                                           None);\n+    if let Some(ref code) = matches.opt_str(\"explain\") {\n+        handle_explain(code, sopts.error_format);\n+        return Ok(());\n+    }\n \n     let (odir, ofile) = make_output(&matches);\n     let (input, input_file_path, input_err) = match make_input(&matches.free) {\n-        Some((input, input_file_path, input_err)) => {\n-            let (input, input_file_path) = callbacks.some_input(input, input_file_path);\n-            (input, input_file_path, input_err)\n-        },\n-        None => match callbacks.no_input(&matches, &sopts, &cfg, &odir, &ofile, &descriptions) {\n-            Some((input, input_file_path)) => (input, input_file_path, None),\n-            None => return (Ok(()), None),\n-        },\n-    };\n+        Some(v) => v,\n+        None => {\n+            match matches.free.len() {\n+                0 => {\n+                    let config = dummy_config(sopts, cfg, diagnostic_output);\n+                    interface::run_compiler(config, |compiler| {\n+                        let sopts = &compiler.session().opts;\n+                        if sopts.describe_lints {\n+                            describe_lints(\n+                                compiler.session(),\n+                                &*compiler.session().lint_store.borrow(),\n+                                false\n+                            );\n+                            return;\n+                        }\n+                        let should_stop = RustcDefaultCalls::print_crate_info(\n+                            &***compiler.codegen_backend(),\n+                            compiler.session(),\n+                            None,\n+                            &odir,\n+                            &ofile\n+                        );\n \n-    let loader = file_loader.unwrap_or(box RealFileLoader);\n-    let source_map = Lrc::new(SourceMap::with_file_loader(loader, sopts.file_path_mapping()));\n-    let mut sess = session::build_session_with_source_map(\n-        sopts,\n-        input_file_path.clone(),\n-        descriptions,\n-        source_map,\n-        emitter_dest.map(|e| DiagnosticOutput::Raw(e)).unwrap_or(DiagnosticOutput::Default),\n-        Default::default(),\n-    );\n+                        if should_stop == Compilation::Stop {\n+                            return;\n+                        }\n+                        early_error(sopts.error_format, \"no input filename given\")\n+                    });\n+                    return Ok(());\n+                }\n+                1 => panic!(\"make_input should have provided valid inputs\"),\n+                _ => early_error(sopts.error_format, &format!(\n+                    \"multiple input filenames provided (first two filenames are `{}` and `{}`)\",\n+                    matches.free[0],\n+                    matches.free[1],\n+                )),\n+            }\n+        }\n+    };\n \n     if let Some(err) = input_err {\n         // Immediately stop compilation if there was an issue reading\n         // the input (for example if the input stream is not UTF-8).\n-        sess.err(&err.to_string());\n-        return (Err(CompileIncomplete::Stopped), Some(sess));\n+        interface::run_compiler(dummy_config(sopts, cfg, diagnostic_output), |compiler| {\n+            compiler.session().err(&err.to_string());\n+        });\n+        return Err(ErrorReported);\n     }\n \n-    let codegen_backend = util::get_codegen_backend(&sess);\n+    let mut config = interface::Config {\n+        opts: sopts,\n+        crate_cfg: cfg,\n+        input,\n+        input_path: input_file_path,\n+        output_file: ofile,\n+        output_dir: odir,\n+        file_loader,\n+        diagnostic_output,\n+        stderr: None,\n+        crate_name: None,\n+        lint_caps: Default::default(),\n+    };\n+\n+    callbacks.config(&mut config);\n+\n+    interface::run_compiler(config, |compiler| {\n+        let sess = compiler.session();\n+        let should_stop = RustcDefaultCalls::print_crate_info(\n+            &***compiler.codegen_backend(),\n+            sess,\n+            Some(compiler.input()),\n+            compiler.output_dir(),\n+            compiler.output_file(),\n+        ).and_then(|| RustcDefaultCalls::list_metadata(\n+            sess,\n+            compiler.cstore(),\n+            &matches,\n+            compiler.input()\n+        ));\n+\n+        if should_stop == Compilation::Stop {\n+            return sess.compile_status();\n+        }\n+\n+        let pretty_info = parse_pretty(sess, &matches);\n+\n+        compiler.parse()?;\n \n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+        if let Some((ppm, opt_uii)) = pretty_info {\n+            if ppm.needs_ast_map(&opt_uii) {\n+                pretty::visit_crate(sess, &mut compiler.parse()?.peek_mut(), ppm);\n+                compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n+                    let expanded_crate = compiler.expansion()?.take().0;\n+                    pretty::print_after_hir_lowering(\n+                        tcx,\n+                        compiler.input(),\n+                        &expanded_crate,\n+                        ppm,\n+                        opt_uii.clone(),\n+                        compiler.output_file().as_ref().map(|p| &**p),\n+                    );\n+                    Ok(())\n+                })?;\n+                return sess.compile_status();\n+            } else {\n+                let mut krate = compiler.parse()?.take();\n+                pretty::visit_crate(sess, &mut krate, ppm);\n+                pretty::print_after_parsing(\n+                    sess,\n+                    &compiler.input(),\n+                    &krate,\n+                    ppm,\n+                    compiler.output_file().as_ref().map(|p| &**p),\n+                );\n+                return sess.compile_status();\n+            }\n+        }\n \n-    let mut cfg = config::build_configuration(&sess, cfg);\n-    util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n-    sess.parse_sess.config = cfg;\n+        if !callbacks.after_parsing(compiler) {\n+            return sess.compile_status();\n+        }\n \n-    let result = {\n-        let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n+        if sess.opts.debugging_opts.parse_only ||\n+           sess.opts.debugging_opts.show_span.is_some() ||\n+           sess.opts.debugging_opts.ast_json_noexpand {\n+            return sess.compile_status();\n+        }\n \n-        let cstore = CStore::new(codegen_backend.metadata_loader());\n+        compiler.register_plugins()?;\n \n-        do_or_return!(callbacks.late_callback(&*codegen_backend,\n-                                              &matches,\n-                                              &sess,\n-                                              &cstore,\n-                                              &input,\n-                                              &odir,\n-                                              &ofile), Some(sess));\n+        // Lint plugins are registered; now we can process command line flags.\n+        if sess.opts.describe_lints {\n+            describe_lints(&sess, &sess.lint_store.borrow(), true);\n+            return sess.compile_status();\n+        }\n \n-        let _sess_abort_error = OnDrop(|| sess.diagnostic().print_error_count());\n+        compiler.prepare_outputs()?;\n \n-        let control = callbacks.build_controller(&sess, &matches);\n+        if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n+            && sess.opts.output_types.len() == 1\n+        {\n+            return sess.compile_status();\n+        }\n \n-        driver::compile_input(codegen_backend,\n-                              &sess,\n-                              &cstore,\n-                              &input_file_path,\n-                              &input,\n-                              &odir,\n-                              &ofile,\n-                              Some(plugins),\n-                              &control)\n-    };\n+        compiler.global_ctxt()?;\n \n-    if sess.opts.debugging_opts.self_profile {\n-        sess.profiler(|p| p.dump_raw_events(&sess.opts));\n-    }\n+        if sess.opts.debugging_opts.no_analysis ||\n+           sess.opts.debugging_opts.ast_json {\n+            return sess.compile_status();\n+        }\n+\n+        if sess.opts.debugging_opts.save_analysis {\n+            let expanded_crate = compiler.expansion()?.take().0;\n+\n+            let crate_name = compiler.crate_name()?.peek().clone();\n+            compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n+                let result = tcx.analysis(LOCAL_CRATE);\n+\n+                time(sess, \"save analysis\", || {\n+                    // FIXME: Should this run even with analysis errors?\n+                    save::process_crate(\n+                        tcx,\n+                        &expanded_crate,\n+                        &crate_name,\n+                        &compiler.input(),\n+                        None,\n+                        DumpHandler::new(compiler.output_dir().as_ref().map(|p| &**p), &crate_name)\n+                    )\n+                });\n+\n+                result\n+            })?;\n+        } else {\n+            // Drop AST after creating GlobalCtxt to free memory\n+            mem::drop(compiler.expansion()?.take());\n+        }\n+        compiler.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n+\n+        if !callbacks.after_analysis(compiler) {\n+            return sess.compile_status();\n+        }\n+\n+        compiler.ongoing_codegen()?;\n+\n+        // Drop GlobalCtxt after starting codegen to free memory\n+        mem::drop(compiler.global_ctxt()?.take());\n+\n+        if sess.opts.debugging_opts.print_type_sizes {\n+            sess.code_stats.borrow().print_type_sizes();\n+        }\n+\n+        compiler.link()?;\n+\n+        if sess.opts.debugging_opts.perf_stats {\n+            sess.print_perf_stats();\n+        }\n+\n+        if sess.print_fuel_crate.is_some() {\n+            eprintln!(\"Fuel used by {}: {}\",\n+                sess.print_fuel_crate.as_ref().unwrap(),\n+                sess.print_fuel.load(SeqCst));\n+        }\n \n-    (result, Some(sess))\n+        Ok(())\n+    })\n }\n \n #[cfg(unix)]\n@@ -363,72 +477,6 @@ impl Compilation {\n     }\n }\n \n-/// A trait for customizing the compilation process. Offers a number of hooks for\n-/// executing custom code or customizing input.\n-pub trait CompilerCalls<'a> {\n-    /// Hook for a callback early in the process of handling arguments. This will\n-    /// be called straight after options have been parsed but before anything\n-    /// else (e.g., selecting input and output).\n-    fn early_callback(&mut self,\n-                      _: &getopts::Matches,\n-                      _: &config::Options,\n-                      _: &ast::CrateConfig,\n-                      _: &errors::registry::Registry,\n-                      _: ErrorOutputType)\n-                      -> Compilation {\n-        Compilation::Continue\n-    }\n-\n-    /// Hook for a callback late in the process of handling arguments. This will\n-    /// be called just before actual compilation starts (and before build_controller\n-    /// is called), after all arguments etc. have been completely handled.\n-    fn late_callback(&mut self,\n-                     _: &dyn CodegenBackend,\n-                     _: &getopts::Matches,\n-                     _: &Session,\n-                     _: &CStore,\n-                     _: &Input,\n-                     _: &Option<PathBuf>,\n-                     _: &Option<PathBuf>)\n-                     -> Compilation {\n-        Compilation::Continue\n-    }\n-\n-    /// Called after we extract the input from the arguments. Gives the implementer\n-    /// an opportunity to change the inputs or to add some custom input handling.\n-    /// The default behaviour is to simply pass through the inputs.\n-    fn some_input(&mut self,\n-                  input: Input,\n-                  input_path: Option<PathBuf>)\n-                  -> (Input, Option<PathBuf>) {\n-        (input, input_path)\n-    }\n-\n-    /// Called after we extract the input from the arguments if there is no valid\n-    /// input. Gives the implementer an opportunity to supply alternate input (by\n-    /// returning a Some value) or to add custom behaviour for this error such as\n-    /// emitting error messages. Returning None will cause compilation to stop\n-    /// at this point.\n-    fn no_input(&mut self,\n-                _: &getopts::Matches,\n-                _: &config::Options,\n-                _: &ast::CrateConfig,\n-                _: &Option<PathBuf>,\n-                _: &Option<PathBuf>,\n-                _: &errors::registry::Registry)\n-                -> Option<(Input, Option<PathBuf>)> {\n-        None\n-    }\n-\n-    // Create a CompilController struct for controlling the behaviour of\n-    // compilation.\n-    fn build_controller(\n-        self: Box<Self>,\n-        _: &Session,\n-        _: &getopts::Matches\n-    ) -> CompileController<'a>;\n-}\n-\n /// CompilerCalls instance for a regular rustc build.\n #[derive(Copy, Clone)]\n pub struct RustcDefaultCalls;\n@@ -532,178 +580,6 @@ fn show_content_with_pager(content: &String) {\n     }\n }\n \n-impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n-    fn early_callback(&mut self,\n-                      matches: &getopts::Matches,\n-                      _: &config::Options,\n-                      _: &ast::CrateConfig,\n-                      _: &errors::registry::Registry,\n-                      output: ErrorOutputType)\n-                      -> Compilation {\n-        if let Some(ref code) = matches.opt_str(\"explain\") {\n-            handle_explain(code, output);\n-            return Compilation::Stop;\n-        }\n-\n-        Compilation::Continue\n-    }\n-\n-    fn no_input(&mut self,\n-                matches: &getopts::Matches,\n-                sopts: &config::Options,\n-                cfg: &ast::CrateConfig,\n-                odir: &Option<PathBuf>,\n-                ofile: &Option<PathBuf>,\n-                descriptions: &errors::registry::Registry)\n-                -> Option<(Input, Option<PathBuf>)> {\n-        match matches.free.len() {\n-            0 => {\n-                let mut sess = build_session(sopts.clone(),\n-                    None,\n-                    descriptions.clone());\n-                if sopts.describe_lints {\n-                    let mut ls = lint::LintStore::new();\n-                    rustc_lint::register_builtins(&mut ls, Some(&sess));\n-                    describe_lints(&sess, &ls, false);\n-                    return None;\n-                }\n-                rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-                let mut cfg = config::build_configuration(&sess, cfg.clone());\n-                let codegen_backend = util::get_codegen_backend(&sess);\n-                util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n-                sess.parse_sess.config = cfg;\n-                let should_stop = RustcDefaultCalls::print_crate_info(\n-                    &*codegen_backend,\n-                    &sess,\n-                    None,\n-                    odir,\n-                    ofile\n-                );\n-\n-                if should_stop == Compilation::Stop {\n-                    return None;\n-                }\n-                early_error(sopts.error_format, \"no input filename given\");\n-            }\n-            1 => panic!(\"make_input should have provided valid inputs\"),\n-            _ =>\n-                early_error(\n-                    sopts.error_format,\n-                    &format!(\n-                        \"multiple input filenames provided (first two filenames are `{}` and `{}`)\",\n-                        matches.free[0],\n-                        matches.free[1],\n-                    ),\n-                )\n-        }\n-    }\n-\n-    fn late_callback(&mut self,\n-                     codegen_backend: &dyn CodegenBackend,\n-                     matches: &getopts::Matches,\n-                     sess: &Session,\n-                     cstore: &CStore,\n-                     input: &Input,\n-                     odir: &Option<PathBuf>,\n-                     ofile: &Option<PathBuf>)\n-                     -> Compilation {\n-        RustcDefaultCalls::print_crate_info(codegen_backend, sess, Some(input), odir, ofile)\n-            .and_then(|| RustcDefaultCalls::list_metadata(sess, cstore, matches, input))\n-    }\n-\n-    fn build_controller(self: Box<Self>,\n-                        sess: &Session,\n-                        matches: &getopts::Matches)\n-                        -> CompileController<'a> {\n-        let mut control = CompileController::basic();\n-\n-        control.keep_ast = sess.opts.debugging_opts.keep_ast;\n-        control.continue_parse_after_error = sess.opts.debugging_opts.continue_parse_after_error;\n-\n-        if let Some((ppm, opt_uii)) = parse_pretty(sess, matches) {\n-            if ppm.needs_ast_map(&opt_uii) {\n-                control.after_hir_lowering.stop = Compilation::Stop;\n-\n-                control.after_parse.callback = box move |state| {\n-                    let mut krate = state.krate.take().unwrap();\n-                    pretty::visit_crate(state.session, &mut krate, ppm);\n-                    state.krate = Some(krate);\n-                };\n-                control.after_hir_lowering.callback = box move |state| {\n-                    pretty::print_after_hir_lowering(state.session,\n-                                                     state.cstore.unwrap(),\n-                                                     state.hir_map.unwrap(),\n-                                                     state.resolutions.unwrap(),\n-                                                     state.input,\n-                                                     &state.expanded_crate.take().unwrap(),\n-                                                     state.crate_name.unwrap(),\n-                                                     ppm,\n-                                                     state.output_filenames.unwrap(),\n-                                                     opt_uii.clone(),\n-                                                     state.out_file);\n-                };\n-            } else {\n-                control.after_parse.stop = Compilation::Stop;\n-\n-                control.after_parse.callback = box move |state| {\n-                    let mut krate = state.krate.take().unwrap();\n-                    pretty::visit_crate(state.session, &mut krate, ppm);\n-                    pretty::print_after_parsing(state.session,\n-                                                state.input,\n-                                                &krate,\n-                                                ppm,\n-                                                state.out_file);\n-                };\n-            }\n-\n-            return control;\n-        }\n-\n-        if sess.opts.debugging_opts.parse_only ||\n-           sess.opts.debugging_opts.show_span.is_some() ||\n-           sess.opts.debugging_opts.ast_json_noexpand {\n-            control.after_parse.stop = Compilation::Stop;\n-        }\n-\n-        if sess.opts.debugging_opts.no_analysis ||\n-           sess.opts.debugging_opts.ast_json {\n-            control.after_hir_lowering.stop = Compilation::Stop;\n-        }\n-\n-        if sess.opts.debugging_opts.save_analysis {\n-            enable_save_analysis(&mut control);\n-        }\n-\n-        if sess.print_fuel_crate.is_some() {\n-            let old_callback = control.compilation_done.callback;\n-            control.compilation_done.callback = box move |state| {\n-                old_callback(state);\n-                let sess = state.session;\n-                eprintln!(\"Fuel used by {}: {}\",\n-                    sess.print_fuel_crate.as_ref().unwrap(),\n-                    sess.print_fuel.load(SeqCst));\n-            }\n-        }\n-        control\n-    }\n-}\n-\n-pub fn enable_save_analysis(control: &mut CompileController) {\n-    control.keep_ast = true;\n-    control.after_analysis.callback = box |state| {\n-        time(state.session, \"save analysis\", || {\n-            save::process_crate(state.tcx.unwrap(),\n-                                state.expanded_crate.unwrap(),\n-                                state.crate_name.unwrap(),\n-                                state.input,\n-                                None,\n-                                DumpHandler::new(state.out_dir,\n-                                                 state.crate_name.unwrap()))\n-        });\n-    };\n-    control.after_analysis.run_callback_on_error = true;\n-}\n-\n impl RustcDefaultCalls {\n     pub fn list_metadata(sess: &Session,\n                          cstore: &CStore,\n@@ -1199,49 +1075,6 @@ fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, Vec<as\n     }\n }\n \n-// Temporarily have stack size set to 32MB to deal with various crates with long method\n-// chains or deep syntax trees.\n-// FIXME(oli-obk): get https://github.com/rust-lang/rust/pull/55617 the finish line\n-const STACK_SIZE: usize = 32 * 1024 * 1024; // 32MB\n-\n-/// Runs `f` in a suitable thread for running `rustc`; returns a `Result` with either the return\n-/// value of `f` or -- if a panic occurs -- the panic value.\n-///\n-/// This version applies the given name to the thread. This is used by rustdoc to ensure consistent\n-/// doctest output across platforms and executions.\n-pub fn in_named_rustc_thread<F, R>(name: String, f: F) -> Result<R, Box<dyn Any + Send>>\n-    where F: FnOnce() -> R + Send + 'static,\n-          R: Send + 'static,\n-{\n-    // We need a thread for soundness of thread local storage in rustc. For debugging purposes\n-    // we allow an escape hatch where everything runs on the main thread.\n-    if env::var_os(\"RUSTC_UNSTABLE_NO_MAIN_THREAD\").is_none() {\n-        let mut cfg = thread::Builder::new().name(name);\n-\n-        // If the env is trying to override the stack size then *don't* set it explicitly.\n-        // The libstd thread impl will fetch the `RUST_MIN_STACK` env var itself.\n-        if env::var_os(\"RUST_MIN_STACK\").is_none() {\n-            cfg = cfg.stack_size(STACK_SIZE);\n-        }\n-\n-        let thread = cfg.spawn(f);\n-        thread.unwrap().join()\n-    } else {\n-        let f = panic::AssertUnwindSafe(f);\n-        panic::catch_unwind(f)\n-    }\n-}\n-\n-/// Runs `f` in a suitable thread for running `rustc`; returns a\n-/// `Result` with either the return value of `f` or -- if a panic\n-/// occurs -- the panic value.\n-pub fn in_rustc_thread<F, R>(f: F) -> Result<R, Box<dyn Any + Send>>\n-    where F: FnOnce() -> R + Send + 'static,\n-          R: Send + 'static,\n-{\n-    in_named_rustc_thread(\"rustc\".to_string(), f)\n-}\n-\n /// Gets a list of extra command-line flags provided by the user, as strings.\n ///\n /// This function is used during ICEs to show more information useful for\n@@ -1296,28 +1129,15 @@ fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n     }\n }\n \n-#[derive(Debug)]\n-pub struct CompilationFailure;\n-\n-impl Error for CompilationFailure {}\n-\n-impl Display for CompilationFailure {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"compilation had errors\")\n-    }\n-}\n-\n /// Runs a procedure which will detect panics in the compiler and print nicer\n /// error messages rather than just failing the test.\n ///\n /// The diagnostic emitter yielded to the procedure should be used for reporting\n /// errors of the compiler.\n-pub fn monitor<F: FnOnce() + Send + 'static>(f: F) -> Result<(), CompilationFailure> {\n-    in_rustc_thread(move || {\n-        f()\n-    }).map_err(|value| {\n+pub fn report_ices_to_stderr_if_any<F: FnOnce() -> R, R>(f: F) -> Result<R, ErrorReported> {\n+    catch_unwind(panic::AssertUnwindSafe(f)).map_err(|value| {\n         if value.is::<errors::FatalErrorMarker>() {\n-            CompilationFailure\n+            ErrorReported\n         } else {\n             // Thread panicked without emitting a fatal diagnostic\n             eprintln!(\"\");\n@@ -1364,25 +1184,6 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) -> Result<(), CompilationFail\n     })\n }\n \n-pub fn diagnostics_registry() -> errors::registry::Registry {\n-    use errors::registry::Registry;\n-\n-    let mut all_errors = Vec::new();\n-    all_errors.extend_from_slice(&rustc::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_typeck::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n-    // FIXME: need to figure out a way to get these back in here\n-    // all_errors.extend_from_slice(get_codegen_backend(sess).diagnostics());\n-    all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_passes::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_plugin::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_mir::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&syntax::DIAGNOSTICS);\n-\n-    Registry::new(&all_errors)\n-}\n-\n /// This allows tools to enable rust logging without having to magically match rustc's\n /// log crate version\n pub fn init_rustc_env_logger() {\n@@ -1391,17 +1192,17 @@ pub fn init_rustc_env_logger() {\n \n pub fn main() {\n     init_rustc_env_logger();\n-    let result = run(|| {\n+    let result = report_ices_to_stderr_if_any(|| {\n         let args = env::args_os().enumerate()\n             .map(|(i, arg)| arg.into_string().unwrap_or_else(|arg| {\n                 early_error(ErrorOutputType::default(),\n                             &format!(\"Argument {} is not valid Unicode: {:?}\", i, arg))\n             }))\n             .collect::<Vec<_>>();\n-        run_compiler(&args,\n-                     Box::new(RustcDefaultCalls),\n-                     None,\n-                     None)\n+        run_compiler(&args, &mut DefaultCallbacks, None, None)\n+    }).and_then(|result| result);\n+    process::exit(match result {\n+        Ok(_) => EXIT_SUCCESS,\n+        Err(_) => EXIT_FAILURE,\n     });\n-    process::exit(result as i32);\n }"}, {"sha": "3182b2ce30c6d52b1347297a464c68364213ae93", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 107, "deletions": 166, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -6,13 +6,14 @@ use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks;\n use rustc::hir::print as pprust_hir;\n+use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::session::Session;\n-use rustc::session::config::{Input, OutputFilenames};\n-use rustc::ty::{self, TyCtxt, Resolutions, AllArenas};\n-use rustc_interface::util;\n+use rustc::session::config::Input;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::util::common::ErrorReported;\n+use rustc_interface::util::ReplaceBodyWithLoop;\n use rustc_borrowck as borrowck;\n use rustc_borrowck::graphviz as borrowck_dot;\n-use rustc_metadata::cstore::CStore;\n use rustc_mir::util::{write_mir_pretty, write_mir_graphviz};\n \n use syntax::ast;\n@@ -35,7 +36,8 @@ pub use self::PpSourceMode::*;\n pub use self::PpMode::*;\n use self::NodesMatchingUII::*;\n use abort_on_err;\n-use driver;\n+\n+use source_name;\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum PpSourceMode {\n@@ -154,7 +156,7 @@ impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n     fn call_with_pp_support<'tcx, A, F>(&self,\n                                         sess: &'tcx Session,\n-                                        hir_map: Option<&hir_map::Map<'tcx>>,\n+                                        tcx: Option<TyCtxt<'tcx, 'tcx, 'tcx>>,\n                                         f: F)\n                                         -> A\n         where F: FnOnce(&dyn PrinterSupport) -> A\n@@ -163,15 +165,15 @@ impl PpSourceMode {\n             PpmNormal | PpmEveryBodyLoops | PpmExpanded => {\n                 let annotation = NoAnn {\n                     sess,\n-                    hir_map: hir_map.map(|m| m.clone()),\n+                    tcx,\n                 };\n                 f(&annotation)\n             }\n \n             PpmIdentified | PpmExpandedIdentified => {\n                 let annotation = IdentifiedAnnotation {\n                     sess,\n-                    hir_map: hir_map.map(|m| m.clone()),\n+                    tcx,\n                 };\n                 f(&annotation)\n             }\n@@ -186,55 +188,37 @@ impl PpSourceMode {\n     }\n     fn call_with_pp_support_hir<'tcx, A, F>(\n         &self,\n-        sess: &'tcx Session,\n-        cstore: &'tcx CStore,\n-        hir_map: &hir_map::Map<'tcx>,\n-        resolutions: &Resolutions,\n-        output_filenames: &OutputFilenames,\n-        id: &str,\n+        tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n         f: F\n     ) -> A\n         where F: FnOnce(&dyn HirPrinterSupport, &hir::Crate) -> A\n     {\n         match *self {\n             PpmNormal => {\n                 let annotation = NoAnn {\n-                    sess,\n-                    hir_map: Some(hir_map.clone()),\n+                    sess: tcx.sess,\n+                    tcx: Some(tcx),\n                 };\n-                f(&annotation, hir_map.forest.krate())\n+                f(&annotation, tcx.hir().forest.krate())\n             }\n \n             PpmIdentified => {\n                 let annotation = IdentifiedAnnotation {\n-                    sess,\n-                    hir_map: Some(hir_map.clone()),\n+                    sess: tcx.sess,\n+                    tcx: Some(tcx),\n                 };\n-                f(&annotation, hir_map.forest.krate())\n+                f(&annotation, tcx.hir().forest.krate())\n             }\n             PpmTyped => {\n-                let control = &driver::CompileController::basic();\n-                let codegen_backend = util::get_codegen_backend(sess);\n-                let mut arenas = AllArenas::new();\n-                driver::phase_3_run_analysis_passes(&*codegen_backend,\n-                                                    control,\n-                                                    sess,\n-                                                    cstore,\n-                                                    hir_map.clone(),\n-                                                    resolutions.clone(),\n-                                                    &mut arenas,\n-                                                    id,\n-                                                    output_filenames,\n-                                                    |tcx, _, result| {\n-                    abort_on_err(result, tcx.sess);\n-                    let empty_tables = ty::TypeckTables::empty(None);\n-                    let annotation = TypedAnnotation {\n-                        tcx,\n-                        tables: Cell::new(&empty_tables)\n-                    };\n-                    tcx.dep_graph.with_ignore(|| {\n-                        f(&annotation, hir_map.forest.krate())\n-                    })\n+                abort_on_err(tcx.analysis(LOCAL_CRATE), tcx.sess);\n+\n+                let empty_tables = ty::TypeckTables::empty(None);\n+                let annotation = TypedAnnotation {\n+                    tcx,\n+                    tables: Cell::new(&empty_tables)\n+                };\n+                tcx.dep_graph.with_ignore(|| {\n+                    f(&annotation, tcx.hir().forest.krate())\n                 })\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n@@ -283,7 +267,7 @@ trait HirPrinterSupport<'hir>: pprust_hir::PpAnn {\n \n struct NoAnn<'hir> {\n     sess: &'hir Session,\n-    hir_map: Option<hir_map::Map<'hir>>,\n+    tcx: Option<TyCtxt<'hir, 'hir, 'hir>>,\n }\n \n impl<'hir> PrinterSupport for NoAnn<'hir> {\n@@ -302,7 +286,7 @@ impl<'hir> HirPrinterSupport<'hir> for NoAnn<'hir> {\n     }\n \n     fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'hir>> {\n-        self.hir_map.as_ref()\n+        self.tcx.map(|tcx| tcx.hir())\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a dyn pprust_hir::PpAnn {\n@@ -314,8 +298,8 @@ impl<'hir> pprust::PpAnn for NoAnn<'hir> {}\n impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n               -> io::Result<()> {\n-        if let Some(ref map) = self.hir_map {\n-            pprust_hir::PpAnn::nested(map, state, nested)\n+        if let Some(tcx) = self.tcx {\n+            pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n         } else {\n             Ok(())\n         }\n@@ -324,7 +308,7 @@ impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n \n struct IdentifiedAnnotation<'hir> {\n     sess: &'hir Session,\n-    hir_map: Option<hir_map::Map<'hir>>,\n+    tcx: Option<TyCtxt<'hir, 'hir, 'hir>>,\n }\n \n impl<'hir> PrinterSupport for IdentifiedAnnotation<'hir> {\n@@ -380,7 +364,7 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n     }\n \n     fn hir_map<'a>(&'a self) -> Option<&'a hir_map::Map<'hir>> {\n-        self.hir_map.as_ref()\n+        self.tcx.map(|tcx| tcx.hir())\n     }\n \n     fn pp_ann<'a>(&'a self) -> &'a dyn pprust_hir::PpAnn {\n@@ -391,8 +375,8 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State, nested: pprust_hir::Nested)\n               -> io::Result<()> {\n-        if let Some(ref map) = self.hir_map {\n-            pprust_hir::PpAnn::nested(map, state, nested)\n+        if let Some(ref tcx) = self.tcx {\n+            pprust_hir::PpAnn::nested(tcx.hir(), state, nested)\n         } else {\n             Ok(())\n         }\n@@ -691,12 +675,12 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n \n pub fn visit_crate(sess: &Session, krate: &mut ast::Crate, ppm: PpMode) {\n     if let PpmSource(PpmEveryBodyLoops) = ppm {\n-        util::ReplaceBodyWithLoop::new(sess).visit_crate(krate);\n+        ReplaceBodyWithLoop::new(sess).visit_crate(krate);\n     }\n }\n \n fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, FileName) {\n-    let src_name = input.source_name();\n+    let src_name = source_name(input);\n     let src = sess.source_map()\n         .get_source_file(&src_name)\n         .unwrap()\n@@ -752,31 +736,24 @@ pub fn print_after_parsing(sess: &Session,\n     write_output(out, ofile);\n }\n \n-pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n-                                                cstore: &'tcx CStore,\n-                                                hir_map: &hir_map::Map<'tcx>,\n-                                                resolutions: &Resolutions,\n-                                                input: &Input,\n-                                                krate: &ast::Crate,\n-                                                crate_name: &str,\n-                                                ppm: PpMode,\n-                                                output_filenames: &OutputFilenames,\n-                                                opt_uii: Option<UserIdentifiedItem>,\n-                                                ofile: Option<&Path>) {\n+pub fn print_after_hir_lowering<'tcx>(\n+    tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+    input: &Input,\n+    krate: &ast::Crate,\n+    ppm: PpMode,\n+    opt_uii: Option<UserIdentifiedItem>,\n+    ofile: Option<&Path>) {\n     if ppm.needs_analysis() {\n-        print_with_analysis(sess,\n-                            cstore,\n-                            hir_map,\n-                            resolutions,\n-                            crate_name,\n-                            output_filenames,\n-                            ppm,\n-                            opt_uii,\n-                            ofile);\n+        abort_on_err(print_with_analysis(\n+            tcx,\n+            ppm,\n+            opt_uii,\n+            ofile\n+        ), tcx.sess);\n         return;\n     }\n \n-    let (src, src_name) = get_source(input, sess);\n+    let (src, src_name) = get_source(input, tcx.sess);\n \n     let mut rdr = &src[..];\n     let mut out = Vec::new();\n@@ -785,7 +762,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n             (PpmSource(s), _) => {\n                 // Silently ignores an identified node.\n                 let out: &mut dyn Write = &mut out;\n-                s.call_with_pp_support(sess, Some(hir_map), move |annotation| {\n+                s.call_with_pp_support(tcx.sess, Some(tcx), move |annotation| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.source_map(),\n@@ -801,13 +778,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n \n             (PpmHir(s), None) => {\n                 let out: &mut dyn Write = &mut out;\n-                s.call_with_pp_support_hir(sess,\n-                                           cstore,\n-                                           hir_map,\n-                                           resolutions,\n-                                           output_filenames,\n-                                           crate_name,\n-                                           move |annotation, krate| {\n+                s.call_with_pp_support_hir(tcx, move |annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust_hir::print_crate(sess.source_map(),\n@@ -823,27 +794,15 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n \n             (PpmHirTree(s), None) => {\n                 let out: &mut dyn Write = &mut out;\n-                s.call_with_pp_support_hir(sess,\n-                                           cstore,\n-                                           hir_map,\n-                                           resolutions,\n-                                           output_filenames,\n-                                           crate_name,\n-                                           move |_annotation, krate| {\n+                s.call_with_pp_support_hir(tcx, move |_annotation, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     write!(out, \"{:#?}\", krate)\n                 })\n             }\n \n             (PpmHir(s), Some(uii)) => {\n                 let out: &mut dyn Write = &mut out;\n-                s.call_with_pp_support_hir(sess,\n-                                           cstore,\n-                                           hir_map,\n-                                           resolutions,\n-                                           output_filenames,\n-                                           crate_name,\n-                                           move |annotation, _| {\n+                s.call_with_pp_support_hir(tcx, move |annotation, _| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     let hir_map = annotation.hir_map().expect(\"-Z unpretty missing HIR map\");\n@@ -869,16 +828,10 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n \n             (PpmHirTree(s), Some(uii)) => {\n                 let out: &mut dyn Write = &mut out;\n-                s.call_with_pp_support_hir(sess,\n-                                           cstore,\n-                                           hir_map,\n-                                           resolutions,\n-                                           output_filenames,\n-                                           crate_name,\n-                                           move |_annotation, _krate| {\n+                s.call_with_pp_support_hir(tcx, move |_annotation, _krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n-                    for node_id in uii.all_matching_node_ids(hir_map) {\n-                        let node = hir_map.get(node_id);\n+                    for node_id in uii.all_matching_node_ids(tcx.hir()) {\n+                        let node = tcx.hir().get(node_id);\n                         write!(out, \"{:#?}\", node)?;\n                     }\n                     Ok(())\n@@ -896,85 +849,73 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n // analysis is performed. However, we want to call `phase_3_run_analysis_passes`\n // with a different callback than the standard driver, so that isn't easy.\n // Instead, we call that function ourselves.\n-fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n-                                       cstore: &'a CStore,\n-                                       hir_map: &hir_map::Map<'tcx>,\n-                                       resolutions: &Resolutions,\n-                                       crate_name: &str,\n-                                       output_filenames: &OutputFilenames,\n-                                       ppm: PpMode,\n-                                       uii: Option<UserIdentifiedItem>,\n-                                       ofile: Option<&Path>) {\n+fn print_with_analysis<'tcx>(\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    ppm: PpMode,\n+    uii: Option<UserIdentifiedItem>,\n+    ofile: Option<&Path>\n+) -> Result<(), ErrorReported> {\n     let nodeid = if let Some(uii) = uii {\n         debug!(\"pretty printing for {:?}\", uii);\n-        Some(uii.to_one_node_id(\"-Z unpretty\", sess, &hir_map))\n+        Some(uii.to_one_node_id(\"-Z unpretty\", tcx.sess, tcx.hir()))\n     } else {\n         debug!(\"pretty printing for whole crate\");\n         None\n     };\n \n     let mut out = Vec::new();\n \n-    let control = &driver::CompileController::basic();\n-    let codegen_backend = util::get_codegen_backend(sess);\n-    let mut arenas = AllArenas::new();\n-    driver::phase_3_run_analysis_passes(&*codegen_backend,\n-                                        control,\n-                                        sess,\n-                                        cstore,\n-                                        hir_map.clone(),\n-                                        resolutions.clone(),\n-                                        &mut arenas,\n-                                        crate_name,\n-                                        output_filenames,\n-                                        |tcx, _, result| {\n-        abort_on_err(result, tcx.sess);\n-        match ppm {\n-            PpmMir | PpmMirCFG => {\n-                if let Some(nodeid) = nodeid {\n-                    let def_id = tcx.hir().local_def_id(nodeid);\n-                    match ppm {\n-                        PpmMir => write_mir_pretty(tcx, Some(def_id), &mut out),\n-                        PpmMirCFG => write_mir_graphviz(tcx, Some(def_id), &mut out),\n-                        _ => unreachable!(),\n-                    }?;\n-                } else {\n-                    match ppm {\n-                        PpmMir => write_mir_pretty(tcx, None, &mut out),\n-                        PpmMirCFG => write_mir_graphviz(tcx, None, &mut out),\n-                        _ => unreachable!(),\n-                    }?;\n-                }\n-                Ok(())\n+    tcx.analysis(LOCAL_CRATE)?;\n+\n+    let mut print = || match ppm {\n+        PpmMir | PpmMirCFG => {\n+            if let Some(nodeid) = nodeid {\n+                let def_id = tcx.hir().local_def_id(nodeid);\n+                match ppm {\n+                    PpmMir => write_mir_pretty(tcx, Some(def_id), &mut out),\n+                    PpmMirCFG => write_mir_graphviz(tcx, Some(def_id), &mut out),\n+                    _ => unreachable!(),\n+                }?;\n+            } else {\n+                match ppm {\n+                    PpmMir => write_mir_pretty(tcx, None, &mut out),\n+                    PpmMirCFG => write_mir_graphviz(tcx, None, &mut out),\n+                    _ => unreachable!(),\n+                }?;\n             }\n-            PpmFlowGraph(mode) => {\n-                let nodeid =\n-                    nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or unique path \\\n-                                   suffix (b::c::d)\");\n-                let node = tcx.hir().find(nodeid).unwrap_or_else(|| {\n-                    tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n-                });\n+            Ok(())\n+        }\n+        PpmFlowGraph(mode) => {\n+            let nodeid =\n+                nodeid.expect(\"`pretty flowgraph=..` needs NodeId (int) or unique path \\\n+                                suffix (b::c::d)\");\n+            let node = tcx.hir().find(nodeid).unwrap_or_else(|| {\n+                tcx.sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\", nodeid))\n+            });\n \n-                match blocks::Code::from_node(&tcx.hir(), nodeid) {\n-                    Some(code) => {\n-                        let variants = gather_flowgraph_variants(tcx.sess);\n+            match blocks::Code::from_node(&tcx.hir(), nodeid) {\n+                Some(code) => {\n+                    let variants = gather_flowgraph_variants(tcx.sess);\n \n-                        let out: &mut dyn Write = &mut out;\n+                    let out: &mut dyn Write = &mut out;\n \n-                        print_flowgraph(variants, tcx, code, mode, out)\n-                    }\n-                    None => {\n-                        let message = format!(\"--pretty=flowgraph needs block, fn, or method; \\\n-                                               got {:?}\",\n-                                              node);\n+                    print_flowgraph(variants, tcx, code, mode, out)\n+                }\n+                None => {\n+                    let message = format!(\"--pretty=flowgraph needs block, fn, or method; \\\n+                                            got {:?}\",\n+                                            node);\n \n-                        tcx.sess.span_fatal(tcx.hir().span(nodeid), &message)\n-                    }\n+                    tcx.sess.span_fatal(tcx.hir().span(nodeid), &message)\n                 }\n             }\n-            _ => unreachable!(),\n         }\n-    }).unwrap();\n+        _ => unreachable!(),\n+    };\n+\n+    print().unwrap();\n \n     write_output(out, ofile);\n+\n+    Ok(())\n }"}, {"sha": "f98939eb40a8e45147178677ce410dd7e1ccfac2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 43, "deletions": 99, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -1,34 +1,23 @@\n //! Standalone tests for the inference module.\n \n-use driver;\n-use errors;\n use errors::emitter::Emitter;\n use errors::{DiagnosticBuilder, Level};\n use rustc::hir;\n-use rustc::hir::map as hir_map;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{self, InferOk, InferResult, SuppressRegionErrors};\n use rustc::middle::region;\n-use rustc::session::config::{OutputFilenames, OutputTypes};\n-use rustc::session::{self, config};\n+use rustc::session::{DiagnosticOutput, config};\n use rustc::traits::ObligationCause;\n-use rustc::ty::query::OnDiskCache;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc_data_structures::sync::{self, Lrc};\n-use rustc_interface::util;\n-use rustc_lint;\n-use rustc_metadata::cstore::CStore;\n+use rustc_data_structures::sync;\n use rustc_target::spec::abi::Abi;\n-use syntax;\n+use rustc_interface::interface;\n use syntax::ast;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::source_map::{FileName, FilePathMapping, SourceMap};\n+use syntax::source_map::FileName;\n use syntax::symbol::Symbol;\n \n-use std::path::PathBuf;\n-use std::sync::mpsc;\n-\n struct Env<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a infer::InferCtxt<'a, 'gcx, 'tcx>,\n     region_scope_tree: &'a mut region::ScopeTree,\n@@ -75,102 +64,57 @@ impl Emitter for ExpectErrorEmitter {\n     }\n }\n \n-fn errors(msgs: &[&str]) -> (Box<dyn Emitter + sync::Send>, usize) {\n-    let v = msgs.iter().map(|m| m.to_string()).collect();\n+fn errors(msgs: &[&str]) -> (Box<dyn Emitter + Send + sync::Send>, usize) {\n+    let mut v: Vec<_> = msgs.iter().map(|m| m.to_string()).collect();\n+    if !v.is_empty() {\n+        v.push(\"aborting due to previous error\".to_owned());\n+    }\n     (\n-        box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + sync::Send>,\n+        box ExpectErrorEmitter { messages: v } as Box<dyn Emitter + Send + sync::Send>,\n         msgs.len(),\n     )\n }\n \n-fn test_env<F>(source_string: &str, args: (Box<dyn Emitter + sync::Send>, usize), body: F)\n-where\n-    F: FnOnce(Env) + sync::Send,\n-{\n-    syntax::with_globals(|| {\n-        let mut options = config::Options::default();\n-        options.debugging_opts.verbose = true;\n-        options.unstable_features = UnstableFeatures::Allow;\n-\n-        // When we're compiling this library with `--test` it'll run as a binary but\n-        // not actually exercise much functionality.\n-        // As a result most of the logic loading the codegen backend is defunkt\n-        // (it assumes we're a dynamic library in a sysroot)\n-        // so let's just use the metadata only backend which doesn't need to load any libraries.\n-        options.debugging_opts.codegen_backend = Some(\"metadata_only\".to_owned());\n-\n-        driver::spawn_thread_pool(options, |options| {\n-            test_env_with_pool(options, source_string, args, body)\n-        })\n-    });\n-}\n-\n-fn test_env_with_pool<F>(\n-    options: config::Options,\n+fn test_env<F>(\n     source_string: &str,\n-    (emitter, expected_err_count): (Box<dyn Emitter + sync::Send>, usize),\n+    (emitter, expected_err_count): (Box<dyn Emitter + Send + sync::Send>, usize),\n     body: F,\n-) where\n-    F: FnOnce(Env),\n+)\n+where\n+    F: FnOnce(Env) + Send,\n {\n-    let diagnostic_handler = errors::Handler::with_emitter(true, None, emitter);\n-    let sess = session::build_session_(\n-        options,\n-        None,\n-        diagnostic_handler,\n-        Lrc::new(SourceMap::new(FilePathMapping::empty())),\n-        Default::default(),\n-    );\n-    let cstore = CStore::new(util::get_codegen_backend(&sess).metadata_loader());\n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+    let mut opts = config::Options::default();\n+    opts.debugging_opts.verbose = true;\n+    opts.unstable_features = UnstableFeatures::Allow;\n+\n+    // When we're compiling this library with `--test` it'll run as a binary but\n+    // not actually exercise much functionality.\n+    // As a result most of the logic loading the codegen backend is defunkt\n+    // (it assumes we're a dynamic library in a sysroot)\n+    // so let's just use the metadata only backend which doesn't need to load any libraries.\n+    opts.debugging_opts.codegen_backend = Some(\"metadata_only\".to_owned());\n+\n     let input = config::Input::Str {\n         name: FileName::anon_source_code(&source_string),\n         input: source_string.to_string(),\n     };\n-    let krate =\n-        driver::phase_1_parse_input(&driver::CompileController::basic(), &sess, &input).unwrap();\n-    let driver::ExpansionResult {\n-        defs,\n-        resolutions,\n-        mut hir_forest,\n-        ..\n-    } = {\n-        driver::phase_2_configure_and_expand(\n-            &sess,\n-            &cstore,\n-            krate,\n-            None,\n-            \"test\",\n-            None,\n-            |_| Ok(()),\n-        ).expect(\"phase 2 aborted\")\n-    };\n \n-    let mut arenas = ty::AllArenas::new();\n-    let hir_map = hir_map::map_crate(&sess, &cstore, &mut hir_forest, &defs);\n-\n-    // Run just enough stuff to build a tcx.\n-    let (tx, _rx) = mpsc::channel();\n-    let outputs = OutputFilenames {\n-        out_directory: PathBuf::new(),\n-        out_filestem: String::new(),\n-        single_output_file: None,\n-        extra: String::new(),\n-        outputs: OutputTypes::new(&[]),\n+    let config = interface::Config {\n+        opts,\n+        crate_cfg: Default::default(),\n+        input,\n+        input_path: None,\n+        output_file: None,\n+        output_dir: None,\n+        file_loader: None,\n+        diagnostic_output: DiagnosticOutput::Emitter(emitter),\n+        stderr: None,\n+        crate_name: Some(\"test\".to_owned()),\n+        lint_caps: Default::default(),\n     };\n-    TyCtxt::create_and_enter(\n-        &sess,\n-        &cstore,\n-        ty::query::Providers::default(),\n-        ty::query::Providers::default(),\n-        &mut arenas,\n-        resolutions,\n-        hir_map,\n-        OnDiskCache::new_empty(sess.source_map()),\n-        \"test_crate\",\n-        tx,\n-        &outputs,\n-        |tcx| {\n+\n+    interface::run_compiler(config, |compiler| {\n+        compiler.global_ctxt().unwrap().peek_mut().enter(|tcx| {\n             tcx.infer_ctxt().enter(|infcx| {\n                 let mut region_scope_tree = region::ScopeTree::default();\n                 let param_env = ty::ParamEnv::empty();\n@@ -189,8 +133,8 @@ fn test_env_with_pool<F>(\n                 );\n                 assert_eq!(tcx.sess.err_count(), expected_err_count);\n             });\n-        },\n-    );\n+        })\n+    });\n }\n \n fn d1() -> ty::DebruijnIndex {"}, {"sha": "fe75bbc36c3b1eea28fdf0cd7d93ff8c9bea65c9", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -21,7 +21,7 @@ mod persist;\n \n pub use assert_dep_graph::assert_dep_graph;\n pub use persist::dep_graph_tcx_init;\n-pub use persist::load_dep_graph;\n+pub use persist::{DepGraphFuture, load_dep_graph};\n pub use persist::load_query_result_cache;\n pub use persist::LoadResult;\n pub use persist::copy_cgu_workproducts_to_incr_comp_cache_dir;"}, {"sha": "4295034692958a0bbc8c19720a2519ce4e0c8fcf", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -94,10 +94,10 @@ impl<T> MaybeAsync<T> {\n     }\n }\n \n+pub type DepGraphFuture = MaybeAsync<LoadResult<(PreviousDepGraph, WorkProductMap)>>;\n+\n /// Launch a thread and load the dependency graph in the background.\n-pub fn load_dep_graph(sess: &Session) ->\n-    MaybeAsync<LoadResult<(PreviousDepGraph, WorkProductMap)>>\n-{\n+pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n     // Since `sess` isn't `Sync`, we perform all accesses to `sess`\n     // before we fire the background thread.\n "}, {"sha": "bf404140f18d5c39af7c683c7cc5952c93f305aa", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -16,7 +16,7 @@ pub use fs::in_incr_comp_dir;\n pub use fs::in_incr_comp_dir_sess;\n pub use fs::prepare_session_directory;\n pub use load::dep_graph_tcx_init;\n-pub use load::load_dep_graph;\n+pub use load::{DepGraphFuture, load_dep_graph};\n pub use load::load_query_result_cache;\n pub use load::LoadResult;\n pub use save::save_dep_graph;"}, {"sha": "ec6b26afb8c50400718d2bc8bc0054b03b55d180", "filename": "src/librustc_interface/interface.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -0,0 +1,155 @@\n+use queries::Queries;\n+use rustc::lint;\n+use rustc::session::config::{self, Input};\n+use rustc::session::{DiagnosticOutput, Session};\n+use rustc::util::common::ErrorReported;\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+use rustc_data_structures::OnDrop;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_metadata::cstore::CStore;\n+use std::collections::HashSet;\n+use std::io::Write;\n+use std::path::PathBuf;\n+use std::result;\n+use std::sync::{Arc, Mutex};\n+use syntax;\n+use syntax::source_map::{FileLoader, SourceMap};\n+use util;\n+use profile;\n+\n+pub use passes::BoxedResolver;\n+\n+pub type Result<T> = result::Result<T, ErrorReported>;\n+\n+/// Represents a compiler session.\n+/// Can be used run `rustc_interface` queries.\n+/// Created by passing `Config` to `run_compiler`.\n+pub struct Compiler {\n+    pub(crate) sess: Lrc<Session>,\n+    codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n+    source_map: Lrc<SourceMap>,\n+    pub(crate) input: Input,\n+    pub(crate) input_path: Option<PathBuf>,\n+    pub(crate) output_dir: Option<PathBuf>,\n+    pub(crate) output_file: Option<PathBuf>,\n+    pub(crate) queries: Queries,\n+    pub(crate) cstore: Lrc<CStore>,\n+    pub(crate) crate_name: Option<String>,\n+}\n+\n+impl Compiler {\n+    pub fn session(&self) -> &Lrc<Session> {\n+        &self.sess\n+    }\n+    pub fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n+        &self.codegen_backend\n+    }\n+    pub fn cstore(&self) -> &Lrc<CStore> {\n+        &self.cstore\n+    }\n+    pub fn source_map(&self) -> &Lrc<SourceMap> {\n+        &self.source_map\n+    }\n+    pub fn input(&self) -> &Input {\n+        &self.input\n+    }\n+    pub fn output_dir(&self) -> &Option<PathBuf> {\n+        &self.output_dir\n+    }\n+    pub fn output_file(&self) -> &Option<PathBuf> {\n+        &self.output_file\n+    }\n+}\n+\n+/// The compiler configuration\n+pub struct Config {\n+    /// Command line options\n+    pub opts: config::Options,\n+\n+    /// cfg! configuration in addition to the default ones\n+    pub crate_cfg: FxHashSet<(String, Option<String>)>,\n+\n+    pub input: Input,\n+    pub input_path: Option<PathBuf>,\n+    pub output_dir: Option<PathBuf>,\n+    pub output_file: Option<PathBuf>,\n+    pub file_loader: Option<Box<dyn FileLoader + Send + Sync>>,\n+    pub diagnostic_output: DiagnosticOutput,\n+\n+    /// Set to capture stderr output during compiler execution\n+    pub stderr: Option<Arc<Mutex<Vec<u8>>>>,\n+\n+    pub crate_name: Option<String>,\n+    pub lint_caps: FxHashMap<lint::LintId, lint::Level>,\n+}\n+\n+pub fn run_compiler_in_existing_thread_pool<F, R>(config: Config, f: F) -> R\n+where\n+    F: FnOnce(&Compiler) -> R,\n+{\n+    let (sess, codegen_backend, source_map) = util::create_session(\n+        config.opts,\n+        config.crate_cfg,\n+        config.diagnostic_output,\n+        config.file_loader,\n+        config.input_path.clone(),\n+        config.lint_caps,\n+    );\n+\n+    let cstore = Lrc::new(CStore::new(codegen_backend.metadata_loader()));\n+\n+    let compiler = Compiler {\n+        sess,\n+        codegen_backend,\n+        source_map,\n+        cstore,\n+        input: config.input,\n+        input_path: config.input_path,\n+        output_dir: config.output_dir,\n+        output_file: config.output_file,\n+        queries: Default::default(),\n+        crate_name: config.crate_name,\n+    };\n+\n+    let _sess_abort_error = OnDrop(|| compiler.sess.diagnostic().print_error_count());\n+\n+    if compiler.sess.profile_queries() {\n+        profile::begin(&compiler.sess);\n+    }\n+\n+    let r = f(&compiler);\n+\n+    if compiler.sess.profile_queries() {\n+        profile::dump(&compiler.sess, \"profile_queries\".to_string())\n+    }\n+\n+    if compiler.sess.opts.debugging_opts.self_profile {\n+        compiler.sess.profiler(|p| p.dump_raw_events(&compiler.sess.opts));\n+    }\n+\n+    r\n+}\n+\n+pub fn run_compiler<F, R>(mut config: Config, f: F) -> R\n+where\n+    F: FnOnce(&Compiler) -> R + Send,\n+    R: Send,\n+{\n+    syntax::with_globals(move || {\n+        let stderr = config.stderr.take();\n+        util::spawn_thread_pool(\n+            config.opts.debugging_opts.threads,\n+            &stderr,\n+            || run_compiler_in_existing_thread_pool(config, f),\n+        )\n+    })\n+}\n+\n+pub fn default_thread_pool<F, R>(f: F) -> R\n+where\n+    F: FnOnce() -> R + Send,\n+    R: Send,\n+{\n+    util::spawn_thread_pool(None, &None, f)\n+}"}, {"sha": "6a931c249b5bff312563b4f79be32683bf90aa5d", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -3,6 +3,7 @@\n #![feature(nll)]\n #![feature(arbitrary_self_types)]\n #![feature(generator_trait)]\n+#![feature(generators)]\n #![cfg_attr(unix, feature(libc))]\n \n #![allow(unused_imports)]\n@@ -37,7 +38,11 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate syntax_ext;\n \n-pub mod passes;\n-pub mod profile;\n+pub mod interface;\n+mod passes;\n+mod queries;\n pub mod util;\n-pub mod proc_macro_decls;\n+mod proc_macro_decls;\n+mod profile;\n+\n+pub use interface::{run_compiler, Config};"}, {"sha": "d61ccd5605b60a276b3c14ee826bfd9e13dc7851", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 744, "deletions": 12, "changes": 756, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -1,3 +1,4 @@\n+use interface::{Compiler, Result};\n use util;\n use proc_macro_decls;\n \n@@ -8,7 +9,7 @@ use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::lint;\n use rustc::middle::{self, reachable, resolve_lifetime, stability};\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, AllArenas, Resolutions, TyCtxt};\n+use rustc::ty::{self, AllArenas, Resolutions, TyCtxt, GlobalCtxt};\n use rustc::ty::steal::Steal;\n use rustc::traits;\n use rustc::util::common::{time, ErrorReported};\n@@ -23,6 +24,7 @@ use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n use rustc_incremental;\n+use rustc_incremental::DepGraphFuture;\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n use rustc_mir as mir;\n@@ -35,12 +37,13 @@ use rustc_traits;\n use rustc_typeck as typeck;\n use syntax::{self, ast, attr, diagnostics, visit};\n use syntax::early_buffered_lints::BufferedEarlyLint;\n-use syntax::ext::base::ExtCtxt;\n+use syntax::ext::base::{NamedSyntaxExtension, ExtCtxt};\n use syntax::mut_visit::MutVisitor;\n use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::symbol::Symbol;\n+use syntax::feature_gate::AttributeType;\n use syntax_pos::{FileName, hygiene};\n use syntax_ext;\n \n@@ -59,8 +62,524 @@ use std::rc::Rc;\n use std::mem;\n use std::ops::Generator;\n \n-/// Returns all the paths that correspond to generated files.\n-pub fn generated_output_paths(\n+pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n+    sess.diagnostic()\n+        .set_continue_after_error(sess.opts.debugging_opts.continue_parse_after_error);\n+    hygiene::set_default_edition(sess.edition());\n+\n+    sess.profiler(|p| p.start_activity(ProfileCategory::Parsing));\n+    let krate = time(sess, \"parsing\", || match *input {\n+        Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n+        Input::Str {\n+            ref input,\n+            ref name,\n+        } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n+    })?;\n+    sess.profiler(|p| p.end_activity(ProfileCategory::Parsing));\n+\n+    sess.diagnostic().set_continue_after_error(true);\n+\n+    if sess.opts.debugging_opts.ast_json_noexpand {\n+        println!(\"{}\", json::as_json(&krate));\n+    }\n+\n+    if sess.opts.debugging_opts.input_stats {\n+        println!(\n+            \"Lines of code:             {}\",\n+            sess.source_map().count_lines()\n+        );\n+        println!(\"Pre-expansion node count:  {}\", count_nodes(&krate));\n+    }\n+\n+    if let Some(ref s) = sess.opts.debugging_opts.show_span {\n+        syntax::show_span::run(sess.diagnostic(), s, &krate);\n+    }\n+\n+    if sess.opts.debugging_opts.hir_stats {\n+        hir_stats::print_ast_stats(&krate, \"PRE EXPANSION AST STATS\");\n+    }\n+\n+    Ok(krate)\n+}\n+\n+fn count_nodes(krate: &ast::Crate) -> usize {\n+    let mut counter = NodeCounter::new();\n+    visit::walk_crate(&mut counter, krate);\n+    counter.count\n+}\n+\n+declare_box_region_type!(\n+    pub BoxedResolver,\n+    for(),\n+    (&mut Resolver<'_>) -> (Result<ast::Crate>, ExpansionResult)\n+);\n+\n+/// Runs the \"early phases\" of the compiler: initial `cfg` processing,\n+/// loading compiler plugins (including those from `addl_plugins`),\n+/// syntax expansion, secondary `cfg` expansion, synthesis of a test\n+/// harness if one is to be provided, injection of a dependency on the\n+/// standard library and prelude, and name resolution.\n+///\n+/// Returns `None` if we're aborting after handling -W help.\n+pub fn configure_and_expand(\n+    sess: Lrc<Session>,\n+    cstore: Lrc<CStore>,\n+    krate: ast::Crate,\n+    crate_name: &str,\n+    plugin_info: PluginInfo,\n+) -> Result<(ast::Crate, BoxedResolver)> {\n+    // Currently, we ignore the name resolution data structures for the purposes of dependency\n+    // tracking. Instead we will run name resolution and include its output in the hash of each\n+    // item, much like we do for macro expansion. In other words, the hash reflects not just\n+    // its contents but the results of name resolution on those contents. Hopefully we'll push\n+    // this back at some point.\n+    let crate_name = crate_name.to_string();\n+    let (result, resolver) = BoxedResolver::new(static move || {\n+        let sess = &*sess;\n+        let mut crate_loader = CrateLoader::new(sess, &*cstore, &crate_name);\n+        let resolver_arenas = Resolver::arenas();\n+        let res = configure_and_expand_inner(\n+            sess,\n+            &*cstore,\n+            krate,\n+            &crate_name,\n+            &resolver_arenas,\n+            &mut crate_loader,\n+            plugin_info,\n+        );\n+        let mut resolver = match res {\n+            Err(v) => {\n+                yield BoxedResolver::initial_yield(Err(v));\n+                panic!()\n+            }\n+            Ok((krate, resolver)) => {\n+                yield BoxedResolver::initial_yield(Ok(krate));\n+                resolver\n+            }\n+        };\n+        box_region_allow_access!(for(), (&mut Resolver<'_>), (&mut resolver));\n+        ExpansionResult::from_owned_resolver(resolver)\n+    });\n+    result.map(|k| (k, resolver))\n+}\n+\n+pub struct ExpansionResult {\n+    pub defs: Steal<hir::map::Definitions>,\n+    pub resolutions: Steal<Resolutions>,\n+}\n+\n+impl ExpansionResult {\n+    fn from_owned_resolver(\n+        resolver: Resolver<'_>,\n+    ) -> Self {\n+        ExpansionResult {\n+            defs: Steal::new(resolver.definitions),\n+            resolutions: Steal::new(Resolutions {\n+                freevars: resolver.freevars,\n+                export_map: resolver.export_map,\n+                trait_map: resolver.trait_map,\n+                glob_map: resolver.glob_map,\n+                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n+                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates,\n+                extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n+                    (ident.name, entry.introduced_by_item)\n+                }).collect(),\n+            }),\n+        }\n+    }\n+\n+    pub fn from_resolver_ref(\n+        resolver: &Resolver<'_>,\n+    ) -> Self {\n+        ExpansionResult {\n+            defs: Steal::new(resolver.definitions.clone()),\n+            resolutions: Steal::new(Resolutions {\n+                freevars: resolver.freevars.clone(),\n+                export_map: resolver.export_map.clone(),\n+                trait_map: resolver.trait_map.clone(),\n+                glob_map: resolver.glob_map.clone(),\n+                maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n+                maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n+                extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n+                    (ident.name, entry.introduced_by_item)\n+                }).collect(),\n+            }),\n+        }\n+    }\n+}\n+\n+impl BoxedResolver {\n+    pub fn to_expansion_result(\n+        mut resolver: Rc<Option<RefCell<BoxedResolver>>>,\n+    ) -> ExpansionResult {\n+        if let Some(resolver) = Rc::get_mut(&mut resolver) {\n+            mem::replace(resolver, None).unwrap().into_inner().complete()\n+        } else {\n+            let resolver = &*resolver;\n+            resolver.as_ref().unwrap().borrow_mut().access(|resolver| {\n+                ExpansionResult::from_resolver_ref(resolver)\n+            })\n+        }\n+    }\n+}\n+\n+pub struct PluginInfo {\n+    syntax_exts: Vec<NamedSyntaxExtension>,\n+    attributes: Vec<(String, AttributeType)>,\n+}\n+\n+pub fn register_plugins<'a>(\n+    compiler: &Compiler,\n+    sess: &'a Session,\n+    cstore: &'a CStore,\n+    mut krate: ast::Crate,\n+    crate_name: &str,\n+) -> Result<(ast::Crate, PluginInfo)> {\n+    krate = time(sess, \"attributes injection\", || {\n+        syntax::attr::inject(krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr)\n+    });\n+\n+    let (mut krate, features) = syntax::config::features(\n+        krate,\n+        &sess.parse_sess,\n+        sess.edition(),\n+    );\n+    // these need to be set \"early\" so that expansion sees `quote` if enabled.\n+    sess.init_features(features);\n+\n+    let crate_types = util::collect_crate_types(sess, &krate.attrs);\n+    sess.crate_types.set(crate_types);\n+\n+    let disambiguator = util::compute_crate_disambiguator(sess);\n+    sess.crate_disambiguator.set(disambiguator);\n+    rustc_incremental::prepare_session_directory(sess, &crate_name, disambiguator);\n+\n+    if sess.opts.incremental.is_some() {\n+        time(sess, \"garbage collect incremental cache directory\", || {\n+            if let Err(e) = rustc_incremental::garbage_collect_session_directories(sess) {\n+                warn!(\n+                    \"Error while trying to garbage collect incremental \\\n+                     compilation cache directory: {}\",\n+                    e\n+                );\n+            }\n+        });\n+    }\n+\n+    // If necessary, compute the dependency graph (in the background).\n+    compiler.dep_graph_future().ok();\n+\n+    time(sess, \"recursion limit\", || {\n+        middle::recursion_limit::update_limits(sess, &krate);\n+    });\n+\n+    krate = time(sess, \"crate injection\", || {\n+        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n+        syntax::std_inject::maybe_inject_crates_ref(krate, alt_std_name, sess.edition())\n+    });\n+\n+    let registrars = time(sess, \"plugin loading\", || {\n+        plugin::load::load_plugins(\n+            sess,\n+            &cstore,\n+            &krate,\n+            crate_name,\n+            Some(sess.opts.debugging_opts.extra_plugins.clone()),\n+        )\n+    });\n+\n+    let mut registry = Registry::new(sess, krate.span);\n+\n+    time(sess, \"plugin registration\", || {\n+        if sess.features_untracked().rustc_diagnostic_macros {\n+            registry.register_macro(\n+                \"__diagnostic_used\",\n+                diagnostics::plugin::expand_diagnostic_used,\n+            );\n+            registry.register_macro(\n+                \"__register_diagnostic\",\n+                diagnostics::plugin::expand_register_diagnostic,\n+            );\n+            registry.register_macro(\n+                \"__build_diagnostic_array\",\n+                diagnostics::plugin::expand_build_diagnostic_array,\n+            );\n+        }\n+\n+        for registrar in registrars {\n+            registry.args_hidden = Some(registrar.args);\n+            (registrar.fun)(&mut registry);\n+        }\n+    });\n+\n+    let Registry {\n+        syntax_exts,\n+        early_lint_passes,\n+        late_lint_passes,\n+        lint_groups,\n+        llvm_passes,\n+        attributes,\n+        ..\n+    } = registry;\n+\n+    sess.track_errors(|| {\n+        let mut ls = sess.lint_store.borrow_mut();\n+        for pass in early_lint_passes {\n+            ls.register_early_pass(Some(sess), true, false, pass);\n+        }\n+        for pass in late_lint_passes {\n+            ls.register_late_pass(Some(sess), true, pass);\n+        }\n+\n+        for (name, (to, deprecated_name)) in lint_groups {\n+            ls.register_group(Some(sess), true, name, deprecated_name, to);\n+        }\n+\n+        *sess.plugin_llvm_passes.borrow_mut() = llvm_passes;\n+        *sess.plugin_attributes.borrow_mut() = attributes.clone();\n+    })?;\n+\n+    Ok((krate, PluginInfo {\n+        syntax_exts,\n+        attributes,\n+    }))\n+}\n+\n+fn configure_and_expand_inner<'a>(\n+    sess: &'a Session,\n+    cstore: &'a CStore,\n+    mut krate: ast::Crate,\n+    crate_name: &str,\n+    resolver_arenas: &'a ResolverArenas<'a>,\n+    crate_loader: &'a mut CrateLoader<'a>,\n+    plugin_info: PluginInfo,\n+) -> Result<(ast::Crate, Resolver<'a>)> {\n+    let attributes = plugin_info.attributes;\n+    time(sess, \"pre ast expansion lint checks\", || {\n+        lint::check_ast_crate(\n+            sess,\n+            &krate,\n+            true,\n+            rustc_lint::BuiltinCombinedPreExpansionLintPass::new());\n+    });\n+\n+    let mut resolver = Resolver::new(\n+        sess,\n+        cstore,\n+        &krate,\n+        crate_name,\n+        crate_loader,\n+        &resolver_arenas,\n+    );\n+    syntax_ext::register_builtins(&mut resolver, plugin_info.syntax_exts);\n+\n+    // Expand all macros\n+    sess.profiler(|p| p.start_activity(ProfileCategory::Expansion));\n+    krate = time(sess, \"expansion\", || {\n+        // Windows dlls do not have rpaths, so they don't know how to find their\n+        // dependencies. It's up to us to tell the system where to find all the\n+        // dependent dlls. Note that this uses cfg!(windows) as opposed to\n+        // targ_cfg because syntax extensions are always loaded for the host\n+        // compiler, not for the target.\n+        //\n+        // This is somewhat of an inherently racy operation, however, as\n+        // multiple threads calling this function could possibly continue\n+        // extending PATH far beyond what it should. To solve this for now we\n+        // just don't add any new elements to PATH which are already there\n+        // within PATH. This is basically a targeted fix at #17360 for rustdoc\n+        // which runs rustc in parallel but has been seen (#33844) to cause\n+        // problems with PATH becoming too long.\n+        let mut old_path = OsString::new();\n+        if cfg!(windows) {\n+            old_path = env::var_os(\"PATH\").unwrap_or(old_path);\n+            let mut new_path = sess.host_filesearch(PathKind::All).search_path_dirs();\n+            for path in env::split_paths(&old_path) {\n+                if !new_path.contains(&path) {\n+                    new_path.push(path);\n+                }\n+            }\n+            env::set_var(\n+                \"PATH\",\n+                &env::join_paths(\n+                    new_path\n+                        .iter()\n+                        .filter(|p| env::join_paths(iter::once(p)).is_ok()),\n+                ).unwrap(),\n+            );\n+        }\n+\n+        // Create the config for macro expansion\n+        let features = sess.features_untracked();\n+        let cfg = syntax::ext::expand::ExpansionConfig {\n+            features: Some(&features),\n+            recursion_limit: *sess.recursion_limit.get(),\n+            trace_mac: sess.opts.debugging_opts.trace_macros,\n+            should_test: sess.opts.test,\n+            ..syntax::ext::expand::ExpansionConfig::default(crate_name.to_string())\n+        };\n+\n+        let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n+\n+        // Expand macros now!\n+        let krate = time(sess, \"expand crate\", || {\n+            ecx.monotonic_expander().expand_crate(krate)\n+        });\n+\n+        // The rest is error reporting\n+\n+        time(sess, \"check unused macros\", || {\n+            ecx.check_unused_macros();\n+        });\n+\n+        let mut missing_fragment_specifiers: Vec<_> = ecx.parse_sess\n+            .missing_fragment_specifiers\n+            .borrow()\n+            .iter()\n+            .cloned()\n+            .collect();\n+        missing_fragment_specifiers.sort();\n+\n+        for span in missing_fragment_specifiers {\n+            let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n+            let msg = \"missing fragment specifier\";\n+            sess.buffer_lint(lint, ast::CRATE_NODE_ID, span, msg);\n+        }\n+        if cfg!(windows) {\n+            env::set_var(\"PATH\", &old_path);\n+        }\n+        krate\n+    });\n+    sess.profiler(|p| p.end_activity(ProfileCategory::Expansion));\n+\n+    time(sess, \"maybe building test harness\", || {\n+        syntax::test::modify_for_testing(\n+            &sess.parse_sess,\n+            &mut resolver,\n+            sess.opts.test,\n+            &mut krate,\n+            sess.diagnostic(),\n+            &sess.features_untracked(),\n+        )\n+    });\n+\n+    // If we're actually rustdoc then there's no need to actually compile\n+    // anything, so switch everything to just looping\n+    if sess.opts.actually_rustdoc {\n+        util::ReplaceBodyWithLoop::new(sess).visit_crate(&mut krate);\n+    }\n+\n+    let (has_proc_macro_decls, has_global_allocator) = time(sess, \"AST validation\", || {\n+        ast_validation::check_crate(sess, &krate)\n+    });\n+\n+    // If we're in rustdoc we're always compiling as an rlib, but that'll trip a\n+    // bunch of checks in the `modify` function below. For now just skip this\n+    // step entirely if we're rustdoc as it's not too useful anyway.\n+    if !sess.opts.actually_rustdoc {\n+        krate = time(sess, \"maybe creating a macro crate\", || {\n+            let crate_types = sess.crate_types.borrow();\n+            let num_crate_types = crate_types.len();\n+            let is_proc_macro_crate = crate_types.contains(&config::CrateType::ProcMacro);\n+            let is_test_crate = sess.opts.test;\n+            syntax_ext::proc_macro_decls::modify(\n+                &sess.parse_sess,\n+                &mut resolver,\n+                krate,\n+                is_proc_macro_crate,\n+                has_proc_macro_decls,\n+                is_test_crate,\n+                num_crate_types,\n+                sess.diagnostic(),\n+            )\n+        });\n+    }\n+\n+    if has_global_allocator {\n+        // Expand global allocators, which are treated as an in-tree proc macro\n+        time(sess, \"creating allocators\", || {\n+            allocator::expand::modify(\n+                &sess.parse_sess,\n+                &mut resolver,\n+                &mut krate,\n+                crate_name.to_string(),\n+                sess.diagnostic(),\n+            )\n+        });\n+    }\n+\n+    // Done with macro expansion!\n+\n+    if sess.opts.debugging_opts.input_stats {\n+        println!(\"Post-expansion node count: {}\", count_nodes(&krate));\n+    }\n+\n+    if sess.opts.debugging_opts.hir_stats {\n+        hir_stats::print_ast_stats(&krate, \"POST EXPANSION AST STATS\");\n+    }\n+\n+    if sess.opts.debugging_opts.ast_json {\n+        println!(\"{}\", json::as_json(&krate));\n+    }\n+\n+    time(sess, \"name resolution\", || {\n+        resolver.resolve_crate(&krate);\n+    });\n+\n+    // Needs to go *after* expansion to be able to check the results of macro expansion.\n+    time(sess, \"complete gated feature checking\", || {\n+        syntax::feature_gate::check_crate(\n+            &krate,\n+            &sess.parse_sess,\n+            &sess.features_untracked(),\n+            &attributes,\n+            sess.opts.unstable_features,\n+        );\n+    });\n+\n+    // Add all buffered lints from the `ParseSess` to the `Session`.\n+    sess.parse_sess.buffered_lints.with_lock(|buffered_lints| {\n+        info!(\"{} parse sess buffered_lints\", buffered_lints.len());\n+        for BufferedEarlyLint{id, span, msg, lint_id} in buffered_lints.drain(..) {\n+            let lint = lint::Lint::from_parser_lint_id(lint_id);\n+            sess.buffer_lint(lint, id, span, &msg);\n+        }\n+    });\n+\n+    Ok((krate, resolver))\n+}\n+\n+pub fn lower_to_hir(\n+    sess: &Session,\n+    cstore: &CStore,\n+    resolver: &mut Resolver<'_>,\n+    dep_graph: &DepGraph,\n+    krate: &ast::Crate,\n+) -> Result<hir::map::Forest> {\n+    // Lower ast -> hir\n+    let hir_forest = time(sess, \"lowering ast -> hir\", || {\n+        let hir_crate = lower_crate(sess, cstore, &dep_graph, &krate, resolver);\n+\n+        if sess.opts.debugging_opts.hir_stats {\n+            hir_stats::print_hir_stats(&hir_crate);\n+        }\n+\n+        hir::map::Forest::new(hir_crate, &dep_graph)\n+    });\n+\n+    time(sess, \"early lint checks\", || {\n+        lint::check_ast_crate(sess, &krate, false, rustc_lint::BuiltinCombinedEarlyLintPass::new())\n+    });\n+\n+    // Discard hygiene data, which isn't required after lowering to HIR.\n+    if !sess.opts.debugging_opts.keep_hygiene_data {\n+        syntax::ext::hygiene::clear_markings();\n+    }\n+\n+    Ok(hir_forest)\n+}\n+\n+// Returns all the paths that correspond to generated files.\n+fn generated_output_paths(\n     sess: &Session,\n     outputs: &OutputFilenames,\n     exact_name: bool,\n@@ -106,7 +625,7 @@ where\n     None\n }\n \n-pub fn output_contains_path(output_paths: &[PathBuf], input_path: &PathBuf) -> bool {\n+fn output_contains_path(output_paths: &[PathBuf], input_path: &PathBuf) -> bool {\n     let input_path = input_path.canonicalize().ok();\n     if input_path.is_none() {\n         return false;\n@@ -121,7 +640,7 @@ pub fn output_contains_path(output_paths: &[PathBuf], input_path: &PathBuf) -> b\n     check_output(output_paths, check).is_some()\n }\n \n-pub fn output_conflicts_with_dir(output_paths: &[PathBuf]) -> Option<PathBuf> {\n+fn output_conflicts_with_dir(output_paths: &[PathBuf]) -> Option<PathBuf> {\n     let check = |output_path: &PathBuf| {\n         if output_path.is_dir() {\n             Some(output_path.clone())\n@@ -138,7 +657,7 @@ fn escape_dep_filename(filename: &FileName) -> String {\n     filename.to_string().replace(\" \", \"\\\\ \")\n }\n \n-pub fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[PathBuf]) {\n+fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[PathBuf]) {\n     // Write out dependency rules to the dep-info file if requested\n     if !sess.opts.output_types.contains_key(&OutputType::DepInfo) {\n         return;\n@@ -178,15 +697,192 @@ pub fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames:\n     }\n }\n \n-pub fn provide(providers: &mut ty::query::Providers) {\n+pub fn prepare_outputs(\n+    sess: &Session,\n+    compiler: &Compiler,\n+    krate: &ast::Crate,\n+    crate_name: &str\n+) -> Result<OutputFilenames> {\n+    // FIXME: rustdoc passes &[] instead of &krate.attrs here\n+    let outputs = util::build_output_filenames(\n+        &compiler.input,\n+        &compiler.output_dir,\n+        &compiler.output_file,\n+        &krate.attrs,\n+        sess\n+    );\n+\n+    let output_paths = generated_output_paths(\n+        sess,\n+        &outputs,\n+        compiler.output_file.is_some(),\n+        &crate_name,\n+    );\n+\n+    // Ensure the source file isn't accidentally overwritten during compilation.\n+    if let Some(ref input_path) = compiler.input_path {\n+        if sess.opts.will_create_output_file() {\n+            if output_contains_path(&output_paths, input_path) {\n+                sess.err(&format!(\n+                    \"the input file \\\"{}\\\" would be overwritten by the generated \\\n+                        executable\",\n+                    input_path.display()\n+                ));\n+                return Err(ErrorReported);\n+            }\n+            if let Some(dir_path) = output_conflicts_with_dir(&output_paths) {\n+                sess.err(&format!(\n+                    \"the generated executable for the input file \\\"{}\\\" conflicts with the \\\n+                        existing directory \\\"{}\\\"\",\n+                    input_path.display(),\n+                    dir_path.display()\n+                ));\n+                return Err(ErrorReported);\n+            }\n+        }\n+    }\n+\n+    write_out_deps(sess, &outputs, &output_paths);\n+\n+    let only_dep_info = sess.opts.output_types.contains_key(&OutputType::DepInfo)\n+        && sess.opts.output_types.len() == 1;\n+\n+    if !only_dep_info {\n+        if let Some(ref dir) = compiler.output_dir {\n+            if fs::create_dir_all(dir).is_err() {\n+                sess.err(\"failed to find or create the directory specified by --out-dir\");\n+                return Err(ErrorReported);\n+            }\n+        }\n+    }\n+\n+    Ok(outputs)\n+}\n+\n+pub fn default_provide(providers: &mut ty::query::Providers) {\n     providers.analysis = analysis;\n     proc_macro_decls::provide(providers);\n+    plugin::build::provide(providers);\n+    hir::provide(providers);\n+    borrowck::provide(providers);\n+    mir::provide(providers);\n+    reachable::provide(providers);\n+    resolve_lifetime::provide(providers);\n+    rustc_privacy::provide(providers);\n+    typeck::provide(providers);\n+    ty::provide(providers);\n+    traits::provide(providers);\n+    stability::provide(providers);\n+    middle::intrinsicck::provide(providers);\n+    middle::liveness::provide(providers);\n+    reachable::provide(providers);\n+    rustc_passes::provide(providers);\n+    rustc_traits::provide(providers);\n+    middle::region::provide(providers);\n+    middle::entry::provide(providers);\n+    cstore::provide(providers);\n+    lint::provide(providers);\n+}\n+\n+pub fn default_provide_extern(providers: &mut ty::query::Providers) {\n+    cstore::provide_extern(providers);\n+}\n+\n+declare_box_region_type!(\n+    pub BoxedGlobalCtxt,\n+    for('gcx),\n+    (&'gcx GlobalCtxt<'gcx>) -> ((), ())\n+);\n+\n+impl BoxedGlobalCtxt {\n+    pub fn enter<F, R>(&mut self, f: F) -> R\n+    where\n+        F: for<'tcx> FnOnce(TyCtxt<'tcx, 'tcx, 'tcx>) -> R\n+    {\n+        self.access(|gcx| ty::tls::enter_global(gcx, |tcx| f(tcx)))\n+    }\n }\n \n+pub fn create_global_ctxt(\n+    compiler: &Compiler,\n+    mut hir_forest: hir::map::Forest,\n+    defs: hir::map::Definitions,\n+    resolutions: Resolutions,\n+    outputs: OutputFilenames,\n+    tx: mpsc::Sender<Box<dyn Any + Send>>,\n+    crate_name: &str\n+) -> BoxedGlobalCtxt {\n+    let sess = compiler.session().clone();\n+    let cstore = compiler.cstore.clone();\n+    let codegen_backend = compiler.codegen_backend().clone();\n+    let crate_name = crate_name.to_string();\n+\n+    let ((), result) = BoxedGlobalCtxt::new(static move || {\n+        let sess = &*sess;\n+        let cstore = &*cstore;\n+\n+        let global_ctxt: Option<GlobalCtxt<'_>>;\n+        let arenas = AllArenas::new();\n+\n+        // Construct the HIR map\n+        let hir_map = time(sess, \"indexing hir\", || {\n+            hir::map::map_crate(sess, cstore, &mut hir_forest, &defs)\n+        });\n+\n+        let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n+            rustc_incremental::load_query_result_cache(sess)\n+        });\n+\n+        let mut local_providers = ty::query::Providers::default();\n+        default_provide(&mut local_providers);\n+        codegen_backend.provide(&mut local_providers);\n+\n+        let mut extern_providers = local_providers;\n+        default_provide_extern(&mut extern_providers);\n+        codegen_backend.provide_extern(&mut extern_providers);\n+\n+        let gcx = TyCtxt::create_global_ctxt(\n+            sess,\n+            cstore,\n+            local_providers,\n+            extern_providers,\n+            &arenas,\n+            resolutions,\n+            hir_map,\n+            query_result_on_disk_cache,\n+            &crate_name,\n+            tx,\n+            &outputs\n+        );\n+\n+        global_ctxt = Some(gcx);\n+        let gcx = global_ctxt.as_ref().unwrap();\n+\n+        ty::tls::enter_global(gcx, |tcx| {\n+            // Do some initialization of the DepGraph that can only be done with the\n+            // tcx available.\n+            time(tcx.sess, \"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n+        });\n+\n+        yield BoxedGlobalCtxt::initial_yield(());\n+        box_region_allow_access!(for('gcx), (&'gcx GlobalCtxt<'gcx>), (gcx));\n+\n+        gcx.queries.record_computed_queries(sess);\n+\n+        if sess.opts.debugging_opts.query_stats {\n+            gcx.queries.print_stats();\n+        }\n+    });\n+\n+    result\n+}\n+\n+/// Runs the resolution, type-checking, region checking and other\n+/// miscellaneous analysis passes on the crate.\n fn analysis<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     cnum: CrateNum,\n-) -> Result<(), ErrorReported> {\n+) -> Result<()> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let sess = tcx.sess;\n@@ -249,9 +945,9 @@ fn analysis<'tcx>(\n         }\n     });\n \n-    time(sess,\n-            \"MIR borrow checking\",\n-            || tcx.par_body_owners(|def_id| { tcx.ensure().mir_borrowck(def_id); }));\n+    time(sess, \"MIR borrow checking\", || {\n+        tcx.par_body_owners(|def_id| tcx.ensure().mir_borrowck(def_id));\n+    });\n \n     time(sess, \"dumping chalk-like clauses\", || {\n         rustc_traits::lowering::dump_program_clauses(tcx);\n@@ -304,3 +1000,39 @@ fn analysis<'tcx>(\n \n     Ok(())\n }\n+\n+/// Runs the codegen backend, after which the AST and analysis can\n+/// be discarded.\n+pub fn start_codegen<'tcx>(\n+    codegen_backend: &dyn CodegenBackend,\n+    tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+    rx: mpsc::Receiver<Box<dyn Any + Send>>,\n+    outputs: &OutputFilenames,\n+) -> Box<dyn Any> {\n+    if log_enabled!(::log::Level::Info) {\n+        println!(\"Pre-codegen\");\n+        tcx.print_debug_stats();\n+    }\n+\n+    time(tcx.sess, \"resolving dependency formats\", || {\n+        ::rustc::middle::dependency_format::calculate(tcx)\n+    });\n+\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n+    let codegen = time(tcx.sess, \"codegen\", move || codegen_backend.codegen_crate(tcx, rx));\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n+\n+    if log_enabled!(::log::Level::Info) {\n+        println!(\"Post-codegen\");\n+        tcx.print_debug_stats();\n+    }\n+\n+    if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {\n+        if let Err(e) = mir::transform::dump_mir::emit_mir(tcx, outputs) {\n+            tcx.sess.err(&format!(\"could not emit MIR: {}\", e));\n+            tcx.sess.abort_if_errors();\n+        }\n+    }\n+\n+    codegen\n+}"}, {"sha": "57ced0464d9fa1fd51f4530ea0237a4464b58176", "filename": "src/librustc_interface/queries.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -0,0 +1,302 @@\n+use interface::{Compiler, Result};\n+use passes::{self, BoxedResolver, ExpansionResult, BoxedGlobalCtxt, PluginInfo};\n+use rustc_incremental::DepGraphFuture;\n+use rustc_data_structures::sync::Lrc;\n+use rustc::session::config::{Input, OutputFilenames, OutputType};\n+use rustc::session::Session;\n+use rustc::util::common::{time, ErrorReported};\n+use rustc::util::profiling::ProfileCategory;\n+use rustc::lint;\n+use rustc::hir;\n+use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::ty;\n+use rustc::ty::steal::Steal;\n+use rustc::dep_graph::DepGraph;\n+use rustc_passes::hir_stats;\n+use rustc_plugin::registry::Registry;\n+use serialize::json;\n+use std::cell::{Ref, RefMut, RefCell};\n+use std::ops::Deref;\n+use std::rc::Rc;\n+use std::sync::mpsc;\n+use std::any::Any;\n+use std::mem;\n+use syntax::parse::{self, PResult};\n+use syntax::util::node_count::NodeCounter;\n+use syntax::{self, ast, attr, diagnostics, visit};\n+use syntax_pos::hygiene;\n+\n+/// Represent the result of a query.\n+/// This result can be stolen with the `take` method and returned with the `give` method.\n+pub struct Query<T> {\n+    result: RefCell<Option<Result<T>>>,\n+}\n+\n+impl<T> Query<T> {\n+    fn compute<F: FnOnce() -> Result<T>>(&self, f: F) -> Result<&Query<T>> {\n+        let mut result = self.result.borrow_mut();\n+        if result.is_none() {\n+            *result = Some(f());\n+        }\n+        result.as_ref().unwrap().as_ref().map(|_| self).map_err(|err| *err)\n+    }\n+\n+    /// Takes ownership of the query result. Further attempts to take or peek the query\n+    /// result will panic unless it is returned by calling the `give` method.\n+    pub fn take(&self) -> T {\n+        self.result\n+            .borrow_mut()\n+            .take()\n+            .expect(\"missing query result\")\n+            .unwrap()\n+    }\n+\n+    /// Returns a stolen query result. Panics if there's already a result.\n+    pub fn give(&self, value: T) {\n+        let mut result = self.result.borrow_mut();\n+        assert!(result.is_none(), \"a result already exists\");\n+        *result = Some(Ok(value));\n+    }\n+\n+    /// Borrows the query result using the RefCell. Panics if the result is stolen.\n+    pub fn peek(&self) -> Ref<'_, T> {\n+        Ref::map(self.result.borrow(), |r| {\n+            r.as_ref().unwrap().as_ref().expect(\"missing query result\")\n+        })\n+    }\n+\n+    /// Mutably borrows the query result using the RefCell. Panics if the result is stolen.\n+    pub fn peek_mut(&self) -> RefMut<'_, T> {\n+        RefMut::map(self.result.borrow_mut(), |r| {\n+            r.as_mut().unwrap().as_mut().expect(\"missing query result\")\n+        })\n+    }\n+}\n+\n+impl<T> Default for Query<T> {\n+    fn default() -> Self {\n+        Query {\n+            result: RefCell::new(None),\n+        }\n+    }\n+}\n+\n+#[derive(Default)]\n+pub(crate) struct Queries {\n+    dep_graph_future: Query<Option<DepGraphFuture>>,\n+    parse: Query<ast::Crate>,\n+    crate_name: Query<String>,\n+    register_plugins: Query<(ast::Crate, PluginInfo)>,\n+    expansion: Query<(ast::Crate, Rc<Option<RefCell<BoxedResolver>>>)>,\n+    dep_graph: Query<DepGraph>,\n+    lower_to_hir: Query<(Steal<hir::map::Forest>, ExpansionResult)>,\n+    prepare_outputs: Query<OutputFilenames>,\n+    codegen_channel: Query<(Steal<mpsc::Sender<Box<dyn Any + Send>>>,\n+                            Steal<mpsc::Receiver<Box<dyn Any + Send>>>)>,\n+    global_ctxt: Query<BoxedGlobalCtxt>,\n+    ongoing_codegen: Query<Box<dyn Any>>,\n+    link: Query<()>,\n+}\n+\n+impl Compiler {\n+    pub fn dep_graph_future(&self) -> Result<&Query<Option<DepGraphFuture>>> {\n+        self.queries.dep_graph_future.compute(|| {\n+            Ok(if self.session().opts.build_dep_graph() {\n+                Some(rustc_incremental::load_dep_graph(self.session()))\n+            } else {\n+                None\n+            })\n+        })\n+    }\n+\n+    pub fn parse(&self) -> Result<&Query<ast::Crate>> {\n+        self.queries.parse.compute(|| {\n+            passes::parse(self.session(), &self.input).map_err(\n+                |mut parse_error| {\n+                    parse_error.emit();\n+                    ErrorReported\n+                },\n+            )\n+        })\n+    }\n+\n+    pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, PluginInfo)>> {\n+        self.queries.register_plugins.compute(|| {\n+            let crate_name = self.crate_name()?.peek().clone();\n+            let krate = self.parse()?.take();\n+\n+            passes::register_plugins(\n+                self,\n+                self.session(),\n+                self.cstore(),\n+                krate,\n+                &crate_name,\n+            )\n+        })\n+    }\n+\n+    pub fn crate_name(&self) -> Result<&Query<String>> {\n+        self.queries.crate_name.compute(|| {\n+            let parse_result = self.parse()?;\n+            let krate = parse_result.peek();\n+            let result = match self.crate_name {\n+                Some(ref crate_name) => crate_name.clone(),\n+                None => rustc_codegen_utils::link::find_crate_name(\n+                    Some(self.session()),\n+                    &krate.attrs,\n+                    &self.input\n+                ),\n+            };\n+            Ok(result)\n+        })\n+    }\n+\n+    pub fn expansion(\n+        &self\n+    ) -> Result<&Query<(ast::Crate, Rc<Option<RefCell<BoxedResolver>>>)>> {\n+        self.queries.expansion.compute(|| {\n+            let crate_name = self.crate_name()?.peek().clone();\n+            let (krate, plugin_info) = self.register_plugins()?.take();\n+            passes::configure_and_expand(\n+                self.sess.clone(),\n+                self.cstore().clone(),\n+                krate,\n+                &crate_name,\n+                plugin_info,\n+            ).map(|(krate, resolver)| (krate, Rc::new(Some(RefCell::new(resolver)))))\n+        })\n+    }\n+\n+    pub fn dep_graph(&self) -> Result<&Query<DepGraph>> {\n+        self.queries.dep_graph.compute(|| {\n+            Ok(match self.dep_graph_future()?.take() {\n+                None => DepGraph::new_disabled(),\n+                Some(future) => {\n+                    let (prev_graph, prev_work_products) =\n+                        time(self.session(), \"blocked while dep-graph loading finishes\", || {\n+                            future.open().unwrap_or_else(|e| rustc_incremental::LoadResult::Error {\n+                                message: format!(\"could not decode incremental cache: {:?}\", e),\n+                            }).open(self.session())\n+                        });\n+                    DepGraph::new(prev_graph, prev_work_products)\n+                }\n+            })\n+        })\n+    }\n+\n+    pub fn lower_to_hir(&self) -> Result<&Query<(Steal<hir::map::Forest>, ExpansionResult)>> {\n+        self.queries.lower_to_hir.compute(|| {\n+            let expansion_result = self.expansion()?;\n+            let (krate, resolver) = expansion_result.take();\n+            let resolver_ref = &*resolver;\n+            let hir = Steal::new(resolver_ref.as_ref().unwrap().borrow_mut().access(|resolver| {\n+                passes::lower_to_hir(\n+                    self.session(),\n+                    self.cstore(),\n+                    resolver,\n+                    &*self.dep_graph()?.peek(),\n+                    &krate\n+                )\n+            })?);\n+            expansion_result.give((krate, Rc::new(None)));\n+            Ok((hir, BoxedResolver::to_expansion_result(resolver)))\n+        })\n+    }\n+\n+    pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n+        self.queries.prepare_outputs.compute(|| {\n+            self.lower_to_hir()?;\n+            let krate = self.expansion()?;\n+            let krate = krate.peek();\n+            let crate_name = self.crate_name()?;\n+            let crate_name = crate_name.peek();\n+            passes::prepare_outputs(self.session(), self, &krate.0, &*crate_name)\n+        })\n+    }\n+\n+    pub fn codegen_channel(&self) -> Result<&Query<(Steal<mpsc::Sender<Box<dyn Any + Send>>>,\n+                                                    Steal<mpsc::Receiver<Box<dyn Any + Send>>>)>> {\n+        self.queries.codegen_channel.compute(|| {\n+            let (tx, rx) = mpsc::channel();\n+            Ok((Steal::new(tx), Steal::new(rx)))\n+        })\n+    }\n+\n+    pub fn global_ctxt(&self) -> Result<&Query<BoxedGlobalCtxt>> {\n+        self.queries.global_ctxt.compute(|| {\n+            let crate_name = self.crate_name()?.peek().clone();\n+            let outputs = self.prepare_outputs()?.peek().clone();\n+            let hir = self.lower_to_hir()?;\n+            let hir = hir.peek();\n+            let (ref hir_forest, ref expansion) = *hir;\n+            let tx = self.codegen_channel()?.peek().0.steal();\n+            Ok(passes::create_global_ctxt(\n+                self,\n+                hir_forest.steal(),\n+                expansion.defs.steal(),\n+                expansion.resolutions.steal(),\n+                outputs,\n+                tx,\n+                &crate_name))\n+        })\n+    }\n+\n+    pub fn ongoing_codegen(&self) -> Result<&Query<Box<dyn Any>>> {\n+        self.queries.ongoing_codegen.compute(|| {\n+            let rx = self.codegen_channel()?.peek().1.steal();\n+            let outputs = self.prepare_outputs()?;\n+            self.global_ctxt()?.peek_mut().enter(|tcx| {\n+                tcx.analysis(LOCAL_CRATE).ok();\n+\n+                // Don't do code generation if there were any errors\n+                self.session().compile_status()?;\n+\n+                Ok(passes::start_codegen(\n+                    &***self.codegen_backend(),\n+                    tcx,\n+                    rx,\n+                    &*outputs.peek()\n+                ))\n+            })\n+        })\n+    }\n+\n+    pub fn link(&self) -> Result<&Query<()>> {\n+        self.queries.link.compute(|| {\n+            let sess = self.session();\n+\n+            let ongoing_codegen = self.ongoing_codegen()?.take();\n+\n+            self.codegen_backend().join_codegen_and_link(\n+                ongoing_codegen,\n+                sess,\n+                &*self.dep_graph()?.peek(),\n+                &*self.prepare_outputs()?.peek(),\n+            ).map_err(|_| ErrorReported)?;\n+\n+            Ok(())\n+        })\n+    }\n+\n+    pub fn compile(&self) -> Result<()> {\n+        self.prepare_outputs()?;\n+\n+        if self.session().opts.output_types.contains_key(&OutputType::DepInfo)\n+            && self.session().opts.output_types.len() == 1\n+        {\n+            return Ok(())\n+        }\n+\n+        self.global_ctxt()?;\n+\n+        // Drop AST after creating GlobalCtxt to free memory\n+        mem::drop(self.expansion()?.take());\n+\n+        self.ongoing_codegen()?;\n+\n+        // Drop GlobalCtxt after starting codegen to free memory\n+        mem::drop(self.global_ctxt()?.take());\n+\n+        self.link().map(|_| ())\n+    }\n+}"}, {"sha": "0f858d632060e7cc39e1e65c139f0698b3dd4326", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 158, "deletions": 1, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -4,6 +4,8 @@ use rustc::session::CrateDisambiguator;\n use rustc::ty;\n use rustc::lint;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n+#[cfg(parallel_compiler)]\n+use rustc_data_structures::jobserver;\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -79,6 +81,161 @@ pub fn add_configuration(\n     }\n }\n \n+pub fn create_session(\n+    sopts: config::Options,\n+    cfg: FxHashSet<(String, Option<String>)>,\n+    diagnostic_output: DiagnosticOutput,\n+    file_loader: Option<Box<dyn FileLoader + Send + Sync + 'static>>,\n+    input_path: Option<PathBuf>,\n+    lint_caps: FxHashMap<lint::LintId, lint::Level>,\n+) -> (Lrc<Session>, Lrc<Box<dyn CodegenBackend>>, Lrc<SourceMap>) {\n+    let descriptions = diagnostics_registry();\n+\n+    let loader = file_loader.unwrap_or(box RealFileLoader);\n+    let source_map = Lrc::new(SourceMap::with_file_loader(\n+        loader,\n+        sopts.file_path_mapping(),\n+    ));\n+    let mut sess = session::build_session_with_source_map(\n+        sopts,\n+        input_path,\n+        descriptions,\n+        source_map.clone(),\n+        diagnostic_output,\n+        lint_caps,\n+    );\n+\n+    let codegen_backend = get_codegen_backend(&sess);\n+\n+    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+\n+    let mut cfg = config::build_configuration(&sess, config::to_crate_config(cfg));\n+    add_configuration(&mut cfg, &sess, &*codegen_backend);\n+    sess.parse_sess.config = cfg;\n+\n+    (Lrc::new(sess), Lrc::new(codegen_backend), source_map)\n+}\n+\n+// Temporarily have stack size set to 32MB to deal with various crates with long method\n+// chains or deep syntax trees.\n+// FIXME(oli-obk): get https://github.com/rust-lang/rust/pull/55617 the finish line\n+const STACK_SIZE: usize = 32 * 1024 * 1024; // 32MB\n+\n+fn get_stack_size() -> Option<usize> {\n+    // FIXME: Hacks on hacks. If the env is trying to override the stack size\n+    // then *don't* set it explicitly.\n+    if env::var_os(\"RUST_MIN_STACK\").is_none() {\n+        Some(STACK_SIZE)\n+    } else {\n+        None\n+    }\n+}\n+\n+struct Sink(Arc<Mutex<Vec<u8>>>);\n+impl Write for Sink {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Write::write(&mut *self.0.lock().unwrap(), data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+pub fn scoped_thread<F: FnOnce() -> R + Send, R: Send>(cfg: thread::Builder, f: F) -> R {\n+    struct Ptr(*mut ());\n+    unsafe impl Send for Ptr {}\n+    unsafe impl Sync for Ptr {}\n+\n+    let mut f = Some(f);\n+    let run = Ptr(&mut f as *mut _ as *mut ());\n+    let mut result = None;\n+    let result_ptr = Ptr(&mut result as *mut _ as *mut ());\n+\n+    let thread = cfg.spawn(move || {\n+        let run = unsafe { (*(run.0 as *mut Option<F>)).take().unwrap() };\n+        let result = unsafe { &mut *(result_ptr.0 as *mut Option<R>) };\n+        *result = Some(run());\n+    });\n+\n+    match thread.unwrap().join() {\n+        Ok(()) => result.unwrap(),\n+        Err(p) => panic::resume_unwind(p),\n+    }\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n+    _threads: Option<usize>,\n+    stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n+    f: F,\n+) -> R {\n+    let mut cfg = thread::Builder::new().name(\"rustc\".to_string());\n+\n+    if let Some(size) = get_stack_size() {\n+        cfg = cfg.stack_size(size);\n+    }\n+\n+    scoped_thread(cfg, || {\n+        syntax::with_globals( || {\n+            ty::tls::GCX_PTR.set(&Lock::new(0), || {\n+                if let Some(stderr) = stderr {\n+                    io::set_panic(Some(box Sink(stderr.clone())));\n+                }\n+                ty::tls::with_thread_locals(|| f())\n+            })\n+        })\n+    })\n+}\n+\n+#[cfg(parallel_compiler)]\n+pub fn spawn_thread_pool<F: FnOnce() -> R + Send, R: Send>(\n+    threads: Option<usize>,\n+    stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n+    f: F,\n+) -> R {\n+    use rayon::{ThreadPool, ThreadPoolBuilder};\n+    use syntax;\n+    use syntax_pos;\n+\n+    let gcx_ptr = &Lock::new(0);\n+\n+    let mut config = ThreadPoolBuilder::new()\n+        .acquire_thread_handler(jobserver::acquire_thread)\n+        .release_thread_handler(jobserver::release_thread)\n+        .num_threads(Session::threads_from_count(threads))\n+        .deadlock_handler(|| unsafe { ty::query::handle_deadlock() });\n+\n+    if let Some(size) = get_stack_size() {\n+        config = config.stack_size(size);\n+    }\n+\n+    let with_pool = move |pool: &ThreadPool| pool.install(move || f());\n+\n+    syntax::with_globals(|| {\n+        syntax::GLOBALS.with(|syntax_globals| {\n+            syntax_pos::GLOBALS.with(|syntax_pos_globals| {\n+                // The main handler runs for each Rayon worker thread and sets up\n+                // the thread local rustc uses. syntax_globals and syntax_pos_globals are\n+                // captured and set on the new threads. ty::tls::with_thread_locals sets up\n+                // thread local callbacks from libsyntax\n+                let main_handler = move |worker: &mut dyn FnMut()| {\n+                    syntax::GLOBALS.set(syntax_globals, || {\n+                        syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n+                            if let Some(stderr) = stderr {\n+                                io::set_panic(Some(box Sink(stderr.clone())));\n+                            }\n+                            ty::tls::with_thread_locals(|| {\n+                                ty::tls::GCX_PTR.set(gcx_ptr, || worker())\n+                            })\n+                        })\n+                    })\n+                };\n+\n+                ThreadPool::scoped_pool(config, main_handler, with_pool).unwrap()\n+            })\n+        })\n+    })\n+}\n+\n fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n     let lib = DynamicLibrary::open(Some(path)).unwrap_or_else(|err| {\n         let err = format!(\"couldn't load codegen backend {:?}: {:?}\", path, err);\n@@ -297,7 +454,7 @@ pub fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend\n     }\n }\n \n-pub fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n+pub(crate) fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n     use std::hash::Hasher;\n \n     // The crate_disambiguator is a 128 bit hash. The disambiguator is fed"}, {"sha": "20fa6009b310b704a1300ca45f31825968ca172e", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -7,13 +7,13 @@ use self::def_ctor::{get_def_from_def_id, get_def_from_hir_id};\n \n use super::*;\n \n-pub struct AutoTraitFinder<'a, 'tcx: 'a, 'rcx: 'a> {\n-    pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n+pub struct AutoTraitFinder<'a, 'tcx> {\n+    pub cx: &'a core::DocContext<'tcx>,\n     pub f: auto::AutoTraitFinder<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n-    pub fn new(cx: &'a core::DocContext<'a, 'tcx, 'rcx>) -> Self {\n+impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n+    pub fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n         let f = auto::AutoTraitFinder::new(&cx.tcx);\n \n         AutoTraitFinder { cx, f }"}, {"sha": "aaae0bafd9e01c86a4f5ef87f758905a4e362184", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -11,12 +11,12 @@ use super::*;\n \n use self::def_ctor::{get_def_from_def_id, get_def_from_hir_id};\n \n-pub struct BlanketImplFinder<'a, 'tcx: 'a, 'rcx: 'a> {\n-    pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n+pub struct BlanketImplFinder<'a, 'tcx> {\n+    pub cx: &'a core::DocContext<'tcx>,\n }\n \n-impl<'a, 'tcx, 'rcx> BlanketImplFinder <'a, 'tcx, 'rcx> {\n-    pub fn new(cx: &'a core::DocContext<'a, 'tcx, 'rcx>) -> Self {\n+impl<'a, 'tcx> BlanketImplFinder<'a, 'tcx> {\n+    pub fn new(cx: &'a core::DocContext<'tcx>) -> Self {\n         BlanketImplFinder { cx }\n     }\n "}, {"sha": "405a2e66d6e5c21dbb4d48b212a0c4d17fe33f81", "filename": "src/librustdoc/clean/def_ctor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fdef_ctor.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -2,7 +2,7 @@ use crate::core::DocContext;\n \n use super::*;\n \n-pub fn get_def_from_def_id<F>(cx: &DocContext<'_, '_, '_>,\n+pub fn get_def_from_def_id<F>(cx: &DocContext<'_>,\n                               def_id: DefId,\n                               callback: &F,\n ) -> Vec<Item>\n@@ -38,7 +38,7 @@ where F: Fn(& dyn Fn(DefId) -> Def) -> Vec<Item> {\n     }\n }\n \n-pub fn get_def_from_hir_id<F>(cx: &DocContext<'_, '_, '_>,\n+pub fn get_def_from_hir_id<F>(cx: &DocContext<'_>,\n                               id: hir::HirId,\n                               name: String,\n                               callback: &F,"}, {"sha": "880f67281b9679bfe85e50d6f2e75706b2d26038", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -36,7 +36,7 @@ use super::Clean;\n /// The returned value is `None` if the definition could not be inlined,\n /// and `Some` of a vector of items if it was successfully expanded.\n pub fn try_inline(\n-    cx: &DocContext<'_, '_, '_>,\n+    cx: &DocContext<'_>,\n     def: Def,\n     name: ast::Name,\n     visited: &mut FxHashSet<DefId>\n@@ -129,7 +129,7 @@ pub fn try_inline(\n     Some(ret)\n }\n \n-pub fn try_inline_glob(cx: &DocContext<'_, '_, '_>, def: Def, visited: &mut FxHashSet<DefId>)\n+pub fn try_inline_glob(cx: &DocContext<'_>, def: Def, visited: &mut FxHashSet<DefId>)\n     -> Option<Vec<clean::Item>>\n {\n     if def == Def::Err { return None }\n@@ -146,15 +146,15 @@ pub fn try_inline_glob(cx: &DocContext<'_, '_, '_>, def: Def, visited: &mut FxHa\n     }\n }\n \n-pub fn load_attrs(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Attributes {\n+pub fn load_attrs(cx: &DocContext<'_>, did: DefId) -> clean::Attributes {\n     cx.tcx.get_attrs(did).clean(cx)\n }\n \n /// Record an external fully qualified name in the external_paths cache.\n ///\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n-pub fn record_extern_fqn(cx: &DocContext<'_, '_, '_>, did: DefId, kind: clean::TypeKind) {\n+pub fn record_extern_fqn(cx: &DocContext<'_>, did: DefId, kind: clean::TypeKind) {\n     let mut crate_name = cx.tcx.crate_name(did.krate).to_string();\n     if did.is_local() {\n         crate_name = cx.crate_name.clone().unwrap_or(crate_name);\n@@ -182,7 +182,7 @@ pub fn record_extern_fqn(cx: &DocContext<'_, '_, '_>, did: DefId, kind: clean::T\n     }\n }\n \n-pub fn build_external_trait(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Trait {\n+pub fn build_external_trait(cx: &DocContext<'_>, did: DefId) -> clean::Trait {\n     let auto_trait = cx.tcx.trait_def(did).has_auto_impl;\n     let trait_items = cx.tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n     let predicates = cx.tcx.predicates_of(did);\n@@ -202,7 +202,7 @@ pub fn build_external_trait(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::T\n     }\n }\n \n-fn build_external_function(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Function {\n+fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n     let constness = if cx.tcx.is_min_const_fn(did) {\n@@ -224,7 +224,7 @@ fn build_external_function(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Fu\n     }\n }\n \n-fn build_enum(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Enum {\n+fn build_enum(cx: &DocContext<'_>, did: DefId) -> clean::Enum {\n     let predicates = cx.tcx.predicates_of(did);\n \n     clean::Enum {\n@@ -234,7 +234,7 @@ fn build_enum(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Enum {\n     }\n }\n \n-fn build_struct(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Struct {\n+fn build_struct(cx: &DocContext<'_>, did: DefId) -> clean::Struct {\n     let predicates = cx.tcx.predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n@@ -250,7 +250,7 @@ fn build_struct(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Struct {\n     }\n }\n \n-fn build_union(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Union {\n+fn build_union(cx: &DocContext<'_>, did: DefId) -> clean::Union {\n     let predicates = cx.tcx.predicates_of(did);\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n@@ -262,7 +262,7 @@ fn build_union(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Union {\n     }\n }\n \n-fn build_type_alias(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Typedef {\n+fn build_type_alias(cx: &DocContext<'_>, did: DefId) -> clean::Typedef {\n     let predicates = cx.tcx.predicates_of(did);\n \n     clean::Typedef {\n@@ -271,7 +271,7 @@ fn build_type_alias(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Typedef {\n     }\n }\n \n-pub fn build_impls(cx: &DocContext<'_, '_, '_>, did: DefId) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext<'_>, did: DefId) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n     let mut impls = Vec::new();\n \n@@ -282,7 +282,7 @@ pub fn build_impls(cx: &DocContext<'_, '_, '_>, did: DefId) -> Vec<clean::Item>\n     impls\n }\n \n-pub fn build_impl(cx: &DocContext<'_, '_, '_>, did: DefId, ret: &mut Vec<clean::Item>) {\n+pub fn build_impl(cx: &DocContext<'_>, did: DefId, ret: &mut Vec<clean::Item>) {\n     if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n         return\n     }\n@@ -393,7 +393,7 @@ pub fn build_impl(cx: &DocContext<'_, '_, '_>, did: DefId, ret: &mut Vec<clean::\n }\n \n fn build_module(\n-    cx: &DocContext<'_, '_, '_>,\n+    cx: &DocContext<'_>,\n     did: DefId,\n     visited: &mut FxHashSet<DefId>\n ) -> clean::Module {\n@@ -404,7 +404,7 @@ fn build_module(\n         is_crate: false,\n     };\n \n-    fn fill_in(cx: &DocContext<'_, '_, '_>, did: DefId, items: &mut Vec<clean::Item>,\n+    fn fill_in(cx: &DocContext<'_>, did: DefId, items: &mut Vec<clean::Item>,\n                visited: &mut FxHashSet<DefId>) {\n         // If we're re-exporting a re-export it may actually re-export something in\n         // two namespaces, so the target may be listed twice. Make sure we only\n@@ -421,30 +421,30 @@ fn build_module(\n     }\n }\n \n-pub fn print_inlined_const(cx: &DocContext<'_, '_, '_>, did: DefId) -> String {\n+pub fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {\n     if let Some(node_id) = cx.tcx.hir().as_local_hir_id(did) {\n         cx.tcx.hir().hir_to_pretty_string(node_id)\n     } else {\n         cx.tcx.rendered_const(did)\n     }\n }\n \n-fn build_const(cx: &DocContext<'_, '_, '_>, did: DefId) -> clean::Constant {\n+fn build_const(cx: &DocContext<'_>, did: DefId) -> clean::Constant {\n     clean::Constant {\n         type_: cx.tcx.type_of(did).clean(cx),\n         expr: print_inlined_const(cx, did)\n     }\n }\n \n-fn build_static(cx: &DocContext<'_, '_, '_>, did: DefId, mutable: bool) -> clean::Static {\n+fn build_static(cx: &DocContext<'_>, did: DefId, mutable: bool) -> clean::Static {\n     clean::Static {\n         type_: cx.tcx.type_of(did).clean(cx),\n         mutability: if mutable {clean::Mutable} else {clean::Immutable},\n         expr: \"\\n\\n\\n\".to_string(), // trigger the \"[definition]\" links\n     }\n }\n \n-fn build_macro(cx: &DocContext<'_, '_, '_>, did: DefId, name: ast::Name) -> clean::ItemEnum {\n+fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemEnum {\n     let imported_from = cx.tcx.original_crate_name(did.krate);\n     match cx.cstore.load_macro_untracked(did, cx.sess()) {\n         LoadedMacro::MacroDef(def) => {\n@@ -546,7 +546,7 @@ fn separate_supertrait_bounds(mut g: clean::Generics)\n     (g, ty_bounds)\n }\n \n-pub fn record_extern_trait(cx: &DocContext<'_, '_, '_>, did: DefId) {\n+pub fn record_extern_trait(cx: &DocContext<'_>, did: DefId) {\n     if did.is_local() {\n         return;\n     }"}, {"sha": "f2bf7ead5619b22bccccc8030d5382e9e7a1342b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -71,56 +71,56 @@ thread_local!(pub static MAX_DEF_ID: RefCell<FxHashMap<CrateNum, DefId>> = Defau\n const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n // extract the stability index for a node from tcx, if possible\n-fn get_stability(cx: &DocContext<'_, '_, '_>, def_id: DefId) -> Option<Stability> {\n+fn get_stability(cx: &DocContext<'_>, def_id: DefId) -> Option<Stability> {\n     cx.tcx.lookup_stability(def_id).clean(cx)\n }\n \n-fn get_deprecation(cx: &DocContext<'_, '_, '_>, def_id: DefId) -> Option<Deprecation> {\n+fn get_deprecation(cx: &DocContext<'_>, def_id: DefId) -> Option<Deprecation> {\n     cx.tcx.lookup_deprecation(def_id).clean(cx)\n }\n \n pub trait Clean<T> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> T;\n+    fn clean(&self, cx: &DocContext<'_>) -> T;\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<U> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U, V: Idx> Clean<IndexVec<V, U>> for IndexVec<V, T> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> IndexVec<V, U> {\n+    fn clean(&self, cx: &DocContext<'_>) -> IndexVec<V, U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for P<T> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> U {\n+    fn clean(&self, cx: &DocContext<'_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> U {\n+    fn clean(&self, cx: &DocContext<'_>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<U> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Option<U> {\n         self.as_ref().map(|v| v.clean(cx))\n     }\n }\n \n impl<T, U> Clean<U> for ty::Binder<T> where T: Clean<U> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> U {\n+    fn clean(&self, cx: &DocContext<'_>) -> U {\n         self.skip_binder().clean(cx)\n     }\n }\n \n impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<U> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n@@ -139,8 +139,8 @@ pub struct Crate {\n     pub masked_crates: FxHashSet<CrateNum>,\n }\n \n-impl<'a, 'tcx, 'rcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx, 'rcx> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Crate {\n+impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Crate {\n         use crate::visit_lib::LibEmbargoVisitor;\n \n         {\n@@ -234,7 +234,7 @@ pub struct ExternalCrate {\n }\n \n impl Clean<ExternalCrate> for CrateNum {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> ExternalCrate {\n+    fn clean(&self, cx: &DocContext<'_>) -> ExternalCrate {\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         let krate_span = cx.tcx.def_span(root);\n         let krate_src = cx.sess().source_map().span_to_filename(krate_span);\n@@ -582,7 +582,7 @@ pub struct Module {\n }\n \n impl Clean<Item> for doctree::Module {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = if self.name.is_some() {\n             self.name.expect(\"No name provided\").clean(cx)\n         } else {\n@@ -1023,7 +1023,7 @@ impl AttributesExt for Attributes {\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Attributes {\n+    fn clean(&self, cx: &DocContext<'_>) -> Attributes {\n         Attributes::from_ast(cx.sess().diagnostic(), self)\n     }\n }\n@@ -1035,7 +1035,7 @@ pub enum GenericBound {\n }\n \n impl GenericBound {\n-    fn maybe_sized(cx: &DocContext<'_, '_, '_>) -> GenericBound {\n+    fn maybe_sized(cx: &DocContext<'_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n         let empty = cx.tcx.intern_substs(&[]);\n         let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n@@ -1052,7 +1052,7 @@ impl GenericBound {\n         }, hir::TraitBoundModifier::Maybe)\n     }\n \n-    fn is_sized_bound(&self, cx: &DocContext<'_, '_, '_>) -> bool {\n+    fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc::hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n             if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n@@ -1078,7 +1078,7 @@ impl GenericBound {\n }\n \n impl Clean<GenericBound> for hir::GenericBound {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericBound {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n             hir::GenericBound::Trait(ref t, modifier) => {\n@@ -1088,7 +1088,7 @@ impl Clean<GenericBound> for hir::GenericBound {\n     }\n }\n \n-fn external_generic_args(cx: &DocContext<'_, '_, '_>, trait_did: Option<DefId>, has_self: bool,\n+fn external_generic_args(cx: &DocContext<'_>, trait_did: Option<DefId>, has_self: bool,\n                         bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> GenericArgs {\n     let lifetimes = substs.regions().filter_map(|v| v.clean(cx)).collect();\n     let types = substs.types().skip(has_self as usize).collect::<Vec<_>>();\n@@ -1130,7 +1130,7 @@ fn external_generic_args(cx: &DocContext<'_, '_, '_>, trait_did: Option<DefId>,\n \n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n-fn external_path(cx: &DocContext<'_, '_, '_>, name: &str, trait_did: Option<DefId>, has_self: bool,\n+fn external_path(cx: &DocContext<'_>, name: &str, trait_did: Option<DefId>, has_self: bool,\n                  bindings: Vec<TypeBinding>, substs: SubstsRef<'_>) -> Path {\n     Path {\n         global: false,\n@@ -1143,7 +1143,7 @@ fn external_path(cx: &DocContext<'_, '_, '_>, name: &str, trait_did: Option<DefI\n }\n \n impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>) {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericBound {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         let (trait_ref, ref bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n         let path = external_path(cx, &cx.tcx.item_name(trait_ref.def_id).as_str(),\n@@ -1187,13 +1187,13 @@ impl<'a, 'tcx> Clean<GenericBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n }\n \n impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericBound {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericBound {\n         (self, vec![]).clean(cx)\n     }\n }\n \n impl<'tcx> Clean<Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<Vec<GenericBound>> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Option<Vec<GenericBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions().filter_map(|r| r.clean(cx)).map(GenericBound::Outlives));\n         v.extend(self.types().map(|t| GenericBound::TraitBound(PolyTrait {\n@@ -1220,7 +1220,7 @@ impl Lifetime {\n }\n \n impl Clean<Lifetime> for hir::Lifetime {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Lifetime {\n+    fn clean(&self, cx: &DocContext<'_>) -> Lifetime {\n         if self.hir_id != hir::DUMMY_HIR_ID {\n             let def = cx.tcx.named_region(self.hir_id);\n             match def {\n@@ -1239,7 +1239,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n }\n \n impl Clean<Lifetime> for hir::GenericParam {\n-    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Lifetime {\n+    fn clean(&self, _: &DocContext<'_>) -> Lifetime {\n         match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 if self.bounds.len() > 0 {\n@@ -1263,7 +1263,7 @@ impl Clean<Lifetime> for hir::GenericParam {\n }\n \n impl Clean<Constant> for hir::ConstArg {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Constant {\n+    fn clean(&self, cx: &DocContext<'_>) -> Constant {\n         Constant {\n             type_: cx.tcx.type_of(cx.tcx.hir().body_owner_def_id(self.value.body)).clean(cx),\n             expr: print_const_expr(cx, self.value.body),\n@@ -1272,13 +1272,13 @@ impl Clean<Constant> for hir::ConstArg {\n }\n \n impl<'tcx> Clean<Lifetime> for ty::GenericParamDef {\n-    fn clean(&self, _cx: &DocContext<'_, '_, '_>) -> Lifetime {\n+    fn clean(&self, _cx: &DocContext<'_>) -> Lifetime {\n         Lifetime(self.name.to_string())\n     }\n }\n \n impl Clean<Option<Lifetime>> for ty::RegionKind {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<Lifetime> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BrNamed(_, name)) => Some(Lifetime(name.to_string())),\n@@ -1307,7 +1307,7 @@ pub enum WherePredicate {\n }\n \n impl Clean<WherePredicate> for hir::WherePredicate {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n+    fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n         match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => {\n                 WherePredicate::BoundPredicate {\n@@ -1334,7 +1334,7 @@ impl Clean<WherePredicate> for hir::WherePredicate {\n }\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n         use rustc::ty::Predicate;\n \n         match *self {\n@@ -1353,7 +1353,7 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n }\n \n impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n+    fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n         WherePredicate::BoundPredicate {\n             ty: self.trait_ref.self_ty().clean(cx),\n             bounds: vec![self.trait_ref.clean(cx)]\n@@ -1362,7 +1362,7 @@ impl<'a> Clean<WherePredicate> for ty::TraitPredicate<'a> {\n }\n \n impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n-    fn clean(&self, _cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n+    fn clean(&self, _cx: &DocContext<'_>) -> WherePredicate {\n         panic!(\"subtype predicates are an internal rustc artifact \\\n                 and should not be seen by rustdoc\")\n     }\n@@ -1371,7 +1371,7 @@ impl<'tcx> Clean<WherePredicate> for ty::SubtypePredicate<'tcx> {\n impl<'tcx> Clean<Option<WherePredicate>> for\n     ty::OutlivesPredicate<ty::Region<'tcx>,ty::Region<'tcx>> {\n \n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n \n         match (a, b) {\n@@ -1389,7 +1389,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for\n }\n \n impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ref ty, ref lt) = *self;\n \n         match lt {\n@@ -1405,7 +1405,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n }\n \n impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> WherePredicate {\n+    fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n         WherePredicate::EqPredicate {\n             lhs: self.projection_ty.clean(cx),\n             rhs: self.ty.clean(cx)\n@@ -1414,7 +1414,7 @@ impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n }\n \n impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n+    fn clean(&self, cx: &DocContext<'_>) -> Type {\n         let trait_ = match self.trait_ref(cx.tcx).clean(cx) {\n             GenericBound::TraitBound(t, _) => t.trait_,\n             GenericBound::Outlives(_) => panic!(\"cleaning a trait got a lifetime\"),\n@@ -1462,7 +1462,7 @@ impl GenericParamDef {\n }\n \n impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericParamDef {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => {\n                 (self.name.to_string(), GenericParamDefKind::Lifetime)\n@@ -1495,7 +1495,7 @@ impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n }\n \n impl Clean<GenericParamDef> for hir::GenericParam {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericParamDef {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 let name = if self.bounds.len() > 0 {\n@@ -1545,7 +1545,7 @@ pub struct Generics {\n }\n \n impl Clean<Generics> for hir::Generics {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Generics {\n+    fn clean(&self, cx: &DocContext<'_>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n@@ -1615,7 +1615,7 @@ impl Clean<Generics> for hir::Generics {\n \n impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n                                     &'a Lrc<ty::GenericPredicates<'tcx>>) {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Generics {\n+    fn clean(&self, cx: &DocContext<'_>) -> Generics {\n         use self::WherePredicate as WP;\n \n         let (gens, preds) = *self;\n@@ -1702,7 +1702,7 @@ pub struct Method {\n }\n \n impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId) {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Method {\n+    fn clean(&self, cx: &DocContext<'_>) -> Method {\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx))\n         });\n@@ -1729,7 +1729,7 @@ pub struct Function {\n }\n \n impl Clean<Item> for doctree::Function {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.generics.clean(cx), (&self.decl, self.body).clean(cx))\n         });\n@@ -1800,7 +1800,7 @@ pub struct Arguments {\n }\n \n impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Arguments {\n+    fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n                 let mut name = self.1.get(i).map(|ident| ident.to_string())\n@@ -1818,7 +1818,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n }\n \n impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Arguments {\n+    fn clean(&self, cx: &DocContext<'_>) -> Arguments {\n         let body = cx.tcx.hir().body(self.1);\n \n         Arguments {\n@@ -1835,7 +1835,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n     where (&'a [hir::Ty], A): Clean<Arguments>\n {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FnDecl {\n+    fn clean(&self, cx: &DocContext<'_>) -> FnDecl {\n         FnDecl {\n             inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n@@ -1845,7 +1845,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n }\n \n impl<'a, 'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FnDecl {\n+    fn clean(&self, cx: &DocContext<'_>) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if cx.tcx.hir().as_local_hir_id(did).is_some() {\n             vec![].into_iter()\n@@ -1905,7 +1905,7 @@ pub enum FunctionRetTy {\n }\n \n impl Clean<FunctionRetTy> for hir::FunctionRetTy {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> FunctionRetTy {\n+    fn clean(&self, cx: &DocContext<'_>) -> FunctionRetTy {\n         match *self {\n             hir::Return(ref typ) => Return(typ.clean(cx)),\n             hir::DefaultReturn(..) => DefaultReturn,\n@@ -1934,7 +1934,7 @@ pub struct Trait {\n }\n \n impl Clean<Item> for doctree::Trait {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         let is_spotlight = attrs.has_doc_flag(\"spotlight\");\n         Item {\n@@ -1965,7 +1965,7 @@ pub struct TraitAlias {\n }\n \n impl Clean<Item> for doctree::TraitAlias {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let attrs = self.attrs.clean(cx);\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -1984,7 +1984,7 @@ impl Clean<Item> for doctree::TraitAlias {\n }\n \n impl Clean<bool> for hir::IsAuto {\n-    fn clean(&self, _: &DocContext<'_, '_, '_>) -> bool {\n+    fn clean(&self, _: &DocContext<'_>) -> bool {\n         match *self {\n             hir::IsAuto::Yes => true,\n             hir::IsAuto::No => false,\n@@ -1993,13 +1993,13 @@ impl Clean<bool> for hir::IsAuto {\n }\n \n impl Clean<Type> for hir::TraitRef {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n+    fn clean(&self, cx: &DocContext<'_>) -> Type {\n         resolve_type(cx, self.path.clean(cx), self.hir_ref_id)\n     }\n }\n \n impl Clean<PolyTrait> for hir::PolyTraitRef {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> PolyTrait {\n+    fn clean(&self, cx: &DocContext<'_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n             generic_params: self.bound_generic_params.clean(cx)\n@@ -2008,7 +2008,7 @@ impl Clean<PolyTrait> for hir::PolyTraitRef {\n }\n \n impl Clean<Item> for hir::TraitItem {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let inner = match self.node {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssociatedConstItem(ty.clean(cx),\n@@ -2046,7 +2046,7 @@ impl Clean<Item> for hir::TraitItem {\n }\n \n impl Clean<Item> for hir::ImplItem {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let inner = match self.node {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssociatedConstItem(ty.clean(cx),\n@@ -2079,7 +2079,7 @@ impl Clean<Item> for hir::ImplItem {\n }\n \n impl<'tcx> Clean<Item> for ty::AssociatedItem {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let inner = match self.kind {\n             ty::AssociatedKind::Const => {\n                 let ty = cx.tcx.type_of(self.def_id);\n@@ -2524,7 +2524,7 @@ impl From<ast::FloatTy> for PrimitiveType {\n }\n \n impl Clean<Type> for hir::Ty {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n+    fn clean(&self, cx: &DocContext<'_>) -> Type {\n         use rustc::hir::*;\n \n         match self.node {\n@@ -2726,7 +2726,7 @@ impl Clean<Type> for hir::Ty {\n }\n \n impl<'tcx> Clean<Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Type {\n+    fn clean(&self, cx: &DocContext<'_>) -> Type {\n         match self.sty {\n             ty::Never => Never,\n             ty::Bool => Primitive(PrimitiveType::Bool),\n@@ -2921,7 +2921,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n }\n \n impl Clean<Item> for hir::StructField {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let local_did = cx.tcx.hir().local_def_id_from_hir_id(self.hir_id);\n \n         Item {\n@@ -2938,7 +2938,7 @@ impl Clean<Item> for hir::StructField {\n }\n \n impl<'tcx> Clean<Item> for ty::FieldDef {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.ident.name).clean(cx),\n             attrs: cx.tcx.get_attrs(self.did).clean(cx),\n@@ -2961,7 +2961,7 @@ pub enum Visibility {\n }\n \n impl Clean<Option<Visibility>> for hir::Visibility {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Option<Visibility> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Option<Visibility> {\n         Some(match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n@@ -2976,7 +2976,7 @@ impl Clean<Option<Visibility>> for hir::Visibility {\n }\n \n impl Clean<Option<Visibility>> for ty::Visibility {\n-    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Option<Visibility> {\n+    fn clean(&self, _: &DocContext<'_>) -> Option<Visibility> {\n         Some(if *self == ty::Visibility::Public { Public } else { Inherited })\n     }\n }\n@@ -2998,7 +2998,7 @@ pub struct Union {\n }\n \n impl Clean<Item> for doctree::Struct {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3018,7 +3018,7 @@ impl Clean<Item> for doctree::Struct {\n }\n \n impl Clean<Item> for doctree::Union {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3048,7 +3048,7 @@ pub struct VariantStruct {\n }\n \n impl Clean<VariantStruct> for ::rustc::hir::VariantData {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> VariantStruct {\n+    fn clean(&self, cx: &DocContext<'_>) -> VariantStruct {\n         VariantStruct {\n             struct_type: doctree::struct_type_from_def(self),\n             fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n@@ -3065,7 +3065,7 @@ pub struct Enum {\n }\n \n impl Clean<Item> for doctree::Enum {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3089,7 +3089,7 @@ pub struct Variant {\n }\n \n impl Clean<Item> for doctree::Variant {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3106,7 +3106,7 @@ impl Clean<Item> for doctree::Variant {\n }\n \n impl<'tcx> Clean<Item> for ty::VariantDef {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => VariantKind::CLike,\n             CtorKind::Fn => {\n@@ -3154,7 +3154,7 @@ pub enum VariantKind {\n }\n \n impl Clean<VariantKind> for hir::VariantData {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> VariantKind {\n+    fn clean(&self, cx: &DocContext<'_>) -> VariantKind {\n         if self.is_struct() {\n             VariantKind::Struct(self.clean(cx))\n         } else if self.is_unit() {\n@@ -3185,7 +3185,7 @@ impl Span {\n }\n \n impl Clean<Span> for syntax_pos::Span {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Span {\n+    fn clean(&self, cx: &DocContext<'_>) -> Span {\n         if self.is_dummy() {\n             return Span::empty();\n         }\n@@ -3218,7 +3218,7 @@ impl Path {\n }\n \n impl Clean<Path> for hir::Path {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Path {\n+    fn clean(&self, cx: &DocContext<'_>) -> Path {\n         Path {\n             global: self.is_global(),\n             def: self.def,\n@@ -3241,7 +3241,7 @@ pub enum GenericArgs {\n }\n \n impl Clean<GenericArgs> for hir::GenericArgs {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> GenericArgs {\n+    fn clean(&self, cx: &DocContext<'_>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty.clean(cx);\n             GenericArgs::Parenthesized {\n@@ -3283,7 +3283,7 @@ pub struct PathSegment {\n }\n \n impl Clean<PathSegment> for hir::PathSegment {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> PathSegment {\n+    fn clean(&self, cx: &DocContext<'_>) -> PathSegment {\n         PathSegment {\n             name: self.ident.name.clean(cx),\n             args: self.with_generic_args(|generic_args| generic_args.clean(cx))\n@@ -3355,21 +3355,21 @@ fn qpath_to_string(p: &hir::QPath) -> String {\n \n impl Clean<String> for Ident {\n     #[inline]\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> String {\n+    fn clean(&self, cx: &DocContext<'_>) -> String {\n         self.name.clean(cx)\n     }\n }\n \n impl Clean<String> for ast::Name {\n     #[inline]\n-    fn clean(&self, _: &DocContext<'_, '_, '_>) -> String {\n+    fn clean(&self, _: &DocContext<'_>) -> String {\n         self.to_string()\n     }\n }\n \n impl Clean<String> for InternedString {\n     #[inline]\n-    fn clean(&self, _: &DocContext<'_, '_, '_>) -> String {\n+    fn clean(&self, _: &DocContext<'_>) -> String {\n         self.to_string()\n     }\n }\n@@ -3381,7 +3381,7 @@ pub struct Typedef {\n }\n \n impl Clean<Item> for doctree::Typedef {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3405,7 +3405,7 @@ pub struct Existential {\n }\n \n impl Clean<Item> for doctree::Existential {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3431,7 +3431,7 @@ pub struct BareFunctionDecl {\n }\n \n impl Clean<BareFunctionDecl> for hir::BareFnTy {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> BareFunctionDecl {\n+    fn clean(&self, cx: &DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n             (self.generic_params.clean(cx), (&*self.decl, &self.arg_names[..]).clean(cx))\n         });\n@@ -3455,7 +3455,7 @@ pub struct Static {\n }\n \n impl Clean<Item> for doctree::Static {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n         Item {\n             name: Some(self.name.clean(cx)),\n@@ -3481,7 +3481,7 @@ pub struct Constant {\n }\n \n impl Clean<Item> for doctree::Constant {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -3505,7 +3505,7 @@ pub enum Mutability {\n }\n \n impl Clean<Mutability> for hir::Mutability {\n-    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Mutability {\n+    fn clean(&self, _: &DocContext<'_>) -> Mutability {\n         match self {\n             &hir::MutMutable => Mutable,\n             &hir::MutImmutable => Immutable,\n@@ -3520,7 +3520,7 @@ pub enum ImplPolarity {\n }\n \n impl Clean<ImplPolarity> for hir::ImplPolarity {\n-    fn clean(&self, _: &DocContext<'_, '_, '_>) -> ImplPolarity {\n+    fn clean(&self, _: &DocContext<'_>) -> ImplPolarity {\n         match self {\n             &hir::ImplPolarity::Positive => ImplPolarity::Positive,\n             &hir::ImplPolarity::Negative => ImplPolarity::Negative,\n@@ -3542,7 +3542,7 @@ pub struct Impl {\n }\n \n pub fn get_auto_traits_with_hir_id(\n-    cx: &DocContext<'_, '_, '_>,\n+    cx: &DocContext<'_>,\n     id: hir::HirId,\n     name: String\n ) -> Vec<Item> {\n@@ -3551,7 +3551,7 @@ pub fn get_auto_traits_with_hir_id(\n }\n \n pub fn get_auto_traits_with_def_id(\n-    cx: &DocContext<'_, '_, '_>,\n+    cx: &DocContext<'_>,\n     id: DefId\n ) -> Vec<Item> {\n     let finder = AutoTraitFinder::new(cx);\n@@ -3560,7 +3560,7 @@ pub fn get_auto_traits_with_def_id(\n }\n \n pub fn get_blanket_impls_with_hir_id(\n-    cx: &DocContext<'_, '_, '_>,\n+    cx: &DocContext<'_>,\n     id: hir::HirId,\n     name: String\n ) -> Vec<Item> {\n@@ -3569,7 +3569,7 @@ pub fn get_blanket_impls_with_hir_id(\n }\n \n pub fn get_blanket_impls_with_def_id(\n-    cx: &DocContext<'_, '_, '_>,\n+    cx: &DocContext<'_>,\n     id: DefId\n ) -> Vec<Item> {\n     let finder = BlanketImplFinder::new(cx);\n@@ -3578,7 +3578,7 @@ pub fn get_blanket_impls_with_def_id(\n }\n \n impl Clean<Vec<Item>> for doctree::Impl {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         let mut ret = Vec::new();\n         let trait_ = self.trait_.clean(cx);\n         let items = self.items.clean(cx);\n@@ -3620,7 +3620,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n     }\n }\n \n-fn build_deref_target_impls(cx: &DocContext<'_, '_, '_>,\n+fn build_deref_target_impls(cx: &DocContext<'_>,\n                             items: &[Item],\n                             ret: &mut Vec<Item>) {\n     use self::PrimitiveType::*;\n@@ -3679,7 +3679,7 @@ fn build_deref_target_impls(cx: &DocContext<'_, '_, '_>,\n }\n \n impl Clean<Vec<Item>> for doctree::ExternCrate {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n \n         let please_inline = self.vis.node.is_pub() && self.attrs.iter().any(|a| {\n             a.name() == \"doc\" && match a.meta_item_list() {\n@@ -3715,7 +3715,7 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n }\n \n impl Clean<Vec<Item>> for doctree::Import {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n@@ -3789,7 +3789,7 @@ pub struct ImportSource {\n }\n \n impl Clean<Vec<Item>> for hir::ForeignMod {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Vec<Item> {\n+    fn clean(&self, cx: &DocContext<'_>) -> Vec<Item> {\n         let mut items = self.items.clean(cx);\n         for item in &mut items {\n             if let ForeignFunctionItem(ref mut f) = item.inner {\n@@ -3801,7 +3801,7 @@ impl Clean<Vec<Item>> for hir::ForeignMod {\n }\n \n impl Clean<Item> for hir::ForeignItem {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let inner = match self.node {\n             hir::ForeignItemKind::Fn(ref decl, ref names, ref generics) => {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n@@ -3848,11 +3848,11 @@ impl Clean<Item> for hir::ForeignItem {\n // Utilities\n \n pub trait ToSource {\n-    fn to_src(&self, cx: &DocContext<'_, '_, '_>) -> String;\n+    fn to_src(&self, cx: &DocContext<'_>) -> String;\n }\n \n impl ToSource for syntax_pos::Span {\n-    fn to_src(&self, cx: &DocContext<'_, '_, '_>) -> String {\n+    fn to_src(&self, cx: &DocContext<'_>) -> String {\n         debug!(\"converting span {:?} to snippet\", self.clean(cx));\n         let sn = match cx.sess().source_map().span_to_snippet(*self) {\n             Ok(x) => x,\n@@ -3899,7 +3899,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n-fn print_const(cx: &DocContext<'_, '_, '_>, n: ty::LazyConst<'_>) -> String {\n+fn print_const(cx: &DocContext<'_>, n: ty::LazyConst<'_>) -> String {\n     match n {\n         ty::LazyConst::Unevaluated(def_id, _) => {\n             if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n@@ -3921,12 +3921,12 @@ fn print_const(cx: &DocContext<'_, '_, '_>, n: ty::LazyConst<'_>) -> String {\n     }\n }\n \n-fn print_const_expr(cx: &DocContext<'_, '_, '_>, body: hir::BodyId) -> String {\n+fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n     cx.tcx.hir().hir_to_pretty_string(body.hir_id)\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-fn resolve_type(cx: &DocContext<'_, '_, '_>,\n+fn resolve_type(cx: &DocContext<'_>,\n                 path: Path,\n                 id: hir::HirId) -> Type {\n     if id == hir::DUMMY_HIR_ID {\n@@ -3957,7 +3957,7 @@ fn resolve_type(cx: &DocContext<'_, '_, '_>,\n     ResolvedPath { path: path, typarams: None, did: did, is_generic: is_generic }\n }\n \n-pub fn register_def(cx: &DocContext<'_, '_, '_>, def: Def) -> DefId {\n+pub fn register_def(cx: &DocContext<'_>, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n     let (did, kind) = match def {\n@@ -3992,7 +3992,7 @@ pub fn register_def(cx: &DocContext<'_, '_, '_>, def: Def) -> DefId {\n     did\n }\n \n-fn resolve_use_source(cx: &DocContext<'_, '_, '_>, path: Path) -> ImportSource {\n+fn resolve_use_source(cx: &DocContext<'_>, path: Path) -> ImportSource {\n     ImportSource {\n         did: if path.def.opt_def_id().is_none() {\n             None\n@@ -4010,7 +4010,7 @@ pub struct Macro {\n }\n \n impl Clean<Item> for doctree::Macro {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let name = self.name.clean(cx);\n         Item {\n             name: Some(name.clone()),\n@@ -4039,7 +4039,7 @@ pub struct ProcMacro {\n }\n \n impl Clean<Item> for doctree::ProcMacro {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> Item {\n+    fn clean(&self, cx: &DocContext<'_>) -> Item {\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -4073,7 +4073,7 @@ pub struct Deprecation {\n }\n \n impl Clean<Stability> for attr::Stability {\n-    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Stability {\n+    fn clean(&self, _: &DocContext<'_>) -> Stability {\n         Stability {\n             level: stability::StabilityLevel::from_attr_level(&self.level),\n             feature: Some(self.feature.to_string()).filter(|f| !f.is_empty()),\n@@ -4100,13 +4100,13 @@ impl Clean<Stability> for attr::Stability {\n }\n \n impl<'a> Clean<Stability> for &'a attr::Stability {\n-    fn clean(&self, dc: &DocContext<'_, '_, '_>) -> Stability {\n+    fn clean(&self, dc: &DocContext<'_>) -> Stability {\n         (**self).clean(dc)\n     }\n }\n \n impl Clean<Deprecation> for attr::Deprecation {\n-    fn clean(&self, _: &DocContext<'_, '_, '_>) -> Deprecation {\n+    fn clean(&self, _: &DocContext<'_>) -> Deprecation {\n         Deprecation {\n             since: self.since.map(|s| s.to_string()).filter(|s| !s.is_empty()),\n             note: self.note.map(|n| n.to_string()).filter(|n| !n.is_empty()),\n@@ -4122,7 +4122,7 @@ pub struct TypeBinding {\n }\n \n impl Clean<TypeBinding> for hir::TypeBinding {\n-    fn clean(&self, cx: &DocContext<'_, '_, '_>) -> TypeBinding {\n+    fn clean(&self, cx: &DocContext<'_>) -> TypeBinding {\n         TypeBinding {\n             name: self.ident.name.clean(cx),\n             ty: self.ty.clean(cx)\n@@ -4131,7 +4131,7 @@ impl Clean<TypeBinding> for hir::TypeBinding {\n }\n \n pub fn def_id_to_path(\n-    cx: &DocContext<'_, '_, '_>,\n+    cx: &DocContext<'_>,\n     did: DefId,\n     name: Option<String>\n ) -> Vec<String> {\n@@ -4148,7 +4148,7 @@ pub fn def_id_to_path(\n     once(crate_name).chain(relative).collect()\n }\n \n-pub fn enter_impl_trait<F, R>(cx: &DocContext<'_, '_, '_>, f: F) -> R\n+pub fn enter_impl_trait<F, R>(cx: &DocContext<'_>, f: F) -> R\n where\n     F: FnOnce() -> R,\n {"}, {"sha": "8ca570cb443c9cf289b43d8ef9e1e8daa43a4720", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -22,7 +22,7 @@ use crate::clean::WherePredicate as WP;\n use crate::clean;\n use crate::core::DocContext;\n \n-pub fn where_clauses(cx: &DocContext<'_, '_, '_>, clauses: Vec<WP>) -> Vec<WP> {\n+pub fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     // First, partition the where clause into its separate components\n     let mut params: BTreeMap<_, Vec<_>> = BTreeMap::new();\n     let mut lifetimes = Vec::new();\n@@ -141,7 +141,7 @@ fn ty_bounds(bounds: Vec<clean::GenericBound>) -> Vec<clean::GenericBound> {\n     bounds\n }\n \n-fn trait_is_same_or_supertrait(cx: &DocContext<'_, '_, '_>, child: DefId,\n+fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId,\n                                trait_: DefId) -> bool {\n     if child == trait_ {\n         return true"}, {"sha": "f2682e00430d08fb3aadd79afc136e7377668cac", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -203,7 +203,7 @@ pub struct RenderOptions {\n impl Options {\n     /// Parses the given command-line for options. If an error message or other early-return has\n     /// been printed, returns `Err` with the exit code.\n-    pub fn from_matches(matches: &getopts::Matches) -> Result<Options, isize> {\n+    pub fn from_matches(matches: &getopts::Matches) -> Result<Options, i32> {\n         // Check for unstable options.\n         nightly_options::check_nightly_options(&matches, &opts());\n "}, {"sha": "47dbbc20980ba63b361cc7f205b54f66966413e7", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 76, "deletions": 131, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -1,19 +1,18 @@\n use rustc_lint;\n-use rustc_driver::{driver, abort_on_err};\n use rustc::session::{self, config};\n use rustc::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CrateNum, LOCAL_CRATE};\n use rustc::hir::def::Def;\n use rustc::hir::{self, HirId, HirVec};\n use rustc::middle::cstore::CrateStore;\n use rustc::middle::privacy::AccessLevels;\n-use rustc::ty::{self, TyCtxt, AllArenas};\n-use rustc::hir::map as hir_map;\n+use rustc::ty::{self, TyCtxt};\n use rustc::lint::{self, LintPass};\n use rustc::session::config::ErrorOutputType;\n+use rustc::session::DiagnosticOutput;\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n-use rustc_interface::util;\n+use rustc_interface::interface;\n+use rustc_driver::abort_on_err;\n use rustc_resolve as resolve;\n-use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::CStore;\n use rustc_target::spec::TargetTriple;\n \n@@ -24,15 +23,15 @@ use syntax::json::JsonEmitter;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::DUMMY_SP;\n-use errors::{self, FatalError};\n+use errors;\n use errors::emitter::{Emitter, EmitterWriter};\n use parking_lot::ReentrantMutex;\n \n use std::cell::RefCell;\n use std::mem;\n use rustc_data_structures::sync::{self, Lrc};\n-use std::rc::Rc;\n use std::sync::Arc;\n+use std::rc::Rc;\n \n use crate::visit_ast::RustdocVisitor;\n use crate::config::{Options as RustdocOptions, RenderOptions};\n@@ -47,12 +46,13 @@ pub use rustc::session::search_paths::SearchPath;\n \n pub type ExternalPaths = FxHashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n-pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub resolver: &'a RefCell<resolve::Resolver<'rcx>>,\n+pub struct DocContext<'tcx> {\n+\n+    pub tcx: TyCtxt<'tcx, 'tcx, 'tcx>,\n+    pub resolver: Rc<Option<RefCell<interface::BoxedResolver>>>,\n     /// The stack of module NodeIds up till this point\n     pub crate_name: Option<String>,\n-    pub cstore: Rc<CStore>,\n+    pub cstore: Lrc<CStore>,\n     /// Later on moved into `html::render::CACHE_KEY`\n     pub renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n@@ -79,11 +79,18 @@ pub struct DocContext<'a, 'tcx: 'a, 'rcx: 'a> {\n     pub all_traits: Vec<DefId>,\n }\n \n-impl<'a, 'tcx, 'rcx> DocContext<'a, 'tcx, 'rcx> {\n+impl<'tcx> DocContext<'tcx> {\n     pub fn sess(&self) -> &session::Session {\n         &self.tcx.sess\n     }\n \n+    pub fn enter_resolver<F, R>(&self, f: F) -> R\n+    where F: FnOnce(&mut resolve::Resolver<'_>) -> R {\n+        let resolver = &*self.resolver;\n+        let resolver = resolver.as_ref().unwrap();\n+        resolver.borrow_mut().access(f)\n+    }\n+\n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n     pub fn enter_alias<F, R>(&self,\n@@ -368,19 +375,31 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n     whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n \n-    let lints = lint::builtin::HardwiredLints.get_lints()\n-                    .into_iter()\n-                    .chain(rustc_lint::SoftLints.get_lints().into_iter())\n-                    .filter_map(|lint| {\n-                        if lint.name == warnings_lint_name ||\n-                           lint.name == intra_link_resolution_failure_name {\n-                            None\n-                        } else {\n-                            Some((lint.name_lower(), lint::Allow))\n-                        }\n-                    })\n-                    .chain(lint_opts.into_iter())\n-                    .collect::<Vec<_>>();\n+    let lints = || {\n+        lint::builtin::HardwiredLints\n+            .get_lints()\n+            .into_iter()\n+            .chain(rustc_lint::SoftLints.get_lints().into_iter())\n+    };\n+\n+    let lint_opts = lints().filter_map(|lint| {\n+        if lint.name == warnings_lint_name ||\n+            lint.name == intra_link_resolution_failure_name {\n+            None\n+        } else {\n+            Some((lint.name_lower(), lint::Allow))\n+        }\n+    }).chain(lint_opts.into_iter()).collect::<Vec<_>>();\n+\n+    let lint_caps = lints().filter_map(|lint| {\n+        // We don't want to whitelist *all* lints so let's\n+        // ignore those ones.\n+        if whitelisted_lints.iter().any(|l| &lint.name == l) {\n+            None\n+        } else {\n+            Some((lint::LintId::of(lint), lint::Allow))\n+        }\n+    }).collect();\n \n     let host_triple = TargetTriple::from_triple(config::host_triple());\n     // plays with error output here!\n@@ -389,7 +408,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         search_paths: libs,\n         crate_types: vec![config::CrateType::Rlib],\n         lint_opts: if !display_warnings {\n-            lints\n+            lint_opts\n         } else {\n             vec![]\n         },\n@@ -406,116 +425,42 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         describe_lints,\n         ..Options::default()\n     };\n-    driver::spawn_thread_pool(sessopts, move |sessopts| {\n-        let source_map = Lrc::new(source_map::SourceMap::new(sessopts.file_path_mapping()));\n-        let diagnostic_handler = new_handler(error_format,\n-                                             Some(source_map.clone()),\n-                                             debugging_options.treat_err_as_bug,\n-                                             debugging_options.ui_testing);\n-\n-        let mut sess = session::build_session_(\n-            sessopts, cpath, diagnostic_handler, source_map, Default::default(),\n-        );\n \n-        lint::builtin::HardwiredLints.get_lints()\n-                                     .into_iter()\n-                                     .chain(rustc_lint::SoftLints.get_lints().into_iter())\n-                                     .filter_map(|lint| {\n-                                         // We don't want to whitelist *all* lints so let's\n-                                         // ignore those ones.\n-                                         if whitelisted_lints.iter().any(|l| &lint.name == l) {\n-                                             None\n-                                         } else {\n-                                             Some(lint)\n-                                         }\n-                                     })\n-                                     .for_each(|l| {\n-                                         sess.driver_lint_caps.insert(lint::LintId::of(l),\n-                                                                      lint::Allow);\n-                                     });\n-\n-        let codegen_backend = util::get_codegen_backend(&sess);\n-        let cstore = Rc::new(CStore::new(codegen_backend.metadata_loader()));\n-        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-        let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs));\n-        util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n-        sess.parse_sess.config = cfg;\n-\n-        let control = &driver::CompileController::basic();\n-\n-        let krate = match driver::phase_1_parse_input(control, &sess, &input) {\n-            Ok(krate) => krate,\n-            Err(mut e) => {\n-                e.emit();\n-                FatalError.raise();\n-            }\n-        };\n+    let config = interface::Config {\n+        opts: sessopts,\n+        crate_cfg: config::parse_cfgspecs(cfgs),\n+        input,\n+        input_path: cpath,\n+        output_file: None,\n+        output_dir: None,\n+        file_loader: None,\n+        diagnostic_output: DiagnosticOutput::Default,\n+        stderr: None,\n+        crate_name: crate_name.clone(),\n+        lint_caps,\n+    };\n \n-        let name = match crate_name {\n-            Some(ref crate_name) => crate_name.clone(),\n-            None => ::rustc_codegen_utils::link::find_crate_name(Some(&sess), &krate.attrs, &input),\n-        };\n+    interface::run_compiler_in_existing_thread_pool(config, |compiler| {\n+        let sess = compiler.session();\n \n-        let mut crate_loader = CrateLoader::new(&sess, &cstore, &name);\n-\n-        let resolver_arenas = resolve::Resolver::arenas();\n-        let result = driver::phase_2_configure_and_expand_inner(&sess,\n-                                                        &cstore,\n-                                                        krate,\n-                                                        None,\n-                                                        &name,\n-                                                        None,\n-                                                        &resolver_arenas,\n-                                                        &mut crate_loader,\n-                                                        |_| Ok(()));\n-        let driver::InnerExpansionResult {\n-            mut hir_forest,\n-            resolver,\n-            ..\n-        } = abort_on_err(result, &sess);\n-\n-        // We need to hold on to the complete resolver, so we clone everything\n-        // for the analysis passes to use. Suboptimal, but necessary in the\n+        // We need to hold on to the complete resolver, so we cause everything to be\n+        // cloned for the analysis passes to use. Suboptimal, but necessary in the\n         // current architecture.\n-        let defs = resolver.definitions.clone();\n-        let resolutions = ty::Resolutions {\n-            freevars: resolver.freevars.clone(),\n-            export_map: resolver.export_map.clone(),\n-            trait_map: resolver.trait_map.clone(),\n-            glob_map: resolver.glob_map.clone(),\n-            maybe_unused_trait_imports: resolver.maybe_unused_trait_imports.clone(),\n-            maybe_unused_extern_crates: resolver.maybe_unused_extern_crates.clone(),\n-            extern_prelude: resolver.extern_prelude.iter().map(|(ident, entry)| {\n-                (ident.name, entry.introduced_by_item)\n-            }).collect(),\n-        };\n+        let resolver = abort_on_err(compiler.expansion(), sess).peek().1.clone();\n \n-        let mut arenas = AllArenas::new();\n-        let hir_map = hir_map::map_crate(&sess, &*cstore, &mut hir_forest, &defs);\n-        let output_filenames = util::build_output_filenames(&input,\n-                                                            &None,\n-                                                            &None,\n-                                                            &[],\n-                                                            &sess);\n-\n-        let resolver = RefCell::new(resolver);\n-        driver::phase_3_run_analysis_passes(&*codegen_backend,\n-                                            control,\n-                                            &sess,\n-                                            &*cstore,\n-                                            hir_map,\n-                                            resolutions,\n-                                            &mut arenas,\n-                                            &name,\n-                                            &output_filenames,\n-                                            |tcx, _, result| {\n-            if result.is_err() {\n-                sess.fatal(\"Compilation failed, aborting rustdoc\");\n-            }\n+        if sess.err_count() > 0 {\n+            sess.fatal(\"Compilation failed, aborting rustdoc\");\n+        }\n \n-            let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n+        let mut global_ctxt = abort_on_err(compiler.global_ctxt(), sess).take();\n \n+        global_ctxt.enter(|tcx| {\n+            tcx.analysis(LOCAL_CRATE).ok();\n+\n+            // Abort if there were any errors so far\n+            sess.abort_if_errors();\n+\n+            let access_levels = tcx.privacy_access_levels(LOCAL_CRATE);\n             // Convert from a NodeId set to a DefId set since we don't always have easy access\n             // to the map from defid -> nodeid\n             let access_levels = AccessLevels {\n@@ -535,9 +480,9 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n             let ctxt = DocContext {\n                 tcx,\n-                resolver: &resolver,\n+                resolver,\n                 crate_name,\n-                cstore: cstore.clone(),\n+                cstore: compiler.cstore().clone(),\n                 external_traits: Default::default(),\n                 active_extern_traits: Default::default(),\n                 renderinfo: RefCell::new(renderinfo),"}, {"sha": "f11e268b9092c17b5a0ea15e6a68b45f4bb09756", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -23,14 +23,13 @@ extern crate getopts;\n extern crate env_logger;\n extern crate rustc;\n extern crate rustc_data_structures;\n-extern crate rustc_codegen_utils;\n extern crate rustc_driver;\n extern crate rustc_resolve;\n extern crate rustc_lint;\n+extern crate rustc_interface;\n extern crate rustc_metadata;\n extern crate rustc_target;\n extern crate rustc_typeck;\n-extern crate rustc_interface;\n extern crate serialize;\n extern crate syntax;\n extern crate syntax_pos;\n@@ -91,11 +90,11 @@ pub fn main() {\n     rustc_driver::set_sigpipe_handler();\n     env_logger::init();\n     let res = std::thread::Builder::new().stack_size(thread_stack_size).spawn(move || {\n-        syntax::with_globals(move || {\n+        rustc_interface::interface::default_thread_pool(move || {\n             get_args().map(|args| main_args(&args)).unwrap_or(1)\n         })\n     }).unwrap().join().unwrap_or(rustc_driver::EXIT_FAILURE);\n-    process::exit(res as i32);\n+    process::exit(res);\n }\n \n fn get_args() -> Option<Vec<String>> {\n@@ -364,7 +363,7 @@ fn usage(argv0: &str) {\n     println!(\"{}\", options.usage(&format!(\"{} [options] <input>\", argv0)));\n }\n \n-fn main_args(args: &[String]) -> isize {\n+fn main_args(args: &[String]) -> i32 {\n     let mut options = getopts::Options::new();\n     for option in opts() {\n         (option.apply)(&mut options);\n@@ -441,7 +440,7 @@ where R: 'static + Send,\n \n     let (tx, rx) = channel();\n \n-    let result = rustc_driver::monitor(move || syntax::with_globals(move || {\n+    let result = rustc_driver::report_ices_to_stderr_if_any(move || syntax::with_globals(move || {\n         let crate_name = options.crate_name.clone();\n         let crate_version = options.crate_version.clone();\n         let (mut krate, renderinfo, renderopts, passes) = core::run_core(options);"}, {"sha": "a2e2303bb27f36d94258c559bdc775edd076fa6b", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -36,7 +36,7 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n \n /// Render `input` (e.g., \"foo.md\") into an HTML file in `output`\n /// (e.g., output = \"bar\" => \"bar/foo.html\").\n-pub fn render(input: PathBuf, options: RenderOptions, diag: &errors::Handler) -> isize {\n+pub fn render(input: PathBuf, options: RenderOptions, diag: &errors::Handler) -> i32 {\n     let mut output = options.output;\n     output.push(input.file_stem().unwrap());\n     output.set_extension(\"html\");\n@@ -126,7 +126,7 @@ pub fn render(input: PathBuf, options: RenderOptions, diag: &errors::Handler) ->\n }\n \n /// Runs any tests/code examples in the markdown file `input`.\n-pub fn test(mut options: Options, diag: &errors::Handler) -> isize {\n+pub fn test(mut options: Options, diag: &errors::Handler) -> i32 {\n     let input_str = match load_string(&options.input, diag) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,"}, {"sha": "fe407fa24d93e3932256a45d8018845f9d598159", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -15,7 +15,7 @@ pub const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     description: \"counts the number of items with and without documentation\",\n };\n \n-fn calculate_doc_coverage(krate: clean::Crate, _: &DocContext<'_, '_, '_>) -> clean::Crate {\n+fn calculate_doc_coverage(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     let mut calc = CoverageCalculator::default();\n     let krate = calc.fold_crate(krate);\n "}, {"sha": "0556852c54ac2e741aa64b62fad4369b4c804e70", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -16,15 +16,15 @@ pub const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     description: \"validates syntax inside Rust code blocks\",\n };\n \n-pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_, '_, '_>) -> clean::Crate {\n+pub fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n     SyntaxChecker { cx }.fold_crate(krate)\n }\n \n-struct SyntaxChecker<'a, 'tcx: 'a, 'rcx: 'a> {\n-    cx: &'a DocContext<'a, 'tcx, 'rcx>,\n+struct SyntaxChecker<'a, 'tcx: 'a> {\n+    cx: &'a DocContext<'tcx>,\n }\n \n-impl<'a, 'tcx, 'rcx> SyntaxChecker<'a, 'tcx, 'rcx> {\n+impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n     fn check_rust_syntax(&self, item: &clean::Item, dox: &str, code_block: RustCodeBlock) {\n         let sess = ParseSess::new(FilePathMapping::empty());\n         let source_file = sess.source_map().new_source_file(\n@@ -98,7 +98,7 @@ impl<'a, 'tcx, 'rcx> SyntaxChecker<'a, 'tcx, 'rcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'rcx> DocFolder for SyntaxChecker<'a, 'tcx, 'rcx> {\n+impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if let Some(dox) = &item.attrs.collapsed_doc_value() {\n             for code_block in markdown::rust_code_blocks(&dox) {"}, {"sha": "8666ba357b832f92bc10cf1f1c506c514575a2a1", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -29,7 +29,7 @@ impl DocFragment {\n     }\n }\n \n-pub fn collapse_docs(krate: clean::Crate, _: &DocContext<'_, '_, '_>) -> clean::Crate {\n+pub fn collapse_docs(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     Collapser.fold_crate(krate)\n }\n "}, {"sha": "fefff1f3a759339ad5b77cde5e4ddfb4bd53577e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -25,7 +25,7 @@ pub const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     description: \"reads a crate's documentation to resolve intra-doc-links\",\n };\n \n-pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n+pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     if !UnstableFeatures::from_environment().is_nightly_build() {\n         krate\n     } else {\n@@ -47,14 +47,14 @@ enum PathKind {\n     Type,\n }\n \n-struct LinkCollector<'a, 'tcx: 'a, 'rcx: 'a> {\n-    cx: &'a DocContext<'a, 'tcx, 'rcx>,\n+struct LinkCollector<'a, 'tcx> {\n+    cx: &'a DocContext<'tcx>,\n     mod_ids: Vec<ast::NodeId>,\n     is_nightly_build: bool,\n }\n \n-impl<'a, 'tcx, 'rcx> LinkCollector<'a, 'tcx, 'rcx> {\n-    fn new(cx: &'a DocContext<'a, 'tcx, 'rcx>) -> Self {\n+impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n+    fn new(cx: &'a DocContext<'tcx>) -> Self {\n         LinkCollector {\n             cx,\n             mod_ids: Vec::new(),\n@@ -78,12 +78,11 @@ impl<'a, 'tcx, 'rcx> LinkCollector<'a, 'tcx, 'rcx> {\n         // path.\n         if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n             // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let result = cx.resolver.borrow_mut()\n-                                    .with_scope(id,\n+            let result = cx.enter_resolver(|resolver| resolver.with_scope(id,\n                 |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP,\n                                                     &path_str, is_val)\n-            });\n+            }));\n \n             if let Ok(result) = result {\n                 // In case this is a trait item, skip the\n@@ -142,11 +141,9 @@ impl<'a, 'tcx, 'rcx> LinkCollector<'a, 'tcx, 'rcx> {\n             }\n \n             // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let ty = cx.resolver.borrow_mut()\n-                                .with_scope(id,\n-                |resolver| {\n+            let ty = cx.enter_resolver(|resolver| resolver.with_scope(id, |resolver| {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n-            })?;\n+            }))?;\n             match ty.def {\n                 Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n                     let item = cx.tcx.inherent_impls(did)\n@@ -218,7 +215,7 @@ impl<'a, 'tcx, 'rcx> LinkCollector<'a, 'tcx, 'rcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'rcx> DocFolder for LinkCollector<'a, 'tcx, 'rcx> {\n+impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n         let item_hir_id = if item.is_mod() {\n             if let Some(id) = self.cx.tcx.hir().as_local_hir_id(item.def_id) {\n@@ -437,26 +434,27 @@ impl<'a, 'tcx, 'rcx> DocFolder for LinkCollector<'a, 'tcx, 'rcx> {\n }\n \n /// Resolves a string as a macro.\n-fn macro_resolve(cx: &DocContext<'_, '_, '_>, path_str: &str) -> Option<Def> {\n+fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Def> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n-    let mut resolver = cx.resolver.borrow_mut();\n-    let parent_scope = resolver.dummy_parent_scope();\n-    if let Ok(def) = resolver.resolve_macro_to_def_inner(&path, MacroKind::Bang,\n-                                                         &parent_scope, false, false) {\n-        if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n-            // skip proc-macro stubs, they'll cause `get_macro` to crash\n-        } else {\n-            if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n-                return Some(def);\n+    cx.enter_resolver(|resolver| {\n+        let parent_scope = resolver.dummy_parent_scope();\n+        if let Ok(def) = resolver.resolve_macro_to_def_inner(&path, MacroKind::Bang,\n+                                                            &parent_scope, false, false) {\n+            if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n+                // skip proc-macro stubs, they'll cause `get_macro` to crash\n+            } else {\n+                if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n+                    return Some(def);\n+                }\n             }\n         }\n-    }\n-    if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n-        return Some(*def);\n-    }\n-    None\n+        if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n+            return Some(*def);\n+        }\n+        None\n+    })\n }\n \n /// Reports a resolution failure diagnostic.\n@@ -465,7 +463,7 @@ fn macro_resolve(cx: &DocContext<'_, '_, '_>, path_str: &str) -> Option<Def> {\n /// documentation attributes themselves. This is a little heavy-handed, so we display the markdown\n /// line containing the failure as a note as well.\n fn resolution_failure(\n-    cx: &DocContext<'_, '_, '_>,\n+    cx: &DocContext<'_>,\n     attrs: &Attributes,\n     path_str: &str,\n     dox: &str,\n@@ -507,7 +505,7 @@ fn resolution_failure(\n     diag.emit();\n }\n \n-fn ambiguity_error(cx: &DocContext<'_, '_, '_>, attrs: &Attributes,\n+fn ambiguity_error(cx: &DocContext<'_>, attrs: &Attributes,\n                    path_str: &str,\n                    article1: &str, kind1: &str, disambig1: &str,\n                    article2: &str, kind2: &str, disambig2: &str) {\n@@ -563,7 +561,7 @@ fn type_ns_kind(def: Def, path_str: &str) -> (&'static str, &'static str, String\n }\n \n /// Given an enum variant's def, return the def of its enum and the associated fragment.\n-fn handle_variant(cx: &DocContext<'_, '_, '_>, def: Def) -> Result<(Def, Option<String>), ()> {\n+fn handle_variant(cx: &DocContext<'_>, def: Def) -> Result<(Def, Option<String>), ()> {\n     use rustc::ty::DefIdTree;\n \n     let parent = if let Some(parent) = cx.tcx.parent(def.def_id()) {\n@@ -604,7 +602,7 @@ fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {\n     }\n }\n \n-fn primitive_impl(cx: &DocContext<'_, '_, '_>, path_str: &str) -> Option<DefId> {\n+fn primitive_impl(cx: &DocContext<'_>, path_str: &str) -> Option<DefId> {\n     let tcx = cx.tcx;\n     match path_str {\n         \"u8\" => tcx.lang_items().u8_impl(),"}, {"sha": "de043277c835967c1f7d7851a1586b97a2fd8bb2", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -12,7 +12,7 @@ pub const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     description: \"retrieves trait impls for items in the crate\",\n };\n \n-pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n+pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     let mut synth = SyntheticImplCollector::new(cx);\n     let mut krate = synth.fold_crate(krate);\n \n@@ -138,21 +138,21 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n     krate\n }\n \n-struct SyntheticImplCollector<'a, 'tcx: 'a, 'rcx: 'a> {\n-    cx: &'a DocContext<'a, 'tcx, 'rcx>,\n+struct SyntheticImplCollector<'a, 'tcx> {\n+    cx: &'a DocContext<'tcx>,\n     impls: Vec<Item>,\n }\n \n-impl<'a, 'tcx, 'rcx> SyntheticImplCollector<'a, 'tcx, 'rcx> {\n-    fn new(cx: &'a DocContext<'a, 'tcx, 'rcx>) -> Self {\n+impl<'a, 'tcx> SyntheticImplCollector<'a, 'tcx> {\n+    fn new(cx: &'a DocContext<'tcx>) -> Self {\n         SyntheticImplCollector {\n             cx,\n             impls: Vec::new(),\n         }\n     }\n }\n \n-impl<'a, 'tcx, 'rcx> DocFolder for SyntheticImplCollector<'a, 'tcx, 'rcx> {\n+impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {\n             if let (Some(hir_id), Some(name)) ="}, {"sha": "3c403d421c8fd9fb08a2f497d215f2d94acbb039", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -54,7 +54,7 @@ pub use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n #[derive(Copy, Clone)]\n pub struct Pass {\n     pub name: &'static str,\n-    pub pass: fn(clean::Crate, &DocContext<'_, '_, '_>) -> clean::Crate,\n+    pub pass: fn(clean::Crate, &DocContext<'_>) -> clean::Crate,\n     pub description: &'static str,\n }\n \n@@ -308,8 +308,8 @@ impl DocFolder for ImportStripper {\n     }\n }\n \n-pub fn look_for_tests<'a, 'tcx: 'a, 'rcx: 'a>(\n-    cx: &'a DocContext<'a, 'tcx, 'rcx>,\n+pub fn look_for_tests<'tcx>(\n+    cx: &DocContext<'tcx>,\n     dox: &str,\n     item: &Item,\n     check_missing_code: bool,\n@@ -370,7 +370,7 @@ crate fn span_of_attrs(attrs: &clean::Attributes) -> Span {\n /// attributes are not all sugared doc comments. It's difficult to calculate the correct span in\n /// that case due to escaping and other source features.\n crate fn source_span_for_markdown_range(\n-    cx: &DocContext<'_, '_, '_>,\n+    cx: &DocContext<'_>,\n     markdown: &str,\n     md_range: &Range<usize>,\n     attrs: &clean::Attributes,"}, {"sha": "5560ebed9ae69a0be4ef0de006399f96b9e5dbc1", "filename": "src/librustdoc/passes/private_items_doc_tests.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -9,25 +9,25 @@ pub const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass = Pass {\n     description: \"check private items doc tests\",\n };\n \n-struct PrivateItemDocTestLinter<'a, 'tcx: 'a, 'rcx: 'a> {\n-    cx: &'a DocContext<'a, 'tcx, 'rcx>,\n+struct PrivateItemDocTestLinter<'a, 'tcx> {\n+    cx: &'a DocContext<'tcx>,\n }\n \n-impl<'a, 'tcx, 'rcx> PrivateItemDocTestLinter<'a, 'tcx, 'rcx> {\n-    fn new(cx: &'a DocContext<'a, 'tcx, 'rcx>) -> Self {\n+impl<'a, 'tcx> PrivateItemDocTestLinter<'a, 'tcx> {\n+    fn new(cx: &'a DocContext<'tcx>) -> Self {\n         PrivateItemDocTestLinter {\n             cx,\n         }\n     }\n }\n \n-pub fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_, '_, '_>) -> Crate {\n+pub fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     let mut coll = PrivateItemDocTestLinter::new(cx);\n \n     coll.fold_crate(krate)\n }\n \n-impl<'a, 'tcx, 'rcx> DocFolder for PrivateItemDocTestLinter<'a, 'tcx, 'rcx> {\n+impl<'a, 'tcx> DocFolder for PrivateItemDocTestLinter<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n         let cx = self.cx;\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);"}, {"sha": "a71a1e001fc69e475e23a5d6437d5ee87c09eb94", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -12,7 +12,7 @@ pub const PROPAGATE_DOC_CFG: Pass = Pass {\n     description: \"propagates `#[doc(cfg(...))]` to child items\",\n };\n \n-pub fn propagate_doc_cfg(cr: Crate, _: &DocContext<'_, '_, '_>) -> Crate {\n+pub fn propagate_doc_cfg(cr: Crate, _: &DocContext<'_>) -> Crate {\n     CfgPropagator { parent_cfg: None }.fold_crate(cr)\n }\n "}, {"sha": "240299c212abc10f2ef1547ce7ec0ea719caf8b2", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -14,7 +14,7 @@ pub const STRIP_HIDDEN: Pass = Pass {\n };\n \n /// Strip items marked `#[doc(hidden)]`\n-pub fn strip_hidden(krate: clean::Crate, _: &DocContext<'_, '_, '_>) -> clean::Crate {\n+pub fn strip_hidden(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     let mut retained = DefIdSet::default();\n \n     // strip all #[doc(hidden)] items"}, {"sha": "516760ade666741222d70f0714768a0746afbc18", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -9,6 +9,6 @@ pub const STRIP_PRIV_IMPORTS: Pass = Pass {\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n \n-pub fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_, '_, '_>)  -> clean::Crate {\n+pub fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_>)  -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "fc742bf74d006c147d81363bc475e22e38278c6a", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -14,7 +14,7 @@ pub const STRIP_PRIVATE: Pass = Pass {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-pub fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_, '_, '_>) -> clean::Crate {\n+pub fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet::default();\n     let access_levels = cx.renderinfo.borrow().access_levels.clone();"}, {"sha": "95e322f70b2ea113e8562565f618d7b478075143", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -13,7 +13,7 @@ pub const UNINDENT_COMMENTS: Pass = Pass {\n     description: \"removes excess indentation on comments in order for markdown to like it\",\n };\n \n-pub fn unindent_comments(krate: clean::Crate, _: &DocContext<'_, '_, '_>) -> clean::Crate {\n+pub fn unindent_comments(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     CommentCleaner.fold_crate(krate)\n }\n "}, {"sha": "f1d4d8470b2a56382a1c75b0d22f5524724d32e0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 122, "deletions": 172, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -1,30 +1,25 @@\n-use errors::{self, FatalError};\n-use errors::emitter::ColorConfig;\n use rustc_data_structures::sync::Lrc;\n-use rustc_lint;\n-use rustc_driver::{self, driver, Compilation};\n-use rustc_driver::driver::phase_2_configure_and_expand;\n-use rustc_metadata::cstore::CStore;\n-use rustc_interface::util;\n+use rustc_interface::interface;\n use rustc::hir;\n use rustc::hir::intravisit;\n-use rustc::session::{self, CompileIncomplete, config};\n+use rustc::hir::def_id::LOCAL_CRATE;\n+use rustc::session::{self, config, DiagnosticOutput};\n use rustc::session::config::{OutputType, OutputTypes, Externs, CodegenOptions};\n use rustc::session::search_paths::SearchPath;\n+use rustc::util::common::ErrorReported;\n use syntax::ast;\n use syntax::source_map::SourceMap;\n use syntax::edition::Edition;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::with_globals;\n use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n use tempfile::Builder as TempFileBuilder;\n use testing;\n \n use std::env;\n use std::io::prelude::*;\n use std::io;\n-use std::path::PathBuf;\n use std::panic::{self, AssertUnwindSafe};\n+use std::path::PathBuf;\n use std::process::Command;\n use std::str;\n use std::sync::{Arc, Mutex};\n@@ -44,7 +39,7 @@ pub struct TestOptions {\n     pub attrs: Vec<String>,\n }\n \n-pub fn run(mut options: Options) -> isize {\n+pub fn run(options: Options) -> i32 {\n     let input = config::Input::File(options.input.clone());\n \n     let sessopts = config::Options {\n@@ -63,87 +58,72 @@ pub fn run(mut options: Options) -> isize {\n         edition: options.edition,\n         ..config::Options::default()\n     };\n-    driver::spawn_thread_pool(sessopts, |sessopts| {\n-        let source_map = Lrc::new(SourceMap::new(sessopts.file_path_mapping()));\n-        let handler =\n-            errors::Handler::with_tty_emitter(ColorConfig::Auto,\n-                                            true, None,\n-                                            Some(source_map.clone()));\n-\n-        let mut sess = session::build_session_(\n-            sessopts, Some(options.input), handler, source_map.clone(), Default::default(),\n-        );\n-        let codegen_backend = util::get_codegen_backend(&sess);\n-        let cstore = CStore::new(codegen_backend.metadata_loader());\n-        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-        let mut cfg = config::build_configuration(&sess,\n-                                                  config::parse_cfgspecs(options.cfgs.clone()));\n-        util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n-        sess.parse_sess.config = cfg;\n-\n-        let krate =\n-            match driver::phase_1_parse_input(&driver::CompileController::basic(), &sess, &input) {\n-                Ok(krate) => krate,\n-                Err(mut e) => {\n-                    e.emit();\n-                    FatalError.raise();\n-                }\n-            };\n-        let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n-            phase_2_configure_and_expand(\n-                &sess,\n-                &cstore,\n-                krate,\n-                None,\n-                \"rustdoc-test\",\n-                None,\n-                |_| Ok(()),\n-            ).expect(\"phase_2_configure_and_expand aborted in rustdoc!\")\n-        };\n \n-        let crate_name = options.crate_name.unwrap_or_else(|| {\n-            ::rustc_codegen_utils::link::find_crate_name(None, &hir_forest.krate().attrs, &input)\n-        });\n-        let mut opts = scrape_test_config(hir_forest.krate());\n+    let config = interface::Config {\n+        opts: sessopts,\n+        crate_cfg: config::parse_cfgspecs(options.cfgs.clone()),\n+        input,\n+        input_path: None,\n+        output_file: None,\n+        output_dir: None,\n+        file_loader: None,\n+        diagnostic_output: DiagnosticOutput::Default,\n+        stderr: None,\n+        crate_name: options.crate_name.clone(),\n+        lint_caps: Default::default(),\n+    };\n+\n+    let mut test_args = options.test_args.clone();\n+    let display_warnings = options.display_warnings;\n+\n+    let tests = interface::run_compiler(config, |compiler| -> Result<_, ErrorReported> {\n+        let lower_to_hir = compiler.lower_to_hir()?;\n+\n+        let mut opts = scrape_test_config(lower_to_hir.peek().0.borrow().krate());\n         opts.display_warnings |= options.display_warnings;\n         let mut collector = Collector::new(\n-            crate_name,\n+            compiler.crate_name()?.peek().to_string(),\n             options.cfgs,\n             options.libs,\n             options.codegen_options,\n             options.externs,\n             false,\n             opts,\n             options.maybe_sysroot,\n-            Some(source_map),\n+            Some(compiler.source_map().clone()),\n             None,\n             options.linker,\n             options.edition,\n             options.persist_doctests,\n         );\n \n-        {\n-            let map = hir::map::map_crate(&sess, &cstore, &mut hir_forest, &defs);\n-            let krate = map.krate();\n+        let mut global_ctxt = compiler.global_ctxt()?.take();\n+        global_ctxt.enter(|tcx| {\n+            let krate = tcx.hir().krate();\n             let mut hir_collector = HirCollector {\n-                sess: &sess,\n+                sess: compiler.session(),\n                 collector: &mut collector,\n-                map: &map,\n-                codes: ErrorCodes::from(sess.opts.unstable_features.is_nightly_build()),\n+                map: tcx.hir(),\n+                codes: ErrorCodes::from(compiler.session().opts\n+                                                .unstable_features.is_nightly_build()),\n             };\n             hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n                 intravisit::walk_crate(this, krate);\n             });\n-        }\n+        });\n \n-        options.test_args.insert(0, \"rustdoctest\".to_string());\n+        Ok(collector.tests)\n+    }).expect(\"compiler aborted in rustdoc!\");\n \n-        testing::test_main(&options.test_args,\n-                        collector.tests.into_iter().collect(),\n-                        testing::Options::new().display_output(options.display_warnings));\n-        0\n-    })\n+    test_args.insert(0, \"rustdoctest\".to_string());\n+\n+    testing::test_main(\n+        &test_args,\n+        tests,\n+        testing::Options::new().display_output(display_warnings)\n+    );\n+\n+    0\n }\n \n // Look for `#![doc(test(no_crate_inject))]`, used by crates in the std facade.\n@@ -239,16 +219,18 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n         }\n         fn flush(&mut self) -> io::Result<()> { Ok(()) }\n     }\n-    struct Bomb(Arc<Mutex<Vec<u8>>>, Box<dyn Write+Send>);\n+    struct Bomb(Arc<Mutex<Vec<u8>>>, Option<Box<dyn Write+Send>>);\n     impl Drop for Bomb {\n         fn drop(&mut self) {\n-            let _ = self.1.write_all(&self.0.lock().unwrap());\n+            let mut old = self.1.take().unwrap();\n+            let _ = old.write_all(&self.0.lock().unwrap());\n+            io::set_panic(Some(old));\n         }\n     }\n     let data = Arc::new(Mutex::new(Vec::new()));\n \n     let old = io::set_panic(Some(box Sink(data.clone())));\n-    let _bomb = Bomb(data.clone(), old.unwrap_or(box io::stdout()));\n+    let _bomb = Bomb(data.clone(), Some(old.unwrap_or(box io::stdout())));\n \n     enum DirState {\n         Temp(tempfile::TempDir),\n@@ -264,91 +246,67 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n         }\n     }\n \n-    let (outdir, compile_result) = driver::spawn_thread_pool(sessopts, |sessopts| {\n-        let source_map = Lrc::new(SourceMap::new(sessopts.file_path_mapping()));\n-        let emitter = errors::emitter::EmitterWriter::new(box Sink(data.clone()),\n-                                                        Some(source_map.clone()),\n-                                                        false,\n-                                                        false);\n-\n-        // Compile the code\n-        let diagnostic_handler = errors::Handler::with_emitter(true, None, box emitter);\n-\n-        let mut sess = session::build_session_(\n-            sessopts, None, diagnostic_handler, source_map, Default::default(),\n-        );\n-        let codegen_backend = util::get_codegen_backend(&sess);\n-        let cstore = CStore::new(codegen_backend.metadata_loader());\n-        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-        let outdir = Mutex::new(\n-            if let Some(mut path) = persist_doctests {\n-                path.push(format!(\"{}_{}\",\n-                    filename\n-                        .to_string()\n-                        .rsplit('/')\n-                        .next()\n-                        .unwrap()\n-                        .replace(\".\", \"_\"),\n-                        line)\n-                );\n-                std::fs::create_dir_all(&path)\n-                    .expect(\"Couldn't create directory for doctest executables\");\n-\n-                DirState::Perm(path)\n-            } else {\n-                DirState::Temp(TempFileBuilder::new()\n-                                .prefix(\"rustdoctest\")\n-                                .tempdir()\n-                                .expect(\"rustdoc needs a tempdir\"))\n-            }\n+    let outdir = if let Some(mut path) = persist_doctests {\n+        path.push(format!(\"{}_{}\",\n+            filename\n+                .to_string()\n+                .rsplit('/')\n+                .next()\n+                .unwrap()\n+                .replace(\".\", \"_\"),\n+                line)\n         );\n-        let mut control = driver::CompileController::basic();\n-\n-        let mut cfg = config::build_configuration(&sess, config::parse_cfgspecs(cfgs.clone()));\n-        util::add_configuration(&mut cfg, &sess, &*codegen_backend);\n-        sess.parse_sess.config = cfg;\n-\n-        let out = Some(outdir.lock().unwrap().path().join(\"rust_out\"));\n-\n-        if no_run {\n-            control.after_analysis.stop = Compilation::Stop;\n-        }\n+        std::fs::create_dir_all(&path)\n+            .expect(\"Couldn't create directory for doctest executables\");\n \n-        let res = panic::catch_unwind(AssertUnwindSafe(|| {\n-            driver::compile_input(\n-                codegen_backend,\n-                &sess,\n-                &cstore,\n-                &None,\n-                &input,\n-                &None,\n-                &out,\n-                None,\n-                &control\n-            )\n-        }));\n-\n-        let compile_result = match res {\n-            Ok(Ok(())) | Ok(Err(CompileIncomplete::Stopped)) => Ok(()),\n-            Err(_) | Ok(Err(CompileIncomplete::Errored(_))) => Err(())\n-        };\n+        DirState::Perm(path)\n+    } else {\n+        DirState::Temp(TempFileBuilder::new()\n+                        .prefix(\"rustdoctest\")\n+                        .tempdir()\n+                        .expect(\"rustdoc needs a tempdir\"))\n+    };\n+    let output_file = outdir.path().join(\"rust_out\");\n+\n+    let config = interface::Config {\n+        opts: sessopts,\n+        crate_cfg: config::parse_cfgspecs(cfgs),\n+        input,\n+        input_path: None,\n+        output_file: Some(output_file.clone()),\n+        output_dir: None,\n+        file_loader: None,\n+        diagnostic_output: DiagnosticOutput::Raw(box Sink(data.clone())),\n+        stderr: Some(data.clone()),\n+        crate_name: None,\n+        lint_caps: Default::default(),\n+    };\n \n-        (outdir, compile_result)\n-    });\n+    let compile_result = panic::catch_unwind(AssertUnwindSafe(|| {\n+        interface::run_compiler(config, |compiler| {\n+            if no_run {\n+                compiler.global_ctxt().and_then(|global_ctxt| global_ctxt.take().enter(|tcx| {\n+                    tcx.analysis(LOCAL_CRATE)\n+                })).ok();\n+            } else {\n+                compiler.compile().ok();\n+            };\n+            compiler.session().compile_status()\n+        })\n+    })).map_err(|_| ()).and_then(|s| s.map_err(|_| ()));\n \n     match (compile_result, compile_fail) {\n         (Ok(()), true) => {\n             panic!(\"test compiled while it wasn't supposed to\")\n         }\n         (Ok(()), false) => {}\n-        (Err(()), true) => {\n+        (Err(_), true) => {\n             if error_codes.len() > 0 {\n                 let out = String::from_utf8(data.lock().unwrap().to_vec()).unwrap();\n                 error_codes.retain(|err| !out.contains(err));\n             }\n         }\n-        (Err(()), false) => {\n+        (Err(_), false) => {\n             panic!(\"couldn't compile the test\")\n         }\n     }\n@@ -360,7 +318,8 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n     if no_run { return }\n \n     // Run the code!\n-    let mut cmd = Command::new(&outdir.lock().unwrap().path().join(\"rust_out\"));\n+    let mut cmd = Command::new(output_file);\n+\n     match cmd.output() {\n         Err(e) => panic!(\"couldn't run the test: {}{}\", e,\n                         if e.kind() == io::ErrorKind::PermissionDenied {\n@@ -735,35 +694,26 @@ impl Tester for Collector {\n                 allow_fail: config.allow_fail,\n             },\n             testfn: testing::DynTestFn(box move || {\n-                let panic = io::set_panic(None);\n-                let print = io::set_print(None);\n-                match {\n-                    rustc_driver::in_named_rustc_thread(name, move || with_globals(move || {\n-                        io::set_panic(panic);\n-                        io::set_print(print);\n-                        run_test(&test,\n-                                 &cratename,\n-                                 &filename,\n-                                 line,\n-                                 cfgs,\n-                                 libs,\n-                                 cg,\n-                                 externs,\n-                                 config.should_panic,\n-                                 config.no_run,\n-                                 config.test_harness,\n-                                 config.compile_fail,\n-                                 config.error_codes,\n-                                 &opts,\n-                                 maybe_sysroot,\n-                                 linker,\n-                                 edition,\n-                                 persist_doctests)\n-                    }))\n-                } {\n-                    Ok(()) => (),\n-                    Err(err) => panic::resume_unwind(err),\n-                }\n+                run_test(\n+                    &test,\n+                    &cratename,\n+                    &filename,\n+                    line,\n+                    cfgs,\n+                    libs,\n+                    cg,\n+                    externs,\n+                    config.should_panic,\n+                    config.no_run,\n+                    config.test_harness,\n+                    config.compile_fail,\n+                    config.error_codes,\n+                    &opts,\n+                    maybe_sysroot,\n+                    linker,\n+                    edition,\n+                    persist_doctests\n+                )\n             }),\n         });\n     }"}, {"sha": "0c99f6ddeddf1262aff5b63b1598972b27809c45", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -27,21 +27,21 @@ use crate::doctree::*;\n // Also, is there some reason that this doesn't use the 'visit'\n // framework from syntax?.\n \n-pub struct RustdocVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n+pub struct RustdocVisitor<'a, 'tcx> {\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n-    pub cx: &'a core::DocContext<'a, 'tcx, 'rcx>,\n+    pub cx: &'a core::DocContext<'tcx>,\n     view_item_stack: FxHashSet<ast::NodeId>,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n     exact_paths: Option<FxHashMap<DefId, Vec<String>>>,\n }\n \n-impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n+impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub fn new(\n-        cx: &'a core::DocContext<'a, 'tcx, 'rcx>\n-    ) -> RustdocVisitor<'a, 'tcx, 'rcx> {\n+        cx: &'a core::DocContext<'tcx>\n+    ) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n         let mut stack = FxHashSet::default();\n         stack.insert(ast::CRATE_NODE_ID);\n@@ -269,7 +269,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                           om: &mut Module,\n                           please_inline: bool) -> bool {\n \n-        fn inherits_doc_hidden(cx: &core::DocContext<'_, '_, '_>, mut node: ast::NodeId) -> bool {\n+        fn inherits_doc_hidden(cx: &core::DocContext<'_>, mut node: ast::NodeId) -> bool {\n             while let Some(id) = cx.tcx.hir().get_enclosing_scope(node) {\n                 node = id;\n                 if cx.tcx.hir().attrs(node).lists(\"doc\").has_word(\"hidden\") {"}, {"sha": "def6f8b557b51b6b7793076c4d5058bc80c20d1b", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -12,8 +12,8 @@ use crate::clean::{AttributesExt, NestedAttributesExt};\n \n /// Similar to `librustc_privacy::EmbargoVisitor`, but also takes\n /// specific rustdoc annotations into account (i.e., `doc(hidden)`)\n-pub struct LibEmbargoVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n-    cx: &'a crate::core::DocContext<'a, 'tcx, 'rcx>,\n+pub struct LibEmbargoVisitor<'a, 'tcx> {\n+    cx: &'a crate::core::DocContext<'tcx>,\n     // Accessibility levels for reachable nodes\n     access_levels: RefMut<'a, AccessLevels<DefId>>,\n     // Previous accessibility level, None means unreachable\n@@ -22,10 +22,10 @@ pub struct LibEmbargoVisitor<'a, 'tcx: 'a, 'rcx: 'a> {\n     visited_mods: FxHashSet<DefId>,\n }\n \n-impl<'a, 'tcx, 'rcx> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n+impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n     pub fn new(\n-        cx: &'a crate::core::DocContext<'a, 'tcx, 'rcx>\n-    ) -> LibEmbargoVisitor<'a, 'tcx, 'rcx> {\n+        cx: &'a crate::core::DocContext<'tcx>\n+    ) -> LibEmbargoVisitor<'a, 'tcx> {\n         LibEmbargoVisitor {\n             cx,\n             access_levels: RefMut::map(cx.renderinfo.borrow_mut(), |ri| &mut ri.access_levels),"}, {"sha": "626fceb581436477fff657af5843ecbabfc44388", "filename": "src/rustc/rustc.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Frustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Frustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -1,14 +1,3 @@\n-#![feature(link_args)]\n-\n-// Set the stack size at link time on Windows. See rustc_driver::in_rustc_thread\n-// for the rationale.\n-#[allow(unused_attributes)]\n-#[cfg_attr(all(windows, target_env = \"msvc\"), link_args = \"/STACK:16777216\")]\n-// We only build for msvc and gnu now, but we use a exhaustive condition here\n-// so we can expect either the stack size to be set or the build fails.\n-#[cfg_attr(all(windows, not(target_env = \"msvc\")), link_args = \"-Wl,--stack,16777216\")]\n-// Also, don't forget to set this for rustdoc.\n-extern {}\n \n fn main() {\n     // Pull in jemalloc when enabled."}, {"sha": "641ff18d37e9bb8572674a67c7dc5d645aa6411b", "filename": "src/test/run-make-fulldeps/hotplug_codegen_backend/the_backend.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fhotplug_codegen_backend%2Fthe_backend.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -7,12 +7,13 @@ extern crate rustc_codegen_utils;\n use std::any::Any;\n use std::sync::mpsc;\n use syntax::symbol::Symbol;\n-use rustc::session::{Session, CompileIncomplete};\n+use rustc::session::Session;\n use rustc::session::config::OutputFilenames;\n use rustc::ty::TyCtxt;\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::MetadataLoader;\n use rustc::dep_graph::DepGraph;\n+use rustc::util::common::ErrorReported;\n use rustc_codegen_utils::codegen_backend::{CodegenBackend, MetadataOnlyCodegenBackend};\n \n struct TheBackend(Box<CodegenBackend>);\n@@ -46,7 +47,7 @@ impl CodegenBackend for TheBackend {\n         sess: &Session,\n         _dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n-    ) -> Result<(), CompileIncomplete> {\n+    ) -> Result<(), ErrorReported> {\n         use std::io::Write;\n         use rustc::session::config::CrateType;\n         use rustc_codegen_utils::link::out_filename;"}, {"sha": "0cbdf40e2f908747738952de53211255a17a6031", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 29, "deletions": 45, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -1,26 +1,16 @@\n #![feature(rustc_private)]\n \n extern crate rustc;\n-extern crate rustc_driver;\n-extern crate rustc_lint;\n-extern crate rustc_metadata;\n-extern crate rustc_errors;\n-extern crate rustc_codegen_utils;\n extern crate rustc_interface;\n extern crate syntax;\n \n-use rustc::session::{build_session, Session};\n+use rustc::session::DiagnosticOutput;\n use rustc::session::config::{Input, Options,\n                              OutputType, OutputTypes};\n-use rustc_driver::driver::{self, compile_input, CompileController};\n-use rustc_metadata::cstore::CStore;\n-use rustc_errors::registry::Registry;\n-use rustc_interface::util;\n+use rustc_interface::interface;\n use syntax::source_map::FileName;\n-use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n use std::path::PathBuf;\n-use std::rc::Rc;\n \n fn main() {\n     let src = r#\"\n@@ -44,39 +34,33 @@ fn main() {\n     compile(src.to_string(), tmpdir.join(\"out\"), sysroot.clone());\n }\n \n-fn basic_sess(opts: Options) -> (Session, Rc<CStore>, Box<CodegenBackend>) {\n-    let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n-    let sess = build_session(opts, None, descriptions);\n-    let codegen_backend = util::get_codegen_backend(&sess);\n-    let cstore = Rc::new(CStore::new(codegen_backend.metadata_loader()));\n-    rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-    (sess, cstore, codegen_backend)\n-}\n-\n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n-    syntax::with_globals(|| {\n-        let mut opts = Options::default();\n-        opts.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n-        opts.maybe_sysroot = Some(sysroot);\n-        if let Ok(linker) = std::env::var(\"RUSTC_LINKER\") {\n-            opts.cg.linker = Some(linker.into());\n-        }\n-        driver::spawn_thread_pool(opts, |opts| {\n-            let (sess, cstore, codegen_backend) = basic_sess(opts);\n-            let control = CompileController::basic();\n-            let name = FileName::anon_source_code(&code);\n-            let input = Input::Str { name, input: code };\n-            let _ = compile_input(\n-                codegen_backend,\n-                &sess,\n-                &cstore,\n-                &None,\n-                &input,\n-                &None,\n-                &Some(output),\n-                None,\n-                &control\n-            );\n-        });\n+    let mut opts = Options::default();\n+    opts.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n+    opts.maybe_sysroot = Some(sysroot);\n+\n+    if let Ok(linker) = std::env::var(\"RUSTC_LINKER\") {\n+        opts.cg.linker = Some(linker.into());\n+    }\n+\n+    let name = FileName::anon_source_code(&code);\n+    let input = Input::Str { name, input: code };\n+\n+    let config = interface::Config {\n+        opts,\n+        crate_cfg: Default::default(),\n+        input,\n+        input_path: None,\n+        output_file: Some(output),\n+        output_dir: None,\n+        file_loader: None,\n+        diagnostic_output: DiagnosticOutput::Default,\n+        stderr: None,\n+        crate_name: None,\n+        lint_caps: Default::default(),\n+    };\n+\n+    interface::run_compiler(config, |compiler| {\n+        compiler.compile().ok();\n     });\n }"}, {"sha": "b4731bbaeb5cab4fc23551bbfd0b43e6d92a15e4", "filename": "src/test/run-pass-fulldeps/compiler-calls.rs", "status": "modified", "additions": 10, "deletions": 71, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fcompiler-calls.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -1,91 +1,30 @@\n-// Test that the CompilerCalls interface to the compiler works.\n+// Test that the Callbacks interface to the compiler works.\n \n // ignore-cross-compile\n // ignore-stage1\n \n #![feature(rustc_private)]\n \n-extern crate getopts;\n-extern crate rustc;\n extern crate rustc_driver;\n-extern crate rustc_codegen_utils;\n-extern crate syntax;\n-extern crate rustc_errors as errors;\n-extern crate rustc_metadata;\n+extern crate rustc_interface;\n \n-use rustc::session::Session;\n-use rustc::session::config::{self, Input};\n-use rustc_driver::{driver, CompilerCalls, Compilation};\n-use rustc_codegen_utils::codegen_backend::CodegenBackend;\n-use rustc_metadata::cstore::CStore;\n-use syntax::ast;\n-\n-use std::path::PathBuf;\n+use rustc_interface::interface;\n \n struct TestCalls<'a> {\n     count: &'a mut u32\n }\n \n-impl<'a> CompilerCalls<'a> for TestCalls<'a> {\n-    fn early_callback(&mut self,\n-                      _: &getopts::Matches,\n-                      _: &config::Options,\n-                      _: &ast::CrateConfig,\n-                      _: &errors::registry::Registry,\n-                      _: config::ErrorOutputType)\n-                      -> Compilation {\n+impl rustc_driver::Callbacks for TestCalls<'_> {\n+    fn config(&mut self, _config: &mut interface::Config) {\n         *self.count *= 2;\n-        Compilation::Continue\n-    }\n-\n-    fn late_callback(&mut self,\n-                     _: &CodegenBackend,\n-                     _: &getopts::Matches,\n-                     _: &Session,\n-                     _: &CStore,\n-                     _: &Input,\n-                     _: &Option<PathBuf>,\n-                     _: &Option<PathBuf>)\n-                     -> Compilation {\n-        *self.count *= 3;\n-        Compilation::Stop\n-    }\n-\n-    fn some_input(&mut self, input: Input, input_path: Option<PathBuf>)\n-                  -> (Input, Option<PathBuf>) {\n-        *self.count *= 5;\n-        (input, input_path)\n-    }\n-\n-    fn no_input(&mut self,\n-                _: &getopts::Matches,\n-                _: &config::Options,\n-                _: &ast::CrateConfig,\n-                _: &Option<PathBuf>,\n-                _: &Option<PathBuf>,\n-                _: &errors::registry::Registry)\n-                -> Option<(Input, Option<PathBuf>)> {\n-        panic!(\"This shouldn't happen\");\n-    }\n-\n-    fn build_controller(self: Box<Self>,\n-                        _: &Session,\n-                        _: &getopts::Matches)\n-                        -> driver::CompileController<'a> {\n-        panic!(\"This shouldn't be called\");\n     }\n }\n \n-\n fn main() {\n     let mut count = 1;\n-    {\n-        let tc = TestCalls { count: &mut count };\n-        // we should never get use this filename, but lets make sure they are valid args.\n-        let args = vec![\"compiler-calls\".to_string(), \"foo.rs\".to_string()];\n-        syntax::with_globals(|| {\n-            rustc_driver::run_compiler(&args, Box::new(tc), None, None);\n-        });\n-    }\n-    assert_eq!(count, 30);\n+    let args = vec![\"compiler-calls\".to_string(), \"foo.rs\".to_string()];\n+    rustc_driver::report_ices_to_stderr_if_any(|| {\n+        rustc_driver::run_compiler(&args, &mut TestCalls { count: &mut count }, None, None).ok();\n+    }).ok();\n+    assert_eq!(count, 2);\n }"}, {"sha": "d2c4a28ce980a8a3ae52a05fc90464e96c8c54a3", "filename": "src/test/rustdoc-ui/deny-intra-link-resolution-failure.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-intra-link-resolution-failure.stderr?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -11,3 +11,5 @@ LL | #![deny(intra_doc_link_resolution_failure)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n+error: aborting due to previous error\n+"}, {"sha": "4cc0f4b4128fb5119e57d753462bd32795b9c64d", "filename": "src/test/rustdoc-ui/deny-missing-docs-crate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -18,5 +18,5 @@ error: missing documentation for a struct\n LL | pub struct Foo; //~ ERROR\n    | ^^^^^^^^^^^^^^^\n \n-error: Compilation failed, aborting rustdoc\n+error: aborting due to 2 previous errors\n "}, {"sha": "ce9584a4bb0cef8f4fbcec0136ee3e41b2347139", "filename": "src/test/rustdoc-ui/deny-missing-docs-macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.stderr?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -10,5 +10,5 @@ note: lint level defined here\n LL | #![deny(missing_docs)]\n    |         ^^^^^^^^^^^^\n \n-error: Compilation failed, aborting rustdoc\n+error: aborting due to previous error\n "}, {"sha": "208bdedf24ddb6b10aebd044bdfc6b5118fb770e", "filename": "src/test/rustdoc-ui/doc-without-codeblock.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -24,3 +24,5 @@ error: Missing code example in this documentation\n LL |     /// Or maybe not because she saved herself!\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: aborting due to 4 previous errors\n+"}, {"sha": "c9f59405ce0123d616abfb5fb7840c093d22e163", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -12,7 +12,10 @@ error[E0425]: cannot find value `no` in this scope\n 3 | no\n   | ^^ not found in this scope\n \n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:352:13\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`.\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:310:13\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 11) stdout ----\n@@ -21,7 +24,7 @@ thread '$DIR/failed-doctest-output.rs - SomeStruct (line 11)' panicked at 'test\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n-', src/librustdoc/test.rs:373:17\n+', src/librustdoc/test.rs:332:17\n \n \n failures:"}, {"sha": "12a56dcc4a5ef121ffd183257439bbae5e480d2a", "filename": "src/test/rustdoc-ui/intra-doc-alias-ice.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-doc-alias-ice.stderr?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -11,3 +11,5 @@ LL | #![deny(intra_doc_link_resolution_failure)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n+error: aborting due to previous error\n+"}, {"sha": "93c05a0c4dd29839f2ff0448e8fc2090d3a65058", "filename": "src/test/rustdoc-ui/intra-link-span-ice-55723.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-link-span-ice-55723.stderr?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -11,3 +11,5 @@ LL | #![deny(intra_doc_link_resolution_failure)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: to escape `[` and `]` characters, just add '/' before them like `/[` or `/]`\n \n+error: aborting due to previous error\n+"}, {"sha": "76a9133147eac4486f99a79da4c7d664627b524b", "filename": "src/test/rustdoc-ui/lint-group.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-group.stderr?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -42,3 +42,5 @@ LL | #![deny(rustdoc)]\n    |         ^^^^^^^\n    = note: #[deny(missing_doc_code_examples)] implied by #[deny(rustdoc)]\n \n+error: aborting due to 3 previous errors\n+"}, {"sha": "20f3eb8b12025eb201e156f3522c9ea9312dd57c", "filename": "src/test/rustdoc-ui/private-item-doc-test.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fprivate-item-doc-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftest%2Frustdoc-ui%2Fprivate-item-doc-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fprivate-item-doc-test.stderr?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -14,3 +14,5 @@ note: lint level defined here\n LL | #![deny(private_doc_tests)]\n    |         ^^^^^^^^^^^^^^^^^\n \n+error: aborting due to previous error\n+"}, {"sha": "8171708e99d004e3bd161007152f0e24588ebbc0", "filename": "src/tools/rustdoc/main.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftools%2Frustdoc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51938c61f6f1b26e463f9071716f543543486e72/src%2Ftools%2Frustdoc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc%2Fmain.rs?ref=51938c61f6f1b26e463f9071716f543543486e72", "patch": "@@ -1,15 +1,3 @@\n #![deny(rust_2018_idioms)]\n \n-#![feature(link_args)]\n-\n-#[allow(unused_attributes)]\n-// Set the stack size at link time on Windows. See rustc_driver::in_rustc_thread\n-// for the rationale.\n-#[cfg_attr(all(windows, target_env = \"msvc\"), link_args = \"/STACK:16777216\")]\n-// We only build for msvc and gnu now, but we use a exhaustive condition here\n-// so we can expect either the stack size to be set or the build fails.\n-#[cfg_attr(all(windows, not(target_env = \"msvc\")), link_args = \"-Wl,--stack,16777216\")]\n-// See src/rustc/rustc.rs for the corresponding rustc settings.\n-extern {}\n-\n fn main() { rustdoc::main() }"}]}