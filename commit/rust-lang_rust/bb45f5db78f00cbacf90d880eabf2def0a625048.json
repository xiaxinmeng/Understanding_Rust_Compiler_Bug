{"sha": "bb45f5db78f00cbacf90d880eabf2def0a625048", "node_id": "C_kwDOAAsO6NoAKGJiNDVmNWRiNzhmMDBjYmFjZjkwZDg4MGVhYmYyZGVmMGE2MjUwNDg", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-25T10:49:29Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-12T10:47:50Z"}, "message": "Remove the RustcDefaultCalls struct\n\nIt is a leftover from before the introduction of rustc_interface", "tree": {"sha": "c07ec4518b957cbff33ead237d0b3cbd44c1ae34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c07ec4518b957cbff33ead237d0b3cbd44c1ae34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb45f5db78f00cbacf90d880eabf2def0a625048", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb45f5db78f00cbacf90d880eabf2def0a625048", "html_url": "https://github.com/rust-lang/rust/commit/bb45f5db78f00cbacf90d880eabf2def0a625048", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb45f5db78f00cbacf90d880eabf2def0a625048/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cdefd763b910ffd1d42233a8c752ab5fd84ca4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cdefd763b910ffd1d42233a8c752ab5fd84ca4d", "html_url": "https://github.com/rust-lang/rust/commit/9cdefd763b910ffd1d42233a8c752ab5fd84ca4d"}], "stats": {"total": 289, "additions": 138, "deletions": 151}, "files": [{"sha": "7eeae66d709e9baeab17dfa5d5b36295fe90dcf8", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 138, "deletions": 151, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/bb45f5db78f00cbacf90d880eabf2def0a625048/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb45f5db78f00cbacf90d880eabf2def0a625048/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=bb45f5db78f00cbacf90d880eabf2def0a625048", "patch": "@@ -263,7 +263,7 @@ fn run_compiler(\n                         describe_lints(compiler.session(), &lint_store, registered_lints);\n                         return;\n                     }\n-                    let should_stop = RustcDefaultCalls::print_crate_info(\n+                    let should_stop = print_crate_info(\n                         &***compiler.codegen_backend(),\n                         compiler.session(),\n                         None,\n@@ -292,7 +292,7 @@ fn run_compiler(\n \n     interface::run_compiler(config, |compiler| {\n         let sess = compiler.session();\n-        let should_stop = RustcDefaultCalls::print_crate_info(\n+        let should_stop = print_crate_info(\n             &***compiler.codegen_backend(),\n             sess,\n             Some(compiler.input()),\n@@ -301,13 +301,9 @@ fn run_compiler(\n             compiler.temps_dir(),\n         )\n         .and_then(|| {\n-            RustcDefaultCalls::list_metadata(\n-                sess,\n-                &*compiler.codegen_backend().metadata_loader(),\n-                compiler.input(),\n-            )\n+            list_metadata(sess, &*compiler.codegen_backend().metadata_loader(), compiler.input())\n         })\n-        .and_then(|| RustcDefaultCalls::try_process_rlink(sess, compiler));\n+        .and_then(|| try_process_rlink(sess, compiler));\n \n         if should_stop == Compilation::Stop {\n             return sess.compile_status();\n@@ -512,10 +508,6 @@ impl Compilation {\n     }\n }\n \n-/// CompilerCalls instance for a regular rustc build.\n-#[derive(Copy, Clone)]\n-pub struct RustcDefaultCalls;\n-\n fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n     let upper_cased_code = code.to_ascii_uppercase();\n     let normalised = if upper_cased_code.starts_with('E') {\n@@ -588,162 +580,157 @@ fn show_content_with_pager(content: &str) {\n     }\n }\n \n-impl RustcDefaultCalls {\n-    pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n-        if sess.opts.debugging_opts.link_only {\n-            if let Input::File(file) = compiler.input() {\n-                // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n-                sess.init_crate_types(collect_crate_types(sess, &[]));\n-                let outputs = compiler.build_output_filenames(sess, &[]);\n-                let rlink_data = fs::read(file).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n-                });\n-                let mut decoder = rustc_serialize::opaque::Decoder::new(&rlink_data, 0);\n-                let codegen_results: CodegenResults =\n-                    rustc_serialize::Decodable::decode(&mut decoder);\n-                let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n-                abort_on_err(result, sess);\n-            } else {\n-                sess.fatal(\"rlink must be a file\")\n-            }\n-            Compilation::Stop\n+pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n+    if sess.opts.debugging_opts.link_only {\n+        if let Input::File(file) = compiler.input() {\n+            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n+            sess.init_crate_types(collect_crate_types(sess, &[]));\n+            let outputs = compiler.build_output_filenames(sess, &[]);\n+            let rlink_data = fs::read(file).unwrap_or_else(|err| {\n+                sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n+            });\n+            let mut decoder = rustc_serialize::opaque::Decoder::new(&rlink_data, 0);\n+            let codegen_results: CodegenResults = rustc_serialize::Decodable::decode(&mut decoder);\n+            let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n+            abort_on_err(result, sess);\n         } else {\n-            Compilation::Continue\n+            sess.fatal(\"rlink must be a file\")\n         }\n+        Compilation::Stop\n+    } else {\n+        Compilation::Continue\n     }\n+}\n \n-    pub fn list_metadata(\n-        sess: &Session,\n-        metadata_loader: &dyn MetadataLoader,\n-        input: &Input,\n-    ) -> Compilation {\n-        if sess.opts.debugging_opts.ls {\n-            match *input {\n-                Input::File(ref ifile) => {\n-                    let path = &(*ifile);\n-                    let mut v = Vec::new();\n-                    locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v)\n-                        .unwrap();\n-                    println!(\"{}\", String::from_utf8(v).unwrap());\n-                }\n-                Input::Str { .. } => {\n-                    early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n-                }\n+pub fn list_metadata(\n+    sess: &Session,\n+    metadata_loader: &dyn MetadataLoader,\n+    input: &Input,\n+) -> Compilation {\n+    if sess.opts.debugging_opts.ls {\n+        match *input {\n+            Input::File(ref ifile) => {\n+                let path = &(*ifile);\n+                let mut v = Vec::new();\n+                locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v).unwrap();\n+                println!(\"{}\", String::from_utf8(v).unwrap());\n+            }\n+            Input::Str { .. } => {\n+                early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n             }\n-            return Compilation::Stop;\n         }\n-\n-        Compilation::Continue\n+        return Compilation::Stop;\n     }\n \n-    fn print_crate_info(\n-        codegen_backend: &dyn CodegenBackend,\n-        sess: &Session,\n-        input: Option<&Input>,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        temps_dir: &Option<PathBuf>,\n-    ) -> Compilation {\n-        use rustc_session::config::PrintRequest::*;\n-        // NativeStaticLibs and LinkArgs are special - printed during linking\n-        // (empty iterator returns true)\n-        if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n-            return Compilation::Continue;\n-        }\n+    Compilation::Continue\n+}\n \n-        let attrs = match input {\n-            None => None,\n-            Some(input) => {\n-                let result = parse_crate_attrs(sess, input);\n-                match result {\n-                    Ok(attrs) => Some(attrs),\n-                    Err(mut parse_error) => {\n-                        parse_error.emit();\n-                        return Compilation::Stop;\n-                    }\n+fn print_crate_info(\n+    codegen_backend: &dyn CodegenBackend,\n+    sess: &Session,\n+    input: Option<&Input>,\n+    odir: &Option<PathBuf>,\n+    ofile: &Option<PathBuf>,\n+    temps_dir: &Option<PathBuf>,\n+) -> Compilation {\n+    use rustc_session::config::PrintRequest::*;\n+    // NativeStaticLibs and LinkArgs are special - printed during linking\n+    // (empty iterator returns true)\n+    if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n+        return Compilation::Continue;\n+    }\n+\n+    let attrs = match input {\n+        None => None,\n+        Some(input) => {\n+            let result = parse_crate_attrs(sess, input);\n+            match result {\n+                Ok(attrs) => Some(attrs),\n+                Err(mut parse_error) => {\n+                    parse_error.emit();\n+                    return Compilation::Stop;\n                 }\n             }\n-        };\n-        for req in &sess.opts.prints {\n-            match *req {\n-                TargetList => {\n-                    let mut targets =\n-                        rustc_target::spec::TARGETS.iter().copied().collect::<Vec<_>>();\n-                    targets.sort_unstable();\n-                    println!(\"{}\", targets.join(\"\\n\"));\n-                }\n-                Sysroot => println!(\"{}\", sess.sysroot.display()),\n-                TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n-                TargetSpec => println!(\"{}\", sess.target.to_json().pretty()),\n-                FileNames | CrateName => {\n-                    let input = input.unwrap_or_else(|| {\n-                        early_error(ErrorOutputType::default(), \"no input file provided\")\n-                    });\n-                    let attrs = attrs.as_ref().unwrap();\n-                    let t_outputs = rustc_interface::util::build_output_filenames(\n-                        input, odir, ofile, temps_dir, attrs, sess,\n-                    );\n-                    let id = rustc_session::output::find_crate_name(sess, attrs, input);\n-                    if *req == PrintRequest::CrateName {\n-                        println!(\"{}\", id);\n-                        continue;\n-                    }\n-                    let crate_types = collect_crate_types(sess, attrs);\n-                    for &style in &crate_types {\n-                        let fname =\n-                            rustc_session::output::filename_for_input(sess, style, &id, &t_outputs);\n-                        println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n-                    }\n+        }\n+    };\n+    for req in &sess.opts.prints {\n+        match *req {\n+            TargetList => {\n+                let mut targets = rustc_target::spec::TARGETS.iter().copied().collect::<Vec<_>>();\n+                targets.sort_unstable();\n+                println!(\"{}\", targets.join(\"\\n\"));\n+            }\n+            Sysroot => println!(\"{}\", sess.sysroot.display()),\n+            TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n+            TargetSpec => println!(\"{}\", sess.target.to_json().pretty()),\n+            FileNames | CrateName => {\n+                let input = input.unwrap_or_else(|| {\n+                    early_error(ErrorOutputType::default(), \"no input file provided\")\n+                });\n+                let attrs = attrs.as_ref().unwrap();\n+                let t_outputs = rustc_interface::util::build_output_filenames(\n+                    input, odir, ofile, temps_dir, attrs, sess,\n+                );\n+                let id = rustc_session::output::find_crate_name(sess, attrs, input);\n+                if *req == PrintRequest::CrateName {\n+                    println!(\"{}\", id);\n+                    continue;\n                 }\n-                Cfg => {\n-                    let mut cfgs = sess\n-                        .parse_sess\n-                        .config\n-                        .iter()\n-                        .filter_map(|&(name, value)| {\n-                            // Note that crt-static is a specially recognized cfg\n-                            // directive that's printed out here as part of\n-                            // rust-lang/rust#37406, but in general the\n-                            // `target_feature` cfg is gated under\n-                            // rust-lang/rust#29717. For now this is just\n-                            // specifically allowing the crt-static cfg and that's\n-                            // it, this is intended to get into Cargo and then go\n-                            // through to build scripts.\n-                            if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n-                                && !sess.is_nightly_build()\n-                                && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n-                            {\n-                                return None;\n-                            }\n-\n-                            if let Some(value) = value {\n-                                Some(format!(\"{}=\\\"{}\\\"\", name, value))\n-                            } else {\n-                                Some(name.to_string())\n-                            }\n-                        })\n-                        .collect::<Vec<String>>();\n-\n-                    cfgs.sort();\n-                    for cfg in cfgs {\n-                        println!(\"{}\", cfg);\n-                    }\n+                let crate_types = collect_crate_types(sess, attrs);\n+                for &style in &crate_types {\n+                    let fname =\n+                        rustc_session::output::filename_for_input(sess, style, &id, &t_outputs);\n+                    println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n                 }\n-                RelocationModels\n-                | CodeModels\n-                | TlsModels\n-                | TargetCPUs\n-                | StackProtectorStrategies\n-                | TargetFeatures => {\n-                    codegen_backend.print(*req, sess);\n+            }\n+            Cfg => {\n+                let mut cfgs = sess\n+                    .parse_sess\n+                    .config\n+                    .iter()\n+                    .filter_map(|&(name, value)| {\n+                        // Note that crt-static is a specially recognized cfg\n+                        // directive that's printed out here as part of\n+                        // rust-lang/rust#37406, but in general the\n+                        // `target_feature` cfg is gated under\n+                        // rust-lang/rust#29717. For now this is just\n+                        // specifically allowing the crt-static cfg and that's\n+                        // it, this is intended to get into Cargo and then go\n+                        // through to build scripts.\n+                        if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n+                            && !sess.is_nightly_build()\n+                            && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n+                        {\n+                            return None;\n+                        }\n+\n+                        if let Some(value) = value {\n+                            Some(format!(\"{}=\\\"{}\\\"\", name, value))\n+                        } else {\n+                            Some(name.to_string())\n+                        }\n+                    })\n+                    .collect::<Vec<String>>();\n+\n+                cfgs.sort();\n+                for cfg in cfgs {\n+                    println!(\"{}\", cfg);\n                 }\n-                // Any output here interferes with Cargo's parsing of other printed output\n-                NativeStaticLibs => {}\n-                LinkArgs => {}\n             }\n+            RelocationModels\n+            | CodeModels\n+            | TlsModels\n+            | TargetCPUs\n+            | StackProtectorStrategies\n+            | TargetFeatures => {\n+                codegen_backend.print(*req, sess);\n+            }\n+            // Any output here interferes with Cargo's parsing of other printed output\n+            NativeStaticLibs => {}\n+            LinkArgs => {}\n         }\n-        Compilation::Stop\n     }\n+    Compilation::Stop\n }\n \n /// Prints version information"}]}