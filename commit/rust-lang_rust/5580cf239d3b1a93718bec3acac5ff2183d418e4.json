{"sha": "5580cf239d3b1a93718bec3acac5ff2183d418e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1ODBjZjIzOWQzYjFhOTM3MThiZWMzYWNhYzVmZjIxODNkNDE4ZTQ=", "commit": {"author": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-02-06T14:34:37Z"}, "committer": {"name": "Andrea Pretto", "email": "eulerdisk@gmail.com", "date": "2019-02-09T10:29:59Z"}, "message": "auto_import assist", "tree": {"sha": "4e4147f0458d4bb4c293273efc0c7af4ea7ba3d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e4147f0458d4bb4c293273efc0c7af4ea7ba3d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5580cf239d3b1a93718bec3acac5ff2183d418e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5580cf239d3b1a93718bec3acac5ff2183d418e4", "html_url": "https://github.com/rust-lang/rust/commit/5580cf239d3b1a93718bec3acac5ff2183d418e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5580cf239d3b1a93718bec3acac5ff2183d418e4/comments", "author": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eulerdisk", "id": 10089822, "node_id": "MDQ6VXNlcjEwMDg5ODIy", "avatar_url": "https://avatars.githubusercontent.com/u/10089822?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eulerdisk", "html_url": "https://github.com/eulerdisk", "followers_url": "https://api.github.com/users/eulerdisk/followers", "following_url": "https://api.github.com/users/eulerdisk/following{/other_user}", "gists_url": "https://api.github.com/users/eulerdisk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eulerdisk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eulerdisk/subscriptions", "organizations_url": "https://api.github.com/users/eulerdisk/orgs", "repos_url": "https://api.github.com/users/eulerdisk/repos", "events_url": "https://api.github.com/users/eulerdisk/events{/privacy}", "received_events_url": "https://api.github.com/users/eulerdisk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34398a8756b56c323d3b4b2ef32fbca32d88a105", "url": "https://api.github.com/repos/rust-lang/rust/commits/34398a8756b56c323d3b4b2ef32fbca32d88a105", "html_url": "https://github.com/rust-lang/rust/commit/34398a8756b56c323d3b4b2ef32fbca32d88a105"}], "stats": {"total": 785, "additions": 785, "deletions": 0}, "files": [{"sha": "40621e89164fe056f0ff12d72d29c08b9b19f0ed", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5580cf239d3b1a93718bec3acac5ff2183d418e4/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5580cf239d3b1a93718bec3acac5ff2183d418e4/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=5580cf239d3b1a93718bec3acac5ff2183d418e4", "patch": "@@ -900,6 +900,7 @@ version = \"0.1.0\"\n name = \"ra_assists\"\n version = \"0.1.0\"\n dependencies = [\n+ \"itertools 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ra_db 0.1.0\",\n  \"ra_fmt 0.1.0\","}, {"sha": "a5808d5b7f245d9c3e6f4707010f277695800f09", "filename": "crates/ra_assists/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5580cf239d3b1a93718bec3acac5ff2183d418e4/crates%2Fra_assists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5580cf239d3b1a93718bec3acac5ff2183d418e4/crates%2Fra_assists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2FCargo.toml?ref=5580cf239d3b1a93718bec3acac5ff2183d418e4", "patch": "@@ -6,6 +6,7 @@ authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n \n [dependencies]\n join_to_string = \"0.1.3\"\n+itertools = \"0.8.0\"\n \n ra_syntax = { path = \"../ra_syntax\" }\n ra_text_edit = { path = \"../ra_text_edit\" }"}, {"sha": "4cac5a926403f201947c4d9a7d7973d2c261bdac", "filename": "crates/ra_assists/src/auto_import.rs", "status": "added", "additions": 780, "deletions": 0, "changes": 780, "blob_url": "https://github.com/rust-lang/rust/blob/5580cf239d3b1a93718bec3acac5ff2183d418e4/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580cf239d3b1a93718bec3acac5ff2183d418e4/crates%2Fra_assists%2Fsrc%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fauto_import.rs?ref=5580cf239d3b1a93718bec3acac5ff2183d418e4", "patch": "@@ -0,0 +1,780 @@\n+use hir::db::HirDatabase;\n+use ra_syntax::{\n+    ast, AstNode, SyntaxNode, Direction, TextRange,\n+    SyntaxKind::{ PATH, PATH_SEGMENT, COLONCOLON, COMMA }\n+};\n+use crate::assist_ctx::{AssistCtx, Assist, AssistBuilder};\n+use itertools::{ Itertools, EitherOrBoth };\n+\n+// TODO: refactor this before merge\n+mod formatting {\n+    use ra_syntax::{\n+        AstNode, SyntaxNode,\n+        ast::{self, AstToken},\n+        algo::generate,\n+};\n+\n+    /// If the node is on the beginning of the line, calculate indent.\n+    pub fn leading_indent(node: &SyntaxNode) -> Option<&str> {\n+        for leaf in prev_leaves(node) {\n+            if let Some(ws) = ast::Whitespace::cast(leaf) {\n+                let ws_text = ws.text();\n+                if let Some(pos) = ws_text.rfind('\\n') {\n+                    return Some(&ws_text[pos + 1..]);\n+                }\n+            }\n+            if leaf.leaf_text().unwrap().contains('\\n') {\n+                break;\n+            }\n+        }\n+        None\n+    }\n+\n+    fn prev_leaves(node: &SyntaxNode) -> impl Iterator<Item = &SyntaxNode> {\n+        generate(prev_leaf(node), |&node| prev_leaf(node))\n+    }\n+\n+    fn prev_leaf(node: &SyntaxNode) -> Option<&SyntaxNode> {\n+        generate(node.ancestors().find_map(SyntaxNode::prev_sibling), |it| {\n+            it.last_child()\n+        })\n+        .last()\n+    }\n+}\n+\n+fn collect_path_segments(path: &ast::Path) -> Option<Vec<&ast::PathSegment>> {\n+    let mut v = Vec::new();\n+    collect_path_segments_raw(&mut v, path)?;\n+    return Some(v);\n+}\n+\n+fn collect_path_segments_raw<'b, 'a: 'b>(\n+    segments: &'b mut Vec<&'a ast::PathSegment>,\n+    mut path: &'a ast::Path,\n+) -> Option<usize> {\n+    let oldlen = segments.len();\n+    loop {\n+        let mut children = path.syntax().children();\n+        let (first, second, third) = (\n+            children.next().map(|n| (n, n.kind())),\n+            children.next().map(|n| (n, n.kind())),\n+            children.next().map(|n| (n, n.kind())),\n+        );\n+        match (first, second, third) {\n+            (Some((subpath, PATH)), Some((_, COLONCOLON)), Some((segment, PATH_SEGMENT))) => {\n+                path = ast::Path::cast(subpath)?;\n+                segments.push(ast::PathSegment::cast(segment)?);\n+            }\n+            (Some((segment, PATH_SEGMENT)), _, _) => {\n+                segments.push(ast::PathSegment::cast(segment)?);\n+                break;\n+            }\n+            (_, _, _) => return None,\n+        }\n+    }\n+    // We need to reverse only the new added segments\n+    let only_new_segments = segments.split_at_mut(oldlen).1;\n+    only_new_segments.reverse();\n+    return Some(segments.len() - oldlen);\n+}\n+\n+fn fmt_segments(segments: &[&ast::PathSegment]) -> String {\n+    let mut buf = String::new();\n+    fmt_segments_raw(segments, &mut buf);\n+    return buf;\n+}\n+\n+fn fmt_segments_raw(segments: &[&ast::PathSegment], buf: &mut String) {\n+    let mut first = true;\n+    for s in segments {\n+        if !first {\n+            buf.push_str(\"::\");\n+        }\n+        match s.kind() {\n+            Some(ast::PathSegmentKind::Name(nameref)) => buf.push_str(nameref.text()),\n+            Some(ast::PathSegmentKind::SelfKw) => buf.push_str(\"self\"),\n+            Some(ast::PathSegmentKind::SuperKw) => buf.push_str(\"super\"),\n+            Some(ast::PathSegmentKind::CrateKw) => buf.push_str(\"crate\"),\n+            None => {}\n+        }\n+        first = false;\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum PathSegmentsMatch {\n+    // Patch matches exactly\n+    Full,\n+    // None of the segments matched. It's a more explicit Partial(0)\n+    Empty,\n+    // When some of the segments matched\n+    Partial(usize),\n+    // When all the segments of the right path are matched against the left path,\n+    // but the left path is longer.\n+    PartialLeft(usize),\n+    // When all the segments of the left path are matched against the right path,\n+    // but the right path is longer.\n+    PartialRight(usize),\n+    // In all the three cases above we keep track of how many segments matched\n+}\n+\n+fn compare_path_segments(\n+    left: &[&ast::PathSegment],\n+    right: &[&ast::PathSegment],\n+) -> PathSegmentsMatch {\n+    let mut matching = 0;\n+    for either_or_both in left.iter().zip_longest(right.iter()) {\n+        match either_or_both {\n+            EitherOrBoth::Both(left, right) => {\n+                if compare_path_segment(left, right) {\n+                    matching += 1\n+                } else {\n+                    return if matching == 0 {\n+                        PathSegmentsMatch::Empty\n+                    } else {\n+                        PathSegmentsMatch::Partial(matching)\n+                    };\n+                }\n+            }\n+            EitherOrBoth::Left(_) => {\n+                return PathSegmentsMatch::PartialLeft(matching);\n+            }\n+            EitherOrBoth::Right(_) => {\n+                return PathSegmentsMatch::PartialRight(matching);\n+            }\n+        }\n+    }\n+    return PathSegmentsMatch::Full;\n+}\n+\n+fn compare_path_segment(a: &ast::PathSegment, b: &ast::PathSegment) -> bool {\n+    if let (Some(ka), Some(kb)) = (a.kind(), b.kind()) {\n+        return match (ka, kb) {\n+            (ast::PathSegmentKind::Name(nameref_a), ast::PathSegmentKind::Name(nameref_b)) => {\n+                nameref_a.text() == nameref_b.text()\n+            }\n+            (ast::PathSegmentKind::SelfKw, ast::PathSegmentKind::SelfKw) => true,\n+            (ast::PathSegmentKind::SuperKw, ast::PathSegmentKind::SuperKw) => true,\n+            (ast::PathSegmentKind::CrateKw, ast::PathSegmentKind::CrateKw) => true,\n+            (_, _) => false,\n+        };\n+    } else {\n+        false\n+    }\n+}\n+\n+fn compare_path_segment_with_name(a: &ast::PathSegment, b: &ast::Name) -> bool {\n+    if let Some(ka) = a.kind() {\n+        return match (ka, b) {\n+            (ast::PathSegmentKind::Name(nameref_a), _) => nameref_a.text() == b.text(),\n+            (_, _) => false,\n+        };\n+    } else {\n+        false\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum ImportAction<'a> {\n+    Nothing,\n+    // Add a brand new use statement.\n+    AddNewUse(\n+        Option<&'a SyntaxNode>, // anchor node\n+        bool,                   // true if we want to add the new statement after the anchor\n+    ),\n+\n+    // In the following actions we keep track of how may segments matched,\n+    // so we can choose the best action to take.\n+\n+    // To split an existing use statement creating a nested import.\n+    AddNestedImport(\n+        usize,\n+        &'a ast::Path,                // the complete path we want to split\n+        Option<&'a ast::PathSegment>, // the first segment of path we want to add into the new nested list\n+        bool,                         // true if we want to add 'self' in addition to the segment\n+    ),\n+    // To add the target path to an existing nested import tree list.\n+    AddInTreeList(\n+        usize,\n+        &'a ast::UseTreeList,\n+        bool, // true if we want to add 'self'\n+    ),\n+}\n+\n+impl<'a> ImportAction<'a> {\n+    fn better<'b>(left: &'b ImportAction<'a>, right: &'b ImportAction<'a>) -> &'b ImportAction<'a> {\n+        if left.is_better(right) {\n+            left\n+        } else {\n+            right\n+        }\n+    }\n+\n+    fn is_better(&self, other: &ImportAction) -> bool {\n+        match (self, other) {\n+            (ImportAction::Nothing, _) => true,\n+            (ImportAction::AddInTreeList(..), ImportAction::Nothing) => false,\n+            (ImportAction::AddNestedImport(n, ..), ImportAction::AddInTreeList(m, ..)) => n > m,\n+            (ImportAction::AddInTreeList(n, ..), ImportAction::AddNestedImport(m, ..)) => n > m,\n+            (ImportAction::AddInTreeList(..), _) => true,\n+            (ImportAction::AddNestedImport(..), ImportAction::Nothing) => false,\n+            (ImportAction::AddNestedImport(..), _) => true,\n+            (ImportAction::AddNewUse(..), _) => false,\n+        }\n+    }\n+}\n+\n+// Find out the best ImportAction to import target path against current_use_tree.\n+// If current_use_tree has a nested import the function gets called recursively on every UseTree inside a UseTreeList.\n+fn walk_use_tree_for_best_action<'b, 'c, 'a: 'b + 'c>(\n+    current_path_segments: &'b mut Vec<&'a ast::PathSegment>, // buffer containing path segments\n+    current_parent_use_tree_list: Option<&'a ast::UseTreeList>, // will be Some value if we are in a nested import\n+    current_use_tree: &'a ast::UseTree, // the use tree we are currently examinating\n+    target: &'c [&'a ast::PathSegment], // the path we want to import\n+) -> ImportAction<'a> {\n+    // We save the number of segments in the buffer so we can restore the correct segments\n+    // before returning. Recursive call will add segments so we need to delete them.\n+    let prev_len = current_path_segments.len();\n+\n+    let tree_list = current_use_tree.use_tree_list();\n+    let alias = current_use_tree.alias();\n+\n+    let path = match current_use_tree.path() {\n+        Some(path) => path,\n+        None => {\n+            // If the use item don't have a path, it means it's broken (syntax error)\n+            return ImportAction::AddNewUse(\n+                current_use_tree\n+                    .syntax()\n+                    .ancestors()\n+                    .find_map(ast::UseItem::cast)\n+                    .map(AstNode::syntax),\n+                true,\n+            );\n+        }\n+    };\n+\n+    // This can happen only if current_use_tree is a direct child of a UseItem\n+    if let Some(name) = alias.and_then(ast::NameOwner::name) {\n+        if compare_path_segment_with_name(target[0], name) {\n+            return ImportAction::Nothing;\n+        }\n+    }\n+\n+    collect_path_segments_raw(current_path_segments, path);\n+\n+    // We compare only the new segments added in the line just above.\n+    // The first prev_len segments were already compared in 'parent' recursive calls.\n+    let c = compare_path_segments(\n+        target.split_at(prev_len).1,\n+        current_path_segments.split_at(prev_len).1,\n+    );\n+\n+    let mut action = match c {\n+        PathSegmentsMatch::Full => {\n+            // e.g: target is std::fmt and we can have\n+            // 1- use std::fmt;\n+            // 2- use std::fmt:{ ... }\n+            if let Some(list) = tree_list {\n+                // In case 2 we need to add self to the nested list\n+                // unless it's already there\n+                let has_self = list.use_trees().map(ast::UseTree::path).any(|p| {\n+                    p.and_then(ast::Path::segment)\n+                        .and_then(ast::PathSegment::kind)\n+                        .filter(|k| *k == ast::PathSegmentKind::SelfKw)\n+                        .is_some()\n+                });\n+\n+                if has_self {\n+                    ImportAction::Nothing\n+                } else {\n+                    ImportAction::AddInTreeList(current_path_segments.len(), list, true)\n+                }\n+            } else {\n+                // Case 1\n+                ImportAction::Nothing\n+            }\n+        }\n+        PathSegmentsMatch::Empty => ImportAction::AddNewUse(\n+            // e.g: target is std::fmt and we can have\n+            // use foo::bar\n+            // We add a brand new use statement\n+            current_use_tree\n+                .syntax()\n+                .ancestors()\n+                .find_map(ast::UseItem::cast)\n+                .map(AstNode::syntax),\n+            true,\n+        ),\n+        PathSegmentsMatch::Partial(n) => {\n+            // e.g: target is std::fmt and we have\n+            // use std::io;\n+            // We need to split.\n+            let segments_to_split = current_path_segments.split_at(prev_len + n).1;\n+            ImportAction::AddNestedImport(prev_len + n, path, Some(segments_to_split[0]), false)\n+        }\n+        PathSegmentsMatch::PartialLeft(n) => {\n+            // e.g: target is std::fmt and we can have\n+            // 1- use std;\n+            // 2- use std::{ ... };\n+\n+            // fallback action\n+            let mut better_action = ImportAction::AddNewUse(\n+                current_use_tree\n+                    .syntax()\n+                    .ancestors()\n+                    .find_map(ast::UseItem::cast)\n+                    .map(AstNode::syntax),\n+                true,\n+            );\n+            if let Some(list) = tree_list {\n+                // Case 2, check recursively if the path is already imported in the nested list\n+                for u in list.use_trees() {\n+                    let child_action =\n+                        walk_use_tree_for_best_action(current_path_segments, Some(list), u, target);\n+                    if child_action.is_better(&better_action) {\n+                        better_action = child_action;\n+                        if let ImportAction::Nothing = better_action {\n+                            return better_action;\n+                        }\n+                    }\n+                }\n+            } else {\n+                // Case 1, split\n+                better_action = ImportAction::AddNestedImport(prev_len + n, path, None, true)\n+            }\n+            better_action\n+        }\n+        PathSegmentsMatch::PartialRight(n) => {\n+            // e.g: target std::fmt and we can have\n+            // use std::fmt::Debug;\n+            let segments_to_split = current_path_segments.split_at(prev_len + n).1;\n+            ImportAction::AddNestedImport(prev_len + n, path, Some(segments_to_split[0]), true)\n+        }\n+    };\n+\n+    // If we are inside a UseTreeList adding a use statement become adding to the existing\n+    // tree list.\n+    action = match (current_parent_use_tree_list, action) {\n+        (Some(use_tree_list), ImportAction::AddNewUse(..)) => {\n+            ImportAction::AddInTreeList(prev_len, use_tree_list, false)\n+        }\n+        (_, _) => action,\n+    };\n+\n+    // We remove the segments added\n+    current_path_segments.truncate(prev_len);\n+    return action;\n+}\n+\n+fn best_action_for_target<'b, 'a: 'b>(\n+    container: &'a SyntaxNode,\n+    path: &'a ast::Path,\n+    target: &'b [&'a ast::PathSegment],\n+) -> ImportAction<'a> {\n+    let mut storage = Vec::with_capacity(16); // this should be the only allocation\n+    let best_action = container\n+        .children()\n+        .filter_map(ast::UseItem::cast)\n+        .filter_map(ast::UseItem::use_tree)\n+        .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n+        .fold(None, |best, a| {\n+            best.and_then(|best| Some(*ImportAction::better(&best, &a)))\n+                .or(Some(a))\n+        });\n+\n+    match best_action {\n+        Some(action) => return action,\n+        None => {\n+            // We have no action we no use item was found in container so we find\n+            // another item and we use it as anchor.\n+            // If there are not items, we choose the target path itself as anchor.\n+            let anchor = container\n+                .children()\n+                .find_map(ast::ModuleItem::cast)\n+                .map(AstNode::syntax)\n+                .or(Some(path.syntax()));\n+\n+            return ImportAction::AddNewUse(anchor, false);\n+        }\n+    }\n+}\n+\n+fn make_assist(action: &ImportAction, target: &[&ast::PathSegment], edit: &mut AssistBuilder) {\n+    match action {\n+        ImportAction::AddNewUse(anchor, after) => {\n+            make_assist_add_new_use(anchor, *after, target, edit)\n+        }\n+        ImportAction::AddInTreeList(n, tree_list_node, add_self) => {\n+            // We know that the fist n segments already exists in the use statement we want\n+            // to modify, so we want to add only the last target.len() - n segments.\n+            let segments_to_add = target.split_at(*n).1;\n+            make_assist_add_in_tree_list(tree_list_node, segments_to_add, *add_self, edit)\n+        }\n+        ImportAction::AddNestedImport(n, path, first_segment_to_split, add_self) => {\n+            let segments_to_add = target.split_at(*n).1;\n+            make_assist_add_nested_import(\n+                path,\n+                first_segment_to_split,\n+                segments_to_add,\n+                *add_self,\n+                edit,\n+            )\n+        }\n+        _ => {}\n+    }\n+}\n+\n+fn make_assist_add_new_use(\n+    anchor: &Option<&SyntaxNode>,\n+    after: bool,\n+    target: &[&ast::PathSegment],\n+    edit: &mut AssistBuilder,\n+) {\n+    if let Some(anchor) = anchor {\n+        let indent = formatting::leading_indent(anchor);\n+        let mut buf = String::new();\n+        if after {\n+            buf.push_str(\"\\n\");\n+            if let Some(spaces) = indent {\n+                buf.push_str(spaces);\n+            }\n+        }\n+        buf.push_str(\"use \");\n+        fmt_segments_raw(target, &mut buf);\n+        buf.push_str(\";\");\n+        if !after {\n+            buf.push_str(\"\\n\\n\");\n+            if let Some(spaces) = indent {\n+                buf.push_str(spaces);\n+            }\n+        }\n+        let position = if after {\n+            anchor.range().end()\n+        } else {\n+            anchor.range().start()\n+        };\n+        edit.insert(position, buf);\n+    }\n+}\n+\n+fn make_assist_add_in_tree_list(\n+    tree_list: &ast::UseTreeList,\n+    target: &[&ast::PathSegment],\n+    add_self: bool,\n+    edit: &mut AssistBuilder,\n+) {\n+    let last = tree_list.use_trees().last();\n+    if let Some(last) = last {\n+        let mut buf = String::new();\n+        let comma = last\n+            .syntax()\n+            .siblings(Direction::Next)\n+            .find(|n| n.kind() == COMMA);\n+        let offset = if let Some(comma) = comma {\n+            comma.range().end()\n+        } else {\n+            buf.push_str(\",\");\n+            last.syntax().range().end()\n+        };\n+        if add_self {\n+            buf.push_str(\" self\")\n+        } else {\n+            buf.push_str(\" \");\n+        }\n+        fmt_segments_raw(target, &mut buf);\n+        edit.insert(offset, buf);\n+    } else {\n+\n+    }\n+}\n+\n+fn make_assist_add_nested_import(\n+    path: &ast::Path,\n+    first_segment_to_split: &Option<&ast::PathSegment>,\n+    target: &[&ast::PathSegment],\n+    add_self: bool,\n+    edit: &mut AssistBuilder,\n+) {\n+    let use_tree = path.syntax().ancestors().find_map(ast::UseTree::cast);\n+    if let Some(use_tree) = use_tree {\n+        let (start, add_colon_colon) = if let Some(first_segment_to_split) = first_segment_to_split\n+        {\n+            (first_segment_to_split.syntax().range().start(), false)\n+        } else {\n+            (use_tree.syntax().range().end(), true)\n+        };\n+        let end = use_tree.syntax().range().end();\n+\n+        let mut buf = String::new();\n+        if add_colon_colon {\n+            buf.push_str(\"::\");\n+        }\n+        buf.push_str(\"{ \");\n+        if add_self {\n+            buf.push_str(\"self, \");\n+        }\n+        fmt_segments_raw(target, &mut buf);\n+        if !target.is_empty() {\n+            buf.push_str(\", \");\n+        }\n+        edit.insert(start, buf);\n+        edit.insert(end, \"}\");\n+    }\n+}\n+\n+pub(crate) fn auto_import(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n+    let node = ctx.covering_node();\n+    let current_file = node.ancestors().find_map(ast::SourceFile::cast)?;\n+\n+    let path = node.ancestors().find_map(ast::Path::cast)?;\n+    // We don't want to mess with use statements\n+    if path\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::UseItem::cast)\n+        .is_some()\n+    {\n+        return None;\n+    }\n+\n+    let segments = collect_path_segments(path)?;\n+    if segments.len() < 2 {\n+        return None;\n+    }\n+\n+    ctx.build(\n+        format!(\"import {} in the current file\", fmt_segments(&segments)),\n+        |edit| {\n+            let action = best_action_for_target(current_file.syntax(), path, &segments);\n+            make_assist(&action, segments.as_slice(), edit);\n+            if let Some(last_segment) = path.segment() {\n+                // Here we are assuming the assist will provide a  correct use statement\n+                // so we can delete the path qualifier\n+                edit.delete(TextRange::from_to(\n+                    path.syntax().range().start(),\n+                    last_segment.syntax().range().start(),\n+                ));\n+            }\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use crate::helpers::{ check_assist, check_assist_not_applicable };\n+\n+    #[test]\n+    fn test_auto_import_file_add_use_no_anchor() {\n+        check_assist(\n+            auto_import,\n+            \"\n+std::fmt::Debug<|>\n+    \",\n+            \"\n+use std::fmt::Debug;\n+\n+Debug<|>\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_use() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use stdx;\n+\n+impl std::fmt::Debug<|> for Foo {\n+}\n+    \",\n+            \"\n+use stdx;\n+use std::fmt::Debug;\n+\n+impl Debug<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_use_other_anchor() {\n+        check_assist(\n+            auto_import,\n+            \"\n+impl std::fmt::Debug<|> for Foo {\n+}\n+    \",\n+            \"\n+use std::fmt::Debug;\n+\n+impl Debug<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_use_other_anchor_indent() {\n+        check_assist(\n+            auto_import,\n+            \"\n+    impl std::fmt::Debug<|> for Foo {\n+    }\n+    \",\n+            \"\n+    use std::fmt::Debug;\n+\n+    impl Debug<|> for Foo {\n+    }\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_split_different() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt;\n+\n+impl std::io<|> for Foo {\n+}\n+    \",\n+            \"\n+use std::{ io, fmt};\n+\n+impl io<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_split_self_for_use() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt;\n+\n+impl std::fmt::Debug<|> for Foo {\n+}\n+    \",\n+            \"\n+use std::fmt::{ self, Debug, };\n+\n+impl Debug<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_split_self_for_target() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt::Debug;\n+\n+impl std::fmt<|> for Foo {\n+}\n+    \",\n+            \"\n+use std::fmt::{ self, Debug};\n+\n+impl fmt<|> for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_to_nested_self_nested() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt::{Debug, nested::{Display}};\n+\n+impl std::fmt::nested<|> for Foo {\n+}\n+\",\n+            \"\n+use std::fmt::{Debug, nested::{Display, self}};\n+\n+impl nested<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_to_nested_self_already_included() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt::{Debug, nested::{self, Display}};\n+\n+impl std::fmt::nested<|> for Foo {\n+}\n+\",\n+            \"\n+use std::fmt::{Debug, nested::{self, Display}};\n+\n+impl nested<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_add_to_nested_nested() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt::{Debug, nested::{Display}};\n+\n+impl std::fmt::nested::Debug<|> for Foo {\n+}\n+\",\n+            \"\n+use std::fmt::{Debug, nested::{Display, Debug}};\n+\n+impl Debug<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_file_alias() {\n+        check_assist(\n+            auto_import,\n+            \"\n+use std::fmt as foo;\n+\n+impl foo::Debug<|> for Foo {\n+}\n+\",\n+            \"\n+use std::fmt as foo;\n+\n+impl Debug<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_auto_import_not_applicable_one_segment() {\n+        check_assist_not_applicable(\n+            auto_import,\n+            \"\n+impl foo<|> for Foo {\n+}\n+\",\n+        );\n+    }\n+}"}, {"sha": "af578893efc46b45327450d1b941dc11a5808b32", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5580cf239d3b1a93718bec3acac5ff2183d418e4/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5580cf239d3b1a93718bec3acac5ff2183d418e4/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=5580cf239d3b1a93718bec3acac5ff2183d418e4", "patch": "@@ -84,6 +84,8 @@ mod introduce_variable;\n mod replace_if_let_with_match;\n mod split_import;\n mod remove_dbg;\n+mod auto_import;\n+\n fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assist>] {\n     &[\n         add_derive::add_derive,\n@@ -95,6 +97,7 @@ fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assis\n         replace_if_let_with_match::replace_if_let_with_match,\n         split_import::split_import,\n         remove_dbg::remove_dbg,\n+        auto_import::auto_import,\n     ]\n }\n "}]}