{"sha": "74b398b93d647237acbc1c738e55e47ec13ea7b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0YjM5OGI5M2Q2NDcyMzdhY2JjMWM3MzhlNTVlNDdlYzEzZWE3YjI=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-19T21:23:41Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-19T21:23:41Z"}, "message": "progress on lifetimes", "tree": {"sha": "0892d9b29fa2eeba4ba135b60d3a6e7110a50a24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0892d9b29fa2eeba4ba135b60d3a6e7110a50a24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74b398b93d647237acbc1c738e55e47ec13ea7b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74b398b93d647237acbc1c738e55e47ec13ea7b2", "html_url": "https://github.com/rust-lang/rust/commit/74b398b93d647237acbc1c738e55e47ec13ea7b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74b398b93d647237acbc1c738e55e47ec13ea7b2/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02134464b0ac3cb64e221fd008b8b9e6bad1d932", "url": "https://api.github.com/repos/rust-lang/rust/commits/02134464b0ac3cb64e221fd008b8b9e6bad1d932", "html_url": "https://github.com/rust-lang/rust/commit/02134464b0ac3cb64e221fd008b8b9e6bad1d932"}], "stats": {"total": 132, "additions": 120, "deletions": 12}, "files": [{"sha": "84bc7e2ef594757540114488101f04b3f04623b1", "filename": "lifetimes.md", "status": "modified", "additions": 120, "deletions": 12, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/74b398b93d647237acbc1c738e55e47ec13ea7b2/lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/74b398b93d647237acbc1c738e55e47ec13ea7b2/lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lifetimes.md?ref=74b398b93d647237acbc1c738e55e47ec13ea7b2", "patch": "@@ -1,4 +1,4 @@\n-% Ownership\n+% Ownership and Lifetimes\n \n Ownership is the breakout feature of Rust. It allows Rust to be completely\n memory-safe and efficient, while avoiding garbage collection. Before getting\n@@ -58,6 +58,13 @@ a Cell is to copy the bits in or out.\n manages this through *runtime* checks. It is effectively a thread-unsafe\n read-write lock.\n \n+For more details see Dan Grossman's Existential Types for Imperative Languages:\n+* [paper][grossman-paper] (Advanced)\n+* [slides][grossman-slides] (Simple)\n+\n+[grossman-paper]: http://homes.cs.washington.edu/~djg/papers/exists_imp.pdf\n+[grossman-slides]: https://homes.cs.washington.edu/~djg/slides/esop02_talk.pdf\n+\n \n \n \n@@ -96,19 +103,49 @@ more than a local lint against incorrect usage of a value.\n \n ## Weird Lifetimes\n \n-Almost always, the mutability of a lifetime can be derived from the mutability\n-of the reference it is attached to. However this is not necessarily the case.\n-For instance in the following code:\n+Given the following code:\n \n ```rust\n-fn foo<'a>(input: &'a mut u8) -> &'a u8 { &* input }\n+struct Foo;\n+\n+impl Foo {\n+    fn mutate_and_share(&mut self) -> &Self { &*self }\n+    fn share(&self) {}\n+}\n+\n+fn main() {\n+    let mut foo = Foo;\n+    let loan = foo.mutate_and_share();\n+    foo.share();\n+}\n+```\n+\n+One might expect it to compile. We call `mutate_and_share`, which mutably borrows\n+`foo` *temporarily*, but then returns *only* a shared reference. Therefore we\n+would expect `foo.share()` to succeed as `foo` shouldn't be mutably borrowed.\n+\n+However when we try to compile it:\n+\n+```text\n+<anon>:11:5: 11:8 error: cannot borrow `foo` as immutable because it is also borrowed as mutable\n+<anon>:11     foo.share();\n+              ^~~\n+<anon>:10:16: 10:19 note: previous borrow of `foo` occurs here; the mutable borrow prevents subsequent moves, borrows, or modification of `foo` until the borrow ends\n+<anon>:10     let loan = foo.mutate_and_share();\n+                         ^~~\n+<anon>:12:2: 12:2 note: previous borrow ends here\n+<anon>:8 fn main() {\n+<anon>:9     let mut foo = Foo;\n+<anon>:10     let loan = foo.mutate_and_share();\n+<anon>:11     foo.share();\n+<anon>:12 }\n+          ^\n ```\n \n-One would expect the output of foo to be an immutable lifetime. However we have\n-derived it from the input, which is a mutable lifetime. So although we have a\n-shared reference, it will have the much more limited aliasing rules of a mutable\n-reference. As a consequence, there is no expressive benefit in a method that\n-mutates returning a shared reference.\n+What happened? Well, the lifetime of `loan` is derived from a *mutable* borrow.\n+This makes the type system believe that `foo` is mutably borrowed as long as\n+`loan` exists, even though it's a shared reference. To my knowledge, this is not\n+a bug.\n \n \n \n@@ -413,7 +450,7 @@ respectively.\n \n \n \n-## PhantomData and PhantomFn\n+## PhantomData\n \n This is all well and good for the types the standard library provides, but\n how is variance determined for type that *you* define? A struct is, informally\n@@ -475,6 +512,8 @@ pub struct Iter<'a, T: 'a> {\n ```\n \n \n+\n+\n ## Splitting Lifetimes\n \n The mutual exclusion property of mutable references can be very limiting when\n@@ -544,7 +583,76 @@ fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n ```\n \n This is pretty plainly dangerous. We use transmute to duplicate the slice with an\n-*unbounded* lifetime, so that it\n+*unbounded* lifetime, so that it can be treated as disjoint from the other until\n+we unify them when we return.\n+\n+However more subtle is how iterators that yield mutable references work.\n+The iterator trait is defined as follows:\n+\n+```rust\n+trait Iterator {\n+    type Item;\n+\n+    fn next(&mut self) -> Option<Self::Item>;\n+}\n+```\n+\n+Given this definition, Self::Item has *no* connection to `self`. This means\n+that we can call `next` several times in a row, and hold onto all the results\n+*concurrently*. This is perfectly fine for by-value iterators, which have exactly\n+these semantics. It's also actually fine for shared references, as it's perfectly\n+fine to grab a huge pile of shared references to the same thing (although the\n+iterator needs to be a separate object from the thing being shared). But mutable\n+references make this a mess. At first glance, they might seem completely\n+incompatible with this API, as it would produce multiple mutable references to\n+the same object!\n+\n+However it actually *does* work, exactly because iterators are one-shot objects.\n+Everything an IterMut yields will be yielded *at most* once, so we don't *actually*\n+ever yield multiple mutable references to the same piece of data.\n+\n+In general all mutable iterators require *some* unsafe code *somewhere*, though.\n+Whether it's raw pointers, or safely composing on top of *another* IterMut.\n+\n+For instance, VecDeque's IterMut:\n+\n+```rust\n+pub struct IterMut<'a, T:'a> {\n+    // The whole backing array. Some of these indices are initialized!\n+    ring: &'a mut [T],\n+    tail: usize,\n+    head: usize,\n+}\n+\n+impl<'a, T> Iterator for IterMut<'a, T> {\n+    type Item = &'a mut T;\n+\n+    fn next(&mut self) -> Option<&'a mut T> {\n+        if self.tail == self.head {\n+            return None;\n+        }\n+        let tail = self.tail;\n+        self.tail = wrap_index(self.tail.wrapping_add(1), self.ring.len());\n+\n+        unsafe {\n+            // might as well do unchecked indexing since wrap_index has us\n+            // in-bounds, and many of the \"middle\" indices are uninitialized\n+            // anyway.\n+            let elem = self.ring.get_unchecked_mut(tail);\n+\n+            // round-trip through a raw pointer to unbound the lifetime from\n+            // ourselves\n+            Some(&mut *(elem as *mut _))\n+        }\n+    }\n+}\n+```\n \n+A very subtle but interesting detail in this design is that it *relies on\n+privacy to be sound*. Borrowck works on some very simple rules. One of those rules\n+is that if we have a live &mut Foo and Foo contains an &mut Bar, then that &mut\n+Bar is *also* live. Since IterMut is always live when `next` can be called, if\n+`ring` were public then we could mutate `ring` while outstanding mutable borrows\n+to it exist!\n \n "}]}