{"sha": "7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "node_id": "C_kwDOAAsO6NoAKDdiNjMwNThkMTM0MjhhZGU5ZjhlZjBhNWZiZWI2YTNmMjIyOWRjMzM", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-15T05:09:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-15T05:09:43Z"}, "message": "Rollup merge of #99131 - compiler-errors:label-fn, r=cjgillot\n\nAdd label for generic arg (+ APIT) and RPIT callables in `label_fn_like`\n\nFixes #98308", "tree": {"sha": "e3b927bc868a86ff6e5fc6cea8ebe4953e51e282", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3b927bc868a86ff6e5fc6cea8ebe4953e51e282"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi0PaXCRBK7hj4Ov3rIwAAlusIAKw7H9l5/pdb5MXCurr+tUI7\nwKVcKPRoOqZtQHKkKjLFzE1DHoze4uW4YPFEGGIy3n+sUY7PD5WxL+QovAMiGGKa\n2MRSmrZ/mGrTrL5O0Ir+GqrvZprVORQRsiEbmwiR8ULJwB42sNQKv6i6IT1oZOiz\ny1wqvVioWKWZg8c4l4hWGC5H5Hbr0FHMJrEjbTEA/qfaHvAzmc6A7h2kaY6m5kCX\nfQ15yJZg7Udfn4xAl0Yfl5Q2KhEmrqEqn64o1y1/dWuzZSfg9oxLDHM4BnWRPpJh\ncdDCv8yj1EoZQhy2xNCFcH2MknoiMTvuhG7W81vMKKbNWGRZOE/dAWdHuqbGmKk=\n=5yvR\n-----END PGP SIGNATURE-----\n", "payload": "tree e3b927bc868a86ff6e5fc6cea8ebe4953e51e282\nparent 99f3132cd7a36b665aba4704fae457711eea929e\nparent d25abdc0c52cc08cdd290be325f1be04f3cea548\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657861783 +0530\ncommitter GitHub <noreply@github.com> 1657861783 +0530\n\nRollup merge of #99131 - compiler-errors:label-fn, r=cjgillot\n\nAdd label for generic arg (+ APIT) and RPIT callables in `label_fn_like`\n\nFixes #98308\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "html_url": "https://github.com/rust-lang/rust/commit/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99f3132cd7a36b665aba4704fae457711eea929e", "url": "https://api.github.com/repos/rust-lang/rust/commits/99f3132cd7a36b665aba4704fae457711eea929e", "html_url": "https://github.com/rust-lang/rust/commit/99f3132cd7a36b665aba4704fae457711eea929e"}, {"sha": "d25abdc0c52cc08cdd290be325f1be04f3cea548", "url": "https://api.github.com/repos/rust-lang/rust/commits/d25abdc0c52cc08cdd290be325f1be04f3cea548", "html_url": "https://github.com/rust-lang/rust/commit/d25abdc0c52cc08cdd290be325f1be04f3cea548"}], "stats": {"total": 396, "additions": 296, "deletions": 100}, "files": [{"sha": "8ead05122740e6f9926828f9770d037a0537e6eb", "filename": "compiler/rustc_middle/src/ty/closure.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fclosure.rs?ref=7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "patch": "@@ -128,6 +128,14 @@ impl<'tcx> ClosureKind {\n             None\n         }\n     }\n+\n+    pub fn to_def_id(&self, tcx: TyCtxt<'_>) -> DefId {\n+        match self {\n+            ClosureKind::Fn => tcx.lang_items().fn_once_trait().unwrap(),\n+            ClosureKind::FnMut => tcx.lang_items().fn_mut_trait().unwrap(),\n+            ClosureKind::FnOnce => tcx.lang_items().fn_trait().unwrap(),\n+        }\n+    }\n }\n \n /// A composite describing a `Place` that is captured by a closure."}, {"sha": "ec045d3e70c96d806f5e28b9885673ffc7e003ab", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 179, "deletions": 84, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "patch": "@@ -21,15 +21,18 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt};\n+use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n-use rustc_trait_selection::traits::{self, ObligationCauseCode, StatementAsExpression};\n+use rustc_trait_selection::traits::{\n+    self, ObligationCauseCode, SelectionContext, StatementAsExpression,\n+};\n \n use std::iter;\n use std::slice;\n@@ -89,7 +92,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 args_no_rcvr,\n                 false,\n                 tuple_arguments,\n-                None,\n+                method.ok().map(|method| method.def_id),\n             );\n             return self.tcx.ty_error();\n         }\n@@ -393,41 +396,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if !call_appears_satisfied {\n-            // Next, let's construct the error\n-            let (error_span, full_call_span, ctor_of) = match &call_expr.kind {\n-                hir::ExprKind::Call(\n-                    hir::Expr {\n-                        span,\n-                        kind:\n-                            hir::ExprKind::Path(hir::QPath::Resolved(\n-                                _,\n-                                hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n-                            )),\n-                        ..\n-                    },\n-                    _,\n-                ) => (call_span, *span, Some(of)),\n-                hir::ExprKind::Call(hir::Expr { span, .. }, _) => (call_span, *span, None),\n-                hir::ExprKind::MethodCall(path_segment, _, span) => {\n-                    let ident_span = path_segment.ident.span;\n-                    let ident_span = if let Some(args) = path_segment.args {\n-                        ident_span.with_hi(args.span_ext.hi())\n-                    } else {\n-                        ident_span\n-                    };\n-                    (\n-                        *span, ident_span, None, // methods are never ctors\n-                    )\n-                }\n-                k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n-            };\n-            let args_span = error_span.trim_start(full_call_span).unwrap_or(error_span);\n-            let call_name = match ctor_of {\n-                Some(CtorOf::Struct) => \"struct\",\n-                Some(CtorOf::Variant) => \"enum variant\",\n-                None => \"function\",\n-            };\n-\n             let compatibility_diagonal = IndexVec::from_raw(compatibility_diagonal);\n             let provided_args = IndexVec::from_iter(provided_args.iter().take(if c_variadic {\n                 minimum_input_count\n@@ -451,13 +419,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 compatibility_diagonal,\n                 formal_and_expected_inputs,\n                 provided_args,\n-                full_call_span,\n-                error_span,\n-                args_span,\n-                call_name,\n                 c_variadic,\n                 err_code,\n                 fn_def_id,\n+                call_span,\n+                call_expr,\n             );\n         }\n     }\n@@ -467,14 +433,47 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         compatibility_diagonal: IndexVec<ProvidedIdx, Compatibility<'tcx>>,\n         formal_and_expected_inputs: IndexVec<ExpectedIdx, (Ty<'tcx>, Ty<'tcx>)>,\n         provided_args: IndexVec<ProvidedIdx, &'tcx hir::Expr<'tcx>>,\n-        full_call_span: Span,\n-        error_span: Span,\n-        args_span: Span,\n-        call_name: &str,\n         c_variadic: bool,\n         err_code: &str,\n         fn_def_id: Option<DefId>,\n+        call_span: Span,\n+        call_expr: &hir::Expr<'tcx>,\n     ) {\n+        // Next, let's construct the error\n+        let (error_span, full_call_span, ctor_of) = match &call_expr.kind {\n+            hir::ExprKind::Call(\n+                hir::Expr {\n+                    span,\n+                    kind:\n+                        hir::ExprKind::Path(hir::QPath::Resolved(\n+                            _,\n+                            hir::Path { res: Res::Def(DefKind::Ctor(of, _), _), .. },\n+                        )),\n+                    ..\n+                },\n+                _,\n+            ) => (call_span, *span, Some(of)),\n+            hir::ExprKind::Call(hir::Expr { span, .. }, _) => (call_span, *span, None),\n+            hir::ExprKind::MethodCall(path_segment, _, span) => {\n+                let ident_span = path_segment.ident.span;\n+                let ident_span = if let Some(args) = path_segment.args {\n+                    ident_span.with_hi(args.span_ext.hi())\n+                } else {\n+                    ident_span\n+                };\n+                (\n+                    *span, ident_span, None, // methods are never ctors\n+                )\n+            }\n+            k => span_bug!(call_span, \"checking argument types on a non-call: `{:?}`\", k),\n+        };\n+        let args_span = error_span.trim_start(full_call_span).unwrap_or(error_span);\n+        let call_name = match ctor_of {\n+            Some(CtorOf::Struct) => \"struct\",\n+            Some(CtorOf::Variant) => \"enum variant\",\n+            None => \"function\",\n+        };\n+\n         // Don't print if it has error types or is just plain `_`\n         fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n             tys.into_iter().any(|ty| ty.references_error() || ty.is_ty_var())\n@@ -495,6 +494,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 (self.resolve_vars_if_possible(ty), expr.span)\n             })\n             .collect();\n+        let callee_expr = match &call_expr.peel_blocks().kind {\n+            hir::ExprKind::Call(callee, _) => Some(*callee),\n+            hir::ExprKind::MethodCall(_, callee, _) => {\n+                if let Some((DefKind::AssocFn, def_id)) =\n+                    self.typeck_results.borrow().type_dependent_def(call_expr.hir_id)\n+                    && let Some(assoc) = tcx.opt_associated_item(def_id)\n+                    && assoc.fn_has_self_parameter\n+                {\n+                    Some(&callee[0])\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        };\n+        let callee_ty = callee_expr\n+            .and_then(|callee_expr| self.typeck_results.borrow().expr_ty_adjusted_opt(callee_expr));\n \n         // A \"softer\" version of the `demand_compatible`, which checks types without persisting them,\n         // and treats error types differently\n@@ -631,7 +647,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             Applicability::MachineApplicable,\n                         );\n                     };\n-                    label_fn_like(tcx, &mut err, fn_def_id);\n+                    self.label_fn_like(&mut err, fn_def_id, callee_ty);\n                     err.emit();\n                     return;\n                 }\n@@ -721,7 +737,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 format!(\"arguments to this {} are incorrect\", call_name),\n             );\n             // Call out where the function is defined\n-            label_fn_like(tcx, &mut err, fn_def_id);\n+            self.label_fn_like(&mut err, fn_def_id, callee_ty);\n             err.emit();\n             return;\n         }\n@@ -1003,7 +1019,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         // Call out where the function is defined\n-        label_fn_like(tcx, &mut err, fn_def_id);\n+        self.label_fn_like(&mut err, fn_def_id, callee_ty);\n \n         // And add a suggestion block for all of the parameters\n         let suggestion_text = match suggestion_text {\n@@ -1795,47 +1811,126 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n     }\n-}\n \n-fn label_fn_like<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    err: &mut rustc_errors::DiagnosticBuilder<'tcx, rustc_errors::ErrorGuaranteed>,\n-    def_id: Option<DefId>,\n-) {\n-    let Some(def_id) = def_id else {\n-        return;\n-    };\n-\n-    if let Some(def_span) = tcx.def_ident_span(def_id) {\n-        let mut spans: MultiSpan = def_span.into();\n-\n-        let params = tcx\n-            .hir()\n-            .get_if_local(def_id)\n-            .and_then(|node| node.body_id())\n-            .into_iter()\n-            .flat_map(|id| tcx.hir().body(id).params);\n-\n-        for param in params {\n-            spans.push_span_label(param.span, \"\");\n+    fn label_fn_like(\n+        &self,\n+        err: &mut rustc_errors::DiagnosticBuilder<'tcx, rustc_errors::ErrorGuaranteed>,\n+        callable_def_id: Option<DefId>,\n+        callee_ty: Option<Ty<'tcx>>,\n+    ) {\n+        let Some(mut def_id) = callable_def_id else {\n+            return;\n+        };\n+\n+        if let Some(assoc_item) = self.tcx.opt_associated_item(def_id)\n+            // Possibly points at either impl or trait item, so try to get it\n+            // to point to trait item, then get the parent.\n+            // This parent might be an impl in the case of an inherent function,\n+            // but the next check will fail.\n+            && let maybe_trait_item_def_id = assoc_item.trait_item_def_id.unwrap_or(def_id)\n+            && let maybe_trait_def_id = self.tcx.parent(maybe_trait_item_def_id)\n+            // Just an easy way to check \"trait_def_id == Fn/FnMut/FnOnce\"\n+            && let Some(call_kind) = ty::ClosureKind::from_def_id(self.tcx, maybe_trait_def_id)\n+            && let Some(callee_ty) = callee_ty\n+        {\n+            let callee_ty = callee_ty.peel_refs();\n+            match *callee_ty.kind() {\n+                ty::Param(param) => {\n+                    let param =\n+                        self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx);\n+                    if param.kind.is_synthetic() {\n+                        // if it's `impl Fn() -> ..` then just fall down to the def-id based logic\n+                        def_id = param.def_id;\n+                    } else {\n+                        // Otherwise, find the predicate that makes this generic callable,\n+                        // and point at that.\n+                        let instantiated = self\n+                            .tcx\n+                            .explicit_predicates_of(self.body_id.owner)\n+                            .instantiate_identity(self.tcx);\n+                        // FIXME(compiler-errors): This could be problematic if something has two\n+                        // fn-like predicates with different args, but callable types really never\n+                        // do that, so it's OK.\n+                        for (predicate, span) in\n+                            std::iter::zip(instantiated.predicates, instantiated.spans)\n+                        {\n+                            if let ty::PredicateKind::Trait(pred) = predicate.kind().skip_binder()\n+                                && pred.self_ty().peel_refs() == callee_ty\n+                                && ty::ClosureKind::from_def_id(self.tcx, pred.def_id()).is_some()\n+                            {\n+                                err.span_note(span, \"callable defined here\");\n+                                return;\n+                            }\n+                        }\n+                    }\n+                }\n+                ty::Opaque(new_def_id, _)\n+                | ty::Closure(new_def_id, _)\n+                | ty::FnDef(new_def_id, _) => {\n+                    def_id = new_def_id;\n+                }\n+                _ => {\n+                    // Look for a user-provided impl of a `Fn` trait, and point to it.\n+                    let new_def_id = self.probe(|_| {\n+                        let trait_ref = ty::TraitRef::new(\n+                            call_kind.to_def_id(self.tcx),\n+                            self.tcx.mk_substs([\n+                                ty::GenericArg::from(callee_ty),\n+                                self.next_ty_var(TypeVariableOrigin {\n+                                    kind: TypeVariableOriginKind::MiscVariable,\n+                                    span: rustc_span::DUMMY_SP,\n+                                })\n+                                .into(),\n+                            ].into_iter()),\n+                        );\n+                        let obligation = traits::Obligation::new(\n+                            traits::ObligationCause::dummy(),\n+                            self.param_env,\n+                            ty::Binder::dummy(ty::TraitPredicate {\n+                                trait_ref,\n+                                constness: ty::BoundConstness::NotConst,\n+                                polarity: ty::ImplPolarity::Positive,\n+                            }),\n+                        );\n+                        match SelectionContext::new(&self).select(&obligation) {\n+                            Ok(Some(traits::ImplSource::UserDefined(impl_source))) => {\n+                                Some(impl_source.impl_def_id)\n+                            }\n+                            _ => None\n+                        }\n+                    });\n+                    if let Some(new_def_id) = new_def_id {\n+                        def_id = new_def_id;\n+                    } else {\n+                        return;\n+                    }\n+                }\n+            }\n         }\n \n-        let def_kind = tcx.def_kind(def_id);\n-        err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n-    } else {\n-        match tcx.hir().get_if_local(def_id) {\n-            Some(hir::Node::Expr(hir::Expr {\n-                kind: hir::ExprKind::Closure(hir::Closure { fn_decl_span, .. }),\n-                ..\n-            })) => {\n-                let spans: MultiSpan = (*fn_decl_span).into();\n+        if let Some(def_span) = self.tcx.def_ident_span(def_id) && !def_span.is_dummy() {\n+            let mut spans: MultiSpan = def_span.into();\n \n-                // Note: We don't point to param spans here because they overlap\n-                // with the closure span itself\n+            let params = self\n+                .tcx\n+                .hir()\n+                .get_if_local(def_id)\n+                .and_then(|node| node.body_id())\n+                .into_iter()\n+                .flat_map(|id| self.tcx.hir().body(id).params);\n \n-                err.span_note(spans, \"closure defined here\");\n+            for param in params {\n+                spans.push_span_label(param.span, \"\");\n             }\n-            _ => {}\n+\n+            let def_kind = self.tcx.def_kind(def_id);\n+            err.span_note(spans, &format!(\"{} defined here\", def_kind.descr(def_id)));\n+        } else {\n+            let def_kind = self.tcx.def_kind(def_id);\n+            err.span_note(\n+                self.tcx.def_span(def_id),\n+                &format!(\"{} defined here\", def_kind.descr(def_id)),\n+            );\n         }\n     }\n }"}, {"sha": "a18e967668deff0d7180d45d3731d240900e0252", "filename": "src/test/ui/argument-suggestions/exotic-calls.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.rs?ref=7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "patch": "@@ -0,0 +1,26 @@\n+fn foo<T: Fn()>(t: T) {\n+    t(1i32);\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn bar(t: impl Fn()) {\n+    t(1i32);\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn baz() -> impl Fn() {\n+    || {}\n+}\n+\n+fn baz2() {\n+    baz()(1i32)\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn qux() {\n+    let x = || {};\n+    x(1i32);\n+    //~^ ERROR this function takes 0 arguments but 1 argument was supplied\n+}\n+\n+fn main() {}"}, {"sha": "ca93ecc4e381a9407d27f2b5d2c923e51025cc89", "filename": "src/test/ui/argument-suggestions/exotic-calls.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fexotic-calls.stderr?ref=7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "patch": "@@ -0,0 +1,67 @@\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:2:5\n+   |\n+LL |     t(1i32);\n+   |     ^ ---- argument of type `i32` unexpected\n+   |\n+note: callable defined here\n+  --> $DIR/exotic-calls.rs:1:11\n+   |\n+LL | fn foo<T: Fn()>(t: T) {\n+   |           ^^^^\n+help: remove the extra argument\n+   |\n+LL |     t();\n+   |     ~~~\n+\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:7:5\n+   |\n+LL |     t(1i32);\n+   |     ^ ---- argument of type `i32` unexpected\n+   |\n+note: type parameter defined here\n+  --> $DIR/exotic-calls.rs:6:11\n+   |\n+LL | fn bar(t: impl Fn()) {\n+   |           ^^^^^^^^^\n+help: remove the extra argument\n+   |\n+LL |     t();\n+   |     ~~~\n+\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:16:5\n+   |\n+LL |     baz()(1i32)\n+   |     ^^^^^ ---- argument of type `i32` unexpected\n+   |\n+note: opaque type defined here\n+  --> $DIR/exotic-calls.rs:11:13\n+   |\n+LL | fn baz() -> impl Fn() {\n+   |             ^^^^^^^^^\n+help: remove the extra argument\n+   |\n+LL |     baz()()\n+   |\n+\n+error[E0057]: this function takes 0 arguments but 1 argument was supplied\n+  --> $DIR/exotic-calls.rs:22:5\n+   |\n+LL |     x(1i32);\n+   |     ^ ---- argument of type `i32` unexpected\n+   |\n+note: closure defined here\n+  --> $DIR/exotic-calls.rs:21:13\n+   |\n+LL |     let x = || {};\n+   |             ^^\n+help: remove the extra argument\n+   |\n+LL |     x();\n+   |     ~~~\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0057`."}, {"sha": "aaa3c49b3d83ea468b98434656856502c29b824d", "filename": "src/test/ui/issues/issue-16939.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/src%2Ftest%2Fui%2Fissues%2Fissue-16939.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/src%2Ftest%2Fui%2Fissues%2Fissue-16939.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16939.stderr?ref=7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "patch": "@@ -4,11 +4,11 @@ error[E0057]: this function takes 0 arguments but 1 argument was supplied\n LL |     |t| f(t);\n    |         ^ - argument unexpected\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+note: callable defined here\n+  --> $DIR/issue-16939.rs:4:12\n    |\n-LL |     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n-   |                           ^^^^\n+LL | fn _foo<F: Fn()> (f: F) {\n+   |            ^^^^\n help: remove the extra argument\n    |\n LL |     |t| f();"}, {"sha": "475ea9dfaf1b44d842c3d4dfbe2a11d73df2eea7", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr?ref=7b63058d13428ade9f8ef0a5fbeb6a3f2229dc33", "patch": "@@ -6,23 +6,23 @@ LL |     let ans = s(\"what\");\n    |               |\n    |               arguments to this function are incorrect\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+note: implementation defined here\n+  --> $DIR/overloaded-calls-bad.rs:10:1\n    |\n-LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-   |                           ^^^^^^^^\n+LL | impl FnMut<(isize,)> for S {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0057]: this function takes 1 argument but 0 arguments were supplied\n   --> $DIR/overloaded-calls-bad.rs:29:15\n    |\n LL |     let ans = s();\n    |               ^-- an argument of type `isize` is missing\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+note: implementation defined here\n+  --> $DIR/overloaded-calls-bad.rs:10:1\n    |\n-LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-   |                           ^^^^^^^^\n+LL | impl FnMut<(isize,)> for S {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: provide the argument\n    |\n LL |     let ans = s(/* isize */);\n@@ -36,11 +36,11 @@ LL |     let ans = s(\"burma\", \"shave\");\n    |                 |\n    |                 expected `isize`, found `&str`\n    |\n-note: associated function defined here\n-  --> $SRC_DIR/core/src/ops/function.rs:LL:COL\n+note: implementation defined here\n+  --> $DIR/overloaded-calls-bad.rs:10:1\n    |\n-LL |     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n-   |                           ^^^^^^^^\n+LL | impl FnMut<(isize,)> for S {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: remove the extra argument\n    |\n LL |     let ans = s(/* isize */);"}]}