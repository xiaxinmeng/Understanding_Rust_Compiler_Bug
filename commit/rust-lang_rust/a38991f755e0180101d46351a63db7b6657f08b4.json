{"sha": "a38991f755e0180101d46351a63db7b6657f08b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzODk5MWY3NTVlMDE4MDEwMWQ0NjM1MWE2M2RiN2I2NjU3ZjA4YjQ=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-05-22T23:36:36Z"}, "committer": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-06-10T21:46:39Z"}, "message": "Small review fixes", "tree": {"sha": "f52fbfc9992ecfa85c406ceb5dda116be7165619", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f52fbfc9992ecfa85c406ceb5dda116be7165619"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a38991f755e0180101d46351a63db7b6657f08b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a38991f755e0180101d46351a63db7b6657f08b4", "html_url": "https://github.com/rust-lang/rust/commit/a38991f755e0180101d46351a63db7b6657f08b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a38991f755e0180101d46351a63db7b6657f08b4/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63d73fd70bcea43b457a9863d8b6d20ebc89c09f", "url": "https://api.github.com/repos/rust-lang/rust/commits/63d73fd70bcea43b457a9863d8b6d20ebc89c09f", "html_url": "https://github.com/rust-lang/rust/commit/63d73fd70bcea43b457a9863d8b6d20ebc89c09f"}], "stats": {"total": 159, "additions": 92, "deletions": 67}, "files": [{"sha": "74f352eb3be6ff5bdd1957948e40043ce13d8f34", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a38991f755e0180101d46351a63db7b6657f08b4/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a38991f755e0180101d46351a63db7b6657f08b4/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=a38991f755e0180101d46351a63db7b6657f08b4", "patch": "@@ -649,13 +649,11 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 use SavedLocalEligibility::*;\n \n                 let mut assignments: IndexVec<GeneratorSavedLocal, SavedLocalEligibility> =\n-                    iter::repeat(Unassigned)\n-                    .take(info.field_tys.len())\n-                    .collect();\n+                    IndexVec::from_elem_n(Unassigned, info.field_tys.len());\n \n                 // The saved locals not eligible for overlap. These will get\n                 // \"promoted\" to the prefix of our generator.\n-                let mut eligible_locals = BitSet::new_filled(info.field_tys.len());\n+                let mut ineligible_locals = BitSet::new_empty(info.field_tys.len());\n \n                 // Figure out which of our saved locals are fields in only\n                 // one variant. The rest are deemed ineligible for overlap.\n@@ -670,7 +668,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                                 // point, so it is no longer a candidate.\n                                 trace!(\"removing local {:?} in >1 variant ({:?}, {:?})\",\n                                        local, variant_index, idx);\n-                                eligible_locals.remove(*local);\n+                                ineligible_locals.insert(*local);\n                                 assignments[*local] = Ineligible(None);\n                             }\n                             Ineligible(_) => {},\n@@ -681,46 +679,50 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 // Next, check every pair of eligible locals to see if they\n                 // conflict.\n                 for (local_a, conflicts_a) in info.storage_conflicts.iter_enumerated() {\n-                    if !eligible_locals.contains(local_a) {\n+                    if ineligible_locals.contains(local_a) {\n                         continue;\n                     }\n \n                     for local_b in conflicts_a.iter() {\n-                        // local_a and local_b have overlapping storage, therefore they\n+                        // local_a and local_b are storage live at the same time, therefore they\n                         // cannot overlap in the generator layout. The only way to guarantee\n                         // this is if they are in the same variant, or one is ineligible\n                         // (which means it is stored in every variant).\n-                        if !eligible_locals.contains(local_b) ||\n+                        if ineligible_locals.contains(local_b) ||\n                             assignments[local_a] == assignments[local_b]\n                         {\n                             continue;\n                         }\n \n                         // If they conflict, we will choose one to make ineligible.\n+                        // This is not always optimal; it's just a greedy heuristic\n+                        // that seems to produce good results most of the time.\n                         let conflicts_b = &info.storage_conflicts[local_b];\n                         let (remove, other) = if conflicts_a.count() > conflicts_b.count() {\n                             (local_a, local_b)\n                         } else {\n                             (local_b, local_a)\n                         };\n-                        eligible_locals.remove(remove);\n+                        ineligible_locals.insert(remove);\n                         assignments[remove] = Ineligible(None);\n                         trace!(\"removing local {:?} due to conflict with {:?}\", remove, other);\n                     }\n                 }\n \n-                let mut ineligible_locals = BitSet::new_filled(info.field_tys.len());\n-                ineligible_locals.subtract(&eligible_locals);\n-\n                 // Write down the order of our locals that will be promoted to\n                 // the prefix.\n-                for (idx, local) in ineligible_locals.iter().enumerate() {\n-                    assignments[local] = Ineligible(Some(idx as u32));\n+                {\n+                    let mut idx = 0u32;\n+                    for local in ineligible_locals.iter() {\n+                        assignments[local] = Ineligible(Some(idx));\n+                        idx += 1;\n+                    }\n                 }\n                 debug!(\"generator saved local assignments: {:?}\", assignments);\n \n                 // Build a prefix layout, including \"promoting\" all ineligible\n-                // locals as part of the prefix.\n+                // locals as part of the prefix. We compute the layout of all of\n+                // these fields at once to get optimal packing.\n                 let discr_index = substs.prefix_tys(def_id, tcx).count();\n                 let promoted_tys =\n                     ineligible_locals.iter().map(|local| subst_field(info.field_tys[local]));\n@@ -733,20 +735,23 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     StructKind::AlwaysSized)?;\n                 let (prefix_size, prefix_align) = (prefix.size, prefix.align);\n \n-                // Split the prefix layout into the \"outer\" fields (upvars and\n-                // discriminant) and the \"promoted\" fields. Promoted fields will\n-                // get included in each variant that requested them in\n-                // GeneratorLayout.\n-                let renumber_indices = |mut index: Vec<u32>| -> Vec<u32> {\n-                    debug!(\"renumber_indices({:?})\", index);\n-                    let mut inverse_index = (0..index.len() as u32).collect::<Vec<_>>();\n-                    inverse_index.sort_unstable_by_key(|i| index[*i as usize]);\n+                let recompute_memory_index = |offsets: &Vec<u32>| -> Vec<u32> {\n+                    debug!(\"recompute_memory_index({:?})\", offsets);\n+                    let mut inverse_index = (0..offsets.len() as u32).collect::<Vec<_>>();\n+                    inverse_index.sort_unstable_by_key(|i| offsets[*i as usize]);\n+\n+                    let mut index = vec![0; offsets.len()];\n                     for i in 0..index.len() {\n                         index[inverse_index[i] as usize] = i as u32;\n                     }\n-                    debug!(\"renumber_indices() => {:?}\", index);\n+                    debug!(\"recompute_memory_index() => {:?}\", index);\n                     index\n                 };\n+\n+                // Split the prefix layout into the \"outer\" fields (upvars and\n+                // discriminant) and the \"promoted\" fields. Promoted fields will\n+                // get included in each variant that requested them in\n+                // GeneratorLayout.\n                 debug!(\"prefix = {:#?}\", prefix);\n                 let (outer_fields, promoted_offsets, promoted_memory_index) = match prefix.fields {\n                     FieldPlacement::Arbitrary { offsets, memory_index } => {\n@@ -756,11 +761,11 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             memory_index.split_at(discr_index + 1);\n                         let outer_fields = FieldPlacement::Arbitrary {\n                             offsets: offsets_a.to_vec(),\n-                            memory_index: renumber_indices(memory_index_a.to_vec())\n+                            memory_index: recompute_memory_index(&memory_index_a.to_vec())\n                         };\n                         (outer_fields,\n                          offsets_b.to_vec(),\n-                         renumber_indices(memory_index_b.to_vec()))\n+                         recompute_memory_index(&memory_index_b.to_vec()))\n                     }\n                     _ => bug!(),\n                 };\n@@ -769,15 +774,17 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                 let mut align = prefix.align;\n                 let variants = info.variant_fields.iter_enumerated().map(|(index, variant_fields)| {\n                     // Only include overlap-eligible fields when we compute our variant layout.\n-                    let variant_only_tys = variant_fields.iter().flat_map(|local| {\n-                        let ty = info.field_tys[*local];\n-                        match assignments[*local] {\n-                            Unassigned => bug!(),\n-                            Assigned(v) if v == index => Some(subst_field(ty)),\n-                            Assigned(_) => bug!(\"assignment does not match variant\"),\n-                            Ineligible(_) => None,\n-                        }\n-                    });\n+                    let variant_only_tys = variant_fields\n+                        .iter()\n+                        .filter(|local| {\n+                            match assignments[**local] {\n+                                Unassigned => bug!(),\n+                                Assigned(v) if v == index => true,\n+                                Assigned(_) => bug!(\"assignment does not match variant\"),\n+                                Ineligible(_) => false,\n+                            }\n+                        })\n+                        .map(|local| subst_field(info.field_tys[*local]));\n \n                     let mut variant = univariant_uninterned(\n                         &variant_only_tys\n@@ -823,7 +830,7 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                     }\n                     variant.fields = FieldPlacement::Arbitrary {\n                         offsets: combined_offsets,\n-                        memory_index: renumber_indices(combined_memory_index),\n+                        memory_index: recompute_memory_index(&combined_memory_index),\n                     };\n \n                     size = size.max(variant.size);"}, {"sha": "03a48a38c4a6d4d9a8b3df43cc5ee2d11b3c89d2", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a38991f755e0180101d46351a63db7b6657f08b4/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a38991f755e0180101d46351a63db7b6657f08b4/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=a38991f755e0180101d46351a63db7b6657f08b4", "patch": "@@ -431,7 +431,7 @@ fn for_each_block_location<'tcx, T: BitDenotation<'tcx>>(\n         let term_loc = Location { block, statement_index: mir[block].statements.len() };\n         analysis.before_terminator_effect(&mut sets, term_loc);\n         f(sets.gen_set, term_loc);\n-        analysis.before_statement_effect(&mut sets, term_loc);\n+        analysis.terminator_effect(&mut sets, term_loc);\n         f(sets.gen_set, term_loc);\n     }\n }"}, {"sha": "1bcffcfb4d2980d498ab8db230629d93d4631027", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 48, "deletions": 30, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a38991f755e0180101d46351a63db7b6657f08b4/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a38991f755e0180101d46351a63db7b6657f08b4/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=a38991f755e0180101d46351a63db7b6657f08b4", "patch": "@@ -394,17 +394,33 @@ impl<'tcx> Visitor<'tcx> for StorageIgnored {\n     }\n }\n \n+struct LivenessInfo {\n+    /// Which locals are live across any suspension point.\n+    ///\n+    /// GeneratorSavedLocal is indexed in terms of the elements in this set;\n+    /// i.e. GeneratorSavedLocal::new(1) corresponds to the second local\n+    /// included in this set.\n+    live_locals: liveness::LiveVarSet,\n+\n+    /// The set of saved locals live at each suspension point.\n+    live_locals_at_suspension_points: Vec<BitSet<GeneratorSavedLocal>>,\n+\n+    /// For every saved local, the set of other saved locals that are\n+    /// storage-live at the same time as this local. We cannot overlap locals in\n+    /// the layout which have conflicting storage.\n+    storage_conflicts: IndexVec<GeneratorSavedLocal, BitSet<GeneratorSavedLocal>>,\n+\n+    /// For every suspending block, the locals which are storage-live across\n+    /// that suspension point.\n+    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet>,\n+}\n+\n fn locals_live_across_suspend_points(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     body: &Body<'tcx>,\n     source: MirSource<'tcx>,\n     movable: bool,\n-) -> (\n-    liveness::LiveVarSet,\n-    Vec<BitSet<GeneratorSavedLocal>>,\n-    IndexVec<GeneratorSavedLocal, BitSet<GeneratorSavedLocal>>,\n-    FxHashMap<BasicBlock, liveness::LiveVarSet>,\n-) {\n+) -> LivenessInfo {\n     let dead_unwinds = BitSet::new_empty(body.basic_blocks().len());\n     let def_id = source.def_id();\n \n@@ -434,7 +450,7 @@ fn locals_live_across_suspend_points(\n     };\n \n     // Calculate the liveness of MIR locals ignoring borrows.\n-    let mut set = liveness::LiveVarSet::new_empty(body.local_decls.len());\n+    let mut live_locals = liveness::LiveVarSet::new_empty(body.local_decls.len());\n     let mut liveness = liveness::liveness_of_locals(\n         body,\n     );\n@@ -489,36 +505,40 @@ fn locals_live_across_suspend_points(\n             // Locals live are live at this point only if they are used across\n             // suspension points (the `liveness` variable)\n             // and their storage is live (the `storage_liveness` variable)\n-            storage_liveness.intersect(&liveness.outs[block]);\n+            let mut live_locals_here = storage_liveness;\n+            live_locals_here.intersect(&liveness.outs[block]);\n \n             // The generator argument is ignored\n-            storage_liveness.remove(self_arg());\n-\n-            let live_locals = storage_liveness;\n+            live_locals_here.remove(self_arg());\n \n             // Add the locals live at this suspension point to the set of locals which live across\n             // any suspension points\n-            set.union(&live_locals);\n+            live_locals.union(&live_locals_here);\n \n-            live_locals_at_suspension_points.push(live_locals);\n+            live_locals_at_suspension_points.push(live_locals_here);\n         }\n     }\n \n     // Renumber our liveness_map bitsets to include only the locals we are\n     // saving.\n     let live_locals_at_suspension_points = live_locals_at_suspension_points\n         .iter()\n-        .map(|live_locals| renumber_bitset(&live_locals, &set))\n+        .map(|live_here| renumber_bitset(&live_here, &live_locals))\n         .collect();\n \n     let storage_conflicts = compute_storage_conflicts(\n         body,\n-        &set,\n+        &live_locals,\n         &ignored,\n         storage_live,\n         storage_live_analysis);\n \n-    (set, live_locals_at_suspension_points, storage_conflicts, storage_liveness_map)\n+    LivenessInfo {\n+        live_locals,\n+        live_locals_at_suspension_points,\n+        storage_conflicts,\n+        storage_liveness: storage_liveness_map,\n+    }\n }\n \n /// For every saved local, looks for which locals are StorageLive at the same\n@@ -555,14 +575,11 @@ fn compute_storage_conflicts(\n         eligible_storage_live.intersect(&stored_locals);\n \n         for local in eligible_storage_live.iter() {\n-            let mut overlaps = eligible_storage_live.clone();\n-            overlaps.remove(local);\n-            local_conflicts[local].union(&overlaps);\n+            local_conflicts[local].union(&eligible_storage_live);\n+        }\n \n-            if !overlaps.is_empty() {\n-                trace!(\"at {:?}, local {:?} conflicts with {:?}\",\n-                       loc, local, overlaps);\n-            }\n+        if eligible_storage_live.count() > 1 {\n+            trace!(\"at {:?}, eligible_storage_live={:?}\", loc, eligible_storage_live);\n         }\n     });\n \n@@ -617,8 +634,9 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         FxHashMap<BasicBlock, liveness::LiveVarSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n-    let (live_locals, live_locals_at_suspension_points, storage_conflicts, storage_liveness) =\n-        locals_live_across_suspend_points(tcx, body, source, movable);\n+    let LivenessInfo {\n+        live_locals, live_locals_at_suspension_points, storage_conflicts, storage_liveness\n+    } = locals_live_across_suspend_points(tcx, body, source, movable);\n \n     // Erase regions from the types passed in from typeck so we can compare them with\n     // MIR types\n@@ -673,11 +691,11 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut fields = IndexVec::new();\n         for (idx, saved_local) in live_locals.iter().enumerate() {\n             fields.push(saved_local);\n-            // Note that if a field is included in multiple variants, it will be\n-            // added overwritten here. That's fine; fields do not move around\n-            // inside generators, so it doesn't matter which variant index we\n-            // access them by.\n-            remap.insert(locals[saved_local], (tys[saved_local], variant_index, idx));\n+            // Note that if a field is included in multiple variants, we will\n+            // just use the first one here. That's fine; fields do not move\n+            // around inside generators, so it doesn't matter which variant\n+            // index we access them by.\n+            remap.entry(locals[saved_local]).or_insert((tys[saved_local], variant_index, idx));\n         }\n         variant_fields.push(fields);\n     }"}]}