{"sha": "062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MmEwNWRkZThjM2VhNTM4NmZhMzU4ZDg4MmUxZWFjYTk5YTlmZjA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-23T19:10:29Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T15:51:58Z"}, "message": "metadata: Constrain FoundAst::FoundParent to an Item.", "tree": {"sha": "5bb45b66a71e282366ca7f2a7c16aca44143cce8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5bb45b66a71e282366ca7f2a7c16aca44143cce8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "html_url": "https://github.com/rust-lang/rust/commit/062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/062a05dde8c3ea5386fa358d882e1eaca99a9ff0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b918e37eb3e393c5a5b0408430e146c0b66ec7ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/b918e37eb3e393c5a5b0408430e146c0b66ec7ed", "html_url": "https://github.com/rust-lang/rust/commit/b918e37eb3e393c5a5b0408430e146c0b66ec7ed"}], "stats": {"total": 171, "additions": 70, "deletions": 101}, "files": [{"sha": "cde79c4659a964a67880afded219b0e3235ed0a8", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/062a05dde8c3ea5386fa358d882e1eaca99a9ff0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062a05dde8c3ea5386fa358d882e1eaca99a9ff0/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "patch": "@@ -122,7 +122,7 @@ pub struct ChildItem {\n \n pub enum FoundAst<'ast> {\n     Found(&'ast InlinedItem),\n-    FoundParent(DefId, &'ast InlinedItem),\n+    FoundParent(DefId, &'ast hir::Item),\n     NotFound,\n }\n "}, {"sha": "5c5574c3a8300eeab57e5268dd080766a4e40e7b", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 44, "deletions": 54, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/062a05dde8c3ea5386fa358d882e1eaca99a9ff0/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062a05dde8c3ea5386fa358d882e1eaca99a9ff0/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "patch": "@@ -125,61 +125,51 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &TyCtxt<'tcx>,\n                                  parent_path: Vec<ast_map::PathElem>,\n                                  parent_def_path: ast_map::DefPath,\n-                                 par_doc: rbml::Doc,\n+                                 ast_doc: rbml::Doc,\n                                  orig_did: DefId)\n-                                 -> Result<&'tcx InlinedItem, (Vec<ast_map::PathElem>,\n-                                                               ast_map::DefPath)> {\n-    match par_doc.opt_child(c::tag_ast) {\n-      None => Err((parent_path, parent_def_path)),\n-      Some(ast_doc) => {\n-        let mut path_as_str = None;\n-        debug!(\"> Decoding inlined fn: {:?}::?\",\n-        {\n-            // Do an Option dance to use the path after it is moved below.\n-            let s = ast_map::path_to_string(parent_path.iter().cloned());\n-            path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| &x[..])\n-        });\n-        let mut ast_dsr = reader::Decoder::new(ast_doc);\n-        let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n-        let to_id_range = reserve_id_range(&tcx.sess, from_id_range);\n-        let dcx = &DecodeContext {\n-            cdata: cdata,\n-            tcx: tcx,\n-            from_id_range: from_id_range,\n-            to_id_range: to_id_range,\n-            last_filemap_index: Cell::new(0)\n-        };\n-        let raw_ii = decode_ast(ast_doc);\n-        let ii = ast_map::map_decoded_item(&dcx.tcx.map,\n-                                           parent_path,\n-                                           parent_def_path,\n-                                           raw_ii,\n-                                           dcx);\n-        let name = match *ii {\n-            InlinedItem::Item(ref i) => i.name,\n-            InlinedItem::Foreign(ref i) => i.name,\n-            InlinedItem::TraitItem(_, ref ti) => ti.name,\n-            InlinedItem::ImplItem(_, ref ii) => ii.name\n-        };\n-        debug!(\"Fn named: {}\", name);\n-        debug!(\"< Decoded inlined fn: {}::{}\",\n-               path_as_str.unwrap(),\n-               name);\n-        region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n-        decode_side_tables(dcx, ast_doc);\n-        copy_item_types(dcx, ii, orig_did);\n-        match *ii {\n-          InlinedItem::Item(ref i) => {\n-            debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n-                   ::rustc_front::print::pprust::item_to_string(&i));\n-          }\n-          _ => { }\n-        }\n-\n-        Ok(ii)\n-      }\n-    }\n+                                 -> &'tcx InlinedItem {\n+    let mut path_as_str = None;\n+    debug!(\"> Decoding inlined fn: {:?}::?\",\n+    {\n+        // Do an Option dance to use the path after it is moved below.\n+        let s = ast_map::path_to_string(parent_path.iter().cloned());\n+        path_as_str = Some(s);\n+        path_as_str.as_ref().map(|x| &x[..])\n+    });\n+    let mut ast_dsr = reader::Decoder::new(ast_doc);\n+    let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n+    let to_id_range = reserve_id_range(&tcx.sess, from_id_range);\n+    let dcx = &DecodeContext {\n+        cdata: cdata,\n+        tcx: tcx,\n+        from_id_range: from_id_range,\n+        to_id_range: to_id_range,\n+        last_filemap_index: Cell::new(0)\n+    };\n+    let ii = ast_map::map_decoded_item(&dcx.tcx.map,\n+                                       parent_path,\n+                                       parent_def_path,\n+                                       decode_ast(ast_doc),\n+                                       dcx);\n+    let name = match *ii {\n+        InlinedItem::Item(ref i) => i.name,\n+        InlinedItem::Foreign(ref i) => i.name,\n+        InlinedItem::TraitItem(_, ref ti) => ti.name,\n+        InlinedItem::ImplItem(_, ref ii) => ii.name\n+    };\n+    debug!(\"Fn named: {}\", name);\n+    debug!(\"< Decoded inlined fn: {}::{}\",\n+            path_as_str.unwrap(),\n+            name);\n+    region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n+    decode_side_tables(dcx, ast_doc);\n+    copy_item_types(dcx, ii, orig_did);\n+    if let InlinedItem::Item(ref i) = *ii {\n+        debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n+               ::rustc_front::print::pprust::item_to_string(&i));\n+    }\n+\n+    ii\n }\n \n // ______________________________________________________________________"}, {"sha": "7af01d8abe7e284608a171ead8e6e0f6e51fa906", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 23, "deletions": 40, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/062a05dde8c3ea5386fa358d882e1eaca99a9ff0/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062a05dde8c3ea5386fa358d882e1eaca99a9ff0/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "patch": "@@ -798,53 +798,36 @@ pub fn get_item_name(intr: &IdentInterner, cdata: Cmd, id: DefIndex) -> ast::Nam\n     item_name(intr, cdata.lookup_item(id))\n }\n \n-pub fn maybe_get_item_ast<'tcx>(cdata: Cmd,\n-                                tcx: &TyCtxt<'tcx>,\n-                                id: DefIndex,\n+pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &TyCtxt<'tcx>, id: DefIndex)\n                                 -> FoundAst<'tcx> {\n     debug!(\"Looking up item: {:?}\", id);\n     let item_doc = cdata.lookup_item(id);\n     let item_did = item_def_id(item_doc, cdata);\n-    let parent_path = {\n-        let mut path = item_path(item_doc);\n-        path.pop();\n-        path\n-    };\n-    let parent_def_path = {\n-        let mut def_path = def_path(cdata, id);\n-        def_path.pop();\n-        def_path\n-    };\n-    match decode_inlined_item(cdata,\n-                              tcx,\n-                              parent_path,\n-                              parent_def_path,\n-                              item_doc,\n-                              item_did) {\n-        Ok(ii) => FoundAst::Found(ii),\n-        Err((mut parent_path, mut parent_def_path)) => {\n-            match item_parent_item(cdata, item_doc) {\n-                Some(parent_did) => {\n-                    // Remove the last element from the paths, since we are now\n-                    // trying to inline the parent.\n-                    parent_path.pop();\n-                    parent_def_path.pop();\n-\n-                    let parent_item = cdata.lookup_item(parent_did.index);\n-                    match decode_inlined_item(cdata,\n-                                              tcx,\n-                                              parent_path,\n-                                              parent_def_path,\n-                                              parent_item,\n-                                              parent_did) {\n-                        Ok(ii) => FoundAst::FoundParent(parent_did, ii),\n-                        Err(_) => FoundAst::NotFound\n-                    }\n-                }\n-                None => FoundAst::NotFound\n+    let mut parent_path = item_path(item_doc);\n+    parent_path.pop();\n+    let mut parent_def_path = def_path(cdata, id);\n+    parent_def_path.pop();\n+    if let Some(ast_doc) = reader::maybe_get_doc(item_doc, tag_ast as usize) {\n+        let ii = decode_inlined_item(cdata, tcx, parent_path,\n+                                     parent_def_path,\n+                                     ast_doc, item_did);\n+        return FoundAst::Found(ii);\n+    } else if let Some(parent_did) = item_parent_item(cdata, item_doc) {\n+        // Remove the last element from the paths, since we are now\n+        // trying to inline the parent.\n+        parent_path.pop();\n+        parent_def_path.pop();\n+        let parent_doc = cdata.lookup_item(parent_did.index);\n+        if let Some(ast_doc) = reader::maybe_get_doc(parent_doc, tag_ast as usize) {\n+            let ii = decode_inlined_item(cdata, tcx, parent_path,\n+                                         parent_def_path,\n+                                         ast_doc, parent_did);\n+            if let &InlinedItem::Item(ref i) = ii {\n+                return FoundAst::FoundParent(parent_did, i);\n             }\n         }\n     }\n+    FoundAst::NotFound\n }\n \n pub fn is_item_mir_available<'tcx>(cdata: Cmd, id: DefIndex) -> bool {"}, {"sha": "0dcb0c29fafe05823e7b21d6a6562cc900e39d3f", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/062a05dde8c3ea5386fa358d882e1eaca99a9ff0/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062a05dde8c3ea5386fa358d882e1eaca99a9ff0/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=062a05dde8c3ea5386fa358d882e1eaca99a9ff0", "patch": "@@ -93,15 +93,15 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             item.id\n         }\n-        FoundAst::FoundParent(parent_id, &InlinedItem::Item(ref item)) => {\n+        FoundAst::FoundParent(parent_id, item) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n             let mut my_id = 0;\n             match item.node {\n                 hir::ItemEnum(ref ast_def, _) => {\n                     let ast_vs = &ast_def.variants;\n-                    let ty_vs = &ccx.tcx().lookup_adt_def(parent_id).variants;\n+                    let ty_vs = &tcx.lookup_adt_def(parent_id).variants;\n                     assert_eq!(ast_vs.len(), ty_vs.len());\n                     for (ast_v, ty_v) in ast_vs.iter().zip(ty_vs.iter()) {\n                         if ty_v.did == fn_id { my_id = ast_v.node.data.id(); }\n@@ -123,10 +123,6 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: DefId) -> Option<DefId> {\n             trans_item(ccx, &item);\n             my_id\n         }\n-        FoundAst::FoundParent(_, _) => {\n-            ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\\n-                            with a non-item parent\");\n-        }\n         FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(trait_item.id));\n             ccx.external_srcs().borrow_mut().insert(trait_item.id, fn_id);"}]}