{"sha": "09b0a8a813d178233aff88d521ff0aa672ff6dbe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YjBhOGE4MTNkMTc4MjMzYWZmODhkNTIxZmYwYWE2NzJmZjZkYmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-13T22:58:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-13T22:58:24Z"}, "message": "Auto merge of #1022 - christianpoveda:fix-fd-access, r=RalfJung\n\nFix unchecked memory access for files\n\nThis PR takes care of two problems:\n\n- It uses `Memory::(read|write)_bytes` to guarantee that memory accesses are checked (Fixes: https://github.com/rust-lang/miri/issues/1007)\n- It removes the `(get|remove)_handle_and` methods which were a little bit cumbersome to use. In particular `remove_handle_and`, because we were using it to avoid borrowing issues before the `Evaluator::memory` field was public.\n\n@RalfJung @oli-obk", "tree": {"sha": "b5a46add397dfc5626385f577b051850d0e549ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5a46add397dfc5626385f577b051850d0e549ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09b0a8a813d178233aff88d521ff0aa672ff6dbe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09b0a8a813d178233aff88d521ff0aa672ff6dbe", "html_url": "https://github.com/rust-lang/rust/commit/09b0a8a813d178233aff88d521ff0aa672ff6dbe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09b0a8a813d178233aff88d521ff0aa672ff6dbe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69415b48e2e57ef7f528c55930a21fdb5897c822", "url": "https://api.github.com/repos/rust-lang/rust/commits/69415b48e2e57ef7f528c55930a21fdb5897c822", "html_url": "https://github.com/rust-lang/rust/commit/69415b48e2e57ef7f528c55930a21fdb5897c822"}, {"sha": "4baef7120a934b79f87dbe5d09591d781c1c81f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4baef7120a934b79f87dbe5d09591d781c1c81f7", "html_url": "https://github.com/rust-lang/rust/commit/4baef7120a934b79f87dbe5d09591d781c1c81f7"}], "stats": {"total": 163, "additions": 84, "deletions": 79}, "files": [{"sha": "4de59ad32ff59dc2ae2b9478a07870e394622c69", "filename": "src/shims/fs.rs", "status": "modified", "additions": 84, "deletions": 79, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/09b0a8a813d178233aff88d521ff0aa672ff6dbe/src%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09b0a8a813d178233aff88d521ff0aa672ff6dbe/src%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ffs.rs?ref=09b0a8a813d178233aff88d521ff0aa672ff6dbe", "patch": "@@ -1,5 +1,6 @@\n use std::collections::HashMap;\n-use std::fs::{File, OpenOptions, remove_file};\n+use std::convert::TryFrom;\n+use std::fs::{remove_file, File, OpenOptions};\n use std::io::{Read, Write};\n \n use rustc::ty::layout::Size;\n@@ -125,8 +126,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n             // always sets this flag when opening a file. However we still need to check that the\n             // file itself is open.\n-            let fd_cloexec = this.eval_libc_i32(\"FD_CLOEXEC\")?;\n-            this.get_handle_and(fd, |_| Ok(fd_cloexec))\n+            if this.machine.file_handler.handles.contains_key(&fd) {\n+                Ok(this.eval_libc_i32(\"FD_CLOEXEC\")?)\n+            } else {\n+                this.handle_not_found()\n+            }\n         } else {\n             throw_unsup_format!(\"The {:#x} command is not supported for `fcntl`)\", cmd);\n         }\n@@ -139,9 +143,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n-        this.remove_handle_and(fd, |handle, this| {\n-            this.try_unwrap_io_result(handle.file.sync_all().map(|_| 0i32))\n-        })\n+        if let Some(handle) = this.machine.file_handler.handles.remove(&fd) {\n+            // `File::sync_all` does the checks that are done when closing a file. We do this to\n+            // to handle possible errors correctly.\n+            let result = this.try_unwrap_io_result(handle.file.sync_all().map(|_| 0i32));\n+            // Now we actually close the file.\n+            drop(handle);\n+            // And return the result.\n+            result\n+        } else {\n+            this.handle_not_found()\n+        }\n     }\n \n     fn read(\n@@ -154,27 +166,50 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"read\")?;\n \n-        let count = this.read_scalar(count_op)?.to_machine_usize(&*this.tcx)?;\n+        let ptr_size = this.pointer_size().bits();\n+\n+        // We cap the number of read bytes to the largest value that we are able to fit in both the\n+        // host's and target's `isize`.\n+        let count = this\n+            .read_scalar(count_op)?\n+            .to_machine_usize(&*this.tcx)?\n+            .min((1 << (ptr_size - 1)) - 1) // max value of target `isize`\n+            .min(isize::max_value() as u64);\n         // Reading zero bytes should not change `buf`.\n         if count == 0 {\n             return Ok(0);\n         }\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        let buf_scalar = this.read_scalar(buf_op)?.not_undef()?;\n-\n-        // Remove the file handle to avoid borrowing issues.\n-        this.remove_handle_and(fd, |mut handle, this| {\n-            // Don't use `?` to avoid returning before reinserting the handle.\n-            let bytes = this.force_ptr(buf_scalar).and_then(|buf| {\n-                // FIXME: Don't use raw methods\n-                this.memory\n-                    .get_raw_mut(buf.alloc_id)?\n-                    .get_bytes_mut(&*this.tcx, buf, Size::from_bytes(count))\n-                    .map(|buffer| handle.file.read(buffer))\n-            });\n-            this.machine.file_handler.handles.insert(fd, handle).unwrap_none();\n-            this.try_unwrap_io_result(bytes?.map(|bytes| bytes as i64))\n-        })\n+        let buf = this.read_scalar(buf_op)?.not_undef()?;\n+\n+        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n+            // This can never fail because `count` was capped to be smaller than\n+            // `isize::max_value()`.\n+            let count = isize::try_from(count).unwrap();\n+            // We want to read at most `count` bytes. We are sure that `count` is not negative\n+            // because it was a target's `usize`. Also we are sure that its smaller than\n+            // `usize::max_value()` because it is a host's `isize`.\n+            let mut bytes = vec![0; count as usize];\n+            let result = handle\n+                .file\n+                .read(&mut bytes)\n+                // `File::read` never returns a value larger than `count`, so this cannot fail.\n+                .map(|c| i64::try_from(c).unwrap());\n+\n+            match result {\n+                Ok(read_bytes) => {\n+                    // If reading to `bytes` did not fail, we write those bytes to the buffer.\n+                    this.memory.write_bytes(buf, bytes)?;\n+                    Ok(read_bytes)\n+                }\n+                Err(e) => {\n+                    this.set_last_error_from_io_error(e)?;\n+                    Ok(-1)\n+                }\n+            }\n+        } else {\n+            this.handle_not_found()\n+        }\n     }\n \n     fn write(\n@@ -187,27 +222,32 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.check_no_isolation(\"write\")?;\n \n-        let count = this.read_scalar(count_op)?.to_machine_usize(&*this.tcx)?;\n+        let ptr_size = this.pointer_size().bits();\n+\n+        // We cap the number of read bytes to the largest value that we are able to fit in both the\n+        // host's and target's `isize`.\n+        let count = this\n+            .read_scalar(count_op)?\n+            .to_machine_usize(&*this.tcx)?\n+            .min((1 << (ptr_size - 1)) - 1) // max value of target `isize`\n+            .min(isize::max_value() as u64);\n         // Writing zero bytes should not change `buf`.\n         if count == 0 {\n             return Ok(0);\n         }\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n-        let buf = this.force_ptr(this.read_scalar(buf_op)?.not_undef()?)?;\n-\n-        this.remove_handle_and(fd, |mut handle, this| {\n-            // FIXME: Don't use raw methods\n-            let bytes = this.memory.get_raw(buf.alloc_id).and_then(|alloc| {\n-                alloc\n-                    .get_bytes(&*this.tcx, buf, Size::from_bytes(count))\n-                    .map(|bytes| handle.file.write(bytes).map(|bytes| bytes as i64))\n-            });\n-            this.machine.file_handler.handles.insert(fd, handle).unwrap_none();\n-            this.try_unwrap_io_result(bytes?)\n-        })\n+        let buf = this.read_scalar(buf_op)?.not_undef()?;\n+\n+        if let Some(handle) = this.machine.file_handler.handles.get_mut(&fd) {\n+            let bytes = this.memory.read_bytes(buf, Size::from_bytes(count))?;\n+            let result = handle.file.write(&bytes).map(|c| i64::try_from(c).unwrap());\n+            this.try_unwrap_io_result(result)\n+        } else {\n+            this.handle_not_found()\n+        }\n     }\n \n-    fn unlink( &mut self, path_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn unlink(&mut self, path_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.check_no_isolation(\"unlink\")?;\n@@ -219,49 +259,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(result)\n     }\n \n-    /// Helper function that gets a `FileHandle` immutable reference and allows to manipulate it\n-    /// using the `f` closure.\n-    ///\n-    /// If the `fd` file descriptor does not correspond to a file, this functions returns `Ok(-1)`\n-    /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n-    ///\n-    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n-    /// functions return different integer types (like `read`, that returns an `i64`).\n-    fn get_handle_and<F, T: From<i32>>(&mut self, fd: i32, f: F) -> InterpResult<'tcx, T>\n-    where\n-        F: Fn(&FileHandle) -> InterpResult<'tcx, T>,\n-    {\n+    /// Function used when a handle is not found inside `FileHandler`. It returns `Ok(-1)`and sets\n+    /// the last OS error to `libc::EBADF` (invalid file descriptor). This function uses\n+    /// `T: From<i32>` instead of `i32` directly because some fs functions return different integer\n+    /// types (like `read`, that returns an `i64`).\n+    fn handle_not_found<T: From<i32>>(&mut self) -> InterpResult<'tcx, T> {\n         let this = self.eval_context_mut();\n-        if let Some(handle) = this.machine.file_handler.handles.get(&fd) {\n-            f(handle)\n-        } else {\n-            let ebadf = this.eval_libc(\"EBADF\")?;\n-            this.set_last_error(ebadf)?;\n-            Ok((-1).into())\n-        }\n-    }\n-\n-    /// Helper function that removes a `FileHandle` and allows to manipulate it using the `f`\n-    /// closure. This function is quite useful when you need to modify a `FileHandle` but you need\n-    /// to modify `MiriEvalContext` at the same time, so you can modify the handle and reinsert it\n-    /// using `f`.\n-    ///\n-    /// If the `fd` file descriptor does not correspond to a file, this functions returns `Ok(-1)`\n-    /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n-    ///\n-    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n-    /// functions return different integer types (like `read`, that returns an `i64`).\n-    fn remove_handle_and<F, T: From<i32>>(&mut self, fd: i32, mut f: F) -> InterpResult<'tcx, T>\n-    where\n-        F: FnMut(FileHandle, &mut MiriEvalContext<'mir, 'tcx>) -> InterpResult<'tcx, T>,\n-    {\n-        let this = self.eval_context_mut();\n-        if let Some(handle) = this.machine.file_handler.handles.remove(&fd) {\n-            f(handle, this)\n-        } else {\n-            let ebadf = this.eval_libc(\"EBADF\")?;\n-            this.set_last_error(ebadf)?;\n-            Ok((-1).into())\n-        }\n+        let ebadf = this.eval_libc(\"EBADF\")?;\n+        this.set_last_error(ebadf)?;\n+        Ok((-1).into())\n     }\n }"}]}