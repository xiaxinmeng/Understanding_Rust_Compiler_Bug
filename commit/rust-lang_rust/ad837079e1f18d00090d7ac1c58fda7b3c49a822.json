{"sha": "ad837079e1f18d00090d7ac1c58fda7b3c49a822", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkODM3MDc5ZTFmMThkMDAwOTBkN2FjMWM1OGZkYTdiM2M0OWE4MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-05T22:52:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-05T22:52:21Z"}, "message": "Auto merge of #817 - RalfJung:small-alloc, r=RalfJung\n\nalign small malloc-allocations even less, and test that we do\n\nNeeds https://github.com/rust-lang/rust/pull/62295 to land.\n\nFixes https://github.com/rust-lang/miri/issues/812.", "tree": {"sha": "351de76249cfc6e2c2e212970a3f9a3f99cf5380", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/351de76249cfc6e2c2e212970a3f9a3f99cf5380"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad837079e1f18d00090d7ac1c58fda7b3c49a822", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad837079e1f18d00090d7ac1c58fda7b3c49a822", "html_url": "https://github.com/rust-lang/rust/commit/ad837079e1f18d00090d7ac1c58fda7b3c49a822", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad837079e1f18d00090d7ac1c58fda7b3c49a822/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "285fc0d70e33e91016d288f0afd0971a85095f3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/285fc0d70e33e91016d288f0afd0971a85095f3c", "html_url": "https://github.com/rust-lang/rust/commit/285fc0d70e33e91016d288f0afd0971a85095f3c"}, {"sha": "029a29407acd30454fb41f340a8d108a47bef349", "url": "https://api.github.com/repos/rust-lang/rust/commits/029a29407acd30454fb41f340a8d108a47bef349", "html_url": "https://github.com/rust-lang/rust/commit/029a29407acd30454fb41f340a8d108a47bef349"}], "stats": {"total": 117, "additions": 73, "deletions": 44}, "files": [{"sha": "cbd8e335771e35cb73fdfb2d643b913ccb9e980b", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad837079e1f18d00090d7ac1c58fda7b3c49a822/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/ad837079e1f18d00090d7ac1c58fda7b3c49a822/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=ad837079e1f18d00090d7ac1c58fda7b3c49a822", "patch": "@@ -1 +1 @@\n-088b987307b91612ab164026e1dcdd0129fdb62b\n+24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca"}, {"sha": "b29ce3537706bf01be3da729f03cf40c1e1370d4", "filename": "src/eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad837079e1f18d00090d7ac1c58fda7b3c49a822/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad837079e1f18d00090d7ac1c58fda7b3c49a822/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=ad837079e1f18d00090d7ac1c58fda7b3c49a822", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n use crate::{\n-    InterpResult, InterpError, InterpretCx, StackPopCleanup, struct_error,\n+    InterpResult, InterpError, InterpCx, StackPopCleanup, struct_error,\n     Scalar, Tag, Pointer,\n     MemoryExtra, MiriMemoryKind, Evaluator, TlsEvalContextExt,\n };\n@@ -28,8 +28,8 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     tcx: TyCtxt<'tcx>,\n     main_id: DefId,\n     config: MiriConfig,\n-) -> InterpResult<'tcx, InterpretCx<'mir, 'tcx, Evaluator<'tcx>>> {\n-    let mut ecx = InterpretCx::new(\n+) -> InterpResult<'tcx, InterpCx<'mir, 'tcx, Evaluator<'tcx>>> {\n+    let mut ecx = InterpCx::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Evaluator::new(),\n@@ -43,7 +43,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         config.validate\n     };\n \n-    // FIXME: InterpretCx::new should take an initial MemoryExtra\n+    // FIXME: InterpCx::new should take an initial MemoryExtra\n     ecx.memory_mut().extra = MemoryExtra::new(config.seed.map(StdRng::seed_from_u64), validate);\n     \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);"}, {"sha": "930eeee96b5939e73c72902da0c9d85debd284c8", "filename": "src/machine.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ad837079e1f18d00090d7ac1c58fda7b3c49a822/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad837079e1f18d00090d7ac1c58fda7b3c49a822/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=ad837079e1f18d00090d7ac1c58fda7b3c49a822", "patch": "@@ -25,6 +25,8 @@ pub enum MiriMemoryKind {\n     Rust,\n     /// `malloc` memory.\n     C,\n+    /// Windows `HeapAlloc` memory.\n+    WinHeap,\n     /// Part of env var emulation.\n     Env,\n     /// Statics.\n@@ -103,8 +105,8 @@ impl<'tcx> Evaluator<'tcx> {\n     }\n }\n \n-/// A rustc InterpretCx for Miri.\n-pub type MiriEvalContext<'mir, 'tcx> = InterpretCx<'mir, 'tcx, Evaluator<'tcx>>;\n+/// A rustc InterpCx for Miri.\n+pub type MiriEvalContext<'mir, 'tcx> = InterpCx<'mir, 'tcx, Evaluator<'tcx>>;\n \n /// A little trait that's useful to be inherited by extension traits.\n pub trait MiriEvalContextExt<'mir, 'tcx> {\n@@ -136,14 +138,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Static);\n \n     #[inline(always)]\n-    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         ecx.memory().extra.validate\n     }\n \n     /// Returns `Ok()` when the function was handled; fail otherwise.\n     #[inline(always)]\n     fn find_fn(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n@@ -154,7 +156,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn call_intrinsic(\n-        ecx: &mut rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut rustc_mir::interpret::InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: PlaceTy<'tcx, Tag>,\n@@ -164,7 +166,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn ptr_op(\n-        ecx: &rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &rustc_mir::interpret::InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Tag>,\n         right: ImmTy<'tcx, Tag>,\n@@ -173,7 +175,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     fn box_alloc(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"box_alloc for {:?}\", dest.layout.ty);\n@@ -239,7 +241,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn before_terminator(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>\n+    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>\n     {\n         // We are not interested in detecting loops.\n         Ok(())\n@@ -309,7 +311,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn retag(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         kind: mir::RetagKind,\n         place: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n@@ -323,14 +325,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn stack_push(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n         Ok(ecx.memory().extra.stacked_borrows.borrow_mut().new_call())\n     }\n \n     #[inline(always)]\n     fn stack_pop(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         extra: stacked_borrows::CallId,\n     ) -> InterpResult<'tcx> {\n         Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n@@ -407,7 +409,7 @@ impl MayLeak for MiriMemoryKind {\n     fn may_leak(self) -> bool {\n         use self::MiriMemoryKind::*;\n         match self {\n-            Rust | C => false,\n+            Rust | C | WinHeap => false,\n             Env | Static => true,\n         }\n     }"}, {"sha": "2fe2ecc19581aacdc1e29ae6d9b91b80e31af73d", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ad837079e1f18d00090d7ac1c58fda7b3c49a822/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad837079e1f18d00090d7ac1c58fda7b3c49a822/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=ad837079e1f18d00090d7ac1c58fda7b3c49a822", "patch": "@@ -10,30 +10,48 @@ use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// Returns the minimum alignment for the target architecture.\n-    fn min_align(&self) -> Align {\n+    /// Returns the minimum alignment for the target architecture for allocations of the given size.\n+    fn min_align(&self, size: u64, kind: MiriMemoryKind) -> Align {\n         let this = self.eval_context_ref();\n         // List taken from `libstd/sys_common/alloc.rs`.\n         let min_align = match this.tcx.tcx.sess.target.target.arch.as_str() {\n             \"x86\" | \"arm\" | \"mips\" | \"powerpc\" | \"powerpc64\" | \"asmjs\" | \"wasm32\" => 8,\n             \"x86_64\" | \"aarch64\" | \"mips64\" | \"s390x\" | \"sparc64\" => 16,\n             arch => bug!(\"Unsupported target architecture: {}\", arch),\n         };\n-        Align::from_bytes(min_align).unwrap()\n+        // Windows always aligns, even small allocations.\n+        // Source: <https://support.microsoft.com/en-us/help/286470/how-to-use-pageheap-exe-in-windows-xp-windows-2000-and-windows-server>\n+        // But jemalloc does not, so for the C heap we only align if the allocation is sufficiently big.\n+        if kind == MiriMemoryKind::WinHeap || size >= min_align {\n+            return Align::from_bytes(min_align).unwrap();\n+        }\n+        // We have `size < min_align`. Round `size` *down* to the next power of two and use that.\n+        fn prev_power_of_two(x: u64) -> u64 {\n+            let next_pow2 = x.next_power_of_two();\n+            if next_pow2 == x {\n+                // x *is* a power of two, just use that.\n+                x\n+            } else {\n+                // x is between two powers, so next = 2*prev.\n+                next_pow2 / 2\n+            }\n+        }\n+        Align::from_bytes(prev_power_of_two(size)).unwrap()\n     }\n \n     fn malloc(\n         &mut self,\n         size: u64,\n         zero_init: bool,\n+        kind: MiriMemoryKind,\n     ) -> Scalar<Tag> {\n         let this = self.eval_context_mut();\n         let tcx = &{this.tcx.tcx};\n         if size == 0 {\n             Scalar::from_int(0, this.pointer_size())\n         } else {\n-            let align = this.min_align();\n-            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n+            let align = this.min_align(size, kind);\n+            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, kind.into());\n             if zero_init {\n                 // We just allocated this, the access cannot fail\n                 this.memory_mut()\n@@ -47,14 +65,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn free(\n         &mut self,\n         ptr: Scalar<Tag>,\n+        kind: MiriMemoryKind,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if !this.is_null(ptr)? {\n             let ptr = this.force_ptr(ptr)?;\n             this.memory_mut().deallocate(\n                 ptr,\n                 None,\n-                MiriMemoryKind::C.into(),\n+                kind.into(),\n             )?;\n         }\n         Ok(())\n@@ -64,39 +83,38 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         old_ptr: Scalar<Tag>,\n         new_size: u64,\n+        kind: MiriMemoryKind,\n     ) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n-        let align = this.min_align();\n+        let new_align = this.min_align(new_size, kind);\n         if this.is_null(old_ptr)? {\n             if new_size == 0 {\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n                 let new_ptr = this.memory_mut().allocate(\n                     Size::from_bytes(new_size),\n-                    align,\n-                    MiriMemoryKind::C.into()\n+                    new_align,\n+                    kind.into()\n                 );\n                 Ok(Scalar::Ptr(new_ptr))\n             }\n         } else {\n             let old_ptr = this.force_ptr(old_ptr)?;\n             let memory = this.memory_mut();\n-            let old_size = Size::from_bytes(memory.get(old_ptr.alloc_id)?.bytes.len() as u64);\n             if new_size == 0 {\n                 memory.deallocate(\n                     old_ptr,\n-                    Some((old_size, align)),\n-                    MiriMemoryKind::C.into(),\n+                    None,\n+                    kind.into(),\n                 )?;\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n                 let new_ptr = memory.reallocate(\n                     old_ptr,\n-                    old_size,\n-                    align,\n+                    None,\n                     Size::from_bytes(new_size),\n-                    align,\n-                    MiriMemoryKind::C.into(),\n+                    new_align,\n+                    kind.into(),\n                 )?;\n                 Ok(Scalar::Ptr(new_ptr))\n             }\n@@ -145,14 +163,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             \"malloc\" => {\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                let res = this.malloc(size, /*zero_init:*/ false);\n+                let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n                 let items = this.read_scalar(args[0])?.to_usize(this)?;\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n                 let size = items.checked_mul(len).ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n-                let res = this.malloc(size, /*zero_init:*/ true);\n+                let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"posix_memalign\" => {\n@@ -187,12 +205,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"free\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                this.free(ptr)?;\n+                this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n                 let old_ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let new_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let res = this.realloc(old_ptr, new_size)?;\n+                let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n                 this.write_scalar(res, dest)?;\n             }\n \n@@ -262,12 +280,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n+                let align = Align::from_bytes(align).unwrap();\n                 let new_ptr = this.memory_mut().reallocate(\n                     ptr,\n-                    Size::from_bytes(old_size),\n-                    Align::from_bytes(align).unwrap(),\n+                    Some((Size::from_bytes(old_size), align)),\n                     Size::from_bytes(new_size),\n-                    Align::from_bytes(align).unwrap(),\n+                    align,\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n                 this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n@@ -327,7 +345,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n \n                 // Now we make a function call.\n-                // TODO: consider making this reusable? `InterpretCx::step` does something similar\n+                // TODO: consider making this reusable? `InterpCx::step` does something similar\n                 // for the TLS destructors, and of course `eval_main`.\n                 let mir = this.load_mir(f_instance.def)?;\n                 let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n@@ -765,22 +783,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let flags = this.read_scalar(args[1])?.to_u32()?;\n                 let size = this.read_scalar(args[2])?.to_usize(this)?;\n                 let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n-                let res = this.malloc(size, zero_init);\n+                let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap);\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n                 let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                this.free(ptr)?;\n+                this.free(ptr, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(Scalar::from_int(1, Size::from_bytes(4)), dest)?;\n             }\n             \"HeapReAlloc\" => {\n                 let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n                 let size = this.read_scalar(args[3])?.to_usize(this)?;\n-                let res = this.realloc(ptr, size)?;\n+                let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(res, dest)?;\n             }\n "}, {"sha": "bf51baacd35a9a9d7a548533eb343781968832c2", "filename": "tests/run-pass-noseed/malloc.rs", "status": "renamed", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad837079e1f18d00090d7ac1c58fda7b3c49a822/tests%2Frun-pass-noseed%2Fmalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad837079e1f18d00090d7ac1c58fda7b3c49a822/tests%2Frun-pass-noseed%2Fmalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fmalloc.rs?ref=ad837079e1f18d00090d7ac1c58fda7b3c49a822", "patch": "@@ -1,4 +1,5 @@\n //ignore-windows: Uses POSIX APIs\n+//compile-flags: -Zmiri-seed=\n \n #![feature(rustc_private)]\n \n@@ -7,6 +8,14 @@ use core::{slice, ptr};\n extern crate libc;\n \n fn main() {\n+    // Test that small allocations sometimes *are* not very aligned.\n+    let saw_unaligned = (0..64).any(|_| unsafe {\n+        let p = libc::malloc(3);\n+        libc::free(p);\n+        (p as usize) % 4 != 0 // find any that this is *not* 4-aligned\n+    });\n+    assert!(saw_unaligned);\n+\n     unsafe {\n         // Use calloc for initialized memory\n         let p1 = libc::calloc(20, 1);", "previous_filename": "tests/run-pass/realloc.rs"}]}