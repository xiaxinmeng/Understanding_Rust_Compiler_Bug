{"sha": "a9f047c048eac4f135dd6df5223b7195d651539d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZjA0N2MwNDhlYWM0ZjEzNWRkNmRmNTIyM2I3MTk1ZDY1MTUzOWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-19T07:05:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-19T07:05:05Z"}, "message": "Auto merge of #46664 - mikeyhew:raw_pointer_self, r=arielb1\n\narbitrary_self_types: add support for raw pointer `self` types\n\nThis adds support for raw pointer `self` types, under the `arbitrary_self_types` feature flag. Types like `self: *const Self`, `self: *const Rc<Self>`, `self: Rc<*const Self` are all supported. Object safety checks are updated to allow`self: *const Self` and `self: *mut Self`.\n\nThis PR does not add support for `*const self` and `*mut self` syntax. That can be added in a later PR once this code is reviewed and merged.\n\n#44874\n\nr? @arielb1", "tree": {"sha": "6aafdf5c1ae3526fa5cd6ff1e072b4dfe355a443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6aafdf5c1ae3526fa5cd6ff1e072b4dfe355a443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9f047c048eac4f135dd6df5223b7195d651539d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9f047c048eac4f135dd6df5223b7195d651539d", "html_url": "https://github.com/rust-lang/rust/commit/a9f047c048eac4f135dd6df5223b7195d651539d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9f047c048eac4f135dd6df5223b7195d651539d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8b94c6aa1bdee2fb6371e3f445f0abbba7c5093", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8b94c6aa1bdee2fb6371e3f445f0abbba7c5093", "html_url": "https://github.com/rust-lang/rust/commit/c8b94c6aa1bdee2fb6371e3f445f0abbba7c5093"}, {"sha": "5c656f0c72d4a1aeff9a761fe455e522e975eee2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c656f0c72d4a1aeff9a761fe455e522e975eee2", "html_url": "https://github.com/rust-lang/rust/commit/5c656f0c72d4a1aeff9a761fe455e522e975eee2"}], "stats": {"total": 306, "additions": 273, "deletions": 33}, "files": [{"sha": "4151661b5933c30e03c279ebe66493dbbbd0df77", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -59,9 +59,7 @@ impl ObjectSafetyViolation {\n             ObjectSafetyViolation::Method(name, MethodViolationCode::Generic) =>\n                 format!(\"method `{}` has generic type parameters\", name).into(),\n             ObjectSafetyViolation::Method(name, MethodViolationCode::NonStandardSelfType) =>\n-                format!(\"method `{}` has a non-standard `self` type. Only `&self`, \\\n-                        `&mut self`, and `Box<Self>` are currently supported \\\n-                        for trait objects\", name).into(),\n+                format!(\"method `{}` has a non-standard `self` type\", name).into(),\n             ObjectSafetyViolation::AssociatedConst(name) =>\n                 format!(\"the trait cannot contain associated consts like `{}`\", name).into(),\n         }"}, {"sha": "46bc54b7f6a670aca91035d8457d667d84bc2d67", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -1191,6 +1191,7 @@ fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n     ByReference(ty::Region<'tcx>, hir::Mutability),\n+    ByRawPointer(hir::Mutability),\n     ByBox,\n     Other\n }\n@@ -1231,10 +1232,15 @@ impl<'tcx> ExplicitSelf<'tcx> {\n \n         match self_arg_ty.sty {\n             _ if is_self_ty(self_arg_ty) => ByValue,\n-            ty::TyRef(region, ty::TypeAndMut { ty, mutbl}) if is_self_ty(ty) => {\n+            ty::TyRef(region, ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n                 ByReference(region, mutbl)\n             }\n-            ty::TyAdt(def, _) if def.is_box() && is_self_ty(self_arg_ty.boxed_ty()) => ByBox,\n+            ty::TyRawPtr(ty::TypeAndMut { ty, mutbl }) if is_self_ty(ty) => {\n+                ByRawPointer(mutbl)\n+            }\n+            ty::TyAdt(def, _) if def.is_box() && is_self_ty(self_arg_ty.boxed_ty()) => {\n+                ByBox\n+            }\n             _ => Other\n         }\n     }"}, {"sha": "7832db7dcb5423b77ea7e3fb1d617dd4524dcc2c", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -37,6 +37,7 @@ pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     cur_ty: Ty<'tcx>,\n     obligations: Vec<traits::PredicateObligation<'tcx>>,\n     at_start: bool,\n+    include_raw_pointers: bool,\n     span: Span,\n }\n \n@@ -76,12 +77,13 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n         }\n \n         // Otherwise, deref if type is derefable:\n-        let (kind, new_ty) = if let Some(mt) = self.cur_ty.builtin_deref(false, NoPreference) {\n-            (AutoderefKind::Builtin, mt.ty)\n-        } else {\n-            let ty = self.overloaded_deref_ty(self.cur_ty)?;\n-            (AutoderefKind::Overloaded, ty)\n-        };\n+        let (kind, new_ty) =\n+            if let Some(mt) = self.cur_ty.builtin_deref(self.include_raw_pointers, NoPreference) {\n+                (AutoderefKind::Builtin, mt.ty)\n+            } else {\n+                let ty = self.overloaded_deref_ty(self.cur_ty)?;\n+                (AutoderefKind::Overloaded, ty)\n+            };\n \n         if new_ty.references_error() {\n             return None;\n@@ -194,6 +196,15 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// also dereference through raw pointer types\n+    /// e.g. assuming ptr_to_Foo is the type `*const Foo`\n+    /// fcx.autoderef(span, ptr_to_Foo)  => [*const Foo]\n+    /// fcx.autoderef(span, ptr_to_Foo).include_raw_ptrs() => [*const Foo, Foo]\n+    pub fn include_raw_pointers(mut self) -> Self {\n+        self.include_raw_pointers = true;\n+        self\n+    }\n+\n     pub fn finalize(self) {\n         let fcx = self.fcx;\n         fcx.register_predicates(self.into_obligations());\n@@ -212,6 +223,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             cur_ty: self.resolve_type_vars_if_possible(&base_ty),\n             obligations: vec![],\n             at_start: true,\n+            include_raw_pointers: false,\n             span,\n         }\n     }"}, {"sha": "3a9c4e1901d277e6b9ba342229698ed58069e596", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -276,6 +276,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // FIXME: this feels, like, super dubious\n         self.fcx\n             .autoderef(self.span, self_ty)\n+            .include_raw_pointers()\n             .filter_map(|(ty, _)| {\n                 match ty.sty {\n                     ty::TyDynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),"}, {"sha": "fe30ffb3cfccde1788650231515fdf788f9b2582", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -77,6 +77,12 @@ impl<'a, 'gcx, 'tcx> Deref for ProbeContext<'a, 'gcx, 'tcx> {\n struct CandidateStep<'tcx> {\n     self_ty: Ty<'tcx>,\n     autoderefs: usize,\n+    // true if the type results from a dereference of a raw pointer.\n+    // when assembling candidates, we include these steps, but not when\n+    // picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n+    // `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n+    // `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n+    from_unsafe_deref: bool,\n     unsize: bool,\n }\n \n@@ -257,6 +263,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             vec![CandidateStep {\n                      self_ty,\n                      autoderefs: 0,\n+                     from_unsafe_deref: false,\n                      unsize: false,\n                  }]\n         };\n@@ -289,14 +296,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     -> Option<Vec<CandidateStep<'tcx>>> {\n         // FIXME: we don't need to create the entire steps in one pass\n \n-        let mut autoderef = self.autoderef(span, self_ty);\n+        let mut autoderef = self.autoderef(span, self_ty).include_raw_pointers();\n+        let mut reached_raw_pointer = false;\n         let mut steps: Vec<_> = autoderef.by_ref()\n             .map(|(ty, d)| {\n-                CandidateStep {\n+                let step = CandidateStep {\n                     self_ty: ty,\n                     autoderefs: d,\n+                    from_unsafe_deref: reached_raw_pointer,\n                     unsize: false,\n+                };\n+                if let ty::TyRawPtr(_) = ty.sty {\n+                    // all the subsequent steps will be from_unsafe_deref\n+                    reached_raw_pointer = true;\n                 }\n+                step\n             })\n             .collect();\n \n@@ -307,9 +321,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // a real method lookup, this is a hard error (it's an\n                 // ambiguity and we can't make progress).\n                 if !is_suggestion.0 {\n-                    let t = self.structurally_resolved_type(span, final_ty);\n-                    assert_eq!(t, self.tcx.types.err);\n-                    return None\n+                    if reached_raw_pointer\n+                    && !self.tcx.sess.features.borrow().arbitrary_self_types {\n+                        // only produce a warning in this case, because inference variables used to\n+                        // be allowed here in some cases for raw pointers\n+                        struct_span_warn!(self.tcx.sess, span, E0619,\n+                            \"the type of this value must be known in this context\")\n+                        .note(\"this will be made into a hard error in a future version of \\\n+                               the compiler\")\n+                        .emit();\n+                    } else {\n+                        let t = self.structurally_resolved_type(span, final_ty);\n+                        assert_eq!(t, self.tcx.types.err);\n+                        return None\n+                    }\n                 } else {\n                     // If we're just looking for suggestions,\n                     // though, ambiguity is no big thing, we can\n@@ -322,6 +347,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 steps.push(CandidateStep {\n                     self_ty: self.tcx.mk_slice(elem_ty),\n                     autoderefs: dereferences,\n+                    // this could be from an unsafe deref if we had\n+                    // a *mut/const [T; N]\n+                    from_unsafe_deref: reached_raw_pointer,\n                     unsize: true,\n                 });\n             }\n@@ -830,7 +858,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             .iter()\n             .filter(|step| {\n                 debug!(\"pick_core: step={:?}\", step);\n-                !step.self_ty.references_error()\n+                // skip types that are from a type error or that would require dereferencing\n+                // a raw pointer\n+                !step.self_ty.references_error() && !step.from_unsafe_deref\n             }).flat_map(|step| {\n                 self.pick_by_value_method(step).or_else(|| {\n                 self.pick_autorefd_method(step, hir::MutImmutable).or_else(|| {"}, {"sha": "e65ae6a1b4db3a215f6193a1671c7bb148e8eac1", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -503,7 +503,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             &ty::Binder(self_arg_ty)\n         );\n \n-        let mut autoderef = fcx.autoderef(span, self_arg_ty);\n+        let mut autoderef = fcx.autoderef(span, self_arg_ty).include_raw_pointers();\n \n         loop {\n             if let Some((potential_self_ty, _)) = autoderef.next() {\n@@ -532,12 +532,32 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         let is_self_ty = |ty| fcx.infcx.can_eq(fcx.param_env, self_ty, ty).is_ok();\n         let self_kind = ExplicitSelf::determine(self_arg_ty, is_self_ty);\n \n-        if let ExplicitSelf::Other = self_kind {\n-            if !fcx.tcx.sess.features.borrow().arbitrary_self_types {\n-                feature_gate::feature_err(&fcx.tcx.sess.parse_sess, \"arbitrary_self_types\", span,\n-                    GateIssue::Language, \"arbitrary `self` types are unstable\")\n-                .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n-                .emit();\n+        if !fcx.tcx.sess.features.borrow().arbitrary_self_types {\n+            match self_kind {\n+                ExplicitSelf::ByValue |\n+                ExplicitSelf::ByReference(_, _) |\n+                ExplicitSelf::ByBox => (),\n+\n+                ExplicitSelf::ByRawPointer(_) => {\n+                    feature_gate::feature_err(\n+                        &fcx.tcx.sess.parse_sess,\n+                        \"arbitrary_self_types\",\n+                        span,\n+                        GateIssue::Language,\n+                        \"raw pointer `self` is unstable\")\n+                    .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                    .emit();\n+                }\n+\n+                ExplicitSelf::Other => {\n+                    feature_gate::feature_err(\n+                        &fcx.tcx.sess.parse_sess,\n+                        \"arbitrary_self_types\",\n+                        span,\n+                        GateIssue::Language,\"arbitrary `self` types are unstable\")\n+                    .help(\"consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\")\n+                    .emit();\n+                }\n             }\n         }\n     }"}, {"sha": "8b6941e1c635cac5aafaaa50d7fdc08fb9c710df", "filename": "src/test/run-pass/arbitrary_self_types_raw_pointer_struct.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_struct.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(arbitrary_self_types)]\n+\n+use std::rc::Rc;\n+\n+struct Foo(String);\n+\n+impl Foo {\n+    unsafe fn foo(self: *const Self) -> *const str {\n+        (*self).0.as_ref()\n+    }\n+\n+    fn complicated_1(self: *const Rc<Self>) -> &'static str {\n+        \"Foo::complicated_1\"\n+    }\n+\n+    unsafe fn complicated_2(self: Rc<*const Self>) -> *const str {\n+        (**self).0.as_ref()\n+    }\n+}\n+\n+fn main() {\n+    let foo = Foo(\"abc123\".into());\n+    assert_eq!(\"abc123\", unsafe { &*(&foo as *const Foo).foo() });\n+    assert_eq!(\"Foo::complicated_1\", std::ptr::null::<Rc<Foo>>().complicated_1());\n+    let rc = Rc::new(&foo as *const Foo);\n+    assert_eq!(\"abc123\", unsafe { &*rc.complicated_2()});\n+}"}, {"sha": "f70e38a14e4166174810f25d6087cb7503f7da3e", "filename": "src/test/run-pass/arbitrary_self_types_raw_pointer_trait.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_raw_pointer_trait.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(arbitrary_self_types)]\n+\n+use std::ptr;\n+\n+trait Foo {\n+    fn foo(self: *const Self) -> &'static str;\n+\n+    unsafe fn bar(self: *const Self) -> i64;\n+\n+    unsafe fn complicated(self: *const *const Self) -> i64 where Self: Sized {\n+        (*self).bar()\n+    }\n+}\n+\n+impl Foo for i32 {\n+    fn foo(self: *const Self) -> &'static str {\n+        \"I'm an i32!\"\n+    }\n+\n+    unsafe fn bar(self: *const Self) -> i64 {\n+        *self as i64\n+    }\n+}\n+\n+impl Foo for u32 {\n+    fn foo(self: *const Self) -> &'static str {\n+        \"I'm a u32!\"\n+    }\n+\n+    unsafe fn bar(self: *const Self) -> i64 {\n+        *self as i64\n+    }\n+}\n+\n+fn main() {\n+    let null_i32 = ptr::null::<i32>() as *const Foo;\n+    let null_u32 = ptr::null::<u32>() as *const Foo;\n+\n+    assert_eq!(\"I'm an i32!\", null_i32.foo());\n+    assert_eq!(\"I'm a u32!\", null_u32.foo());\n+\n+    let valid_i32 = 5i32;\n+    let valid_i32_thin = &valid_i32 as *const i32;\n+    assert_eq!(\"I'm an i32!\", valid_i32_thin.foo());\n+    assert_eq!(5, unsafe { valid_i32_thin.bar() });\n+    assert_eq!(5, unsafe { (&valid_i32_thin as *const *const i32).complicated() });\n+    let valid_i32_fat = valid_i32_thin as *const Foo;\n+    assert_eq!(\"I'm an i32!\", valid_i32_fat.foo());\n+    assert_eq!(5, unsafe { valid_i32_fat.bar() });\n+\n+    let valid_u32 = 18u32;\n+    let valid_u32_thin = &valid_u32 as *const u32;\n+    assert_eq!(\"I'm a u32!\", valid_u32_thin.foo());\n+    assert_eq!(18, unsafe { valid_u32_thin.bar() });\n+    assert_eq!(18, unsafe { (&valid_u32_thin as *const *const u32).complicated() });\n+    let valid_u32_fat = valid_u32_thin as *const Foo;\n+    assert_eq!(\"I'm a u32!\", valid_u32_fat.foo());\n+    assert_eq!(18, unsafe { valid_u32_fat.bar() });\n+\n+}"}, {"sha": "f258488ee2fb1d4921eb0b29efa277f4e97b711a", "filename": "src/test/ui/arbitrary-self-types-not-object-safe.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Farbitrary-self-types-not-object-safe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Farbitrary-self-types-not-object-safe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farbitrary-self-types-not-object-safe.stderr?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -4,15 +4,15 @@ error[E0038]: the trait `Foo` cannot be made into an object\n 40 |     let x = Box::new(5usize) as Box<Foo>;\n    |                                 ^^^^^^^^ the trait `Foo` cannot be made into an object\n    |\n-   = note: method `foo` has a non-standard `self` type. Only `&self`, `&mut self`, and `Box<Self>` are currently supported for trait objects\n+   = note: method `foo` has a non-standard `self` type\n \n error[E0038]: the trait `Foo` cannot be made into an object\n   --> $DIR/arbitrary-self-types-not-object-safe.rs:40:13\n    |\n 40 |     let x = Box::new(5usize) as Box<Foo>;\n    |             ^^^^^^^^^^^^^^^^ the trait `Foo` cannot be made into an object\n    |\n-   = note: method `foo` has a non-standard `self` type. Only `&self`, `&mut self`, and `Box<Self>` are currently supported for trait objects\n+   = note: method `foo` has a non-standard `self` type\n    = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<Foo>>` for `std::boxed::Box<usize>`\n \n error: aborting due to 2 previous errors"}, {"sha": "29e51727edcfd8c3f576d8cfd9892f681794cc69", "filename": "src/test/ui/feature-gate-arbitrary_self_types-raw-pointer.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Ffeature-gate-arbitrary_self_types-raw-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Ffeature-gate-arbitrary_self_types-raw-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-arbitrary_self_types-raw-pointer.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(self: *const Self) {}\n+    //~^ ERROR raw pointer `self` is unstable\n+}\n+\n+trait Bar {\n+    fn bar(self: *const Self);\n+    //~^ ERROR raw pointer `self` is unstable\n+}\n+\n+impl Bar for () {\n+    fn bar(self: *const Self) {}\n+    //~^ ERROR raw pointer `self` is unstable\n+}\n+\n+fn main() {}"}, {"sha": "d629ac4c60fc08a0ba6354df40ba2582d4f38c7a", "filename": "src/test/ui/feature-gate-arbitrary_self_types-raw-pointer.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Ffeature-gate-arbitrary_self_types-raw-pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Ffeature-gate-arbitrary_self_types-raw-pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-arbitrary_self_types-raw-pointer.stderr?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -0,0 +1,29 @@\n+error: raw pointer `self` is unstable (see issue #44874)\n+  --> $DIR/feature-gate-arbitrary_self_types-raw-pointer.rs:19:18\n+   |\n+19 |     fn bar(self: *const Self);\n+   |                  ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(arbitrary_self_types)] to the crate attributes to enable\n+   = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n+\n+error: raw pointer `self` is unstable (see issue #44874)\n+  --> $DIR/feature-gate-arbitrary_self_types-raw-pointer.rs:14:18\n+   |\n+14 |     fn foo(self: *const Self) {}\n+   |                  ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(arbitrary_self_types)] to the crate attributes to enable\n+   = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n+\n+error: raw pointer `self` is unstable (see issue #44874)\n+  --> $DIR/feature-gate-arbitrary_self_types-raw-pointer.rs:24:18\n+   |\n+24 |     fn bar(self: *const Self) {}\n+   |                  ^^^^^^^^^^^\n+   |\n+   = help: add #![feature(arbitrary_self_types)] to the crate attributes to enable\n+   = help: consider changing to `self`, `&self`, `&mut self`, or `self: Box<Self>`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "0ae027679fe310d61d76fcfb5b90bc132e35a9e9", "filename": "src/test/ui/inference-variable-behind-raw-pointer.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Finference-variable-behind-raw-pointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Finference-variable-behind-raw-pointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference-variable-behind-raw-pointer.rs?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S(String);\n+// must-compile-successfully\n \n-impl S {\n-    fn f(self: *mut S) -> String { self.0 }\n-    //~^ ERROR invalid `self` type\n-}\n+// tests that the following code compiles, but produces a future-compatibility warning\n \n-fn main() { S(\"\".to_owned()).f(); }\n+fn main() {\n+    let data = std::ptr::null();\n+    let _ = &data as *const *const ();\n+    if data.is_null() {}\n+}", "previous_filename": "src/test/compile-fail/issue-26194.rs"}, {"sha": "a8874c9bf5a39e89a1f82a023c1b518e52616db3", "filename": "src/test/ui/inference-variable-behind-raw-pointer.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Finference-variable-behind-raw-pointer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a9f047c048eac4f135dd6df5223b7195d651539d/src%2Ftest%2Fui%2Finference-variable-behind-raw-pointer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference-variable-behind-raw-pointer.stderr?ref=a9f047c048eac4f135dd6df5223b7195d651539d", "patch": "@@ -0,0 +1,8 @@\n+warning[E0619]: the type of this value must be known in this context\n+  --> $DIR/inference-variable-behind-raw-pointer.rs:18:13\n+   |\n+18 |     if data.is_null() {}\n+   |             ^^^^^^^\n+   |\n+   = note: this will be made into a hard error in a future version of the compiler\n+"}]}