{"sha": "26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2ZTY5MmRkMzk4ZGExNjA4YzZkOGZjMmM2ZjlhYzM0YjdlYTdhM2E=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-21T21:16:31Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-21T21:54:48Z"}, "message": "Fix spurious non-exhaustive errors for cross-crate struct variants", "tree": {"sha": "70ace0d01f8073174904249085cd16f400e8e34a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70ace0d01f8073174904249085cd16f400e8e34a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a", "html_url": "https://github.com/rust-lang/rust/commit/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a/comments", "author": null, "committer": null, "parents": [{"sha": "f556c8cbd8af182a9dd871a4a36692a0dba7cc2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f556c8cbd8af182a9dd871a4a36692a0dba7cc2e", "html_url": "https://github.com/rust-lang/rust/commit/f556c8cbd8af182a9dd871a4a36692a0dba7cc2e"}], "stats": {"total": 55, "additions": 40, "deletions": 15}, "files": [{"sha": "b550cb2bb68e42cceb1f63fbef149a29f5f8a3ab", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a", "patch": "@@ -194,7 +194,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, m: &Matrix) {\n #[deriving(Clone, PartialEq)]\n enum ctor {\n     single,\n-    variant(DefId /* variant */, bool /* is_structure */),\n+    variant(DefId),\n     val(const_val),\n     range(const_val, const_val),\n     vec(uint)\n@@ -218,7 +218,8 @@ fn construct_witness(cx: &MatchCheckCtxt, ctor: &ctor, pats: Vec<Gc<Pat>>, lty:\n \n         ty::ty_enum(cid, _) | ty::ty_struct(cid, _)  => {\n             let (vid, is_structure) = match ctor {\n-                &variant(vid, is_structure) => (vid, is_structure),\n+                &variant(vid) => (vid,\n+                    ty::enum_variant_with_id(cx.tcx, cid, vid).arg_names.is_some()),\n                 _ => (cid, true)\n             };\n             if is_structure {\n@@ -310,7 +311,7 @@ fn all_constructors(cx: &MatchCheckCtxt, m: &Matrix, left_ty: ty::t) -> Vec<ctor\n         ty::ty_enum(eid, _) =>\n             ty::enum_variants(cx.tcx, eid)\n                 .iter()\n-                .map(|va| variant(va.id, va.arg_names.is_some()))\n+                .map(|va| variant(va.id))\n                 .collect(),\n \n         ty::ty_vec(_, None) =>\n@@ -434,7 +435,7 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, left_ty: ty::t, p: Gc<Pat>) -> Option<ctor>\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                     Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n                 },\n-                Some(&DefVariant(_, id, is_structure)) => Some(variant(id, is_structure)),\n+                Some(&DefVariant(_, id, _)) => Some(variant(id)),\n                 _ => None\n             },\n         PatEnum(..) =>\n@@ -443,12 +444,12 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, left_ty: ty::t, p: Gc<Pat>) -> Option<ctor>\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n                     Some(val(eval_const_expr(cx.tcx, &*const_expr)))\n                 },\n-                Some(&DefVariant(_, id, is_structure)) => Some(variant(id, is_structure)),\n+                Some(&DefVariant(_, id, _)) => Some(variant(id)),\n                 _ => Some(single)\n             },\n         PatStruct(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n-                Some(&DefVariant(_, id, is_structure)) => Some(variant(id, is_structure)),\n+                Some(&DefVariant(_, id, _)) => Some(variant(id)),\n                 _ => Some(single)\n             },\n         PatLit(expr) =>\n@@ -498,7 +499,7 @@ fn constructor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n         },\n         ty::ty_enum(eid, _) => {\n             match *ctor {\n-                variant(id, _) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n+                variant(id) => enum_variant_with_id(cx.tcx, eid, id).args.len(),\n                 _ => unreachable!()\n             }\n         }\n@@ -545,9 +546,10 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n         &PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().find_copy(pat_id);\n             match opt_def {\n-                Some(DefVariant(_, id, _)) => match *ctor_id {\n-                    variant(vid, _) if vid == id => Some(vec!()),\n-                    _ => None\n+                Some(DefVariant(_, id, _)) => if *ctor_id == variant(id) {\n+                    Some(vec!())\n+                } else {\n+                    None\n                 },\n                 Some(DefStatic(did, _)) => {\n                     let const_expr = lookup_const_by_id(cx.tcx, did).unwrap();\n@@ -581,7 +583,7 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n                         }\n                     }\n                 }\n-                DefVariant(_, id, _) if variant(id, false) != *ctor_id => None,\n+                DefVariant(_, id, _) if *ctor_id != variant(id) => None,\n                 DefVariant(..) | DefFn(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.clone(),\n@@ -596,7 +598,7 @@ fn specialize(cx: &MatchCheckCtxt, r: &[Gc<Pat>],\n             // Is this a struct or an enum variant?\n             let def = cx.tcx.def_map.borrow().get_copy(pat_id);\n             let class_id = match def {\n-                DefVariant(_, variant_id, _) => if *ctor_id == variant(variant_id, true) {\n+                DefVariant(_, variant_id, _) => if *ctor_id == variant(variant_id) {\n                     Some(variant_id)\n                 } else {\n                     None"}, {"sha": "88b6b36322228b108a1ce13f4f597b738fe800e4", "filename": "src/test/auxiliary/struct_variant_xc_aux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstruct_variant_xc_aux.rs?ref=26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a", "patch": "@@ -14,5 +14,6 @@\n #![feature(struct_variant)]\n \n pub enum Enum {\n-    Variant { pub arg: u8 }\n+    Variant(u8),\n+    StructVariant { pub arg: u8 }\n }"}, {"sha": "11521e86117b489a231cca6e3ffb86781ef24489", "filename": "src/test/run-pass/struct_variant_xc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a/src%2Ftest%2Frun-pass%2Fstruct_variant_xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a/src%2Ftest%2Frun-pass%2Fstruct_variant_xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct_variant_xc.rs?ref=26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a", "patch": "@@ -11,8 +11,8 @@\n // aux-build:struct_variant_xc_aux.rs\n extern crate struct_variant_xc_aux;\n \n-use struct_variant_xc_aux::Variant;\n+use struct_variant_xc_aux::StructVariant;\n \n pub fn main() {\n-    let _ = Variant { arg: 1 };\n+    let _ = StructVariant { arg: 1 };\n }"}, {"sha": "8cb1cdd2a7ff379d27183cf23e89ec6b685a6292", "filename": "src/test/run-pass/struct_variant_xc_match.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a/src%2Ftest%2Frun-pass%2Fstruct_variant_xc_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a/src%2Ftest%2Frun-pass%2Fstruct_variant_xc_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct_variant_xc_match.rs?ref=26e692dd398da1608c6d8fc2c6f9ac34b7ea7a3a", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:struct_variant_xc_aux.rs\n+extern crate struct_variant_xc_aux;\n+\n+use struct_variant_xc_aux::{StructVariant, Variant};\n+\n+pub fn main() {\n+    let arg = match StructVariant { arg: 42 } {\n+        Variant(_) => unreachable!(),\n+        StructVariant { arg } => arg\n+    };\n+    assert_eq!(arg, 42);\n+}"}]}