{"sha": "e015bee2866a802f17c84bd6d3a06212945a9d17", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMTViZWUyODY2YTgwMmYxN2M4NGJkNmQzYTA2MjEyOTQ1YTlkMTc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-06-18T16:39:16Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-06-28T14:44:16Z"}, "message": "Rewrite each_path to allow performance improvements in the future.\n\nInstead of determining paths from the path tag, we iterate through\nmodules' children recursively in the metadata. This will allow for\nlazy external module resolution.", "tree": {"sha": "676f45de5bbcc9420fb0417719b262953c8d808c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/676f45de5bbcc9420fb0417719b262953c8d808c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e015bee2866a802f17c84bd6d3a06212945a9d17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e015bee2866a802f17c84bd6d3a06212945a9d17", "html_url": "https://github.com/rust-lang/rust/commit/e015bee2866a802f17c84bd6d3a06212945a9d17", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e015bee2866a802f17c84bd6d3a06212945a9d17/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89eb9951958dc2cd652645cea5badf4bb9edc6f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/89eb9951958dc2cd652645cea5badf4bb9edc6f9", "html_url": "https://github.com/rust-lang/rust/commit/89eb9951958dc2cd652645cea5badf4bb9edc6f9"}], "stats": {"total": 934, "additions": 574, "deletions": 360}, "files": [{"sha": "3908b61381b78bb18f3980e211b78991f371510d", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -381,7 +381,7 @@ impl Sem<~[Waitqueue]> {\n     // The only other places that condvars get built are rwlock.write_cond()\n     // and rwlock_write_mode.\n     pub fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n-        do self.access {\n+        do self.access_waitqueue {\n             blk(&Condvar { sem: self, order: Nothing })\n         }\n     }"}, {"sha": "e7725436f2b4ff826808cf9706fa0b3d11fd6489", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -176,6 +176,10 @@ pub static tag_item_method_tps: uint = 0x7b;\n pub static tag_item_method_fty: uint = 0x7c;\n pub static tag_item_method_transformed_self_ty: uint = 0x7d;\n \n+pub static tag_mod_child: uint = 0x7e;\n+pub static tag_misc_info: uint = 0x7f;\n+pub static tag_misc_info_crate_items: uint = 0x80;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "4ede9f96f1f401421c466ab4950e8617bf051e03", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -97,18 +97,14 @@ pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_impls_for_mod(cstore: @mut cstore::CStore, def: ast::def_id,\n-                         name: Option<ast::ident>)\n-                      -> @~[@resolve::Impl] {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    do decoder::get_impls_for_mod(cstore.intr, cdata, def.node, name) |cnum| {\n-        cstore::get_crate_data(cstore, cnum)\n-    }\n+/// Returns information about the given implementation.\n+pub fn get_impl(cstore: @mut cstore::CStore, impl_def_id: ast::def_id)\n+                -> resolve::Impl {\n+    let cdata = cstore::get_crate_data(cstore, impl_def_id.crate);\n+    decoder::get_impl(cstore.intr, cdata, impl_def_id.node)\n }\n \n-pub fn get_method(tcx: ty::ctxt,\n-                  def: ast::def_id) -> ty::Method\n-{\n+pub fn get_method(tcx: ty::ctxt, def: ast::def_id) -> ty::Method {\n     let cdata = cstore::get_crate_data(tcx.cstore, def.crate);\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }"}, {"sha": "2ebaa2b739fcedcdc2d2b219bf580b609ae7396b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 230, "deletions": 93, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -458,94 +458,246 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) -> bool {\n     return true;\n }\n \n-/// Iterates over all the paths in the given crate.\n-pub fn each_path(intr: @ident_interner,\n-                 cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like, ast::visibility) -> bool)\n-                 -> bool {\n-    // FIXME #4572: This function needs to be nuked, as it's impossible to make fast.\n-    // It's the source of most of the performance problems when compiling small crates.\n+struct EachItemContext<'self> {\n+    intr: @ident_interner,\n+    cdata: cmd,\n+    get_crate_data: GetCrateDataCb<'self>,\n+    path_builder: &'self mut ~str,\n+    callback: &'self fn(&str, def_like, ast::visibility) -> bool,\n+}\n \n-    let root = reader::Doc(cdata.data);\n-    let items = reader::get_doc(root, tag_items);\n-    let items_data = reader::get_doc(items, tag_items_data);\n-\n-    // First, go through all the explicit items.\n-    for reader::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n-        let path = ast_map::path_to_str(item_path(item_doc), intr);\n-        let path_is_empty = path.is_empty();\n-        if !path_is_empty {\n-            // Extract the def ID.\n-            let def_id = item_def_id(item_doc, cdata);\n-\n-            // Construct the def for this item.\n-            debug!(\"(each_path) yielding explicit item: %s\", path);\n-            let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n-\n-            let vis = item_visibility(item_doc);\n-\n-            // Hand the information off to the iteratee.\n-            if !f(path, def_like, vis) {\n-                return false;\n+impl<'self> EachItemContext<'self> {\n+    // Pushes the given name and returns the old length.\n+    fn push_name(&mut self, string: &str) -> uint {\n+        let path_len = self.path_builder.len();\n+        if path_len != 0 {\n+            self.path_builder.push_str(\"::\")\n+        }\n+        self.path_builder.push_str(string);\n+        path_len\n+    }\n+\n+    // Pops the given name.\n+    fn pop_name(&mut self, old_len: uint) {\n+        // XXX(pcwalton): There's no safe function to do this. :(\n+        unsafe {\n+            str::raw::set_len(self.path_builder, old_len)\n+        }\n+    }\n+\n+    fn process_item_and_pop_name(&mut self,\n+                                 doc: ebml::Doc,\n+                                 def_id: ast::def_id,\n+                                 old_len: uint)\n+                                 -> bool {\n+        let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n+        match def_like {\n+            dl_def(def) => {\n+                debug!(\"(iterating over each item of a module) processing \\\n+                        `%s` (def %?)\",\n+                       *self.path_builder,\n+                       def);\n+            }\n+            _ => {\n+                debug!(\"(iterating over each item of a module) processing \\\n+                        `%s` (%d:%d)\",\n+                       *self.path_builder,\n+                       def_id.crate,\n+                       def_id.node);\n             }\n         }\n \n-        // If this is a module, find the reexports.\n-        for each_reexport(item_doc) |reexport_doc| {\n-            let def_id_doc =\n-                reader::get_doc(reexport_doc,\n-                                tag_items_data_item_reexport_def_id);\n-            let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n-            let def_id = translate_def_id(cdata, def_id);\n-\n-            let reexport_name_doc =\n-                reader::get_doc(reexport_doc,\n-                                tag_items_data_item_reexport_name);\n-            let reexport_name = reexport_name_doc.as_str_slice();\n-\n-            let reexport_path;\n-            if path_is_empty {\n-                reexport_path = reexport_name.to_owned();\n+        let vis = item_visibility(doc);\n+\n+        let mut continue = (self.callback)(*self.path_builder, def_like, vis);\n+\n+        let family = item_family(doc);\n+        if family == ForeignMod {\n+            // These are unnamed; pop the name now.\n+            self.pop_name(old_len)\n+        }\n+\n+        if continue {\n+            // Recurse if necessary.\n+            match family {\n+                Mod | ForeignMod | Trait | Impl => {\n+                    continue = self.each_item_of_module(def_id);\n+                }\n+                Freeze | Struct | UnsafeFn | Fn | PureFn | ForeignFn |\n+                UnsafeStaticMethod | StaticMethod | PureStaticMethod | Type |\n+                ForeignType | Variant | Enum | PublicField | PrivateField |\n+                InheritedField => {}\n+            }\n+        }\n+\n+        if family != ForeignMod {\n+            self.pop_name(old_len)\n+        }\n+\n+        continue\n+    }\n+\n+    fn each_item_of_module(&mut self, def_id: ast::def_id) -> bool {\n+        // This item might not be in this crate. If it's not, look it up.\n+        let (cdata, items) = if def_id.crate == self.cdata.cnum {\n+            let items = reader::get_doc(reader::Doc(self.cdata.data),\n+                                        tag_items);\n+            (self.cdata, items)\n+        } else {\n+            let crate_data = (self.get_crate_data)(def_id.crate);\n+            let root = reader::Doc(crate_data.data);\n+            (crate_data, reader::get_doc(root, tag_items))\n+        };\n+\n+        // Look up the item.\n+        let item_doc = match maybe_find_item(def_id.node, items) {\n+            None => return false,\n+            Some(item_doc) => item_doc,\n+        };\n+\n+        self.each_child_of_module_or_crate(item_doc)\n+    }\n+\n+    fn each_child_of_module_or_crate(&mut self, item_doc: ebml::Doc) -> bool {\n+        let mut continue = true;\n+\n+        // Iterate over all children.\n+        for reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+            let child_def_id = reader::with_doc_data(child_info_doc,\n+                                                     parse_def_id);\n+            let child_def_id = translate_def_id(self.cdata, child_def_id);\n+\n+            // This item may be in yet another crate, if it was the child of\n+            // a reexport.\n+            let other_crates_items = if child_def_id.crate ==\n+                    self.cdata.cnum {\n+                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n             } else {\n-                reexport_path = path + \"::\" + reexport_name;\n+                let crate_data = (self.get_crate_data)(child_def_id.crate);\n+                let root = reader::Doc(crate_data.data);\n+                reader::get_doc(root, tag_items)\n+            };\n+\n+            debug!(\"(iterating over each item of a module) looking up item \\\n+                    %d:%d in `%s`, crate %d\",\n+                   child_def_id.crate,\n+                   child_def_id.node,\n+                   *self.path_builder,\n+                   self.cdata.cnum);\n+\n+            // Get the item.\n+            match maybe_find_item(child_def_id.node, other_crates_items) {\n+                None => {}\n+                Some(child_item_doc) => {\n+                    // Push the name.\n+                    let child_name = item_name(self.intr, child_item_doc);\n+                    debug!(\"(iterating over each item of a module) pushing \\\n+                            name `%s` onto `%s`\",\n+                           token::ident_to_str(&child_name),\n+                           *self.path_builder);\n+                    let old_len =\n+                        self.push_name(token::ident_to_str(&child_name));\n+\n+                    // Process this item.\n+                    continue = self.process_item_and_pop_name(child_item_doc,\n+                                                              child_def_id,\n+                                                              old_len);\n+\n+                    if !continue {\n+                        break\n+                    }\n+                }\n             }\n+        }\n+\n+        if !continue {\n+            return false\n+        }\n \n-            // This reexport may be in yet another crate\n-            let other_crates_items = if def_id.crate == cdata.cnum {\n-                items\n+        // Iterate over reexports.\n+        for each_reexport(item_doc) |reexport_doc| {\n+            let def_id_doc = reader::get_doc(\n+                reexport_doc,\n+                tag_items_data_item_reexport_def_id);\n+            let orig_def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n+\n+            // NB: was \"cdata\"\n+            let def_id = translate_def_id(self.cdata, orig_def_id);\n+\n+            let name_doc = reader::get_doc(reexport_doc,\n+                                           tag_items_data_item_reexport_name);\n+            let name = name_doc.as_str_slice();\n+\n+            // Push the name.\n+            debug!(\"(iterating over each item of a module) pushing \\\n+                    reexported name `%s` onto `%s` (crate %d, orig %d, \\\n+                    in crate %d)\",\n+                   name,\n+                   *self.path_builder,\n+                   def_id.crate,\n+                   orig_def_id.crate,\n+                   self.cdata.cnum);\n+            let old_len = self.push_name(name);\n+\n+            // This reexport may be in yet another crate.\n+            let other_crates_items = if def_id.crate == self.cdata.cnum {\n+                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n             } else {\n-                let crate_data = get_crate_data(def_id.crate);\n+                let crate_data = (self.get_crate_data)(def_id.crate);\n                 let root = reader::Doc(crate_data.data);\n                 reader::get_doc(root, tag_items)\n             };\n \n             // Get the item.\n             match maybe_find_item(def_id.node, other_crates_items) {\n                 None => {}\n-                Some(item_doc) => {\n-                    // Construct the def for this item.\n-                    let def_like = item_to_def_like(item_doc,\n-                                                    def_id,\n-                                                    cdata.cnum);\n-\n-                    // Hand the information off to the iteratee.\n-                    debug!(\"(each_path) yielding reexported \\\n-                           item: %s\", reexport_path);\n-\n-                    if (!f(reexport_path, def_like, ast::public)) {\n-                        return false;\n-                    }\n+                Some(reexported_item_doc) => {\n+                    continue = self.process_item_and_pop_name(\n+                        reexported_item_doc,\n+                        def_id,\n+                        old_len);\n                 }\n             }\n+\n+            if !continue {\n+                break\n+            }\n         }\n+\n+        continue\n     }\n+}\n \n-    return true;\n+/// Iterates over all the paths in the given crate.\n+pub fn each_path(intr: @ident_interner,\n+                 cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: &fn(&str, def_like, ast::visibility) -> bool)\n+                 -> bool {\n+    // FIXME #4572: This function needs to be nuked, as it's impossible to\n+    // make fast. It's the source of most of the performance problems when\n+    // compiling small crates.\n+\n+    let root_doc = reader::Doc(cdata.data);\n+    let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n+    let crate_items_doc = reader::get_doc(misc_info_doc,\n+                                          tag_misc_info_crate_items);\n+\n+    let mut path_builder = ~\"\";\n+\n+    let mut context = EachItemContext {\n+        intr: intr,\n+        cdata: cdata,\n+        get_crate_data: get_crate_data,\n+        path_builder: &mut path_builder,\n+        callback: f,\n+    };\n+\n+    // Iterate over all top-level crate items.\n+    context.each_child_of_module_or_crate(crate_items_doc)\n }\n \n-pub fn get_item_path(cdata: cmd, id: ast::node_id)\n-    -> ast_map::path {\n+pub fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n     item_path(lookup_item(id, cdata.data))\n }\n \n@@ -661,35 +813,20 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n     rslt\n }\n \n-pub fn get_impls_for_mod(intr: @ident_interner,\n-                         cdata: cmd,\n-                         m_id: ast::node_id,\n-                         name: Option<ast::ident>,\n-                         get_cdata: &fn(ast::crate_num) -> cmd)\n-                      -> @~[@resolve::Impl] {\n+/// Returns information about the given implementation.\n+pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::node_id)\n+                -> resolve::Impl {\n     let data = cdata.data;\n-    let mod_item = lookup_item(m_id, data);\n-    let mut result = ~[];\n-    for reader::tagged_docs(mod_item, tag_mod_impl) |doc| {\n-        let did = reader::with_doc_data(doc, parse_def_id);\n-        let local_did = translate_def_id(cdata, did);\n-        debug!(\"(get impls for mod) getting did %? for '%?'\",\n-               local_did, name);\n-          // The impl may be defined in a different crate. Ask the caller\n-          // to give us the metadata\n-        let impl_cdata = get_cdata(local_did.crate);\n-        let impl_data = impl_cdata.data;\n-        let item = lookup_item(local_did.node, impl_data);\n-        let nm = item_name(intr, item);\n-        if match name { Some(n) => { n == nm } None => { true } } {\n-           let base_tps = item_ty_param_count(item);\n-           result.push(@resolve::Impl {\n-                did: local_did, ident: nm,\n-                methods: item_impl_methods(intr, impl_cdata, item, base_tps)\n-            });\n-        };\n+    let impl_item = lookup_item(impl_id, data);\n+    let base_tps = item_ty_param_count(impl_item);\n+    resolve::Impl {\n+        did: ast::def_id {\n+            crate: cdata.cnum,\n+            node: impl_id,\n+        },\n+        ident: item_name(intr, impl_item),\n+        methods: item_impl_methods(intr, cdata, impl_item, base_tps),\n     }\n-    @result\n }\n \n pub fn get_method_name_and_explicit_self("}, {"sha": "187f2a99ed4c5c1a4e4c4cccb7c4724d374b5791", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 163, "deletions": 37, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -22,7 +22,7 @@ use middle;\n use util::ppaux::ty_to_str;\n \n use core::hash::HashUtil;\n-use core::hashmap::HashMap;\n+use core::hashmap::{HashMap, HashSet};\n use core::int;\n use core::io;\n use core::str;\n@@ -64,7 +64,8 @@ pub struct EncodeParams<'self> {\n     discrim_symbols: &'self HashMap<ast::node_id, @str>,\n     link_meta: &'self LinkMeta,\n     cstore: @mut cstore::CStore,\n-    encode_inlined_item: encode_inlined_item<'self>\n+    encode_inlined_item: encode_inlined_item<'self>,\n+    reachable: @mut HashSet<ast::node_id>,\n }\n \n struct Stats {\n@@ -73,6 +74,7 @@ struct Stats {\n     dep_bytes: uint,\n     lang_item_bytes: uint,\n     link_args_bytes: uint,\n+    misc_bytes: uint,\n     item_bytes: uint,\n     index_bytes: uint,\n     zero_bytes: uint,\n@@ -91,7 +93,8 @@ pub struct EncodeContext<'self> {\n     link_meta: &'self LinkMeta,\n     cstore: &'self cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'self>,\n-    type_abbrevs: abbrev_map\n+    type_abbrevs: abbrev_map,\n+    reachable: @mut HashSet<ast::node_id>,\n }\n \n pub fn reachable(ecx: &EncodeContext, id: node_id) -> bool {\n@@ -470,12 +473,77 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n     }\n }\n \n+/// Iterates through \"auxiliary node IDs\", which are node IDs that describe\n+/// top-level items that are sub-items of the given item. Specifically:\n+///\n+/// * For enums, iterates through the node IDs of the variants.\n+///\n+/// * For newtype structs, iterates through the node ID of the constructor.\n+fn each_auxiliary_node_id(item: @item, callback: &fn(node_id) -> bool)\n+                          -> bool {\n+    let mut continue = true;\n+    match item.node {\n+        item_enum(ref enum_def, _) => {\n+            for enum_def.variants.each |variant| {\n+                continue = callback(variant.node.id);\n+                if !continue {\n+                    break\n+                }\n+            }\n+        }\n+        item_struct(struct_def, _) => {\n+            // If this is a newtype struct, return the constructor.\n+            match struct_def.ctor_id {\n+                Some(ctor_id) if struct_def.fields.len() > 0 &&\n+                        struct_def.fields[0].node.kind ==\n+                        ast::unnamed_field => {\n+                    continue = callback(ctor_id);\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    continue\n+}\n+\n+fn encode_reexports(ecx: &EncodeContext,\n+                    ebml_w: &mut writer::Encoder,\n+                    id: node_id,\n+                    path: &[ast_map::path_elt]) {\n+    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+    match ecx.reexports2.find(&id) {\n+        Some(ref exports) => {\n+            debug!(\"(encoding info for module) found reexports for %d\", id);\n+            for exports.each |exp| {\n+                debug!(\"(encoding info for module) reexport '%s' for %d\",\n+                       exp.name, id);\n+                ebml_w.start_tag(tag_items_data_item_reexport);\n+                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n+                ebml_w.wr_str(def_to_str(exp.def_id));\n+                ebml_w.end_tag();\n+                ebml_w.start_tag(tag_items_data_item_reexport_name);\n+                ebml_w.wr_str(exp.name);\n+                ebml_w.end_tag();\n+                ebml_w.end_tag();\n+                encode_reexported_static_methods(ecx, ebml_w, path, exp);\n+            }\n+        }\n+        None => {\n+            debug!(\"(encoding info for module) found no reexports for %d\",\n+                   id);\n+        }\n+    }\n+}\n+\n fn encode_info_for_mod(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        md: &_mod,\n                        id: node_id,\n                        path: &[ast_map::path_elt],\n-                       name: ident) {\n+                       name: ident,\n+                       vis: visibility) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n@@ -484,6 +552,16 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode info about all the module children.\n     for md.items.iter().advance |item| {\n+        ebml_w.start_tag(tag_mod_child);\n+        ebml_w.wr_str(def_to_str(local_def(item.id)));\n+        ebml_w.end_tag();\n+\n+        for each_auxiliary_node_id(*item) |auxiliary_node_id| {\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n+            ebml_w.end_tag();\n+        }\n+\n         match item.node {\n             item_impl(*) => {\n                 let (ident, did) = (item.ident, item.id);\n@@ -497,35 +575,16 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                 ebml_w.wr_str(def_to_str(local_def(did)));\n                 ebml_w.end_tag();\n             }\n-            _ => {} // FIXME #4573: Encode these too.\n+            _ => {}\n         }\n     }\n \n     encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n \n-    // Encode the reexports of this module.\n-    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n-    match ecx.reexports2.find(&id) {\n-        Some(ref exports) => {\n-            debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for exports.iter().advance |exp| {\n-                debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       exp.name, id);\n-                ebml_w.start_tag(tag_items_data_item_reexport);\n-                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                ebml_w.wr_str(def_to_str(exp.def_id));\n-                ebml_w.end_tag();\n-                ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(exp.name);\n-                ebml_w.end_tag();\n-                ebml_w.end_tag();\n-                encode_reexported_static_methods(ecx, ebml_w, path, exp);\n-            }\n-        }\n-        None => {\n-            debug!(\"(encoding info for module) found no reexports for %d\",\n-                   id);\n-        }\n+    // Encode the reexports of this module, if this module is public.\n+    if vis == public {\n+        debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+        encode_reexports(ecx, ebml_w, id, path);\n     }\n \n     ebml_w.end_tag();\n@@ -799,6 +858,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n+        encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         ebml_w.end_tag();\n@@ -811,6 +871,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let tps_len = generics.ty_params.len();\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n         if tps_len > 0u || should_inline(item.attrs) {\n@@ -822,15 +883,29 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       }\n       item_mod(ref m) => {\n         add_to_index();\n-        encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n+        encode_info_for_mod(ecx,\n+                            ebml_w,\n+                            m,\n+                            item.id,\n+                            path,\n+                            item.ident,\n+                            item.vis);\n       }\n-      item_foreign_mod(_) => {\n+      item_foreign_mod(ref fm) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n');\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+\n+        // Encode all the items in this module.\n+        for fm.items.each |foreign_item| {\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(local_def(foreign_item.id)));\n+            ebml_w.end_tag();\n+        }\n+\n         ebml_w.end_tag();\n       }\n       item_ty(_, ref generics) => {\n@@ -998,6 +1073,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.start_tag(tag_item_trait_method);\n             encode_def_id(ebml_w, method_def_id);\n             ebml_w.end_tag();\n+\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(method_def_id));\n+            ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         for super_traits.iter().advance |ast_trait_ref| {\n@@ -1091,6 +1170,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_family(ebml_w, purity_fn_family(purity));\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        encode_name(ecx, ebml_w, nitem.ident);\n         if abi.is_intrinsic() {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));\n         } else {\n@@ -1107,6 +1187,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         }\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n+        encode_name(ecx, ebml_w, nitem.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n     }\n@@ -1120,9 +1201,13 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n-    encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n-                        crate_node_id, [],\n-                        syntax::parse::token::special_idents::invalid);\n+    encode_info_for_mod(ecx,\n+                        ebml_w,\n+                        &crate.node.module,\n+                        crate_node_id,\n+                        [],\n+                        syntax::parse::token::special_idents::invalid,\n+                        public);\n     let items = ecx.tcx.items;\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n@@ -1416,6 +1501,30 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n+fn encode_misc_info(ecx: &EncodeContext,\n+                    crate: &crate,\n+                    ebml_w: &mut writer::Encoder) {\n+    ebml_w.start_tag(tag_misc_info);\n+    ebml_w.start_tag(tag_misc_info_crate_items);\n+    for crate.node.module.items.each |&item| {\n+        ebml_w.start_tag(tag_mod_child);\n+        ebml_w.wr_str(def_to_str(local_def(item.id)));\n+        ebml_w.end_tag();\n+\n+        for each_auxiliary_node_id(item) |auxiliary_node_id| {\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n+            ebml_w.end_tag();\n+        }\n+    }\n+\n+    // Encode reexports for the root module.\n+    encode_reexports(ecx, ebml_w, 0, []);\n+\n+    ebml_w.end_tag();\n+    ebml_w.end_tag();\n+}\n+\n fn encode_crate_dep(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     dep: decoder::crate_dep) {\n@@ -1455,15 +1564,25 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         dep_bytes: 0,\n         lang_item_bytes: 0,\n         link_args_bytes: 0,\n+        misc_bytes: 0,\n         item_bytes: 0,\n         index_bytes: 0,\n         zero_bytes: 0,\n         total_bytes: 0,\n         n_inlines: 0\n     };\n-    let EncodeParams{item_symbols, diag, tcx, reexports2,\n-                     discrim_symbols, cstore, encode_inlined_item,\n-                     link_meta, _} = parms;\n+    let EncodeParams {\n+        item_symbols,\n+        diag,\n+        tcx,\n+        reexports2,\n+        discrim_symbols,\n+        cstore,\n+        encode_inlined_item,\n+        link_meta,\n+        reachable,\n+        _\n+    } = parms;\n     let type_abbrevs = @mut HashMap::new();\n     let stats = @mut stats;\n     let ecx = EncodeContext {\n@@ -1476,7 +1595,8 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,\n-        type_abbrevs: type_abbrevs\n+        type_abbrevs: type_abbrevs,\n+        reachable: reachable,\n      };\n \n     let mut ebml_w = writer::Encoder(wr as @io::Writer);\n@@ -1502,6 +1622,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     encode_link_args(&ecx, &mut ebml_w);\n     ecx.stats.link_args_bytes = *wr.pos - i;\n \n+    // Encode miscellaneous info.\n+    i = *wr.pos;\n+    encode_misc_info(&ecx, crate, &mut ebml_w);\n+    ecx.stats.misc_bytes = *wr.pos - i;\n+\n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = *wr.pos;\n@@ -1529,6 +1654,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         io::println(fmt!(\"       dep bytes: %u\", ecx.stats.dep_bytes));\n         io::println(fmt!(\" lang item bytes: %u\", ecx.stats.lang_item_bytes));\n         io::println(fmt!(\" link args bytes: %u\", ecx.stats.link_args_bytes));\n+        io::println(fmt!(\"      misc bytes: %u\", ecx.stats.misc_bytes));\n         io::println(fmt!(\"      item bytes: %u\", ecx.stats.item_bytes));\n         io::println(fmt!(\"     index bytes: %u\", ecx.stats.index_bytes));\n         io::println(fmt!(\"      zero bytes: %u\", ecx.stats.zero_bytes));"}, {"sha": "12ddd37104588700ce29010c4618cec5bc72d527", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -77,6 +77,15 @@ fn trait_method_might_be_inlined(trait_method: &trait_method) -> bool {\n     }\n }\n \n+// The context we're in. If we're in a public context, then public symbols are\n+// marked reachable. If we're in a private context, then only trait\n+// implementations are marked reachable.\n+#[deriving(Eq)]\n+enum PrivacyContext {\n+    PublicContext,\n+    PrivateContext,\n+}\n+\n // Information needed while computing reachability.\n struct ReachableContext {\n     // The type context.\n@@ -109,25 +118,31 @@ impl ReachableContext {\n         let reachable_symbols = self.reachable_symbols;\n         let worklist = self.worklist;\n         let visitor = visit::mk_vt(@Visitor {\n-            visit_item: |item, (_, visitor)| {\n+            visit_item: |item, (privacy_context, visitor):\n+                    (PrivacyContext, visit::vt<PrivacyContext>)| {\n                 match item.node {\n                     item_fn(*) => {\n-                        reachable_symbols.insert(item.id);\n+                        if privacy_context == PublicContext {\n+                            reachable_symbols.insert(item.id);\n+                        }\n                         if item_might_be_inlined(item) {\n                             worklist.push(item.id)\n                         }\n                     }\n                     item_struct(ref struct_def, _) => {\n                         match struct_def.ctor_id {\n-                            None => {}\n-                            Some(ctor_id) => {\n+                            Some(ctor_id) if\n+                                    privacy_context == PublicContext => {\n                                 reachable_symbols.insert(ctor_id);\n                             }\n+                            Some(_) | None => {}\n                         }\n                     }\n                     item_enum(ref enum_def, _) => {\n-                        for enum_def.variants.each |variant| {\n-                            reachable_symbols.insert(variant.node.id);\n+                        if privacy_context == PublicContext {\n+                            for enum_def.variants.each |variant| {\n+                                reachable_symbols.insert(variant.node.id);\n+                            }\n                         }\n                     }\n                     item_impl(ref generics, trait_ref, _, ref methods) => {\n@@ -137,19 +152,24 @@ impl ReachableContext {\n                         // treating implementations of reachable or cross-\n                         // crate traits as reachable.\n \n+                        let should_be_considered_public = |method: @method| {\n+                            (method.vis == public &&\n+                                    privacy_context == PublicContext) ||\n+                                    trait_ref.is_some()\n+                        };\n+\n                         // Mark all public methods as reachable.\n-                        for methods.each |method| {\n-                            if method.vis == public || trait_ref.is_some() {\n+                        for methods.each |&method| {\n+                            if should_be_considered_public(method) {\n                                 reachable_symbols.insert(method.id);\n                             }\n                         }\n \n                         if generics_require_inlining(generics) {\n                             // If the impl itself has generics, add all public\n                             // symbols to the worklist.\n-                            for methods.each |method| {\n-                                if method.vis == public ||\n-                                        trait_ref.is_some() {\n+                            for methods.each |&method| {\n+                                if should_be_considered_public(method) {\n                                     worklist.push(method.id)\n                                 }\n                             }\n@@ -161,36 +181,39 @@ impl ReachableContext {\n                                 let attrs = &method.attrs;\n                                 if generics_require_inlining(generics) ||\n                                         attributes_specify_inlining(*attrs) ||\n-                                        method.vis == public ||\n-                                        trait_ref.is_some() {\n+                                        should_be_considered_public(*method) {\n                                     worklist.push(method.id)\n                                 }\n                             }\n                         }\n                     }\n                     item_trait(_, _, ref trait_methods) => {\n                         // Mark all provided methods as reachable.\n-                        for trait_methods.each |trait_method| {\n-                            match *trait_method {\n-                                provided(method) => {\n-                                    reachable_symbols.insert(method.id);\n-                                    worklist.push(method.id)\n+                        if privacy_context == PublicContext {\n+                            for trait_methods.each |trait_method| {\n+                                match *trait_method {\n+                                    provided(method) => {\n+                                        reachable_symbols.insert(method.id);\n+                                        worklist.push(method.id)\n+                                    }\n+                                    required(_) => {}\n                                 }\n-                                required(_) => {}\n                             }\n                         }\n                     }\n                     _ => {}\n                 }\n \n-                if item.vis == public {\n-                    visit::visit_item(item, ((), visitor))\n+                if item.vis == public && privacy_context == PublicContext {\n+                    visit::visit_item(item, (PublicContext, visitor))\n+                } else {\n+                    visit::visit_item(item, (PrivateContext, visitor))\n                 }\n             },\n             .. *visit::default_visitor()\n         });\n \n-        visit::visit_crate(crate, ((), visitor))\n+        visit::visit_crate(crate, (PublicContext, visitor))\n     }\n \n     // Returns true if the given def ID represents a local item that is\n@@ -247,7 +270,7 @@ impl ReachableContext {\n                 }\n             }\n             Some(_) => false,\n-            None => tcx.sess.bug(\"def ID not in def map?!\"),\n+            None => false   // This will happen for default methods.\n         }\n     }\n "}, {"sha": "17c984c8a33cfdb0c531e8675fc6fb3053f9241f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -654,7 +654,17 @@ impl NameBindings {\n                     Some(ref type_def) => {\n                         match (*type_def).type_def {\n                             Some(type_def) => Some(type_def),\n-                            None => None,\n+                            None => {\n+                                match type_def.module_def {\n+                                    Some(module) => {\n+                                        match module.def_id {\n+                                            Some(did) => Some(def_mod(did)),\n+                                            None => None,\n+                                        }\n+                                    }\n+                                    None => None,\n+                                }\n+                            }\n                         }\n                     }\n                 }\n@@ -3149,12 +3159,14 @@ impl Resolver {\n             Some(def_id) if def_id.crate == local_crate => {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording \\\n-                        exports for local module\");\n+                        exports for local module `%s`\",\n+                       self.module_to_str(module_));\n             }\n             None => {\n                 // Record exports for the root module.\n                 debug!(\"(recording exports for module subtree) recording \\\n-                        exports for root module\");\n+                        exports for root module `%s`\",\n+                       self.module_to_str(module_));\n             }\n             Some(_) => {\n                 // Bail out.\n@@ -5037,6 +5049,9 @@ impl Resolver {\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n             expr_method_call(_, _, ident, _, _, _) => {\n+                debug!(\"(recording candidate traits for expr) recording \\\n+                        traits for %d\",\n+                       expr.id);\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n@@ -5112,7 +5127,6 @@ impl Resolver {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                self.session.str_of(name));\n \n-\n         let mut found_traits = ~[];\n         let mut search_module = self.current_module;\n         match self.method_map.find(&name) {"}, {"sha": "df7f73a52436a656ac95a00a32eba7188240f826", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -64,7 +64,7 @@ use util::ppaux::{Repr, ty_to_str};\n use middle::trans::type_::Type;\n \n use core::hash;\n-use core::hashmap::{HashMap};\n+use core::hashmap::{HashMap, HashSet};\n use core::int;\n use core::io;\n use core::libc::c_uint;\n@@ -2509,7 +2509,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n                               variant))\n           }\n         };\n-        if !exprt {\n+        if !exprt && !ccx.reachable.contains(&id) {\n             lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n         }\n         ccx.item_vals.insert(id, val);\n@@ -2816,13 +2816,13 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n         encoder::EncodeParams {\n             diag: diag,\n             tcx: cx.tcx,\n-            reachable: cx.reachable,\n             reexports2: cx.exp_map2,\n             item_symbols: item_symbols,\n             discrim_symbols: discrim_symbols,\n             link_meta: link_meta,\n             cstore: cx.sess.cstore,\n-            encode_inlined_item: ie\n+            encode_inlined_item: ie,\n+            reachable: cx.reachable,\n         }\n }\n \n@@ -2890,7 +2890,7 @@ pub fn trans_crate(sess: session::Session,\n                    emap2: resolve::ExportMap2,\n                    reachable_map: @mut HashSet<ast::node_id>,\n                    maps: astencode::Maps)\n-                   -> (ModuleRef, LinkMeta) {\n+                   -> (ContextRef, ModuleRef, LinkMeta) {\n \n     let mut symbol_hasher = hash::default_state();\n     let link_meta = link::build_link_meta(sess, crate, output, &mut symbol_hasher);\n@@ -2911,8 +2911,15 @@ pub fn trans_crate(sess: session::Session,\n     //     sess.bug(\"couldn't enable multi-threaded LLVM\");\n     // }\n \n-    let ccx = @mut CrateContext::new(sess, llmod_id, tcx, emap2, maps,\n-                                 symbol_hasher, link_meta, reachable);\n+    let ccx = @mut CrateContext::new(sess,\n+                                     llmod_id,\n+                                     tcx,\n+                                     emap2,\n+                                     maps,\n+                                     symbol_hasher,\n+                                     link_meta,\n+                                     reachable_map);\n+\n     {\n         let _icx = push_ctxt(\"data\");\n         trans_constants(ccx, crate);"}, {"sha": "a7ffa8e13b027319b7b61872186aa2abea95973d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 78, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -117,84 +117,7 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n-pub type ExternMap = @mut HashMap<@str, ValueRef>;\n-\n-// Crate context.  Every crate we compile has one of these.\n-pub struct CrateContext {\n-     sess: session::Session,\n-     llmod: ModuleRef,\n-     td: TargetData,\n-     tn: @TypeNames,\n-     externs: ExternMap,\n-     intrinsics: HashMap<&'static str, ValueRef>,\n-     item_vals: @mut HashMap<ast::node_id, ValueRef>,\n-     exp_map2: resolve::ExportMap2,\n-     item_symbols: @mut HashMap<ast::node_id, ~str>,\n-     link_meta: LinkMeta,\n-     enum_sizes: @mut HashMap<ty::t, uint>,\n-     discrims: @mut HashMap<ast::def_id, ValueRef>,\n-     discrim_symbols: @mut HashMap<ast::node_id, @str>,\n-     tydescs: @mut HashMap<ty::t, @mut tydesc_info>,\n-     // Set when running emit_tydescs to enforce that no more tydescs are\n-     // created.\n-     finished_tydescs: @mut bool,\n-     // Track mapping of external ids to local items imported for inlining\n-     external: @mut HashMap<ast::def_id, Option<ast::node_id>>,\n-     // Cache instances of monomorphized functions\n-     monomorphized: @mut HashMap<mono_id, ValueRef>,\n-     monomorphizing: @mut HashMap<ast::def_id, uint>,\n-     // Cache computed type parameter uses (see type_use.rs)\n-     type_use_cache: @mut HashMap<ast::def_id, @~[type_use::type_uses]>,\n-     // Cache generated vtables\n-     vtables: @mut HashMap<mono_id, ValueRef>,\n-     // Cache of constant strings,\n-     const_cstr_cache: @mut HashMap<@str, ValueRef>,\n-\n-     // Reverse-direction for const ptrs cast from globals.\n-     // Key is an int, cast from a ValueRef holding a *T,\n-     // Val is a ValueRef holding a *[T].\n-     //\n-     // Needed because LLVM loses pointer->pointee association\n-     // when we ptrcast, and we have to ptrcast during translation\n-     // of a [T] const because we form a slice, a [*T,int] pair, not\n-     // a pointer to an LLVM array type.\n-     const_globals: @mut HashMap<int, ValueRef>,\n-\n-     // Cache of emitted const values\n-     const_values: @mut HashMap<ast::node_id, ValueRef>,\n-\n-     // Cache of external const values\n-     extern_const_values: @mut HashMap<ast::def_id, ValueRef>,\n-\n-     module_data: @mut HashMap<~str, ValueRef>,\n-     lltypes: @mut HashMap<ty::t, TypeRef>,\n-     llsizingtypes: @mut HashMap<ty::t, TypeRef>,\n-     adt_reprs: @mut HashMap<ty::t, @adt::Repr>,\n-     names: namegen,\n-     next_addrspace: addrspace_gen,\n-     symbol_hasher: @mut hash::State,\n-     type_hashcodes: @mut HashMap<ty::t, @str>,\n-     type_short_names: @mut HashMap<ty::t, ~str>,\n-     all_llvm_symbols: @mut HashSet<@str>,\n-     tcx: ty::ctxt,\n-     maps: astencode::Maps,\n-     stats: @mut Stats,\n-     upcalls: @upcall::Upcalls,\n-     tydesc_type: TypeRef,\n-     int_type: TypeRef,\n-     float_type: TypeRef,\n-     opaque_vec_type: TypeRef,\n-     builder: BuilderRef_res,\n-     shape_cx: shape::Ctxt,\n-     crate_map: ValueRef,\n-     // Set when at least one function uses GC. Needed so that\n-     // decl_gc_metadata knows whether to link to the module metadata, which\n-     // is not emitted by LLVM's GC pass when no functions use GC.\n-     uses_gc: @mut bool,\n-     dbg_cx: Option<debuginfo::DebugContext>,\n-     do_not_commit_warning_issued: @mut bool,\n-     reachable_map: @mut HashSet<ast::node_id>,\n-}\n+pub type ExternMap = HashMap<@str, ValueRef>;\n \n // Types used for llself.\n pub struct ValSelfData {"}, {"sha": "9b81fc406b7cc993c88a56efa1795f89967c40db", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -21,7 +21,6 @@ use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::debuginfo;\n-use middle::trans::reachable;\n use middle::trans::type_use;\n use middle::ty;\n \n@@ -48,7 +47,7 @@ pub struct CrateContext {\n      intrinsics: HashMap<&'static str, ValueRef>,\n      item_vals: HashMap<ast::node_id, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n-     reachable: reachable::map,\n+     reachable: @mut HashSet<ast::node_id>,\n      item_symbols: HashMap<ast::node_id, ~str>,\n      link_meta: LinkMeta,\n      enum_sizes: HashMap<ty::t, uint>,\n@@ -115,10 +114,15 @@ pub struct CrateContext {\n }\n \n impl CrateContext {\n-    pub fn new(sess: session::Session, name: &str, tcx: ty::ctxt,\n-               emap2: resolve::ExportMap2, maps: astencode::Maps,\n-               symbol_hasher: hash::State, link_meta: LinkMeta,\n-               reachable: reachable::map) -> CrateContext {\n+    pub fn new(sess: session::Session,\n+               name: &str,\n+               tcx: ty::ctxt,\n+               emap2: resolve::ExportMap2,\n+               maps: astencode::Maps,\n+               symbol_hasher: hash::State,\n+               link_meta: LinkMeta,\n+               reachable: @mut HashSet<ast::node_id>)\n+               -> CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n             set_task_llcx(llcx);"}, {"sha": "4c1c8e5c2c8a3cd2cced0c9b2da05068a5074d0a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -1393,6 +1393,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 method_map.insert(expr.id, (*entry));\n             }\n             None => {\n+                debug!(\"(checking method call) failing expr is %d\", expr.id);\n+\n                 fcx.type_error_message(expr.span,\n                   |actual| {\n                       fmt!(\"type `%s` does not implement any method in scope \\"}, {"sha": "9de7315d0e71e1f5ddbedd6dc546d9498d099364", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 60, "deletions": 90, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -17,7 +17,7 @@\n use core::prelude::*;\n \n use metadata::csearch::{each_path, get_impl_trait};\n-use metadata::csearch::{get_impls_for_mod};\n+use metadata::csearch;\n use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n@@ -855,92 +855,67 @@ impl CoherenceChecker {\n \n     // External crate handling\n \n-    pub fn add_impls_for_module(&self,\n-                                impls_seen: &mut HashSet<def_id>,\n-                                crate_store: @mut CStore,\n-                                module_def_id: def_id) {\n-        let implementations = get_impls_for_mod(crate_store,\n-                                                module_def_id,\n-                                                None);\n-        for implementations.iter().advance |implementation| {\n-            debug!(\"coherence: adding impl from external crate: %s\",\n-                   ty::item_path_str(self.crate_context.tcx,\n-                                     implementation.did));\n-\n-            // Make sure we don't visit the same implementation\n-            // multiple times.\n-            if !impls_seen.insert(implementation.did) {\n-                // Skip this one.\n-                loop;\n-            }\n-            // Good. Continue.\n-\n-            let self_type = lookup_item_type(self.crate_context.tcx,\n-                                             implementation.did);\n-            let associated_traits = get_impl_trait(self.crate_context.tcx,\n-                                                    implementation.did);\n-\n-            // Do a sanity check to make sure that inherent methods have base\n-            // types.\n-\n-            if associated_traits.is_none() {\n-                match get_base_type_def_id(self.inference_context,\n-                                           dummy_sp(),\n-                                           self_type.ty) {\n-                    None => {\n-                        let session = self.crate_context.tcx.sess;\n-                        session.bug(fmt!(\n-                            \"no base type for external impl \\\n-                             with no trait: %s (type %s)!\",\n-                             session.str_of(implementation.ident),\n-                             ty_to_str(self.crate_context.tcx,self_type.ty)));\n-                    }\n-                    Some(_) => {\n-                        // Nothing to do.\n-                    }\n-                }\n-            }\n-\n-            let mut implementation = *implementation;\n+    pub fn add_external_impl(&self,\n+                             impls_seen: &mut HashSet<def_id>,\n+                             crate_store: @mut CStore,\n+                             impl_def_id: def_id) {\n+        let implementation = csearch::get_impl(crate_store, impl_def_id);\n \n-            // Record all the trait methods.\n-            for associated_traits.iter().advance |trait_ref| {\n-                self.instantiate_default_methods(implementation.did,\n-                                                 &**trait_ref);\n-                // Could we avoid these copies when we don't need them?\n-                let mut methods = /*bad?*/ copy implementation.methods;\n-                self.add_provided_methods_to_impl(\n-                    &mut methods,\n-                    &trait_ref.def_id,\n-                    &implementation.did);\n-                implementation = @Impl { methods: methods,\n-                                        .. *implementation };\n+        debug!(\"coherence: adding impl from external crate: %s\",\n+               ty::item_path_str(self.crate_context.tcx, implementation.did));\n \n+        // Make sure we don't visit the same implementation multiple times.\n+        if !impls_seen.insert(implementation.did) {\n+            // Skip this one.\n+            return\n+        }\n+        // Good. Continue.\n \n-                self.add_trait_method(trait_ref.def_id, implementation);\n-            }\n-\n-            // Add the implementation to the mapping from\n-            // implementation to base type def ID, if there is a base\n-            // type for this implementation.\n+        let self_type = lookup_item_type(self.crate_context.tcx,\n+                                         implementation.did);\n+        let associated_traits = get_impl_trait(self.crate_context.tcx,\n+                                               implementation.did);\n \n+        // Do a sanity check to make sure that inherent methods have base\n+        // types.\n+        if associated_traits.is_none() {\n             match get_base_type_def_id(self.inference_context,\n-                                     dummy_sp(),\n-                                     self_type.ty) {\n+                                       dummy_sp(),\n+                                       self_type.ty) {\n                 None => {\n-                    // Nothing to do.\n+                    let session = self.crate_context.tcx.sess;\n+                    session.bug(fmt!(\"no base type for external impl with no \\\n+                                      trait: %s (type %s)!\",\n+                                     session.str_of(implementation.ident),\n+                                     ty_to_str(self.crate_context.tcx,\n+                                               self_type.ty)));\n                 }\n-                Some(base_type_def_id) => {\n-                    // inherent methods apply to `impl Type` but not\n-                    // `impl Trait for Type`:\n-                    if associated_traits.is_none() {\n-                        self.add_inherent_method(base_type_def_id,\n-                                                 implementation);\n-                    }\n+                Some(_) => {} // Nothing to do.\n+            }\n+        }\n+\n+        // Record all the trait methods.\n+        let implementation = @implementation;\n+        for associated_traits.iter().advance |trait_ref| {\n+            self.add_trait_method(trait_ref.def_id, implementation);\n+        }\n \n-                    self.base_type_def_ids.insert(implementation.did,\n-                                                  base_type_def_id);\n+        // Add the implementation to the mapping from implementation to base\n+        // type def ID, if there is a base type for this implementation.\n+        match get_base_type_def_id(self.inference_context,\n+                                   dummy_sp(),\n+                                   self_type.ty) {\n+            None => {} // Nothing to do.\n+            Some(base_type_def_id) => {\n+                // inherent methods apply to `impl Type` but not\n+                // `impl Trait for Type`:\n+                if associated_traits.is_none() {\n+                    self.add_inherent_method(base_type_def_id,\n+                                             implementation);\n                 }\n+\n+                self.base_type_def_ids.insert(implementation.did,\n+                                              base_type_def_id);\n             }\n         }\n     }\n@@ -952,22 +927,17 @@ impl CoherenceChecker {\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            self.add_impls_for_module(&mut impls_seen,\n-                                      crate_store,\n-                                      def_id { crate: crate_number,\n-                                               node: 0 });\n-\n             for each_path(crate_store, crate_number) |_, def_like, _| {\n                 match def_like {\n-                    dl_def(def_mod(def_id)) => {\n-                        self.add_impls_for_module(&mut impls_seen,\n-                                                  crate_store,\n-                                                  def_id);\n+                    dl_def(def_trait(def_id)) => {\n+                        self.add_default_methods_for_external_trait(def_id);\n                     }\n-                    dl_def(_) | dl_impl(_) | dl_field => {\n-                        // Skip this.\n-                        loop;\n+                    dl_impl(def_id) => {\n+                        self.add_external_impl(&mut impls_seen,\n+                                               crate_store,\n+                                               def_id)\n                     }\n+                    dl_def(_) | dl_field => loop,   // Skip this.\n                 }\n             }\n         }"}, {"sha": "8f0870af513320be08449740652c008a05070487", "filename": "src/libstd/char.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -10,6 +10,7 @@\n \n //! Utilities for manipulating the char type\n \n+use container::Container;\n use option::{None, Option, Some};\n use str;\n use str::{StrSlice, OwnedStr};"}, {"sha": "590292d0d32767126ccf7e380be92ada5b2069df", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -29,6 +29,7 @@\n #[allow(missing_doc)];\n \n use cast;\n+use container::Container;\n use io;\n use iterator::IteratorUtil;\n use libc;\n@@ -1500,7 +1501,10 @@ mod tests {\n     fn test_getenv_big() {\n         let mut s = ~\"\";\n         let mut i = 0;\n-        while i < 100 { s += \"aaaaaaaaaa\"; i += 1; }\n+        while i < 100 {\n+            s = s + \"aaaaaaaaaa\";\n+            i += 1;\n+        }\n         let n = make_rand_name();\n         setenv(n, s);\n         debug!(copy s);"}, {"sha": "5baff8aee68dd159a11b3029120de1ec83f54da1", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -42,6 +42,7 @@ fn main () {\n \n use cast;\n use cmp;\n+use container::Container;\n use int;\n use iterator::IteratorUtil;\n use local_data;"}, {"sha": "2144afc0fbd1858d6390f11c87e9b4d728428293", "filename": "src/libstd/str.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -1140,6 +1140,17 @@ impl<'self> Str for @str {\n     }\n }\n \n+impl<'self> Container for &'self str {\n+    #[inline]\n+    fn len(&self) -> uint {\n+        do as_buf(*self) |_p, n| { n - 1u }\n+    }\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+}\n+\n #[allow(missing_doc)]\n pub trait StrSlice<'self> {\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n@@ -1158,10 +1169,8 @@ pub trait StrSlice<'self> {\n     fn any_line_iter(&self) -> AnyLineIterator<'self>;\n     fn word_iter(&self) -> WordIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n-    fn is_empty(&self) -> bool;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n-    fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n \n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n@@ -1362,9 +1371,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         self.split_iter(char::is_whitespace).filter(|s| !s.is_empty())\n     }\n \n-    /// Returns true if the string has length 0\n-    #[inline]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n     /**\n      * Returns true if the string contains only whitespace\n      *\n@@ -1379,11 +1385,6 @@ impl<'self> StrSlice<'self> for &'self str {\n      */\n     #[inline]\n     fn is_alphanumeric(&self) -> bool { self.iter().all(char::is_alphanumeric) }\n-    /// Returns the size in bytes not counting the null terminator\n-    #[inline]\n-    fn len(&self) -> uint {\n-        do as_buf(*self) |_p, n| { n - 1u }\n-    }\n     /// Returns the number of characters that a string holds\n     #[inline]\n     fn char_len(&self) -> uint { self.iter().len_() }"}, {"sha": "624062a7ec4072279f010726491164506dbba6ca", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e015bee2866a802f17c84bd6d3a06212945a9d17/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=e015bee2866a802f17c84bd6d3a06212945a9d17", "patch": "@@ -94,6 +94,7 @@ use iterator::IteratorUtil;\n #[doc(hidden)]\n pub mod ct {\n     use char;\n+    use container::Container;\n     use prelude::*;\n     use str;\n "}]}