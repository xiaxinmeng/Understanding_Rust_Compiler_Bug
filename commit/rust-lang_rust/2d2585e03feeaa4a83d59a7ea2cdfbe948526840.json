{"sha": "2d2585e03feeaa4a83d59a7ea2cdfbe948526840", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkMjU4NWUwM2ZlZWFhNGE4M2Q1OWE3ZWEyY2RmYmU5NDg1MjY4NDA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-29T09:46:56Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-01-29T10:03:59Z"}, "message": "Don't compute diagnostics on the main thread\n\ncloses #2909", "tree": {"sha": "87b2ca2cdf113dedf3a6b28a99ded52e50238b69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87b2ca2cdf113dedf3a6b28a99ded52e50238b69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d2585e03feeaa4a83d59a7ea2cdfbe948526840", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d2585e03feeaa4a83d59a7ea2cdfbe948526840", "html_url": "https://github.com/rust-lang/rust/commit/2d2585e03feeaa4a83d59a7ea2cdfbe948526840", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d2585e03feeaa4a83d59a7ea2cdfbe948526840/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bdf2e0972a1458c28b3095f8d57e580130d09d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bdf2e0972a1458c28b3095f8d57e580130d09d3", "html_url": "https://github.com/rust-lang/rust/commit/3bdf2e0972a1458c28b3095f8d57e580130d09d3"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "52c7e2bdb0570b593b86856bed210eb48e29f6ba", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2d2585e03feeaa4a83d59a7ea2cdfbe948526840/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d2585e03feeaa4a83d59a7ea2cdfbe948526840/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=2d2585e03feeaa4a83d59a7ea2cdfbe948526840", "patch": "@@ -9,7 +9,7 @@ use std::{error::Error, fmt, panic, path::PathBuf, sync::Arc, time::Instant};\n \n use crossbeam_channel::{select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n-use lsp_types::{ClientCapabilities, NumberOrString, Url};\n+use lsp_types::{ClientCapabilities, NumberOrString};\n use ra_cargo_watch::{CheckOptions, CheckTask};\n use ra_ide::{Canceled, FeatureFlags, FileId, LibraryData, SourceRootId};\n use ra_prof::profile;\n@@ -352,7 +352,7 @@ fn loop_turn(\n             world_state.maybe_collect_garbage();\n             loop_state.in_flight_libraries -= 1;\n         }\n-        Event::CheckWatcher(task) => on_check_task(task, world_state, task_sender)?,\n+        Event::CheckWatcher(task) => on_check_task(pool, task, world_state, task_sender)?,\n         Event::Msg(msg) => match msg {\n             Message::Request(req) => on_request(\n                 world_state,\n@@ -602,31 +602,23 @@ fn on_notification(\n }\n \n fn on_check_task(\n+    pool: &ThreadPool,\n     task: CheckTask,\n     world_state: &mut WorldState,\n     task_sender: &Sender<Task>,\n ) -> Result<()> {\n-    match task {\n+    let urls = match task {\n         CheckTask::ClearDiagnostics => {\n             let state = Arc::get_mut(&mut world_state.check_watcher.state)\n                 .expect(\"couldn't get check watcher state as mutable\");\n-            let cleared_files = state.clear();\n-\n-            // Send updated diagnostics for each cleared file\n-            for url in cleared_files {\n-                publish_diagnostics_for_url(&url, world_state, task_sender)?;\n-            }\n+            state.clear()\n         }\n \n         CheckTask::AddDiagnostic(url, diagnostic) => {\n             let state = Arc::get_mut(&mut world_state.check_watcher.state)\n                 .expect(\"couldn't get check watcher state as mutable\");\n             state.add_diagnostic_with_fixes(url.clone(), diagnostic);\n-\n-            // We manually send a diagnostic update when the watcher asks\n-            // us to, to avoid the issue of having to change the file to\n-            // receive updated diagnostics.\n-            publish_diagnostics_for_url(&url, world_state, task_sender)?;\n+            vec![url]\n         }\n \n         CheckTask::Status(progress) => {\n@@ -636,22 +628,30 @@ fn on_check_task(\n             };\n             let not = notification_new::<req::Progress>(params);\n             task_sender.send(Task::Notify(not)).unwrap();\n+            Vec::new()\n         }\n-    }\n-    Ok(())\n-}\n+    };\n+\n+    let subscriptions = urls\n+        .into_iter()\n+        .map(|url| {\n+            let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n+            Ok(world_state.vfs.read().path2file(&path).map(|it| FileId(it.0)))\n+        })\n+        .filter_map(|res| res.transpose())\n+        .collect::<Result<Vec<_>>>()?;\n+\n+    // We manually send a diagnostic update when the watcher asks\n+    // us to, to avoid the issue of having to change the file to\n+    // receive updated diagnostics.\n+    update_file_notifications_on_threadpool(\n+        pool,\n+        world_state.snapshot(),\n+        false,\n+        task_sender.clone(),\n+        subscriptions,\n+    );\n \n-fn publish_diagnostics_for_url(\n-    url: &Url,\n-    world_state: &WorldState,\n-    task_sender: &Sender<Task>,\n-) -> Result<()> {\n-    let path = url.to_file_path().map_err(|()| format!(\"invalid uri: {}\", url))?;\n-    if let Some(file_id) = world_state.vfs.read().path2file(&path) {\n-        let params = handlers::publish_diagnostics(&world_state.snapshot(), FileId(file_id.0))?;\n-        let not = notification_new::<req::PublishDiagnostics>(params);\n-        task_sender.send(Task::Notify(not)).unwrap();\n-    }\n     Ok(())\n }\n "}]}