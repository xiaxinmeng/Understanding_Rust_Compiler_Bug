{"sha": "f345d1772ab3827fbc3e31428b0d9479cab0ea39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzNDVkMTc3MmFiMzgyN2ZiYzNlMzE0MjhiMGQ5NDc5Y2FiMGVhMzk=", "commit": {"author": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-10T02:50:03Z"}, "committer": {"name": "Vladyslav Katasonov", "email": "cpud47@gmail.com", "date": "2021-02-13T19:04:52Z"}, "message": "handle return, break and continue when extracting function", "tree": {"sha": "6dcbe05090edffb1de7d5ac2c43785e9344633b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dcbe05090edffb1de7d5ac2c43785e9344633b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f345d1772ab3827fbc3e31428b0d9479cab0ea39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f345d1772ab3827fbc3e31428b0d9479cab0ea39", "html_url": "https://github.com/rust-lang/rust/commit/f345d1772ab3827fbc3e31428b0d9479cab0ea39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f345d1772ab3827fbc3e31428b0d9479cab0ea39/comments", "author": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cpud36", "id": 4218373, "node_id": "MDQ6VXNlcjQyMTgzNzM=", "avatar_url": "https://avatars.githubusercontent.com/u/4218373?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cpud36", "html_url": "https://github.com/cpud36", "followers_url": "https://api.github.com/users/cpud36/followers", "following_url": "https://api.github.com/users/cpud36/following{/other_user}", "gists_url": "https://api.github.com/users/cpud36/gists{/gist_id}", "starred_url": "https://api.github.com/users/cpud36/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cpud36/subscriptions", "organizations_url": "https://api.github.com/users/cpud36/orgs", "repos_url": "https://api.github.com/users/cpud36/repos", "events_url": "https://api.github.com/users/cpud36/events{/privacy}", "received_events_url": "https://api.github.com/users/cpud36/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ad3d7938f18dd12df6b66a12656558b166c8d7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ad3d7938f18dd12df6b66a12656558b166c8d7f", "html_url": "https://github.com/rust-lang/rust/commit/0ad3d7938f18dd12df6b66a12656558b166c8d7f"}], "stats": {"total": 1217, "additions": 1083, "deletions": 134}, "files": [{"sha": "6b87c3c05724cf0898d1150d388426a15a69f1df", "filename": "crates/assists/src/handlers/early_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=f345d1772ab3827fbc3e31428b0d9479cab0ea39", "patch": "@@ -88,7 +88,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n \n     let early_expression: ast::Expr = match parent_container.kind() {\n         WHILE_EXPR | LOOP_EXPR => make::expr_continue(),\n-        FN => make::expr_return(),\n+        FN => make::expr_return(None),\n         _ => return None,\n     };\n "}, {"sha": "4372479b9e5420be7234ccfd0854148bee1599f4", "filename": "crates/assists/src/handlers/extract_function.rs", "status": "modified", "additions": 1026, "deletions": 121, "changes": 1147, "blob_url": "https://github.com/rust-lang/rust/blob/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=f345d1772ab3827fbc3e31428b0d9479cab0ea39", "patch": "@@ -1,4 +1,4 @@\n-use std::{fmt, iter};\n+use std::iter;\n \n use ast::make;\n use either::Either;\n@@ -16,9 +16,9 @@ use syntax::{\n         edit::{AstNodeEdit, IndentLevel},\n         AstNode,\n     },\n-    AstToken, Direction, SyntaxElement,\n+    SyntaxElement,\n     SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n-    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, T,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,\n };\n use test_utils::mark;\n \n@@ -84,6 +84,7 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n         // We should not have variables that outlive body if we have expression block\n         return None;\n     }\n+    let control_flow = external_control_flow(&body)?;\n \n     let target_range = body.text_range();\n \n@@ -98,28 +99,122 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext) -> Option\n                 name: \"fun_name\".to_string(),\n                 self_param: self_param.map(|(_, pat)| pat),\n                 params,\n+                control_flow,\n                 ret_ty,\n                 body,\n                 vars_defined_in_body_and_outlive,\n             };\n \n-            builder.replace(target_range, format_replacement(ctx, &fun));\n-\n             let new_indent = IndentLevel::from_node(&insert_after);\n             let old_indent = fun.body.indent_level();\n \n+            builder.replace(target_range, format_replacement(ctx, &fun, old_indent));\n+\n             let fn_def = format_function(ctx, module, &fun, old_indent, new_indent);\n             let insert_offset = insert_after.text_range().end();\n             builder.insert(insert_offset, fn_def);\n         },\n     )\n }\n \n+fn external_control_flow(body: &FunctionBody) -> Option<ControlFlow> {\n+    let mut ret_expr = None;\n+    let mut try_expr = None;\n+    let mut break_expr = None;\n+    let mut continue_expr = None;\n+    let (syntax, text_range) = match body {\n+        FunctionBody::Expr(expr) => (expr.syntax(), expr.syntax().text_range()),\n+        FunctionBody::Span { parent, text_range } => (parent.syntax(), *text_range),\n+    };\n+\n+    let mut nested_loop = None;\n+    let mut nested_scope = None;\n+\n+    for e in syntax.preorder() {\n+        let e = match e {\n+            WalkEvent::Enter(e) => e,\n+            WalkEvent::Leave(e) => {\n+                if nested_loop.as_ref() == Some(&e) {\n+                    nested_loop = None;\n+                }\n+                if nested_scope.as_ref() == Some(&e) {\n+                    nested_scope = None;\n+                }\n+                continue;\n+            }\n+        };\n+        if nested_scope.is_some() {\n+            continue;\n+        }\n+        if !text_range.contains_range(e.text_range()) {\n+            continue;\n+        }\n+        match e.kind() {\n+            SyntaxKind::LOOP_EXPR | SyntaxKind::WHILE_EXPR | SyntaxKind::FOR_EXPR => {\n+                if nested_loop.is_none() {\n+                    nested_loop = Some(e);\n+                }\n+            }\n+            SyntaxKind::FN\n+            | SyntaxKind::CONST\n+            | SyntaxKind::STATIC\n+            | SyntaxKind::IMPL\n+            | SyntaxKind::MODULE => {\n+                if nested_scope.is_none() {\n+                    nested_scope = Some(e);\n+                }\n+            }\n+            SyntaxKind::RETURN_EXPR => {\n+                ret_expr = Some(ast::ReturnExpr::cast(e).unwrap());\n+            }\n+            SyntaxKind::TRY_EXPR => {\n+                try_expr = Some(ast::TryExpr::cast(e).unwrap());\n+            }\n+            SyntaxKind::BREAK_EXPR if nested_loop.is_none() => {\n+                break_expr = Some(ast::BreakExpr::cast(e).unwrap());\n+            }\n+            SyntaxKind::CONTINUE_EXPR if nested_loop.is_none() => {\n+                continue_expr = Some(ast::ContinueExpr::cast(e).unwrap());\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    if try_expr.is_some() {\n+        // FIXME: support try\n+        return None;\n+    }\n+\n+    let kind = match (ret_expr, break_expr, continue_expr) {\n+        (Some(r), None, None) => match r.expr() {\n+            Some(expr) => Some(FlowKind::ReturnValue(expr)),\n+            None => Some(FlowKind::Return),\n+        },\n+        (Some(_), _, _) => {\n+            mark::hit!(external_control_flow_return_and_bc);\n+            return None;\n+        }\n+        (None, Some(_), Some(_)) => {\n+            mark::hit!(external_control_flow_break_and_continue);\n+            return None;\n+        }\n+        (None, Some(b), None) => match b.expr() {\n+            Some(expr) => Some(FlowKind::BreakValue(expr)),\n+            None => Some(FlowKind::Break),\n+        },\n+        (None, None, Some(_)) => Some(FlowKind::Continue),\n+        (None, None, None) => None,\n+    };\n+\n+    Some(ControlFlow { kind })\n+}\n+\n #[derive(Debug)]\n struct Function {\n     name: String,\n     self_param: Option<ast::SelfParam>,\n     params: Vec<Param>,\n+    control_flow: ControlFlow,\n     ret_ty: RetType,\n     body: FunctionBody,\n     vars_defined_in_body_and_outlive: Vec<Local>,\n@@ -134,6 +229,11 @@ struct Param {\n     is_copy: bool,\n }\n \n+#[derive(Debug)]\n+struct ControlFlow {\n+    kind: Option<FlowKind>,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum ParamKind {\n     Value,\n@@ -142,6 +242,30 @@ enum ParamKind {\n     MutRef,\n }\n \n+#[derive(Debug, Eq, PartialEq)]\n+enum FunType {\n+    Unit,\n+    Single(hir::Type),\n+    Tuple(Vec<hir::Type>),\n+}\n+\n+impl Function {\n+    fn return_type(&self, ctx: &AssistContext) -> FunType {\n+        match &self.ret_ty {\n+            RetType::Expr(ty) if ty.is_unit() => FunType::Unit,\n+            RetType::Expr(ty) => FunType::Single(ty.clone()),\n+            RetType::Stmt => match self.vars_defined_in_body_and_outlive.as_slice() {\n+                [] => FunType::Unit,\n+                [var] => FunType::Single(var.ty(ctx.db())),\n+                vars => {\n+                    let types = vars.iter().map(|v| v.ty(ctx.db())).collect();\n+                    FunType::Tuple(types)\n+                }\n+            },\n+        }\n+    }\n+}\n+\n impl ParamKind {\n     fn is_ref(&self) -> bool {\n         matches!(self, ParamKind::SharedRef | ParamKind::MutRef)\n@@ -158,26 +282,78 @@ impl Param {\n         }\n     }\n \n-    fn value_prefix(&self) -> &'static str {\n+    fn to_arg(&self, ctx: &AssistContext) -> ast::Expr {\n+        let var = path_expr_from_local(ctx, self.var);\n         match self.kind() {\n-            ParamKind::Value | ParamKind::MutValue => \"\",\n-            ParamKind::SharedRef => \"&\",\n-            ParamKind::MutRef => \"&mut \",\n+            ParamKind::Value | ParamKind::MutValue => var,\n+            ParamKind::SharedRef => make::expr_ref(var, false),\n+            ParamKind::MutRef => make::expr_ref(var, true),\n         }\n     }\n \n-    fn type_prefix(&self) -> &'static str {\n-        match self.kind() {\n-            ParamKind::Value | ParamKind::MutValue => \"\",\n-            ParamKind::SharedRef => \"&\",\n-            ParamKind::MutRef => \"&mut \",\n+    fn to_param(&self, ctx: &AssistContext, module: hir::Module) -> ast::Param {\n+        let var = self.var.name(ctx.db()).unwrap().to_string();\n+        let var_name = make::name(&var);\n+        let pat = match self.kind() {\n+            ParamKind::MutValue => make::ident_mut_pat(var_name),\n+            ParamKind::Value | ParamKind::SharedRef | ParamKind::MutRef => {\n+                make::ident_pat(var_name)\n+            }\n+        };\n+\n+        let ty = make_ty(&self.ty, ctx, module);\n+        let ty = match self.kind() {\n+            ParamKind::Value | ParamKind::MutValue => ty,\n+            ParamKind::SharedRef => make::ty_ref(ty, false),\n+            ParamKind::MutRef => make::ty_ref(ty, true),\n+        };\n+\n+        make::param(pat.into(), ty)\n+    }\n+}\n+\n+/// Control flow that is exported from extracted function\n+///\n+/// E.g.:\n+/// ```rust,no_run\n+/// loop {\n+///     $0\n+///     if 42 == 42 {\n+///         break;\n+///     }\n+///     $0\n+/// }\n+/// ```\n+#[derive(Debug, Clone)]\n+enum FlowKind {\n+    /// Return without value (`return;`)\n+    Return,\n+    /// Return with value (`return $expr;`)\n+    ReturnValue(ast::Expr),\n+    /// Break without value (`return;`)\n+    Break,\n+    /// Break with value (`break $expr;`)\n+    BreakValue(ast::Expr),\n+    /// Continue\n+    Continue,\n+}\n+\n+impl FlowKind {\n+    fn make_expr(&self, expr: Option<ast::Expr>) -> ast::Expr {\n+        match self {\n+            FlowKind::Return | FlowKind::ReturnValue(_) => make::expr_return(expr),\n+            FlowKind::Break | FlowKind::BreakValue(_) => make::expr_break(expr),\n+            FlowKind::Continue => {\n+                stdx::always!(expr.is_none(), \"continue with value is not possible\");\n+                make::expr_continue()\n+            }\n         }\n     }\n \n-    fn mut_pattern(&self) -> &'static str {\n-        match self.kind() {\n-            ParamKind::MutValue => \"mut \",\n-            _ => \"\",\n+    fn expr_ty(&self, ctx: &AssistContext) -> Option<hir::Type> {\n+        match self {\n+            FlowKind::ReturnValue(expr) | FlowKind::BreakValue(expr) => ctx.sema.type_of_expr(expr),\n+            FlowKind::Return | FlowKind::Break | FlowKind::Continue => None,\n         }\n     }\n }\n@@ -195,14 +371,6 @@ impl RetType {\n             RetType::Stmt => true,\n         }\n     }\n-\n-    fn as_fn_ret(&self) -> Option<&hir::Type> {\n-        match self {\n-            RetType::Stmt => None,\n-            RetType::Expr(ty) if ty.is_unit() => None,\n-            RetType::Expr(ty) => Some(ty),\n-        }\n-    }\n }\n \n /// Semantically same as `ast::Expr`, but preserves identity when using only part of the Block\n@@ -234,7 +402,7 @@ impl FunctionBody {\n     fn indent_level(&self) -> IndentLevel {\n         match &self {\n             FunctionBody::Expr(expr) => IndentLevel::from_node(expr.syntax()),\n-            FunctionBody::Span { parent, .. } => IndentLevel::from_node(parent.syntax()),\n+            FunctionBody::Span { parent, .. } => IndentLevel::from_node(parent.syntax()) + 1,\n         }\n     }\n \n@@ -668,9 +836,24 @@ fn scope_for_fn_insertion_node(node: &SyntaxNode, anchor: Anchor) -> Option<Synt\n     last_ancestor\n }\n \n-fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n-    let mut buf = String::new();\n+fn format_replacement(ctx: &AssistContext, fun: &Function, indent: IndentLevel) -> String {\n+    let ret_ty = fun.return_type(ctx);\n \n+    let args = fun.params.iter().map(|param| param.to_arg(ctx));\n+    let args = make::arg_list(args);\n+    let call_expr = if fun.self_param.is_some() {\n+        let self_arg = make::expr_path(make_path_from_text(\"self\"));\n+        make::expr_method_call(self_arg, &fun.name, args)\n+    } else {\n+        let func = make::expr_path(make_path_from_text(&fun.name));\n+        make::expr_call(func, args)\n+    };\n+\n+    let handler = FlowHandler::from_ret_ty(fun, &ret_ty);\n+\n+    let expr = handler.make_expr(call_expr).indent(indent);\n+\n+    let mut buf = String::new();\n     match fun.vars_defined_in_body_and_outlive.as_slice() {\n         [] => {}\n         [var] => format_to!(buf, \"let {} = \", var.name(ctx.db()).unwrap()),\n@@ -683,34 +866,123 @@ fn format_replacement(ctx: &AssistContext, fun: &Function) -> String {\n             buf.push_str(\") = \");\n         }\n     }\n-\n-    if fun.self_param.is_some() {\n-        format_to!(buf, \"self.\");\n-    }\n-    format_to!(buf, \"{}(\", fun.name);\n-    format_arg_list_to(&mut buf, fun, ctx);\n-    format_to!(buf, \")\");\n-\n-    if fun.ret_ty.is_unit() {\n-        format_to!(buf, \";\");\n+    format_to!(buf, \"{}\", expr);\n+    if fun.ret_ty.is_unit()\n+        && (!fun.vars_defined_in_body_and_outlive.is_empty() || !expr.is_block_like())\n+    {\n+        buf.push(';');\n     }\n-\n     buf\n }\n \n-fn format_arg_list_to(buf: &mut String, fun: &Function, ctx: &AssistContext) {\n-    let mut it = fun.params.iter();\n-    if let Some(param) = it.next() {\n-        format_arg_to(buf, ctx, param);\n+enum FlowHandler {\n+    None,\n+    If { action: FlowKind },\n+    IfOption { action: FlowKind },\n+    MatchOption { none: FlowKind },\n+    MatchResult { err: FlowKind },\n+}\n+\n+impl FlowHandler {\n+    fn from_ret_ty(fun: &Function, ret_ty: &FunType) -> FlowHandler {\n+        match &fun.control_flow.kind {\n+            None => FlowHandler::None,\n+            Some(flow_kind) => {\n+                let action = flow_kind.clone();\n+                if *ret_ty == FunType::Unit {\n+                    match flow_kind {\n+                        FlowKind::Return | FlowKind::Break | FlowKind::Continue => {\n+                            FlowHandler::If { action }\n+                        }\n+                        FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n+                            FlowHandler::IfOption { action }\n+                        }\n+                    }\n+                } else {\n+                    match flow_kind {\n+                        FlowKind::Return | FlowKind::Break | FlowKind::Continue => {\n+                            FlowHandler::MatchOption { none: action }\n+                        }\n+                        FlowKind::ReturnValue(_) | FlowKind::BreakValue(_) => {\n+                            FlowHandler::MatchResult { err: action }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n-    for param in it {\n-        buf.push_str(\", \");\n-        format_arg_to(buf, ctx, param);\n+\n+    fn make_expr(&self, call_expr: ast::Expr) -> ast::Expr {\n+        match self {\n+            FlowHandler::None => call_expr,\n+            FlowHandler::If { action } => {\n+                let action = action.make_expr(None);\n+                let stmt = make::expr_stmt(action);\n+                let block = make::block_expr(iter::once(stmt.into()), None);\n+                let condition = make::condition(call_expr, None);\n+                make::expr_if(condition, block, None)\n+            }\n+            FlowHandler::IfOption { action } => {\n+                let path = make_path_from_text(\"Some\");\n+                let value_pat = make::ident_pat(make::name(\"value\"));\n+                let pattern = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n+                let cond = make::condition(call_expr, Some(pattern.into()));\n+                let value = make::expr_path(make_path_from_text(\"value\"));\n+                let action_expr = action.make_expr(Some(value));\n+                let action_stmt = make::expr_stmt(action_expr);\n+                let then = make::block_expr(iter::once(action_stmt.into()), None);\n+                make::expr_if(cond, then, None)\n+            }\n+            FlowHandler::MatchOption { none } => {\n+                let some_name = \"value\";\n+\n+                let some_arm = {\n+                    let path = make_path_from_text(\"Some\");\n+                    let value_pat = make::ident_pat(make::name(some_name));\n+                    let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n+                    let value = make::expr_path(make_path_from_text(some_name));\n+                    make::match_arm(iter::once(pat.into()), value)\n+                };\n+                let none_arm = {\n+                    let path = make_path_from_text(\"None\");\n+                    let pat = make::path_pat(path);\n+                    make::match_arm(iter::once(pat), none.make_expr(None))\n+                };\n+                let arms = make::match_arm_list(vec![some_arm, none_arm]);\n+                make::expr_match(call_expr, arms)\n+            }\n+            FlowHandler::MatchResult { err } => {\n+                let ok_name = \"value\";\n+                let err_name = \"value\";\n+\n+                let ok_arm = {\n+                    let path = make_path_from_text(\"Ok\");\n+                    let value_pat = make::ident_pat(make::name(ok_name));\n+                    let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n+                    let value = make::expr_path(make_path_from_text(ok_name));\n+                    make::match_arm(iter::once(pat.into()), value)\n+                };\n+                let err_arm = {\n+                    let path = make_path_from_text(\"Err\");\n+                    let value_pat = make::ident_pat(make::name(err_name));\n+                    let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n+                    let value = make::expr_path(make_path_from_text(err_name));\n+                    make::match_arm(iter::once(pat.into()), err.make_expr(Some(value)))\n+                };\n+                let arms = make::match_arm_list(vec![ok_arm, err_arm]);\n+                make::expr_match(call_expr, arms)\n+            }\n+        }\n     }\n }\n \n-fn format_arg_to(buf: &mut String, ctx: &AssistContext, param: &Param) {\n-    format_to!(buf, \"{}{}\", param.value_prefix(), param.var.name(ctx.db()).unwrap());\n+fn make_path_from_text(text: &str) -> ast::Path {\n+    make::path_unqualified(make::path_segment(make::name_ref(text)))\n+}\n+\n+fn path_expr_from_local(ctx: &AssistContext, var: Local) -> ast::Expr {\n+    let name = var.name(ctx.db()).unwrap().to_string();\n+    make::expr_path(make_path_from_text(&name))\n }\n \n fn format_function(\n@@ -721,91 +993,99 @@ fn format_function(\n     new_indent: IndentLevel,\n ) -> String {\n     let mut fn_def = String::new();\n-    format_to!(fn_def, \"\\n\\n{}fn $0{}(\", new_indent, fun.name);\n-    format_function_param_list_to(&mut fn_def, ctx, module, fun);\n-    fn_def.push(')');\n-    format_function_ret_to(&mut fn_def, ctx, module, fun);\n-    fn_def.push(' ');\n-    format_function_body_to(&mut fn_def, ctx, old_indent, new_indent, fun);\n+    let params = make_param_list(ctx, module, fun);\n+    let ret_ty = make_ret_ty(ctx, module, fun);\n+    let body = make_body(ctx, old_indent, new_indent, fun);\n+    format_to!(fn_def, \"\\n\\n{}fn $0{}{}\", new_indent, fun.name, params);\n+    if let Some(ret_ty) = ret_ty {\n+        format_to!(fn_def, \" {}\", ret_ty);\n+    }\n+    format_to!(fn_def, \" {}\", body);\n \n     fn_def\n }\n \n-fn format_function_param_list_to(\n-    fn_def: &mut String,\n-    ctx: &AssistContext,\n-    module: hir::Module,\n-    fun: &Function,\n-) {\n-    let mut it = fun.params.iter();\n-    if let Some(self_param) = &fun.self_param {\n-        format_to!(fn_def, \"{}\", self_param);\n-    } else if let Some(param) = it.next() {\n-        format_param_to(fn_def, ctx, module, param);\n-    }\n-    for param in it {\n-        fn_def.push_str(\", \");\n-        format_param_to(fn_def, ctx, module, param);\n-    }\n-}\n-\n-fn format_param_to(fn_def: &mut String, ctx: &AssistContext, module: hir::Module, param: &Param) {\n-    format_to!(\n-        fn_def,\n-        \"{}{}: {}{}\",\n-        param.mut_pattern(),\n-        param.var.name(ctx.db()).unwrap(),\n-        param.type_prefix(),\n-        format_type(&param.ty, ctx, module)\n-    );\n+fn make_param_list(ctx: &AssistContext, module: hir::Module, fun: &Function) -> ast::ParamList {\n+    let self_param = fun.self_param.clone();\n+    let params = fun.params.iter().map(|param| param.to_param(ctx, module));\n+    make::param_list(self_param, params)\n }\n \n-fn format_function_ret_to(\n-    fn_def: &mut String,\n-    ctx: &AssistContext,\n-    module: hir::Module,\n-    fun: &Function,\n-) {\n-    if let Some(ty) = fun.ret_ty.as_fn_ret() {\n-        format_to!(fn_def, \" -> {}\", format_type(ty, ctx, module));\n-    } else {\n-        match fun.vars_defined_in_body_and_outlive.as_slice() {\n-            [] => {}\n-            [var] => {\n-                format_to!(fn_def, \" -> {}\", format_type(&var.ty(ctx.db()), ctx, module));\n-            }\n-            [v0, vs @ ..] => {\n-                format_to!(fn_def, \" -> ({}\", format_type(&v0.ty(ctx.db()), ctx, module));\n-                for var in vs {\n-                    format_to!(fn_def, \", {}\", format_type(&var.ty(ctx.db()), ctx, module));\n+impl FunType {\n+    fn make_ty(&self, ctx: &AssistContext, module: hir::Module) -> ast::Type {\n+        match self {\n+            FunType::Unit => make::ty_unit(),\n+            FunType::Single(ty) => make_ty(ty, ctx, module),\n+            FunType::Tuple(types) => match types.as_slice() {\n+                [] => {\n+                    stdx::never!(\"tuple type with 0 elements\");\n+                    make::ty_unit()\n                 }\n-                fn_def.push(')');\n-            }\n+                [ty] => {\n+                    stdx::never!(\"tuple type with 1 element\");\n+                    make_ty(ty, ctx, module)\n+                }\n+                types => {\n+                    let types = types.iter().map(|ty| make_ty(ty, ctx, module));\n+                    make::ty_tuple(types)\n+                }\n+            },\n         }\n     }\n }\n \n-fn format_function_body_to(\n-    fn_def: &mut String,\n+fn make_ret_ty(ctx: &AssistContext, module: hir::Module, fun: &Function) -> Option<ast::RetType> {\n+    let ty = fun.return_type(ctx);\n+    let handler = FlowHandler::from_ret_ty(fun, &ty);\n+    let ret_ty = match &handler {\n+        FlowHandler::None => {\n+            if matches!(ty, FunType::Unit) {\n+                return None;\n+            }\n+            ty.make_ty(ctx, module)\n+        }\n+        FlowHandler::If { .. } => make::ty(\"bool\"),\n+        FlowHandler::IfOption { action } => {\n+            let handler_ty = action\n+                .expr_ty(ctx)\n+                .map(|ty| make_ty(&ty, ctx, module))\n+                .unwrap_or_else(make::ty_unit);\n+            make::ty_generic(make::name_ref(\"Option\"), iter::once(handler_ty))\n+        }\n+        FlowHandler::MatchOption { .. } => {\n+            make::ty_generic(make::name_ref(\"Option\"), iter::once(ty.make_ty(ctx, module)))\n+        }\n+        FlowHandler::MatchResult { err } => {\n+            let handler_ty =\n+                err.expr_ty(ctx).map(|ty| make_ty(&ty, ctx, module)).unwrap_or_else(make::ty_unit);\n+            make::ty_generic(make::name_ref(\"Result\"), vec![ty.make_ty(ctx, module), handler_ty])\n+        }\n+    };\n+    Some(make::ret_type(ret_ty))\n+}\n+\n+fn make_body(\n     ctx: &AssistContext,\n     old_indent: IndentLevel,\n     new_indent: IndentLevel,\n     fun: &Function,\n-) {\n+) -> ast::BlockExpr {\n+    let ret_ty = fun.return_type(ctx);\n+    let handler = FlowHandler::from_ret_ty(fun, &ret_ty);\n     let block = match &fun.body {\n         FunctionBody::Expr(expr) => {\n-            let expr = rewrite_body_segment(ctx, &fun.params, expr.syntax());\n+            let expr = rewrite_body_segment(ctx, &fun.params, &handler, expr.syntax());\n             let expr = ast::Expr::cast(expr).unwrap();\n             let expr = expr.dedent(old_indent).indent(IndentLevel(1));\n-            let block = make::block_expr(Vec::new(), Some(expr));\n-            block.indent(new_indent)\n+\n+            make::block_expr(Vec::new(), Some(expr))\n         }\n         FunctionBody::Span { parent, text_range } => {\n             let mut elements: Vec<_> = parent\n                 .syntax()\n                 .children()\n                 .filter(|it| text_range.contains_range(it.text_range()))\n-                .map(|it| rewrite_body_segment(ctx, &fun.params, &it))\n+                .map(|it| rewrite_body_segment(ctx, &fun.params, &handler, &it))\n                 .collect();\n \n             let mut tail_expr = match elements.pop() {\n@@ -821,10 +1101,9 @@ fn format_function_body_to(\n                     [] => {}\n                     [var] => {\n                         tail_expr = Some(path_expr_from_local(ctx, *var));\n-                    },\n+                    }\n                     vars => {\n-                        let exprs = vars.iter()\n-                            .map(|var| path_expr_from_local(ctx, *var));\n+                        let exprs = vars.iter().map(|var| path_expr_from_local(ctx, *var));\n                         let expr = make::expr_tuple(exprs);\n                         tail_expr = Some(expr);\n                     }\n@@ -839,33 +1118,70 @@ fn format_function_body_to(\n                 }\n             });\n \n+            let body_indent = IndentLevel(1);\n+            let elements = elements.map(|stmt| stmt.dedent(old_indent).indent(body_indent));\n+            let tail_expr = tail_expr.map(|expr| expr.dedent(old_indent).indent(body_indent));\n \n-            let block = make::block_expr(elements, tail_expr);\n-            block.dedent(old_indent).indent(new_indent)\n+            make::block_expr(elements, tail_expr)\n         }\n     };\n \n+    let block = match &handler {\n+        FlowHandler::None => block,\n+        FlowHandler::If { .. } => {\n+            let lit_false = ast::Literal::cast(make::tokens::literal(\"false\").parent()).unwrap();\n+            with_tail_expr(block, lit_false.into())\n+        }\n+        FlowHandler::IfOption { .. } => {\n+            let none = make::expr_path(make_path_from_text(\"None\"));\n+            with_tail_expr(block, none)\n         }\n-    \n-    format_to!(fn_def, \"{}\", block);\n+        FlowHandler::MatchOption { .. } => map_tail_expr(block, |tail_expr| {\n+            let some = make::expr_path(make_path_from_text(\"Some\"));\n+            let args = make::arg_list(iter::once(tail_expr));\n+            make::expr_call(some, args)\n+        }),\n+        FlowHandler::MatchResult { .. } => map_tail_expr(block, |tail_expr| {\n+            let some = make::expr_path(make_path_from_text(\"Ok\"));\n+            let args = make::arg_list(iter::once(tail_expr));\n+            make::expr_call(some, args)\n+        }),\n+    };\n+\n+    block.indent(new_indent)\n }\n \n-fn path_expr_from_local(ctx: &AssistContext, var: Local) -> ast::Expr {\n-    let name = var.name(ctx.db()).unwrap().to_string();\n-    let path = make::path_unqualified(make::path_segment(make::name_ref(&name)));\n-    make::expr_path(path)\n+fn map_tail_expr(block: ast::BlockExpr, f: impl FnOnce(ast::Expr) -> ast::Expr) -> ast::BlockExpr {\n+    let tail_expr = match block.tail_expr() {\n+        Some(tail_expr) => tail_expr,\n+        None => return block,\n+    };\n+    make::block_expr(block.statements(), Some(f(tail_expr)))\n+}\n+\n+fn with_tail_expr(block: ast::BlockExpr, tail_expr: ast::Expr) -> ast::BlockExpr {\n+    let stmt_tail = block.tail_expr().map(|expr| make::expr_stmt(expr).into());\n+    let stmts = block.statements().chain(stmt_tail);\n+    make::block_expr(stmts, Some(tail_expr))\n }\n \n fn format_type(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> String {\n     ty.display_source_code(ctx.db(), module.into()).ok().unwrap_or_else(|| \"()\".to_string())\n }\n \n+fn make_ty(ty: &hir::Type, ctx: &AssistContext, module: hir::Module) -> ast::Type {\n+    let ty_str = format_type(ty, ctx, module);\n+    make::ty(&ty_str)\n+}\n+\n fn rewrite_body_segment(\n     ctx: &AssistContext,\n     params: &[Param],\n+    handler: &FlowHandler,\n     syntax: &SyntaxNode,\n ) -> SyntaxNode {\n-    fix_param_usages(ctx, params, syntax)\n+    let syntax = fix_param_usages(ctx, params, syntax);\n+    update_external_control_flow(handler, &syntax)\n }\n \n /// change all usages to account for added `&`/`&mut` for some params\n@@ -906,6 +1222,98 @@ fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode)\n     rewriter.rewrite(syntax)\n }\n \n+fn update_external_control_flow(handler: &FlowHandler, syntax: &SyntaxNode) -> SyntaxNode {\n+    let mut rewriter = SyntaxRewriter::default();\n+\n+    let mut nested_loop = None;\n+    let mut nested_scope = None;\n+    for event in syntax.preorder() {\n+        let node = match event {\n+            WalkEvent::Enter(e) => {\n+                match e.kind() {\n+                    SyntaxKind::LOOP_EXPR | SyntaxKind::WHILE_EXPR | SyntaxKind::FOR_EXPR => {\n+                        if nested_loop.is_none() {\n+                            nested_loop = Some(e.clone());\n+                        }\n+                    }\n+                    SyntaxKind::FN\n+                    | SyntaxKind::CONST\n+                    | SyntaxKind::STATIC\n+                    | SyntaxKind::IMPL\n+                    | SyntaxKind::MODULE => {\n+                        if nested_scope.is_none() {\n+                            nested_scope = Some(e.clone());\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                e\n+            }\n+            WalkEvent::Leave(e) => {\n+                if nested_loop.as_ref() == Some(&e) {\n+                    nested_loop = None;\n+                }\n+                if nested_scope.as_ref() == Some(&e) {\n+                    nested_scope = None;\n+                }\n+                continue;\n+            }\n+        };\n+        if nested_scope.is_some() {\n+            continue;\n+        }\n+        let expr = match ast::Expr::cast(node) {\n+            Some(e) => e,\n+            None => continue,\n+        };\n+        match expr {\n+            ast::Expr::ReturnExpr(return_expr) if nested_scope.is_none() => {\n+                let expr = return_expr.expr();\n+                if let Some(replacement) = make_rewritten_flow(handler, expr) {\n+                    rewriter.replace_ast(&return_expr.into(), &replacement);\n+                }\n+            }\n+            ast::Expr::BreakExpr(break_expr) if nested_loop.is_none() => {\n+                let expr = break_expr.expr();\n+                if let Some(replacement) = make_rewritten_flow(handler, expr) {\n+                    rewriter.replace_ast(&break_expr.into(), &replacement);\n+                }\n+            }\n+            ast::Expr::ContinueExpr(continue_expr) if nested_loop.is_none() => {\n+                if let Some(replacement) = make_rewritten_flow(handler, None) {\n+                    rewriter.replace_ast(&continue_expr.into(), &replacement);\n+                }\n+            }\n+            _ => {\n+                // do nothing\n+            }\n+        }\n+    }\n+\n+    rewriter.rewrite(syntax)\n+}\n+\n+fn make_rewritten_flow(handler: &FlowHandler, arg_expr: Option<ast::Expr>) -> Option<ast::Expr> {\n+    let value = match handler {\n+        FlowHandler::None => return None,\n+        FlowHandler::If { .. } => {\n+            ast::Literal::cast(make::tokens::literal(\"true\").parent()).unwrap().into()\n+        }\n+        FlowHandler::IfOption { .. } => {\n+            let expr = arg_expr.unwrap_or_else(|| make::expr_tuple(Vec::new()));\n+            let args = make::arg_list(iter::once(expr));\n+            make::expr_call(make::expr_path(make_path_from_text(\"Some\")), args)\n+        }\n+        FlowHandler::MatchOption { .. } => make::expr_path(make_path_from_text(\"None\")),\n+        FlowHandler::MatchResult { .. } => {\n+            let expr = arg_expr.unwrap_or_else(|| make::expr_tuple(Vec::new()));\n+            let args = make::arg_list(iter::once(expr));\n+            make::expr_call(make::expr_path(make_path_from_text(\"Err\")), args)\n+        }\n+    };\n+    Some(make::expr_return(Some(value)))\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n@@ -2073,6 +2481,66 @@ fn $0fun_name(c: &Counter) {\n         );\n     }\n \n+    #[test]\n+    fn copy_used_after() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+impl Copy for i32 {}\n+fn foo() {\n+    let n = 0;\n+    $0let m = n;$0\n+    let k = n;\n+}\"##,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+impl Copy for i32 {}\n+fn foo() {\n+    let n = 0;\n+    fun_name(n);\n+    let k = n;\n+}\n+\n+fn $0fun_name(n: i32) {\n+    let m = n;\n+}\"##,\n+        )\n+    }\n+\n+    #[test]\n+    fn copy_custom_used_after() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+struct Counter(i32);\n+impl Copy for Counter {}\n+fn foo() {\n+    let c = Counter(0);\n+    $0let n = c.0;$0\n+    let m = c.0;\n+}\"##,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+struct Counter(i32);\n+impl Copy for Counter {}\n+fn foo() {\n+    let c = Counter(0);\n+    fun_name(c);\n+    let m = c.0;\n+}\n+\n+fn $0fun_name(c: Counter) {\n+    let n = c.0;\n+}\"##,\n+        );\n+    }\n+\n     #[test]\n     fn indented_stmts() {\n         check_assist(\n@@ -2134,4 +2602,441 @@ mod bar {\n }\",\n         );\n     }\n+\n+    #[test]\n+    fn break_loop() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+enum Option<T> {\n+    #[lang = \"None\"] None,\n+    #[lang = \"Some\"] Some(T),\n+}\n+use Option::*;\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let m = n + 1;\n+        break;\n+        let k = 2;$0\n+        let h = 1 + k;\n+    }\n+}\"##,\n+            r##\"\n+enum Option<T> {\n+    #[lang = \"None\"] None,\n+    #[lang = \"Some\"] Some(T),\n+}\n+use Option::*;\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let k = match fun_name(n) {\n+            Some(value) => value,\n+            None => break,\n+        };\n+        let h = 1 + k;\n+    }\n+}\n+\n+fn $0fun_name(n: i32) -> Option<i32> {\n+    let m = n + 1;\n+    return None;\n+    let k = 2;\n+    Some(k)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_to_parent() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+impl Copy for i32 {}\n+enum Result<T, E> {\n+    #[lang = \"Ok\"] Ok(T),\n+    #[lang = \"Err\"] Err(E),\n+}\n+use Result::*;\n+fn foo() -> i64 {\n+    let n = 1;\n+    $0let m = n + 1;\n+    return 1;\n+    let k = 2;$0\n+    (n + k) as i64\n+}\"##,\n+            r##\"\n+#[lang = \"copy\"]\n+pub trait Copy {}\n+impl Copy for i32 {}\n+enum Result<T, E> {\n+    #[lang = \"Ok\"] Ok(T),\n+    #[lang = \"Err\"] Err(E),\n+}\n+use Result::*;\n+fn foo() -> i64 {\n+    let n = 1;\n+    let k = match fun_name(n) {\n+        Ok(value) => value,\n+        Err(value) => return value,\n+    };\n+    (n + k) as i64\n+}\n+\n+fn $0fun_name(n: i32) -> Result<i32, i64> {\n+    let m = n + 1;\n+    return Err(1);\n+    let k = 2;\n+    Ok(k)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_and_continue() {\n+        mark::check!(external_control_flow_break_and_continue);\n+        check_assist_not_applicable(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let m = n + 1;\n+        break;\n+        let k = 2;\n+        continue;\n+        let k = k + 1;$0\n+        let r = n + k;\n+    }\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_and_break() {\n+        mark::check!(external_control_flow_return_and_bc);\n+        check_assist_not_applicable(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let m = n + 1;\n+        break;\n+        let k = 2;\n+        return;\n+        let k = k + 1;$0\n+        let r = n + k;\n+    }\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_loop_with_if() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let mut n = 1;\n+        $0let m = n + 1;\n+        break;\n+        n += m;$0\n+        let h = 1 + n;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let mut n = 1;\n+        if fun_name(&mut n) {\n+            break;\n+        }\n+        let h = 1 + n;\n+    }\n+}\n+\n+fn $0fun_name(n: &mut i32) -> bool {\n+    let m = *n + 1;\n+    return true;\n+    *n += m;\n+    false\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_loop_nested() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let mut n = 1;\n+        $0let m = n + 1;\n+        if m == 42 {\n+            break;\n+        }$0\n+        let h = 1;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let mut n = 1;\n+        if fun_name(n) {\n+            break;\n+        }\n+        let h = 1;\n+    }\n+}\n+\n+fn $0fun_name(n: i32) -> bool {\n+    let m = n + 1;\n+    if m == 42 {\n+        return true;\n+    }\n+    false\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_from_nested_loop() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0\n+        let k = 1;\n+        loop {\n+            return;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let m = match fun_name() {\n+            Some(value) => value,\n+            None => return,\n+        };\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = 1;\n+    loop {\n+        return None;\n+    }\n+    let m = k + 1;\n+    Some(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_from_nested_loop() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let k = 1;\n+        loop {\n+            break;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let m = fun_name();\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    let k = 1;\n+    loop {\n+        break;\n+    }\n+    let m = k + 1;\n+    m\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_from_nested_and_outer_loops() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let k = 1;\n+        loop {\n+            break;\n+        }\n+        if k == 42 {\n+            break;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let m = match fun_name() {\n+            Some(value) => value,\n+            None => break,\n+        };\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = 1;\n+    loop {\n+        break;\n+    }\n+    if k == 42 {\n+        return None;\n+    }\n+    let m = k + 1;\n+    Some(m)\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_from_nested_fn() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        $0let k = 1;\n+        fn test() {\n+            return;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() {\n+    loop {\n+        let n = 1;\n+        let m = fun_name();\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> i32 {\n+    let k = 1;\n+    fn test() {\n+        return;\n+    }\n+    let m = k + 1;\n+    m\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_with_value() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() -> i32 {\n+    loop {\n+        let n = 1;\n+        $0let k = 1;\n+        if k == 42 {\n+            break 3;\n+        }\n+        let m = k + 1;$0\n+        let h = 1;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() -> i32 {\n+    loop {\n+        let n = 1;\n+        if let Some(value) = fun_name() {\n+            break value;\n+        }\n+        let h = 1;\n+    }\n+}\n+\n+fn $0fun_name() -> Option<i32> {\n+    let k = 1;\n+    if k == 42 {\n+        return Some(3);\n+    }\n+    let m = k + 1;\n+    None\n+}\"##,\n+        );\n+    }\n+\n+    #[test]\n+    fn break_with_value_and_return() {\n+        check_assist(\n+            extract_function,\n+            r##\"\n+fn foo() -> i64 {\n+    loop {\n+        let n = 1;\n+        $0\n+        let k = 1;\n+        if k == 42 {\n+            break 3;\n+        }\n+        let m = k + 1;$0\n+        let h = 1 + m;\n+    }\n+}\"##,\n+            r##\"\n+fn foo() -> i64 {\n+    loop {\n+        let n = 1;\n+        let m = match fun_name() {\n+            Ok(value) => value,\n+            Err(value) => break value,\n+        };\n+        let h = 1 + m;\n+    }\n+}\n+\n+fn $0fun_name() -> Result<i32, i64> {\n+    let k = 1;\n+    if k == 42 {\n+        return Err(3);\n+    }\n+    let m = k + 1;\n+    Ok(m)\n+}\"##,\n+        );\n+    }\n }"}, {"sha": "95982498122d7fd5ba38665565c41b43e3ece1bf", "filename": "crates/assists/src/handlers/generate_function.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=f345d1772ab3827fbc3e31428b0d9479cab0ea39", "patch": "@@ -215,8 +215,11 @@ fn fn_args(\n         });\n     }\n     deduplicate_arg_names(&mut arg_names);\n-    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| make::param(name, ty));\n-    Some((None, make::param_list(params)))\n+    let params = arg_names\n+        .into_iter()\n+        .zip(arg_types)\n+        .map(|(name, ty)| make::param(make::ident_pat(make::name(&name)).into(), make::ty(&ty)));\n+    Some((None, make::param_list(None, params)))\n }\n \n /// Makes duplicate argument names unique by appending incrementing numbers."}, {"sha": "720f561a1724ff753d656337c186917a3852cdb2", "filename": "crates/assists/src/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fassists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fassists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests.rs?ref=f345d1772ab3827fbc3e31428b0d9479cab0ea39", "patch": "@@ -195,6 +195,7 @@ fn assist_order_if_expr() {\n     let assists = Assist::get(&db, &TEST_CONFIG, false, frange);\n     let mut assists = assists.iter();\n \n+    assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into function\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into variable\");\n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Replace with match\");\n }\n@@ -220,6 +221,7 @@ fn assist_filter_works() {\n         let assists = Assist::get(&db, &cfg, false, frange);\n         let mut assists = assists.iter();\n \n+        assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into function\");\n         assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into variable\");\n         assert_eq!(assists.next().expect(\"expected assist\").label, \"Replace with match\");\n     }\n@@ -228,9 +230,10 @@ fn assist_filter_works() {\n         let mut cfg = TEST_CONFIG;\n         cfg.allowed = Some(vec![AssistKind::RefactorExtract]);\n         let assists = Assist::get(&db, &cfg, false, frange);\n-        assert_eq!(assists.len(), 1);\n+        assert_eq!(assists.len(), 2);\n \n         let mut assists = assists.iter();\n+        assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into function\");\n         assert_eq!(assists.next().expect(\"expected assist\").label, \"Extract into variable\");\n     }\n "}, {"sha": "5f6b96c231376db16c4087e3409225d941e74eec", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f345d1772ab3827fbc3e31428b0d9479cab0ea39/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=f345d1772ab3827fbc3e31428b0d9479cab0ea39", "patch": "@@ -24,11 +24,24 @@ pub fn name_ref(text: &str) -> ast::NameRef {\n // FIXME: replace stringly-typed constructor with a family of typed ctors, a-la\n // `expr_xxx`.\n pub fn ty(text: &str) -> ast::Type {\n-    ast_from_text(&format!(\"impl {} for D {{}};\", text))\n+    ast_from_text(&format!(\"fn f() -> {} {{}}\", text))\n }\n pub fn ty_unit() -> ast::Type {\n     ty(\"()\")\n }\n+// FIXME: handle types of length == 1\n+pub fn ty_tuple(types: impl IntoIterator<Item = ast::Type>) -> ast::Type {\n+    let contents = types.into_iter().join(\", \");\n+    ty(&format!(\"({})\", contents))\n+}\n+// FIXME: handle path to type\n+pub fn ty_generic(name: ast::NameRef, types: impl IntoIterator<Item = ast::Type>) -> ast::Type {\n+    let contents = types.into_iter().join(\", \");\n+    ty(&format!(\"{}<{}>\", name, contents))\n+}\n+pub fn ty_ref(target: ast::Type, exclusive: bool) -> ast::Type {\n+    ty(&if exclusive { format!(\"&mut {}\", target) } else { format!(\"&{}\", target) })\n+}\n \n pub fn assoc_item_list() -> ast::AssocItemList {\n     ast_from_text(\"impl C for D {};\")\n@@ -175,11 +188,17 @@ pub fn expr_path(path: ast::Path) -> ast::Expr {\n pub fn expr_continue() -> ast::Expr {\n     expr_from_text(\"continue\")\n }\n-pub fn expr_break() -> ast::Expr {\n-    expr_from_text(\"break\")\n+pub fn expr_break(expr: Option<ast::Expr>) -> ast::Expr {\n+    match expr {\n+        Some(expr) => expr_from_text(&format!(\"break {}\", expr)),\n+        None => expr_from_text(\"break\"),\n+    }\n }\n-pub fn expr_return() -> ast::Expr {\n-    expr_from_text(\"return\")\n+pub fn expr_return(expr: Option<ast::Expr>) -> ast::Expr {\n+    match expr {\n+        Some(expr) => expr_from_text(&format!(\"return {}\", expr)),\n+        None => expr_from_text(\"return\"),\n+    }\n }\n pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Expr {\n     expr_from_text(&format!(\"match {} {}\", expr, match_arm_list))\n@@ -212,6 +231,10 @@ pub fn expr_ref(expr: ast::Expr, exclusive: bool) -> ast::Expr {\n pub fn expr_paren(expr: ast::Expr) -> ast::Expr {\n     expr_from_text(&format!(\"({})\", expr))\n }\n+pub fn expr_tuple(elements: impl IntoIterator<Item = ast::Expr>) -> ast::Expr {\n+    let expr = elements.into_iter().format(\", \");\n+    expr_from_text(&format!(\"({})\", expr))\n+}\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n@@ -236,6 +259,13 @@ pub fn ident_pat(name: ast::Name) -> ast::IdentPat {\n         ast_from_text(&format!(\"fn f({}: ())\", text))\n     }\n }\n+pub fn ident_mut_pat(name: ast::Name) -> ast::IdentPat {\n+    return from_text(name.text());\n+\n+    fn from_text(text: &str) -> ast::IdentPat {\n+        ast_from_text(&format!(\"fn f(mut {}: ())\", text))\n+    }\n+}\n \n pub fn wildcard_pat() -> ast::WildcardPat {\n     return from_text(\"_\");\n@@ -356,17 +386,25 @@ pub fn token(kind: SyntaxKind) -> SyntaxToken {\n         .unwrap_or_else(|| panic!(\"unhandled token: {:?}\", kind))\n }\n \n-pub fn param(name: String, ty: String) -> ast::Param {\n-    ast_from_text(&format!(\"fn f({}: {}) {{ }}\", name, ty))\n+pub fn param(pat: ast::Pat, ty: ast::Type) -> ast::Param {\n+    ast_from_text(&format!(\"fn f({}: {}) {{ }}\", pat, ty))\n }\n \n pub fn ret_type(ty: ast::Type) -> ast::RetType {\n     ast_from_text(&format!(\"fn f() -> {} {{ }}\", ty))\n }\n \n-pub fn param_list(pats: impl IntoIterator<Item = ast::Param>) -> ast::ParamList {\n+pub fn param_list(\n+    self_param: Option<ast::SelfParam>,\n+    pats: impl IntoIterator<Item = ast::Param>,\n+) -> ast::ParamList {\n     let args = pats.into_iter().join(\", \");\n-    ast_from_text(&format!(\"fn f({}) {{ }}\", args))\n+    let list = match self_param {\n+        Some(self_param) if args.is_empty() => format!(\"fn f({}) {{ }}\", self_param),\n+        Some(self_param) => format!(\"fn f({}, {}) {{ }}\", self_param, args),\n+        None => format!(\"fn f({}) {{ }}\", args),\n+    };\n+    ast_from_text(&list)\n }\n \n pub fn generic_param(name: String, ty: Option<ast::TypeBoundList>) -> ast::GenericParam {"}]}