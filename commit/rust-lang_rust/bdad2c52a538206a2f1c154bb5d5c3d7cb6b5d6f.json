{"sha": "bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYWQyYzUyYTUzODIwNmEyZjFjMTU0YmI1ZDVjM2Q3Y2I2YjVkNmY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-09-13T16:25:05Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-09-13T16:25:05Z"}, "message": "codegen: use \"_N\" (like for other locals) instead of \"argN\", for argument names.", "tree": {"sha": "38ed9501903fd53708147ed2ccfaa5be18285b1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38ed9501903fd53708147ed2ccfaa5be18285b1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "html_url": "https://github.com/rust-lang/rust/commit/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9214a147b09f8020f82b450e7c9e16290649909", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9214a147b09f8020f82b450e7c9e16290649909", "html_url": "https://github.com/rust-lang/rust/commit/e9214a147b09f8020f82b450e7c9e16290649909"}], "stats": {"total": 111, "additions": 56, "deletions": 55}, "files": [{"sha": "aa3971a1da81aa0f14c5df0e1c4395d73c4eeeed", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "patch": "@@ -453,10 +453,11 @@ fn arg_local_refs<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     mir.args_iter().enumerate().map(|(arg_index, local)| {\n         let arg_decl = &mir.local_decls[local];\n \n+        // FIXME(eddyb) don't allocate a `String` unless it gets used.\n         let name = if let Some(name) = arg_decl.name {\n             name.as_str().to_string()\n         } else {\n-            format!(\"arg{}\", arg_index)\n+            format!(\"{:?}\", local)\n         };\n \n         if Some(local) == mir.spread_arg {"}, {"sha": "ded310d0aebb13543cbc9e1da126c3aed7324a67", "filename": "src/test/codegen/adjustments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Fadjustments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Fadjustments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fadjustments.rs?ref=bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "patch": "@@ -3,7 +3,7 @@\n #![crate_type = \"lib\"]\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }"}, {"sha": "f67487c83ba23d2dc83b8ac5b7c90b552e0545e9", "filename": "src/test/codegen/fastcall-inreg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffastcall-inreg.rs?ref=bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "patch": "@@ -49,27 +49,27 @@\n #![crate_type = \"lib\"]\n \n pub mod tests {\n-    // CHECK: @f1(i32 inreg %arg0, i32 inreg %arg1, i32 %arg2)\n+    // CHECK: @f1(i32 inreg %_1, i32 inreg %_2, i32 %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f1(_: i32, _: i32, _: i32) {}\n \n-    // CHECK: @f2(i32* inreg %arg0, i32* inreg %arg1, i32* %arg2)\n+    // CHECK: @f2(i32* inreg %_1, i32* inreg %_2, i32* %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f2(_: *const i32, _: *const i32, _: *const i32) {}\n \n-    // CHECK: @f3(float %arg0, i32 inreg %arg1, i32 inreg %arg2, i32 %arg3)\n+    // CHECK: @f3(float %_1, i32 inreg %_2, i32 inreg %_3, i32 %_4)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f3(_: f32, _: i32, _: i32, _: i32) {}\n \n-    // CHECK: @f4(i32 inreg %arg0, float %arg1, i32 inreg %arg2, i32 %arg3)\n+    // CHECK: @f4(i32 inreg %_1, float %_2, i32 inreg %_3, i32 %_4)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f4(_: i32, _: f32, _: i32, _: i32) {}\n \n-    // CHECK: @f5(i64 %arg0, i32 %arg1)\n+    // CHECK: @f5(i64 %_1, i32 %_2)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f5(_: i64, _: i32) {}\n \n-    // CHECK: @f6(i1 inreg zeroext %arg0, i32 inreg %arg1, i32 %arg2)\n+    // CHECK: @f6(i1 inreg zeroext %_1, i32 inreg %_2, i32 %_3)\n     #[no_mangle]\n     pub extern \"fastcall\" fn f6(_: bool, _: i32, _: i32) {}\n }"}, {"sha": "7e1791cd4f296f5c3ace1b66e5736c6ceaa5f9d4", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "patch": "@@ -18,48 +18,48 @@ pub fn boolean(x: bool) -> bool {\n   x\n }\n \n-// CHECK: @readonly_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n+// CHECK: @readonly_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn readonly_borrow(_: &i32) {\n }\n \n-// CHECK: @static_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n+// CHECK: @static_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n // static borrow may be captured\n #[no_mangle]\n pub fn static_borrow(_: &'static i32) {\n }\n \n-// CHECK: @named_borrow(i32* noalias readonly align 4 dereferenceable(4) %arg0)\n+// CHECK: @named_borrow(i32* noalias readonly align 4 dereferenceable(4) %_1)\n // borrow with named lifetime may be captured\n #[no_mangle]\n pub fn named_borrow<'r>(_: &'r i32) {\n }\n \n-// CHECK: @unsafe_borrow(i16* align 2 dereferenceable(2) %arg0)\n+// CHECK: @unsafe_borrow(i16* align 2 dereferenceable(2) %_1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_borrow(_: &UnsafeInner) {\n }\n \n-// CHECK: @mutable_unsafe_borrow(i16* align 2 dereferenceable(2) %arg0)\n+// CHECK: @mutable_unsafe_borrow(i16* align 2 dereferenceable(2) %_1)\n // ... unless this is a mutable borrow, those never alias\n #[no_mangle]\n pub fn mutable_unsafe_borrow(_: &mut UnsafeInner) {\n }\n \n-// CHECK: @mutable_borrow(i32* align 4 dereferenceable(4) %arg0)\n+// CHECK: @mutable_borrow(i32* align 4 dereferenceable(4) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_borrow(_: &mut i32) {\n }\n \n-// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32) %arg0)\n+// CHECK: @indirect_struct(%S* noalias nocapture dereferenceable(32) %_1)\n #[no_mangle]\n pub fn indirect_struct(_: S) {\n }\n \n-// CHECK: @borrowed_struct(%S* noalias readonly align 4 dereferenceable(32) %arg0)\n+// CHECK: @borrowed_struct(%S* noalias readonly align 4 dereferenceable(32) %_1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn borrowed_struct(_: &S) {\n@@ -80,36 +80,36 @@ pub fn struct_return() -> S {\n }\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }\n \n-// CHECK: @slice([0 x i8]* noalias nonnull readonly align 1 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @slice([0 x i8]* noalias nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn slice(_: &[u8]) {\n }\n \n-// CHECK: @mutable_slice([0 x i8]* nonnull align 1 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @mutable_slice([0 x i8]* nonnull align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn mutable_slice(_: &mut [u8]) {\n }\n \n-// CHECK: @unsafe_slice([0 x i16]* nonnull align 2 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @unsafe_slice([0 x i16]* nonnull align 2 %_1.0, [[USIZE]] %_1.1)\n // unsafe interior means this isn't actually readonly and there may be aliases ...\n #[no_mangle]\n pub fn unsafe_slice(_: &[UnsafeInner]) {\n }\n \n-// CHECK: @str([0 x i8]* noalias nonnull readonly align 1 %arg0.0, [[USIZE]] %arg0.1)\n+// CHECK: @str([0 x i8]* noalias nonnull readonly align 1 %_1.0, [[USIZE]] %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow({}* nonnull align 1 %arg0.0, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}) %arg0.1)\n+// CHECK: @trait_borrow({}* nonnull align 1 %_1.0, [3 x [[USIZE]]]* noalias readonly align {{.*}} dereferenceable({{.*}}) %_1.1)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n pub fn trait_borrow(_: &Drop) {"}, {"sha": "15f99fd0c22a023094251b5f4511dfb0fb07d149", "filename": "src/test/codegen/refs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Frefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Frefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frefs.rs?ref=bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "patch": "@@ -3,7 +3,7 @@\n #![crate_type = \"lib\"]\n \n // Hack to get the correct size for the length part in slices\n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }"}, {"sha": "87f29f6047c6a0af8932ad2887a7d343268fa007", "filename": "src/test/codegen/repeat-trusted-len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepeat-trusted-len.rs?ref=bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "patch": "@@ -6,7 +6,7 @@\n \n use std::iter;\n \n-// CHECK: @helper([[USIZE:i[0-9]+]] %arg0)\n+// CHECK: @helper([[USIZE:i[0-9]+]] %_1)\n #[no_mangle]\n pub fn helper(_: usize) {\n }"}, {"sha": "e705d5ce3cd72d87acb2e385ba44f9beb3ffe048", "filename": "src/test/codegen/repr-transparent.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent.rs?ref=bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "patch": "@@ -14,36 +14,36 @@ pub struct Zst2(());\n #[repr(transparent)]\n pub struct F32(f32);\n \n-// CHECK: define float @test_F32(float %arg0)\n+// CHECK: define float @test_F32(float %_1)\n #[no_mangle]\n pub extern fn test_F32(_: F32) -> F32 { loop {} }\n \n #[repr(transparent)]\n pub struct Ptr(*mut u8);\n \n-// CHECK: define i8* @test_Ptr(i8* %arg0)\n+// CHECK: define i8* @test_Ptr(i8* %_1)\n #[no_mangle]\n pub extern fn test_Ptr(_: Ptr) -> Ptr { loop {} }\n \n #[repr(transparent)]\n pub struct WithZst(u64, Zst1);\n \n-// CHECK: define i64 @test_WithZst(i64 %arg0)\n+// CHECK: define i64 @test_WithZst(i64 %_1)\n #[no_mangle]\n pub extern fn test_WithZst(_: WithZst) -> WithZst { loop {} }\n \n #[repr(transparent)]\n pub struct WithZeroSizedArray(*const f32, [i8; 0]);\n \n // Apparently we use i32* when newtype-unwrapping f32 pointers. Whatever.\n-// CHECK: define i32* @test_WithZeroSizedArray(i32* %arg0)\n+// CHECK: define i32* @test_WithZeroSizedArray(i32* %_1)\n #[no_mangle]\n pub extern fn test_WithZeroSizedArray(_: WithZeroSizedArray) -> WithZeroSizedArray { loop {} }\n \n #[repr(transparent)]\n pub struct Generic<T>(T);\n \n-// CHECK: define double @test_Generic(double %arg0)\n+// CHECK: define double @test_Generic(double %_1)\n #[no_mangle]\n pub extern fn test_Generic(_: Generic<f64>) -> Generic<f64> { loop {} }\n \n@@ -53,14 +53,14 @@ pub struct GenericPlusZst<T>(T, Zst2);\n #[repr(u8)]\n pub enum Bool { True, False, FileNotFound }\n \n-// CHECK: define{{( zeroext)?}} i8 @test_Gpz(i8{{( zeroext)?}} %arg0)\n+// CHECK: define{{( zeroext)?}} i8 @test_Gpz(i8{{( zeroext)?}} %_1)\n #[no_mangle]\n pub extern fn test_Gpz(_: GenericPlusZst<Bool>) -> GenericPlusZst<Bool> { loop {} }\n \n #[repr(transparent)]\n pub struct LifetimePhantom<'a, T: 'a>(*const T, PhantomData<&'a T>);\n \n-// CHECK: define i16* @test_LifetimePhantom(i16* %arg0)\n+// CHECK: define i16* @test_LifetimePhantom(i16* %_1)\n #[no_mangle]\n pub extern fn test_LifetimePhantom(_: LifetimePhantom<i16>) -> LifetimePhantom<i16> { loop {} }\n \n@@ -70,28 +70,28 @@ pub struct UnitPhantom<T, U> { val: T, unit: PhantomData<U> }\n \n pub struct Px;\n \n-// CHECK: define float @test_UnitPhantom(float %arg0)\n+// CHECK: define float @test_UnitPhantom(float %_1)\n #[no_mangle]\n pub extern fn test_UnitPhantom(_: UnitPhantom<f32, Px>) -> UnitPhantom<f32, Px> { loop {} }\n \n #[repr(transparent)]\n pub struct TwoZsts(Zst1, i8, Zst2);\n \n-// CHECK: define{{( signext)?}} i8 @test_TwoZsts(i8{{( signext)?}} %arg0)\n+// CHECK: define{{( signext)?}} i8 @test_TwoZsts(i8{{( signext)?}} %_1)\n #[no_mangle]\n pub extern fn test_TwoZsts(_: TwoZsts) -> TwoZsts { loop {} }\n \n #[repr(transparent)]\n pub struct Nested1(Zst2, Generic<f64>);\n \n-// CHECK: define double @test_Nested1(double %arg0)\n+// CHECK: define double @test_Nested1(double %_1)\n #[no_mangle]\n pub extern fn test_Nested1(_: Nested1) -> Nested1 { loop {} }\n \n #[repr(transparent)]\n pub struct Nested2(Nested1, Zst1);\n \n-// CHECK: define double @test_Nested2(double %arg0)\n+// CHECK: define double @test_Nested2(double %_1)\n #[no_mangle]\n pub extern fn test_Nested2(_: Nested2) -> Nested2 { loop {} }\n \n@@ -101,7 +101,7 @@ struct f32x4(f32, f32, f32, f32);\n #[repr(transparent)]\n pub struct Vector(f32x4);\n \n-// CHECK: define <4 x float> @test_Vector(<4 x float> %arg0)\n+// CHECK: define <4 x float> @test_Vector(<4 x float> %_1)\n #[no_mangle]\n pub extern fn test_Vector(_: Vector) -> Vector { loop {} }\n \n@@ -111,7 +111,7 @@ impl<T: ?Sized> Mirror for T { type It = Self; }\n #[repr(transparent)]\n pub struct StructWithProjection(<f32 as Mirror>::It);\n \n-// CHECK: define float @test_Projection(float %arg0)\n+// CHECK: define float @test_Projection(float %_1)\n #[no_mangle]\n pub extern fn test_Projection(_: StructWithProjection) -> StructWithProjection { loop {} }\n \n@@ -120,7 +120,7 @@ pub enum EnumF32 {\n     Variant(F32)\n }\n \n-// CHECK: define float @test_EnumF32(float %arg0)\n+// CHECK: define float @test_EnumF32(float %_1)\n #[no_mangle]\n pub extern fn test_EnumF32(_: EnumF32) -> EnumF32 { loop {} }\n \n@@ -129,7 +129,7 @@ pub enum EnumF32WithZsts {\n     Variant(Zst1, F32, Zst2)\n }\n \n-// CHECK: define float @test_EnumF32WithZsts(float %arg0)\n+// CHECK: define float @test_EnumF32WithZsts(float %_1)\n #[no_mangle]\n pub extern fn test_EnumF32WithZsts(_: EnumF32WithZsts) -> EnumF32WithZsts { loop {} }\n \n@@ -138,7 +138,7 @@ pub union UnionF32 {\n     field: F32,\n }\n \n-// CHECK: define float @test_UnionF32(float %arg0)\n+// CHECK: define float @test_UnionF32(float %_1)\n #[no_mangle]\n pub extern fn test_UnionF32(_: UnionF32) -> UnionF32 { loop {} }\n \n@@ -149,7 +149,7 @@ pub union UnionF32WithZsts {\n     zst2: Zst2,\n }\n \n-// CHECK: define float @test_UnionF32WithZsts(float %arg0)\n+// CHECK: define float @test_UnionF32WithZsts(float %_1)\n #[no_mangle]\n pub extern fn test_UnionF32WithZsts(_: UnionF32WithZsts) -> UnionF32WithZsts { loop {} }\n "}, {"sha": "d91ee7f816dede3620fc035ff1d2bbbe9c56e2cd", "filename": "src/test/codegen/scalar-pair-bool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fscalar-pair-bool.rs?ref=bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "patch": "@@ -20,24 +20,24 @@ pub fn pair_i32_bool(pair: (i32, bool)) -> (i32, bool) {\n     pair\n }\n \n-// CHECK: define { i8, i8 } @pair_and_or(i1 zeroext %arg0.0, i1 zeroext %arg0.1)\n+// CHECK: define { i8, i8 } @pair_and_or(i1 zeroext %_1.0, i1 zeroext %_1.1)\n #[no_mangle]\n pub fn pair_and_or((a, b): (bool, bool)) -> (bool, bool) {\n     // Make sure it can operate directly on the unpacked args\n-    // CHECK: and i1 %arg0.0, %arg0.1\n-    // CHECK: or i1 %arg0.0, %arg0.1\n+    // CHECK: and i1 %_1.0, %_1.1\n+    // CHECK: or i1 %_1.0, %_1.1\n     (a && b, a || b)\n }\n \n-// CHECK: define void @pair_branches(i1 zeroext %arg0.0, i1 zeroext %arg0.1)\n+// CHECK: define void @pair_branches(i1 zeroext %_1.0, i1 zeroext %_1.1)\n #[no_mangle]\n pub fn pair_branches((a, b): (bool, bool)) {\n     // Make sure it can branch directly on the unpacked bool args\n-    // CHECK: br i1 %arg0.0\n+    // CHECK: br i1 %_1.0\n     if a {\n         println!(\"Hello!\");\n     }\n-    // CHECK: br i1 %arg0.1\n+    // CHECK: br i1 %_1.1\n     if b {\n         println!(\"Goodbye!\");\n     }"}, {"sha": "7339df17b057a230004e2eb3fbc703fc534ce668", "filename": "src/test/codegen/union-abi.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=bdad2c52a538206a2f1c154bb5d5c3d7cb6b5d6f", "patch": "@@ -16,38 +16,38 @@ pub struct i64x4(i64, i64, i64, i64);\n #[derive(Copy, Clone)]\n pub union UnionI64x4{ a:(), b: i64x4 }\n \n-// CHECK: define void @test_UnionI64x4(<4 x i64>* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4(<4 x i64>* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4(_: UnionI64x4) { loop {} }\n \n pub union UnionI64x4_{ a: i64x4, b: (), c:i64x4, d: Unhab, e: ((),()), f: UnionI64x4 }\n \n-// CHECK: define void @test_UnionI64x4_(<4 x i64>* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4_(<4 x i64>* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4_(_: UnionI64x4_) { loop {} }\n \n pub union UnionI64x4I64{ a: i64x4, b: i64 }\n \n-// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4I64(_: UnionI64x4I64) { loop {} }\n \n pub union UnionI64x4Tuple{ a: i64x4, b: (i64, i64, i64, i64) }\n \n-// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %arg0)\n+// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %_1)\n #[no_mangle]\n pub fn test_UnionI64x4Tuple(_: UnionI64x4Tuple) { loop {} }\n \n \n pub union UnionF32{a:f32}\n \n-// CHECK: define float @test_UnionF32(float %arg0)\n+// CHECK: define float @test_UnionF32(float %_1)\n #[no_mangle]\n pub fn test_UnionF32(_: UnionF32) -> UnionF32 { loop {} }\n \n pub union UnionF32F32{a:f32, b:f32}\n \n-// CHECK: define float @test_UnionF32F32(float %arg0)\n+// CHECK: define float @test_UnionF32F32(float %_1)\n #[no_mangle]\n pub fn test_UnionF32F32(_: UnionF32F32) -> UnionF32F32 { loop {} }\n \n@@ -58,13 +58,13 @@ pub union UnionF32U32{a:f32, b:u32}\n pub fn test_UnionF32U32(_: UnionF32U32) -> UnionF32U32 { loop {} }\n \n pub union UnionU128{a:u128}\n-// CHECK: define i128 @test_UnionU128(i128 %arg0)\n+// CHECK: define i128 @test_UnionU128(i128 %_1)\n #[no_mangle]\n pub fn test_UnionU128(_: UnionU128) -> UnionU128 { loop {} }\n \n #[repr(C)]\n pub union CUnionU128{a:u128}\n-// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %arg0)\n+// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %_1)\n #[no_mangle]\n pub fn test_CUnionU128(_: CUnionU128) { loop {} }\n "}]}