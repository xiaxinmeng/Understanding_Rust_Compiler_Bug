{"sha": "6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "node_id": "C_kwDOAAsO6NoAKDZmNjgxYThlYjNmYmRmMzcwNzVhZTVmOTIxNTE4ZjVmNGI5MzA2YTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-26T14:23:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-26T14:23:27Z"}, "message": "Auto merge of #94376 - c410-f3r:more-let-chains, r=petrochenkov\n\nInitiate the inner usage of `let_chains`\n\nThe intention here is create a strong and robust foundation for a possible future stabilization so please, do not let the lack of any external tool support prevent the merge of this PR. Besides, `let_chains` is useful by itself.\n\ncc #53667", "tree": {"sha": "742e6835fc49b4c3634336dd5ffcb723b93ed5d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/742e6835fc49b4c3634336dd5ffcb723b93ed5d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "html_url": "https://github.com/rust-lang/rust/commit/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c9640e34c73dc45bfd38eca49fa1405b11b6cae", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c9640e34c73dc45bfd38eca49fa1405b11b6cae", "html_url": "https://github.com/rust-lang/rust/commit/8c9640e34c73dc45bfd38eca49fa1405b11b6cae"}, {"sha": "f2e5e454993b5ba16ca3f87a2838859fdfff0736", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e5e454993b5ba16ca3f87a2838859fdfff0736", "html_url": "https://github.com/rust-lang/rust/commit/f2e5e454993b5ba16ca3f87a2838859fdfff0736"}], "stats": {"total": 189, "additions": 88, "deletions": 101}, "files": [{"sha": "d0ffb17f25670584869224af1d91e04235b355ba", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "patch": "@@ -3855,7 +3855,6 @@ dependencies = [\n name = \"rustc_lint\"\n version = \"0.0.0\"\n dependencies = [\n- \"if_chain\",\n  \"rustc_ast\",\n  \"rustc_ast_pretty\",\n  \"rustc_attr\","}, {"sha": "8ea47dda928f5f0cc8af8c4ab83299c95ee021e1", "filename": "compiler/rustc_lint/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6/compiler%2Frustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6/compiler%2Frustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2FCargo.toml?ref=6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "patch": "@@ -4,7 +4,6 @@ version = \"0.0.0\"\n edition = \"2021\"\n \n [dependencies]\n-if_chain = \"1.0\"\n tracing = \"0.1\"\n unicode-security = \"0.0.5\"\n rustc_middle = { path = \"../rustc_middle\" }"}, {"sha": "72e1671449f1ce4223363b6e8f404c96bdccee79", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "patch": "@@ -25,20 +25,21 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n+#![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(if_let_guard)]\n #![feature(iter_intersperse)]\n #![feature(iter_order_by)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![feature(control_flow_enum)]\n #![recursion_limit = \"256\"]\n-#![allow(rustc::potential_query_instability)]\n \n #[macro_use]\n extern crate rustc_middle;"}, {"sha": "c0bf64387ff376ab77bad579e4802c70bcc7779e", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 85, "deletions": 97, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f681a8eb3fbdf37075ae5f921518f5f4b9306a6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=6f681a8eb3fbdf37075ae5f921518f5f4b9306a6", "patch": "@@ -16,7 +16,6 @@ use rustc_target::abi::Abi;\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n \n-use if_chain::if_chain;\n use std::cmp;\n use std::iter;\n use std::ops::ControlFlow;\n@@ -1456,21 +1455,18 @@ impl InvalidAtomicOrdering {\n             sym::AtomicI64,\n             sym::AtomicI128,\n         ];\n-        if_chain! {\n-            if let ExprKind::MethodCall(ref method_path, args, _) = &expr.kind;\n-            if recognized_names.contains(&method_path.ident.name);\n-            if let Some(m_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if let Some(impl_did) = cx.tcx.impl_of_method(m_def_id);\n-            if let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def();\n+        if let ExprKind::MethodCall(ref method_path, args, _) = &expr.kind\n+            && recognized_names.contains(&method_path.ident.name)\n+            && let Some(m_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id)\n+            && let Some(impl_did) = cx.tcx.impl_of_method(m_def_id)\n+            && let Some(adt) = cx.tcx.type_of(impl_did).ty_adt_def()\n             // skip extension traits, only lint functions from the standard library\n-            if cx.tcx.trait_id_of_impl(impl_did).is_none();\n-\n-            if let Some(parent) = cx.tcx.parent(adt.did);\n-            if cx.tcx.is_diagnostic_item(sym::atomic_mod, parent);\n-            if ATOMIC_TYPES.contains(&cx.tcx.item_name(adt.did));\n-            then {\n-                return Some((method_path.ident.name, args));\n-            }\n+            && cx.tcx.trait_id_of_impl(impl_did).is_none()\n+            && let Some(parent) = cx.tcx.parent(adt.did)\n+            && cx.tcx.is_diagnostic_item(sym::atomic_mod, parent)\n+            && ATOMIC_TYPES.contains(&cx.tcx.item_name(adt.did))\n+        {\n+            return Some((method_path.ident.name, args));\n         }\n         None\n     }\n@@ -1499,111 +1495,103 @@ impl InvalidAtomicOrdering {\n     fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         use rustc_hir::def::{DefKind, Res};\n         use rustc_hir::QPath;\n-        if_chain! {\n-            if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store]);\n-            if let Some((ordering_arg, invalid_ordering)) = match method {\n+        if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store])\n+            && let Some((ordering_arg, invalid_ordering)) = match method {\n                 sym::load => Some((&args[1], sym::Release)),\n                 sym::store => Some((&args[2], sym::Acquire)),\n                 _ => None,\n-            };\n-\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = ordering_arg.kind;\n-            if let Res::Def(DefKind::Ctor(..), ctor_id) = path.res;\n-            if Self::matches_ordering(cx, ctor_id, &[invalid_ordering, sym::AcqRel]);\n-            then {\n-                cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, |diag| {\n-                    if method == sym::load {\n-                        diag.build(\"atomic loads cannot have `Release` or `AcqRel` ordering\")\n-                            .help(\"consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\")\n-                            .emit()\n-                    } else {\n-                        debug_assert_eq!(method, sym::store);\n-                        diag.build(\"atomic stores cannot have `Acquire` or `AcqRel` ordering\")\n-                            .help(\"consider using ordering modes `Release`, `SeqCst` or `Relaxed`\")\n-                            .emit();\n-                    }\n-                });\n             }\n+            && let ExprKind::Path(QPath::Resolved(_, path)) = ordering_arg.kind\n+            && let Res::Def(DefKind::Ctor(..), ctor_id) = path.res\n+            && Self::matches_ordering(cx, ctor_id, &[invalid_ordering, sym::AcqRel])\n+        {\n+            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, |diag| {\n+                if method == sym::load {\n+                    diag.build(\"atomic loads cannot have `Release` or `AcqRel` ordering\")\n+                        .help(\"consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\")\n+                        .emit()\n+                } else {\n+                    debug_assert_eq!(method, sym::store);\n+                    diag.build(\"atomic stores cannot have `Acquire` or `AcqRel` ordering\")\n+                        .help(\"consider using ordering modes `Release`, `SeqCst` or `Relaxed`\")\n+                        .emit();\n+                }\n+            });\n         }\n     }\n \n     fn check_memory_fence(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if_chain! {\n-            if let ExprKind::Call(ref func, ref args) = expr.kind;\n-            if let ExprKind::Path(ref func_qpath) = func.kind;\n-            if let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id();\n-            if matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence));\n-            if let ExprKind::Path(ref ordering_qpath) = &args[0].kind;\n-            if let Some(ordering_def_id) = cx.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id();\n-            if Self::matches_ordering(cx, ordering_def_id, &[sym::Relaxed]);\n-            then {\n-                cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, |diag| {\n-                    diag.build(\"memory fences cannot have `Relaxed` ordering\")\n-                        .help(\"consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\")\n-                        .emit();\n-                });\n-            }\n+        if let ExprKind::Call(ref func, ref args) = expr.kind\n+            && let ExprKind::Path(ref func_qpath) = func.kind\n+            && let Some(def_id) = cx.qpath_res(func_qpath, func.hir_id).opt_def_id()\n+            && matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence))\n+            && let ExprKind::Path(ref ordering_qpath) = &args[0].kind\n+            && let Some(ordering_def_id) = cx.qpath_res(ordering_qpath, args[0].hir_id).opt_def_id()\n+            && Self::matches_ordering(cx, ordering_def_id, &[sym::Relaxed])\n+        {\n+            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, |diag| {\n+                diag.build(\"memory fences cannot have `Relaxed` ordering\")\n+                    .help(\"consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\")\n+                    .emit();\n+            });\n         }\n     }\n \n     fn check_atomic_compare_exchange(cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if_chain! {\n-            if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::fetch_update, sym::compare_exchange, sym::compare_exchange_weak]);\n-            if let Some((success_order_arg, failure_order_arg)) = match method {\n+        if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::fetch_update, sym::compare_exchange, sym::compare_exchange_weak])\n+            && let Some((success_order_arg, failure_order_arg)) = match method {\n                 sym::fetch_update => Some((&args[1], &args[2])),\n                 sym::compare_exchange | sym::compare_exchange_weak => Some((&args[3], &args[4])),\n                 _ => None,\n-            };\n-\n-            if let Some(fail_ordering_def_id) = Self::opt_ordering_defid(cx, failure_order_arg);\n-            then {\n-                // Helper type holding on to some checking and error reporting data. Has\n-                // - (success ordering,\n-                // - list of failure orderings forbidden by the success order,\n-                // - suggestion message)\n-                type OrdLintInfo = (Symbol, &'static [Symbol], &'static str);\n-                const RELAXED: OrdLintInfo = (sym::Relaxed, &[sym::SeqCst, sym::Acquire], \"ordering mode `Relaxed`\");\n-                const ACQUIRE: OrdLintInfo = (sym::Acquire, &[sym::SeqCst], \"ordering modes `Acquire` or `Relaxed`\");\n-                const SEQ_CST: OrdLintInfo = (sym::SeqCst, &[], \"ordering modes `Acquire`, `SeqCst` or `Relaxed`\");\n-                const RELEASE: OrdLintInfo = (sym::Release, RELAXED.1, RELAXED.2);\n-                const ACQREL: OrdLintInfo = (sym::AcqRel, ACQUIRE.1, ACQUIRE.2);\n-                const SEARCH: [OrdLintInfo; 5] = [RELAXED, ACQUIRE, SEQ_CST, RELEASE, ACQREL];\n-\n-                let success_lint_info = Self::opt_ordering_defid(cx, success_order_arg)\n-                    .and_then(|success_ord_def_id| -> Option<OrdLintInfo> {\n-                        SEARCH\n-                            .iter()\n-                            .copied()\n-                            .find(|(ordering, ..)| {\n-                                Self::matches_ordering(cx, success_ord_def_id, &[*ordering])\n-                            })\n-                    });\n-                if Self::matches_ordering(cx, fail_ordering_def_id, &[sym::Release, sym::AcqRel]) {\n-                    // If we don't know the success order is, use what we'd suggest\n-                    // if it were maximally permissive.\n-                    let suggested = success_lint_info.unwrap_or(SEQ_CST).2;\n+            }\n+            && let Some(fail_ordering_def_id) = Self::opt_ordering_defid(cx, failure_order_arg)\n+        {\n+            // Helper type holding on to some checking and error reporting data. Has\n+            // - (success ordering,\n+            // - list of failure orderings forbidden by the success order,\n+            // - suggestion message)\n+            type OrdLintInfo = (Symbol, &'static [Symbol], &'static str);\n+            const RELAXED: OrdLintInfo = (sym::Relaxed, &[sym::SeqCst, sym::Acquire], \"ordering mode `Relaxed`\");\n+            const ACQUIRE: OrdLintInfo = (sym::Acquire, &[sym::SeqCst], \"ordering modes `Acquire` or `Relaxed`\");\n+            const SEQ_CST: OrdLintInfo = (sym::SeqCst, &[], \"ordering modes `Acquire`, `SeqCst` or `Relaxed`\");\n+            const RELEASE: OrdLintInfo = (sym::Release, RELAXED.1, RELAXED.2);\n+            const ACQREL: OrdLintInfo = (sym::AcqRel, ACQUIRE.1, ACQUIRE.2);\n+            const SEARCH: [OrdLintInfo; 5] = [RELAXED, ACQUIRE, SEQ_CST, RELEASE, ACQREL];\n+\n+            let success_lint_info = Self::opt_ordering_defid(cx, success_order_arg)\n+                .and_then(|success_ord_def_id| -> Option<OrdLintInfo> {\n+                    SEARCH\n+                        .iter()\n+                        .copied()\n+                        .find(|(ordering, ..)| {\n+                            Self::matches_ordering(cx, success_ord_def_id, &[*ordering])\n+                        })\n+                });\n+            if Self::matches_ordering(cx, fail_ordering_def_id, &[sym::Release, sym::AcqRel]) {\n+                // If we don't know the success order is, use what we'd suggest\n+                // if it were maximally permissive.\n+                let suggested = success_lint_info.unwrap_or(SEQ_CST).2;\n+                cx.struct_span_lint(INVALID_ATOMIC_ORDERING, failure_order_arg.span, |diag| {\n+                    let msg = format!(\n+                        \"{}'s failure ordering may not be `Release` or `AcqRel`\",\n+                        method,\n+                    );\n+                    diag.build(&msg)\n+                        .help(&format!(\"consider using {} instead\", suggested))\n+                        .emit();\n+                });\n+            } else if let Some((success_ord, bad_ords_given_success, suggested)) = success_lint_info {\n+                if Self::matches_ordering(cx, fail_ordering_def_id, bad_ords_given_success) {\n                     cx.struct_span_lint(INVALID_ATOMIC_ORDERING, failure_order_arg.span, |diag| {\n                         let msg = format!(\n-                            \"{}'s failure ordering may not be `Release` or `AcqRel`\",\n+                            \"{}'s failure ordering may not be stronger than the success ordering of `{}`\",\n                             method,\n+                            success_ord,\n                         );\n                         diag.build(&msg)\n                             .help(&format!(\"consider using {} instead\", suggested))\n                             .emit();\n                     });\n-                } else if let Some((success_ord, bad_ords_given_success, suggested)) = success_lint_info {\n-                    if Self::matches_ordering(cx, fail_ordering_def_id, bad_ords_given_success) {\n-                        cx.struct_span_lint(INVALID_ATOMIC_ORDERING, failure_order_arg.span, |diag| {\n-                            let msg = format!(\n-                                \"{}'s failure ordering may not be stronger than the success ordering of `{}`\",\n-                                method,\n-                                success_ord,\n-                            );\n-                            diag.build(&msg)\n-                                .help(&format!(\"consider using {} instead\", suggested))\n-                                .emit();\n-                        });\n-                    }\n                 }\n             }\n         }"}]}