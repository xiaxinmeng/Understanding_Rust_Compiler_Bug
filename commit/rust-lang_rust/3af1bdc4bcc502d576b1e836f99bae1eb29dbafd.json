{"sha": "3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZjFiZGM0YmNjNTAyZDU3NmIxZTgzNmY5OWJhZTFlYjI5ZGJhZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-03T15:10:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-03T15:10:16Z"}, "message": "Auto merge of #60510 - Centril:rollup-gsndjbp, r=Centril\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #59928 (Make deprecation lint `ambiguous_associated_items` deny-by-default)\n - #60220 (report fatal errors during doctest parsing)\n - #60373 (Tidy: ensure lang features are sorted by since)\n - #60388 (Disallow non-explicit elided lifetimes in async fn)\n - #60393 ( Do not suggest incorrect syntax on pattern type error due to borrow)\n - #60401 (Rename `RUST_LOG` to `RUSTC_LOG`)\n - #60409 (Require a trait in the bounds of existential types)\n - #60455 (Resolve match arm ty when arms diverge)\n - #60457 (Const prop refactoring)\n - #60467 (Avoid repeated interning of static strings.)\n - #60478 (minor compiler doc tweaks)\n - #60501 (Propagate mutability from arguments to local bindings in async fn)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "928e4e1504008643140afc74d2c998e62e0947e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/928e4e1504008643140afc74d2c998e62e0947e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "html_url": "https://github.com/rust-lang/rust/commit/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef9a876f8297e26859469b004047e0946ed10565", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef9a876f8297e26859469b004047e0946ed10565", "html_url": "https://github.com/rust-lang/rust/commit/ef9a876f8297e26859469b004047e0946ed10565"}, {"sha": "6f7a1eabdf2770d1a83ad6f1968162f64b36a13d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f7a1eabdf2770d1a83ad6f1968162f64b36a13d", "html_url": "https://github.com/rust-lang/rust/commit/6f7a1eabdf2770d1a83ad6f1968162f64b36a13d"}], "stats": {"total": 1188, "additions": 891, "deletions": 297}, "files": [{"sha": "3d7f00e6410b5f3392db26779224d8e088b81aa9", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -3556,6 +3556,7 @@ dependencies = [\n name = \"tidy\"\n version = \"0.1.0\"\n dependencies = [\n+ \"regex 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.82 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.81 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.33 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "285f9458c44b6a6f3cd8fe26dbacf5b3e0f3f98b", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -436,7 +436,7 @@ fn configure_cmake(builder: &Builder<'_>,\n     }\n \n     if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n-        cfg.env(\"RUST_LOG\", \"sccache=warn\");\n+        cfg.env(\"RUSTC_LOG\", \"sccache=warn\");\n     }\n }\n "}, {"sha": "fd089fc688e32d5db01a66650e90a1dfe0a6bbce", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -362,10 +362,6 @@ struct Foo1 { x: &bool }\n               // ^ expected lifetime parameter\n struct Foo2<'a> { x: &'a bool } // correct\n \n-impl Foo2 {}\n-  // ^^^^ expected lifetime parameter\n-impl<'a> Foo2<'a> {} // correct\n-\n struct Bar1 { x: Foo2 }\n               // ^^^^ expected lifetime parameter\n struct Bar2<'a> { x: Foo2<'a> } // correct\n@@ -2208,4 +2204,5 @@ register_diagnostics! {\n     E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes\n //  E0702, // replaced with a generic attribute input check\n+    E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n }"}, {"sha": "ad26e05bf80d0b005be6de40a927643549dd7f4a", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 52, "deletions": 16, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -2110,15 +2110,49 @@ impl<'a> LoweringContext<'a> {\n                         .expect(\"already checked that type args or bindings exist\");\n                     (false, first_generic_span.shrink_to_lo(), format!(\"{}, \", anon_lt_suggestion))\n                 };\n-                self.sess.buffer_lint_with_diagnostic(\n-                    ELIDED_LIFETIMES_IN_PATHS,\n-                    CRATE_NODE_ID,\n-                    path_span,\n-                    \"hidden lifetime parameters in types are deprecated\",\n-                    builtin::BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n-                        expected_lifetimes, path_span, incl_angl_brckt, insertion_span, suggestion\n-                    )\n-                );\n+                match self.anonymous_lifetime_mode {\n+                    // In create-parameter mode we error here because we don't want to support\n+                    // deprecated impl elision in new features like impl elision and `async fn`,\n+                    // both of which work using the `CreateParameter` mode:\n+                    //\n+                    //     impl Foo for std::cell::Ref<u32> // note lack of '_\n+                    //     async fn foo(_: std::cell::Ref<u32>) { ... }\n+                    AnonymousLifetimeMode::CreateParameter => {\n+                        let mut err = struct_span_err!(\n+                            self.sess,\n+                            path_span,\n+                            E0726,\n+                            \"implicit elided lifetime not allowed here\"\n+                        );\n+                        crate::lint::builtin::add_elided_lifetime_in_path_suggestion(\n+                            &self.sess,\n+                            &mut err,\n+                            expected_lifetimes,\n+                            path_span,\n+                            incl_angl_brckt,\n+                            insertion_span,\n+                            suggestion,\n+                        );\n+                        err.emit();\n+                    }\n+                    AnonymousLifetimeMode::PassThrough |\n+                    AnonymousLifetimeMode::ReportError |\n+                    AnonymousLifetimeMode::Replace(_) => {\n+                        self.sess.buffer_lint_with_diagnostic(\n+                            ELIDED_LIFETIMES_IN_PATHS,\n+                            CRATE_NODE_ID,\n+                            path_span,\n+                            \"hidden lifetime parameters in types are deprecated\",\n+                            builtin::BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n+                                expected_lifetimes,\n+                                path_span,\n+                                incl_angl_brckt,\n+                                insertion_span,\n+                                suggestion,\n+                            )\n+                        );\n+                    }\n+                }\n             }\n         }\n \n@@ -5335,13 +5369,15 @@ impl<'a> LoweringContext<'a> {\n \n     fn elided_path_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         match self.anonymous_lifetime_mode {\n-            // N.B., We intentionally ignore the create-parameter mode here\n-            // and instead \"pass through\" to resolve-lifetimes, which will then\n-            // report an error. This is because we don't want to support\n-            // impl elision for deprecated forms like\n-            //\n-            //     impl Foo for std::cell::Ref<u32> // note lack of '_\n-            AnonymousLifetimeMode::CreateParameter |\n+            AnonymousLifetimeMode::CreateParameter => {\n+                // We should have emitted E0726 when processing this path above\n+                self.sess.delay_span_bug(\n+                    span,\n+                    \"expected 'implicit elided lifetime not allowed' error\",\n+                );\n+                let id = self.sess.next_node_id();\n+                self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n+            }\n             // This is the normal case.\n             AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n "}, {"sha": "4293019aed56893a08ffe669ffcbacfe408dd49f", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1927,6 +1927,9 @@ pub enum ArgSource {\n /// Represents the header (not the body) of a function declaration.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnDecl {\n+    /// The types of the function's arguments.\n+    ///\n+    /// Additional argument data is stored in the function's [body](Body::arguments).\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n     pub c_variadic: bool,"}, {"sha": "95b566d4a1b6933736e3c4fc12756e5f7bd7974f", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -644,7 +644,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         for sp in prior_arms {\n                             err.span_label(*sp, format!(\n                                 \"this is found to be of type `{}`\",\n-                                last_ty,\n+                                self.resolve_type_vars_if_possible(&last_ty),\n                             ));\n                         }\n                     } else if let Some(sp) = prior_arms.last() {"}, {"sha": "a8f39e441309afb06fdd3c8239ebfb7175a29325", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -704,7 +704,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// potentially leaving \"dangling type variables\" behind.\n     /// In such cases, an assertion will fail when attempting to\n     /// register obligations, within a snapshot. Very useful, much\n-    /// better than grovelling through megabytes of `RUST_LOG` output.\n+    /// better than grovelling through megabytes of `RUSTC_LOG` output.\n     ///\n     /// HOWEVER, in some cases the flag is unhelpful. In particular, we\n     /// sometimes create a \"mini-fulfilment-cx\" in which we enroll"}, {"sha": "993e1aacb4e4d29386b1001bedd86fa2bdcf566a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 51, "deletions": 31, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -376,7 +376,7 @@ declare_lint! {\n \n declare_lint! {\n     pub AMBIGUOUS_ASSOCIATED_ITEMS,\n-    Warn,\n+    Deny,\n     \"ambiguous associated items\"\n }\n \n@@ -477,6 +477,48 @@ pub enum BuiltinLintDiagnostics {\n     RedundantImport(Vec<(Span, bool)>, ast::Ident),\n }\n \n+pub(crate) fn add_elided_lifetime_in_path_suggestion(\n+    sess: &Session,\n+    db: &mut DiagnosticBuilder<'_>,\n+    n: usize,\n+    path_span: Span,\n+    incl_angl_brckt: bool,\n+    insertion_span: Span,\n+    anon_lts: String,\n+) {\n+    let (replace_span, suggestion) = if incl_angl_brckt {\n+        (insertion_span, anon_lts)\n+    } else {\n+        // When possible, prefer a suggestion that replaces the whole\n+        // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n+        // at a point (which makes for an ugly/confusing label)\n+        if let Ok(snippet) = sess.source_map().span_to_snippet(path_span) {\n+            // But our spans can get out of whack due to macros; if the place we think\n+            // we want to insert `'_` isn't even within the path expression's span, we\n+            // should bail out of making any suggestion rather than panicking on a\n+            // subtract-with-overflow or string-slice-out-out-bounds (!)\n+            // FIXME: can we do better?\n+            if insertion_span.lo().0 < path_span.lo().0 {\n+                return;\n+            }\n+            let insertion_index = (insertion_span.lo().0 - path_span.lo().0) as usize;\n+            if insertion_index > snippet.len() {\n+                return;\n+            }\n+            let (before, after) = snippet.split_at(insertion_index);\n+            (path_span, format!(\"{}{}{}\", before, anon_lts, after))\n+        } else {\n+            (insertion_span, anon_lts)\n+        }\n+    };\n+    db.span_suggestion(\n+        replace_span,\n+        &format!(\"indicate the anonymous lifetime{}\", if n >= 2 { \"s\" } else { \"\" }),\n+        suggestion,\n+        Applicability::MachineApplicable\n+    );\n+}\n+\n impl BuiltinLintDiagnostics {\n     pub fn run(self, sess: &Session, db: &mut DiagnosticBuilder<'_>) {\n         match self {\n@@ -521,36 +563,14 @@ impl BuiltinLintDiagnostics {\n             BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n                 n, path_span, incl_angl_brckt, insertion_span, anon_lts\n             ) => {\n-                let (replace_span, suggestion) = if incl_angl_brckt {\n-                    (insertion_span, anon_lts)\n-                } else {\n-                    // When possible, prefer a suggestion that replaces the whole\n-                    // `Path<T>` expression with `Path<'_, T>`, rather than inserting `'_, `\n-                    // at a point (which makes for an ugly/confusing label)\n-                    if let Ok(snippet) = sess.source_map().span_to_snippet(path_span) {\n-                        // But our spans can get out of whack due to macros; if the place we think\n-                        // we want to insert `'_` isn't even within the path expression's span, we\n-                        // should bail out of making any suggestion rather than panicking on a\n-                        // subtract-with-overflow or string-slice-out-out-bounds (!)\n-                        // FIXME: can we do better?\n-                        if insertion_span.lo().0 < path_span.lo().0 {\n-                            return;\n-                        }\n-                        let insertion_index = (insertion_span.lo().0 - path_span.lo().0) as usize;\n-                        if insertion_index > snippet.len() {\n-                            return;\n-                        }\n-                        let (before, after) = snippet.split_at(insertion_index);\n-                        (path_span, format!(\"{}{}{}\", before, anon_lts, after))\n-                    } else {\n-                        (insertion_span, anon_lts)\n-                    }\n-                };\n-                db.span_suggestion(\n-                    replace_span,\n-                    &format!(\"indicate the anonymous lifetime{}\", if n >= 2 { \"s\" } else { \"\" }),\n-                    suggestion,\n-                    Applicability::MachineApplicable\n+                add_elided_lifetime_in_path_suggestion(\n+                    sess,\n+                    db,\n+                    n,\n+                    path_span,\n+                    incl_angl_brckt,\n+                    insertion_span,\n+                    anon_lts,\n                 );\n             }\n             BuiltinLintDiagnostics::UnknownCrateTypes(span, note, sugg) => {"}, {"sha": "e713cf8d805531669f4d6a4759d046986e0240f2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -757,12 +757,12 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     /// Check if a `DefId`'s path matches the given absolute type path usage.\n     ///\n     /// # Examples\n-    /// ```rust,ignore (no `cx` or `def_id` available)\n+    ///\n+    /// ```rust,ignore (no context or def id available)\n     /// if cx.match_def_path(def_id, &[\"core\", \"option\", \"Option\"]) {\n     ///     // The given `def_id` is that of an `Option` type\n     /// }\n     /// ```\n-    // Uplifted from rust-lang/rust-clippy\n     pub fn match_def_path(&self, def_id: DefId, path: &[&str]) -> bool {\n         let names = self.get_def_path(def_id);\n \n@@ -772,13 +772,13 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     /// Gets the absolute path of `def_id` as a vector of `&str`.\n     ///\n     /// # Examples\n-    /// ```rust,ignore (no `cx` or `def_id` available)\n+    ///\n+    /// ```rust,ignore (no context or def id available)\n     /// let def_path = cx.get_def_path(def_id);\n     /// if let &[\"core\", \"option\", \"Option\"] = &def_path[..] {\n     ///     // The given `def_id` is that of an `Option` type\n     /// }\n     /// ```\n-    // Uplifted from rust-lang/rust-clippy\n     pub fn get_def_path(&self, def_id: DefId) -> Vec<LocalInternedString> {\n         pub struct AbsolutePathPrinter<'a, 'tcx> {\n             pub tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "0d67865d7170849e8c2c22cbc44fa1cd9afd0378", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -784,26 +784,30 @@ pub fn file_metadata(cx: &CodegenCx<'ll, '_>,\n            file_name,\n            defining_crate);\n \n-    let directory = if defining_crate == LOCAL_CRATE {\n-        &cx.sess().working_dir.0\n+    let file_name = &file_name.to_string();\n+    let file_name_symbol = Symbol::intern(file_name);\n+    if defining_crate == LOCAL_CRATE {\n+        let directory = &cx.sess().working_dir.0.to_string_lossy();\n+        file_metadata_raw(cx, file_name, Some(file_name_symbol),\n+                          directory, Some(Symbol::intern(directory)))\n     } else {\n         // If the path comes from an upstream crate we assume it has been made\n         // independent of the compiler's working directory one way or another.\n-        Path::new(\"\")\n-    };\n-\n-    file_metadata_raw(cx, &file_name.to_string(), &directory.to_string_lossy())\n+        file_metadata_raw(cx, file_name, Some(file_name_symbol), \"\", None)\n+    }\n }\n \n pub fn unknown_file_metadata(cx: &CodegenCx<'ll, '_>) -> &'ll DIFile {\n-    file_metadata_raw(cx, \"<unknown>\", \"\")\n+    file_metadata_raw(cx, \"<unknown>\", None, \"\", None)\n }\n \n fn file_metadata_raw(cx: &CodegenCx<'ll, '_>,\n                      file_name: &str,\n-                     directory: &str)\n+                     file_name_symbol: Option<Symbol>,\n+                     directory: &str,\n+                     directory_symbol: Option<Symbol>)\n                      -> &'ll DIFile {\n-    let key = (Symbol::intern(file_name), Symbol::intern(directory));\n+    let key = (file_name_symbol, directory_symbol);\n \n     if let Some(file_metadata) = debug_context(cx).created_files.borrow().get(&key) {\n         return *file_metadata;"}, {"sha": "f3070a03b4ed523520abd34f1de0a648300edbfd", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -63,7 +63,7 @@ pub struct CrateDebugContext<'a, 'tcx> {\n     llcontext: &'a llvm::Context,\n     llmod: &'a llvm::Module,\n     builder: &'a mut DIBuilder<'a>,\n-    created_files: RefCell<FxHashMap<(Symbol, Symbol), &'a DIFile>>,\n+    created_files: RefCell<FxHashMap<(Option<Symbol>, Option<Symbol>), &'a DIFile>>,\n     created_enum_disr_types: RefCell<FxHashMap<(DefId, layout::Primitive), &'a DIType>>,\n \n     type_map: RefCell<TypeMap<'a, 'tcx>>,"}, {"sha": "5b42b049b5b189862f57adf3e262e2597487e2d3", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1163,7 +1163,7 @@ pub fn report_ices_to_stderr_if_any<F: FnOnce() -> R, R>(f: F) -> Result<R, Erro\n /// This allows tools to enable rust logging without having to magically match rustc's\n /// log crate version\n pub fn init_rustc_env_logger() {\n-    env_logger::init();\n+    env_logger::init_from_env(\"RUSTC_LOG\");\n }\n \n pub fn main() {"}, {"sha": "2d89f73a95f6913c7dc588445d15aeaf6c867337", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 71, "deletions": 53, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,18 +1,19 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-\n use rustc::hir::def::Def;\n-use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local};\n-use rustc::mir::{NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind};\n-use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n+use rustc::mir::{\n+    Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local,\n+    NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind,\n+    TerminatorKind, Terminator,  ClearCrossCrate, SourceInfo, BinOp, ProjectionElem,\n+    SourceScope, SourceScopeLocalData, LocalDecl, Promoted,\n+};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::interpret::{InterpError, Scalar, GlobalId, EvalResult};\n-use rustc::ty::{self, Instance, Ty, TyCtxt};\n-use syntax::source_map::{Span, DUMMY_SP};\n+use rustc::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n+use syntax::source_map::DUMMY_SP;\n use rustc::ty::subst::InternalSubsts;\n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc::ty::ParamEnv;\n use rustc::ty::layout::{\n     LayoutOf, TyLayout, LayoutError,\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n@@ -62,21 +63,33 @@ impl MirPass for ConstProp {\n         let mut optimization_finder = ConstPropagator::new(mir, tcx, source);\n         optimization_finder.visit_mir(mir);\n \n+        // put back the data we stole from `mir`\n+        std::mem::replace(\n+            &mut mir.source_scope_local_data,\n+            optimization_finder.source_scope_local_data\n+        );\n+        std::mem::replace(\n+            &mut mir.promoted,\n+            optimization_finder.promoted\n+        );\n+\n         trace!(\"ConstProp done for {:?}\", source.def_id());\n     }\n }\n \n-type Const<'tcx> = (OpTy<'tcx>, Span);\n+type Const<'tcx> = OpTy<'tcx>;\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n     ecx: InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n-    mir: &'mir Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: MirSource<'tcx>,\n     places: IndexVec<Local, Option<Const<'tcx>>>,\n     can_const_prop: IndexVec<Local, bool>,\n     param_env: ParamEnv<'tcx>,\n+    source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n+    local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    promoted: IndexVec<Promoted, Mir<'tcx>>,\n }\n \n impl<'a, 'b, 'tcx> LayoutOf for ConstPropagator<'a, 'b, 'tcx> {\n@@ -104,20 +117,33 @@ impl<'a, 'b, 'tcx> HasTyCtxt<'tcx> for ConstPropagator<'a, 'b, 'tcx> {\n \n impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     fn new(\n-        mir: &'mir Mir<'tcx>,\n+        mir: &mut Mir<'tcx>,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         source: MirSource<'tcx>,\n     ) -> ConstPropagator<'a, 'mir, 'tcx> {\n         let param_env = tcx.param_env(source.def_id());\n         let ecx = mk_eval_cx(tcx, tcx.def_span(source.def_id()), param_env);\n+        let can_const_prop = CanConstProp::check(mir);\n+        let source_scope_local_data = std::mem::replace(\n+            &mut mir.source_scope_local_data,\n+            ClearCrossCrate::Clear\n+        );\n+        let promoted = std::mem::replace(\n+            &mut mir.promoted,\n+            IndexVec::new()\n+        );\n+\n         ConstPropagator {\n             ecx,\n-            mir,\n             tcx,\n             source,\n             param_env,\n-            can_const_prop: CanConstProp::check(mir),\n+            can_const_prop,\n             places: IndexVec::from_elem(None, &mir.local_decls),\n+            source_scope_local_data,\n+            //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_mir()` needs it\n+            local_decls: mir.local_decls.clone(),\n+            promoted,\n         }\n     }\n \n@@ -130,7 +156,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         F: FnOnce(&mut Self) -> EvalResult<'tcx, T>,\n     {\n         self.ecx.tcx.span = source_info.span;\n-        let lint_root = match self.mir.source_scope_local_data {\n+        let lint_root = match self.source_scope_local_data {\n             ClearCrossCrate::Set(ref ivs) => {\n                 //FIXME(#51314): remove this check\n                 if source_info.scope.index() >= ivs.len() {\n@@ -252,12 +278,11 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     fn eval_constant(\n         &mut self,\n         c: &Constant<'tcx>,\n-        source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n-        self.ecx.tcx.span = source_info.span;\n+        self.ecx.tcx.span = c.span;\n         match self.ecx.eval_const_to_op(*c.literal, None) {\n             Ok(op) => {\n-                Some((op, c.span))\n+                Some(op)\n             },\n             Err(error) => {\n                 let err = error_to_const_error(&self.ecx, error);\n@@ -273,11 +298,11 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _) => {\n                     trace!(\"field proj on {:?}\", proj.base);\n-                    let (base, span) = self.eval_place(&proj.base, source_info)?;\n+                    let base = self.eval_place(&proj.base, source_info)?;\n                     let res = self.use_ecx(source_info, |this| {\n                         this.ecx.operand_field(base, field.index() as u64)\n                     })?;\n-                    Some((res, span))\n+                    Some(res)\n                 },\n                 // We could get more projections by using e.g., `operand_projection`,\n                 // but we do not even have the stack frame set up properly so\n@@ -301,19 +326,19 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now\n                 let res = self.use_ecx(source_info, |this| {\n-                    let mir = &this.mir.promoted[promoted];\n+                    let mir = &this.promoted[promoted];\n                     eval_promoted(this.tcx, cid, mir, this.param_env)\n                 })?;\n                 trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n-                Some((res.into(), source_info.span))\n+                Some(res.into())\n             },\n             _ => None,\n         }\n     }\n \n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         match *op {\n-            Operand::Constant(ref c) => self.eval_constant(c, source_info),\n+            Operand::Constant(ref c) => self.eval_constant(c),\n             | Operand::Move(ref place)\n             | Operand::Copy(ref place) => self.eval_place(place, source_info),\n         }\n@@ -337,18 +362,18 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Rvalue::Discriminant(..) => None,\n \n             Rvalue::Cast(kind, ref operand, _) => {\n-                let (op, span) = self.eval_operand(operand, source_info)?;\n+                let op = self.eval_operand(operand, source_info)?;\n                 self.use_ecx(source_info, |this| {\n                     let dest = this.ecx.allocate(place_layout, MemoryKind::Stack);\n                     this.ecx.cast(op, kind, dest.into())?;\n-                    Ok((dest.into(), span))\n+                    Ok(dest.into())\n                 })\n             }\n \n             // FIXME(oli-obk): evaluate static/constant slice lengths\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n-                type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n+                type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some(\n                     ImmTy {\n                         imm: Immediate::Scalar(\n                             Scalar::Bits {\n@@ -357,9 +382,8 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                             }.into()\n                         ),\n                         layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n-                    }.into(),\n-                    span,\n-                )))\n+                    }.into()\n+                ))\n             }\n             Rvalue::UnaryOp(op, ref arg) => {\n                 let def_id = if self.tcx.is_closure(self.source.def_id()) {\n@@ -373,7 +397,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     return None;\n                 }\n \n-                let (arg, _) = self.eval_operand(arg, source_info)?;\n+                let arg = self.eval_operand(arg, source_info)?;\n                 let val = self.use_ecx(source_info, |this| {\n                     let prim = this.ecx.read_immediate(arg)?;\n                     match op {\n@@ -395,7 +419,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     imm: Immediate::Scalar(val.into()),\n                     layout: place_layout,\n                 };\n-                Some((res.into(), span))\n+                Some(res.into())\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -413,20 +437,20 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 }\n \n                 let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_immediate(right.0)\n+                    this.ecx.read_immediate(right)\n                 })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n-                    let left_ty = left.ty(self.mir, self.tcx);\n+                    let left_ty = left.ty(&self.local_decls, self.tcx);\n                     let left_bits = self\n                         .tcx\n                         .layout_of(self.param_env.and(left_ty))\n                         .unwrap()\n                         .size\n                         .bits();\n-                    let right_size = right.0.layout.size;\n+                    let right_size = right.layout.size;\n                     let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n                     if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n-                        let source_scope_local_data = match self.mir.source_scope_local_data {\n+                        let source_scope_local_data = match self.source_scope_local_data {\n                             ClearCrossCrate::Set(ref data) => data,\n                             ClearCrossCrate::Clear => return None,\n                         };\n@@ -446,7 +470,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 }\n                 let left = self.eval_operand(left, source_info)?;\n                 let l = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_immediate(left.0)\n+                    this.ecx.read_immediate(left)\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n@@ -469,7 +493,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     imm: val,\n                     layout: place_layout,\n                 };\n-                Some((res.into(), span))\n+                Some(res.into())\n             },\n         }\n     }\n@@ -544,8 +568,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n     ) {\n         trace!(\"visit_constant: {:?}\", constant);\n         self.super_constant(constant, location);\n-        let source_info = *self.mir.source_info(location);\n-        self.eval_constant(constant, source_info);\n+        self.eval_constant(constant);\n     }\n \n     fn visit_statement(\n@@ -556,7 +579,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         trace!(\"visit_statement: {:?}\", statement);\n         if let StatementKind::Assign(ref place, ref rval) = statement.kind {\n             let place_ty: Ty<'tcx> = place\n-                .ty(&self.mir.local_decls, self.tcx)\n+                .ty(&self.local_decls, self.tcx)\n                 .ty;\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n@@ -574,18 +597,18 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         self.super_statement(statement, location);\n     }\n \n-    fn visit_terminator_kind(\n+    fn visit_terminator(\n         &mut self,\n-        kind: &TerminatorKind<'tcx>,\n+        terminator: &Terminator<'tcx>,\n         location: Location,\n     ) {\n-        self.super_terminator_kind(kind, location);\n-        let source_info = *self.mir.source_info(location);\n-        if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n-            if let Some(value) = self.eval_operand(cond, source_info) {\n+        self.super_terminator(terminator, location);\n+        let source_info = terminator.source_info;;\n+        if let TerminatorKind::Assert { expected, msg, cond, .. } = &terminator.kind {\n+            if let Some(value) = self.eval_operand(&cond, source_info) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n                 let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n-                if expected != self.ecx.read_scalar(value.0).unwrap() {\n+                if expected != self.ecx.read_scalar(value).unwrap() {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -600,12 +623,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                         },\n                         Operand::Constant(_) => {}\n                     }\n-                    let span = self.mir[location.block]\n-                        .terminator\n-                        .as_ref()\n-                        .unwrap()\n-                        .source_info\n-                        .span;\n+                    let span = terminator.source_info.span;\n                     let hir_id = self\n                         .tcx\n                         .hir()\n@@ -621,7 +639,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let len = self\n                                 .eval_operand(len, source_info)\n                                 .expect(\"len must be const\");\n-                            let len = match self.ecx.read_scalar(len.0) {\n+                            let len = match self.ecx.read_scalar(len) {\n                                 Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n@@ -630,7 +648,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let index = self\n                                 .eval_operand(index, source_info)\n                                 .expect(\"index must be const\");\n-                            let index = match self.ecx.read_scalar(index.0) {\n+                            let index = match self.ecx.read_scalar(index) {\n                                 Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,"}, {"sha": "1f5a6d79141256ae83388b58411d6454eb3e0d79", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -20,7 +20,7 @@ use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n use syntax_ext::proc_macro_decls::is_proc_macro_attr;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, MultiSpan};\n use errors::Applicability;\n use log::debug;\n \n@@ -679,6 +679,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                                                 \"unions cannot have zero fields\");\n                 }\n             }\n+            ItemKind::Existential(ref bounds, _) => {\n+                if !bounds.iter()\n+                          .any(|b| if let GenericBound::Trait(..) = *b { true } else { false }) {\n+                    let msp = MultiSpan::from_spans(bounds.iter()\n+                        .map(|bound| bound.span()).collect());\n+                    self.err_handler().span_err(msp, \"at least one trait must be specified\");\n+                }\n+            }\n             _ => {}\n         }\n "}, {"sha": "6cc7818d712f633799fd35e0ab354d16a34ed796", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,8 +1,8 @@\n use crate::check::{FnCtxt, Expectation, Diverges, Needs};\n use crate::check::coercion::CoerceMany;\n use crate::util::nodemap::FxHashMap;\n-use errors::Applicability;\n-use rustc::hir::{self, PatKind};\n+use errors::{Applicability, DiagnosticBuilder};\n+use rustc::hir::{self, PatKind, Pat};\n use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer;\n@@ -377,15 +377,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             // Look for a case like `fn foo(&foo: u32)` and suggest\n                             // `fn foo(foo: &u32)`\n                             if let Some(mut err) = err {\n-                                if let PatKind::Binding(..) = inner.node {\n-                                    if let Ok(snippet) = tcx.sess.source_map()\n-                                                                    .span_to_snippet(pat.span)\n-                                    {\n-                                        err.help(&format!(\"did you mean `{}: &{}`?\",\n-                                                            &snippet[1..],\n-                                                            expected));\n-                                    }\n-                                }\n+                                self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n                                 err.emit();\n                             }\n                             (rptr_ty, inner_ty)\n@@ -517,6 +509,49 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // subtyping.\n     }\n \n+    fn borrow_pat_suggestion(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        pat: &Pat,\n+        inner: &Pat,\n+        expected: Ty<'tcx>,\n+    ) {\n+        let tcx = self.tcx;\n+        if let PatKind::Binding(..) = inner.node {\n+            let parent_id = tcx.hir().get_parent_node_by_hir_id(pat.hir_id);\n+            let parent = tcx.hir().get_by_hir_id(parent_id);\n+            debug!(\"inner {:?} pat {:?} parent {:?}\", inner, pat, parent);\n+            match parent {\n+                hir::Node::Item(hir::Item { node: hir::ItemKind::Fn(..), .. }) |\n+                hir::Node::ForeignItem(hir::ForeignItem {\n+                    node: hir::ForeignItemKind::Fn(..), ..\n+                }) |\n+                hir::Node::TraitItem(hir::TraitItem { node: hir::TraitItemKind::Method(..), .. }) |\n+                hir::Node::ImplItem(hir::ImplItem { node: hir::ImplItemKind::Method(..), .. }) => {\n+                    // this pat is likely an argument\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n+                        // FIXME: turn into structured suggestion, will need a span that also\n+                        // includes the the arg's type.\n+                        err.help(&format!(\"did you mean `{}: &{}`?\", snippet, expected));\n+                    }\n+                }\n+                hir::Node::Expr(hir::Expr { node: hir::ExprKind::Match(..), .. }) |\n+                hir::Node::Pat(_) => {\n+                    // rely on match ergonomics or it might be nested `&&pat`\n+                    if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(inner.span) {\n+                        err.span_suggestion(\n+                            pat.span,\n+                            \"you can probably remove the explicit borrow\",\n+                            snippet,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+                _ => {} // don't provide suggestions in other cases #55175\n+            }\n+        }\n+    }\n+\n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n             if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {"}, {"sha": "5c0a4da1cd7ef05515e6e683d0ca6af068b8f90a", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -166,9 +166,18 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n             compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions,\n             maybe_sysroot: Option<PathBuf>, linker: Option<PathBuf>, edition: Edition,\n             persist_doctests: Option<PathBuf>) {\n-    // The test harness wants its own `main` and top-level functions, so\n-    // never wrap the test in `fn main() { ... }`.\n-    let (test, line_offset) = make_test(test, Some(cratename), as_test_harness, opts);\n+    let (test, line_offset) = match panic::catch_unwind(|| {\n+        make_test(test, Some(cratename), as_test_harness, opts)\n+    }) {\n+        Ok((test, line_offset)) => (test, line_offset),\n+        Err(cause) if cause.is::<errors::FatalErrorMarker>() => {\n+            // If the parser used by `make_test` panicked due to a fatal error, pass the test code\n+            // through unchanged. The error will be reported during compilation.\n+            (test.to_owned(), 0)\n+        },\n+        Err(cause) => panic::resume_unwind(cause),\n+    };\n+\n     // FIXME(#44940): if doctests ever support path remapping, then this filename\n     // needs to be the result of `SourceMap::span_to_unmapped_path`.\n     let path = match filename {\n@@ -337,7 +346,13 @@ fn run_test(test: &str, cratename: &str, filename: &FileName, line: usize,\n     }\n }\n \n-/// Makes the test file. Also returns the number of lines before the code begins\n+/// Transforms a test into code that can be compiled into a Rust binary, and returns the number of\n+/// lines before the test code begins.\n+///\n+/// # Panics\n+///\n+/// This function uses the compiler's parser internally. The parser will panic if it encounters a\n+/// fatal error while parsing the test.\n pub fn make_test(s: &str,\n                  cratename: Option<&str>,\n                  dont_insert_main: bool,"}, {"sha": "b3ef5f3064c167f1d658a0ebfe994d9f13241720", "filename": "src/libstd/sys/redox/ext/net.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fnet.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,4 +1,4 @@\n-#![stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#![stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n \n //! Unix-specific networking functionality\n \n@@ -27,7 +27,7 @@ use crate::sys::{cvt, fd::FileDesc, syscall};\n /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n /// ```\n #[derive(Clone)]\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n pub struct SocketAddr(());\n \n impl SocketAddr {\n@@ -55,7 +55,7 @@ impl SocketAddr {\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// assert_eq!(addr.as_pathname(), None);\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn as_pathname(&self) -> Option<&Path> {\n         None\n     }\n@@ -83,12 +83,12 @@ impl SocketAddr {\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// assert_eq!(addr.is_unnamed(), true);\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn is_unnamed(&self) -> bool {\n         false\n     }\n }\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl fmt::Debug for SocketAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"SocketAddr\")\n@@ -109,10 +109,10 @@ impl fmt::Debug for SocketAddr {\n /// stream.read_to_string(&mut response).unwrap();\n /// println!(\"{}\", response);\n /// ```\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n pub struct UnixStream(FileDesc);\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl fmt::Debug for UnixStream {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixStream\");\n@@ -143,7 +143,7 @@ impl UnixStream {\n     ///     }\n     /// };\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n         if let Some(s) = path.as_ref().to_str() {\n             cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CLOEXEC))\n@@ -174,7 +174,7 @@ impl UnixStream {\n     ///     }\n     /// };\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n         let server = cvt(syscall::open(\"chan:\", syscall::O_CREAT | syscall::O_CLOEXEC))\n             .map(FileDesc::new)?;\n@@ -198,7 +198,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixStream> {\n         self.0.duplicate().map(UnixStream)\n     }\n@@ -213,7 +213,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::local_addr unimplemented on redox\"))\n     }\n@@ -228,7 +228,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::peer_addr unimplemented on redox\"))\n     }\n@@ -267,7 +267,7 @@ impl UnixStream {\n     /// let err = result.unwrap_err();\n     /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn set_read_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::set_read_timeout unimplemented on redox\"))\n     }\n@@ -306,7 +306,7 @@ impl UnixStream {\n     /// let err = result.unwrap_err();\n     /// assert_eq!(err.kind(), io::ErrorKind::InvalidInput)\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn set_write_timeout(&self, _timeout: Option<Duration>) -> io::Result<()> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::set_write_timeout unimplemented on redox\"))\n     }\n@@ -323,7 +323,7 @@ impl UnixStream {\n     /// socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n     /// assert_eq!(socket.read_timeout().unwrap(), Some(Duration::new(1, 0)));\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::read_timeout unimplemented on redox\"))\n     }\n@@ -340,7 +340,7 @@ impl UnixStream {\n     /// socket.set_write_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set write timeout\");\n     /// assert_eq!(socket.write_timeout().unwrap(), Some(Duration::new(1, 0)));\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::write_timeout unimplemented on redox\"))\n     }\n@@ -355,7 +355,7 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n@@ -375,7 +375,7 @@ impl UnixStream {\n     ///\n     /// # Platform specific\n     /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)\n     }\n@@ -397,13 +397,13 @@ impl UnixStream {\n     /// let socket = UnixStream::connect(\"/tmp/sock\").unwrap();\n     /// socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn shutdown(&self, _how: Shutdown) -> io::Result<()> {\n         Err(Error::new(ErrorKind::Other, \"UnixStream::shutdown unimplemented on redox\"))\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl io::Read for UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         io::Read::read(&mut &*self, buf)\n@@ -415,7 +415,7 @@ impl io::Read for UnixStream {\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl<'a> io::Read for &'a UnixStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.0.read(buf)\n@@ -427,7 +427,7 @@ impl<'a> io::Read for &'a UnixStream {\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl io::Write for UnixStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         io::Write::write(&mut &*self, buf)\n@@ -438,7 +438,7 @@ impl io::Write for UnixStream {\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl<'a> io::Write for &'a UnixStream {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.0.write(buf)\n@@ -449,21 +449,21 @@ impl<'a> io::Write for &'a UnixStream {\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl AsRawFd for UnixStream {\n     fn as_raw_fd(&self) -> RawFd {\n         self.0.raw()\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl FromRawFd for UnixStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n         UnixStream(FileDesc::new(fd))\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl IntoRawFd for UnixStream {\n     fn into_raw_fd(self) -> RawFd {\n         self.0.into_raw()\n@@ -498,10 +498,10 @@ impl IntoRawFd for UnixStream {\n ///     }\n /// }\n /// ```\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n pub struct UnixListener(FileDesc);\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl fmt::Debug for UnixListener {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut builder = fmt.debug_struct(\"UnixListener\");\n@@ -529,7 +529,7 @@ impl UnixListener {\n     ///     }\n     /// };\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n         if let Some(s) = path.as_ref().to_str() {\n             cvt(syscall::open(format!(\"chan:{}\", s), syscall::O_CREAT | syscall::O_CLOEXEC))\n@@ -563,7 +563,7 @@ impl UnixListener {\n     ///     Err(e) => println!(\"accept function failed: {:?}\", e),\n     /// }\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n         self.0.duplicate_path(b\"listen\").map(|fd| (UnixStream(fd), SocketAddr(())))\n     }\n@@ -583,7 +583,7 @@ impl UnixListener {\n     ///\n     /// let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn try_clone(&self) -> io::Result<UnixListener> {\n         self.0.duplicate().map(UnixListener)\n     }\n@@ -599,7 +599,7 @@ impl UnixListener {\n     ///\n     /// let addr = listener.local_addr().expect(\"Couldn't get local address\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn local_addr(&self) -> io::Result<SocketAddr> {\n         Err(Error::new(ErrorKind::Other, \"UnixListener::local_addr unimplemented on redox\"))\n     }\n@@ -615,7 +615,7 @@ impl UnixListener {\n     ///\n     /// listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         self.0.set_nonblocking(nonblocking)\n     }\n@@ -636,7 +636,7 @@ impl UnixListener {\n     ///\n     /// # Platform specific\n     /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n         Ok(None)\n     }\n@@ -672,34 +672,34 @@ impl UnixListener {\n     ///     }\n     /// }\n     /// ```\n-    #[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+    #[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n     pub fn incoming<'a>(&'a self) -> Incoming<'a> {\n         Incoming { listener: self }\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl AsRawFd for UnixListener {\n     fn as_raw_fd(&self) -> RawFd {\n         self.0.raw()\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl FromRawFd for UnixListener {\n     unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n         UnixListener(FileDesc::new(fd))\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl IntoRawFd for UnixListener {\n     fn into_raw_fd(self) -> RawFd {\n         self.0.into_raw()\n     }\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl<'a> IntoIterator for &'a UnixListener {\n     type Item = io::Result<UnixStream>;\n     type IntoIter = Incoming<'a>;\n@@ -740,12 +740,12 @@ impl<'a> IntoIterator for &'a UnixListener {\n /// }\n /// ```\n #[derive(Debug)]\n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n pub struct Incoming<'a> {\n     listener: &'a UnixListener,\n }\n \n-#[stable(feature = \"unix_socket_redox\", since = \"1.29\")]\n+#[stable(feature = \"unix_socket_redox\", since = \"1.29.0\")]\n impl<'a> Iterator for Incoming<'a> {\n     type Item = io::Result<UnixStream>;\n "}, {"sha": "2a1f3c48014069191ac6461a8277b230f2c978cd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -109,15 +109,14 @@ macro_rules! declare_features {\n // stable (active).\n //\n // Note that the features should be grouped into internal/user-facing\n-// and then sorted by version inside those groups.\n-// FIXME(60361): Enforce ^-- with tidy.\n+// and then sorted by version inside those groups. This is inforced with tidy.\n //\n // N.B., `tools/tidy/src/features.rs` parses this information directly out of the\n // source, so take care when modifying it.\n \n declare_features! (\n     // -------------------------------------------------------------------------\n-    // Internal feature gates.\n+    // feature-group-start: internal feature gates\n     // -------------------------------------------------------------------------\n \n     // no tracking issue START\n@@ -211,12 +210,12 @@ declare_features! (\n \n     // no tracking issue END\n \n-    // Allows using the `may_dangle` attribute (RFC 1327).\n-    (active, dropck_eyepatch, \"1.10.0\", Some(34761), None),\n-\n     // Allows using `#[structural_match]` which indicates that a type is structurally matchable.\n     (active, structural_match, \"1.8.0\", Some(31434), None),\n \n+    // Allows using the `may_dangle` attribute (RFC 1327).\n+    (active, dropck_eyepatch, \"1.10.0\", Some(34761), None),\n+\n     // Allows using the `#![panic_runtime]` attribute.\n     (active, panic_runtime, \"1.10.0\", Some(32837), None),\n \n@@ -252,7 +251,11 @@ declare_features! (\n     (active, test_2018_feature, \"1.31.0\", Some(0), Some(Edition::Edition2018)),\n \n     // -------------------------------------------------------------------------\n-    // Actual feature gates (target features).\n+    // feature-group-end: internal feature gates\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: actual feature gates (target features)\n     // -------------------------------------------------------------------------\n \n     // FIXME: Document these and merge with the list below.\n@@ -275,7 +278,11 @@ declare_features! (\n     (active, f16c_target_feature, \"1.36.0\", Some(44839), None),\n \n     // -------------------------------------------------------------------------\n-    // Actual feature gates.\n+    // feature-group-end: actual feature gates (target features)\n+    // -------------------------------------------------------------------------\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-start: actual feature gates\n     // -------------------------------------------------------------------------\n \n     // Allows using `asm!` macro with which inline assembly can be embedded.\n@@ -340,9 +347,6 @@ declare_features! (\n     // Permits specifying whether a function should permit unwinding or abort on unwind.\n     (active, unwind_attributes, \"1.4.0\", Some(58760), None),\n \n-    // Allows using `#[naked]` on functions.\n-    (active, naked_functions, \"1.9.0\", Some(32408), None),\n-\n     // Allows `#[no_debug]`.\n     (active, no_debug, \"1.5.0\", Some(29721), None),\n \n@@ -358,6 +362,9 @@ declare_features! (\n     // Allows specialization of implementations (RFC 1210).\n     (active, specialization, \"1.7.0\", Some(31844), None),\n \n+    // Allows using `#[naked]` on functions.\n+    (active, naked_functions, \"1.9.0\", Some(32408), None),\n+\n     // Allows `cfg(target_has_atomic = \"...\")`.\n     (active, cfg_target_has_atomic, \"1.9.0\", Some(32976), None),\n \n@@ -545,6 +552,10 @@ declare_features! (\n \n     // Allows using C-variadics.\n     (active, c_variadic, \"1.34.0\", Some(44930), None),\n+\n+    // -------------------------------------------------------------------------\n+    // feature-group-end: actual feature gates\n+    // -------------------------------------------------------------------------\n );\n \n // Some features are known to be incomplete and using them is likely to have"}, {"sha": "c5173aa556953368f5eb47683bd4850cacc3dafd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -8725,9 +8725,9 @@ impl<'a> Parser<'a> {\n                 // Check if this is a ident pattern, if so, we can optimize and avoid adding a\n                 // `let <pat> = __argN;` statement, instead just adding a `let <pat> = <pat>;`\n                 // statement.\n-                let (ident, is_simple_pattern) = match input.pat.node {\n-                    PatKind::Ident(_, ident, _) => (ident, true),\n-                    _ => (ident, false),\n+                let (binding_mode, ident, is_simple_pattern) = match input.pat.node {\n+                    PatKind::Ident(binding_mode, ident, _) => (binding_mode, ident, true),\n+                    _ => (BindingMode::ByValue(Mutability::Immutable), ident, false),\n                 };\n \n                 // Construct an argument representing `__argN: <ty>` to replace the argument of the\n@@ -8755,9 +8755,7 @@ impl<'a> Parser<'a> {\n                 let move_local = Local {\n                     pat: P(Pat {\n                         id,\n-                        node: PatKind::Ident(\n-                            BindingMode::ByValue(Mutability::Immutable), ident, None,\n-                        ),\n+                        node: PatKind::Ident(binding_mode, ident, None),\n                         span,\n                     }),\n                     // We explicitly do not specify the type for this statement. When the user's"}, {"sha": "8be2e234fea1fcb0c2ad8dbe23a25ef9ddc9f12c", "filename": "src/test/run-make-fulldeps/libs-through-symlinks/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-make-fulldeps%2Flibs-through-symlinks%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-make-fulldeps%2Flibs-through-symlinks%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Flibs-through-symlinks%2FMakefile?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -8,4 +8,4 @@ all:\n \tmkdir -p $(TMPDIR)/outdir\n \t$(RUSTC) foo.rs -o $(TMPDIR)/outdir/$(NAME)\n \tln -nsf outdir/$(NAME) $(TMPDIR)\n-\tRUST_LOG=rustc_metadata::loader $(RUSTC) bar.rs\n+\tRUSTC_LOG=rustc_metadata::loader $(RUSTC) bar.rs"}, {"sha": "b36435cf113f1137d229592f187df537e258e2ba", "filename": "src/test/run-pass/existential_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Fexistential_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Fexistential_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexistential_type.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -68,14 +68,14 @@ fn my_other_iter<U>(u: U) -> MyOtherIter<U> {\n }\n \n trait Trait {}\n-existential type GenericBound<'a, T: Trait>: 'a;\n+existential type GenericBound<'a, T: Trait>: Sized + 'a;\n \n fn generic_bound<'a, T: Trait + 'a>(t: T) -> GenericBound<'a, T> {\n     t\n }\n \n mod pass_through {\n-    pub existential type Passthrough<T>: 'static;\n+    pub existential type Passthrough<T>: Sized + 'static;\n \n     fn define_passthrough<T: 'static>(t: T) -> Passthrough<T> {\n         t"}, {"sha": "ee6845c1278b8cff92ecfd39591a50df8b9feaa3", "filename": "src/test/run-pass/issues/issue-18075.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Fissues%2Fissue-18075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Fissues%2Fissue-18075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-18075.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-// exec-env:RUST_LOG=rustc::middle=debug\n+// exec-env:RUSTC_LOG=rustc::middle=debug\n \n fn main() {\n     let b = 1isize;"}, {"sha": "1a4c4d89e7dc85ac844d5ce8bd438c9b8dcc92d5", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,6 +1,6 @@\n // ignore-windows\n // ignore-emscripten no threads support\n-// exec-env:RUST_LOG=debug\n+// exec-env:RUSTC_LOG=debug\n \n use std::cell::Cell;\n use std::fmt;"}, {"sha": "69cfc54c465b5f14e38162d481af44c25bd356ca", "filename": "src/test/run-pass/logging_before_rt_started.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Flogging_before_rt_started.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Flogging_before_rt_started.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging_before_rt_started.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,4 +1,4 @@\n-// exec-env:RUST_LOG=std::ptr\n+// exec-env:RUSTC_LOG=std::ptr\n \n // In issue #9487, it was realized that std::ptr was invoking the logging\n // infrastructure, and when std::ptr was used during runtime initialization,"}, {"sha": "b6642572418338c844e91d751c7d9514b35ea69e", "filename": "src/test/run-pass/rustc-rust-log.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Frustc-rust-log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Frustc-rust-log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frustc-rust-log.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -8,6 +8,6 @@\n // dont-check-compiler-stderr\n // compile-flags: --error-format human\n \n-// rustc-env:RUST_LOG=debug\n+// rustc-env:RUSTC_LOG=debug\n \n fn main() {}"}, {"sha": "388d62aa7101c9bf2c38aad77fceab92bbeb8cbe", "filename": "src/test/run-pass/threads-sendsync/spawning-with-debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Fthreads-sendsync%2Fspawning-with-debug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frun-pass%2Fthreads-sendsync%2Fspawning-with-debug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads-sendsync%2Fspawning-with-debug.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -2,7 +2,7 @@\n #![allow(unused_must_use)]\n #![allow(unused_mut)]\n // ignore-windows\n-// exec-env:RUST_LOG=debug\n+// exec-env:RUSTC_LOG=debug\n // ignore-emscripten no threads support\n \n // regression test for issue #10405, make sure we don't call println! too soon."}, {"sha": "7b1cd702731402003757e742d75bda70c775f63e", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -15,7 +15,7 @@ error[E0425]: cannot find value `no` in this scope\n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0425`.\n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:310:13\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:319:13\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 11) stdout ----\n@@ -24,7 +24,7 @@ thread '$DIR/failed-doctest-output.rs - SomeStruct (line 11)' panicked at 'test\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n-', src/librustdoc/test.rs:332:17\n+', src/librustdoc/test.rs:341:17\n \n \n failures:"}, {"sha": "18d6b32bf40370b46c44fbbff7c6c2389aac7466", "filename": "src/test/rustdoc-ui/unparseable-doc-test.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: --test\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// failure-status: 101\n+// rustc-env: RUST_BACKTRACE=0\n+\n+/// ```rust\n+/// let x = 7;\n+/// \"unterminated\n+/// ```\n+pub fn foo() {}"}, {"sha": "7048ef2c58977af8aec254ddcedfa92e9d065bcf", "filename": "src/test/rustdoc-ui/unparseable-doc-test.stdout", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Funparseable-doc-test.stdout?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,24 @@\n+\n+running 1 test\n+test $DIR/unparseable-doc-test.rs - foo (line 6) ... FAILED\n+\n+failures:\n+\n+---- $DIR/unparseable-doc-test.rs - foo (line 6) stdout ----\n+error: unterminated double quote string\n+ --> $DIR/unparseable-doc-test.rs:8:1\n+  |\n+2 | \"unterminated\n+  | ^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+thread '$DIR/unparseable-doc-test.rs - foo (line 6)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:319:13\n+note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+\n+\n+failures:\n+    $DIR/unparseable-doc-test.rs - foo (line 6)\n+\n+test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n+"}, {"sha": "4d6dba74097ca77f240a4d6ff436b5466882924e", "filename": "src/test/ui/async-await/mutable-arguments.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fasync-await%2Fmutable-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fasync-await%2Fmutable-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmutable-arguments.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,10 @@\n+// edition:2018\n+// run-pass\n+\n+#![feature(async_await)]\n+\n+async fn foo(n: u32, mut vec: Vec<u32>) {\n+    vec.push(n);\n+}\n+\n+fn main() {}"}, {"sha": "8db7631ef41086cd70636b123ef234748a49c2cc", "filename": "src/test/ui/async-fn-path-elision.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fasync-fn-path-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fasync-fn-path-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-path-elision.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,16 @@\n+// edition:2018\n+\n+#![feature(async_await, await_macro)]\n+#![allow(dead_code)]\n+\n+struct HasLifetime<'a>(&'a bool);\n+\n+async fn error(lt: HasLifetime) { //~ ERROR implicit elided lifetime not allowed here\n+    if *lt.0 {}\n+}\n+\n+fn no_error(lt: HasLifetime) {\n+    if *lt.0 {}\n+}\n+\n+fn main() {}"}, {"sha": "3b311baba01de961534b7d9b12b7006f5fa1b287", "filename": "src/test/ui/async-fn-path-elision.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fasync-fn-path-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fasync-fn-path-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-fn-path-elision.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,8 @@\n+error[E0726]: implicit elided lifetime not allowed here\n+  --> $DIR/async-fn-path-elision.rs:8:20\n+   |\n+LL | async fn error(lt: HasLifetime) {\n+   |                    ^^^^^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n+\n+error: aborting due to previous error\n+"}, {"sha": "7dfcda69058acc0802d356e2762b548929796cdb", "filename": "src/test/ui/consts/const-err.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fconsts%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fconsts%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -13,4 +13,5 @@ const FOO: u8 = [5u8][1];\n fn main() {\n     black_box((FOO, FOO));\n     //~^ ERROR erroneous constant used\n+    //~| ERROR erroneous constant\n }"}, {"sha": "429e2ae7600d679aed49d60442425b8428d8c40b", "filename": "src/test/ui/consts/const-err.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fconsts%2Fconst-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fconsts%2Fconst-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -13,11 +13,17 @@ LL | #![warn(const_err)]\n    |         ^^^^^^^^^\n \n error[E0080]: erroneous constant used\n-  --> $DIR/const-err.rs:14:15\n+  --> $DIR/const-err.rs:14:16\n    |\n LL |     black_box((FOO, FOO));\n-   |               ^^^^^^^^^^ referenced constant has errors\n+   |                ^^^ referenced constant has errors\n \n-error: aborting due to previous error\n+error[E0080]: erroneous constant used\n+  --> $DIR/const-err.rs:14:21\n+   |\n+LL |     black_box((FOO, FOO));\n+   |                     ^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "bc3013b78b38c8a0886f4df0834fdeb89c49bad9", "filename": "src/test/ui/destructure-trait-ref.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -20,21 +20,25 @@ error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:31:10\n    |\n LL |     let &&x = &1isize as &T;\n-   |          ^^ expected trait T, found reference\n+   |          ^^\n+   |          |\n+   |          expected trait T, found reference\n+   |          help: you can probably remove the explicit borrow: `x`\n    |\n    = note: expected type `dyn T`\n               found type `&_`\n-   = help: did you mean `x: &dyn T`?\n \n error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:36:11\n    |\n LL |     let &&&x = &(&1isize as &T);\n-   |           ^^ expected trait T, found reference\n+   |           ^^\n+   |           |\n+   |           expected trait T, found reference\n+   |           help: you can probably remove the explicit borrow: `x`\n    |\n    = note: expected type `dyn T`\n               found type `&_`\n-   = help: did you mean `x: &dyn T`?\n \n error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:41:13"}, {"sha": "46339c73b1f1d39b00a769e24bcf024af334604c", "filename": "src/test/ui/existential_types/existential-types-with-no-traits.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-no-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-no-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-no-traits.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,14 @@\n+#![feature(existential_type)]\n+\n+existential type Foo: 'static;\n+//~^ ERROR: at least one trait must be specified\n+\n+fn foo() -> Foo {\n+    \"foo\"\n+}\n+\n+fn bar() -> impl 'static { //~ ERROR: at least one trait must be specified\n+    \"foo\"\n+}\n+\n+fn main() {}"}, {"sha": "4b2fbc79d3bc29e4706472b66771ef87d2d7d5d4", "filename": "src/test/ui/existential_types/existential-types-with-no-traits.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-no-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-no-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fexistential-types-with-no-traits.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,14 @@\n+error: at least one trait must be specified\n+  --> $DIR/existential-types-with-no-traits.rs:3:23\n+   |\n+LL | existential type Foo: 'static;\n+   |                       ^^^^^^^\n+\n+error: at least one trait must be specified\n+  --> $DIR/existential-types-with-no-traits.rs:10:13\n+   |\n+LL | fn bar() -> impl 'static {\n+   |             ^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "ffc965aca47c92eab9f8661243324b21d9fc51eb", "filename": "src/test/ui/existential_types/generic_nondefining_use.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_nondefining_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_nondefining_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_nondefining_use.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -4,6 +4,8 @@ fn main() {}\n \n existential type Cmp<T>: 'static;\n //~^ ERROR could not find defining uses\n+//~^^ ERROR: at least one trait must be specified\n+\n \n // not a defining use, because it doesn't define *all* possible generics\n fn cmp() -> Cmp<u32> { //~ ERROR defining existential type use does not fully define"}, {"sha": "d205d44c68c710b782bf5f4151e5c373dcb15827", "filename": "src/test/ui/existential_types/generic_nondefining_use.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_nondefining_use.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,5 +1,11 @@\n+error: at least one trait must be specified\n+  --> $DIR/generic_nondefining_use.rs:5:26\n+   |\n+LL | existential type Cmp<T>: 'static;\n+   |                          ^^^^^^^\n+\n error: defining existential type use does not fully define existential type\n-  --> $DIR/generic_nondefining_use.rs:9:1\n+  --> $DIR/generic_nondefining_use.rs:11:1\n    |\n LL | / fn cmp() -> Cmp<u32> {\n LL | |     5u32\n@@ -12,5 +18,5 @@ error: could not find defining uses\n LL | existential type Cmp<T>: 'static;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n "}, {"sha": "054e6f5f2ade99fda0bd2ed82ce68ee6acbc7946", "filename": "src/test/ui/existential_types/generic_not_used.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_not_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_not_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_not_used.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -3,6 +3,7 @@\n fn main() {}\n \n existential type WrongGeneric<T: 'static>: 'static;\n+//~^ ERROR: at least one trait must be specified\n \n fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {\n //~^ ERROR type parameter `V` is part of concrete type but not used in parameter list"}, {"sha": "d243233992b0266422f18b4fce26366e97bbfb83", "filename": "src/test/ui/existential_types/generic_not_used.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_not_used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_not_used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_not_used.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,5 +1,11 @@\n+error: at least one trait must be specified\n+  --> $DIR/generic_not_used.rs:5:44\n+   |\n+LL | existential type WrongGeneric<T: 'static>: 'static;\n+   |                                            ^^^^^^^\n+\n error: type parameter `V` is part of concrete type but not used in parameter list for existential type\n-  --> $DIR/generic_not_used.rs:7:73\n+  --> $DIR/generic_not_used.rs:8:73\n    |\n LL |   fn wrong_generic<U: 'static, V: 'static>(_: U, v: V) -> WrongGeneric<U> {\n    |  _________________________________________________________________________^\n@@ -8,5 +14,5 @@ LL | |     v\n LL | | }\n    | |_^\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n "}, {"sha": "d9eedd6dca7c1d8621d3578fa178da6da9099c33", "filename": "src/test/ui/existential_types/generic_type_does_not_live_long_enough.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -8,6 +8,7 @@ fn main() {\n \n existential type WrongGeneric<T>: 'static;\n //~^ ERROR the parameter type `T` may not live long enough\n+//~^^ ERROR: at least one trait must be specified\n \n fn wrong_generic<T>(t: T) -> WrongGeneric<T> {\n     t"}, {"sha": "2f76eea4460bd387e0bfbd19d3efc2e128aa8569", "filename": "src/test/ui/existential_types/generic_type_does_not_live_long_enough.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_type_does_not_live_long_enough.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,3 +1,9 @@\n+error: at least one trait must be specified\n+  --> $DIR/generic_type_does_not_live_long_enough.rs:9:35\n+   |\n+LL | existential type WrongGeneric<T>: 'static;\n+   |                                   ^^^^^^^\n+\n error[E0308]: mismatched types\n   --> $DIR/generic_type_does_not_live_long_enough.rs:6:18\n    |\n@@ -22,7 +28,7 @@ note: ...so that the type `T` will meet its required lifetime bounds\n LL | existential type WrongGeneric<T>: 'static;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0308, E0310.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "cc0db893c6aa703ef1f6d0d72326cb9030dfad35", "filename": "src/test/ui/existential_types/generic_underconstrained.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -4,6 +4,7 @@ fn main() {}\n \n trait Trait {}\n existential type Underconstrained<T: Trait>: 'static; //~ ERROR the trait bound `T: Trait`\n+//~^ ERROR: at least one trait must be specified\n \n // no `Trait` bound\n fn underconstrain<T>(_: T) -> Underconstrained<T> {"}, {"sha": "35083a53eb3438083874e0a22bf847bc0c42a565", "filename": "src/test/ui/existential_types/generic_underconstrained.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,3 +1,9 @@\n+error: at least one trait must be specified\n+  --> $DIR/generic_underconstrained.rs:6:46\n+   |\n+LL | existential type Underconstrained<T: Trait>: 'static;\n+   |                                              ^^^^^^^\n+\n error[E0277]: the trait bound `T: Trait` is not satisfied\n   --> $DIR/generic_underconstrained.rs:6:1\n    |\n@@ -7,6 +13,6 @@ LL | existential type Underconstrained<T: Trait>: 'static;\n    = help: consider adding a `where T: Trait` bound\n    = note: the return type of a function must have a statically known size\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "c6263eacd53e3c4d75df015b90133f79115bcb4f", "filename": "src/test/ui/existential_types/generic_underconstrained2.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained2.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -4,6 +4,7 @@ fn main() {}\n \n existential type Underconstrained<T: std::fmt::Debug>: 'static;\n //~^ ERROR `U` doesn't implement `std::fmt::Debug`\n+//~^^ ERROR: at least one trait must be specified\n \n // not a defining use, because it doesn't define *all* possible generics\n fn underconstrained<U>(_: U) -> Underconstrained<U> {\n@@ -12,6 +13,7 @@ fn underconstrained<U>(_: U) -> Underconstrained<U> {\n \n existential type Underconstrained2<T: std::fmt::Debug>: 'static;\n //~^ ERROR `V` doesn't implement `std::fmt::Debug`\n+//~^^ ERROR: at least one trait must be specified\n \n // not a defining use, because it doesn't define *all* possible generics\n fn underconstrained2<U, V>(_: U, _: V) -> Underconstrained2<V> {"}, {"sha": "6ff783f33b96f8b0d97635dc405ed80ea12a336b", "filename": "src/test/ui/existential_types/generic_underconstrained2.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Fgeneric_underconstrained2.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,3 +1,15 @@\n+error: at least one trait must be specified\n+  --> $DIR/generic_underconstrained2.rs:5:56\n+   |\n+LL | existential type Underconstrained<T: std::fmt::Debug>: 'static;\n+   |                                                        ^^^^^^^\n+\n+error: at least one trait must be specified\n+  --> $DIR/generic_underconstrained2.rs:14:57\n+   |\n+LL | existential type Underconstrained2<T: std::fmt::Debug>: 'static;\n+   |                                                         ^^^^^^^\n+\n error[E0277]: `U` doesn't implement `std::fmt::Debug`\n   --> $DIR/generic_underconstrained2.rs:5:1\n    |\n@@ -9,7 +21,7 @@ LL | existential type Underconstrained<T: std::fmt::Debug>: 'static;\n    = note: the return type of a function must have a statically known size\n \n error[E0277]: `V` doesn't implement `std::fmt::Debug`\n-  --> $DIR/generic_underconstrained2.rs:13:1\n+  --> $DIR/generic_underconstrained2.rs:14:1\n    |\n LL | existential type Underconstrained2<T: std::fmt::Debug>: 'static;\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `V` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n@@ -18,6 +30,6 @@ LL | existential type Underconstrained2<T: std::fmt::Debug>: 'static;\n    = help: consider adding a `where V: std::fmt::Debug` bound\n    = note: the return type of a function must have a statically known size\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "5455b39f4cbe220b0255826a29d2a34ac9a992cc", "filename": "src/test/ui/existential_types/unused_generic_param.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Funused_generic_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Funused_generic_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Funused_generic_param.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,18 +1,17 @@\n-// compile-pass\n #![feature(existential_type)]\n \n fn main() {\n }\n \n-// test that unused generic parameters are ok\n existential type PartiallyDefined<T>: 'static;\n+//~^ ERROR: at least one trait must be specified\n \n fn partially_defined<T: std::fmt::Debug>(_: T) -> PartiallyDefined<T> {\n     4u32\n }\n \n-// test that unused generic parameters are ok\n existential type PartiallyDefined2<T>: 'static;\n+//~^ ERROR: at least one trait must be specified\n \n fn partially_defined2<T: std::fmt::Debug>(_: T) -> PartiallyDefined2<T> {\n     4u32"}, {"sha": "9d628d069d36cf8c95b47bb3a0042f974229026e", "filename": "src/test/ui/existential_types/unused_generic_param.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Funused_generic_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fexistential_types%2Funused_generic_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexistential_types%2Funused_generic_param.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,14 @@\n+error: at least one trait must be specified\n+  --> $DIR/unused_generic_param.rs:6:39\n+   |\n+LL | existential type PartiallyDefined<T>: 'static;\n+   |                                       ^^^^^^^\n+\n+error: at least one trait must be specified\n+  --> $DIR/unused_generic_param.rs:13:40\n+   |\n+LL | existential type PartiallyDefined2<T>: 'static;\n+   |                                        ^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "40a52efc7f9fc0860dc774477c5a9c13832f8266", "filename": "src/test/ui/impl-header-lifetime-elision/path-elided.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -5,7 +5,7 @@ trait MyTrait { }\n struct Foo<'a> { x: &'a u32 }\n \n impl MyTrait for Foo {\n-    //~^ ERROR missing lifetime specifier\n+    //~^ ERROR implicit elided lifetime not allowed here\n }\n \n fn main() {}"}, {"sha": "6500a2a55f6677d807922ec67f2cff89d53f6fe3", "filename": "src/test/ui/impl-header-lifetime-elision/path-elided.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fpath-elided.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,9 +1,8 @@\n-error[E0106]: missing lifetime specifier\n+error[E0726]: implicit elided lifetime not allowed here\n   --> $DIR/path-elided.rs:7:18\n    |\n LL | impl MyTrait for Foo {\n-   |                  ^^^ expected lifetime parameter\n+   |                  ^^^- help: indicate the anonymous lifetime: `<'_>`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0106`."}, {"sha": "102d259b0c87ab5e9976df924dce3951c6448e77", "filename": "src/test/ui/impl-header-lifetime-elision/trait-elided.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -3,7 +3,7 @@\n trait MyTrait<'a> { }\n \n impl MyTrait for u32 {\n-    //~^ ERROR missing lifetime specifier\n+    //~^ ERROR implicit elided lifetime not allowed here\n }\n \n fn main() {}"}, {"sha": "ad97cb0abd6239bc34ba3c0f04e0034a0ad0e8e8", "filename": "src/test/ui/impl-header-lifetime-elision/trait-elided.stderr", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Ftrait-elided.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,9 +1,8 @@\n-error[E0106]: missing lifetime specifier\n+error[E0726]: implicit elided lifetime not allowed here\n   --> $DIR/trait-elided.rs:5:6\n    |\n LL | impl MyTrait for u32 {\n-   |      ^^^^^^^ expected lifetime parameter\n+   |      ^^^^^^^- help: indicate the anonymous lifetime: `<'_>`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0106`."}, {"sha": "020585136856bd35070624c7a0e54bcb44a019fe", "filename": "src/test/ui/issues/issue-10412.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fissues%2Fissue-10412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fissues%2Fissue-10412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10412.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -5,7 +5,8 @@ trait Serializable<'self, T> { //~ ERROR lifetimes cannot use keyword names\n \n impl<'self> Serializable<str> for &'self str { //~ ERROR lifetimes cannot use keyword names\n     //~^ ERROR lifetimes cannot use keyword names\n-    //~| ERROR missing lifetime specifier\n+    //~| ERROR implicit elided lifetime not allowed here\n+    //~| ERROR the size for values of type `str` cannot be known at compilation time\n     fn serialize(val : &'self str) -> Vec<u8> { //~ ERROR lifetimes cannot use keyword names\n         vec![1]\n     }"}, {"sha": "0793dd99b4d12578d71987cb9770af50e6468e2e", "filename": "src/test/ui/issues/issue-10412.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10412.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -29,23 +29,32 @@ LL | impl<'self> Serializable<str> for &'self str {\n    |                                    ^^^^^\n \n error: lifetimes cannot use keyword names\n-  --> $DIR/issue-10412.rs:9:25\n+  --> $DIR/issue-10412.rs:10:25\n    |\n LL |     fn serialize(val : &'self str) -> Vec<u8> {\n    |                         ^^^^^\n \n error: lifetimes cannot use keyword names\n-  --> $DIR/issue-10412.rs:12:37\n+  --> $DIR/issue-10412.rs:13:37\n    |\n LL |     fn deserialize(repr: &[u8]) -> &'self str {\n    |                                     ^^^^^\n \n-error[E0106]: missing lifetime specifier\n+error[E0726]: implicit elided lifetime not allowed here\n   --> $DIR/issue-10412.rs:6:13\n    |\n LL | impl<'self> Serializable<str> for &'self str {\n-   |             ^^^^^^^^^^^^^^^^^ expected lifetime parameter\n+   |             ^^^^^^^^^^^^^^^^^ help: indicate the anonymous lifetime: `Serializable<'_, str>`\n \n-error: aborting due to 8 previous errors\n+error[E0277]: the size for values of type `str` cannot be known at compilation time\n+  --> $DIR/issue-10412.rs:6:13\n+   |\n+LL | impl<'self> Serializable<str> for &'self str {\n+   |             ^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `str`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+\n+error: aborting due to 9 previous errors\n \n-For more information about this error, try `rustc --explain E0106`.\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8dfbf1019e9a402245b73b6acd8abf86fd46cd2c", "filename": "src/test/ui/match/match-type-err-first-arm.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -3,8 +3,7 @@ fn main() {\n     let _ = test_func2(1);\n }\n \n-fn test_func1(n: i32) -> i32 {\n-    //~^ NOTE expected `i32` because of return type\n+fn test_func1(n: i32) -> i32 { //~ NOTE expected `i32` because of return type\n     match n {\n         12 => 'b',\n         //~^ ERROR mismatched types\n@@ -14,10 +13,8 @@ fn test_func1(n: i32) -> i32 {\n }\n \n fn test_func2(n: i32) -> i32 {\n-    let x = match n {\n-    //~^ NOTE `match` arms have incompatible types\n-        12 => 'b',\n-        //~^ NOTE this is found to be of type `char`\n+    let x = match n { //~ NOTE `match` arms have incompatible types\n+        12 => 'b', //~ NOTE this is found to be of type `char`\n         _ => 42,\n         //~^ ERROR match arms have incompatible types\n         //~| NOTE expected char, found integer\n@@ -27,8 +24,7 @@ fn test_func2(n: i32) -> i32 {\n }\n \n fn test_func3(n: i32) -> i32 {\n-    let x = match n {\n-    //~^ NOTE `match` arms have incompatible types\n+    let x = match n { //~ NOTE `match` arms have incompatible types\n         1 => 'b',\n         2 => 'b',\n         3 => 'b',\n@@ -43,3 +39,15 @@ fn test_func3(n: i32) -> i32 {\n     };\n     x\n }\n+\n+fn test_func4() {\n+    match Some(0u32) { //~ NOTE `match` arms have incompatible types\n+        Some(x) => {\n+            x //~ NOTE this is found to be of type `u32`\n+        },\n+        None => {}\n+        //~^ ERROR match arms have incompatible types\n+        //~| NOTE expected u32, found ()\n+        //~| NOTE expected type `u32`\n+    };\n+}"}, {"sha": "e0553fca683a557aec0c25492fc2eda0b3bcf2d2", "filename": "src/test/ui/match/match-type-err-first-arm.stderr", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-type-err-first-arm.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,24 +1,23 @@\n error[E0308]: mismatched types\n-  --> $DIR/match-type-err-first-arm.rs:9:15\n+  --> $DIR/match-type-err-first-arm.rs:8:15\n    |\n LL | fn test_func1(n: i32) -> i32 {\n    |                          --- expected `i32` because of return type\n-...\n+LL |     match n {\n LL |         12 => 'b',\n    |               ^^^ expected i32, found char\n \n error[E0308]: match arms have incompatible types\n-  --> $DIR/match-type-err-first-arm.rs:21:14\n+  --> $DIR/match-type-err-first-arm.rs:18:14\n    |\n LL |       let x = match n {\n    |  _____________-\n-LL | |\n LL | |         12 => 'b',\n    | |               --- this is found to be of type `char`\n-LL | |\n LL | |         _ => 42,\n    | |              ^^ expected char, found integer\n-...  |\n+LL | |\n+LL | |\n LL | |\n LL | |     };\n    | |_____- `match` arms have incompatible types\n@@ -27,13 +26,13 @@ LL | |     };\n               found type `{integer}`\n \n error[E0308]: match arms have incompatible types\n-  --> $DIR/match-type-err-first-arm.rs:39:14\n+  --> $DIR/match-type-err-first-arm.rs:35:14\n    |\n LL |       let x = match n {\n    |  _____________-\n-LL | |\n LL | |         1 => 'b',\n LL | |         2 => 'b',\n+LL | |         3 => 'b',\n ...  |\n LL | |         6 => 'b',\n    | |              --- this and all prior arms are found to be of type `char`\n@@ -48,6 +47,24 @@ LL | |     };\n    = note: expected type `char`\n               found type `{integer}`\n \n-error: aborting due to 3 previous errors\n+error[E0308]: match arms have incompatible types\n+  --> $DIR/match-type-err-first-arm.rs:48:17\n+   |\n+LL | /     match Some(0u32) {\n+LL | |         Some(x) => {\n+LL | |             x\n+   | |             - this is found to be of type `u32`\n+LL | |         },\n+LL | |         None => {}\n+   | |                 ^^ expected u32, found ()\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+   = note: expected type `u32`\n+              found type `()`\n+\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "a9347926bda0a554ba69bb081e38d75d2b178540", "filename": "src/test/ui/mismatched_types/issue-38371.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-38371.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -12,11 +12,13 @@ error[E0308]: mismatched types\n   --> $DIR/issue-38371.rs:18:9\n    |\n LL | fn agh(&&bar: &u32) {\n-   |         ^^^^ expected u32, found reference\n+   |         ^^^^\n+   |         |\n+   |         expected u32, found reference\n+   |         help: you can probably remove the explicit borrow: `bar`\n    |\n    = note: expected type `u32`\n               found type `&_`\n-   = help: did you mean `bar: &u32`?\n \n error[E0308]: mismatched types\n   --> $DIR/issue-38371.rs:21:8"}, {"sha": "c4fc01469bf65ec4c41432a4719b8ed33c3a68f1", "filename": "src/test/ui/suggestions/match-ergonomics.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,41 @@\n+fn main() {\n+    let x = vec![1i32];\n+    match &x[..] {\n+        [&v] => {}, //~ ERROR mismatched types\n+        _ => {},\n+    }\n+    match x {\n+        [&v] => {}, //~ ERROR expected an array or slice\n+        _ => {},\n+    }\n+    match &x[..] {\n+        [v] => {},\n+        _ => {},\n+    }\n+    match &x[..] {\n+        &[v] => {},\n+        _ => {},\n+    }\n+    match x {\n+        [v] => {}, //~ ERROR expected an array or slice\n+        _ => {},\n+    }\n+    let y = 1i32;\n+    match &y {\n+        &v => {},\n+        _ => {},\n+    }\n+    match y {\n+        &v => {}, //~ ERROR mismatched types\n+        _ => {},\n+    }\n+    match &y {\n+        v => {},\n+        _ => {},\n+    }\n+    match y {\n+        v => {},\n+        _ => {},\n+    }\n+    if let [&v] = &x[..] {} //~ ERROR mismatched types\n+}"}, {"sha": "b7497be6ceb3693b4f42c485035336a6b55a82c3", "filename": "src/test/ui/suggestions/match-ergonomics.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmatch-ergonomics.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,52 @@\n+error[E0308]: mismatched types\n+  --> $DIR/match-ergonomics.rs:4:10\n+   |\n+LL |         [&v] => {},\n+   |          ^^\n+   |          |\n+   |          expected i32, found reference\n+   |          help: you can probably remove the explicit borrow: `v`\n+   |\n+   = note: expected type `i32`\n+              found type `&_`\n+\n+error[E0529]: expected an array or slice, found `std::vec::Vec<i32>`\n+  --> $DIR/match-ergonomics.rs:8:9\n+   |\n+LL |         [&v] => {},\n+   |         ^^^^ pattern cannot match with input type `std::vec::Vec<i32>`\n+\n+error[E0529]: expected an array or slice, found `std::vec::Vec<i32>`\n+  --> $DIR/match-ergonomics.rs:20:9\n+   |\n+LL |         [v] => {},\n+   |         ^^^ pattern cannot match with input type `std::vec::Vec<i32>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/match-ergonomics.rs:29:9\n+   |\n+LL |         &v => {},\n+   |         ^^\n+   |         |\n+   |         expected i32, found reference\n+   |         help: you can probably remove the explicit borrow: `v`\n+   |\n+   = note: expected type `i32`\n+              found type `&_`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/match-ergonomics.rs:40:13\n+   |\n+LL |     if let [&v] = &x[..] {}\n+   |             ^^\n+   |             |\n+   |             expected i32, found reference\n+   |             help: you can probably remove the explicit borrow: `v`\n+   |\n+   = note: expected type `i32`\n+              found type `&_`\n+\n+error: aborting due to 5 previous errors\n+\n+Some errors have detailed explanations: E0308, E0529.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "82cd21b09d3e7de0717d80df8876d3d58a128f17", "filename": "src/test/ui/type-alias-enum-variants-priority.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,5 +1,4 @@\n #![feature(type_alias_enum_variants)]\n-#![deny(ambiguous_associated_items)]\n \n enum E {\n     V"}, {"sha": "b8271807b835da963da7fb501089929a4b3a9717", "filename": "src/test/ui/type-alias-enum-variants-priority.stderr", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.stderr?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -1,23 +1,19 @@\n error: ambiguous associated item\n-  --> $DIR/type-alias-enum-variants-priority.rs:15:15\n+  --> $DIR/type-alias-enum-variants-priority.rs:14:15\n    |\n LL |     fn f() -> Self::V { 0 }\n    |               ^^^^^^^ help: use fully-qualified syntax: `<E as Trait>::V`\n    |\n-note: lint level defined here\n-  --> $DIR/type-alias-enum-variants-priority.rs:2:9\n-   |\n-LL | #![deny(ambiguous_associated_items)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: #[deny(ambiguous_associated_items)] on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #57644 <https://github.com/rust-lang/rust/issues/57644>\n note: `V` could refer to variant defined here\n-  --> $DIR/type-alias-enum-variants-priority.rs:5:5\n+  --> $DIR/type-alias-enum-variants-priority.rs:4:5\n    |\n LL |     V\n    |     ^\n note: `V` could also refer to associated type defined here\n-  --> $DIR/type-alias-enum-variants-priority.rs:9:5\n+  --> $DIR/type-alias-enum-variants-priority.rs:8:5\n    |\n LL |     type V;\n    |     ^^^^^^^"}, {"sha": "f5db2487618d6e116ffc10138ee6205e8cfdf2c2", "filename": "src/tools/tidy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftools%2Ftidy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftools%2Ftidy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2FCargo.toml?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -4,6 +4,7 @@ version = \"0.1.0\"\n authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n \n [dependencies]\n+regex = \"1\"\n serde = \"1.0.8\"\n serde_derive = \"1.0.8\"\n serde_json = \"1.0.2\""}, {"sha": "3144df6dd4cdf90d8773794a7ed60a0073831172", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 98, "deletions": 30, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -7,13 +7,22 @@\n //! * Library features have at most one stability level.\n //! * Library features have at most one `since` value.\n //! * All unstable lang features have tests to ensure they are actually unstable.\n+//! * Language features in a group are sorted by `since` value.\n \n use std::collections::HashMap;\n use std::fmt;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::Path;\n \n+use regex::{Regex, escape};\n+\n+mod version;\n+use self::version::Version;\n+\n+const FEATURE_GROUP_START_PREFIX: &str = \"// feature-group-start\";\n+const FEATURE_GROUP_END_PREFIX: &str = \"// feature-group-end\";\n+\n #[derive(Debug, PartialEq, Clone)]\n pub enum Status {\n     Stable,\n@@ -35,7 +44,7 @@ impl fmt::Display for Status {\n #[derive(Debug, Clone)]\n pub struct Feature {\n     pub level: Status,\n-    pub since: String,\n+    pub since: Option<Version>,\n     pub has_gate_test: bool,\n     pub tracking_issue: Option<u32>,\n }\n@@ -129,32 +138,40 @@ pub fn check(path: &Path, bad: &mut bool, quiet: bool) {\n     }\n \n     let mut lines = Vec::new();\n-    for (name, feature) in features.iter() {\n-        lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n-                           name,\n-                           \"lang\",\n-                           feature.level,\n-                           feature.since));\n-    }\n-    for (name, feature) in lib_features {\n-        lines.push(format!(\"{:<32} {:<8} {:<12} {:<8}\",\n-                           name,\n-                           \"lib\",\n-                           feature.level,\n-                           feature.since));\n-    }\n+    lines.extend(format_features(&features, \"lang\"));\n+    lines.extend(format_features(&lib_features, \"lib\"));\n \n     lines.sort();\n     for line in lines {\n         println!(\"* {}\", line);\n     }\n }\n \n+fn format_features<'a>(features: &'a Features, family: &'a str) -> impl Iterator<Item = String> + 'a {\n+    features.iter().map(move |(name, feature)| {\n+        format!(\"{:<32} {:<8} {:<12} {:<8}\",\n+                name,\n+                family,\n+                feature.level,\n+                feature.since.map_or(\"None\".to_owned(),\n+                                     |since| since.to_string()))\n+    })\n+}\n+\n fn find_attr_val<'a>(line: &'a str, attr: &str) -> Option<&'a str> {\n-    line.find(attr)\n-        .and_then(|i| line[i..].find('\"').map(|j| i + j + 1))\n-        .and_then(|i| line[i..].find('\"').map(|j| (i, i + j)))\n-        .map(|(i, j)| &line[i..j])\n+    let r = Regex::new(&format!(r#\"{}\\s*=\\s*\"([^\"]*)\"\"#, escape(attr)))\n+        .expect(\"malformed regex for find_attr_val\");\n+    r.captures(line)\n+        .and_then(|c| c.get(1))\n+        .map(|m| m.as_str())\n+}\n+\n+#[test]\n+fn test_find_attr_val() {\n+    let s = r#\"#[unstable(feature = \"checked_duration_since\", issue = \"58402\")]\"#;\n+    assert_eq!(find_attr_val(s, \"feature\"), Some(\"checked_duration_since\"));\n+    assert_eq!(find_attr_val(s, \"issue\"), Some(\"58402\"));\n+    assert_eq!(find_attr_val(s, \"since\"), None);\n }\n \n fn test_filen_gate(filen_underscore: &str, features: &mut Features) -> bool {\n@@ -177,6 +194,9 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n     // without one inside `// no tracking issue START` and `// no tracking issue END`.\n     let mut next_feature_omits_tracking_issue = false;\n \n+    let mut in_feature_group = false;\n+    let mut prev_since = None;\n+\n     contents.lines().zip(1..)\n         .filter_map(|(line, line_number)| {\n             let line = line.trim();\n@@ -194,6 +214,25 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n                 _ => {}\n             }\n \n+            if line.starts_with(FEATURE_GROUP_START_PREFIX) {\n+                if in_feature_group {\n+                    tidy_error!(\n+                        bad,\n+                        // ignore-tidy-linelength\n+                        \"libsyntax/feature_gate.rs:{}: new feature group is started without ending the previous one\",\n+                        line_number,\n+                    );\n+                }\n+\n+                in_feature_group = true;\n+                prev_since = None;\n+                return None;\n+            } else if line.starts_with(FEATURE_GROUP_END_PREFIX) {\n+                in_feature_group = false;\n+                prev_since = None;\n+                return None;\n+            }\n+\n             let mut parts = line.split(',');\n             let level = match parts.next().map(|l| l.trim().trim_start_matches('(')) {\n                 Some(\"active\") => Status::Unstable,\n@@ -202,7 +241,33 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n                 _ => return None,\n             };\n             let name = parts.next().unwrap().trim();\n-            let since = parts.next().unwrap().trim().trim_matches('\"');\n+\n+            let since_str = parts.next().unwrap().trim().trim_matches('\"');\n+            let since = match since_str.parse() {\n+                Ok(since) => Some(since),\n+                Err(err) => {\n+                    tidy_error!(\n+                        bad,\n+                        \"libsyntax/feature_gate.rs:{}: failed to parse since: {} ({:?})\",\n+                        line_number,\n+                        since_str,\n+                        err,\n+                    );\n+                    None\n+                }\n+            };\n+            if in_feature_group {\n+                if prev_since > since {\n+                    tidy_error!(\n+                        bad,\n+                        \"libsyntax/feature_gate.rs:{}: feature {} is not sorted by since\",\n+                        line_number,\n+                        name,\n+                    );\n+                }\n+                prev_since = since;\n+            }\n+\n             let issue_str = parts.next().unwrap().trim();\n             let tracking_issue = if issue_str.starts_with(\"None\") {\n                 if level == Status::Unstable && !next_feature_omits_tracking_issue {\n@@ -222,7 +287,7 @@ pub fn collect_lang_features(base_src_path: &Path, bad: &mut bool) -> Features {\n             Some((name.to_owned(),\n                 Feature {\n                     level,\n-                    since: since.to_owned(),\n+                    since,\n                     has_gate_test: false,\n                     tracking_issue,\n                 }))\n@@ -239,7 +304,7 @@ pub fn collect_lib_features(base_src_path: &Path) -> Features {\n     // add it to the set of known library features so we can still generate docs.\n     lib_features.insert(\"compiler_builtins_lib\".to_owned(), Feature {\n         level: Status::Unstable,\n-        since: String::new(),\n+        since: None,\n         has_gate_test: false,\n         tracking_issue: None,\n     });\n@@ -336,11 +401,11 @@ fn map_lib_features(base_src_path: &Path,\n                 // `const fn` features are handled specially.\n                 let feature_name = match find_attr_val(line, \"feature\") {\n                     Some(name) => name,\n-                    None => err!(\"malformed stability attribute\"),\n+                    None => err!(\"malformed stability attribute: missing `feature` key\"),\n                 };\n                 let feature = Feature {\n                     level: Status::Unstable,\n-                    since: \"None\".to_owned(),\n+                    since: None,\n                     has_gate_test: false,\n                     // FIXME(#57563): #57563 is now used as a common tracking issue,\n                     // although we would like to have specific tracking issues for each\n@@ -359,20 +424,23 @@ fn map_lib_features(base_src_path: &Path,\n             };\n             let feature_name = match find_attr_val(line, \"feature\") {\n                 Some(name) => name,\n-                None => err!(\"malformed stability attribute\"),\n+                None => err!(\"malformed stability attribute: missing `feature` key\"),\n             };\n-            let since = match find_attr_val(line, \"since\") {\n-                Some(name) => name,\n+            let since = match find_attr_val(line, \"since\").map(|x| x.parse()) {\n+                Some(Ok(since)) => Some(since),\n+                Some(Err(_err)) => {\n+                    err!(\"malformed stability attribute: can't parse `since` key\");\n+                },\n                 None if level == Status::Stable => {\n-                    err!(\"malformed stability attribute\");\n+                    err!(\"malformed stability attribute: missing the `since` key\");\n                 }\n-                None => \"None\",\n+                None => None,\n             };\n             let tracking_issue = find_attr_val(line, \"issue\").map(|s| s.parse().unwrap());\n \n             let feature = Feature {\n                 level,\n-                since: since.to_owned(),\n+                since,\n                 has_gate_test: false,\n                 tracking_issue,\n             };"}, {"sha": "6027e7d35e28c4d6b23dc3049ac9b2412b06b54d", "filename": "src/tools/tidy/src/features/version.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures%2Fversion.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -0,0 +1,92 @@\n+use std::str::FromStr;\n+use std::num::ParseIntError;\n+use std::fmt;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Version {\n+    parts: [u32; 3],\n+}\n+\n+impl fmt::Display for Version {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(&format!(\"{}.{}.{}\", self.parts[0], self.parts[1], self.parts[2]))\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum ParseVersionError {\n+    ParseIntError(ParseIntError),\n+    WrongNumberOfParts,\n+}\n+\n+impl From<ParseIntError> for ParseVersionError {\n+    fn from(err: ParseIntError) -> Self {\n+        ParseVersionError::ParseIntError(err)\n+    }\n+}\n+\n+impl FromStr for Version {\n+    type Err = ParseVersionError;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        let mut iter = s.split('.').map(|part| Ok(part.parse()?));\n+\n+        let parts = {\n+            let mut part = || {\n+                iter.next()\n+                    .unwrap_or(Err(ParseVersionError::WrongNumberOfParts))\n+            };\n+\n+            [part()?, part()?, part()?]\n+        };\n+\n+        if let Some(_) = iter.next() {\n+            // Ensure we don't have more than 3 parts.\n+            return Err(ParseVersionError::WrongNumberOfParts);\n+        }\n+\n+        Ok(Self { parts })\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Version;\n+\n+    #[test]\n+    fn test_try_from_invalid_version() {\n+        assert!(\"\".parse::<Version>().is_err());\n+        assert!(\"hello\".parse::<Version>().is_err());\n+        assert!(\"1.32.hi\".parse::<Version>().is_err());\n+        assert!(\"1.32..1\".parse::<Version>().is_err());\n+        assert!(\"1.32\".parse::<Version>().is_err());\n+        assert!(\"1.32.0.1\".parse::<Version>().is_err());\n+    }\n+\n+    #[test]\n+    fn test_try_from_single() {\n+        assert_eq!(\"1.32.0\".parse(), Ok(Version { parts: [1, 32, 0] }));\n+        assert_eq!(\"1.0.0\".parse(), Ok(Version { parts: [1, 0, 0] }));\n+    }\n+\n+    #[test]\n+    fn test_compare() {\n+        let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n+        let v_1_32_0 = \"1.32.0\".parse::<Version>().unwrap();\n+        let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n+        assert!(v_1_0_0 < v_1_32_1);\n+        assert!(v_1_0_0 < v_1_32_0);\n+        assert!(v_1_32_0 < v_1_32_1);\n+    }\n+\n+    #[test]\n+    fn test_to_string() {\n+        let v_1_0_0 = \"1.0.0\".parse::<Version>().unwrap();\n+        let v_1_32_1 = \"1.32.1\".parse::<Version>().unwrap();\n+\n+        assert_eq!(v_1_0_0.to_string(), \"1.0.0\");\n+        assert_eq!(v_1_32_1.to_string(), \"1.32.1\");\n+        assert_eq!(format!(\"{:<8}\", v_1_32_1), \"1.32.1  \");\n+        assert_eq!(format!(\"{:>8}\", v_1_32_1), \"  1.32.1\");\n+    }\n+}"}, {"sha": "30080452edc0199959474d61bf9b5c9558bb9e3b", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "patch": "@@ -5,6 +5,7 @@\n \n #![deny(rust_2018_idioms)]\n \n+extern crate regex;\n extern crate serde_json;\n #[macro_use]\n extern crate serde_derive;"}]}