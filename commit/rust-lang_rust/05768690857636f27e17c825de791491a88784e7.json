{"sha": "05768690857636f27e17c825de791491a88784e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1NzY4NjkwODU3NjM2ZjI3ZTE3YzgyNWRlNzkxNDkxYTg4Nzg0ZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-08T04:18:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-08T04:18:32Z"}, "message": "Auto merge of #38822 - michaelwoerister:collect-fn-once-adapter, r=eddyb\n\ntrans: Fix missing closure env drop-glue in trans-item collector.\n\nFnOnce adapters automatically generated by the compiler introduce a call to drop the closure environment. The collector didn't pick up on that because this drop call does not show up in MIR. That could lead to an assertion being triggered if the drop-glue for the environment wasn't instantiated via something else.\n\nFixes #38810\n\ncc @arielb1\n\nr? @eddyb or @nikomatsakis", "tree": {"sha": "c0ffb878bdefc24a6a5149b49356083a7b40a5af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0ffb878bdefc24a6a5149b49356083a7b40a5af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05768690857636f27e17c825de791491a88784e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05768690857636f27e17c825de791491a88784e7", "html_url": "https://github.com/rust-lang/rust/commit/05768690857636f27e17c825de791491a88784e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05768690857636f27e17c825de791491a88784e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05383b2765fe6bb38ecf5f74f1b2d9bdf55df894", "url": "https://api.github.com/repos/rust-lang/rust/commits/05383b2765fe6bb38ecf5f74f1b2d9bdf55df894", "html_url": "https://github.com/rust-lang/rust/commit/05383b2765fe6bb38ecf5f74f1b2d9bdf55df894"}, {"sha": "8b94267a8c66ee83a90403c6bb6d3dd60ada268c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b94267a8c66ee83a90403c6bb6d3dd60ada268c", "html_url": "https://github.com/rust-lang/rust/commit/8b94267a8c66ee83a90403c6bb6d3dd60ada268c"}], "stats": {"total": 147, "additions": 123, "deletions": 24}, "files": [{"sha": "58d0c46850353697ddf9d908ac330ef682e438ff", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/05768690857636f27e17c825de791491a88784e7/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05768690857636f27e17c825de791491a88784e7/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=05768690857636f27e17c825de791491a88784e7", "patch": "@@ -234,18 +234,37 @@ fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n            trait_closure_kind={:?}, llfn={:?})\",\n            llfn_closure_kind, trait_closure_kind, Value(llfn));\n \n-    match (llfn_closure_kind, trait_closure_kind) {\n+    match needs_fn_once_adapter_shim(llfn_closure_kind, trait_closure_kind) {\n+        Ok(true) => trans_fn_once_adapter_shim(ccx,\n+                                               def_id,\n+                                               substs,\n+                                               method_instance,\n+                                               llfn),\n+        Ok(false) => llfn,\n+        Err(()) => {\n+            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                 llfn_closure_kind,\n+                 trait_closure_kind);\n+        }\n+    }\n+}\n+\n+pub fn needs_fn_once_adapter_shim(actual_closure_kind: ty::ClosureKind,\n+                                  trait_closure_kind: ty::ClosureKind)\n+                                  -> Result<bool, ()>\n+{\n+    match (actual_closure_kind, trait_closure_kind) {\n         (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n         (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n         (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) => {\n             // No adapter needed.\n-            llfn\n+           Ok(false)\n         }\n         (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n             // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n             // `fn(&mut self, ...)`. In fact, at trans time, these are\n             // basically the same thing, so we can just return llfn.\n-            llfn\n+            Ok(false)\n         }\n         (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n         (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n@@ -257,13 +276,9 @@ fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n             //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n             //\n             // These are both the same at trans time.\n-            trans_fn_once_adapter_shim(ccx, def_id, substs, method_instance, llfn)\n-        }\n-        _ => {\n-            bug!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n-                 llfn_closure_kind,\n-                 trait_closure_kind);\n+            Ok(true)\n         }\n+        _ => Err(()),\n     }\n }\n "}, {"sha": "094f293e5eba2f3fa995af08f4f8149cb89ab690", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 99, "deletions": 15, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/05768690857636f27e17c825de791491a88784e7/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05768690857636f27e17c825de791491a88784e7/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=05768690857636f27e17c825de791491a88784e7", "patch": "@@ -205,6 +205,7 @@ use rustc::mir::visit::Visitor as MirVisitor;\n use syntax::abi::Abi;\n use syntax_pos::DUMMY_SP;\n use base::custom_coerce_unsize_info;\n+use callee::needs_fn_once_adapter_shim;\n use context::SharedCrateContext;\n use common::fulfill_obligation;\n use glue::{self, DropGlueKind};\n@@ -568,7 +569,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                 callee_substs,\n                                                 self.param_substs);\n \n-            if let Some((callee_def_id, callee_substs)) = dispatched {\n+            if let StaticDispatchResult::Dispatched {\n+                    def_id: callee_def_id,\n+                    substs: callee_substs,\n+                    fn_once_adjustment,\n+                } = dispatched {\n                 // if we have a concrete impl (which we might not have\n                 // in the case of something compiler generated like an\n                 // object shim or a closure that is handled differently),\n@@ -581,6 +586,17 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                                                           callee_substs,\n                                                           self.param_substs);\n                     self.output.push(trans_item);\n+\n+                    // This call will instantiate an FnOnce adapter, which drops\n+                    // the closure environment. Therefore we need to make sure\n+                    // that we collect the drop-glue for the environment type.\n+                    if let Some(env_ty) = fn_once_adjustment {\n+                        let env_ty = glue::get_drop_glue_type(self.scx, env_ty);\n+                        if self.scx.type_needs_drop(env_ty) {\n+                            let dg = DropGlueKind::Ty(env_ty);\n+                            self.output.push(TransItem::DropGlue(dg));\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -793,15 +809,13 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n             bug!(\"encountered unexpected type\");\n         }\n     }\n-\n-\n }\n \n fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                 fn_def_id: DefId,\n                                 fn_substs: &'tcx Substs<'tcx>,\n                                 param_substs: &'tcx Substs<'tcx>)\n-                                -> Option<(DefId, &'tcx Substs<'tcx>)> {\n+                                -> StaticDispatchResult<'tcx> {\n     debug!(\"do_static_dispatch(fn_def_id={}, fn_substs={:?}, param_substs={:?})\",\n            def_id_to_string(scx.tcx(), fn_def_id),\n            fn_substs,\n@@ -818,18 +832,38 @@ fn do_static_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         debug!(\" => regular function\");\n         // The function is not part of an impl or trait, no dispatching\n         // to be done\n-        Some((fn_def_id, fn_substs))\n+        StaticDispatchResult::Dispatched {\n+            def_id: fn_def_id,\n+            substs: fn_substs,\n+            fn_once_adjustment: None,\n+        }\n     }\n }\n \n+enum StaticDispatchResult<'tcx> {\n+    // The call could be resolved statically as going to the method with\n+    // `def_id` and `substs`.\n+    Dispatched {\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+\n+        // If this is a call to a closure that needs an FnOnce adjustment,\n+        // this contains the new self type of the call (= type of the closure\n+        // environment)\n+        fn_once_adjustment: Option<ty::Ty<'tcx>>,\n+    },\n+    // This goes to somewhere that we don't know at compile-time\n+    Unknown\n+}\n+\n // Given a trait-method and substitution information, find out the actual\n // implementation of the trait method.\n fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n                                              trait_method: &ty::AssociatedItem,\n                                              trait_id: DefId,\n                                              callee_substs: &'tcx Substs<'tcx>,\n                                              param_substs: &'tcx Substs<'tcx>)\n-                                             -> Option<(DefId, &'tcx Substs<'tcx>)> {\n+                                             -> StaticDispatchResult<'tcx> {\n     let tcx = scx.tcx();\n     debug!(\"do_static_trait_method_dispatch(trait_method={}, \\\n                                             trait_id={}, \\\n@@ -850,17 +884,56 @@ fn do_static_trait_method_dispatch<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n     // the actual function:\n     match vtbl {\n         traits::VtableImpl(impl_data) => {\n-            Some(traits::find_method(tcx, trait_method.name, rcvr_substs, &impl_data))\n+            let (def_id, substs) = traits::find_method(tcx,\n+                                                       trait_method.name,\n+                                                       rcvr_substs,\n+                                                       &impl_data);\n+            StaticDispatchResult::Dispatched {\n+                def_id: def_id,\n+                substs: substs,\n+                fn_once_adjustment: None,\n+            }\n         }\n         traits::VtableClosure(closure_data) => {\n-            Some((closure_data.closure_def_id, closure_data.substs.substs))\n+            let closure_def_id = closure_data.closure_def_id;\n+            let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_id).unwrap();\n+            let actual_closure_kind = tcx.closure_kind(closure_def_id);\n+\n+            let needs_fn_once_adapter_shim =\n+                match needs_fn_once_adapter_shim(actual_closure_kind,\n+                                                 trait_closure_kind) {\n+                Ok(true) => true,\n+                _ => false,\n+            };\n+\n+            let fn_once_adjustment = if needs_fn_once_adapter_shim {\n+                Some(tcx.mk_closure_from_closure_substs(closure_def_id,\n+                                                        closure_data.substs))\n+            } else {\n+                None\n+            };\n+\n+            StaticDispatchResult::Dispatched {\n+                def_id: closure_def_id,\n+                substs: closure_data.substs.substs,\n+                fn_once_adjustment: fn_once_adjustment,\n+            }\n         }\n-        // Trait object and function pointer shims are always\n-        // instantiated in-place, and as they are just an ABI-adjusting\n-        // indirect call they do not have any dependencies.\n-        traits::VtableFnPointer(..) |\n+        traits::VtableFnPointer(ref data) => {\n+            // If we know the destination of this fn-pointer, we'll have to make\n+            // sure that this destination actually gets instantiated.\n+            if let ty::TyFnDef(def_id, substs, _) = data.fn_ty.sty {\n+                // The destination of the pointer might be something that needs\n+                // further dispatching, such as a trait method, so we do that.\n+                do_static_dispatch(scx, def_id, substs, param_substs)\n+            } else {\n+                StaticDispatchResult::Unknown\n+            }\n+        }\n+        // Trait object shims are always instantiated in-place, and as they are\n+        // just an ABI-adjusting indirect call they do not have any dependencies.\n         traits::VtableObject(..) => {\n-            None\n+            StaticDispatchResult::Unknown\n         }\n         _ => {\n             bug!(\"static call to invalid vtable: {:?}\", vtbl)\n@@ -994,8 +1067,19 @@ fn create_trans_items_for_vtable_methods<'a, 'tcx>(scx: &SharedCrateContext<'a,\n             // Walk all methods of the trait, including those of its supertraits\n             let methods = traits::get_vtable_methods(scx.tcx(), poly_trait_ref);\n             let methods = methods.filter_map(|method| method)\n-                .filter_map(|(def_id, substs)| do_static_dispatch(scx, def_id, substs,\n-                                                                  param_substs))\n+                .filter_map(|(def_id, substs)| {\n+                    if let StaticDispatchResult::Dispatched {\n+                        def_id,\n+                        substs,\n+                        // We already add the drop-glue for the closure env\n+                        // unconditionally below.\n+                        fn_once_adjustment: _ ,\n+                    } = do_static_dispatch(scx, def_id, substs, param_substs) {\n+                        Some((def_id, substs))\n+                    } else {\n+                        None\n+                    }\n+                })\n                 .filter(|&(def_id, _)| can_have_local_instance(scx.tcx(), def_id))\n                 .map(|(def_id, substs)| create_fn_trans_item(scx, def_id, substs, param_substs));\n             output.extend(methods);"}]}