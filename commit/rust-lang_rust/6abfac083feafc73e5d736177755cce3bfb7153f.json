{"sha": "6abfac083feafc73e5d736177755cce3bfb7153f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYmZhYzA4M2ZlYWZjNzNlNWQ3MzYxNzc3NTVjY2UzYmZiNzE1M2Y=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-30T18:51:18Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-12-31T01:06:08Z"}, "message": "Fallout from stabilization", "tree": {"sha": "d5502fab0dd68ea96057616eb20d90a2c9050218", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5502fab0dd68ea96057616eb20d90a2c9050218"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6abfac083feafc73e5d736177755cce3bfb7153f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6abfac083feafc73e5d736177755cce3bfb7153f", "html_url": "https://github.com/rust-lang/rust/commit/6abfac083feafc73e5d736177755cce3bfb7153f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6abfac083feafc73e5d736177755cce3bfb7153f/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e1879eaf1cb5e727eb134a3e27018f7535852eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e1879eaf1cb5e727eb134a3e27018f7535852eb", "html_url": "https://github.com/rust-lang/rust/commit/6e1879eaf1cb5e727eb134a3e27018f7535852eb"}], "stats": {"total": 835, "additions": 410, "deletions": 425}, "files": [{"sha": "d52de12ff5b292e7e9be43557755ea2d31bcb4e7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -32,6 +32,7 @@ use std::io::process;\n use std::io::timer;\n use std::io;\n use std::os;\n+use std::iter::repeat;\n use std::str;\n use std::string::String;\n use std::thread::Thread;\n@@ -976,8 +977,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n                          proc_res: &ProcRes) {\n \n     // true if we found the error in question\n-    let mut found_flags = Vec::from_elem(\n-        expected_errors.len(), false);\n+    let mut found_flags: Vec<_> = repeat(false).take(expected_errors.len()).collect();\n \n     if proc_res.status.success() {\n         fatal(\"process did not return an error status\");\n@@ -1337,7 +1337,7 @@ fn make_run_args(config: &Config, props: &TestProps, testfile: &Path) ->\n     // Add the arguments in the run_flags directive\n     args.extend(split_maybe_args(&props.run_flags).into_iter());\n \n-    let prog = args.remove(0).unwrap();\n+    let prog = args.remove(0);\n     return ProcArgs {\n         prog: prog,\n         args: args,"}, {"sha": "67058ea6a619391fe96e590471042a77d8375ac8", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -95,7 +95,7 @@ use heap::deallocate;\n /// use std::thread::Thread;\n ///\n /// fn main() {\n-///     let numbers = Vec::from_fn(100, |i| i as f32);\n+///     let numbers: Vec<_> = range(0, 100u32).map(|i| i as f32).collect();\n ///     let shared_numbers = Arc::new(numbers);\n ///\n ///     for _ in range(0u, 10) {"}, {"sha": "0834eacabd09e2ccfe8d2215169d808a7dc22ba0", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -66,7 +66,7 @@\n //! // for a simpler implementation.\n //! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: uint, goal: uint) -> uint {\n //!     // dist[node] = current shortest distance from `start` to `node`\n-//!     let mut dist = Vec::from_elem(adj_list.len(), uint::MAX);\n+//!     let mut dist: Vec<_> = range(0, adj_list.len()).map(|_| uint::MAX).collect();\n //!\n //!     let mut heap = BinaryHeap::new();\n //!"}, {"sha": "12faf3b5d5f253c3379abd94d8f2d41f0577e73a", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -85,7 +85,7 @@ use core::prelude::*;\n use core::cmp;\n use core::default::Default;\n use core::fmt;\n-use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take};\n+use core::iter::{Cloned, Chain, Enumerate, Repeat, Skip, Take, repeat};\n use core::iter;\n use core::num::Int;\n use core::slice::{Iter, IterMut};\n@@ -267,7 +267,7 @@ impl Bitv {\n     pub fn from_elem(nbits: uint, bit: bool) -> Bitv {\n         let nblocks = blocks_for_bits(nbits);\n         let mut bitv = Bitv {\n-            storage: Vec::from_elem(nblocks, if bit { !0u32 } else { 0u32 }),\n+            storage: repeat(if bit { !0u32 } else { 0u32 }).take(nblocks).collect(),\n             nbits: nbits\n         };\n         bitv.fix_last_block();\n@@ -651,7 +651,7 @@ impl Bitv {\n \n         let len = self.nbits/8 +\n                   if self.nbits % 8 == 0 { 0 } else { 1 };\n-        Vec::from_fn(len, |i|\n+        range(0, len).map(|i|\n             bit(self, i, 0) |\n             bit(self, i, 1) |\n             bit(self, i, 2) |\n@@ -660,7 +660,7 @@ impl Bitv {\n             bit(self, i, 5) |\n             bit(self, i, 6) |\n             bit(self, i, 7)\n-        )\n+        ).collect()\n     }\n \n     /// Deprecated: Use `iter().collect()`.\n@@ -834,7 +834,7 @@ impl Bitv {\n         // Allocate new words, if needed\n         if new_nblocks > self.storage.len() {\n             let to_add = new_nblocks - self.storage.len();\n-            self.storage.grow(to_add, full_value);\n+            self.storage.extend(repeat(full_value).take(to_add));\n         }\n \n         // Adjust internal bit count"}, {"sha": "9ed7cb18bc89cae51d1fecf179aca08c8bd7466d", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -554,10 +554,10 @@ impl <K, V> Node<K, V> {\n         let node = mem::replace(left_and_out, unsafe { Node::new_internal(capacity_from_b(b)) });\n         left_and_out._len = 1;\n         unsafe {\n-            ptr::write(left_and_out.keys_mut().unsafe_mut(0), key);\n-            ptr::write(left_and_out.vals_mut().unsafe_mut(0), value);\n-            ptr::write(left_and_out.edges_mut().unsafe_mut(0), node);\n-            ptr::write(left_and_out.edges_mut().unsafe_mut(1), right);\n+            ptr::write(left_and_out.keys_mut().get_unchecked_mut(0), key);\n+            ptr::write(left_and_out.vals_mut().get_unchecked_mut(0), value);\n+            ptr::write(left_and_out.edges_mut().get_unchecked_mut(0), node);\n+            ptr::write(left_and_out.edges_mut().get_unchecked_mut(1), right);\n         }\n     }\n \n@@ -636,7 +636,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a Node<K, V>, handle::Edge, handle::Internal> {\n     /// making it more suitable for moving down a chain of nodes.\n     pub fn into_edge(self) -> &'a Node<K, V> {\n         unsafe {\n-            self.node.edges().unsafe_get(self.index)\n+            self.node.edges().get_unchecked(self.index)\n         }\n     }\n }\n@@ -647,7 +647,7 @@ impl<'a, K: 'a, V: 'a> Handle<&'a mut Node<K, V>, handle::Edge, handle::Internal\n     /// `edge_mut`, making it more suitable for moving down a chain of nodes.\n     pub fn into_edge_mut(self) -> &'a mut Node<K, V> {\n         unsafe {\n-            self.node.edges_mut().unsafe_mut(self.index)\n+            self.node.edges_mut().get_unchecked_mut(self.index)\n         }\n     }\n }\n@@ -721,7 +721,7 @@ impl<K, V, NodeRef: DerefMut<Node<K, V>>> Handle<NodeRef, handle::Edge, handle::\n     /// confused with `node`, which references the parent node of what is returned here.\n     pub fn edge_mut(&mut self) -> &mut Node<K, V> {\n         unsafe {\n-            self.node.edges_mut().unsafe_mut(self.index)\n+            self.node.edges_mut().get_unchecked_mut(self.index)\n         }\n     }\n \n@@ -829,8 +829,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a Node<K, V>, handle::KV, NodeType> {\n         let (keys, vals) = self.node.as_slices();\n         unsafe {\n             (\n-                keys.unsafe_get(self.index),\n-                vals.unsafe_get(self.index)\n+                keys.get_unchecked(self.index),\n+                vals.get_unchecked(self.index)\n             )\n         }\n     }\n@@ -844,8 +844,8 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<&'a mut Node<K, V>, handle::KV, NodeType\n         let (keys, vals) = self.node.as_slices_mut();\n         unsafe {\n             (\n-                keys.unsafe_mut(self.index),\n-                vals.unsafe_mut(self.index)\n+                keys.get_unchecked_mut(self.index),\n+                vals.get_unchecked_mut(self.index)\n             )\n         }\n     }\n@@ -869,14 +869,14 @@ impl<'a, K: 'a, V: 'a, NodeRef: Deref<Node<K, V>> + 'a, NodeType> Handle<NodeRef\n     // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     // /// handle.\n     // pub fn key(&'a self) -> &'a K {\n-    //     unsafe { self.node.keys().unsafe_get(self.index) }\n+    //     unsafe { self.node.keys().get_unchecked(self.index) }\n     // }\n     //\n     // /// Returns a reference to the value pointed-to by this handle. This doesn't return a\n     // /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     // /// handle.\n     // pub fn val(&'a self) -> &'a V {\n-    //     unsafe { self.node.vals().unsafe_get(self.index) }\n+    //     unsafe { self.node.vals().get_unchecked(self.index) }\n     // }\n }\n \n@@ -886,14 +886,14 @@ impl<'a, K: 'a, V: 'a, NodeRef: DerefMut<Node<K, V>> + 'a, NodeType> Handle<Node\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n     pub fn key_mut(&'a mut self) -> &'a mut K {\n-        unsafe { self.node.keys_mut().unsafe_mut(self.index) }\n+        unsafe { self.node.keys_mut().get_unchecked_mut(self.index) }\n     }\n \n     /// Returns a mutable reference to the value pointed-to by this handle. This doesn't return a\n     /// reference with a lifetime as large as `into_kv_mut`, but it also does not consume the\n     /// handle.\n     pub fn val_mut(&'a mut self) -> &'a mut V {\n-        unsafe { self.node.vals_mut().unsafe_mut(self.index) }\n+        unsafe { self.node.vals_mut().get_unchecked_mut(self.index) }\n     }\n }\n \n@@ -1077,7 +1077,7 @@ impl<K, V> Node<K, V> {\n         debug_assert!(!self.is_leaf());\n \n         unsafe {\n-            let ret = ptr::read(self.edges().unsafe_get(0));\n+            let ret = ptr::read(self.edges().get_unchecked(0));\n             self.destroy();\n             ptr::write(self, ret);\n         }\n@@ -1091,8 +1091,8 @@ impl<K, V> Node<K, V> {\n     unsafe fn push_kv(&mut self, key: K, val: V) {\n         let len = self.len();\n \n-        ptr::write(self.keys_mut().unsafe_mut(len), key);\n-        ptr::write(self.vals_mut().unsafe_mut(len), val);\n+        ptr::write(self.keys_mut().get_unchecked_mut(len), key);\n+        ptr::write(self.vals_mut().get_unchecked_mut(len), val);\n \n         self._len += 1;\n     }\n@@ -1102,7 +1102,7 @@ impl<K, V> Node<K, V> {\n     unsafe fn push_edge(&mut self, edge: Node<K, V>) {\n         let len = self.len();\n \n-        ptr::write(self.edges_mut().unsafe_mut(len), edge);\n+        ptr::write(self.edges_mut().get_unchecked_mut(len), edge);\n     }\n \n     // This must be followed by insert_edge on an internal node.\n@@ -1119,12 +1119,12 @@ impl<K, V> Node<K, V> {\n             self.len() - index\n         );\n \n-        ptr::write(self.keys_mut().unsafe_mut(index), key);\n-        ptr::write(self.vals_mut().unsafe_mut(index), val);\n+        ptr::write(self.keys_mut().get_unchecked_mut(index), key);\n+        ptr::write(self.vals_mut().get_unchecked_mut(index), val);\n \n         self._len += 1;\n \n-        self.vals_mut().unsafe_mut(index)\n+        self.vals_mut().get_unchecked_mut(index)\n     }\n \n     // This can only be called immediately after a call to insert_kv.\n@@ -1135,14 +1135,14 @@ impl<K, V> Node<K, V> {\n             self.edges().as_ptr().offset(index as int),\n             self.len() - index\n         );\n-        ptr::write(self.edges_mut().unsafe_mut(index), edge);\n+        ptr::write(self.edges_mut().get_unchecked_mut(index), edge);\n     }\n \n     // This must be followed by pop_edge on an internal node.\n     #[inline]\n     unsafe fn pop_kv(&mut self) -> (K, V) {\n-        let key = ptr::read(self.keys().unsafe_get(self.len() - 1));\n-        let val = ptr::read(self.vals().unsafe_get(self.len() - 1));\n+        let key = ptr::read(self.keys().get_unchecked(self.len() - 1));\n+        let val = ptr::read(self.vals().get_unchecked(self.len() - 1));\n \n         self._len -= 1;\n \n@@ -1152,16 +1152,16 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to pop_kv.\n     #[inline]\n     unsafe fn pop_edge(&mut self) -> Node<K, V> {\n-        let edge = ptr::read(self.edges().unsafe_get(self.len() + 1));\n+        let edge = ptr::read(self.edges().get_unchecked(self.len() + 1));\n \n         edge\n     }\n \n     // This must be followed by remove_edge on an internal node.\n     #[inline]\n     unsafe fn remove_kv(&mut self, index: uint) -> (K, V) {\n-        let key = ptr::read(self.keys().unsafe_get(index));\n-        let val = ptr::read(self.vals().unsafe_get(index));\n+        let key = ptr::read(self.keys().get_unchecked(index));\n+        let val = ptr::read(self.vals().get_unchecked(index));\n \n         ptr::copy_memory(\n             self.keys_mut().as_mut_ptr().offset(index as int),\n@@ -1182,7 +1182,7 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to remove_kv.\n     #[inline]\n     unsafe fn remove_edge(&mut self, index: uint) -> Node<K, V> {\n-        let edge = ptr::read(self.edges().unsafe_get(index));\n+        let edge = ptr::read(self.edges().get_unchecked(index));\n \n         ptr::copy_memory(\n             self.edges_mut().as_mut_ptr().offset(index as int),\n@@ -1229,8 +1229,8 @@ impl<K, V> Node<K, V> {\n                 );\n             }\n \n-            let key = ptr::read(self.keys().unsafe_get(right_offset - 1));\n-            let val = ptr::read(self.vals().unsafe_get(right_offset - 1));\n+            let key = ptr::read(self.keys().get_unchecked(right_offset - 1));\n+            let val = ptr::read(self.vals().get_unchecked(right_offset - 1));\n \n             self._len = right_offset - 1;\n \n@@ -1249,8 +1249,8 @@ impl<K, V> Node<K, V> {\n             let old_len = self.len();\n             self._len += right.len() + 1;\n \n-            ptr::write(self.keys_mut().unsafe_mut(old_len), key);\n-            ptr::write(self.vals_mut().unsafe_mut(old_len), val);\n+            ptr::write(self.keys_mut().get_unchecked_mut(old_len), key);\n+            ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n             ptr::copy_nonoverlapping_memory(\n                 self.keys_mut().as_mut_ptr().offset(old_len as int + 1),"}, {"sha": "4eaaad07c994f48a14a322bb5c248840526d0b02", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -1290,8 +1290,10 @@ mod tests {\n                     v.pop();\n                 }\n                 1 => {\n-                    m.pop_front();\n-                    v.remove(0);\n+                    if !v.is_empty() {\n+                        m.pop_front();\n+                        v.remove(0);\n+                    }\n                 }\n                 2 | 4 =>  {\n                     m.push_front(-i);"}, {"sha": "688214140c1be1ec999bd24dc1b9ca3d6a0e8e50", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -128,8 +128,8 @@ mod prelude {\n     pub use unicode::char::UnicodeChar;\n \n     // from collections.\n-    pub use slice::{CloneSliceExt, VectorVector};\n-    pub use str::{IntoMaybeOwned, StrVector};\n+    pub use slice::{CloneSliceExt, SliceConcatExt};\n+    pub use str::IntoMaybeOwned;\n     pub use string::{String, ToString};\n     pub use vec::Vec;\n }"}, {"sha": "82b24e627d99b82d472e4c46da9ace6788a287cf", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -1137,7 +1137,7 @@ impl<'a, T> Iterator<&'a T> for Iter<'a, T> {\n         }\n         let tail = self.tail;\n         self.tail = wrap_index(self.tail + 1, self.ring.len());\n-        unsafe { Some(self.ring.unsafe_get(tail)) }\n+        unsafe { Some(self.ring.get_unchecked(tail)) }\n     }\n \n     #[inline]\n@@ -1154,7 +1154,7 @@ impl<'a, T> DoubleEndedIterator<&'a T> for Iter<'a, T> {\n             return None;\n         }\n         self.head = wrap_index(self.head - 1, self.ring.len());\n-        unsafe { Some(self.ring.unsafe_get(self.head)) }\n+        unsafe { Some(self.ring.get_unchecked(self.head)) }\n     }\n }\n \n@@ -1173,7 +1173,7 @@ impl<'a, T> RandomAccessIterator<&'a T> for Iter<'a, T> {\n             None\n         } else {\n             let idx = wrap_index(self.tail + j, self.ring.len());\n-            unsafe { Some(self.ring.unsafe_get(idx)) }\n+            unsafe { Some(self.ring.get_unchecked(idx)) }\n         }\n     }\n }"}, {"sha": "385380bb7978e480499bb71590ea0172e1703cf1", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 71, "deletions": 57, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -96,20 +96,26 @@ use core::mem::size_of;\n use core::mem;\n use core::ops::{FnMut,SliceMut};\n use core::prelude::{Clone, Greater, Iterator, IteratorExt, Less, None, Option};\n-use core::prelude::{Ord, Ordering, RawPtr, Some, range, IteratorCloneExt, Result};\n+use core::prelude::{Ord, Ordering, PtrExt, Some, range, IteratorCloneExt, Result};\n use core::ptr;\n use core::slice as core_slice;\n use self::Direction::*;\n \n use vec::Vec;\n \n-pub use core::slice::{Chunks, AsSlice, SplitN, Windows};\n+pub use core::slice::{Chunks, AsSlice, Windows};\n pub use core::slice::{Iter, IterMut, PartialEqSliceExt};\n pub use core::slice::{IntSliceExt, SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n pub use core::slice::{bytes, mut_ref_slice, ref_slice};\n pub use core::slice::{from_raw_buf, from_raw_mut_buf};\n \n+#[deprecated = \"use Iter instead\"]\n+pub type Items<'a, T:'a> = Iter<'a, T>;\n+\n+#[deprecated = \"use IterMut instead\"]\n+pub type MutItems<'a, T:'a> = IterMut<'a, T>;\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1412,7 +1418,7 @@ mod tests {\n     use prelude::{Some, None, range, Vec, ToString, Clone, Greater, Less, Equal};\n     use prelude::{SliceExt, Iterator, IteratorExt, DoubleEndedIteratorExt};\n     use prelude::{OrdSliceExt, CloneSliceExt, PartialEqSliceExt, AsSlice};\n-    use prelude::{RandomAccessIterator, Ord, VectorVector};\n+    use prelude::{RandomAccessIterator, Ord, SliceConcatExt};\n     use core::cell::Cell;\n     use core::default::Default;\n     use core::mem;\n@@ -1678,15 +1684,19 @@ mod tests {\n     fn test_swap_remove() {\n         let mut v = vec![1i, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n-        assert_eq!(e, Some(1));\n+        assert_eq!(e, 1);\n         assert_eq!(v, vec![5i, 2, 3, 4]);\n         e = v.swap_remove(3);\n-        assert_eq!(e, Some(4));\n+        assert_eq!(e, 4);\n         assert_eq!(v, vec![5i, 2, 3]);\n+    }\n \n-        e = v.swap_remove(3);\n-        assert_eq!(e, None);\n-        assert_eq!(v, vec![5i, 2, 3]);\n+    #[test]\n+    #[should_fail]\n+    fn test_swap_remove_fail() {\n+        let mut v = vec![1i];\n+        let _ = v.swap_remove(0);\n+        let _ = v.swap_remove(0);\n     }\n \n     #[test]\n@@ -1970,48 +1980,48 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_binary_search_elem() {\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&5).found(), Some(4));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&4).found(), Some(3));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&3).found(), Some(2));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&2).found(), Some(1));\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&1).found(), Some(0));\n+    fn test_binary_search() {\n+        assert_eq!([1i,2,3,4,5].binary_search(&5).ok(), Some(4));\n+        assert_eq!([1i,2,3,4,5].binary_search(&4).ok(), Some(3));\n+        assert_eq!([1i,2,3,4,5].binary_search(&3).ok(), Some(2));\n+        assert_eq!([1i,2,3,4,5].binary_search(&2).ok(), Some(1));\n+        assert_eq!([1i,2,3,4,5].binary_search(&1).ok(), Some(0));\n \n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&4).found(), Some(1));\n-        assert_eq!([2i,4,6,8,10].binary_search_elem(&10).found(), Some(4));\n+        assert_eq!([2i,4,6,8,10].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4,6,8,10].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2i,4,6,8,10].binary_search(&10).ok(), Some(4));\n \n-        assert_eq!([2i,4,6,8].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4,6,8].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4,6,8].binary_search_elem(&4).found(), Some(1));\n-        assert_eq!([2i,4,6,8].binary_search_elem(&8).found(), Some(3));\n+        assert_eq!([2i,4,6,8].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4,6,8].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4,6,8].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2i,4,6,8].binary_search(&8).ok(), Some(3));\n \n-        assert_eq!([2i,4,6].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4,6].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4,6].binary_search_elem(&4).found(), Some(1));\n-        assert_eq!([2i,4,6].binary_search_elem(&6).found(), Some(2));\n+        assert_eq!([2i,4,6].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4,6].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4,6].binary_search(&4).ok(), Some(1));\n+        assert_eq!([2i,4,6].binary_search(&6).ok(), Some(2));\n \n-        assert_eq!([2i,4].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i,4].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i,4].binary_search_elem(&2).found(), Some(0));\n-        assert_eq!([2i,4].binary_search_elem(&4).found(), Some(1));\n+        assert_eq!([2i,4].binary_search(&1).ok(), None);\n+        assert_eq!([2i,4].binary_search(&5).ok(), None);\n+        assert_eq!([2i,4].binary_search(&2).ok(), Some(0));\n+        assert_eq!([2i,4].binary_search(&4).ok(), Some(1));\n \n-        assert_eq!([2i].binary_search_elem(&1).found(), None);\n-        assert_eq!([2i].binary_search_elem(&5).found(), None);\n-        assert_eq!([2i].binary_search_elem(&2).found(), Some(0));\n+        assert_eq!([2i].binary_search(&1).ok(), None);\n+        assert_eq!([2i].binary_search(&5).ok(), None);\n+        assert_eq!([2i].binary_search(&2).ok(), Some(0));\n \n-        assert_eq!([].binary_search_elem(&1i).found(), None);\n-        assert_eq!([].binary_search_elem(&5i).found(), None);\n+        assert_eq!([].binary_search(&1i).ok(), None);\n+        assert_eq!([].binary_search(&5i).ok(), None);\n \n-        assert!([1i,1,1,1,1].binary_search_elem(&1).found() != None);\n-        assert!([1i,1,1,1,2].binary_search_elem(&1).found() != None);\n-        assert!([1i,1,1,2,2].binary_search_elem(&1).found() != None);\n-        assert!([1i,1,2,2,2].binary_search_elem(&1).found() != None);\n-        assert_eq!([1i,2,2,2,2].binary_search_elem(&1).found(), Some(0));\n+        assert!([1i,1,1,1,1].binary_search(&1).ok() != None);\n+        assert!([1i,1,1,1,2].binary_search(&1).ok() != None);\n+        assert!([1i,1,1,2,2].binary_search(&1).ok() != None);\n+        assert!([1i,1,2,2,2].binary_search(&1).ok() != None);\n+        assert_eq!([1i,2,2,2,2].binary_search(&1).ok(), Some(0));\n \n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&6).found(), None);\n-        assert_eq!([1i,2,3,4,5].binary_search_elem(&0).found(), None);\n+        assert_eq!([1i,2,3,4,5].binary_search(&6).ok(), None);\n+        assert_eq!([1i,2,3,4,5].binary_search(&0).ok(), None);\n     }\n \n     #[test]\n@@ -2106,13 +2116,15 @@ mod tests {\n     #[test]\n     fn test_concat() {\n         let v: [Vec<int>, ..0] = [];\n-        assert_eq!(v.concat_vec(), vec![]);\n-        assert_eq!([vec![1i], vec![2i,3i]].concat_vec(), vec![1, 2, 3]);\n+        let c: Vec<int> = v.concat();\n+        assert_eq!(c, []);\n+        let d: Vec<int> = [vec![1i], vec![2i,3i]].concat();\n+        assert_eq!(d, vec![1i, 2, 3]);\n \n         let v: [&[int], ..2] = [&[1], &[2, 3]];\n-        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 3]);\n-        let v: [&[int], ..3] = [&[1], &[2], &[3]];\n-        assert_eq!(v.connect_vec(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), vec![1i, 0, 2, 3]);\n+        let v: [&[int], ..3] = [&[1i], &[2], &[3]];\n+        assert_eq!(v.connect(&0), vec![1i, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -2158,23 +2170,25 @@ mod tests {\n     fn test_remove() {\n         let mut a = vec![1i,2,3,4];\n \n-        assert_eq!(a.remove(2), Some(3));\n+        assert_eq!(a.remove(2), 3);\n         assert_eq!(a, vec![1i,2,4]);\n \n-        assert_eq!(a.remove(2), Some(4));\n-        assert_eq!(a, vec![1i,2]);\n-\n-        assert_eq!(a.remove(2), None);\n+        assert_eq!(a.remove(2), 4);\n         assert_eq!(a, vec![1i,2]);\n \n-        assert_eq!(a.remove(0), Some(1));\n+        assert_eq!(a.remove(0), 1);\n         assert_eq!(a, vec![2i]);\n \n-        assert_eq!(a.remove(0), Some(2));\n+        assert_eq!(a.remove(0), 2);\n         assert_eq!(a, vec![]);\n+    }\n \n-        assert_eq!(a.remove(0), None);\n-        assert_eq!(a.remove(10), None);\n+    #[test]\n+    #[should_fail]\n+    fn test_remove_fail() {\n+        let mut a = vec![1i];\n+        let _ = a.remove(0);\n+        let _ = a.remove(0);\n     }\n \n     #[test]\n@@ -2870,7 +2884,7 @@ mod bench {\n         let xss: Vec<Vec<uint>> =\n             Vec::from_fn(100, |i| range(0u, i).collect());\n         b.iter(|| {\n-            xss.as_slice().concat_vec()\n+            xss.as_slice().concat();\n         });\n     }\n "}, {"sha": "8d5d76f9598f4a400b0a482399222cf78539b8e2", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 28, "deletions": 60, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -96,40 +96,43 @@ Section: Creating a string\n \n impl<S: Str> SliceConcatExt<str, String> for [S] {\n     fn concat(&self) -> String {\n-        if self.is_empty() {\n+        let s = self.as_slice();\n+\n+        if s.is_empty() {\n             return String::new();\n         }\n \n         // `len` calculation may overflow but push_str will check boundaries\n-        let len = self.iter().map(|s| s.as_slice().len()).sum();\n-\n+        let len = s.iter().map(|s| s.as_slice().len()).sum();\n         let mut result = String::with_capacity(len);\n \n-        for s in self.iter() {\n-            result.push_str(s.as_slice());\n+        for s in s.iter() {\n+            result.push_str(s.as_slice())\n         }\n \n         result\n     }\n \n     fn connect(&self, sep: &str) -> String {\n-        if self.is_empty() {\n+        let s = self.as_slice();\n+\n+        if s.is_empty() {\n             return String::new();\n         }\n \n         // concat is faster\n         if sep.is_empty() {\n-            return self.concat();\n+            return s.concat();\n         }\n \n         // this is wrong without the guarantee that `self` is non-empty\n         // `len` calculation may overflow but push_str but will check boundaries\n-        let len = sep.len() * (self.len() - 1)\n-            + self.iter().map(|s| s.as_slice().len()).sum();\n+        let len = sep.len() * (s.len() - 1)\n+            + s.iter().map(|s| s.as_slice().len()).sum();\n         let mut result = String::with_capacity(len);\n         let mut first = true;\n \n-        for s in self.iter() {\n+        for s in s.iter() {\n             if first {\n                 first = false;\n             } else {\n@@ -141,11 +144,6 @@ impl<S: Str> SliceConcatExt<str, String> for [S] {\n     }\n }\n \n-impl<S: Str> SliceConcatExt<str, String> for Vec<S> {\n-    fn concat(&self) -> String { self[].concat() }\n-    fn connect(&self, sep: &str) -> String { self[].connect(sep) }\n-}\n-\n /*\n Section: Iterators\n */\n@@ -186,7 +184,7 @@ pub struct Decompositions<'a> {\n impl<'a> Iterator<char> for Decompositions<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        match self.buffer.head() {\n+        match self.buffer.first() {\n             Some(&(c, 0)) => {\n                 self.sorted = false;\n                 self.buffer.remove(0);\n@@ -233,13 +231,16 @@ impl<'a> Iterator<char> for Decompositions<'a> {\n             self.sorted = true;\n         }\n \n-        match self.buffer.remove(0) {\n-            Some((c, 0)) => {\n-                self.sorted = false;\n-                Some(c)\n+        if self.buffer.is_empty() {\n+            None\n+        } else {\n+            match self.buffer.remove(0) {\n+                (c, 0) => {\n+                    self.sorted = false;\n+                    Some(c)\n+                }\n+                (c, _) => Some(c),\n             }\n-            Some((c, _)) => Some(c),\n-            None => None\n         }\n     }\n \n@@ -712,7 +713,7 @@ pub trait StrExt for Sized?: ops::Slice<uint, str> {\n         if me.is_empty() { return t.chars().count(); }\n         if t.is_empty() { return me.chars().count(); }\n \n-        let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n+        let mut dcol: Vec<_> = range(0, t.len() + 1).collect();\n         let mut t_last = 0;\n \n         for (i, sc) in me.chars().enumerate() {\n@@ -1857,45 +1858,23 @@ mod tests {\n         assert_eq!(\"\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\", \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".slice_chars(2, 8));\n     }\n \n-    struct S {\n-        x: [String, .. 2]\n-    }\n-\n-    impl AsSlice<String> for S {\n-        fn as_slice<'a> (&'a self) -> &'a [String] {\n-            &self.x\n-        }\n-    }\n-\n     fn s(x: &str) -> String { x.into_string() }\n \n     macro_rules! test_concat {\n         ($expected: expr, $string: expr) => {\n             {\n-                let s = $string.concat();\n+                let s: String = $string.concat();\n                 assert_eq!($expected, s);\n             }\n         }\n     }\n \n     #[test]\n     fn test_concat_for_different_types() {\n-        test_concat!(\"ab\", [\"a\", \"b\"]);\n-        test_concat!(\"ab\", [s(\"a\"), s(\"b\")]);\n+        test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n         test_concat!(\"ab\", vec![\"a\", \"b\"]);\n         test_concat!(\"ab\", vec![\"a\", \"b\"].as_slice());\n         test_concat!(\"ab\", vec![s(\"a\"), s(\"b\")]);\n-\n-        let mut v0 = [\"a\", \"b\"];\n-        let mut v1 = [s(\"a\"), s(\"b\")];\n-        unsafe {\n-            use std::c_vec::CVec;\n-\n-            test_concat!(\"ab\", CVec::new(v0.as_mut_ptr(), v0.len()));\n-            test_concat!(\"ab\", CVec::new(v1.as_mut_ptr(), v1.len()));\n-        }\n-\n-        test_concat!(\"ab\", S { x: [s(\"a\"), s(\"b\")] });\n     }\n \n     #[test]\n@@ -1924,17 +1903,6 @@ mod tests {\n         test_connect!(\"a-b\", vec![\"a\", \"b\"], hyphen.as_slice());\n         test_connect!(\"a-b\", vec![\"a\", \"b\"].as_slice(), \"-\");\n         test_connect!(\"a-b\", vec![s(\"a\"), s(\"b\")], \"-\");\n-\n-        let mut v0 = [\"a\", \"b\"];\n-        let mut v1 = [s(\"a\"), s(\"b\")];\n-        unsafe {\n-            use std::c_vec::CVec;\n-\n-            test_connect!(\"a-b\", CVec::new(v0.as_mut_ptr(), v0.len()), \"-\");\n-            test_connect!(\"a-b\", CVec::new(v1.as_mut_ptr(), v1.len()), hyphen.as_slice());\n-        }\n-\n-        test_connect!(\"a-b\", S { x: [s(\"a\"), s(\"b\")] }, \"-\");\n     }\n \n     #[test]\n@@ -3304,7 +3272,7 @@ mod tests {\n #[cfg(test)]\n mod bench {\n     use super::*;\n-    use prelude::{SliceExt, IteratorExt, DoubleEndedIteratorExt};\n+    use prelude::{SliceExt, IteratorExt, DoubleEndedIteratorExt, SliceConcatExt};\n     use test::Bencher;\n     use test::black_box;\n \n@@ -3467,7 +3435,7 @@ mod bench {\n     fn bench_connect(b: &mut Bencher) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let sep = \"\u2192\";\n-        let v = [s, s, s, s, s, s, s, s, s, s];\n+        let v = vec![s, s, s, s, s, s, s, s, s, s];\n         b.iter(|| {\n             assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n         })"}, {"sha": "433384b625f4045f5486fac6beaf15d7c07d99b8", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -151,7 +151,7 @@ impl String {\n         let mut i = 0;\n         let total = v.len();\n         fn unsafe_get(xs: &[u8], i: uint) -> u8 {\n-            unsafe { *xs.unsafe_get(i) }\n+            unsafe { *xs.get_unchecked(i) }\n         }\n         fn safe_get(xs: &[u8], i: uint, total: uint) -> u8 {\n             if i >= total {"}, {"sha": "a694242d1ccaf62a5b2f8d7c9fca0b7c41762f9e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -173,8 +173,7 @@ impl<T> Vec<T> {\n     ///\n     /// It is important to note that this function does not specify the *length* of the returned\n     /// vector, but only the *capacity*. (For an explanation of the difference between length and\n-    /// capacity, see the main `Vec<T>` docs above, 'Capacity and reallocation'.) To create a\n-    /// vector of a given length, use `Vec::from_elem` or `Vec::from_fn`.\n+    /// capacity, see the main `Vec<T>` docs above, 'Capacity and reallocation'.)\n     ///\n     /// # Examples\n     ///\n@@ -272,7 +271,7 @@ impl<T> Vec<T> {\n     /// Deprecated: use `into_iter().partition(f)` instead.\n     #[inline]\n     #[deprecated = \"use into_iter().partition(f) instead\"]\n-    pub fn partition<F>(self, mut f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n+    pub fn partition<F>(self, f: F) -> (Vec<T>, Vec<T>) where F: FnMut(&T) -> bool {\n         self.into_iter().partition(f)\n     }\n \n@@ -298,7 +297,7 @@ impl<T> Vec<T> {\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted in the given\n-    /// `Vec`. The collection may reserve more space to avoid frequent reallocations.\n+    /// `Vec<T>`. The collection may reserve more space to avoid frequent reallocations.\n     ///\n     /// # Panics\n     ///\n@@ -322,7 +321,7 @@ impl<T> Vec<T> {\n     }\n \n     /// Reserves the minimum capacity for exactly `additional` more elements to\n-    /// be inserted in the given `Vec`. Does nothing if the capacity is already\n+    /// be inserted in the given `Vec<T>`. Does nothing if the capacity is already\n     /// sufficient.\n     ///\n     /// Note that the allocator may give the collection more space than it\n@@ -350,9 +349,10 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Shrinks the capacity of the vector as much as possible. It will drop\n-    /// down as close as possible to the length but the allocator may still\n-    /// inform the vector that there is space for a few more elements.\n+    /// Shrinks the capacity of the vector as much as possible.\n+    ///\n+    /// It will drop down as close as possible to the length but the allocator\n+    /// may still inform the vector that there is space for a few more elements.\n     ///\n     /// # Examples\n     ///\n@@ -370,19 +370,20 @@ impl<T> Vec<T> {\n         if self.len == 0 {\n             if self.cap != 0 {\n                 unsafe {\n-                    dealloc(self.ptr, self.cap)\n+                    dealloc(*self.ptr, self.cap)\n                 }\n                 self.cap = 0;\n             }\n         } else {\n             unsafe {\n                 // Overflow check is unnecessary as the vector is already at\n                 // least this large.\n-                self.ptr = reallocate(self.ptr as *mut u8,\n-                                      self.cap * mem::size_of::<T>(),\n-                                      self.len * mem::size_of::<T>(),\n-                                      mem::min_align_of::<T>()) as *mut T;\n-                if self.ptr.is_null() { ::alloc::oom() }\n+                let ptr = reallocate(*self.ptr as *mut u8,\n+                                     self.cap * mem::size_of::<T>(),\n+                                     self.len * mem::size_of::<T>(),\n+                                     mem::min_align_of::<T>()) as *mut T;\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n             }\n             self.cap = self.len;\n         }\n@@ -443,15 +444,15 @@ impl<T> Vec<T> {\n     pub fn as_mut_slice<'a>(&'a mut self) -> &'a mut [T] {\n         unsafe {\n             mem::transmute(RawSlice {\n-                data: self.ptr as *const T,\n+                data: *self.ptr as *const T,\n                 len: self.len,\n             })\n         }\n     }\n \n-    /// Creates a consuming iterator, that is, one that moves each\n-    /// value out of the vector (from start to end). The vector cannot\n-    /// be used after calling this.\n+    /// Creates a consuming iterator, that is, one that moves each value out of\n+    /// the vector (from start to end). The vector cannot be used after calling\n+    /// this.\n     ///\n     /// # Examples\n     ///\n@@ -466,9 +467,9 @@ impl<T> Vec<T> {\n     #[stable]\n     pub fn into_iter(self) -> IntoIter<T> {\n         unsafe {\n-            let ptr = self.ptr;\n+            let ptr = *self.ptr;\n             let cap = self.cap;\n-            let begin = self.ptr as *const T;\n+            let begin = ptr as *const T;\n             let end = if mem::size_of::<T>() == 0 {\n                 (ptr as uint + self.len()) as *const T\n             } else {\n@@ -512,13 +513,11 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n     ///\n-    /// assert_eq!(v.swap_remove(1), Some(\"bar\"));\n+    /// assert_eq!(v.swap_remove(1), \"bar\");\n     /// assert_eq!(v, vec![\"foo\", \"qux\", \"baz\"]);\n     ///\n-    /// assert_eq!(v.swap_remove(0), Some(\"foo\"));\n+    /// assert_eq!(v.swap_remove(0), \"foo\");\n     /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n-    ///\n-    /// assert_eq!(v.swap_remove(2), None);\n     /// ```\n     #[inline]\n     #[stable]\n@@ -577,11 +576,7 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// let mut v = vec![1i, 2, 3];\n-    /// assert_eq!(v.remove(1), Some(2));\n-    /// assert_eq!(v, vec![1, 3]);\n-    ///\n-    /// assert_eq!(v.remove(4), None);\n-    /// // v is unchanged:\n+    /// assert_eq!(v.remove(1), 2);\n     /// assert_eq!(v, vec![1, 3]);\n     /// ```\n     #[stable]\n@@ -1185,8 +1180,9 @@ impl<T> Vec<T> {\n             let size = capacity.checked_mul(mem::size_of::<T>())\n                                .expect(\"capacity overflow\");\n             unsafe {\n-                self.ptr = alloc_or_realloc(self.ptr, self.cap * mem::size_of::<T>(), size);\n-                if self.ptr.is_null() { ::alloc::oom() }\n+                let ptr = alloc_or_realloc(*self.ptr, self.cap * mem::size_of::<T>(), size);\n+                if ptr.is_null() { ::alloc::oom() }\n+                self.ptr = NonZero::new(ptr);\n             }\n             self.cap = capacity;\n         }\n@@ -2207,9 +2203,10 @@ mod tests {\n     }\n \n     #[test]\n+    #[should_fail]\n     fn test_swap_remove_empty() {\n         let mut vec: Vec<uint> = vec!();\n-        assert_eq!(vec.swap_remove(0), None);\n+        vec.swap_remove(0);\n     }\n \n     #[test]"}, {"sha": "42d4a28405c8b9028b0a542a8bdf990182a82b34", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -448,7 +448,7 @@ impl<V> VecMap<V> {\n     pub fn insert(&mut self, key: uint, value: V) -> Option<V> {\n         let len = self.v.len();\n         if len <= key {\n-            self.v.grow_fn(key - len + 1, |_| None);\n+            self.v.extend(range(0, key - len + 1).map(|_| None));\n         }\n         replace(&mut self.v[key], Some(value))\n     }"}, {"sha": "b0fd52896fe5726b078dba2e63b0162e454fa348", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -478,7 +478,7 @@ pub trait IteratorExt<A>: Iterator<A> {\n     ///\n     /// ```\n     /// let vec = vec![1i, 2i, 3i, 4i];\n-    /// let (even, odd): (Vec<int>, Vec<Int>) = vec.into_iter().partition(|&n| n % 2 == 0);\n+    /// let (even, odd): (Vec<int>, Vec<int>) = vec.into_iter().partition(|&n| n % 2 == 0);\n     /// assert_eq!(even, vec![2, 4]);\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```"}, {"sha": "1bf05247a671cb227e27552206da3edeb3c0264a", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -46,6 +46,8 @@ use num::Int;\n use ops::{FnMut, mod};\n use option::Option;\n use option::Option::{None, Some};\n+use result::Result;\n+use result::Result::{Ok, Err};\n use ptr;\n use ptr::PtrExt;\n use mem;\n@@ -237,7 +239,7 @@ impl<T> SliceExt<T> for [T] {\n     }\n \n     #[unstable]\n-    fn binary_search_by<F>(&self, mut f: F) -> Result where\n+    fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where\n         F: FnMut(&T) -> Ordering\n     {\n         let mut base : uint = 0;\n@@ -255,7 +257,7 @@ impl<T> SliceExt<T> for [T] {\n             }\n             lim >>= 1;\n         }\n-        Err(base);\n+        Err(base)\n     }\n \n     #[inline]"}, {"sha": "9ef7d6030593a008f24a6d22fb1477afcdcd5ead", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -8,30 +8,30 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::slice::BinarySearchResult::{Found, NotFound};\n+use core::result::Result::{Ok, Err};\n \n #[test]\n fn binary_search_not_found() {\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n     let b = [1i, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&6)) == Ok(3));\n     let b = [1i, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    assert!(b.binary_search_by(|v| v.cmp(&5)) == Err(3));\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&8)) == Found(4));\n+    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(4));\n     let b = [1i, 2, 4, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(4));\n+    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(4));\n     let b = [1i, 2, 4, 6, 7, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&8)) == Found(5));\n+    assert!(b.binary_search_by(|v| v.cmp(&8)) == Ok(5));\n     let b = [1i, 2, 4, 5, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(5));\n+    assert!(b.binary_search_by(|v| v.cmp(&7)) == Err(5));\n     let b = [1i, 2, 4, 5, 6, 8, 9];\n-    assert!(b.binary_search(|v| v.cmp(&0)) == NotFound(0));\n+    assert!(b.binary_search_by(|v| v.cmp(&0)) == Err(0));\n     let b = [1i, 2, 4, 5, 6, 8];\n-    assert!(b.binary_search(|v| v.cmp(&9)) == NotFound(6));\n+    assert!(b.binary_search_by(|v| v.cmp(&9)) == Err(6));\n }\n \n #[test]"}, {"sha": "0184222b9e0b660fea87cf2d43eaae35818d03d0", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -578,7 +578,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n \n     fn f(_x: uint) -> Vec<Optval> { return Vec::new(); }\n \n-    let mut vals = Vec::from_fn(n_opts, f);\n+    let mut vals: Vec<_> = range(0, n_opts).map(f).collect();\n     let mut free: Vec<String> = Vec::new();\n     let l = args.len();\n     let mut i = 0;"}, {"sha": "a76e5ebd08a8493ae4ff217f9863193350515e16", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -361,7 +361,7 @@ impl Isaac64Rng {\n         const MP_VEC: [(uint, uint), .. 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n         macro_rules! ind (\n             ($x:expr) => {\n-                *self.mem.unsafe_get(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n+                *self.mem.get_unchecked(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n             }\n         );\n \n@@ -375,13 +375,13 @@ impl Isaac64Rng {\n                             let mix = if $j == 0 {!mix} else {mix};\n \n                             unsafe {\n-                                let x = *self.mem.unsafe_get(base + mr_offset);\n-                                a = mix + *self.mem.unsafe_get(base + m2_offset);\n+                                let x = *self.mem.get_unchecked(base + mr_offset);\n+                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                *self.mem.unsafe_mut(base + mr_offset) = y;\n+                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n+                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );\n@@ -392,13 +392,13 @@ impl Isaac64Rng {\n                             let mix = if $j == 0 {!mix} else {mix};\n \n                             unsafe {\n-                                let x = *self.mem.unsafe_get(base + mr_offset);\n-                                a = mix + *self.mem.unsafe_get(base + m2_offset);\n+                                let x = *self.mem.get_unchecked(base + mr_offset);\n+                                a = mix + *self.mem.get_unchecked(base + m2_offset);\n                                 let y = ind!(x) + a + b;\n-                                *self.mem.unsafe_mut(base + mr_offset) = y;\n+                                *self.mem.get_unchecked_mut(base + mr_offset) = y;\n \n                                 b = ind!(y >> RAND_SIZE_64_LEN) + x;\n-                                *self.rsl.unsafe_mut(base + mr_offset) = b;\n+                                *self.rsl.get_unchecked_mut(base + mr_offset) = b;\n                             }\n                         }}\n                     );"}, {"sha": "fd0c54e8ed3a8fce98cb8b2a7d525463a005b167", "filename": "src/librbml/io.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -11,6 +11,7 @@\n use std::io::{IoError, IoResult, SeekStyle};\n use std::io;\n use std::slice;\n+use std::iter::repeat;\n \n static BUF_CAPACITY: uint = 128;\n \n@@ -87,7 +88,7 @@ impl Writer for SeekableMemWriter {\n             // currently are\n             let difference = self.pos as i64 - self.buf.len() as i64;\n             if difference > 0 {\n-                self.buf.grow(difference as uint, 0);\n+                self.buf.extend(repeat(0).take(difference as uint));\n             }\n \n             // Figure out what bytes will be used to overwrite what's currently"}, {"sha": "1476e6ab8a7068669c5e8b81edc13cb0e1bb2660", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -14,6 +14,7 @@\n pub use self::Inst::*;\n \n use std::cmp;\n+use std::iter::repeat;\n use parse;\n use parse::{\n     Flags, FLAG_EMPTY,\n@@ -157,7 +158,7 @@ impl<'r> Compiler<'r> {\n             Capture(cap, name, x) => {\n                 let len = self.names.len();\n                 if cap >= len {\n-                    self.names.grow(10 + cap - len, None)\n+                    self.names.extend(repeat(None).take(10 + cap - len))\n                 }\n                 self.names[cap] = name;\n "}, {"sha": "692a065299ca2b25a21d39c6f515a760c7fc87b9", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -18,7 +18,6 @@ use std::cmp;\n use std::fmt;\n use std::iter;\n use std::num;\n-use std::slice::BinarySearchResult;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n@@ -1028,9 +1027,9 @@ fn is_valid_cap(c: char) -> bool {\n }\n \n fn find_class(classes: NamedClasses, name: &str) -> Option<Vec<(char, char)>> {\n-    match classes.binary_search(|&(s, _)| s.cmp(name)) {\n-        BinarySearchResult::Found(i) => Some(classes[i].1.to_vec()),\n-        BinarySearchResult::NotFound(_) => None,\n+    match classes.binary_search_by(|&(s, _)| s.cmp(name)) {\n+        Ok(i) => Some(classes[i].1.to_vec()),\n+        Err(_) => None,\n     }\n }\n "}, {"sha": "72e0e559c805bb7f0192088050576b7e29d648f2", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -38,6 +38,7 @@ pub use self::StepState::*;\n \n use std::cmp;\n use std::mem;\n+use std::iter::repeat;\n use std::slice::SliceExt;\n use compile::{\n     Program,\n@@ -121,7 +122,7 @@ impl<'r, 't> Nfa<'r, 't> {\n         let mut clist = &mut Threads::new(self.which, ninsts, ncaps);\n         let mut nlist = &mut Threads::new(self.which, ninsts, ncaps);\n \n-        let mut groups = Vec::from_elem(ncaps * 2, None);\n+        let mut groups: Vec<_> = repeat(None).take(ncaps * 2).collect();\n \n         // Determine if the expression starts with a '^' so we can avoid\n         // simulating .*?\n@@ -227,8 +228,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                     let negate = flags & FLAG_NEGATED > 0;\n                     let casei = flags & FLAG_NOCASE > 0;\n                     let found = ranges.as_slice();\n-                    let found = found.binary_search(|&rc| class_cmp(casei, c, rc))\n-                        .found().is_some();\n+                    let found = found.binary_search_by(|&rc| class_cmp(casei, c, rc)).is_ok();\n                     if found ^ negate {\n                         self.add(nlist, pc+1, caps);\n                     }\n@@ -457,10 +457,10 @@ impl Threads {\n     fn new(which: MatchKind, num_insts: uint, ncaps: uint) -> Threads {\n         Threads {\n             which: which,\n-            queue: Vec::from_fn(num_insts, |_| {\n-                Thread { pc: 0, groups: Vec::from_elem(ncaps * 2, None) }\n-            }),\n-            sparse: Vec::from_elem(num_insts, 0u),\n+            queue: range(0, num_insts).map(|_| {\n+                Thread { pc: 0, groups: repeat(None).take(ncaps * 2).collect() }\n+            }).collect(),\n+            sparse: repeat(0u).take(num_insts).collect(),\n             size: 0,\n         }\n     }\n@@ -518,15 +518,15 @@ pub fn is_word(c: Option<char>) -> bool {\n     // Try the common ASCII case before invoking binary search.\n     match c {\n         '_' | '0' ... '9' | 'a' ... 'z' | 'A' ... 'Z' => true,\n-        _ => PERLW.binary_search(|&(start, end)| {\n+        _ => PERLW.binary_search_by(|&(start, end)| {\n             if c >= start && c <= end {\n                 Equal\n             } else if start > c {\n                 Greater\n             } else {\n                 Less\n             }\n-        }).found().is_some()\n+        }).is_ok()\n     }\n }\n "}, {"sha": "5d0532a621022eb6723685784600bb62014c8e37", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -1599,7 +1599,7 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     F: FnMut(&mut SeekableMemWriter, &T),\n     T: Hash,\n {\n-    let mut buckets: Vec<Vec<entry<T>>> = Vec::from_fn(256, |_| Vec::new());\n+    let mut buckets: Vec<Vec<entry<T>>> = range(0, 256u16).map(|_| Vec::new()).collect();\n     for elt in index.into_iter() {\n         let h = hash::hash(&elt.val) as uint;\n         buckets[h % 256].push(elt);"}, {"sha": "522e1d4d3b284a571ca9e952e408264dfcff1d43", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -611,9 +611,9 @@ fn is_useful(cx: &MatchCheckCtxt,\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n                                 let pat_slice = pats[];\n-                                let subpats = Vec::from_fn(arity, |i| {\n+                                let subpats: Vec<_> = range(0, arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n-                                });\n+                                }).collect();\n                                 vec![construct_witness(cx, &c, subpats, left_ty)]\n                             };\n                             result.extend(pats.into_iter().skip(arity));\n@@ -635,7 +635,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                 match is_useful(cx, &matrix, v.tail(), witness) {\n                     UsefulWithWitness(pats) => {\n                         let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = Vec::from_elem(arity, DUMMY_WILD_PAT);\n+                        let wild_pats: Vec<_> = repeat(DUMMY_WILD_PAT).take(arity).collect();\n                         let enum_pat = construct_witness(cx, &constructor, wild_pats, left_ty);\n                         let mut new_pats = vec![enum_pat];\n                         new_pats.extend(pats.into_iter());\n@@ -788,7 +788,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n     } = raw_pat(r[col]);\n     let head: Option<Vec<&Pat>> = match *node {\n         ast::PatWild(_) =>\n-            Some(Vec::from_elem(arity, DUMMY_WILD_PAT)),\n+            Some(repeat(DUMMY_WILD_PAT).take(arity).collect()),\n \n         ast::PatIdent(_, _, _) => {\n             let opt_def = cx.tcx.def_map.borrow().get(&pat_id).cloned();\n@@ -801,7 +801,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 } else {\n                     None\n                 },\n-                _ => Some(Vec::from_elem(arity, DUMMY_WILD_PAT))\n+                _ => Some(repeat(DUMMY_WILD_PAT).take(arity).collect())\n             }\n         }\n \n@@ -815,7 +815,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 DefVariant(..) | DefStruct(..) => {\n                     Some(match args {\n                         &Some(ref args) => args.iter().map(|p| &**p).collect(),\n-                        &None => Vec::from_elem(arity, DUMMY_WILD_PAT)\n+                        &None => repeat(DUMMY_WILD_PAT).take(arity).collect(),\n                     })\n                 }\n                 _ => None\n@@ -894,13 +894,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 // Fixed-length vectors.\n                 Single => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n+                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },\n                 Slice(length) if before.len() + after.len() <= length && slice.is_some() => {\n                     let mut pats: Vec<&Pat> = before.iter().map(|p| &**p).collect();\n-                    pats.grow_fn(arity - before.len() - after.len(), |_| DUMMY_WILD_PAT);\n+                    pats.extend(repeat(DUMMY_WILD_PAT).take(arity - before.len() - after.len()));\n                     pats.extend(after.iter().map(|p| &**p));\n                     Some(pats)\n                 },"}, {"sha": "6cf6065de19f0ee90e6942ac161cd4e88d5e91a4", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -21,6 +21,7 @@ use middle::cfg::CFGIndex;\n use middle::ty;\n use std::io;\n use std::uint;\n+use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_util::IdRange;\n use syntax::visit;\n@@ -203,9 +204,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let entry = if oper.initial_value() { uint::MAX } else {0};\n \n-        let gens = Vec::from_elem(num_nodes * words_per_id, 0);\n-        let kills = Vec::from_elem(num_nodes * words_per_id, 0);\n-        let on_entry = Vec::from_elem(num_nodes * words_per_id, entry);\n+        let gens: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n+        let kills: Vec<_> = repeat(0).take(num_nodes * words_per_id).collect();\n+        let on_entry: Vec<_> = repeat(entry).take(num_nodes * words_per_id).collect();\n \n         let nodeid_to_index = build_nodeid_to_index(decl, cfg);\n \n@@ -446,7 +447,7 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n                 changed: true\n             };\n \n-            let mut temp = Vec::from_elem(words_per_id, 0u);\n+            let mut temp: Vec<_> = repeat(0u).take(words_per_id).collect();\n             while propcx.changed {\n                 propcx.changed = false;\n                 propcx.reset(temp.as_mut_slice());"}, {"sha": "6f1c7af5b8628671494ec222c0bd538d91769c36", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -1187,7 +1187,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n         let mut new_ty = P(ty.clone());\n         let mut ty_queue = vec!(ty);\n         while !ty_queue.is_empty() {\n-            let cur_ty = ty_queue.remove(0).unwrap();\n+            let cur_ty = ty_queue.remove(0);\n             match cur_ty.node {\n                 ast::TyRptr(lt_opt, ref mut_ty) => {\n                     let rebuild = match lt_opt {"}, {"sha": "91fbaca26d113fdc67f0a5e0b04c34d33a7f4ef8", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -799,7 +799,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn next_ty_vars(&self, n: uint) -> Vec<Ty<'tcx>> {\n-        Vec::from_fn(n, |_i| self.next_ty_var())\n+        range(0, n).map(|_i| self.next_ty_var()).collect()\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {"}, {"sha": "7372bb267b06c853de1e77c1fe5e327af1cfb67f", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -34,6 +34,7 @@ use util::ppaux::Repr;\n \n use std::cell::{Cell, RefCell};\n use std::u32;\n+use std::iter::repeat;\n use syntax::ast;\n \n mod doc;\n@@ -975,7 +976,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        Vec::from_fn(self.num_vars() as uint, |_| {\n+        range(0, self.num_vars() as uint).map(|_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -984,7 +985,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 classification: Contracting,\n                 value: NoValue,\n             }\n-        })\n+        }).collect()\n     }\n \n     fn dump_constraints(&self) {\n@@ -1247,7 +1248,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations.\n-        let mut dup_vec = Vec::from_elem(self.num_vars() as uint, u32::MAX);\n+        let mut dup_vec: Vec<_> = repeat(u32::MAX).take(self.num_vars() as uint).collect();\n \n         let mut opt_graph = None;\n \n@@ -1308,7 +1309,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             }\n         }\n \n-        Vec::from_fn(self.num_vars() as uint, |idx| var_data[idx].value)\n+        range(0, self.num_vars() as uint).map(|idx| var_data[idx].value).collect()\n     }\n \n     fn construct_graph(&self) -> RegionGraph {"}, {"sha": "5be8d03e74359306afe6012ecda7e15ea5fb7abd", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -117,6 +117,7 @@ use util::nodemap::NodeMap;\n \n use std::{fmt, io, uint};\n use std::rc::Rc;\n+use std::iter::repeat;\n use syntax::ast::{mod, NodeId, Expr};\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::{mod, special_idents};\n@@ -575,8 +576,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         Liveness {\n             ir: ir,\n             s: specials,\n-            successors: Vec::from_elem(num_live_nodes, invalid_node()),\n-            users: Vec::from_elem(num_live_nodes * num_vars, invalid_users()),\n+            successors: repeat(invalid_node()).take(num_live_nodes).collect(),\n+            users: repeat(invalid_users()).take(num_live_nodes * num_vars).collect(),\n             loop_scope: Vec::new(),\n             break_ln: NodeMap::new(),\n             cont_ln: NodeMap::new(),\n@@ -1068,7 +1069,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 // the same bindings, and we also consider the first pattern to be\n                 // the \"authoritative\" set of ids\n                 let arm_succ =\n-                    self.define_bindings_in_arm_pats(arm.pats.head().map(|p| &**p),\n+                    self.define_bindings_in_arm_pats(arm.pats.first().map(|p| &**p),\n                                                      guard_succ);\n                 self.merge_from_succ(ln, arm_succ, first_merge);\n                 first_merge = false;\n@@ -1436,7 +1437,7 @@ fn check_arm(this: &mut Liveness, arm: &ast::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n-    this.arm_pats_bindings(arm.pats.head().map(|p| &**p), |this, ln, var, sp, id| {\n+    this.arm_pats_bindings(arm.pats.first().map(|p| &**p), |this, ln, var, sp, id| {\n         this.warn_about_unused(sp, id, ln, var);\n     });\n     visit::walk_arm(this, arm);\n@@ -1542,7 +1543,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 } else {\n                     let ends_with_stmt = match body.expr {\n                         None if body.stmts.len() > 0 =>\n-                            match body.stmts.last().unwrap().node {\n+                            match body.stmts.first().unwrap().node {\n                                 ast::StmtSemi(ref e, _) => {\n                                     ty::expr_ty(self.ir.tcx, &**e) == t_ret\n                                 },\n@@ -1553,7 +1554,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     self.ir.tcx.sess.span_err(\n                         sp, \"not all control paths return a value\");\n                     if ends_with_stmt {\n-                        let last_stmt = body.stmts.last().unwrap();\n+                        let last_stmt = body.stmts.first().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n                                                         last_stmt.span, sp);\n                         let span_semicolon = Span {"}, {"sha": "edba2839f37eabc9476b5c8a85df7aae6e9d74de", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -751,10 +751,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n-                let name = token::get_ident(path.segments\n-                                                .last()\n-                                                .unwrap()\n-                                                .identifier);\n+                let name = token::get_ident(path.segments.last().unwrap().identifier);\n                 let origdid = orig_def.def_id();\n                 self.ensure_public(span,\n                                    def,"}, {"sha": "e9504a92f7b460ef714c3d9f24faef02dc88e8da", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -296,7 +296,7 @@ impl<'a> LifetimeContext<'a> {\n         debug!(\"visit_early_late: referenced_idents={}\",\n                referenced_idents);\n \n-        let (early, late) = generics.lifetimes.clone().partition(\n+        let (early, late): (Vec<_>, _) = generics.lifetimes.iter().cloned().partition(\n             |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n         self.with(EarlyScope(early_space, &early, self.scope), move |old_scope, this| {"}, {"sha": "07da9853e558525d280845190bd51a345730bac9", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -323,7 +323,11 @@ impl<T> VecPerParamSpace<T> {\n                 SelfSpace => { self.self_limit -= 1; }\n                 FnSpace => {}\n             }\n-            self.content.remove(limit - 1)\n+            if self.content.is_empty() {\n+                None\n+            } else {\n+                Some(self.content.remove(limit - 1))\n+            }\n         }\n     }\n "}, {"sha": "e7c77b12499274360e9f3ce7bacbe6a75b87c836", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -14,7 +14,7 @@ pub fn lev_distance(me: &str, t: &str) -> uint {\n     if me.is_empty() { return t.chars().count(); }\n     if t.is_empty() { return me.chars().count(); }\n \n-    let mut dcol = Vec::from_fn(t.len() + 1, |x| x);\n+    let mut dcol: Vec<_> = range(0, t.len() + 1).collect();\n     let mut t_last = 0;\n \n     for (i, sc) in me.chars().enumerate() {"}, {"sha": "a7d1d3a23bd1345c941e74a729001fc690f7f4f2", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -14,7 +14,7 @@\n \n #![allow(deprecated)] // to_be32\n \n-use std::iter::range_step;\n+use std::iter::{range_step, repeat};\n use std::num::Int;\n use std::slice::bytes::{MutableByteVector, copy_memory};\n use serialize::hex::ToHex;\n@@ -258,7 +258,7 @@ pub trait Digest {\n     /// Convenience function that retrieves the result of a digest as a\n     /// newly allocated vec of bytes.\n     fn result_bytes(&mut self) -> Vec<u8> {\n-        let mut buf = Vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        let mut buf: Vec<u8> = repeat(0u8).take((self.output_bits()+7)/8).collect();\n         self.result(buf.as_mut_slice());\n         buf\n     }\n@@ -612,7 +612,7 @@ mod tests {\n     /// correct.\n     fn test_digest_1million_random<D: Digest>(digest: &mut D, blocksize: uint, expected: &str) {\n         let total_size = 1000000;\n-        let buffer = Vec::from_elem(blocksize * 2, 'a' as u8);\n+        let buffer: Vec<u8> = repeat('a' as u8).take(blocksize * 2).collect();\n         let mut rng = IsaacRng::new_unseeded();\n         let mut count = 0;\n "}, {"sha": "070ae1151aa6d4701e305057cd84bdb4471b9662", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -25,7 +25,6 @@ use rustc::middle::mem_categorization as mc;\n use rustc::util::ppaux::{Repr, UserString};\n use std::mem;\n use std::rc::Rc;\n-use std::slice;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::attr::AttrMetaMethods;\n@@ -268,9 +267,9 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     return;\n \n     fn non_member(elem: MovePathIndex, set: &[MovePathIndex]) -> bool {\n-        match set.binary_search_elem(&elem) {\n-            slice::BinarySearchResult::Found(_) => false,\n-            slice::BinarySearchResult::NotFound(_) => true,\n+        match set.binary_search(&elem) {\n+            Ok(_) => false,\n+            Err(_) => true,\n         }\n     }\n }"}, {"sha": "664d470b11bd1c46ad6a228946272b712f8ad6f5", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -37,4 +37,3 @@ pub use borrowck::FnPartsWithCFG;\n mod borrowck;\n \n pub mod graphviz;\n-"}, {"sha": "0d98434d042ba91f672d6f6a172925ec1ead6f02", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -265,11 +265,13 @@ Available lint options:\n         lints\n     }\n \n-    let (plugin, builtin) = lint_store.get_lints().partitioned(|&(_, p)| p);\n+    let (plugin, builtin): (Vec<_>, _) = lint_store.get_lints()\n+        .iter().cloned().partition(|&(_, p)| p);\n     let plugin = sort_lints(plugin);\n     let builtin = sort_lints(builtin);\n \n-    let (plugin_groups, builtin_groups) = lint_store.get_lint_groups().partitioned(|&(_, _, p)| p);\n+    let (plugin_groups, builtin_groups): (Vec<_>, _) = lint_store.get_lint_groups()\n+        .iter().cloned().partition(|&(_, _, p)| p);\n     let plugin_groups = sort_lint_groups(plugin_groups);\n     let builtin_groups = sort_lint_groups(builtin_groups);\n \n@@ -377,7 +379,7 @@ fn describe_codegen_flags() {\n /// returns None.\n pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     // Throw away the first argument, the name of the binary\n-    let _binary = args.remove(0).unwrap();\n+    let _binary = args.remove(0);\n \n     if args.is_empty() {\n         // user did not write `-v` nor `-Z unstable-options`, so do not"}, {"sha": "cc240915e9d7be579652f18a30b51d5d53a59365", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -4828,9 +4828,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `{}` to \\\n                                         type {}\",\n-                                       token::get_ident(path.segments\n-                                                            .last().unwrap()\n-                                                            .identifier),\n+                                       token::get_ident(path.segments.last().unwrap() .identifier),\n                                        def);\n                                 result_def = Some(def);\n                             }\n@@ -5021,19 +5019,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             self.resolve_error(path.span,\n                                 format!(\"`{}` is not an enum variant, struct or const\",\n                                     token::get_ident(\n-                                        path.segments\n-                                            .last()\n-                                            .unwrap()\n-                                            .identifier))[]);\n+                                        path.segments.last().unwrap().identifier))[]);\n                         }\n                         None => {\n                             self.resolve_error(path.span,\n                                 format!(\"unresolved enum variant, struct or const `{}`\",\n                                     token::get_ident(\n-                                        path.segments\n-                                            .last()\n-                                            .unwrap()\n-                                            .identifier))[]);\n+                                        path.segments.last().unwrap().identifier))[]);\n                         }\n                     }\n \n@@ -5187,9 +5179,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Try to find a path to an item in a module.\n         let unqualified_def =\n-                self.resolve_identifier(path.segments\n-                                            .last().unwrap()\n-                                            .identifier,\n+                self.resolve_identifier(path.segments.last().unwrap().identifier,\n                                         namespace,\n                                         check_ribs,\n                                         path.span);"}, {"sha": "c6e4ce9457b533ba764480a276163ee6bfbf5bb9", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -606,9 +606,9 @@ fn extract_variant_args<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     val: ValueRef)\n                                     -> ExtractedBlock<'blk, 'tcx> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n-    let args = Vec::from_fn(adt::num_args(repr, disr_val), |i| {\n+    let args = range(0, adt::num_args(repr, disr_val)).map(|i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n-    });\n+    }).collect();\n \n     ExtractedBlock { vals: args, bcx: bcx }\n }"}, {"sha": "fffdc9c97ab97e41fa73be0b562b865664efe755", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -23,6 +23,7 @@ use trans::context::CrateContext;\n use trans::type_::Type;\n \n use std::cmp;\n+use std::iter::repeat;\n \n #[deriving(Clone, Copy, PartialEq)]\n enum RegClass {\n@@ -286,7 +287,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     let words = (ty_size(ty) + 7) / 8;\n-    let mut cls = Vec::from_elem(words, NoClass);\n+    let mut cls: Vec<_> = repeat(NoClass).take(words).collect();\n     if words > 4 {\n         all_mem(cls.as_mut_slice());\n         return cls;"}, {"sha": "1f01da8a124b3c7309e82460b2012c7964d19fdf", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -25,6 +25,7 @@ use middle::ty::{mod, Ty};\n use util::ppaux::{Repr, ty_to_string};\n \n use std::c_str::ToCStr;\n+use std::iter::repeat;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n use syntax::ptr::P;\n@@ -608,7 +609,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs = Vec::from_elem(n, const_expr(cx, &**elem).0);\n+            let vs: Vec<_> = repeat(const_expr(cx, &**elem).0).take(n).collect();\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n                 C_struct(cx, vs[], false)\n             } else {"}, {"sha": "f191976e23ce8869324268ed26649cdc31c5c014", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -3396,10 +3396,7 @@ fn create_scope_map(cx: &CrateContext,\n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx,\n-                                                          loc.file\n-                                                             .name\n-                                                             []);\n+                        let file_metadata = file_metadata(cx, loc.file.name[]);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {"}, {"sha": "7587adae5b7ef68b3a30908c8c9e9fc834ba6d9a", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -68,6 +68,7 @@ use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n use syntax::parse::token;\n use std::rc::Rc;\n+use std::iter::repeat;\n \n // Destinations\n \n@@ -1413,7 +1414,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let tcx = bcx.tcx();\n     with_field_tys(tcx, ty, Some(expr_id), |discr, field_tys| {\n-        let mut need_base = Vec::from_elem(field_tys.len(), true);\n+        let mut need_base: Vec<_> = repeat(true).take(field_tys.len()).collect();\n \n         let numbered_fields = fields.iter().map(|field| {\n             let opt_pos ="}, {"sha": "2cc40a617950843affa2364d296169b9e6039195", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -22,6 +22,7 @@ use syntax::ast;\n use std::c_str::ToCStr;\n use std::mem;\n use std::cell::RefCell;\n+use std::iter::repeat;\n \n use libc::c_uint;\n \n@@ -282,7 +283,7 @@ impl Type {\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n-            let mut elts = Vec::from_elem(n_elts, Type { rf: 0 as TypeRef });\n+            let mut elts: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_elts).collect();\n             llvm::LLVMGetStructElementTypes(self.to_ref(),\n                                             elts.as_mut_ptr() as *mut TypeRef);\n             elts\n@@ -296,7 +297,7 @@ impl Type {\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n-            let mut args = Vec::from_elem(n_args, Type { rf: 0 as TypeRef });\n+            let mut args: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_args).collect();\n             llvm::LLVMGetParamTypes(self.to_ref(),\n                                     args.as_mut_ptr() as *mut TypeRef);\n             args"}, {"sha": "dee9aafd06d7bfc561420daf53b0eee36aa61c59", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -62,7 +62,7 @@ use util::nodemap::DefIdMap;\n use util::ppaux::{mod, Repr, UserString};\n \n use std::rc::Rc;\n-use std::iter::AdditiveIterator;\n+use std::iter::{repeat, AdditiveIterator};\n use syntax::{abi, ast, ast_util};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -317,8 +317,8 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n \n         match anon_regions {\n             Ok(v) => v.into_iter().collect(),\n-            Err(_) => Vec::from_fn(expected_num_region_params,\n-                                   |_| ty::ReStatic) // hokey\n+            Err(_) => range(0, expected_num_region_params)\n+                          .map(|_| ty::ReStatic).collect() // hokey\n         }\n     };\n \n@@ -500,7 +500,7 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n                             .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n                             .collect::<Vec<Ty<'tcx>>>();\n \n-    let input_params = Vec::from_elem(inputs.len(), String::new());\n+    let input_params: Vec<_> = repeat(String::new()).take(inputs.len()).collect();\n     let (implied_output_region,\n          params_lifetimes) = find_implied_output_region(&*inputs, input_params);\n \n@@ -734,8 +734,8 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         path.segments.iter().all(|s| s.parameters.is_empty());\n \n     let substs = if needs_defaults {\n-        let type_params = Vec::from_fn(generics.types.len(TypeSpace),\n-                                       |_| this.ty_infer(path.span));\n+        let type_params: Vec<_> = range(0, generics.types.len(TypeSpace))\n+                                      .map(|_| this.ty_infer(path.span)).collect();\n         let region_params =\n             rscope.anon_regions(path.span, generics.regions.len(TypeSpace))\n                   .unwrap();\n@@ -1528,21 +1528,18 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n     let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n \n     let mut projection_bounds = Vec::new();\n-    let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n-        Some(trait_bound) => {\n-            let ptr = instantiate_poly_trait_ref(this,\n-                                                 rscope,\n-                                                 trait_bound,\n-                                                 None,\n-                                                 &mut projection_bounds);\n-            Some(ptr)\n-        }\n-        None => {\n-            this.tcx().sess.span_err(\n-                span,\n-                \"at least one non-builtin trait is required for an object type\");\n-            None\n-        }\n+    let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n+        let trait_bound = partitioned_bounds.trait_bounds.remove(0);\n+        Some(instantiate_poly_trait_ref(this,\n+                                        rscope,\n+                                        trait_bound,\n+                                        None,\n+                                        &mut projection_bounds))\n+    } else {\n+        this.tcx().sess.span_err(\n+            span,\n+            \"at least one non-builtin trait is required for an object type\");\n+        None\n     };\n \n     let bounds ="}, {"sha": "7c431b4fc0bd065279edc29078605de20e4a70c8", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -124,7 +124,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             check_pat_struct(pcx, pat, path, fields.as_slice(), etc, expected);\n         }\n         ast::PatTup(ref elements) => {\n-            let element_tys = Vec::from_fn(elements.len(), |_| fcx.infcx().next_ty_var());\n+            let element_tys: Vec<_> = range(0, elements.len()).map(|_| fcx.infcx()\n+                .next_ty_var()).collect();\n             let pat_ty = ty::mk_tup(tcx, element_tys.clone());\n             fcx.write_ty(pat.id, pat_ty);\n             demand::eqtype(fcx, pat.span, expected, pat_ty);"}, {"sha": "a751b65a0f8c58233cacd91266082958ded4b931", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -24,6 +24,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n use std::rc::Rc;\n use std::mem;\n+use std::iter::repeat;\n use util::ppaux::Repr;\n \n struct ConfirmContext<'a, 'tcx:'a> {\n@@ -339,7 +340,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             } else if num_supplied_types != num_method_types {\n                 span_err!(self.tcx().sess, self.span, E0036,\n                     \"incorrect number of type parameters given for this method\");\n-                Vec::from_elem(num_method_types, self.tcx().types.err)\n+                repeat(self.tcx().types.err).take(num_method_types).collect()\n             } else {\n                 supplied_method_types\n             }"}, {"sha": "f3a4a8d177e233b1153f1423b4ed7ebcb2b5c55a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -110,6 +110,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n use std::rc::Rc;\n+use std::iter::repeat;\n use syntax::{mod, abi, attr};\n use syntax::ast::{mod, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n use syntax::ast_util::{mod, local_def, PostExpansionMethod};\n@@ -2130,9 +2131,9 @@ impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n \n     fn anon_regions(&self, span: Span, count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n-        Ok(Vec::from_fn(count, |_| {\n+        Ok(range(0, count).map(|_| {\n             self.infcx().next_region_var(infer::MiscVariable(span))\n-        }))\n+        }).collect())\n     }\n }\n \n@@ -2810,7 +2811,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n // FIXME(#17596) Ty<'tcx> is incorrectly invariant w.r.t 'tcx.\n fn err_args<'tcx>(tcx: &ty::ctxt<'tcx>, len: uint) -> Vec<Ty<'tcx>> {\n-    Vec::from_fn(len, |_| tcx.types.err)\n+    range(0, len).map(|_| tcx.types.err).collect()\n }\n \n fn write_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -5166,7 +5167,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // The first step then is to categorize the segments appropriately.\n \n     assert!(path.segments.len() >= 1);\n-    let mut segment_spaces;\n+    let mut segment_spaces: Vec<_>;\n     match def {\n         // Case 1 and 1b. Reference to a *type* or *enum variant*.\n         def::DefSelfTy(..) |\n@@ -5181,15 +5182,15 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefTyParam(..) => {\n             // Everything but the final segment should have no\n             // parameters at all.\n-            segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n+            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::TypeSpace));\n         }\n \n         // Case 2. Reference to a top-level value.\n         def::DefFn(..) |\n         def::DefConst(..) |\n         def::DefStatic(..) => {\n-            segment_spaces = Vec::from_elem(path.segments.len() - 1, None);\n+            segment_spaces = repeat(None).take(path.segments.len() - 1).collect();\n             segment_spaces.push(Some(subst::FnSpace));\n         }\n \n@@ -5205,7 +5206,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 def::FromImpl(_) => {}\n             }\n \n-            segment_spaces = Vec::from_elem(path.segments.len() - 2, None);\n+            segment_spaces = repeat(None).take(path.segments.len() - 2).collect();\n             segment_spaces.push(Some(subst::TypeSpace));\n             segment_spaces.push(Some(subst::FnSpace));\n         }\n@@ -5220,7 +5221,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         def::DefRegion(..) |\n         def::DefLabel(..) |\n         def::DefUpvar(..) => {\n-            segment_spaces = Vec::from_elem(path.segments.len(), None);\n+            segment_spaces = repeat(None).take(path.segments.len()).collect();\n         }\n     }\n     assert_eq!(segment_spaces.len(), path.segments.len());\n@@ -5489,8 +5490,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 \"too few type parameters provided: expected {}{} parameter(s) \\\n                 , found {} parameter(s)\",\n                 qualifier, required_len, provided_len);\n-            substs.types.replace(space,\n-                                 Vec::from_elem(desired.len(), fcx.tcx().types.err));\n+            substs.types.replace(space, repeat(fcx.tcx().types.err).take(desired.len()).collect());\n             return;\n         }\n \n@@ -5614,7 +5614,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     // make a vector of booleans initially false, set to true when used\n     if tps.len() == 0u { return; }\n-    let mut tps_used = Vec::from_elem(tps.len(), false);\n+    let mut tps_used: Vec<_> = repeat(false).take(tps.len()).collect();\n \n     ty::walk_ty(ty, |t| {\n             match t.sty {"}, {"sha": "42ffe2d5327bc4eb85a520c942dba6252b968d99", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -409,4 +409,3 @@ impl<'tcx> Repr<'tcx> for WfConstraint<'tcx> {\n         }\n     }\n }\n-"}, {"sha": "c62218313f4e810142640a3d8a15feaa897dded5", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -13,6 +13,7 @@ use middle::ty;\n use middle::ty_fold;\n \n use std::cell::Cell;\n+use std::iter::repeat;\n use syntax::codemap::Span;\n \n /// Defines strategies for handling regions that are omitted.  For\n@@ -99,7 +100,7 @@ impl RegionScope for SpecificRscope {\n                     count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n-        Ok(Vec::from_elem(count, self.default))\n+        Ok(repeat(self.default).take(count).collect())\n     }\n }\n \n@@ -134,7 +135,7 @@ impl RegionScope for BindingRscope {\n                     count: uint)\n                     -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n-        Ok(Vec::from_fn(count, |_| self.next_region()))\n+        Ok(range(0, count).map(|_| self.next_region()).collect())\n     }\n }\n "}, {"sha": "de0b0a7ad3548e75c444d457c0b7944e15711cb0", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -199,6 +199,7 @@ use middle::subst::{ParamSpace, FnSpace, TypeSpace, SelfSpace, VecPerParamSpace}\n use middle::ty::{mod, Ty};\n use std::fmt;\n use std::rc::Rc;\n+use std::iter::repeat;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -971,7 +972,7 @@ struct SolveContext<'a, 'tcx: 'a> {\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n-    let solutions = Vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n+    let solutions: Vec<_> = repeat(ty::Bivariant).take(terms_cx.num_inferred()).collect();\n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,\n         constraints: constraints,"}, {"sha": "3c09a10f3d98ed651dd4447540d0bf6c25b4df0c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -398,7 +398,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                 Some(root) => {\n                     try!(write!(f, \"<a href='{}{}/primitive.{}.html'>\",\n                                 root,\n-                                path.0.head().unwrap(),\n+                                path.0.first().unwrap(),\n                                 prim.to_url_str()));\n                     needs_termination = true;\n                 }"}, {"sha": "f8a0b88b4088d99ac4ffcf7fbf56771f3d7d359a", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -1799,7 +1799,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     try!(write!(w, r#\"<script type=\"text/javascript\" async\n                               src=\"{root_path}/implementors/{path}/{ty}.{name}.js\">\n                       </script>\"#,\n-                root_path = Vec::from_elem(cx.current.len(), \"..\").connect(\"/\"),\n+                root_path = repeat(\"..\").take(cx.current.len()).collect::<Vec<_>>().connect(\"/\"),\n                 path = if ast_util::is_local(it.def_id) {\n                     cx.current.connect(\"/\")\n                 } else {\n@@ -2055,7 +2055,8 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     match cache().impls.get(&it.def_id) {\n         Some(v) => {\n-            let (non_trait, traits) = v.partitioned(|i| i.impl_.trait_.is_none());\n+            let (non_trait, traits): (Vec<_>, _) = v.iter().cloned()\n+                .partition(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n                 for i in non_trait.iter() {\n@@ -2065,7 +2066,8 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n             if traits.len() > 0 {\n                 try!(write!(w, \"<h2 id='implementations'>Trait \\\n                                   Implementations</h2>\"));\n-                let (derived, manual) = traits.partition(|i| i.impl_.derived);\n+                let (derived, manual): (Vec<_>, _) = traits.into_iter()\n+                    .partition(|i| i.impl_.derived);\n                 for i in manual.iter() {\n                     try!(render_impl(w, i));\n                 }"}, {"sha": "7c6cfb337dc4622997060cbfb8591cec652f8ff6", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -74,7 +74,7 @@ use fmt;\n use hash;\n use mem;\n use ptr;\n-use slice::{mod, ImmutableIntSlice};\n+use slice::{mod, IntSliceExt};\n use str;\n use string::String;\n use core::kinds::marker;"}, {"sha": "a8004155af06d7bde0a02a57ac9b1b3af2223d24", "filename": "src/libstd/comm/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fcomm%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fcomm%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fsync.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -148,7 +148,7 @@ impl<T: Send> Packet<T> {\n                     tail: 0 as *mut Node,\n                 },\n                 buf: Buffer {\n-                    buf: Vec::from_fn(cap + if cap == 0 {1} else {0}, |_| None),\n+                    buf: range(0, cap + if cap == 0 {1} else {0}).map(|_| None).collect(),\n                     start: 0,\n                     size: 0,\n                 },"}, {"sha": "0fba0f6704be4bac990c9f2dbd06c632f5904b33", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -439,9 +439,10 @@ mod test {\n \n     impl Reader for ShortReader {\n         fn read(&mut self, _: &mut [u8]) -> io::IoResult<uint> {\n-            match self.lengths.remove(0) {\n-                Some(i) => Ok(i),\n-                None => Err(io::standard_error(io::EndOfFile))\n+            if self.lengths.is_empty() {\n+                Err(io::standard_error(io::EndOfFile))\n+            } else {\n+                Ok(self.lengths.remove(0))\n             }\n         }\n     }"}, {"sha": "a9d9607395ce52997ca3549ad2354776cd093459", "filename": "src/libstd/os.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -620,10 +620,11 @@ pub fn get_exit_status() -> int {\n unsafe fn load_argc_and_argv(argc: int,\n                              argv: *const *const c_char) -> Vec<Vec<u8>> {\n     use c_str::CString;\n+    use iter::range;\n \n-    Vec::from_fn(argc as uint, |i| {\n+    range(0, argc as uint).map(|i| {\n         CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_vec()\n-    })\n+    }).collect()\n }\n \n /// Returns the command line arguments\n@@ -721,7 +722,7 @@ fn real_args() -> Vec<String> {\n     let lpCmdLine = unsafe { GetCommandLineW() };\n     let szArgList = unsafe { CommandLineToArgvW(lpCmdLine, lpArgCount) };\n \n-    let args = Vec::from_fn(nArgs as uint, |i| unsafe {\n+    let args: Vec<_> = range(0, nArgs as uint).map(|i| unsafe {\n         // Determine the length of this argument.\n         let ptr = *szArgList.offset(i as int);\n         let mut len = 0;\n@@ -732,7 +733,7 @@ fn real_args() -> Vec<String> {\n         let buf = slice::from_raw_buf(&ptr, len);\n         let opt_s = String::from_utf16(sys::os::truncate_utf16_at_nul(buf));\n         opt_s.ok().expect(\"CommandLineToArgvW returned invalid UTF-16\")\n-    });\n+    }).collect();\n \n     unsafe {\n         LocalFree(szArgList as *mut c_void);"}, {"sha": "bd4031e623085ee0c1263833ba9eef187918c109", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -29,7 +29,7 @@ use vec::Vec;\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &[u8]\n-pub type Components<'a> = Splits<'a, u8, fn(&u8) -> bool>;\n+pub type Components<'a> = Split<'a, u8, fn(&u8) -> bool>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n pub type StrComponents<'a> ="}, {"sha": "751ed4b70fb38fa1646c49a1b5ae47217d45d0ea", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -25,8 +25,8 @@ use iter::{Iterator, IteratorExt, Map, repeat};\n use mem;\n use option::Option;\n use option::Option::{Some, None};\n-use slice::{AsSlice, SliceExt, SliceConcatExt};\n-use str::{CharSplits, FromStr, Str, StrAllocating, StrPrelude};\n+use slice::{SliceExt, SliceConcatExt};\n+use str::{SplitTerminator, FromStr, StrExt};\n use string::{String, ToString};\n use unicode::char::UnicodeChar;\n use vec::Vec;"}, {"sha": "98eff621ce0f3c95c3c28552ff007b2e5b29a7ae", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -95,14 +95,14 @@ mod imp {\n     }\n \n     unsafe fn load_argc_and_argv(argc: int, argv: *const *const u8) -> Vec<Vec<u8>> {\n-        Vec::from_fn(argc as uint, |i| {\n+        range(0, argc as uint).map(|i| {\n             let arg = *argv.offset(i as int);\n             let mut len = 0u;\n             while *arg.offset(len as int) != 0 {\n                 len += 1u;\n             }\n             slice::from_raw_buf(&arg, len).to_vec()\n-        })\n+        }).collect()\n     }\n \n     #[cfg(test)]"}, {"sha": "c0ef89666c0f59b16885ee4a1ce6369ace8af752", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -120,9 +120,9 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n     // signals the first requests in the queue, possible re-enqueueing it.\n     fn signal(active: &mut Vec<Box<Inner>>,\n               dead: &mut Vec<(uint, Box<Inner>)>) {\n-        let mut timer = match active.remove(0) {\n-            Some(timer) => timer, None => return\n-        };\n+        if active.is_empty() { return }\n+\n+        let mut timer = active.remove(0);\n         let mut cb = timer.cb.take().unwrap();\n         cb.call();\n         if timer.repeat {\n@@ -178,15 +178,15 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n                         Ok(RemoveTimer(id, ack)) => {\n                             match dead.iter().position(|&(i, _)| id == i) {\n                                 Some(i) => {\n-                                    let (_, i) = dead.remove(i).unwrap();\n+                                    let (_, i) = dead.remove(i);\n                                     ack.send(i);\n                                     continue\n                                 }\n                                 None => {}\n                             }\n                             let i = active.iter().position(|i| i.id == id);\n                             let i = i.expect(\"no timer found\");\n-                            let t = active.remove(i).unwrap();\n+                            let t = active.remove(i);\n                             ack.send(t);\n                         }\n                         Err(..) => break"}, {"sha": "210feb9aee7b2526f5aa939f4fd2b71349671af2", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -17,6 +17,7 @@ use prelude::*;\n \n use fmt;\n use io::{IoResult, IoError};\n+use iter::repeat;\n use libc::{c_int, c_char, c_void};\n use libc;\n use os;\n@@ -130,7 +131,7 @@ pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD) -> Option<String\n         let mut res = None;\n         let mut done = false;\n         while !done {\n-            let mut buf = Vec::from_elem(n as uint, 0u16);\n+            let mut buf: Vec<u16> = repeat(0u16).take(n).collect();\n             let k = f(buf.as_mut_ptr(), n);\n             if k == (0 as DWORD) {\n                 done = true;"}, {"sha": "a88d11eed22bd254645039b56629578c12489620", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -34,6 +34,7 @@ use libc::{c_int, HANDLE, LPDWORD, DWORD, LPVOID};\n use libc::{get_osfhandle, CloseHandle};\n use libc::types::os::arch::extra::LPCVOID;\n use io::{mod, IoError, IoResult, MemReader};\n+use iter::repeat;\n use prelude::*;\n use ptr;\n use str::from_utf8;\n@@ -89,7 +90,7 @@ impl TTY {\n     pub fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         // Read more if the buffer is empty\n         if self.utf8.eof() {\n-            let mut utf16 = Vec::from_elem(0x1000, 0u16);\n+            let mut utf16: Vec<u16> = repeat(0u16).take(0x1000).collect();\n             let mut num: DWORD = 0;\n             match unsafe { ReadConsoleW(self.handle,\n                                          utf16.as_mut_ptr() as LPVOID,"}, {"sha": "b5395d09ca7d4adb2b90a34fdae0bee7a1343615", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -26,7 +26,7 @@ use arena::TypedArena;\n use std::cell::RefCell;\n use std::fmt;\n use std::io::IoResult;\n-use std::iter;\n+use std::iter::{mod, repeat};\n use std::mem;\n use std::slice;\n \n@@ -726,7 +726,7 @@ impl<'ast> NodeCollector<'ast> {\n         debug!(\"ast_map: {} => {}\", id, entry);\n         let len = self.map.len();\n         if id as uint >= len {\n-            self.map.grow(id as uint - len + 1, NotPresent);\n+            self.map.extend(repeat(NotPresent).take(id as uint - len + 1));\n         }\n         self.map[id as uint] = entry;\n     }"}, {"sha": "9fcaf2210c194ea74d726ccc855adca5a2eade3d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -470,7 +470,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n                          -> P<ast::Item> {\n     // partition the attributes into ItemModifiers and others\n-    let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n+    let (modifiers, other_attrs): (Vec<_>, _) = it.attrs.iter().cloned().partition(|attr| {\n         match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n             Some(rc) => match *rc { Modifier(_) => true, _ => false },\n             _ => false"}, {"sha": "500070a14d2d9f6b7281811c2ca31b2638ac38af", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -22,6 +22,7 @@ use parse::token;\n use ptr::P;\n \n use std::collections::HashMap;\n+use std::iter::repeat;\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n@@ -477,7 +478,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// to\n     fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n-        let mut names = Vec::from_fn(self.name_positions.len(), |_| None);\n+        let mut names: Vec<_> = repeat(None).take(self.name_positions.len()).collect();\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n@@ -664,7 +665,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     name_ordering: Vec<String>,\n                                     names: HashMap<String, P<ast::Expr>>)\n                                     -> P<ast::Expr> {\n-    let arg_types = Vec::from_fn(args.len(), |_| None);\n+    let arg_types: Vec<_> = range(0, args.len()).map(|_| None).collect();\n     let mut cx = Context {\n         ecx: ecx,\n         args: args,\n@@ -707,13 +708,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n             None => break\n         }\n     }\n-    match parser.errors.remove(0) {\n-        Some(error) => {\n-            cx.ecx.span_err(cx.fmtsp,\n-                            format!(\"invalid format string: {}\", error)[]);\n-            return DummyResult::raw_expr(sp);\n-        }\n-        None => {}\n+    if !parser.errors.is_empty() {\n+        cx.ecx.span_err(cx.fmtsp, format!(\"invalid format string: {}\",\n+                                          parser.errors.remove(0))[]);\n+        return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {\n         let s = cx.trans_literal_string();"}, {"sha": "65ecf701e8dfcbd433041379ea3523138d8f4150", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -166,7 +166,7 @@ pub fn count_names(ms: &[TokenTree]) -> uint {\n pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: BytePos)\n                            -> Box<MatcherPos> {\n     let match_idx_hi = count_names(ms[]);\n-    let matches = Vec::from_fn(match_idx_hi, |_i| Vec::new());\n+    let matches: Vec<_> = range(0, match_idx_hi).map(|_| Vec::new()).collect();\n     box MatcherPos {\n         stack: vec![],\n         top_elts: TtSeq(ms),\n@@ -392,7 +392,8 @@ pub fn parse(sess: &ParseSess,\n                             cur_eis.push(new_ei);\n                         }\n \n-                        let matches = Vec::from_elem(ei.matches.len(), Vec::new());\n+                        let matches: Vec<_> = range(0, ei.matches.len())\n+                            .map(|_| Vec::new()).collect();\n                         let ei_t = ei;\n                         cur_eis.push(box MatcherPos {\n                             stack: vec![],"}, {"sha": "a15f1ca354bffd8e870483e07dd7f288a18348f9", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -65,6 +65,7 @@ pub use self::Token::*;\n \n use std::io;\n use std::string;\n+use std::iter::repeat;\n \n #[deriving(Clone, Copy, PartialEq)]\n pub enum Breaks {\n@@ -166,9 +167,9 @@ pub fn mk_printer(out: Box<io::Writer+'static>, linewidth: uint) -> Printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n-    let token: Vec<Token> = Vec::from_elem(n, Eof);\n-    let size: Vec<int> = Vec::from_elem(n, 0i);\n-    let scan_stack: Vec<uint> = Vec::from_elem(n, 0u);\n+    let token: Vec<Token> = repeat(Eof).take(n).collect();\n+    let size: Vec<int> = repeat(0i).take(n).collect();\n+    let scan_stack: Vec<uint> = repeat(0u).take(n).collect();\n     Printer {\n         out: out,\n         buf_len: n,"}, {"sha": "c1823231e24f75133f609268d2092d90273048b6", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -163,7 +163,7 @@ impl<'a> fold::Folder for PreludeInjector<'a> {\n                 }),\n         };\n \n-        let (crates, uses) = view_items.partitioned(|x| {\n+        let (crates, uses): (Vec<_>, _) = view_items.iter().cloned().partition(|x| {\n             match x.node {\n                 ast::ViewItemExternCrate(..) => true,\n                 _ => false,"}, {"sha": "680ed55cd98438db54a196aec96a8f14311b8a4a", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -16,6 +16,7 @@ use self::FormatState::*;\n use self::FormatOp::*;\n use std::ascii::OwnedAsciiExt;\n use std::mem::replace;\n+use std::iter::repeat;\n \n #[deriving(Copy, PartialEq)]\n enum States {\n@@ -508,7 +509,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             if flags.precision > s.len() {\n                 let mut s_ = Vec::with_capacity(flags.precision);\n                 let n = flags.precision - s.len();\n-                s_.grow(n, b'0');\n+                s_.extend(repeat(b'0').take(n));\n                 s_.extend(s.into_iter());\n                 s = s_;\n             }\n@@ -560,10 +561,10 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n     if flags.width > s.len() {\n         let n = flags.width - s.len();\n         if flags.left {\n-            s.grow(n, b' ');\n+            s.extend(repeat(b' ').take(n));\n         } else {\n             let mut s_ = Vec::with_capacity(flags.width);\n-            s_.grow(n, b' ');\n+            s_.extend(repeat(b' ').take(n));\n             s_.extend(s.into_iter());\n             s = s_;\n         }"}, {"sha": "c097e9337905093b510f1d1c6f0c30519c641fe9", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -990,8 +990,8 @@ fn run_tests<F>(opts: &TestOpts,\n \n     try!(callback(TeFiltered(filtered_descs)));\n \n-    let (filtered_tests, filtered_benchs_and_metrics) =\n-        filtered_tests.partition(|e| {\n+    let (filtered_tests, filtered_benchs_and_metrics): (Vec<_>, _) =\n+        filtered_tests.into_iter().partition(|e| {\n             match e.testfn {\n                 StaticTestFn(_) | DynTestFn(_) => true,\n                 _ => false"}, {"sha": "9e4aa0712470bc6c7ebe346d0fb62f119927b7f8", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -13,21 +13,21 @@\n use core::cmp::Ordering::{Equal, Less, Greater};\n use core::option::Option;\n use core::option::Option::{Some, None};\n-use core::slice;\n use core::slice::SliceExt;\n+use core::result::Result::{Ok, Err};\n use tables::normalization::{canonical_table, compatibility_table, composition_table};\n \n fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'static [T]> {\n-    match r.binary_search(|&(val, _)| {\n+    match r.binary_search_by(|&(val, _)| {\n         if c == val { Equal }\n         else if val < c { Less }\n         else { Greater }\n     }) {\n-        slice::BinarySearchResult::Found(idx) => {\n+        Ok(idx) => {\n             let (_, result) = r[idx];\n             Some(result)\n         }\n-        slice::BinarySearchResult::NotFound(_) => None\n+        Err(_) => None\n     }\n }\n \n@@ -81,16 +81,16 @@ pub fn compose(a: char, b: char) -> Option<char> {\n         match bsearch_table(a, composition_table) {\n             None => None,\n             Some(candidates) => {\n-                match candidates.binary_search(|&(val, _)| {\n+                match candidates.binary_search_by(|&(val, _)| {\n                     if b == val { Equal }\n                     else if val < b { Less }\n                     else { Greater }\n                 }) {\n-                    slice::BinarySearchResult::Found(idx) => {\n+                    Ok(idx) => {\n                         let (_, result) = candidates[idx];\n                         Some(result)\n                     }\n-                    slice::BinarySearchResult::NotFound(_) => None\n+                    Err(_) => None\n                 }\n             }\n         }"}, {"sha": "5a8f63f207e2721be96a15bfcadf8b83c453c5a3", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -19,11 +19,11 @@ pub const UNICODE_VERSION: (uint, uint, uint) = (7, 0, 0);\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n     use core::slice::SliceExt;\n-    r.binary_search(|&(lo,hi)| {\n+    r.binary_search_by(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n         else { Greater }\n-    }).found().is_some()\n+    }).is_ok()\n }\n \n pub mod general_category {\n@@ -6826,17 +6826,17 @@ pub mod normalization {\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n         use core::slice::SliceExt;\n-        use core::slice;\n-        match r.binary_search(|&(lo, hi, _)| {\n+        use core::result::Result::{Ok, Err};\n+        match r.binary_search_by(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(idx) => {\n+            Ok(idx) => {\n                 let (_, _, result) = r[idx];\n                 result\n             }\n-            slice::BinarySearchResult::NotFound(_) => 0\n+            Err(_) => 0\n         }\n     }\n \n@@ -6961,7 +6961,7 @@ pub mod conversions {\n     use core::slice::SliceExt;\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n-    use core::slice;\n+    use core::result::Result::{Ok, Err};\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n@@ -6978,13 +6978,13 @@ pub mod conversions {\n     }\n \n     fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n-        match table.binary_search(|&(key, _)| {\n+        match table.binary_search_by(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(i) => Some(i),\n-            slice::BinarySearchResult::NotFound(_) => None,\n+            Ok(i) => Some(i),\n+            Err(_) => None,\n         }\n     }\n \n@@ -7596,20 +7596,20 @@ pub mod charwidth {\n     use core::option::Option;\n     use core::option::Option::{Some, None};\n     use core::slice::SliceExt;\n-    use core::slice;\n+    use core::result::Result::{Ok, Err};\n \n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n-        match r.binary_search(|&(lo, hi, _, _)| {\n+        match r.binary_search_by(|&(lo, hi, _, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(idx) => {\n+            Ok(idx) => {\n                 let (_, _, r_ncjk, r_cjk) = r[idx];\n                 if is_cjk { r_cjk } else { r_ncjk }\n             }\n-            slice::BinarySearchResult::NotFound(_) => 1\n+            Err(_) => 1\n         }\n     }\n \n@@ -7804,7 +7804,7 @@ pub mod grapheme {\n     use core::kinds::Copy;\n     use core::slice::SliceExt;\n     pub use self::GraphemeCat::*;\n-    use core::slice;\n+    use core::result::Result::{Ok, Err};\n \n     #[allow(non_camel_case_types)]\n     #[deriving(Clone)]\n@@ -7825,16 +7825,16 @@ pub mod grapheme {\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n         use core::cmp::Ordering::{Equal, Less, Greater};\n-        match r.binary_search(|&(lo, hi, _)| {\n+        match r.binary_search_by(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            slice::BinarySearchResult::Found(idx) => {\n+            Ok(idx) => {\n                 let (_, _, cat) = r[idx];\n                 cat\n             }\n-            slice::BinarySearchResult::NotFound(_) => GC_Any\n+            Err(_) => GC_Any\n         }\n     }\n "}, {"sha": "3a37981744a5af2433fed551f742465c78c9af7f", "filename": "src/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frust-installer?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -1 +1 @@\n-Subproject commit aed73472416064642911af790b25d57c9390b6c7\n+Subproject commit 3a37981744a5af2433fed551f742465c78c9af7f"}, {"sha": "26d4ec25c643955f3641f0a38aaf4b81c60f62d7", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -65,7 +65,7 @@ fn shift_push() {\n     let mut v2 = Vec::new();\n \n     while v1.len() > 0 {\n-        v2.push(v1.remove(0).unwrap());\n+        v2.push(v1.remove(0));\n     }\n }\n "}, {"sha": "909f8afc34a9fe68f5dd1fa1c92a1f7bbc4aebca", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -181,7 +181,7 @@ fn reverse_complement(seq: &mut [u8], tables: &Tables) {\n         unsafe {\n             copy_memory(seq.as_mut_ptr().offset((i - off + 1) as int),\n                         seq.as_ptr().offset((i - off) as int), off);\n-            *seq.unsafe_mut(i - off) = b'\\n';\n+            *seq.get_unchecked_mut(i - off) = b'\\n';\n         }\n         i += LINE_LEN + 1;\n     }"}, {"sha": "5be3b960ec635711d09cdff1ecb2623836257376", "filename": "src/test/compile-fail/issue-15756.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15756.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use std::slice::Chunks;\n-use std::slice::MutChunks;\n+use std::slice::ChunksMut;\n \n-fn dft_iter<'a, T>(arg1: Chunks<'a,T>, arg2: MutChunks<'a,T>)\n+fn dft_iter<'a, T>(arg1: Chunks<'a,T>, arg2: ChunksMut<'a,T>)\n {\n     for\n     &something"}, {"sha": "45b0314d2c01da88190a844571b87fecb337bb44", "filename": "src/test/compile-fail/resolve-conflict-type-vs-import.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6abfac083feafc73e5d736177755cce3bfb7153f/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-conflict-type-vs-import.rs?ref=6abfac083feafc73e5d736177755cce3bfb7153f", "patch": "@@ -15,4 +15,3 @@ struct Iter;\n \n fn main() {\n }\n-"}]}