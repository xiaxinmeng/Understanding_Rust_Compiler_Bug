{"sha": "e02b6d17486ecef8541d03bb6a38c52d1a35b339", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMmI2ZDE3NDg2ZWNlZjg1NDFkMDNiYjZhMzhjNTJkMWEzNWIzMzk=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-10-27T11:55:16Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-11T07:50:27Z"}, "message": "destructor checker (dropck).\n\nLargely adapted from pcwalton's original branch, with following\nnotable modifications:\n\nUse `regionck::type_must_outlive` to generate `SafeDestructor`\nconstraints.  (this plugged some soundness holes in the analysis).\n\nAvoid exponential time blowup on compile-fail/huge-struct.rs by\nkeeping the breadcrumbs until end of traversal.\n\nAvoid premature return from regionck::visit_expr.\n\nFactored drop-checking code out into dropck module.\n\nAdded `SafeDestructor` to enum `SubregionOrigin` (for error reporting).\n\n----\n\nSince this imposes restrictions on the lifetimes used in types with\ndestructors, this is a (wait for it)\n\n[breaking-change]", "tree": {"sha": "3679de338902b17ffbe0f4363376767b6d9e100f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3679de338902b17ffbe0f4363376767b6d9e100f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e02b6d17486ecef8541d03bb6a38c52d1a35b339", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e02b6d17486ecef8541d03bb6a38c52d1a35b339", "html_url": "https://github.com/rust-lang/rust/commit/e02b6d17486ecef8541d03bb6a38c52d1a35b339", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e02b6d17486ecef8541d03bb6a38c52d1a35b339/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81383bd8691c0915e66abaca845e508b6edc4851", "url": "https://api.github.com/repos/rust-lang/rust/commits/81383bd8691c0915e66abaca845e508b6edc4851", "html_url": "https://github.com/rust-lang/rust/commit/81383bd8691c0915e66abaca845e508b6edc4851"}], "stats": {"total": 265, "additions": 261, "deletions": 4}, "files": [{"sha": "5d7a56ef0e6c6a846963cde229085bf7445b4bea", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=e02b6d17486ecef8541d03bb6a38c52d1a35b339", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n                 }\n                 SubSupConflict(var_origin, _, sub_r, _, sup_r) => {\n-                    debug!(\"processing SubSupConflict\");\n+                    debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub_r, sup_r);\n                     match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n                         Some(ref same_frs) => {\n                             var_origins.push(var_origin);\n@@ -709,6 +709,23 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     sup,\n                     \"\");\n             }\n+            infer::SafeDestructor(span) => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    \"unsafe use of destructor: destructor might be called \\\n+                     while references are dead\");\n+                // FIXME (22171): terms \"super/subregion\" are suboptimal\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"superregion: \",\n+                    sup,\n+                    \"\");\n+                note_and_explain_region(\n+                    self.tcx,\n+                    \"subregion: \",\n+                    sub,\n+                    \"\");\n+            }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_err(\n                     span,\n@@ -1629,6 +1646,12 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"...so that the declared lifetime parameter bounds \\\n                                 are satisfied\")[]);\n             }\n+            infer::SafeDestructor(span) => {\n+                self.tcx.sess.span_note(\n+                    span,\n+                    \"...so that references are valid when the destructor \\\n+                     runs\")\n+            }\n         }\n     }\n }"}, {"sha": "41310f055887a65e5120a39a9bcce00a3c8fd4d4", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e02b6d17486ecef8541d03bb6a38c52d1a35b339", "patch": "@@ -215,6 +215,9 @@ pub enum SubregionOrigin<'tcx> {\n \n     // An auto-borrow that does not enclose the expr where it occurs\n     AutoBorrow(Span),\n+\n+    // Region constraint arriving from destructor safety\n+    SafeDestructor(Span),\n }\n \n /// Times when we replace late-bound regions with variables:\n@@ -1197,6 +1200,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             CallReturn(a) => a,\n             AddrOf(a) => a,\n             AutoBorrow(a) => a,\n+            SafeDestructor(a) => a,\n         }\n     }\n }\n@@ -1259,6 +1263,7 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n             CallReturn(a) => format!(\"CallReturn({})\", a.repr(tcx)),\n             AddrOf(a) => format!(\"AddrOf({})\", a.repr(tcx)),\n             AutoBorrow(a) => format!(\"AutoBorrow({})\", a.repr(tcx)),\n+            SafeDestructor(a) => format!(\"SafeDestructor({})\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "3dba8045d60c88e54ae3476e6563fcd805e730bb", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=e02b6d17486ecef8541d03bb6a38c52d1a35b339", "patch": "@@ -1399,6 +1399,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             for upper_bound in &upper_bounds {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n+                    debug!(\"pushing SubSupConflict sub: {:?} sup: {:?}\",\n+                           lower_bound.region, upper_bound.region);\n                     errors.push(SubSupConflict(\n                         (*self.var_origins.borrow())[node_idx.index as uint].clone(),\n                         lower_bound.origin.clone(),"}, {"sha": "a1e0f91984b70abb797dd048ed9488fb651e7699", "filename": "src/librustc_typeck/check/dropck.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=e02b6d17486ecef8541d03bb6a38c52d1a35b339", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use check::regionck::{self, Rcx};\n+\n+use middle::infer;\n+use middle::region;\n+use middle::ty::{self, Ty};\n+use util::ppaux::{Repr};\n+\n+use syntax::codemap::Span;\n+\n+pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                                                     typ: ty::Ty<'tcx>,\n+                                                     span: Span,\n+                                                     scope: region::CodeExtent) {\n+    debug!(\"check_safety_of_destructor_if_necessary typ: {} scope: {:?}\",\n+           typ.repr(rcx.tcx()), scope);\n+\n+    // types that have been traversed so far by `traverse_type_if_unseen`\n+    let mut breadcrumbs: Vec<Ty<'tcx>> = Vec::new();\n+\n+    iterate_over_potentially_unsafe_regions_in_type(\n+        rcx,\n+        &mut breadcrumbs,\n+        typ,\n+        span,\n+        scope,\n+        0);\n+}\n+\n+fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n+    rcx: &mut Rcx<'a, 'tcx>,\n+    breadcrumbs: &mut Vec<Ty<'tcx>>,\n+    ty_root: ty::Ty<'tcx>,\n+    span: Span,\n+    scope: region::CodeExtent,\n+    depth: uint)\n+{\n+    let origin = |&:| infer::SubregionOrigin::SafeDestructor(span);\n+    let mut walker = ty_root.walk();\n+    while let Some(typ) = walker.next() {\n+        // Avoid recursing forever.\n+        if breadcrumbs.contains(&typ) {\n+            continue;\n+        }\n+        breadcrumbs.push(typ);\n+\n+        let has_dtor = match typ.sty {\n+            ty::ty_struct(struct_did, _) => ty::has_dtor(rcx.tcx(), struct_did),\n+            ty::ty_enum(enum_did, _) => ty::has_dtor(rcx.tcx(), enum_did),\n+            _ => false,\n+        };\n+\n+        debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n+                {}typ: {} scope: {:?} has_dtor: {}\",\n+               (0..depth).map(|_| ' ').collect::<String>(),\n+               typ.repr(rcx.tcx()), scope, has_dtor);\n+\n+        if has_dtor {\n+            // If `typ` has a destructor, then we must ensure that all\n+            // borrowed data reachable via `typ` must outlive the\n+            // parent of `scope`. (It does not suffice for it to\n+            // outlive `scope` because that could imply that the\n+            // borrowed data is torn down in between the end of\n+            // `scope` and when the destructor itself actually runs.\n+\n+            let parent_region =\n+                match rcx.tcx().region_maps.opt_encl_scope(scope) {\n+                    Some(parent_scope) => ty::ReScope(parent_scope),\n+                    None => rcx.tcx().sess.span_bug(\n+                        span, format!(\"no enclosing scope found for scope: {:?}\",\n+                                      scope).as_slice()),\n+                };\n+\n+            regionck::type_must_outlive(rcx, origin(), typ, parent_region);\n+\n+        } else {\n+            // Okay, `typ` itself is itself not reachable by a\n+            // destructor; but it may contain substructure that has a\n+            // destructor.\n+\n+            match typ.sty {\n+                ty::ty_struct(struct_did, substs) => {\n+                    // Don't recurse; we extract type's substructure,\n+                    // so do not process subparts of type expression.\n+                    walker.skip_current_subtree();\n+\n+                    let fields =\n+                        ty::lookup_struct_fields(rcx.tcx(), struct_did);\n+                    for field in fields.iter() {\n+                        let field_type =\n+                            ty::lookup_field_type(rcx.tcx(),\n+                                                  struct_did,\n+                                                  field.id,\n+                                                  substs);\n+                        iterate_over_potentially_unsafe_regions_in_type(\n+                            rcx,\n+                            breadcrumbs,\n+                            field_type,\n+                            span,\n+                            scope,\n+                            depth+1)\n+                    }\n+                }\n+\n+                ty::ty_enum(enum_did, substs) => {\n+                    // Don't recurse; we extract type's substructure,\n+                    // so do not process subparts of type expression.\n+                    walker.skip_current_subtree();\n+\n+                    let all_variant_info =\n+                        ty::substd_enum_variants(rcx.tcx(),\n+                                                 enum_did,\n+                                                 substs);\n+                    for variant_info in all_variant_info.iter() {\n+                        for argument_type in variant_info.args.iter() {\n+                            iterate_over_potentially_unsafe_regions_in_type(\n+                                rcx,\n+                                breadcrumbs,\n+                                *argument_type,\n+                                span,\n+                                scope,\n+                                depth+1)\n+                        }\n+                    }\n+                }\n+\n+                ty::ty_rptr(..) | ty::ty_ptr(_) | ty::ty_bare_fn(..) => {\n+                    // Don't recurse, since references, pointers,\n+                    // boxes, and bare functions don't own instances\n+                    // of the types appearing within them.\n+                    walker.skip_current_subtree();\n+                }\n+                _ => {}\n+            };\n+\n+            // You might be tempted to pop breadcrumbs here after\n+            // processing type's internals above, but then you hit\n+            // exponential time blowup e.g. on\n+            // compile-fail/huge-struct.rs. Instead, we do not remove\n+            // anything from the breadcrumbs vector during any particular\n+            // traversal, and instead clear it after the whole traversal\n+            // is done.\n+        }\n+    }\n+}"}, {"sha": "d90ed7eda599e2441a284b48aca9ada43bdf18cd", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e02b6d17486ecef8541d03bb6a38c52d1a35b339", "patch": "@@ -127,6 +127,7 @@ use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n \n mod assoc;\n+pub mod dropck;\n pub mod _match;\n pub mod vtable;\n pub mod writeback;"}, {"sha": "80f6e3800f7131c375349630172877eb991294e1", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=e02b6d17486ecef8541d03bb6a38c52d1a35b339", "patch": "@@ -83,6 +83,7 @@\n //! contents.\n \n use astconv::AstConv;\n+use check::dropck;\n use check::FnCtxt;\n use check::regionmanip;\n use check::vtable;\n@@ -171,6 +172,7 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n     // id of AST node being analyzed (the subject of the analysis).\n     subject: SubjectNode,\n+\n }\n \n /// Returns the validity region of `def` -- that is, how long is `def` valid?\n@@ -198,7 +200,8 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         Rcx { fcx: fcx,\n               repeating_scope: initial_repeating_scope,\n               subject: subject,\n-              region_bound_pairs: Vec::new() }\n+              region_bound_pairs: Vec::new()\n+        }\n     }\n \n     pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n@@ -469,6 +472,10 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n         type_of_node_must_outlive(\n             rcx, infer::BindingTypeIsNotValidAtDecl(span),\n             id, var_region);\n+\n+        let var_scope = tcx.region_maps.var_scope(id);\n+        let typ = rcx.resolve_node_type(id);\n+        dropck::check_safety_of_destructor_if_necessary(rcx, typ, span, var_scope);\n     })\n }\n \n@@ -517,6 +524,40 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             */\n             _ => {}\n         }\n+\n+        // If necessary, constrain destructors in the unadjusted form of this\n+        // expression.\n+        let cmt_result = {\n+            let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+            mc.cat_expr_unadjusted(expr)\n+        };\n+        match cmt_result {\n+            Ok(head_cmt) => {\n+                check_safety_of_rvalue_destructor_if_necessary(rcx,\n+                                                               head_cmt,\n+                                                               expr.span);\n+            }\n+            Err(..) => {\n+                rcx.fcx.tcx().sess.span_note(expr.span,\n+                                             \"cat_expr_unadjusted Errd during dtor check\");\n+            }\n+        }\n+    }\n+\n+    // If necessary, constrain destructors in this expression. This will be\n+    // the adjusted form if there is an adjustment.\n+    let cmt_result = {\n+        let mc = mc::MemCategorizationContext::new(rcx.fcx);\n+        mc.cat_expr(expr)\n+    };\n+    match cmt_result {\n+        Ok(head_cmt) => {\n+            check_safety_of_rvalue_destructor_if_necessary(rcx, head_cmt, expr.span);\n+        }\n+        Err(..) => {\n+            rcx.fcx.tcx().sess.span_note(expr.span,\n+                                         \"cat_expr Errd during dtor check\");\n+        }\n     }\n \n     match expr.node {\n@@ -995,6 +1036,33 @@ pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,\n                     minimum_lifetime, maximum_lifetime)\n }\n \n+fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                                                            cmt: mc::cmt<'tcx>,\n+                                                            span: Span) {\n+    match cmt.cat {\n+        mc::cat_rvalue(region) => {\n+            match region {\n+                ty::ReScope(rvalue_scope) => {\n+                    let typ = rcx.resolve_type(cmt.ty);\n+                    dropck::check_safety_of_destructor_if_necessary(rcx,\n+                                                                    typ,\n+                                                                    span,\n+                                                                    rvalue_scope);\n+                }\n+                ty::ReStatic => {}\n+                region => {\n+                    rcx.tcx()\n+                       .sess\n+                       .span_bug(span,\n+                                 format!(\"unexpected rvalue region in rvalue \\\n+                                          destructor safety checking: `{}`\",\n+                                         region.repr(rcx.tcx())).as_slice());\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n \n /// Invoked on any index expression that occurs. Checks that if this is a slice being indexed, the\n /// lifetime of the pointer includes the deref expr.\n@@ -1404,7 +1472,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n }\n \n /// Ensures that all borrowed data reachable via `ty` outlives `region`.\n-fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                origin: infer::SubregionOrigin<'tcx>,\n                                ty: Ty<'tcx>,\n                                region: ty::Region)"}, {"sha": "923614f9e8a74c7a7dbb3634cda1b07613b06e22", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e02b6d17486ecef8541d03bb6a38c52d1a35b339/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=e02b6d17486ecef8541d03bb6a38c52d1a35b339", "patch": "@@ -147,7 +147,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         item.span,\n                                                         item.id,\n                                                         Some(&mut this.cache));\n-            for variant in &variants {\n+            debug!(\"check_type_defn at bounds_checker.scope: {:?}\", bounds_checker.scope);\n+\n+             for variant in &variants {\n                 for field in &variant.fields {\n                     // Regions are checked below.\n                     bounds_checker.check_traits_in_ty(field.ty);\n@@ -182,6 +184,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         item.span,\n                                                         item.id,\n                                                         Some(&mut this.cache));\n+            debug!(\"check_item_type at bounds_checker.scope: {:?}\", bounds_checker.scope);\n \n             let type_scheme = ty::lookup_item_type(fcx.tcx(), local_def(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n@@ -200,6 +203,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                                         item.span,\n                                                         item.id,\n                                                         Some(&mut this.cache));\n+            debug!(\"check_impl at bounds_checker.scope: {:?}\", bounds_checker.scope);\n \n             // Find the impl self type as seen from the \"inside\" --\n             // that is, with all type parameters converted from bound"}]}