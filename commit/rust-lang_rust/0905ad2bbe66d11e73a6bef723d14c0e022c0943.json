{"sha": "0905ad2bbe66d11e73a6bef723d14c0e022c0943", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MDVhZDJiYmU2NmQxMWU3M2E2YmVmNzIzZDE0YzBlMDIyYzA5NDM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-10T01:23:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-10T01:24:56Z"}, "message": "rustdoc: Vastly simplify the document model\n\nDon't attempt to impose any structure for documenting arguments, return\nvalues, etc.", "tree": {"sha": "3cd6ba12a9956daf3af6d47bd824aea231f47e22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cd6ba12a9956daf3af6d47bd824aea231f47e22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0905ad2bbe66d11e73a6bef723d14c0e022c0943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0905ad2bbe66d11e73a6bef723d14c0e022c0943", "html_url": "https://github.com/rust-lang/rust/commit/0905ad2bbe66d11e73a6bef723d14c0e022c0943", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0905ad2bbe66d11e73a6bef723d14c0e022c0943/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f4c0d71e521112e8113e552c06739440fb193d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f4c0d71e521112e8113e552c06739440fb193d7", "html_url": "https://github.com/rust-lang/rust/commit/9f4c0d71e521112e8113e552c06739440fb193d7"}], "stats": {"total": 1281, "additions": 37, "deletions": 1244}, "files": [{"sha": "b6bc6f9271d3184417011d8ea7459af8f8df4a69", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 2, "deletions": 110, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -9,10 +9,8 @@ import rustc::syntax::ast;\n import rustc::front::attr;\n import core::tuple;\n \n-export crate_attrs, basic_attrs, fn_attrs, arg_attrs,\n-       variant_attrs, res_attrs, method_attrs;\n-export parse_crate, parse_basic, parse_fn,\n-       parse_variant, parse_res, parse_method;\n+export crate_attrs, basic_attrs, variant_attrs;\n+export parse_crate, parse_basic, parse_variant;\n export parse_hidden;\n \n type crate_attrs = {\n@@ -24,27 +22,10 @@ type basic_attrs = {\n     desc: option<str>\n };\n \n-type fn_attrs = {\n-    args: [arg_attrs],\n-    return: option<str>,\n-    failure: option<str>\n-};\n-\n-type arg_attrs = {\n-    name: str,\n-    desc: str\n-};\n-\n type variant_attrs = {\n     desc: option<str>\n };\n \n-type res_attrs = {\n-    args: [arg_attrs]\n-};\n-\n-type method_attrs = fn_attrs;\n-\n #[cfg(test)]\n mod test {\n \n@@ -231,72 +212,6 @@ fn parse_long_doc<T>(\n     }\n }\n \n-fn parse_fn(attrs: [ast::attribute]) -> fn_attrs {\n-    parse_long_doc(attrs, parse_fn_long_doc)\n-}\n-\n-fn parse_fn_long_doc(items: [@ast::meta_item]) -> fn_attrs {\n-    let return = attr::meta_item_value_from_list(items, \"return\");\n-    let failure = attr::meta_item_value_from_list(items, \"failure\");\n-    let args = parse_args(items);\n-\n-    {\n-        args: args,\n-        return: return,\n-        failure: failure\n-    }\n-}\n-\n-fn parse_args(items: [@ast::meta_item]) -> [arg_attrs] {\n-    alt attr::meta_item_list_from_list(items, \"args\") {\n-      some(items) {\n-        vec::filter_map(items) {|item|\n-            option::map(attr::name_value_str_pair(item)) { |pair|\n-                {\n-                    name: tuple::first(pair),\n-                    desc: tuple::second(pair)\n-                }\n-            }\n-        }\n-      }\n-      none { [] }\n-    }\n-}\n-\n-#[test]\n-fn parse_fn_should_handle_undocumented_functions() {\n-    let source = \"\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_fn(attrs);\n-    assert attrs.return == none;\n-    assert vec::len(attrs.args) == 0u;\n-}\n-\n-#[test]\n-fn parse_fn_should_parse_the_return_value_description() {\n-    let source = \"#[doc(return = \\\"return value\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_fn(attrs);\n-    assert attrs.return == some(\"return value\");\n-}\n-\n-#[test]\n-fn parse_fn_should_parse_the_argument_descriptions() {\n-    let source = \"#[doc(args(a = \\\"arg a\\\", b = \\\"arg b\\\"))]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_fn(attrs);\n-    assert attrs.args[0] == {name: \"a\", desc: \"arg a\"};\n-    assert attrs.args[1] == {name: \"b\", desc: \"arg b\"};\n-}\n-\n-#[test]\n-fn parse_fn_should_parse_failure_conditions() {\n-    let source = \"#[doc(failure = \\\"it's the fail\\\")]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_fn(attrs);\n-    assert attrs.failure == some(\"it's the fail\");\n-}\n-\n fn parse_variant(attrs: [ast::attribute]) -> variant_attrs {\n     parse_short_doc_or(\n         attrs,\n@@ -342,29 +257,6 @@ fn should_parse_variant_long_doc() {\n     assert attrs.desc == some(\"a\");\n }\n \n-fn parse_res(attrs: [ast::attribute]) -> res_attrs {\n-    parse_long_doc(attrs, parse_res_long_doc)\n-}\n-\n-fn parse_res_long_doc(items: [@ast::meta_item]) -> res_attrs {\n-    {\n-        args: parse_args(items)\n-    }\n-}\n-\n-#[test]\n-fn shoulde_parse_resource_arg() {\n-    let source = \"#[doc(args(a = \\\"b\\\"))]\";\n-    let attrs = test::parse_attributes(source);\n-    let attrs = parse_res(attrs);\n-    assert attrs.args[0].name == \"a\";\n-    assert attrs.args[0].desc == \"b\";\n-}\n-\n-fn parse_method(attrs: [ast::attribute]) -> method_attrs {\n-    parse_fn(attrs)\n-}\n-\n fn parse_hidden(attrs: [ast::attribute]) -> bool {\n     parse_short_doc_or(\n         attrs,"}, {"sha": "e8ada93545646f1230f6e8cdb8472f21eda421e7", "filename": "src/rustdoc/attr_pass.rs", "status": "modified", "additions": 7, "deletions": 175, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_pass.rs?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -26,9 +26,7 @@ fn run(\n     let fold = fold::fold({\n         fold_crate: fold_crate,\n         fold_item: fold_item,\n-        fold_fn: fold_fn,\n         fold_enum: fold_enum,\n-        fold_res: fold_res,\n         fold_iface: fold_iface,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(srv)\n@@ -130,103 +128,12 @@ fn should_extract_native_fn_attributes() {\n     assert doc.cratemod().nmods()[0].fns[0].desc() == some(\"test\");\n }\n \n-fn fold_fn(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::fndoc\n-) -> doc::fndoc {\n-\n-    let srv = fold.ctxt;\n-\n-    let doc = fold::default_seq_fold_fn(fold, doc);\n-    let attrs = parse_item_attrs(srv, doc.id(), attr_parser::parse_fn);\n-    ret merge_fn_attrs(doc, attrs);\n-\n-    fn merge_fn_attrs(\n-        doc: doc::fndoc,\n-        attrs: attr_parser::fn_attrs\n-    ) -> doc::fndoc {\n-        ret {\n-            args: merge_arg_attrs(doc.args, attrs.args),\n-            return: merge_ret_attrs(doc.return, attrs.return),\n-            failure: attrs.failure\n-            with doc\n-        };\n-    }\n-}\n-\n-fn merge_arg_attrs(\n-    docs: [doc::argdoc],\n-    attrs: [attr_parser::arg_attrs]\n-) -> [doc::argdoc] {\n-    par::seqmap(docs) {|doc|\n-        alt vec::find(attrs) {|attr|\n-            attr.name == doc.name\n-        } {\n-            some(attr) {\n-                {\n-                    desc: some(attr.desc)\n-                    with doc\n-                }\n-            }\n-            none { doc }\n-        }\n-    }\n-    // FIXME: Warning when documenting a non-existent arg\n-}\n-\n-\n-fn merge_ret_attrs(\n-    doc: doc::retdoc,\n-    attrs: option<str>\n-) -> doc::retdoc {\n-    {\n-        desc: attrs\n-        with doc\n-    }\n-}\n-\n #[test]\n fn should_extract_fn_attributes() {\n     let doc = test::mk_doc(\"#[doc = \\\"test\\\"] fn a() -> int { }\");\n     assert doc.cratemod().fns()[0].desc() == some(\"test\");\n }\n \n-#[test]\n-fn should_extract_fn_arg_attributes() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn c(a: bool) { }\");\n-    assert doc.cratemod().fns()[0].args[0].desc == some(\"b\");\n-}\n-\n-#[test]\n-fn should_extract_fn_return_attributes() {\n-    let source = \"#[doc(return = \\\"what\\\")] fn a() -> int { }\";\n-    astsrv::from_str(source) {|srv|\n-        let doc = extract::from_srv(srv, \"\");\n-        let doc = tystr_pass::mk_pass().f(srv, doc);\n-        let fold = fold::default_any_fold(srv);\n-        let doc = fold_fn(fold, doc.cratemod().fns()[0]);\n-        assert doc.return.desc == some(\"what\");\n-    }\n-}\n-\n-#[test]\n-fn should_preserve_fn_sig() {\n-    let source = \"fn a() -> int { }\";\n-    astsrv::from_str(source) {|srv|\n-        let doc = extract::from_srv(srv, \"\");\n-        let doc = tystr_pass::mk_pass().f(srv, doc);\n-        let fold = fold::default_any_fold(srv);\n-        let doc = fold_fn(fold, doc.cratemod().fns()[0]);\n-        assert doc.sig == some(\"fn a() -> int\");\n-    }\n-}\n-\n-#[test]\n-fn should_extract_fn_failure_conditions() {\n-    let doc = test::mk_doc(\"#[doc(failure = \\\"what\\\")] fn a() { }\");\n-    assert doc.cratemod().fns()[0].failure == some(\"what\");\n-}\n-\n #[test]\n fn should_extract_const_docs() {\n     let doc = test::mk_doc(\"#[doc(brief = \\\"foo\\\", desc = \\\"bar\\\")]\\\n@@ -284,49 +191,6 @@ fn should_extract_variant_docs() {\n     assert doc.cratemod().enums()[0].variants[0].desc == some(\"c\");\n }\n \n-fn fold_res(\n-    fold: fold::fold<astsrv::srv>,\n-    doc: doc::resdoc\n-) -> doc::resdoc {\n-\n-    let srv = fold.ctxt;\n-    let doc = fold::default_seq_fold_res(fold, doc);\n-    let attrs = parse_item_attrs(srv, doc.id(), attr_parser::parse_res);\n-\n-    {\n-        args: par::seqmap(doc.args) {|doc|\n-            alt vec::find(attrs.args) {|attr|\n-                attr.name == doc.name\n-            } {\n-                some(attr) {\n-                    {\n-                        desc: some(attr.desc)\n-                        with doc\n-                    }\n-                }\n-                none { doc }\n-            }\n-        }\n-        with doc\n-    }\n-}\n-\n-#[test]\n-fn should_extract_res_docs() {\n-    let doc = test::mk_doc(\"#[doc(brief = \\\"a\\\", desc = \\\"b\\\")]\\\n-                            resource r(b: bool) { }\");\n-    assert doc.cratemod().resources()[0].brief() == some(\"a\");\n-    assert doc.cratemod().resources()[0].desc() == some(\"b\");\n-}\n-\n-#[test]\n-fn should_extract_res_arg_docs() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))]\\\n-                            resource r(a: bool) { }\");\n-    assert doc.cratemod().resources()[0].args[0].name == \"a\";\n-    assert doc.cratemod().resources()[0].args[0].desc == some(\"b\");\n-}\n-\n fn fold_iface(\n     fold: fold::fold<astsrv::srv>,\n     doc: doc::ifacedoc\n@@ -346,30 +210,21 @@ fn merge_method_attrs(\n     docs: [doc::methoddoc]\n ) -> [doc::methoddoc] {\n \n-    type method_attrs = (attr_parser::basic_attrs,\n-                         attr_parser::method_attrs);\n-\n     // Create an assoc list from method name to attributes\n-    let attrs: [(str, method_attrs)] = astsrv::exec(srv) {|ctxt|\n+    let attrs: [(str, attr_parser::basic_attrs)] = astsrv::exec(srv) {|ctxt|\n         alt ctxt.ast_map.get(item_id) {\n           ast_map::node_item(@{\n             node: ast::item_iface(_, methods), _\n           }, _) {\n             par::seqmap(methods) {|method|\n-                (method.ident,\n-                 (attr_parser::parse_basic(method.attrs),\n-                  attr_parser::parse_method(method.attrs)\n-                 ))\n+                (method.ident, attr_parser::parse_basic(method.attrs))\n             }\n           }\n           ast_map::node_item(@{\n             node: ast::item_impl(_, _, _, methods), _\n           }, _) {\n             par::seqmap(methods) {|method|\n-                (method.ident,\n-                 (attr_parser::parse_basic(method.attrs),\n-                  attr_parser::parse_method(method.attrs)\n-                  ))\n+                (method.ident, attr_parser::parse_basic(method.attrs))\n             }\n           }\n           _ { fail \"unexpected item\" }\n@@ -378,15 +233,11 @@ fn merge_method_attrs(\n \n     vec::map2(docs, attrs) {|doc, attrs|\n         assert doc.name == tuple::first(attrs);\n-        let basic_attrs = tuple::first(tuple::second(attrs));\n-        let method_attrs = tuple::second(tuple::second(attrs));\n+        let basic_attrs = tuple::second(attrs);\n \n         {\n             brief: basic_attrs.brief,\n-            desc: basic_attrs.desc,\n-            args: merge_arg_attrs(doc.args, method_attrs.args),\n-            return: merge_ret_attrs(doc.return, method_attrs.return),\n-            failure: method_attrs.failure\n+            desc: basic_attrs.desc\n             with doc\n         }\n     }\n@@ -402,20 +253,10 @@ fn should_extract_iface_docs() {\n fn should_extract_iface_method_docs() {\n     let doc = test::mk_doc(\n         \"iface i {\\\n-         #[doc(\\\n-         brief = \\\"brief\\\",\\\n-         desc = \\\"desc\\\",\\\n-         args(a = \\\"a\\\"),\\\n-         return = \\\"return\\\",\\\n-         failure = \\\"failure\\\")]\\\n+         #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool;\\\n          }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].brief == some(\"brief\");\n     assert doc.cratemod().ifaces()[0].methods[0].desc == some(\"desc\");\n-    assert doc.cratemod().ifaces()[0].methods[0].args[0].desc == some(\"a\");\n-    assert doc.cratemod().ifaces()[0].methods[0].return.desc\n-        == some(\"return\");\n-    assert doc.cratemod().ifaces()[0].methods[0].failure == some(\"failure\");\n }\n \n \n@@ -443,19 +284,10 @@ fn should_extract_impl_docs() {\n fn should_extract_impl_method_docs() {\n     let doc = test::mk_doc(\n         \"impl i for int {\\\n-         #[doc(\\\n-         brief = \\\"brief\\\",\\\n-         desc = \\\"desc\\\",\\\n-         args(a = \\\"a\\\"),\\\n-         return = \\\"return\\\",\\\n-         failure = \\\"failure\\\")]\\\n+         #[doc = \\\"desc\\\"]\\\n          fn f(a: bool) -> bool { }\\\n          }\");\n-    assert doc.cratemod().impls()[0].methods[0].brief == some(\"brief\");\n     assert doc.cratemod().impls()[0].methods[0].desc == some(\"desc\");\n-    assert doc.cratemod().impls()[0].methods[0].args[0].desc == some(\"a\");\n-    assert doc.cratemod().impls()[0].methods[0].return.desc == some(\"return\");\n-    assert doc.cratemod().impls()[0].methods[0].failure == some(\"failure\");\n }\n \n #[test]"}, {"sha": "2da723fa7dd71196d9117b65dd690a0241b73d06", "filename": "src/rustdoc/doc.rs", "status": "modified", "additions": 12, "deletions": 47, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fdoc.rs?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -50,6 +50,11 @@ type itemdoc = {\n     reexport: bool\n };\n \n+type simpleitemdoc = {\n+    item: itemdoc,\n+    sig: option<str>\n+};\n+\n type moddoc = {\n     item: itemdoc,\n     items: [itemtag],\n@@ -61,27 +66,9 @@ type nmoddoc = {\n     fns: [fndoc]\n };\n \n-type constdoc = {\n-    item: itemdoc,\n-    ty: option<str>\n-};\n+type constdoc = simpleitemdoc;\n \n-type fndoc = {\n-    item: itemdoc,\n-    args: [argdoc],\n-    return: retdoc,\n-    failure: option<str>,\n-    sig: option<str>\n-};\n-\n-type argdoc = {\n-    name: str,\n-    desc: option<str>\n-};\n-\n-type retdoc = {\n-    desc: option<str>\n-};\n+type fndoc = simpleitemdoc;\n \n type enumdoc = {\n     item: itemdoc,\n@@ -94,11 +81,7 @@ type variantdoc = {\n     sig: option<str>\n };\n \n-type resdoc = {\n-    item: itemdoc,\n-    args: [argdoc],\n-    sig: option<str>\n-};\n+type resdoc = simpleitemdoc;\n \n type ifacedoc = {\n     item: itemdoc,\n@@ -110,9 +93,6 @@ type methoddoc = {\n     brief: option<str>,\n     desc: option<str>,\n     sections: [section],\n-    args: [argdoc],\n-    return: retdoc,\n-    failure: option<str>,\n     sig: option<str>\n };\n \n@@ -123,10 +103,7 @@ type impldoc = {\n     methods: [methoddoc]\n };\n \n-type tydoc = {\n-    item: itemdoc,\n-    sig: option<str>\n-};\n+type tydoc = simpleitemdoc;\n \n type index = {\n     entries: [index_entry]\n@@ -355,30 +332,22 @@ impl of item for itemtag {\n     }\n }\n \n-impl of item for moddoc {\n-    fn item() -> itemdoc { self.item }\n-}\n-\n-impl of item for nmoddoc {\n+impl of item for simpleitemdoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl of item for fndoc {\n+impl of item for moddoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl of item for constdoc {\n+impl of item for nmoddoc {\n     fn item() -> itemdoc { self.item }\n }\n \n impl of item for enumdoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl of item for resdoc {\n-    fn item() -> itemdoc { self.item }\n-}\n-\n impl of item for ifacedoc {\n     fn item() -> itemdoc { self.item }\n }\n@@ -387,10 +356,6 @@ impl of item for impldoc {\n     fn item() -> itemdoc { self.item }\n }\n \n-impl of item for tydoc {\n-    fn item() -> itemdoc { self.item }\n-}\n-\n impl util<A:item> for A {\n     fn id() -> ast_id {\n         self.item().id"}, {"sha": "23cc4755cf46e997c0ce22587cc2134dadd04fbd", "filename": "src/rustdoc/extract.rs", "status": "modified", "additions": 9, "deletions": 70, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fextract.rs?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -68,9 +68,9 @@ fn moddoc_from_mod(\n                     nmoddoc_from_mod(itemdoc, nm)\n                 ))\n               }\n-              ast::item_fn(decl, _, _) {\n+              ast::item_fn(_, _, _) {\n                 some(doc::fntag(\n-                    fndoc_from_fn(itemdoc, decl)\n+                    fndoc_from_fn(itemdoc)\n                 ))\n               }\n               ast::item_const(_, _) {\n@@ -83,9 +83,9 @@ fn moddoc_from_mod(\n                     enumdoc_from_enum(itemdoc, variants)\n                 ))\n               }\n-              ast::item_res(decl, _, _, _, _) {\n+              ast::item_res(_, _, _, _, _) {\n                 some(doc::restag(\n-                    resdoc_from_resource(itemdoc, decl)\n+                    resdoc_from_resource(itemdoc)\n                 ))\n               }\n               ast::item_iface(_, methods) {\n@@ -121,54 +121,25 @@ fn nmoddoc_from_mod(\n         fns: par::seqmap(module.items) {|item|\n             let itemdoc = mk_itemdoc(item.id, item.ident);\n             alt item.node {\n-              ast::native_item_fn(decl, _) {\n-                fndoc_from_fn(itemdoc, decl)\n+              ast::native_item_fn(_, _) {\n+                fndoc_from_fn(itemdoc)\n               }\n             }\n         }\n     }\n }\n \n-fn fndoc_from_fn(\n-    itemdoc: doc::itemdoc,\n-    decl: ast::fn_decl\n-) -> doc::fndoc {\n+fn fndoc_from_fn(itemdoc: doc::itemdoc) -> doc::fndoc {\n     {\n         item: itemdoc,\n-        args: argdocs_from_args(decl.inputs),\n-        return: {\n-            desc: none\n-        },\n-        failure: none,\n         sig: none\n     }\n }\n \n-#[test]\n-fn should_extract_fn_args() {\n-    let source = \"fn a(b: int, c: int) { }\";\n-    let ast = parse::from_str(source);\n-    let doc = extract(ast, \"\");\n-    let fn_ = doc.cratemod().fns()[0];\n-    assert fn_.args[0].name == \"b\";\n-    assert fn_.args[1].name == \"c\";\n-}\n-\n-fn argdocs_from_args(args: [ast::arg]) -> [doc::argdoc] {\n-    par::seqmap(args, argdoc_from_arg)\n-}\n-\n-fn argdoc_from_arg(arg: ast::arg) -> doc::argdoc {\n-    {\n-        name: arg.ident,\n-        desc: none\n-    }\n-}\n-\n fn constdoc_from_const(itemdoc: doc::itemdoc) -> doc::constdoc {\n     {\n         item: itemdoc,\n-        ty: none\n+        sig: none\n     }\n }\n \n@@ -216,13 +187,9 @@ fn should_extract_enum_variants() {\n     assert doc.cratemod().enums()[0].variants[0].name == \"v\";\n }\n \n-fn resdoc_from_resource(\n-    itemdoc: doc::itemdoc,\n-    decl: ast::fn_decl\n-) -> doc::resdoc {\n+fn resdoc_from_resource(itemdoc: doc::itemdoc) -> doc::resdoc {\n     {\n         item: itemdoc,\n-        args: argdocs_from_args(decl.inputs),\n         sig: none\n     }\n }\n@@ -234,12 +201,6 @@ fn should_extract_resources() {\n     assert doc.cratemod().resources()[0].name() == \"r\";\n }\n \n-#[test]\n-fn should_extract_resource_args() {\n-    let doc = test::mk_doc(\"resource r(b: bool) { }\");\n-    assert doc.cratemod().resources()[0].args[0].name == \"b\";\n-}\n-\n fn ifacedoc_from_iface(\n     itemdoc: doc::itemdoc,\n     methods: [ast::ty_method]\n@@ -252,11 +213,6 @@ fn ifacedoc_from_iface(\n                 brief: none,\n                 desc: none,\n                 sections: [],\n-                args: argdocs_from_args(method.decl.inputs),\n-                return: {\n-                    desc: none\n-                },\n-                failure: none,\n                 sig: none\n             }\n         }\n@@ -275,12 +231,6 @@ fn should_extract_iface_methods() {\n     assert doc.cratemod().ifaces()[0].methods[0].name == \"f\";\n }\n \n-#[test]\n-fn should_extract_iface_method_args() {\n-    let doc = test::mk_doc(\"iface i { fn f(a: bool); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].args[0].name == \"a\";\n-}\n-\n fn impldoc_from_impl(\n     itemdoc: doc::itemdoc,\n     methods: [@ast::method]\n@@ -295,11 +245,6 @@ fn impldoc_from_impl(\n                 brief: none,\n                 desc: none,\n                 sections: [],\n-                args: argdocs_from_args(method.decl.inputs),\n-                return: {\n-                    desc: none\n-                },\n-                failure: none,\n                 sig: none\n             }\n         }\n@@ -324,12 +269,6 @@ fn should_extract_impl_methods() {\n     assert doc.cratemod().impls()[0].methods[0].name == \"f\";\n }\n \n-#[test]\n-fn should_extract_impl_method_args() {\n-    let doc = test::mk_doc(\"impl i for int { fn f(a: bool) { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].args[0].name == \"a\";\n-}\n-\n fn tydoc_from_ty(\n     itemdoc: doc::itemdoc\n ) -> doc::tydoc {"}, {"sha": "3cc403b2ace87a53f13e581d352503c9aa7f2345", "filename": "src/rustdoc/markdown_pass.rs", "status": "modified", "additions": 4, "deletions": 213, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fmarkdown_pass.rs?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -424,10 +424,7 @@ fn write_fn(\n         doc.sig,\n         doc.brief(),\n         doc.desc(),\n-        doc.sections(),\n-        doc.args,\n-        doc.return,\n-        doc.failure\n+        doc.sections()\n     );\n }\n \n@@ -436,16 +433,10 @@ fn write_fnlike(\n     sig: option<str>,\n     brief: option<str>,\n     desc: option<str>,\n-    sections: [doc::section],\n-    args: [doc::argdoc],\n-    return: doc::retdoc,\n-    failure: option<str>\n+    sections: [doc::section]\n ) {\n     write_sig(ctxt, sig);\n     write_common(ctxt, brief, desc, sections);\n-    write_args(ctxt, args);\n-    write_return(ctxt, return);\n-    write_failure(ctxt, failure);\n }\n \n fn write_sig(ctxt: ctxt, sig: option<str>) {\n@@ -509,131 +500,12 @@ fn should_leave_blank_line_between_fn_header_and_sig() {\n     assert str::contains(markdown, \"Function `a`\\n\\n    fn a()\");\n }\n \n-fn write_args(\n-    ctxt: ctxt,\n-    args: [doc::argdoc]\n-) {\n-    if vec::is_not_empty(args) {\n-        write_lead(ctxt, \"Arguments\");\n-        ctxt.w.write_line(\"\");\n-        ctxt.w.write_line(\"\");\n-        vec::iter(args) {|arg| write_arg(ctxt, arg) };\n-        ctxt.w.write_line(\"\");\n-    }\n-}\n-\n-fn write_arg(ctxt: ctxt, arg: doc::argdoc) {\n-    ctxt.w.write_str(#fmt(\n-        \"* `%s`\",\n-        arg.name\n-    ));\n-    alt arg.desc {\n-      some(desc) {\n-        ctxt.w.write_str(#fmt(\" - %s\", desc));\n-      }\n-      none { }\n-    }\n-    ctxt.w.write_line(\"\");\n-}\n-\n-#[test]\n-fn should_write_argument_list() {\n-    let source = \"fn a(b: int, c: int) { }\";\n-    let markdown = test::render(source);\n-    assert str::contains(\n-        markdown,\n-        \"__Arguments__: \\n\\\n-         \\n\\\n-         * `b`\\n\\\n-         * `c`\\n\\\n-         \\n\"\n-    );\n-}\n-\n-#[test]\n-fn should_not_write_arguments_if_none() {\n-    let source = \"fn a() { } fn b() { }\";\n-    let markdown = test::render(source);\n-    assert !str::contains(markdown, \"Arguments\");\n-}\n-\n-#[test]\n-fn should_write_argument_description() {\n-    let source = \"#[doc(args(a = \\\"milk\\\"))] fn f(a: bool) { }\";\n-    let markdown = test::render(source);\n-    assert str::contains(markdown, \"`a` - milk\");\n-}\n-\n-fn write_return(\n-    ctxt: ctxt,\n-    doc: doc::retdoc\n-) {\n-    alt doc.desc {\n-      some(d) {\n-        write_lead(ctxt, \"Return value\");\n-        ctxt.w.write_line(d);\n-        ctxt.w.write_line(\"\");\n-      }\n-      none { }\n-    }\n-}\n-\n-#[test]\n-fn should_write_return_type_on_new_line() {\n-    let markdown = test::render(\n-        \"#[doc(return = \\\"test\\\")] fn a() -> int { }\");\n-    assert str::contains(markdown, \"\\n__Return value__: test\");\n-}\n-\n-#[test]\n-fn should_write_blank_line_between_return_type_and_next_header() {\n-    let markdown = test::render(\n-        \"#[doc(return = \\\"test\\\")] fn a() -> int { } \\\n-         fn b() -> int { }\"\n-    );\n-    assert str::contains(markdown, \"__Return value__: test\\n\\n##\");\n-}\n-\n-#[test]\n-fn should_not_write_return_type_when_there_is_none() {\n-    let markdown = test::render(\"fn a() { }\");\n-    assert !str::contains(markdown, \"Return value\");\n-}\n-\n-#[test]\n-fn should_write_blank_line_after_return_description() {\n-    let markdown = test::render(\n-        \"#[doc(return = \\\"blorp\\\")] fn a() -> int { }\"\n-    );\n-    assert str::contains(markdown, \"blorp\\n\\n\");\n-}\n-\n-fn write_failure(ctxt: ctxt, str: option<str>) {\n-    alt str {\n-      some(str) {\n-        write_lead(ctxt, \"Failure conditions\");\n-        ctxt.w.write_line(str);\n-        ctxt.w.write_line(\"\");\n-      }\n-      none { }\n-    }\n-}\n-\n-#[test]\n-fn should_write_failure_conditions() {\n-    let markdown = test::render(\n-        \"#[doc(failure = \\\"it's the fail\\\")] fn a () { }\");\n-    assert str::contains(\n-        markdown,\n-        \"\\n\\n__Failure conditions__: it's the fail\\n\\n\");\n-}\n-\n fn write_const(\n     ctxt: ctxt,\n     doc: doc::constdoc\n ) {\n     write_header(ctxt, h2, doc::consttag(doc));\n-    write_sig(ctxt, doc.ty);\n+    write_sig(ctxt, doc.sig);\n     write_common(ctxt, doc.brief(), doc.desc(), doc.sections());\n }\n \n@@ -739,7 +611,6 @@ fn write_res(ctxt: ctxt, doc: doc::resdoc) {\n     write_header(ctxt, h2, doc::restag(doc));\n     write_sig(ctxt, doc.sig);\n     write_common(ctxt, doc.brief(), doc.desc(), doc.sections());\n-    write_args(ctxt, doc.args);\n }\n \n #[test]\n@@ -754,13 +625,6 @@ fn should_write_resource_signature() {\n     assert str::contains(markdown, \"\\n    resource r(a: bool)\\n\");\n }\n \n-#[test]\n-fn should_write_resource_args() {\n-    let markdown = test::render(\"#[doc(args(a = \\\"b\\\"))]\\\n-                                 resource r(a: bool) { }\");\n-    assert str::contains(markdown, \"__Arguments__: \\n\\n* `a` - b\");\n-}\n-\n fn write_iface(ctxt: ctxt, doc: doc::ifacedoc) {\n     write_header(ctxt, h2, doc::ifacetag(doc));\n     write_common(ctxt, doc.brief(), doc.desc(), doc.sections());\n@@ -778,10 +642,7 @@ fn write_method(ctxt: ctxt, doc: doc::methoddoc) {\n         doc.sig,\n         doc.brief,\n         doc.desc,\n-        doc.sections,\n-        doc.args,\n-        doc.return,\n-        doc.failure\n+        doc.sections\n     );\n }\n \n@@ -819,41 +680,6 @@ fn should_write_iface_method_signature() {\n     assert str::contains(markdown, \"\\n    fn a()\");\n }\n \n-#[test]\n-fn should_write_iface_method_argument_header() {\n-    let markdown = test::render(\n-        \"iface a { fn a(b: int); }\");\n-    assert str::contains(markdown, \"\\n\\n__Arguments__: \\n\\n\");\n-}\n-\n-#[test]\n-fn should_write_iface_method_arguments() {\n-    let markdown = test::render(\n-        \"iface a { fn a(b: int); }\");\n-    assert str::contains(markdown, \"* `b`\\n\");\n-}\n-\n-#[test]\n-fn should_not_write_iface_method_arguments_if_none() {\n-    let markdown = test::render(\n-        \"iface a { fn a(); }\");\n-    assert !str::contains(markdown, \"Arguments\");\n-}\n-\n-#[test]\n-fn should_write_iface_method_return_info() {\n-    let markdown = test::render(\n-        \"iface a { #[doc(return = \\\"test\\\")] fn a() -> int; }\");\n-    assert str::contains(markdown, \"__Return value__: test\");\n-}\n-\n-#[test]\n-fn should_write_iface_method_failure_conditions() {\n-    let markdown = test::render(\n-        \"iface a { #[doc(failure = \\\"nuked\\\")] fn a(); }\");\n-    assert str::contains(markdown, \"__Failure conditions__: nuked\");\n-}\n-\n fn write_impl(ctxt: ctxt, doc: doc::impldoc) {\n     write_header(ctxt, h2, doc::impltag(doc));\n     write_common(ctxt, doc.brief(), doc.desc(), doc.sections());\n@@ -900,41 +726,6 @@ fn should_write_impl_method_signature() {\n     assert str::contains(markdown, \"\\n    fn a()\");\n }\n \n-#[test]\n-fn should_write_impl_method_argument_header() {\n-    let markdown = test::render(\n-        \"impl a for int { fn a(b: int) { } }\");\n-    assert str::contains(markdown, \"\\n\\n__Arguments__: \\n\\n\");\n-}\n-\n-#[test]\n-fn should_write_impl_method_arguments() {\n-    let markdown = test::render(\n-        \"impl a for int { fn a(b: int) { } }\");\n-    assert str::contains(markdown, \"* `b`\\n\");\n-}\n-\n-#[test]\n-fn should_not_write_impl_method_arguments_if_none() {\n-    let markdown = test::render(\n-        \"impl a for int { fn a() { } }\");\n-    assert !str::contains(markdown, \"Arguments\");\n-}\n-\n-#[test]\n-fn should_write_impl_method_return_info() {\n-    let markdown = test::render(\n-        \"impl a for int { #[doc(return = \\\"test\\\")] fn a() -> int { } }\");\n-    assert str::contains(markdown, \"__Return value__: test\");\n-}\n-\n-#[test]\n-fn should_write_impl_method_failure_conditions() {\n-    let markdown = test::render(\n-        \"impl a for int { #[doc(failure = \\\"nuked\\\")] fn a() { } }\");\n-    assert str::contains(markdown, \"__Failure conditions__: nuked\");\n-}\n-\n fn write_type(\n     ctxt: ctxt,\n     doc: doc::tydoc"}, {"sha": "dc4194e0fc79574053f4192db772f85ca9c2b2b8", "filename": "src/rustdoc/prune_undoc_details_pass.rs", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/9f4c0d71e521112e8113e552c06739440fb193d7/src%2Frustdoc%2Fprune_undoc_details_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4c0d71e521112e8113e552c06739440fb193d7/src%2Frustdoc%2Fprune_undoc_details_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_details_pass.rs?ref=9f4c0d71e521112e8113e552c06739440fb193d7", "patch": "@@ -1,129 +0,0 @@\n-#[doc = \"Prunes args, retvals of the document tree that \\\n-         contain no documentation\"];\n-\n-export mk_pass;\n-\n-fn mk_pass() -> pass {\n-    {\n-        name: \"prune_undoc_details\",\n-        f: run\n-    }\n-}\n-\n-fn run(\n-    _srv: astsrv::srv,\n-    doc: doc::doc\n-) -> doc::doc {\n-    let fold = fold::fold({\n-        fold_fn: fold_fn,\n-        fold_res: fold_res,\n-        fold_iface: fold_iface,\n-        fold_impl: fold_impl\n-        with *fold::default_any_fold(())\n-    });\n-    fold.fold_doc(fold, doc)\n-}\n-\n-fn fold_fn(\n-    fold: fold::fold<()>,\n-    doc: doc::fndoc\n-) -> doc::fndoc {\n-    let doc = fold::default_seq_fold_fn(fold, doc);\n-\n-    {\n-        args: prune_args(doc.args)\n-        with doc\n-    }\n-}\n-\n-fn prune_args(docs: [doc::argdoc]) -> [doc::argdoc] {\n-    vec::filter_map(docs) {|doc|\n-        if option::is_some(doc.desc) {\n-            some(doc)\n-        } else {\n-            none\n-        }\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_arguments() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] fn a(b: int) { }\");\n-    assert vec::is_empty(doc.cratemod().fns()[0].args);\n-}\n-\n-fn fold_res(\n-    fold: fold::fold<()>,\n-    doc: doc::resdoc\n-) -> doc::resdoc {\n-    let doc = fold::default_seq_fold_res(fold, doc);\n-\n-    {\n-        args: prune_args(doc.args)\n-        with doc\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_resource_args() {\n-    let doc = test::mk_doc(\"#[doc = \\\"drunk\\\"]\\\n-                            resource r(a: bool) { }\");\n-    assert vec::is_empty(doc.cratemod().resources()[0].args);\n-}\n-\n-fn fold_iface(\n-    fold: fold::fold<()>,\n-    doc: doc::ifacedoc\n-) -> doc::ifacedoc {\n-    let doc = fold::default_seq_fold_iface(fold, doc);\n-\n-    {\n-        methods: prune_methods(doc.methods)\n-        with doc\n-    }\n-}\n-\n-fn prune_methods(docs: [doc::methoddoc]) -> [doc::methoddoc] {\n-    par::anymap(docs) {|doc|\n-        {\n-            args: prune_args(doc.args)\n-            with doc\n-        }\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_iface_method_args() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_empty(doc.cratemod().ifaces()[0].methods[0].args);\n-}\n-\n-fn fold_impl(\n-    fold: fold::fold<()>,\n-    doc: doc::impldoc\n-) -> doc::impldoc {\n-    let doc = fold::default_seq_fold_impl(fold, doc);\n-\n-    {\n-        methods: prune_methods(doc.methods)\n-        with doc\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_impl_method_args() {\n-    let doc = test::mk_doc(\n-        \"#[doc = \\\"hey\\\"] impl i for int { fn a(b: bool) { } }\");\n-    assert vec::is_empty(doc.cratemod().impls()[0].methods[0].args);\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n-            let doc = extract::from_srv(srv, \"\");\n-            let doc = attr_pass::mk_pass().f(srv, doc);\n-            run(srv, doc)\n-        }\n-    }\n-}"}, {"sha": "ca7287cb8fc5bcd539225a58f11f156b47be4230", "filename": "src/rustdoc/prune_undoc_items_pass.rs", "status": "removed", "additions": 0, "deletions": 377, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/9f4c0d71e521112e8113e552c06739440fb193d7/src%2Frustdoc%2Fprune_undoc_items_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4c0d71e521112e8113e552c06739440fb193d7/src%2Frustdoc%2Fprune_undoc_items_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fprune_undoc_items_pass.rs?ref=9f4c0d71e521112e8113e552c06739440fb193d7", "patch": "@@ -1,377 +0,0 @@\n-#[doc = \"Prunes items of the document tree that contain no documentation\"];\n-\n-export mk_pass;\n-\n-fn mk_pass() -> pass {\n-    {\n-        name: \"prune_undoc_items\",\n-        f: run\n-    }\n-}\n-\n-type ctxt = {\n-    mutable have_docs: bool\n-};\n-\n-fn run(\n-    _srv: astsrv::srv,\n-    doc: doc::doc\n-) -> doc::doc {\n-    let ctxt = {\n-        mutable have_docs: true\n-    };\n-    let fold = fold::fold({\n-        fold_mod: fold_mod,\n-        fold_fn: fold_fn,\n-        fold_const: fold_const,\n-        fold_enum: fold_enum,\n-        fold_res: fold_res,\n-        fold_iface: fold_iface,\n-        fold_impl: fold_impl,\n-        fold_type: fold_type\n-        with *fold::default_any_fold(ctxt)\n-    });\n-    fold.fold_doc(fold, doc)\n-}\n-\n-fn fold_mod(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::moddoc\n-) -> doc::moddoc {\n-    let doc = {\n-        items: vec::filter_map(doc.items) {|itemtag|\n-            alt itemtag {\n-              doc::modtag(moddoc) {\n-                let doc = fold.fold_mod(fold, moddoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::modtag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::fntag(fndoc) {\n-                let doc = fold.fold_fn(fold, fndoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::fntag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::consttag(constdoc) {\n-                let doc = fold.fold_const(fold, constdoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::consttag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::enumtag(enumdoc) {\n-                let doc = fold.fold_enum(fold, enumdoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::enumtag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::restag(resdoc) {\n-                let doc = fold.fold_res(fold, resdoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::restag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::ifacetag(ifacedoc) {\n-                let doc = fold.fold_iface(fold, ifacedoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::ifacetag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::impltag(impldoc) {\n-                let doc = fold.fold_impl(fold, impldoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::impltag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              doc::tytag(tydoc) {\n-                let doc = fold.fold_type(fold, tydoc);\n-                if fold.ctxt.have_docs {\n-                    some(doc::tytag(doc))\n-                } else {\n-                    none\n-                }\n-              }\n-              _ { some(itemtag) }\n-            }\n-        }\n-        with fold::default_any_fold_mod(fold, doc)\n-    };\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || vec::is_not_empty(doc.items);\n-    ret doc;\n-}\n-\n-fn fold_fn(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::fndoc\n-) -> doc::fndoc {\n-    let doc = fold::default_seq_fold_fn(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || args_have_docs(doc.args)\n-        || doc.return.desc != none\n-        || doc.failure != none;\n-    ret doc;\n-}\n-\n-fn args_have_docs(docs: [doc::argdoc]) -> bool {\n-    vec::foldl(false, docs) {|accum, doc|\n-        accum || doc.desc != none\n-    }\n-}\n-\n-#[test]\n-fn should_elide_fns_with_undocumented_arguments() {\n-    let doc = test::mk_doc(\"fn a(a: int) { }\");\n-    assert vec::is_empty(doc.cratemod().fns());\n-}\n-\n-#[test]\n-fn should_not_elide_fns_with_documented_arguments() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"b\\\"))] fn a(a: int) { }\");\n-    assert vec::is_not_empty(doc.cratemod().fns());\n-}\n-\n-#[test]\n-fn should_not_elide_fns_with_documented_failure_conditions() {\n-    let doc = test::mk_doc(\"#[doc(failure = \\\"yup\\\")] fn a() { }\");\n-    assert vec::is_not_empty(doc.cratemod().fns());\n-}\n-\n-#[test]\n-fn should_elide_undocumented_mods() {\n-    let doc = test::mk_doc(\"mod a { }\");\n-    assert vec::is_empty(doc.cratemod().mods());\n-}\n-\n-#[test]\n-fn should_not_elide_undocument_mods_with_documented_mods() {\n-    let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] mod b { } }\");\n-    assert vec::is_not_empty(doc.cratemod().mods());\n-}\n-\n-#[test]\n-fn should_not_elide_undocument_mods_with_documented_fns() {\n-    let doc = test::mk_doc(\"mod a { #[doc = \\\"b\\\"] fn b() { } }\");\n-    assert vec::is_not_empty(doc.cratemod().mods());\n-}\n-\n-#[test]\n-fn should_elide_undocumented_fns() {\n-    let doc = test::mk_doc(\"fn a() { }\");\n-    assert vec::is_empty(doc.cratemod().fns());\n-}\n-\n-fn fold_const(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::constdoc\n-) -> doc::constdoc {\n-    let doc = fold::default_seq_fold_const(fold, doc);\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none;\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_consts() {\n-    let doc = test::mk_doc(\"const a: bool = true;\");\n-    assert vec::is_empty(doc.cratemod().consts());\n-}\n-\n-fn fold_enum(fold: fold::fold<ctxt>, doc: doc::enumdoc) -> doc::enumdoc {\n-    let doc = {\n-        variants: vec::filter_map(doc.variants) {|variant|\n-            if variant.desc != none {\n-                some(variant)\n-            } else {\n-                none\n-            }\n-        }\n-        with fold::default_seq_fold_enum(fold, doc)\n-    };\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || vec::is_not_empty(doc.variants);\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_enums() {\n-    let doc = test::mk_doc(\"enum a { b }\");\n-    assert vec::is_empty(doc.cratemod().enums());\n-}\n-\n-#[test]\n-fn should_elide_undocumented_variants() {\n-    let doc = test::mk_doc(\"#[doc = \\\"a\\\"] enum a { b }\");\n-    assert vec::is_empty(doc.cratemod().enums()[0].variants);\n-}\n-\n-#[test]\n-fn should_not_elide_enums_with_documented_variants() {\n-    let doc = test::mk_doc(\"enum a { #[doc = \\\"a\\\"] b }\");\n-    assert vec::is_not_empty(doc.cratemod().enums());\n-}\n-\n-fn fold_res(fold: fold::fold<ctxt>, doc: doc::resdoc) -> doc::resdoc {\n-    let doc = fold::default_seq_fold_res(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || args_have_docs(doc.args);\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_resources() {\n-    let doc = test::mk_doc(\"resource r(a: bool) { }\");\n-    assert vec::is_empty(doc.cratemod().resources());\n-}\n-\n-#[test]\n-fn should_not_elide_resources_with_documented_args() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"drunk\\\"))]\\\n-                            resource r(a: bool) { }\");\n-    assert vec::is_not_empty(doc.cratemod().resources());\n-}\n-\n-fn fold_iface(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::ifacedoc\n-) -> doc::ifacedoc {\n-    let doc = fold::default_seq_fold_iface(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || methods_have_docs(doc.methods);\n-    ret doc;\n-}\n-\n-fn methods_have_docs(docs: [doc::methoddoc]) -> bool {\n-    vec::foldl(false, docs) {|accum, doc|\n-        accum\n-            || doc.brief != none\n-            || doc.desc != none\n-            || args_have_docs(doc.args)\n-            || doc.return.desc != none\n-            || doc.failure != none\n-    }\n-}\n-\n-#[test]\n-fn should_elide_undocumented_ifaces() {\n-    let doc = test::mk_doc(\"iface i { fn a(); }\");\n-    assert vec::is_empty(doc.cratemod().ifaces());\n-}\n-\n-#[test]\n-fn should_not_elide_documented_ifaces() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_not_empty(doc.cratemod().ifaces());\n-}\n-\n-#[test]\n-fn should_elide_ifaces_with_undocumented_args() {\n-    let doc = test::mk_doc(\"iface i { fn a(b: bool); }\");\n-    assert vec::is_empty(doc.cratemod().ifaces());\n-}\n-\n-#[test]\n-fn should_not_elide_ifaces_with_documented_methods() {\n-    let doc = test::mk_doc(\"iface i { #[doc = \\\"hey\\\"] fn a(); }\");\n-    assert vec::is_not_empty(doc.cratemod().ifaces());\n-}\n-\n-#[test]\n-fn should_not_elide_undocumented_iface_methods() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] iface i { fn a(); }\");\n-    assert vec::is_not_empty(doc.cratemod().ifaces()[0].methods);\n-}\n-\n-fn fold_impl(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::impldoc\n-) -> doc::impldoc {\n-    let doc = fold::default_seq_fold_impl(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none\n-        || methods_have_docs(doc.methods);\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_impls() {\n-    let doc = test::mk_doc(\"impl i for int { fn a() { } }\");\n-    assert vec::is_empty(doc.cratemod().impls());\n-}\n-\n-#[test]\n-fn should_not_elide_documented_impls() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] impl i for int { fn a() { } }\");\n-    assert vec::is_not_empty(doc.cratemod().impls());\n-}\n-\n-#[test]\n-fn should_not_elide_impls_with_documented_methods() {\n-    let doc = test::mk_doc(\"impl i for int { #[doc = \\\"hey\\\"] fn a() { } }\");\n-    assert vec::is_not_empty(doc.cratemod().impls());\n-}\n-\n-#[test]\n-fn should_not_elide_undocumented_impl_methods() {\n-    let doc = test::mk_doc(\"#[doc = \\\"hey\\\"] impl i for int { fn a() { } }\");\n-    assert vec::is_not_empty(doc.cratemod().impls()[0].methods);\n-}\n-\n-fn fold_type(\n-    fold: fold::fold<ctxt>,\n-    doc: doc::tydoc\n-) -> doc::tydoc {\n-    let doc = fold::default_seq_fold_type(fold, doc);\n-\n-    fold.ctxt.have_docs =\n-        doc.brief() != none\n-        || doc.desc() != none;\n-    ret doc;\n-}\n-\n-#[test]\n-fn should_elide_undocumented_types() {\n-    let doc = test::mk_doc(\"type t = int;\");\n-    assert vec::is_empty(doc.cratemod().types());\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    fn mk_doc(source: str) -> doc::doc {\n-        astsrv::from_str(source) {|srv|\n-            let doc = extract::from_srv(srv, \"\");\n-            let doc = attr_pass::mk_pass().f(srv, doc);\n-            run(srv, doc)\n-        }\n-    }\n-}"}, {"sha": "a4df1c7e8ea3647b48836c885d58f206baa62c26", "filename": "src/rustdoc/rustdoc.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rc?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -24,8 +24,6 @@ mod fold;\n mod path_pass;\n mod attr_pass;\n mod tystr_pass;\n-mod prune_undoc_details_pass;\n-mod prune_undoc_items_pass;\n mod prune_unexported_pass;\n mod prune_hidden_pass;\n mod desc_to_brief_pass;"}, {"sha": "e087dcefc306e95e3d2ef899f4b409b467d2a66c", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -143,9 +143,6 @@ fn run(config: config::config) {\n             tystr_pass::mk_pass(),\n             path_pass::mk_pass(),\n             attr_pass::mk_pass(),\n-            prune_undoc_details_pass::mk_pass(),\n-            // FIXME: This pass should be optional\n-            // prune_undoc_items_pass::mk_pass(),\n             prune_hidden_pass::mk_pass(),\n             desc_to_brief_pass::mk_pass(),\n             unindent_pass::mk_pass(),"}, {"sha": "97fb62445b614ca4a21709a85a7ba00d58664097", "filename": "src/rustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 98, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftext_pass.rs?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -20,9 +20,7 @@ fn run(\n ) -> doc::doc {\n     let fold = fold::fold({\n         fold_item: fold_item,\n-        fold_fn: fold_fn,\n         fold_enum: fold_enum,\n-        fold_res: fold_res,\n         fold_iface: fold_iface,\n         fold_impl: fold_impl\n         with *fold::default_any_fold(op)\n@@ -54,26 +52,6 @@ fn apply_to_sections(op: op, sections: [doc::section]) -> [doc::section] {\n     }\n }\n \n-fn fold_fn(fold: fold::fold<op>, doc: doc::fndoc) -> doc::fndoc {\n-    let fold_ctxt = fold.ctxt;\n-    let doc = fold::default_seq_fold_fn(fold, doc);\n-\n-    {\n-        args: par::anymap(doc.args) {|doc|\n-            {\n-                desc: maybe_apply_op(fold_ctxt, doc.desc)\n-                with doc\n-            }\n-        },\n-        return: {\n-            desc: maybe_apply_op(fold.ctxt, doc.return.desc)\n-            with doc.return\n-        },\n-        failure: maybe_apply_op(fold.ctxt, doc.failure)\n-        with doc\n-    }\n-}\n-\n fn fold_enum(fold: fold::fold<op>, doc: doc::enumdoc) -> doc::enumdoc {\n     let fold_ctxt = fold.ctxt;\n     let doc = fold::default_seq_fold_enum(fold, doc);\n@@ -89,21 +67,6 @@ fn fold_enum(fold: fold::fold<op>, doc: doc::enumdoc) -> doc::enumdoc {\n     }\n }\n \n-fn fold_res(fold: fold::fold<op>, doc: doc::resdoc) -> doc::resdoc {\n-    let fold_ctxt = fold.ctxt;\n-    let doc = fold::default_seq_fold_res(fold, doc);\n-\n-    {\n-        args: par::anymap(doc.args) {|arg|\n-            {\n-                desc: maybe_apply_op(fold_ctxt, arg.desc)\n-                with arg\n-            }\n-        }\n-        with doc\n-    }\n-}\n-\n fn fold_iface(fold: fold::fold<op>, doc: doc::ifacedoc) -> doc::ifacedoc {\n     let doc = fold::default_seq_fold_iface(fold, doc);\n \n@@ -118,18 +81,7 @@ fn apply_to_methods(op: op, docs: [doc::methoddoc]) -> [doc::methoddoc] {\n         {\n             brief: maybe_apply_op(op, doc.brief),\n             desc: maybe_apply_op(op, doc.desc),\n-            sections: apply_to_sections(op, doc.sections),\n-            args: par::anymap(doc.args) {|doc|\n-                {\n-                    desc: maybe_apply_op(op, doc.desc)\n-                    with doc\n-                }\n-            },\n-            return: {\n-                desc: maybe_apply_op(op, doc.return.desc)\n-                with doc.return\n-            },\n-            failure: maybe_apply_op(op, doc.failure)\n+            sections: apply_to_sections(op, doc.sections)\n             with doc\n         }\n     }\n@@ -174,13 +126,6 @@ fn should_execute_op_on_resource_desc() {\n     assert doc.cratemod().resources()[0].desc() == some(\"a\");\n }\n \n-#[test]\n-fn should_execute_op_on_resource_args() {\n-    let doc = test::mk_doc(\n-        \"#[doc(args(a = \\\" a \\\"))] resource r(a: bool) { }\");\n-    assert doc.cratemod().resources()[0].args[0].desc == some(\"a\");\n-}\n-\n #[test]\n fn should_execute_op_on_iface_brief() {\n     let doc = test::mk_doc(\n@@ -209,26 +154,6 @@ fn should_execute_op_on_iface_method_desc() {\n     assert doc.cratemod().ifaces()[0].methods[0].desc == some(\"a\");\n }\n \n-#[test]\n-fn should_execute_op_on_iface_method_args() {\n-    let doc = test::mk_doc(\n-        \"iface i { #[doc(args(a = \\\" a \\\"))] fn a(a: bool); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].args[0].desc == some(\"a\");\n-}\n-\n-#[test]\n-fn should_execute_op_on_iface_method_return() {\n-    let doc = test::mk_doc(\n-        \"iface i { #[doc(return = \\\" a \\\")] fn a() -> int; }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].return.desc == some(\"a\");\n-}\n-\n-#[test]\n-fn should_execute_op_on_iface_method_failure_condition() {\n-    let doc = test::mk_doc(\"iface i { #[doc(failure = \\\" a \\\")] fn a(); }\");\n-    assert doc.cratemod().ifaces()[0].methods[0].failure == some(\"a\");\n-}\n-\n #[test]\n fn should_execute_op_on_impl_brief() {\n     let doc = test::mk_doc(\n@@ -257,28 +182,6 @@ fn should_execute_op_on_impl_method_desc() {\n     assert doc.cratemod().impls()[0].methods[0].desc == some(\"a\");\n }\n \n-#[test]\n-fn should_execute_op_on_impl_method_args() {\n-    let doc = test::mk_doc(\n-        \"impl i for int { #[doc(args(a = \\\" a \\\"))] fn a(a: bool) { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].args[0].desc == some(\"a\");\n-}\n-\n-#[test]\n-fn should_execute_op_on_impl_method_return() {\n-    let doc = test::mk_doc(\n-        \"impl i for int { #[doc(return = \\\" a \\\")] fn a() -> int { fail } }\");\n-    assert doc.cratemod().impls()[0].methods[0].return.desc == some(\"a\");\n-}\n-\n-#[test]\n-fn should_execute_op_on_impl_method_failure_condition() {\n-    let doc = test::mk_doc(\n-        \"impl i for int { #[doc(failure = \\\" a \\\")] fn a() { } }\");\n-    assert doc.cratemod().impls()[0].methods[0].failure == some(\"a\");\n-}\n-\n-\n #[test]\n fn should_execute_op_on_type_brief() {\n     let doc = test::mk_doc("}, {"sha": "13382fb7d07ce17ec7d0efc82c623f088597616e", "filename": "src/rustdoc/trim_pass.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Ftrim_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Ftrim_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftrim_pass.rs?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -40,24 +40,6 @@ fn should_trim_fn() {\n     assert doc.cratemod().fns()[0].desc() == some(\"desc\");\n }\n \n-#[test]\n-fn should_trim_args() {\n-    let doc = test::mk_doc(\"#[doc(args(a = \\\"\\na\\n\\\"))] fn a(a: int) { }\");\n-    assert doc.cratemod().fns()[0].args[0].desc == some(\"a\");\n-}\n-\n-#[test]\n-fn should_trim_ret() {\n-    let doc = test::mk_doc(\"#[doc(return = \\\"\\na\\n\\\")] fn a() -> int { }\");\n-    assert doc.cratemod().fns()[0].return.desc == some(\"a\");\n-}\n-\n-#[test]\n-fn should_trim_failure_conditions() {\n-    let doc = test::mk_doc(\"#[doc(failure = \\\"\\na\\n\\\")] fn a() -> int { }\");\n-    assert doc.cratemod().fns()[0].failure == some(\"a\");\n-}\n-\n #[cfg(test)]\n mod test {\n     fn mk_doc(source: str) -> doc::doc {"}, {"sha": "949d3f7e65d30f9665225a7ccef57df81050ef04", "filename": "src/rustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0905ad2bbe66d11e73a6bef723d14c0e022c0943/src%2Frustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Ftystr_pass.rs?ref=0905ad2bbe66d11e73a6bef723d14c0e022c0943", "patch": "@@ -81,7 +81,7 @@ fn fold_const(\n     let srv = fold.ctxt;\n \n     {\n-        ty: some(astsrv::exec(srv) {|ctxt|\n+        sig: some(astsrv::exec(srv) {|ctxt|\n             alt check ctxt.ast_map.get(doc.id()) {\n               ast_map::node_item(@{\n                 node: ast::item_const(ty, _), _\n@@ -97,7 +97,7 @@ fn fold_const(\n #[test]\n fn should_add_const_types() {\n     let doc = test::mk_doc(\"const a: bool = true;\");\n-    assert doc.cratemod().consts()[0].ty == some(\"bool\");\n+    assert doc.cratemod().consts()[0].sig == some(\"bool\");\n }\n \n fn fold_enum("}]}