{"sha": "ed0e13f1d86124845606fd378f4ab3cec3d1c9b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMGUxM2YxZDg2MTI0ODQ1NjA2ZmQzNzhmNGFiM2NlYzNkMWM5YjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-07T16:09:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-08T01:05:58Z"}, "message": "fix old map impl, add logging", "tree": {"sha": "4e8dbb561d39310a1ba5eda670d84482ad631bdb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e8dbb561d39310a1ba5eda670d84482ad631bdb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed0e13f1d86124845606fd378f4ab3cec3d1c9b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed0e13f1d86124845606fd378f4ab3cec3d1c9b3", "html_url": "https://github.com/rust-lang/rust/commit/ed0e13f1d86124845606fd378f4ab3cec3d1c9b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed0e13f1d86124845606fd378f4ab3cec3d1c9b3/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30a2361e6848827036edae21fec795b958cc1b9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/30a2361e6848827036edae21fec795b958cc1b9d", "html_url": "https://github.com/rust-lang/rust/commit/30a2361e6848827036edae21fec795b958cc1b9d"}], "stats": {"total": 40, "additions": 25, "deletions": 15}, "files": [{"sha": "c581186e4d157cf4502d29aa40529ab4eed21a2d", "filename": "src/libstd/map.rs", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ed0e13f1d86124845606fd378f4ab3cec3d1c9b3/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed0e13f1d86124845606fd378f4ab3cec3d1c9b3/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=ed0e13f1d86124845606fd378f4ab3cec3d1c9b3", "patch": "@@ -384,14 +384,10 @@ fn mk_flat_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n     // is always a power? of 2), so that all buckets are probed for a\n     // fixed key.\n \n-    fn hashl(n: u32) -> u32 { ret (n >>> 16u32) * 2u32 + 1u32; }\n-    fn hashr(n: u32) -> u32 { ret 0x0000_ffff_u32 & n; }\n-    fn hash(h: u32, nbkts: uint, i: uint) -> uint {\n-        ret ((hashl(h) as uint) * i + (hashr(h) as uint)) % nbkts;\n-    }\n-\n-    fn to_u64(h: uint) -> u32 {\n-        ret (h as u32) ^ ((h >>> 16u) as u32);\n+    fn hashl(n: uint) -> uint { ret (n >>> 16u) * 2u + 1u; }\n+    fn hashr(n: uint) -> uint { ret 0x0000_ffff_u & n; }\n+    fn hash(h: uint, nbkts: uint, i: uint) -> uint {\n+        ret (hashl(h) * i + hashr(h)) % nbkts;\n     }\n \n     /**\n@@ -402,18 +398,26 @@ fn mk_flat_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n                                      bkts: [mutable bucket<K, V>],\n                                      nbkts: uint, key: K, val: V) -> bool {\n         let i: uint = 0u;\n-        let h = to_u64(hasher(key));\n+        let h = hasher(key);\n         while i < nbkts {\n             let j: uint = hash(h, nbkts, i);\n             alt bkts[j] {\n               some(k, _) {\n                 // Copy key to please alias analysis.\n \n                 let k_ = k;\n-                if eqer(key, k_) { bkts[j] = some(k_, val); ret false; }\n+                if eqer(key, k_) {\n+                    log(\"map updated\", \"i\", i, \"h\", h, \"nbkts\", nbkts);\n+                    bkts[j] = some(k_, val);\n+                    ret false;\n+                }\n                 i += 1u;\n               }\n-              _ { bkts[j] = some(key, val); ret true; }\n+              _ {\n+                log(\"map inserted\", \"i\", i, \"h\", h, \"nbkts\", nbkts);\n+                bkts[j] = some(key, val);\n+                ret true;\n+              }\n             }\n         }\n         fail; // full table\n@@ -422,17 +426,23 @@ fn mk_flat_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n                                    bkts: [mutable bucket<K, V>],\n                                    nbkts: uint, key: K) -> option::t<V> {\n         let i: uint = 0u;\n-        let h = to_u64(hasher(key));\n+        let h = hasher(key);\n         while i < nbkts {\n             let j: uint = hash(h, nbkts, i);\n             alt bkts[j] {\n               some(k, v) {\n                 // Copy to please alias analysis.\n                 let k_ = k;\n                 let v_ = v;\n-                if eqer(key, k_) { ret option::some(v_); }\n+                if eqer(key, k_) {\n+                    log(\"map present\", \"i\", i, \"h\", h, \"nbkts\", nbkts);\n+                    ret option::some(v_);\n+                }\n+              }\n+              nil. {\n+                log(\"map absent\", \"i\", i, \"h\", h, \"nbkts\", nbkts);\n+                ret option::none;\n               }\n-              nil. { ret option::none; }\n               deleted. { }\n             }\n             i += 1u;\n@@ -495,7 +505,7 @@ fn mk_flat_hashmap<copy K, copy V>(hasher: hashfn<K>, eqer: eqfn<K>)\n         }\n         fn remove(key: K) -> option::t<V> {\n             let i: uint = 0u;\n-            let h = to_u64(hasher(key));\n+            let h = hasher(key);\n             while i < nbkts {\n                 let j: uint = hash(h, nbkts, i);\n                 alt bkts[j] {"}]}