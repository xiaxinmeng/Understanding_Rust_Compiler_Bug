{"sha": "58a721af9f818bdf57f86448557b45c5ae19a3ef", "node_id": "C_kwDOAAsO6NoAKDU4YTcyMWFmOWY4MThiZGY1N2Y4NjQ0ODU1N2I0NWM1YWUxOWEzZWY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-22T07:54:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-22T07:54:22Z"}, "message": "Auto merge of #93839 - Mark-Simulacrum:delete-json-rust-deserialization, r=nnethercote\n\nSimplify rustc_serialize by dropping support for decoding into JSON\n\nThis PR currently bundles two (somewhat separate) tasks.\n\nFirst, it removes the JSON Decoder trait impl, which permitted going from JSON to Rust structs. For now, we keep supporting JSON deserialization, but only to `Json` (an equivalent of serde_json::Value). The primary hard to remove user there is for custom targets -- which need some form of JSON deserialization -- but they already have a custom ad-hoc pass for moving from Json to a Rust struct.\n\nA [comment](https://github.com/rust-lang/rust/blob/e7aca895980f25f6d2d3c48e10fd04656764d1e4/compiler/rustc_target/src/spec/mod.rs#L1653) there suggests that it would be impractical to move them to a Decodable-based impl, at least without backwards compatibility concerns. I suspect that if we were widely breaking compat there, it would make sense to use serde_json at this point which would produce better error messages; the types in rustc_target are relatively isolated so we would not particularly suffer from using serde_derive.\n\nThe second part of the PR (all but the first commit) is to simplify the Decoder API by removing the non-primitive `read_*` functions. These primarily add indirection (through a closure), which doesn't directly cause a performance issue (the unique closure types essentially guarantee monomorphization), but does increase the amount of work rustc and LLVM need to do. This could be split out to a separate PR, but is included here in part to help motivate the first part.\n\nFuture work might consist of:\n\n* Specializing enum discriminant encoding to avoid leb128 for small enums (since we know the variant count, we can directly use read/write u8 in almost all cases)\n* Adding new methods to support faster deserialization (e.g., access to the underlying byte stream)\n   * Currently these are somewhat ad-hoc supported by specializations for e.g. `Vec<u8>`, but other types which could benefit don't today.\n* Removing the Decoder trait entirely in favor of a concrete type -- today, we only really have one impl of it modulo wrappers used for specialization-based dispatch.\n\nHighly recommend review with whitespace changes off, as the removal of closures frequently causes things to be de-indented.", "tree": {"sha": "086ddac67129cf7c2503daae81f5b0e03706ba81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/086ddac67129cf7c2503daae81f5b0e03706ba81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58a721af9f818bdf57f86448557b45c5ae19a3ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58a721af9f818bdf57f86448557b45c5ae19a3ef", "html_url": "https://github.com/rust-lang/rust/commit/58a721af9f818bdf57f86448557b45c5ae19a3ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58a721af9f818bdf57f86448557b45c5ae19a3ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "html_url": "https://github.com/rust-lang/rust/commit/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a"}, {"sha": "c6ad61a1bd2d82f4ac8f7e3c069caa1c2f52c1b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ad61a1bd2d82f4ac8f7e3c069caa1c2f52c1b4", "html_url": "https://github.com/rust-lang/rust/commit/c6ad61a1bd2d82f4ac8f7e3c069caa1c2f52c1b4"}], "stats": {"total": 1267, "additions": 208, "deletions": 1059}, "files": [{"sha": "ed01afe6e303d90ba94489bd092d20dd3e4633f0", "filename": "compiler/rustc_errors/src/json/tests.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -5,17 +5,12 @@ use rustc_span::source_map::{FilePathMapping, SourceMap};\n \n use crate::emitter::{ColorConfig, HumanReadableErrorType};\n use crate::Handler;\n-use rustc_serialize::json::decode;\n+use rustc_serialize::json;\n use rustc_span::{BytePos, Span};\n \n use std::str;\n \n-#[derive(Decodable, Debug, PartialEq, Eq)]\n-struct TestData {\n-    spans: Vec<SpanTestData>,\n-}\n-\n-#[derive(Decodable, Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n struct SpanTestData {\n     pub byte_start: u32,\n     pub byte_end: u32,\n@@ -41,8 +36,6 @@ impl<T: Write> Write for Shared<T> {\n \n /// Test the span yields correct positions in JSON.\n fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n-    let expected_output = TestData { spans: vec![expected_output] };\n-\n     rustc_span::create_default_session_globals_then(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         sm.new_source_file(Path::new(\"test.rs\").to_owned().into(), code.to_owned());\n@@ -64,9 +57,19 @@ fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n \n         let bytes = output.lock().unwrap();\n         let actual_output = str::from_utf8(&bytes).unwrap();\n-        let actual_output: TestData = decode(actual_output);\n-\n-        assert_eq!(expected_output, actual_output)\n+        let actual_output = json::from_str(&actual_output).unwrap();\n+        let spans = actual_output[\"spans\"].as_array().unwrap();\n+        assert_eq!(spans.len(), 1);\n+        let obj = &spans[0];\n+        let actual_output = SpanTestData {\n+            byte_start: obj[\"byte_start\"].as_u64().unwrap() as u32,\n+            byte_end: obj[\"byte_end\"].as_u64().unwrap() as u32,\n+            line_start: obj[\"line_start\"].as_u64().unwrap() as u32,\n+            line_end: obj[\"line_end\"].as_u64().unwrap() as u32,\n+            column_start: obj[\"column_start\"].as_u64().unwrap() as u32,\n+            column_end: obj[\"column_end\"].as_u64().unwrap() as u32,\n+        };\n+        assert_eq!(expected_output, actual_output);\n     })\n }\n "}, {"sha": "535158ffd8d844d4461109681c175ef8d0daf627", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 8, "deletions": 45, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -42,51 +42,26 @@ fn decodable_body(\n     }\n     let ty_name = s.ast().ident.to_string();\n     let decode_body = match s.variants() {\n-        [vi] => {\n-            let construct = vi.construct(|field, index| decode_field(field, index, true));\n-            quote! {\n-                ::rustc_serialize::Decoder::read_struct(\n-                    __decoder,\n-                    |__decoder| { #construct },\n-                )\n-            }\n-        }\n+        [vi] => vi.construct(|field, _index| decode_field(field)),\n         variants => {\n             let match_inner: TokenStream = variants\n                 .iter()\n                 .enumerate()\n                 .map(|(idx, vi)| {\n-                    let construct = vi.construct(|field, index| decode_field(field, index, false));\n+                    let construct = vi.construct(|field, _index| decode_field(field));\n                     quote! { #idx => { #construct } }\n                 })\n                 .collect();\n-            let names: TokenStream = variants\n-                .iter()\n-                .map(|vi| {\n-                    let variant_name = vi.ast().ident.to_string();\n-                    quote!(#variant_name,)\n-                })\n-                .collect();\n             let message = format!(\n                 \"invalid enum variant tag while decoding `{}`, expected 0..{}\",\n                 ty_name,\n                 variants.len()\n             );\n             quote! {\n-                ::rustc_serialize::Decoder::read_enum(\n-                    __decoder,\n-                    |__decoder| {\n-                        ::rustc_serialize::Decoder::read_enum_variant(\n-                            __decoder,\n-                            &[#names],\n-                            |__decoder, __variant_idx| {\n-                                match __variant_idx {\n-                                    #match_inner\n-                                    _ => panic!(#message),\n-                                }\n-                            })\n-                    }\n-                )\n+                match ::rustc_serialize::Decoder::read_usize(__decoder) {\n+                    #match_inner\n+                    _ => panic!(#message),\n+                }\n             }\n         }\n     };\n@@ -101,30 +76,18 @@ fn decodable_body(\n     )\n }\n \n-fn decode_field(field: &syn::Field, index: usize, is_struct: bool) -> proc_macro2::TokenStream {\n+fn decode_field(field: &syn::Field) -> proc_macro2::TokenStream {\n     let field_span = field.ident.as_ref().map_or(field.ty.span(), |ident| ident.span());\n \n     let decode_inner_method = if let syn::Type::Reference(_) = field.ty {\n         quote! { ::rustc_middle::ty::codec::RefDecodable::decode }\n     } else {\n         quote! { ::rustc_serialize::Decodable::decode }\n     };\n-    let (decode_method, opt_field_name) = if is_struct {\n-        let field_name = field.ident.as_ref().map_or_else(|| index.to_string(), |i| i.to_string());\n-        (proc_macro2::Ident::new(\"read_struct_field\", field_span), quote! { #field_name, })\n-    } else {\n-        (proc_macro2::Ident::new(\"read_enum_variant_arg\", field_span), quote! {})\n-    };\n-\n     let __decoder = quote! { __decoder };\n     // Use the span of the field for the method call, so\n     // that backtraces will point to the field.\n-    let decode_call = quote_spanned! {field_span=>\n-        ::rustc_serialize::Decoder::#decode_method(\n-                #__decoder, #opt_field_name #decode_inner_method)\n-    };\n-\n-    quote! { #decode_call }\n+    quote_spanned! {field_span=> #decode_inner_method(#__decoder) }\n }\n \n pub fn type_encodable_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {"}, {"sha": "9778f77384cf93dd9bc974c177de2b54fec4bbe2", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -122,29 +122,24 @@ impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<\n         let mut edge_list_data = Vec::with_capacity(edge_count);\n \n         for _index in 0..node_count {\n-            d.read_struct(|d| {\n-                let dep_node: DepNode<K> = d.read_struct_field(\"node\", Decodable::decode);\n-                let _i: SerializedDepNodeIndex = nodes.push(dep_node);\n-                debug_assert_eq!(_i.index(), _index);\n-\n-                let fingerprint: Fingerprint =\n-                    d.read_struct_field(\"fingerprint\", Decodable::decode);\n-                let _i: SerializedDepNodeIndex = fingerprints.push(fingerprint);\n-                debug_assert_eq!(_i.index(), _index);\n-\n-                d.read_struct_field(\"edges\", |d| {\n-                    d.read_seq(|d, len| {\n-                        let start = edge_list_data.len().try_into().unwrap();\n-                        for _ in 0..len {\n-                            let edge = d.read_seq_elt(Decodable::decode);\n-                            edge_list_data.push(edge);\n-                        }\n-                        let end = edge_list_data.len().try_into().unwrap();\n-                        let _i: SerializedDepNodeIndex = edge_list_indices.push((start, end));\n-                        debug_assert_eq!(_i.index(), _index);\n-                    })\n-                })\n-            });\n+            let dep_node: DepNode<K> = Decodable::decode(d);\n+            let _i: SerializedDepNodeIndex = nodes.push(dep_node);\n+            debug_assert_eq!(_i.index(), _index);\n+\n+            let fingerprint: Fingerprint = Decodable::decode(d);\n+            let _i: SerializedDepNodeIndex = fingerprints.push(fingerprint);\n+            debug_assert_eq!(_i.index(), _index);\n+\n+            // Deserialize edges -- sequence of DepNodeIndex\n+            let len = d.read_usize();\n+            let start = edge_list_data.len().try_into().unwrap();\n+            for _ in 0..len {\n+                let edge = Decodable::decode(d);\n+                edge_list_data.push(edge);\n+            }\n+            let end = edge_list_data.len().try_into().unwrap();\n+            let _i: SerializedDepNodeIndex = edge_list_indices.push((start, end));\n+            debug_assert_eq!(_i.index(), _index);\n         }\n \n         let index: FxHashMap<_, _> ="}, {"sha": "dee6dc010feef8046769ec2f4b1b7fca54cf23cf", "filename": "compiler/rustc_serialize/src/collection_impls.rs", "status": "modified", "additions": 52, "deletions": 55, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -18,7 +18,8 @@ impl<S: Encoder, A: Array<Item: Encodable<S>>> Encodable<S> for SmallVec<A> {\n \n impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n     fn decode(d: &mut D) -> SmallVec<A> {\n-        d.read_seq(|d, len| (0..len).map(|_| d.read_seq_elt(|d| Decodable::decode(d))).collect())\n+        let len = d.read_usize();\n+        (0..len).map(|_| Decodable::decode(d)).collect()\n     }\n }\n \n@@ -35,7 +36,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for LinkedList<T> {\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n     fn decode(d: &mut D) -> LinkedList<T> {\n-        d.read_seq(|d, len| (0..len).map(|_| d.read_seq_elt(|d| Decodable::decode(d))).collect())\n+        let len = d.read_usize();\n+        (0..len).map(|_| Decodable::decode(d)).collect()\n     }\n }\n \n@@ -52,7 +54,8 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for VecDeque<T> {\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for VecDeque<T> {\n     fn decode(d: &mut D) -> VecDeque<T> {\n-        d.read_seq(|d, len| (0..len).map(|_| d.read_seq_elt(|d| Decodable::decode(d))).collect())\n+        let len = d.read_usize();\n+        (0..len).map(|_| Decodable::decode(d)).collect()\n     }\n }\n \n@@ -78,15 +81,14 @@ where\n     V: Decodable<D>,\n {\n     fn decode(d: &mut D) -> BTreeMap<K, V> {\n-        d.read_map(|d, len| {\n-            let mut map = BTreeMap::new();\n-            for _ in 0..len {\n-                let key = d.read_map_elt_key(|d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(|d| Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        })\n+        let len = d.read_usize();\n+        let mut map = BTreeMap::new();\n+        for _ in 0..len {\n+            let key = Decodable::decode(d);\n+            let val = Decodable::decode(d);\n+            map.insert(key, val);\n+        }\n+        map\n     }\n }\n \n@@ -109,13 +111,12 @@ where\n     T: Decodable<D> + PartialEq + Ord,\n {\n     fn decode(d: &mut D) -> BTreeSet<T> {\n-        d.read_seq(|d, len| {\n-            let mut set = BTreeSet::new();\n-            for _ in 0..len {\n-                set.insert(d.read_seq_elt(|d| Decodable::decode(d)));\n-            }\n-            set\n-        })\n+        let len = d.read_usize();\n+        let mut set = BTreeSet::new();\n+        for _ in 0..len {\n+            set.insert(Decodable::decode(d));\n+        }\n+        set\n     }\n }\n \n@@ -143,16 +144,15 @@ where\n     S: BuildHasher + Default,\n {\n     fn decode(d: &mut D) -> HashMap<K, V, S> {\n-        d.read_map(|d, len| {\n-            let state = Default::default();\n-            let mut map = HashMap::with_capacity_and_hasher(len, state);\n-            for _ in 0..len {\n-                let key = d.read_map_elt_key(|d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(|d| Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        })\n+        let len = d.read_usize();\n+        let state = Default::default();\n+        let mut map = HashMap::with_capacity_and_hasher(len, state);\n+        for _ in 0..len {\n+            let key = Decodable::decode(d);\n+            let val = Decodable::decode(d);\n+            map.insert(key, val);\n+        }\n+        map\n     }\n }\n \n@@ -187,14 +187,13 @@ where\n     S: BuildHasher + Default,\n {\n     fn decode(d: &mut D) -> HashSet<T, S> {\n-        d.read_seq(|d, len| {\n-            let state = Default::default();\n-            let mut set = HashSet::with_capacity_and_hasher(len, state);\n-            for _ in 0..len {\n-                set.insert(d.read_seq_elt(|d| Decodable::decode(d)));\n-            }\n-            set\n-        })\n+        let len = d.read_usize();\n+        let state = Default::default();\n+        let mut set = HashSet::with_capacity_and_hasher(len, state);\n+        for _ in 0..len {\n+            set.insert(Decodable::decode(d));\n+        }\n+        set\n     }\n }\n \n@@ -222,16 +221,15 @@ where\n     S: BuildHasher + Default,\n {\n     fn decode(d: &mut D) -> indexmap::IndexMap<K, V, S> {\n-        d.read_map(|d, len| {\n-            let state = Default::default();\n-            let mut map = indexmap::IndexMap::with_capacity_and_hasher(len, state);\n-            for _ in 0..len {\n-                let key = d.read_map_elt_key(|d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(|d| Decodable::decode(d));\n-                map.insert(key, val);\n-            }\n-            map\n-        })\n+        let len = d.read_usize();\n+        let state = Default::default();\n+        let mut map = indexmap::IndexMap::with_capacity_and_hasher(len, state);\n+        for _ in 0..len {\n+            let key = Decodable::decode(d);\n+            let val = Decodable::decode(d);\n+            map.insert(key, val);\n+        }\n+        map\n     }\n }\n \n@@ -256,14 +254,13 @@ where\n     S: BuildHasher + Default,\n {\n     fn decode(d: &mut D) -> indexmap::IndexSet<T, S> {\n-        d.read_seq(|d, len| {\n-            let state = Default::default();\n-            let mut set = indexmap::IndexSet::with_capacity_and_hasher(len, state);\n-            for _ in 0..len {\n-                set.insert(d.read_seq_elt(|d| Decodable::decode(d)));\n-            }\n-            set\n-        })\n+        let len = d.read_usize();\n+        let state = Default::default();\n+        let mut set = indexmap::IndexSet::with_capacity_and_hasher(len, state);\n+        for _ in 0..len {\n+            set.insert(Decodable::decode(d));\n+        }\n+        set\n     }\n }\n "}, {"sha": "0cbea3a07a8d450864ab5af35118f1a89348f97e", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 7, "deletions": 314, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -45,12 +45,9 @@\n //!\n //! # Rust Type-based Encoding and Decoding\n //!\n-//! Rust provides a mechanism for low boilerplate encoding & decoding of values to and from JSON via\n-//! the serialization API.\n-//! To be able to encode a piece of data, it must implement the `serialize::Encodable` trait.\n-//! To be able to decode a piece of data, it must implement the `serialize::Decodable` trait.\n-//! The Rust compiler provides an annotation to automatically generate the code for these traits:\n-//! `#[derive(Decodable, Encodable)]`\n+//! To be able to encode a piece of data, it must implement the\n+//! `serialize::Encodable` trait.  The `rustc_macros` crate provides an\n+//! annotation to automatically generate the code for this trait: `#[derive(Encodable)]`.\n //!\n //! The JSON API provides an enum `json::Json` and a trait `ToJson` to encode objects.\n //! The `ToJson` trait provides a `to_json` method to convert an object into a `json::Json` value.\n@@ -68,11 +65,11 @@\n //!\n //! ```rust\n //! # #![feature(rustc_private)]\n-//! use rustc_macros::{Decodable, Encodable};\n+//! use rustc_macros::{Encodable};\n //! use rustc_serialize::json;\n //!\n-//! // Automatically generate `Decodable` and `Encodable` trait implementations\n-//! #[derive(Decodable, Encodable)]\n+//! // Automatically generate `Encodable` trait implementations\n+//! #[derive(Encodable)]\n //! pub struct TestStruct  {\n //!     data_int: u8,\n //!     data_str: String,\n@@ -87,9 +84,6 @@\n //!\n //! // Serialize using `json::encode`\n //! let encoded = json::encode(&object).unwrap();\n-//!\n-//! // Deserialize using `json::decode`\n-//! let decoded: TestStruct = json::decode(&encoded[..]);\n //! ```\n //!\n //! ## Using the `ToJson` trait\n@@ -139,12 +133,9 @@\n //!\n //! ```rust\n //! # #![feature(rustc_private)]\n-//! use rustc_macros::Decodable;\n //! use std::collections::BTreeMap;\n-//! use rustc_serialize::json::{self, Json, ToJson};\n+//! use rustc_serialize::json::{Json, ToJson};\n //!\n-//! // Only generate `Decodable` trait implementation\n-//! #[derive(Decodable)]\n //! pub struct TestStruct {\n //!     data_int: u8,\n //!     data_str: String,\n@@ -171,19 +162,14 @@\n //! };\n //! let json_obj: Json = input_data.to_json();\n //! let json_str: String = json_obj.to_string();\n-//!\n-//! // Deserialize like before\n-//! let decoded: TestStruct = json::decode(&json_str);\n //! ```\n \n-use self::DecoderError::*;\n use self::ErrorCode::*;\n use self::InternalStackElement::*;\n use self::JsonEvent::*;\n use self::ParserError::*;\n use self::ParserState::*;\n \n-use std::borrow::Cow;\n use std::collections::{BTreeMap, HashMap};\n use std::mem::swap;\n use std::num::FpCategory as Fp;\n@@ -253,21 +239,6 @@ pub enum ParserError {\n // Builder and Parser have the same errors.\n pub type BuilderError = ParserError;\n \n-#[derive(Clone, PartialEq, Debug)]\n-pub enum DecoderError {\n-    ParseError(ParserError),\n-    ExpectedError(string::String, string::String),\n-    MissingFieldError(string::String),\n-    UnknownVariantError(string::String),\n-    ApplicationError(string::String),\n-}\n-\n-macro_rules! bad {\n-    ($e:expr) => {{\n-        panic!(\"json decode error: {:?}\", $e);\n-    }};\n-}\n-\n #[derive(Copy, Clone, Debug)]\n pub enum EncoderError {\n     FmtError(fmt::Error),\n@@ -297,17 +268,6 @@ pub fn error_str(error: ErrorCode) -> &'static str {\n     }\n }\n \n-/// Shortcut function to decode a JSON `&str` into an object\n-pub fn decode<T: crate::Decodable<Decoder>>(s: &str) -> T {\n-    let json = match from_str(s) {\n-        Ok(x) => x,\n-        Err(e) => bad!(ParseError(e)),\n-    };\n-\n-    let mut decoder = Decoder::new(json);\n-    crate::Decodable::decode(&mut decoder)\n-}\n-\n /// Shortcut function to encode a `T` into a JSON `String`\n pub fn encode<T: for<'r> crate::Encodable<Encoder<'r>>>(\n     object: &T,\n@@ -352,7 +312,6 @@ impl From<fmt::Error> for EncoderError {\n }\n \n pub type EncodeResult = Result<(), EncoderError>;\n-pub type DecodeResult<T> = Result<T, DecoderError>;\n \n fn escape_str(wr: &mut dyn fmt::Write, v: &str) -> EncodeResult {\n     wr.write_str(\"\\\"\")?;\n@@ -2162,272 +2121,6 @@ pub fn from_str(s: &str) -> Result<Json, BuilderError> {\n     builder.build()\n }\n \n-/// A structure to decode JSON to values in rust.\n-pub struct Decoder {\n-    stack: Vec<Json>,\n-}\n-\n-impl Decoder {\n-    /// Creates a new decoder instance for decoding the specified JSON value.\n-    pub fn new(json: Json) -> Decoder {\n-        Decoder { stack: vec![json] }\n-    }\n-\n-    fn pop(&mut self) -> Json {\n-        self.stack.pop().unwrap()\n-    }\n-}\n-\n-macro_rules! expect {\n-    ($e:expr, Null) => {{\n-        match $e {\n-            Json::Null => (),\n-            other => bad!(ExpectedError(\"Null\".to_owned(), other.to_string())),\n-        }\n-    }};\n-    ($e:expr, $t:ident) => {{\n-        match $e {\n-            Json::$t(v) => v,\n-            other => bad!(ExpectedError(stringify!($t).to_owned(), other.to_string())),\n-        }\n-    }};\n-}\n-\n-macro_rules! read_primitive {\n-    ($name:ident, $ty:ty) => {\n-        fn $name(&mut self) -> $ty {\n-            match self.pop() {\n-                Json::I64(f) => f as $ty,\n-                Json::U64(f) => f as $ty,\n-                Json::F64(f) => bad!(ExpectedError(\"Integer\".to_owned(), f.to_string())),\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n-                // is going to have a string here, as per JSON spec.\n-                Json::String(s) => match s.parse().ok() {\n-                    Some(f) => f,\n-                    None => bad!(ExpectedError(\"Number\".to_owned(), s)),\n-                },\n-                value => bad!(ExpectedError(\"Number\".to_owned(), value.to_string())),\n-            }\n-        }\n-    };\n-}\n-\n-impl crate::Decoder for Decoder {\n-    fn read_unit(&mut self) -> () {\n-        expect!(self.pop(), Null)\n-    }\n-\n-    read_primitive! { read_usize, usize }\n-    read_primitive! { read_u8, u8 }\n-    read_primitive! { read_u16, u16 }\n-    read_primitive! { read_u32, u32 }\n-    read_primitive! { read_u64, u64 }\n-    read_primitive! { read_u128, u128 }\n-    read_primitive! { read_isize, isize }\n-    read_primitive! { read_i8, i8 }\n-    read_primitive! { read_i16, i16 }\n-    read_primitive! { read_i32, i32 }\n-    read_primitive! { read_i64, i64 }\n-    read_primitive! { read_i128, i128 }\n-\n-    fn read_f32(&mut self) -> f32 {\n-        self.read_f64() as f32\n-    }\n-\n-    fn read_f64(&mut self) -> f64 {\n-        match self.pop() {\n-            Json::I64(f) => f as f64,\n-            Json::U64(f) => f as f64,\n-            Json::F64(f) => f,\n-            Json::String(s) => {\n-                // re: #12967.. a type w/ numeric keys (ie HashMap<usize, V> etc)\n-                // is going to have a string here, as per JSON spec.\n-                match s.parse().ok() {\n-                    Some(f) => f,\n-                    None => bad!(ExpectedError(\"Number\".to_owned(), s)),\n-                }\n-            }\n-            Json::Null => f64::NAN,\n-            value => bad!(ExpectedError(\"Number\".to_owned(), value.to_string())),\n-        }\n-    }\n-\n-    fn read_bool(&mut self) -> bool {\n-        expect!(self.pop(), Boolean)\n-    }\n-\n-    fn read_char(&mut self) -> char {\n-        let s = self.read_str();\n-        let mut it = s.chars();\n-        if let (Some(c), None) = (it.next(), it.next()) {\n-            // exactly one character\n-            return c;\n-        }\n-        bad!(ExpectedError(\"single character string\".to_owned(), s.to_string()));\n-    }\n-\n-    fn read_str(&mut self) -> Cow<'_, str> {\n-        Cow::Owned(expect!(self.pop(), String))\n-    }\n-\n-    fn read_raw_bytes_into(&mut self, s: &mut [u8]) {\n-        for c in s.iter_mut() {\n-            *c = self.read_u8();\n-        }\n-    }\n-\n-    fn read_enum<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    fn read_enum_variant<T, F>(&mut self, names: &[&str], mut f: F) -> T\n-    where\n-        F: FnMut(&mut Decoder, usize) -> T,\n-    {\n-        let name = match self.pop() {\n-            Json::String(s) => s,\n-            Json::Object(mut o) => {\n-                let n = match o.remove(\"variant\") {\n-                    Some(Json::String(s)) => s,\n-                    Some(val) => bad!(ExpectedError(\"String\".to_owned(), val.to_string())),\n-                    None => bad!(MissingFieldError(\"variant\".to_owned())),\n-                };\n-                match o.remove(\"fields\") {\n-                    Some(Json::Array(l)) => {\n-                        self.stack.extend(l.into_iter().rev());\n-                    }\n-                    Some(val) => bad!(ExpectedError(\"Array\".to_owned(), val.to_string())),\n-                    None => bad!(MissingFieldError(\"fields\".to_owned())),\n-                }\n-                n\n-            }\n-            json => bad!(ExpectedError(\"String or Object\".to_owned(), json.to_string())),\n-        };\n-        let Some(idx) = names.iter().position(|n| *n == &name[..]) else {\n-            bad!(UnknownVariantError(name));\n-        };\n-        f(self, idx)\n-    }\n-\n-    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    fn read_struct<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        let value = f(self);\n-        self.pop();\n-        value\n-    }\n-\n-    fn read_struct_field<T, F>(&mut self, name: &str, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        let mut obj = expect!(self.pop(), Object);\n-\n-        let value = match obj.remove(name) {\n-            None => {\n-                // Add a Null and try to parse it as an Option<_>\n-                // to get None as a default value.\n-                self.stack.push(Json::Null);\n-                f(self)\n-            }\n-            Some(json) => {\n-                self.stack.push(json);\n-                f(self)\n-            }\n-        };\n-        self.stack.push(Json::Object(obj));\n-        value\n-    }\n-\n-    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        self.read_seq(move |d, len| {\n-            if len == tuple_len {\n-                f(d)\n-            } else {\n-                bad!(ExpectedError(format!(\"Tuple{}\", tuple_len), format!(\"Tuple{}\", len)));\n-            }\n-        })\n-    }\n-\n-    fn read_tuple_arg<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        self.read_seq_elt(f)\n-    }\n-\n-    fn read_option<T, F>(&mut self, mut f: F) -> T\n-    where\n-        F: FnMut(&mut Decoder, bool) -> T,\n-    {\n-        match self.pop() {\n-            Json::Null => f(self, false),\n-            value => {\n-                self.stack.push(value);\n-                f(self, true)\n-            }\n-        }\n-    }\n-\n-    fn read_seq<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder, usize) -> T,\n-    {\n-        let array = expect!(self.pop(), Array);\n-        let len = array.len();\n-        self.stack.extend(array.into_iter().rev());\n-        f(self, len)\n-    }\n-\n-    fn read_seq_elt<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    fn read_map<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder, usize) -> T,\n-    {\n-        let obj = expect!(self.pop(), Object);\n-        let len = obj.len();\n-        for (key, value) in obj {\n-            self.stack.push(value);\n-            self.stack.push(Json::String(key));\n-        }\n-        f(self, len)\n-    }\n-\n-    fn read_map_elt_key<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    fn read_map_elt_val<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Decoder) -> T,\n-    {\n-        f(self)\n-    }\n-}\n-\n /// A trait for converting values to JSON\n pub trait ToJson {\n     /// Converts the value of `self` to an instance of JSON"}, {"sha": "a012be2857e1eb802aa1a7e0d004617663c6df6b", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 31, "deletions": 154, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -200,118 +200,6 @@ pub trait Decoder {\n     fn read_char(&mut self) -> char;\n     fn read_str(&mut self) -> Cow<'_, str>;\n     fn read_raw_bytes_into(&mut self, s: &mut [u8]);\n-\n-    // Compound types:\n-    #[inline]\n-    fn read_enum<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F) -> T\n-    where\n-        F: FnMut(&mut Self, usize) -> T,\n-    {\n-        let disr = self.read_usize();\n-        f(self, disr)\n-    }\n-\n-    #[inline]\n-    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn read_struct<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn read_struct_field<T, F>(&mut self, _f_name: &str, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn read_tuple<T, F>(&mut self, _len: usize, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn read_tuple_arg<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    // Specialized types:\n-    fn read_option<T, F>(&mut self, mut f: F) -> T\n-    where\n-        F: FnMut(&mut Self, bool) -> T,\n-    {\n-        self.read_enum(move |this| {\n-            this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| match idx {\n-                0 => f(this, false),\n-                1 => f(this, true),\n-                _ => panic!(\"read_option: expected 0 for None or 1 for Some\"),\n-            })\n-        })\n-    }\n-\n-    fn read_seq<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self, usize) -> T,\n-    {\n-        let len = self.read_usize();\n-        f(self, len)\n-    }\n-\n-    #[inline]\n-    fn read_seq_elt<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    fn read_map<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self, usize) -> T,\n-    {\n-        let len = self.read_usize();\n-        f(self, len)\n-    }\n-\n-    #[inline]\n-    fn read_map_elt_key<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n-        f(self)\n-    }\n-\n-    #[inline]\n-    fn read_map_elt_val<T, F>(&mut self, f: F) -> T\n-    where\n-        F: FnOnce(&mut Self) -> T,\n-    {\n-        f(self)\n-    }\n }\n \n /// Trait for types that can be serialized\n@@ -493,22 +381,18 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for Vec<T> {\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n     default fn decode(d: &mut D) -> Vec<T> {\n-        d.read_seq(|d, len| {\n-            // SAFETY: we set the capacity in advance, only write elements, and\n-            // only set the length at the end once the writing has succeeded.\n-            let mut vec = Vec::with_capacity(len);\n-            unsafe {\n-                let ptr: *mut T = vec.as_mut_ptr();\n-                for i in 0..len {\n-                    std::ptr::write(\n-                        ptr.offset(i as isize),\n-                        d.read_seq_elt(|d| Decodable::decode(d)),\n-                    );\n-                }\n-                vec.set_len(len);\n+        let len = d.read_usize();\n+        // SAFETY: we set the capacity in advance, only write elements, and\n+        // only set the length at the end once the writing has succeeded.\n+        let mut vec = Vec::with_capacity(len);\n+        unsafe {\n+            let ptr: *mut T = vec.as_mut_ptr();\n+            for i in 0..len {\n+                std::ptr::write(ptr.offset(i as isize), Decodable::decode(d));\n             }\n-            vec\n-        })\n+            vec.set_len(len);\n+        }\n+        vec\n     }\n }\n \n@@ -521,14 +405,13 @@ impl<S: Encoder, T: Encodable<S>, const N: usize> Encodable<S> for [T; N] {\n \n impl<D: Decoder, const N: usize> Decodable<D> for [u8; N] {\n     fn decode(d: &mut D) -> [u8; N] {\n-        d.read_seq(|d, len| {\n-            assert!(len == N);\n-            let mut v = [0u8; N];\n-            for i in 0..len {\n-                v[i] = d.read_seq_elt(|d| Decodable::decode(d));\n-            }\n-            v\n-        })\n+        let len = d.read_usize();\n+        assert!(len == N);\n+        let mut v = [0u8; N];\n+        for i in 0..len {\n+            v[i] = Decodable::decode(d);\n+        }\n+        v\n     }\n }\n \n@@ -563,7 +446,11 @@ impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n \n impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n     fn decode(d: &mut D) -> Option<T> {\n-        d.read_option(|d, b| if b { Some(Decodable::decode(d)) } else { None })\n+        match d.read_usize() {\n+            0 => None,\n+            1 => Some(Decodable::decode(d)),\n+            _ => panic!(\"Encountered invalid discriminant while decoding `Option`.\"),\n+        }\n     }\n }\n \n@@ -582,13 +469,11 @@ impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1,\n \n impl<D: Decoder, T1: Decodable<D>, T2: Decodable<D>> Decodable<D> for Result<T1, T2> {\n     fn decode(d: &mut D) -> Result<T1, T2> {\n-        d.read_enum(|d| {\n-            d.read_enum_variant(&[\"Ok\", \"Err\"], |d, disr| match disr {\n-                0 => Ok(d.read_enum_variant_arg(|d| T1::decode(d))),\n-                1 => Err(d.read_enum_variant_arg(|d| T2::decode(d))),\n-                _ => panic!(\"Encountered invalid discriminant while decoding `Result`.\"),\n-            })\n-        })\n+        match d.read_usize() {\n+            0 => Ok(T1::decode(d)),\n+            1 => Err(T2::decode(d)),\n+            _ => panic!(\"Encountered invalid discriminant while decoding `Result`.\"),\n+        }\n     }\n }\n \n@@ -613,24 +498,16 @@ macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n         impl<D: Decoder, $($name: Decodable<D>),+> Decodable<D> for ($($name,)+) {\n-            #[allow(non_snake_case)]\n             fn decode(d: &mut D) -> ($($name,)+) {\n-                let len: usize = count!($($name)+);\n-                d.read_tuple(len, |d| {\n-                    let ret = ($(d.read_tuple_arg(|d| -> $name {\n-                        Decodable::decode(d)\n-                    }),)+);\n-                    ret\n-                })\n+                ($({ let element: $name = Decodable::decode(d); element },)+)\n             }\n         }\n         impl<S: Encoder, $($name: Encodable<S>),+> Encodable<S> for ($($name,)+) {\n             #[allow(non_snake_case)]\n             fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n                 let ($(ref $name,)+) = *self;\n-                let mut n = 0;\n-                $(let $name = $name; n += 1;)+\n-                s.emit_tuple(n, |s| {\n+                let len: usize = count!($($name)+);\n+                s.emit_tuple(len, |s| {\n                     let mut i = 0;\n                     $(s.emit_tuple_arg({ i+=1; i-1 }, |s| $name.encode(s))?;)+\n                     Ok(())"}, {"sha": "944fe460632199db4a9cd1108a08a5a89e2e9118", "filename": "compiler/rustc_serialize/tests/json.rs", "status": "modified", "additions": 8, "deletions": 303, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_serialize%2Ftests%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Ftests%2Fjson.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -4,61 +4,35 @@ use json::ErrorCode::*;\n use json::Json::*;\n use json::JsonEvent::*;\n use json::ParserError::*;\n-use json::{from_str, Decoder, Encoder, EncoderError, Json, JsonEvent, Parser, StackElement};\n-use rustc_macros::{Decodable, Encodable};\n+use json::{from_str, Encoder, EncoderError, Json, JsonEvent, Parser, StackElement};\n+use rustc_macros::Encodable;\n use rustc_serialize::json;\n-use rustc_serialize::{Decodable, Encodable};\n+use rustc_serialize::Encodable;\n \n use std::collections::BTreeMap;\n use std::io::prelude::*;\n use std::string;\n use Animal::*;\n \n-#[derive(Decodable, Eq, PartialEq, Debug)]\n+#[derive(Eq, PartialEq, Debug)]\n struct OptionData {\n     opt: Option<usize>,\n }\n \n-#[test]\n-fn test_decode_option_none() {\n-    let s = \"{}\";\n-    let obj: OptionData = json::decode(s);\n-    assert_eq!(obj, OptionData { opt: None });\n-}\n-\n-#[test]\n-fn test_decode_option_some() {\n-    let s = \"{ \\\"opt\\\": 10 }\";\n-    let obj: OptionData = json::decode(s);\n-    assert_eq!(obj, OptionData { opt: Some(10) });\n-}\n-\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Number\", \"[]\")\"#)]\n-fn test_decode_option_malformed1() {\n-    check_err::<OptionData>(r#\"{ \"opt\": [] }\"#);\n-}\n-\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Number\", \"false\")\"#)]\n-fn test_decode_option_malformed2() {\n-    check_err::<OptionData>(r#\"{ \"opt\": false }\"#);\n-}\n-\n-#[derive(PartialEq, Encodable, Decodable, Debug)]\n+#[derive(PartialEq, Encodable, Debug)]\n enum Animal {\n     Dog,\n     Frog(string::String, isize),\n }\n \n-#[derive(PartialEq, Encodable, Decodable, Debug)]\n+#[derive(PartialEq, Encodable, Debug)]\n struct Inner {\n     a: (),\n     b: usize,\n     c: Vec<string::String>,\n }\n \n-#[derive(PartialEq, Encodable, Decodable, Debug)]\n+#[derive(PartialEq, Encodable, Debug)]\n struct Outer {\n     inner: Vec<Inner>,\n }\n@@ -323,18 +297,6 @@ fn test_read_identifiers() {\n     assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n }\n \n-#[test]\n-fn test_decode_identifiers() {\n-    let v: () = json::decode(\"null\");\n-    assert_eq!(v, ());\n-\n-    let v: bool = json::decode(\"true\");\n-    assert_eq!(v, true);\n-\n-    let v: bool = json::decode(\"false\");\n-    assert_eq!(v, false);\n-}\n-\n #[test]\n fn test_read_number() {\n     assert_eq!(from_str(\"+\"), Err(SyntaxError(InvalidSyntax, 1, 1)));\n@@ -363,45 +325,6 @@ fn test_read_number() {\n     assert_eq!(from_str(\"18446744073709551615\"), Ok(U64(u64::MAX)));\n }\n \n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Integer\", \"765.25\")\"#)]\n-fn test_decode_numbers() {\n-    let v: f64 = json::decode(\"3\");\n-    assert_eq!(v, 3.0);\n-\n-    let v: f64 = json::decode(\"3.1\");\n-    assert_eq!(v, 3.1);\n-\n-    let v: f64 = json::decode(\"-1.2\");\n-    assert_eq!(v, -1.2);\n-\n-    let v: f64 = json::decode(\"0.4\");\n-    assert_eq!(v, 0.4);\n-\n-    let v: f64 = json::decode(\"0.4e5\");\n-    assert_eq!(v, 0.4e5);\n-\n-    let v: f64 = json::decode(\"0.4e15\");\n-    assert_eq!(v, 0.4e15);\n-\n-    let v: f64 = json::decode(\"0.4e-01\");\n-    assert_eq!(v, 0.4e-01);\n-\n-    let v: u64 = json::decode(\"0\");\n-    assert_eq!(v, 0);\n-\n-    let v: u64 = json::decode(\"18446744073709551615\");\n-    assert_eq!(v, u64::MAX);\n-\n-    let v: i64 = json::decode(\"-9223372036854775808\");\n-    assert_eq!(v, i64::MIN);\n-\n-    let v: i64 = json::decode(\"9223372036854775807\");\n-    assert_eq!(v, i64::MAX);\n-\n-    json::decode::<i64>(\"765.25\");\n-}\n-\n #[test]\n fn test_read_str() {\n     assert_eq!(from_str(\"\\\"\"), Err(SyntaxError(EOFWhileParsingString, 1, 2)));\n@@ -419,26 +342,6 @@ fn test_read_str() {\n     assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(\"\\u{AB12}\".to_string())));\n }\n \n-#[test]\n-fn test_decode_str() {\n-    let s = [\n-        (\"\\\"\\\"\", \"\"),\n-        (\"\\\"foo\\\"\", \"foo\"),\n-        (\"\\\"\\\\\\\"\\\"\", \"\\\"\"),\n-        (\"\\\"\\\\b\\\"\", \"\\x08\"),\n-        (\"\\\"\\\\n\\\"\", \"\\n\"),\n-        (\"\\\"\\\\r\\\"\", \"\\r\"),\n-        (\"\\\"\\\\t\\\"\", \"\\t\"),\n-        (\"\\\"\\\\u12ab\\\"\", \"\\u{12ab}\"),\n-        (\"\\\"\\\\uAB12\\\"\", \"\\u{AB12}\"),\n-    ];\n-\n-    for (i, o) in s {\n-        let v: string::String = json::decode(i);\n-        assert_eq!(v, o);\n-    }\n-}\n-\n #[test]\n fn test_read_array() {\n     assert_eq!(from_str(\"[\"), Err(SyntaxError(EOFWhileParsingValue, 1, 2)));\n@@ -457,45 +360,6 @@ fn test_read_array() {\n     assert_eq!(from_str(\"[2, [4, 1]]\"), Ok(Array(vec![U64(2), Array(vec![U64(4), U64(1)])])));\n }\n \n-#[test]\n-fn test_decode_array() {\n-    let v: Vec<()> = json::decode(\"[]\");\n-    assert_eq!(v, []);\n-\n-    let v: Vec<()> = json::decode(\"[null]\");\n-    assert_eq!(v, [()]);\n-\n-    let v: Vec<bool> = json::decode(\"[true]\");\n-    assert_eq!(v, [true]);\n-\n-    let v: Vec<isize> = json::decode(\"[3, 1]\");\n-    assert_eq!(v, [3, 1]);\n-\n-    let v: Vec<Vec<usize>> = json::decode(\"[[3], [1, 2]]\");\n-    assert_eq!(v, [vec![3], vec![1, 2]]);\n-}\n-\n-#[test]\n-fn test_decode_tuple() {\n-    let t: (usize, usize, usize) = json::decode(\"[1, 2, 3]\");\n-    assert_eq!(t, (1, 2, 3));\n-\n-    let t: (usize, string::String) = json::decode(\"[1, \\\"two\\\"]\");\n-    assert_eq!(t, (1, \"two\".to_string()));\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_decode_tuple_malformed_types() {\n-    json::decode::<(usize, string::String)>(\"[1, 2]\");\n-}\n-\n-#[test]\n-#[should_panic]\n-fn test_decode_tuple_malformed_length() {\n-    json::decode::<(usize, usize)>(\"[1, 2, 3]\");\n-}\n-\n #[test]\n fn test_read_object() {\n     assert_eq!(from_str(\"{\"), Err(SyntaxError(EOFWhileParsingObject, 1, 2)));\n@@ -552,143 +416,11 @@ fn test_read_object() {\n     );\n }\n \n-#[test]\n-fn test_decode_struct() {\n-    let s = \"{\n-        \\\"inner\\\": [\n-            { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n-        ]\n-    }\";\n-\n-    let v: Outer = json::decode(s);\n-    assert_eq!(\n-        v,\n-        Outer { inner: vec![Inner { a: (), b: 2, c: vec![\"abc\".to_string(), \"xyz\".to_string()] }] }\n-    );\n-}\n-\n-#[derive(Decodable)]\n-struct FloatStruct {\n-    f: f64,\n-    a: Vec<f64>,\n-}\n-#[test]\n-fn test_decode_struct_with_nan() {\n-    let s = \"{\\\"f\\\":null,\\\"a\\\":[null,123]}\";\n-    let obj: FloatStruct = json::decode(s);\n-    assert!(obj.f.is_nan());\n-    assert!(obj.a[0].is_nan());\n-    assert_eq!(obj.a[1], 123f64);\n-}\n-\n-#[test]\n-fn test_decode_option() {\n-    let value: Option<string::String> = json::decode(\"null\");\n-    assert_eq!(value, None);\n-\n-    let value: Option<string::String> = json::decode(\"\\\"jodhpurs\\\"\");\n-    assert_eq!(value, Some(\"jodhpurs\".to_string()));\n-}\n-\n-#[test]\n-fn test_decode_enum() {\n-    let value: Animal = json::decode(\"\\\"Dog\\\"\");\n-    assert_eq!(value, Dog);\n-\n-    let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n-    let value: Animal = json::decode(s);\n-    assert_eq!(value, Frog(\"Henry\".to_string(), 349));\n-}\n-\n-#[test]\n-fn test_decode_map() {\n-    let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n-              \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-    let mut map: BTreeMap<string::String, Animal> = json::decode(s);\n-\n-    assert_eq!(map.remove(&\"a\".to_string()), Some(Dog));\n-    assert_eq!(map.remove(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n-}\n-\n #[test]\n fn test_multiline_errors() {\n     assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"), Err(SyntaxError(EOFWhileParsingObject, 3, 8)));\n }\n \n-#[derive(Decodable)]\n-#[allow(dead_code)]\n-struct DecodeStruct {\n-    x: f64,\n-    y: bool,\n-    z: string::String,\n-    w: Vec<DecodeStruct>,\n-}\n-#[derive(Decodable)]\n-enum DecodeEnum {\n-    A(f64),\n-    B(string::String),\n-}\n-fn check_err<T: Decodable<Decoder>>(to_parse: &str) {\n-    let json = from_str(to_parse).unwrap();\n-    let _: T = Decodable::decode(&mut Decoder::new(json));\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Object\", \"[]\")\"#)]\n-fn test_decode_errors_struct1() {\n-    check_err::<DecodeStruct>(\"[]\");\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Number\", \"true\")\"#)]\n-fn test_decode_errors_struct2() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": true, \"y\": true, \"z\": \"\", \"w\": []}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Boolean\", \"[]\")\"#)]\n-fn test_decode_errors_struct3() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": [], \"z\": \"\", \"w\": []}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"String\", \"{}\")\"#)]\n-fn test_decode_errors_struct4() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": true, \"z\": {}, \"w\": []}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Array\", \"null\")\"#)]\n-fn test_decode_errors_struct5() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": true, \"z\": \"\", \"w\": null}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Array\", \"null\")\"#)]\n-fn test_decode_errors_struct6() {\n-    check_err::<DecodeStruct>(r#\"{\"x\": 1, \"y\": true, \"z\": \"\"}\"#);\n-}\n-\n-#[test]\n-#[should_panic(expected = r#\"MissingFieldError(\"variant\")\"#)]\n-fn test_decode_errors_enum1() {\n-    check_err::<DecodeEnum>(r#\"{}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"String\", \"1\")\"#)]\n-fn test_decode_errors_enum2() {\n-    check_err::<DecodeEnum>(r#\"{\"variant\": 1}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"MissingFieldError(\"fields\")\"#)]\n-fn test_decode_errors_enum3() {\n-    check_err::<DecodeEnum>(r#\"{\"variant\": \"A\"}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Array\", \"null\")\"#)]\n-fn test_decode_errors_enum4() {\n-    check_err::<DecodeEnum>(r#\"{\"variant\": \"A\", \"fields\": null}\"#);\n-}\n-#[test]\n-#[should_panic(expected = r#\"UnknownVariantError(\"C\")\"#)]\n-fn test_decode_errors_enum5() {\n-    check_err::<DecodeEnum>(r#\"{\"variant\": \"C\", \"fields\": []}\"#);\n-}\n-\n #[test]\n fn test_find() {\n     let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n@@ -938,7 +670,7 @@ fn test_prettyencoder_indent_level_param() {\n #[test]\n fn test_hashmap_with_enum_key() {\n     use std::collections::HashMap;\n-    #[derive(Encodable, Eq, Hash, PartialEq, Decodable, Debug)]\n+    #[derive(Encodable, Eq, Hash, PartialEq, Debug)]\n     enum Enum {\n         Foo,\n         #[allow(dead_code)]\n@@ -948,33 +680,6 @@ fn test_hashmap_with_enum_key() {\n     map.insert(Enum::Foo, 0);\n     let result = json::encode(&map).unwrap();\n     assert_eq!(&result[..], r#\"{\"Foo\":0}\"#);\n-    let decoded: HashMap<Enum, _> = json::decode(&result);\n-    assert_eq!(map, decoded);\n-}\n-\n-#[test]\n-fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n-    use std::collections::HashMap;\n-    let json_str = \"{\\\"1\\\":true}\";\n-    let json_obj = match from_str(json_str) {\n-        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-        Ok(o) => o,\n-    };\n-    let mut decoder = Decoder::new(json_obj);\n-    let _hm: HashMap<usize, bool> = Decodable::decode(&mut decoder);\n-}\n-\n-#[test]\n-#[should_panic(expected = r#\"ExpectedError(\"Number\", \"a\")\"#)]\n-fn test_hashmap_with_numeric_key_will_error_with_string_keys() {\n-    use std::collections::HashMap;\n-    let json_str = \"{\\\"a\\\":true}\";\n-    let json_obj = match from_str(json_str) {\n-        Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n-        Ok(o) => o,\n-    };\n-    let mut decoder = Decoder::new(json_obj);\n-    let _: HashMap<usize, bool> = Decodable::decode(&mut decoder);\n }\n \n fn assert_stream_equal(src: &str, expected: Vec<(JsonEvent, Vec<StackElement<'_>>)>) {"}, {"sha": "56da7c437280472bab4d7a0120fe7d6b21ad4255", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -299,10 +299,7 @@ impl<E: Encoder> Encodable<E> for DefId {\n \n impl<D: Decoder> Decodable<D> for DefId {\n     default fn decode(d: &mut D) -> DefId {\n-        d.read_struct(|d| DefId {\n-            krate: d.read_struct_field(\"krate\", Decodable::decode),\n-            index: d.read_struct_field(\"index\", Decodable::decode),\n-        })\n+        DefId { krate: Decodable::decode(d), index: Decodable::decode(d) }\n     }\n }\n "}, {"sha": "e51030eedf82fa6cb74f70f960d1b4e9c1685f6c", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -979,12 +979,10 @@ impl<E: Encoder> Encodable<E> for Span {\n }\n impl<D: Decoder> Decodable<D> for Span {\n     default fn decode(s: &mut D) -> Span {\n-        s.read_struct(|d| {\n-            let lo = d.read_struct_field(\"lo\", Decodable::decode);\n-            let hi = d.read_struct_field(\"hi\", Decodable::decode);\n+        let lo = Decodable::decode(s);\n+        let hi = Decodable::decode(s);\n \n-            Span::new(lo, hi, SyntaxContext::root(), None)\n-        })\n+        Span::new(lo, hi, SyntaxContext::root(), None)\n     }\n }\n \n@@ -1440,65 +1438,59 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n \n impl<D: Decoder> Decodable<D> for SourceFile {\n     fn decode(d: &mut D) -> SourceFile {\n-        d.read_struct(|d| {\n-            let name: FileName = d.read_struct_field(\"name\", |d| Decodable::decode(d));\n-            let src_hash: SourceFileHash =\n-                d.read_struct_field(\"src_hash\", |d| Decodable::decode(d));\n-            let start_pos: BytePos = d.read_struct_field(\"start_pos\", |d| Decodable::decode(d));\n-            let end_pos: BytePos = d.read_struct_field(\"end_pos\", |d| Decodable::decode(d));\n-            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", |d| {\n-                let num_lines: u32 = Decodable::decode(d);\n-                let mut lines = Vec::with_capacity(num_lines as usize);\n-\n-                if num_lines > 0 {\n-                    // Read the number of bytes used per diff.\n-                    let bytes_per_diff: u8 = Decodable::decode(d);\n-\n-                    // Read the first element.\n-                    let mut line_start: BytePos = Decodable::decode(d);\n-                    lines.push(line_start);\n-\n-                    for _ in 1..num_lines {\n-                        let diff = match bytes_per_diff {\n-                            1 => d.read_u8() as u32,\n-                            2 => d.read_u16() as u32,\n-                            4 => d.read_u32(),\n-                            _ => unreachable!(),\n-                        };\n+        let name: FileName = Decodable::decode(d);\n+        let src_hash: SourceFileHash = Decodable::decode(d);\n+        let start_pos: BytePos = Decodable::decode(d);\n+        let end_pos: BytePos = Decodable::decode(d);\n+        let lines: Vec<BytePos> = {\n+            let num_lines: u32 = Decodable::decode(d);\n+            let mut lines = Vec::with_capacity(num_lines as usize);\n+\n+            if num_lines > 0 {\n+                // Read the number of bytes used per diff.\n+                let bytes_per_diff: u8 = Decodable::decode(d);\n+\n+                // Read the first element.\n+                let mut line_start: BytePos = Decodable::decode(d);\n+                lines.push(line_start);\n+\n+                for _ in 1..num_lines {\n+                    let diff = match bytes_per_diff {\n+                        1 => d.read_u8() as u32,\n+                        2 => d.read_u16() as u32,\n+                        4 => d.read_u32(),\n+                        _ => unreachable!(),\n+                    };\n \n-                        line_start = line_start + BytePos(diff);\n+                    line_start = line_start + BytePos(diff);\n \n-                        lines.push(line_start);\n-                    }\n+                    lines.push(line_start);\n                 }\n-\n-                lines\n-            });\n-            let multibyte_chars: Vec<MultiByteChar> =\n-                d.read_struct_field(\"multibyte_chars\", |d| Decodable::decode(d));\n-            let non_narrow_chars: Vec<NonNarrowChar> =\n-                d.read_struct_field(\"non_narrow_chars\", |d| Decodable::decode(d));\n-            let name_hash: u128 = d.read_struct_field(\"name_hash\", |d| Decodable::decode(d));\n-            let normalized_pos: Vec<NormalizedPos> =\n-                d.read_struct_field(\"normalized_pos\", |d| Decodable::decode(d));\n-            let cnum: CrateNum = d.read_struct_field(\"cnum\", |d| Decodable::decode(d));\n-            SourceFile {\n-                name,\n-                start_pos,\n-                end_pos,\n-                src: None,\n-                src_hash,\n-                // Unused - the metadata decoder will construct\n-                // a new SourceFile, filling in `external_src` properly\n-                external_src: Lock::new(ExternalSource::Unneeded),\n-                lines,\n-                multibyte_chars,\n-                non_narrow_chars,\n-                normalized_pos,\n-                name_hash,\n-                cnum,\n             }\n-        })\n+\n+            lines\n+        };\n+        let multibyte_chars: Vec<MultiByteChar> = Decodable::decode(d);\n+        let non_narrow_chars: Vec<NonNarrowChar> = Decodable::decode(d);\n+        let name_hash: u128 = Decodable::decode(d);\n+        let normalized_pos: Vec<NormalizedPos> = Decodable::decode(d);\n+        let cnum: CrateNum = Decodable::decode(d);\n+        SourceFile {\n+            name,\n+            start_pos,\n+            end_pos,\n+            src: None,\n+            src_hash,\n+            // Unused - the metadata decoder will construct\n+            // a new SourceFile, filling in `external_src` properly\n+            external_src: Lock::new(ExternalSource::Unneeded),\n+            lines,\n+            multibyte_chars,\n+            non_narrow_chars,\n+            normalized_pos,\n+            name_hash,\n+            cnum,\n+        }\n     }\n }\n "}, {"sha": "678ba18bf045d2879da89967bea531eebf943fa0", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-box.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-box.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -7,7 +7,7 @@ extern crate rustc_macros;\n extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::json;\n+use rustc_serialize::opaque;\n use rustc_serialize::{Decodable, Encodable};\n \n #[derive(Encodable, Decodable)]\n@@ -17,7 +17,9 @@ struct A {\n \n fn main() {\n     let obj = A { foo: Box::new([true, false]) };\n-    let s = json::encode(&obj).unwrap();\n-    let obj2: A = json::decode(&s);\n+    let mut encoder = opaque::Encoder::new(vec![]);\n+    obj.encode(&mut encoder).unwrap();\n+    let mut decoder = opaque::Decoder::new(&encoder.data, 0);\n+    let obj2 = A::decode(&mut decoder);\n     assert_eq!(obj.foo, obj2.foo);\n }"}, {"sha": "5cc5c41364a66a1e31f1e43db5a9274bcbfec841", "filename": "src/test/ui-fulldeps/deriving-encodable-decodable-cell-refcell.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fderiving-encodable-decodable-cell-refcell.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -9,7 +9,7 @@ extern crate rustc_macros;\n extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::json;\n+use rustc_serialize::opaque;\n use rustc_serialize::{Decodable, Encodable};\n use std::cell::{Cell, RefCell};\n \n@@ -26,8 +26,10 @@ struct B {\n \n fn main() {\n     let obj = B { foo: Cell::new(true), bar: RefCell::new(A { baz: 2 }) };\n-    let s = json::encode(&obj).unwrap();\n-    let obj2: B = json::decode(&s);\n+    let mut encoder = opaque::Encoder::new(vec![]);\n+    obj.encode(&mut encoder).unwrap();\n+    let mut decoder = opaque::Decoder::new(&encoder.data, 0);\n+    let obj2 = B::decode(&mut decoder);\n     assert_eq!(obj.foo.get(), obj2.foo.get());\n     assert_eq!(obj.bar.borrow().baz, obj2.bar.borrow().baz);\n }"}, {"sha": "f7e0043f52168ff689cc8704b95f8cfc44524e24", "filename": "src/test/ui-fulldeps/issue-14021.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/58a721af9f818bdf57f86448557b45c5ae19a3ef/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58a721af9f818bdf57f86448557b45c5ae19a3ef/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-14021.rs?ref=58a721af9f818bdf57f86448557b45c5ae19a3ef", "patch": "@@ -8,19 +8,17 @@ extern crate rustc_macros;\n extern crate rustc_serialize;\n \n use rustc_macros::{Decodable, Encodable};\n-use rustc_serialize::json;\n+use rustc_serialize::opaque;\n use rustc_serialize::{Decodable, Encodable};\n \n #[derive(Encodable, Decodable, PartialEq, Debug)]\n struct UnitLikeStruct;\n \n pub fn main() {\n     let obj = UnitLikeStruct;\n-    let json_str: String = json::encode(&obj).unwrap();\n-\n-    let json_object = json::from_str(&json_str);\n-    let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let mut decoded_obj: UnitLikeStruct = Decodable::decode(&mut decoder);\n-\n-    assert_eq!(obj, decoded_obj);\n+    let mut encoder = opaque::Encoder::new(vec![]);\n+    obj.encode(&mut encoder).unwrap();\n+    let mut decoder = opaque::Decoder::new(&encoder.data, 0);\n+    let obj2 = UnitLikeStruct::decode(&mut decoder);\n+    assert_eq!(obj, obj2);\n }"}, {"sha": "044a0c5000e31a80308eb120cdf82861e9880742", "filename": "src/test/ui-fulldeps/issue-24972.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui-fulldeps%2Fissue-24972.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui-fulldeps%2Fissue-24972.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-24972.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -1,39 +0,0 @@\n-// run-pass\n-\n-#![allow(dead_code)]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_serialize;\n-\n-use rustc_serialize::{json, Decodable, Encodable};\n-use std::fmt::Display;\n-\n-pub trait Entity: Decodable<json::Decoder> + for<'a> Encodable<json::Encoder<'a>> + Sized {\n-    type Key: Clone\n-        + Decodable<json::Decoder>\n-        + for<'a> Encodable<json::Encoder<'a>>\n-        + ToString\n-        + Display\n-        + Eq\n-        + Ord\n-        + Sized;\n-\n-    fn id(&self) -> Self::Key;\n-\n-    fn find_by_id(id: Self::Key) -> Option<Self>;\n-}\n-\n-pub struct DbRef<E: Entity> {\n-    pub id: E::Key,\n-}\n-\n-impl<E> DbRef<E>\n-where\n-    E: Entity,\n-{\n-    fn get(self) -> Option<E> {\n-        E::find_by_id(self.id)\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "65dab8d7704766f70c9e6ee9e981d65cabbc35df", "filename": "src/test/ui-fulldeps/issue-4016.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui-fulldeps%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui-fulldeps%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-4016.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -1,19 +0,0 @@\n-// run-pass\n-\n-#![allow(dead_code)]\n-#![feature(rustc_private)]\n-\n-extern crate rustc_serialize;\n-\n-use rustc_serialize::{json, Decodable};\n-\n-trait JD: Decodable<json::Decoder> {}\n-\n-fn exec<T: JD>() {\n-    let doc = json::from_str(\"\").unwrap();\n-    let mut decoder = json::Decoder::new(doc);\n-    let _v: T = Decodable::decode(&mut decoder);\n-    panic!()\n-}\n-\n-pub fn main() {}"}, {"sha": "702bb2d6ef6cb3b5ae20bd438a9a6f0ca33151d4", "filename": "src/test/ui-fulldeps/issue-4036.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui-fulldeps%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a/src%2Ftest%2Fui-fulldeps%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fissue-4036.rs?ref=b8967b0d52a2ba5f0c9da0da03e78ccba5534e4a", "patch": "@@ -1,17 +0,0 @@\n-// run-pass\n-// Issue #4036: Test for an issue that arose around fixing up type inference\n-// byproducts in vtable records.\n-\n-// pretty-expanded FIXME #23616\n-\n-#![feature(rustc_private)]\n-\n-extern crate rustc_serialize;\n-\n-use rustc_serialize::{json, Decodable};\n-\n-pub fn main() {\n-    let json = json::from_str(\"[1]\").unwrap();\n-    let mut decoder = json::Decoder::new(json);\n-    let _x: Vec<isize> = Decodable::decode(&mut decoder);\n-}"}]}