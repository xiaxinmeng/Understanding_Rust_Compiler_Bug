{"sha": "913ab1ec0ad10873134ca429c1496806a9261206", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxM2FiMWVjMGFkMTA4NzMxMzRjYTQyOWMxNDk2ODA2YTkyNjEyMDY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-14T11:25:05Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-17T17:47:45Z"}, "message": "Resolve assoc types on type parameters\n\nE.g. `fn foo<T: Iterator>() -> T::Item`. It seems that rustc does this only for\ntype parameters and only based on their bounds, so we also only consider traits\nfrom bounds.", "tree": {"sha": "877db00b9898b278d9c9213824f9472d640de360", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/877db00b9898b278d9c9213824f9472d640de360"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/913ab1ec0ad10873134ca429c1496806a9261206", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/913ab1ec0ad10873134ca429c1496806a9261206", "html_url": "https://github.com/rust-lang/rust/commit/913ab1ec0ad10873134ca429c1496806a9261206", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/913ab1ec0ad10873134ca429c1496806a9261206/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16ee779483a1d96ccd2258b43c8477744773b314", "url": "https://api.github.com/repos/rust-lang/rust/commits/16ee779483a1d96ccd2258b43c8477744773b314", "html_url": "https://github.com/rust-lang/rust/commit/16ee779483a1d96ccd2258b43c8477744773b314"}], "stats": {"total": 85, "additions": 61, "deletions": 24}, "files": [{"sha": "62e4ed0f4b8f62e8be8868a97e4d7607462f5d41", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 58, "deletions": 21, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/913ab1ec0ad10873134ca429c1496806a9261206/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/913ab1ec0ad10873134ca429c1496806a9261206/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=913ab1ec0ad10873134ca429c1496806a9261206", "patch": "@@ -93,7 +93,7 @@ impl Ty {\n             None => return Ty::Unknown,\n         };\n \n-        let typable: TypableDef = match resolution {\n+        let ty = match resolution {\n             TypeNs::Trait(trait_) => {\n                 let segment = match remaining_index {\n                     None => path.segments.last().expect(\"resolved path has at least one element\"),\n@@ -115,47 +115,84 @@ impl Ty {\n                                 })\n                             }\n                             None => {\n-                                // associated type not found\n+                                // associated type not found (FIXME: report error)\n                                 Ty::Unknown\n                             }\n                         }\n                     } else {\n-                        // FIXME more than one segment remaining, is this possible?\n+                        // FIXME report error (ambiguous associated type)\n                         Ty::Unknown\n                     }\n                 } else {\n                     Ty::Dyn(Arc::new([GenericPredicate::Implemented(trait_ref)]))\n                 };\n             }\n             TypeNs::GenericParam(idx) => {\n-                if remaining_index.is_some() {\n-                    // e.g. T::Item\n-                    return Ty::Unknown;\n-                }\n-                return Ty::Param {\n-                    idx,\n-                    // FIXME: maybe return name in resolution?\n-                    name: path\n+                // FIXME: maybe return name in resolution?\n+                let name = match remaining_index {\n+                    None => path\n                         .as_ident()\n                         .expect(\"generic param should be single-segment path\")\n                         .clone(),\n+                    Some(idx) => path.segments[idx - 1].name.clone(),\n                 };\n+                Ty::Param { idx, name }\n             }\n-            TypeNs::SelfType(impl_block) => {\n-                if remaining_index.is_some() {\n-                    // e.g. Self::Item\n-                    return Ty::Unknown;\n-                }\n-                return impl_block.target_ty(db);\n-            }\n+            TypeNs::SelfType(impl_block) => impl_block.target_ty(db),\n \n-            TypeNs::Adt(it) => it.into(),\n-            TypeNs::BuiltinType(it) => it.into(),\n-            TypeNs::TypeAlias(it) => it.into(),\n+            TypeNs::Adt(it) => Ty::from_hir_path_inner(db, resolver, path, it.into()),\n+            TypeNs::BuiltinType(it) => Ty::from_hir_path_inner(db, resolver, path, it.into()),\n+            TypeNs::TypeAlias(it) => Ty::from_hir_path_inner(db, resolver, path, it.into()),\n             // FIXME: report error\n             TypeNs::EnumVariant(_) => return Ty::Unknown,\n         };\n \n+        if let Some(remaining_index) = remaining_index {\n+            // resolve unselected assoc types\n+            if remaining_index == path.segments.len() - 1 {\n+                let segment = &path.segments[remaining_index];\n+                Ty::select_associated_type(db, resolver, ty, segment)\n+            } else {\n+                // FIXME report error (ambiguous associated type)\n+                Ty::Unknown\n+            }\n+        } else {\n+            ty\n+        }\n+    }\n+\n+    fn select_associated_type(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        self_ty: Ty,\n+        segment: &PathSegment,\n+    ) -> Ty {\n+        let env = trait_env(db, resolver);\n+        let traits_from_env = env.trait_predicates_for_self_ty(&self_ty).map(|tr| tr.trait_);\n+        let traits = traits_from_env.flat_map(|t| t.all_super_traits(db));\n+        let mut result = Ty::Unknown;\n+        for t in traits {\n+            if let Some(associated_ty) = t.associated_type_by_name(db, &segment.name) {\n+                let generics = t.generic_params(db);\n+                let mut substs = Vec::new();\n+                substs.push(self_ty.clone());\n+                substs.extend(\n+                    iter::repeat(Ty::Unknown).take(generics.count_params_including_parent() - 1),\n+                );\n+                // FIXME handle type parameters on the segment\n+                result = Ty::Projection(ProjectionTy { associated_ty, parameters: substs.into() });\n+                break;\n+            }\n+        }\n+        result\n+    }\n+\n+    fn from_hir_path_inner(\n+        db: &impl HirDatabase,\n+        resolver: &Resolver,\n+        path: &Path,\n+        typable: TypableDef,\n+    ) -> Ty {\n         let ty = db.type_for_def(typable, Namespace::Types);\n         let substs = Ty::substs_from_path(db, resolver, path, typable);\n         ty.subst(&substs)"}, {"sha": "dc4e8683d08c76cb6cc57340ffd6a3cd04ae8956", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/913ab1ec0ad10873134ca429c1496806a9261206/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/913ab1ec0ad10873134ca429c1496806a9261206/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=913ab1ec0ad10873134ca429c1496806a9261206", "patch": "@@ -2732,9 +2732,9 @@ fn test() {\n     [147; 148) 't': T\n     [178; 180) '{}': ()\n     [191; 236) '{     ...(S); }': ()\n-    [201; 202) 'x': {unknown}\n-    [205; 209) 'foo1': fn foo1<S>(T) -> {unknown}\n-    [205; 212) 'foo1(S)': {unknown}\n+    [201; 202) 'x': u32\n+    [205; 209) 'foo1': fn foo1<S>(T) -> <T as Iterable>::Item\n+    [205; 212) 'foo1(S)': u32\n     [210; 211) 'S': S\n     [222; 223) 'y': u32\n     [226; 230) 'foo2': fn foo2<S>(T) -> <T as Iterable>::Item"}]}