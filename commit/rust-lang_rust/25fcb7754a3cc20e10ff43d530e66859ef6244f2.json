{"sha": "25fcb7754a3cc20e10ff43d530e66859ef6244f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZmNiNzc1NGEzY2MyMGUxMGZmNDNkNTMwZTY2ODU5ZWY2MjQ0ZjI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-30T03:09:33Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-30T03:09:33Z"}, "message": "Add README.md", "tree": {"sha": "e23b4bd1f7d24de1f915ee48f9e1853cd60216ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e23b4bd1f7d24de1f915ee48f9e1853cd60216ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25fcb7754a3cc20e10ff43d530e66859ef6244f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25fcb7754a3cc20e10ff43d530e66859ef6244f2", "html_url": "https://github.com/rust-lang/rust/commit/25fcb7754a3cc20e10ff43d530e66859ef6244f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25fcb7754a3cc20e10ff43d530e66859ef6244f2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d5226b825857cec813a97a129124ac40d2dfb7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d5226b825857cec813a97a129124ac40d2dfb7b", "html_url": "https://github.com/rust-lang/rust/commit/2d5226b825857cec813a97a129124ac40d2dfb7b"}], "stats": {"total": 240, "additions": 219, "deletions": 21}, "files": [{"sha": "2835eafeaaeef8a814a9161e08c9eb35735664a1", "filename": "README.md", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/25fcb7754a3cc20e10ff43d530e66859ef6244f2/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/25fcb7754a3cc20e10ff43d530e66859ef6244f2/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=25fcb7754a3cc20e10ff43d530e66859ef6244f2", "patch": "@@ -0,0 +1,218 @@\n+# rustfmt\n+\n+A tool for formatting Rust code according to style guidelines.\n+\n+\n+## How to use\n+\n+`cargo build` to build.\n+\n+`cargo test` to run all tests.\n+\n+`cargo run filename` to run on a file, if the file includes out of line modules,\n+then we reformat those too. So to run on a whole module or crate, you just need\n+to run on the top file. You'll probably want to set the `WriteMode` in the call\n+to `run` in `main()`. Eventually you should be able to set the mode from the\n+command line or from a config file or something.\n+\n+\n+## Use cases\n+\n+A formatting tool can be used in different ways and the different use cases can\n+affect the design of the tool. The use cases I'm particularly concerned with are:\n+\n+* running on a whole repo before check-in\n+  - in particular, to replace the `make tidy` pass on the Rust distro\n+* running on code from another project that you are adding to your own\n+* using for mass changes in code style over a project\n+\n+Some valid use cases for a formatting tool which I am explicitly not trying to\n+address (although it would be nice, if possible):\n+\n+* running 'as you type' in an IDE\n+* running on arbitrary snippets of code\n+* running on Rust-like code, specifically code which doesn't parse\n+* use as a pretty printer inside the compiler\n+* refactoring\n+* formatting totally unformatted source code\n+\n+\n+## Scope and vision\n+\n+I do not subscribe to the notion that a formatting tool should only change\n+whitespace. I believe that we should semantics preserving, but not necessarily\n+syntax preserving, i.e., we can change the AST of a program.\n+\n+I.e., we might change glob imports to list or single imports, re-order imports,\n+move bounds to where clauses, combine multiple impls into a single impl, etc.\n+\n+However, we will not change the names of variables or make any changes which\n+*could* change the semantics. To be ever so slightly formal, we might imagine\n+a compilers high level intermediate representation, we should strive to only\n+make changes which do change the HIR, even if they do change the AST.\n+\n+I would like to be able to output refactoring scripts for making deeper changes\n+though. (E.g., renaming variables to satisfy our style guidelines).\n+\n+My long term goal is that all style lints can be moved from the compiler to\n+rustfmt and, as well as warning, can either fix problems or emit refactoring\n+scripts to do so.\n+\n+### Configurability\n+\n+I believe reformatting should be configurable to some extent. We should read in\n+options from a configuration file and reformat accordingly. We should supply at\n+least a config file which matches the Rust style guidelines.\n+\n+There should be multiple modes for running the tool. As well as simply replacing\n+each file, we should be able to show the user a list of the changes we would\n+make, or show a list of violations without corrections (the difference being\n+that there are multiple ways to satisfy a given set of style guidelines, and we\n+should distinguish violations from deviations from our own model).\n+\n+\n+## Implementation philosophy\n+\n+Some details of the philosophy behind the implementation.\n+\n+\n+### Operate on the AST\n+\n+A reformatting tool can be based on either the AST or a token stream (in Rust\n+this is actually a stream of token trees, but its not a fundamental difference).\n+There are pros and cons to the two approaches. I have chosen to use the AST\n+approach. The primary reasons are that it allows us to do more sophisticated\n+manipulations, rather than just change whitespace, and it gives us more context\n+when making those changes.\n+\n+The advantage of the tokens approach are that you can operate on non-parsable\n+code. I don't care too much about that, it would be nice, but I think being able\n+to sophisticated transformations is more important. In the future I hope to\n+(optionally) be able to use type information for informing reformatting too. One\n+specific case of unparsable code is macros. Using tokens is certainly easier\n+here, but I believe it is perfectly solvable with the AST approach. At the limit,\n+we can operate on just tokens in the macro case.\n+\n+I believe that there is not in fact that much difference between the two\n+approaches. Due to imperfect span information, under the AST approach, we\n+sometimes are reduced to examining tokens or do some re-lexing of our own. Under\n+the tokens approach you need to implement your own (much simpler) parser. I\n+believe that as the tool gets more sophisticated, you end up doing more at the\n+token-level, or having an increasingly sophisticated parser, until at the limit\n+you have the same tool.\n+\n+However, I believe starting from the AST gets you more quickly to a usable and\n+useful tool.\n+\n+\n+### Heuristic rather than algorithmic\n+\n+Many formatting tools use a very general algorithmic or even algebraic tool for\n+pretty printing. This results in very elegant code, but I believe does not give\n+the best results. I prefer a more ad hoc approach where each expression/item is\n+formatted using custom rules. We hopefully don't end up with too much code due\n+to good old fashioned abstraction and code sharing. This will give a bigger code\n+base, but hopefully a better result.\n+\n+It also means that there will be some cases we can't format and we have to give\n+up. I think that is OK. Hopefully they are rare enough that manually fixing them\n+is not painful. Better to have a tool that gives great code in 99% of cases and\n+fails in 1% than a tool which gives 50% great code and 50% ugly code, but never\n+fails.\n+\n+\n+### Incremental development\n+\n+I want rustfmt to be useful as soon as possible and to always be useful. I\n+specifically don't want to have to wait for a feature (or worse, the whole tool)\n+to be perfect before it is useful. The main ways this is achieved is to output\n+the source code where we can't yet reformat, be able to turn off new features\n+until they are ready, and the 'do no harm' principle (see next section).\n+\n+\n+### First, do no harm\n+\n+Until rustfmt it perfect, there will always be a trade-off between doing more and\n+doing existing things well. I want to err on the side of the latter.\n+Specifically, rustfmt should never take OK code and make it look worse. If we\n+can't make it better, we should leave it as is. That might mean being less\n+aggressive than we like or using configurability.\n+\n+\n+### Use the source code as guidance\n+\n+There are often multiple ways to format code and satisfy standards. Where this\n+is the case, we should use the source code as a hint for reformatting.\n+Furthermore, where the code has been formatted in a particular way that satisfies\n+the coding standard, it should not be changed (this is sometimes not possible or\n+not worthwhile due to uniformity being desirable, but it is a useful goal).\n+\n+\n+### Architecture details\n+\n+We use the AST from libsyntax. We use libsyntax's visit module to walk the AST\n+to find starting points for reformatting. Eventually, we should reformat everything\n+and we shouldn't need the visit module. We keep track of the last formatted\n+position in the code, and when we reformat the next piece of code we make sure\n+to output the span for all the code in between (handled by missed_spans.rs).\n+\n+Our visitor keeps track of the desired current indent due to blocks (\n+`block_indent`). Each `visit_*` method reformats code according to this indent\n+and `IDEAL_WIDTH` and `MAX_WIDTH` (which should one day be supplied from a \n+config file). Most reformatting done in the `visit_*` methods is a bit hackey\n+and is meant to be temporary until it can be done properly.\n+\n+There are a bunch of methods called `rewrite_*`. There do the bulk of the\n+reformatting. These take the AST node to be reformatted (this may not literally\n+be an AST node from libsyntax, there might be multiple parameters describing a\n+logical node), the current indent, and the current width budget. They return a\n+`String` (or sometimes an `Option<String>`) which formats the code in the box\n+given by the indent and width budget. If the method fails, it returns `None` and\n+the calling method then has to fallback in some way to give the callee more space.\n+\n+So, in summary to format a node, we calculate the width budget and then walk down\n+the tree from the node. At a leaf, we generate an actual string and then unwind,\n+combining these strings as we go back up the tree.\n+\n+For example, consider a method definition:\n+\n+```\n+    fn foo(a: A, b: B) {\n+        ...\n+    }\n+```\n+\n+We start at indent 4, the rewrite function for the whole function knows it must\n+write `fn foo(` before the arguments and `) {` after them, assuming the max width\n+is 100, it thus asks the rewrite argument list function to rewrite with an indent\n+of 11 and in a width of 86. Assuming that is possible (obviously in this case),\n+it returns a string for the arguments and it can make a string for the function\n+header. If the arguments couldn't be fitted in that space, we might try to\n+fallback to a hanging indent, so we try again with indent 8 and width 89.\n+\n+\n+## Contributing\n+\n+### Test and file issues\n+\n+It would be really useful to have people use rustfmt on their projects and file\n+issues where it does something you don't expect.\n+\n+A really useful thing to do that on a crate from the Rust repo. If it does\n+something unexpected, file an issue; if not, make a PR to the Rust repo with the\n+reformatted code. I hope to get the whole repo consistently rustfmt'ed and to\n+replace `make tidy` with rustfmt as a medium-term goal.\n+\n+### Create test cases\n+\n+Having a strong test suite for a tool like this is essential. It is very easy\n+to create regressions. Any tests you can add are very much appreciated.\n+\n+### Hack!\n+\n+Here are some [good starting issues](https://github.com/nrc/rustfmt/issues?q=is%3Aopen+is%3Aissue+label%3Aeasy).\n+Note than some of those issues tagged 'easy' are not that easy and might be better\n+second issues, rather than good first issues to fix.\n+\n+If you've found areas which need polish and don't have issues, please submit a\n+PR, don't feel there needs to be an issue."}, {"sha": "be0bea4b70cac275891fc689a3decc4b4c6c9f45", "filename": "src/mod.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/25fcb7754a3cc20e10ff43d530e66859ef6244f2/src%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25fcb7754a3cc20e10ff43d530e66859ef6244f2/src%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmod.rs?ref=25fcb7754a3cc20e10ff43d530e66859ef6244f2", "patch": "@@ -19,13 +19,6 @@\n // keeping some scratch mem for this and running our own StrPool?\n // TODO for lint violations of names, emit a refactor script\n \n-// TODO priorities\n-// annotations/doc comments\n-// Fix fns and methods properly\n-//   dead spans (comments) - in where clause - test\n-//\n-// Smoke testing till we can use it\n-// take config options from a file\n \n #[macro_use]\n extern crate log;\n@@ -287,19 +280,6 @@ fn main() {\n     // println!(\"  {}\", s);\n }\n \n-// FIXME comments\n-// comments aren't in the AST, which makes processing them difficult, but then\n-// comments are complicated anyway. I think I am happy putting off tackling them\n-// for now. Long term the soluton is for comments to be in the AST, but that means\n-// only the libsyntax AST, not the rustc one, which means waiting for the ASTs\n-// to diverge one day....\n-\n-// Once we do have comments, we just have to implement a simple word wrapping\n-// algorithm to keep the width under IDEAL_WIDTH. We should also convert multiline\n-// /* ... */ comments to // and check doc comments are in the right place and of\n-// the right kind.\n-\n-// Should also make sure comments have the right indent\n \n #[cfg(test)]\n mod test {\n@@ -311,7 +291,7 @@ mod test {\n \n     // For now, the only supported regression tests are idempotent tests - the input and\n     // output must match exactly.\n-    // TODO would be good to check for error messages and fail on them, or at least report.\n+    // FIXME(#28) would be good to check for error messages and fail on them, or at least report.\n     #[test]\n     fn idempotent_tests() {\n         println!(\"Idempotent tests:\");"}]}