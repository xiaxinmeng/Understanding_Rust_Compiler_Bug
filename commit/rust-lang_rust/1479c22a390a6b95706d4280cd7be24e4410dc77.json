{"sha": "1479c22a390a6b95706d4280cd7be24e4410dc77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NzljMjJhMzkwYTZiOTU3MDZkNDI4MGNkN2JlMjRlNDQxMGRjNzc=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-23T07:56:41Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-23T14:38:50Z"}, "message": "Don't mutate waiter nodes", "tree": {"sha": "a080d9f6d67bdf0b9bf28e680dd97d1958bbee9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a080d9f6d67bdf0b9bf28e680dd97d1958bbee9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1479c22a390a6b95706d4280cd7be24e4410dc77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1479c22a390a6b95706d4280cd7be24e4410dc77", "html_url": "https://github.com/rust-lang/rust/commit/1479c22a390a6b95706d4280cd7be24e4410dc77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1479c22a390a6b95706d4280cd7be24e4410dc77/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f1e166899a90226480d564549c36a395e2d8f47", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f1e166899a90226480d564549c36a395e2d8f47", "html_url": "https://github.com/rust-lang/rust/commit/7f1e166899a90226480d564549c36a395e2d8f47"}], "stats": {"total": 18, "additions": 9, "deletions": 9}, "files": [{"sha": "d8565e55ab2fcff24114083174a0a8d1d25371a7", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1479c22a390a6b95706d4280cd7be24e4410dc77/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1479c22a390a6b95706d4280cd7be24e4410dc77/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=1479c22a390a6b95706d4280cd7be24e4410dc77", "patch": "@@ -81,7 +81,7 @@ pub struct Once {\n     // `state_and_queue` is actually an a pointer to a `Waiter` with extra state\n     // bits, so we add the `PhantomData` appropriately.\n     state_and_queue: AtomicUsize,\n-    _marker: marker::PhantomData<*mut Waiter>,\n+    _marker: marker::PhantomData<*const Waiter>,\n }\n \n // The `PhantomData` of a raw pointer removes these two auto traits, but we\n@@ -134,9 +134,9 @@ const STATE_MASK: usize = 0x3;\n \n // Representation of a node in the linked list of waiters in the RUNNING state.\n struct Waiter {\n-    thread: Option<Thread>,\n+    thread: Thread,\n     signaled: AtomicBool,\n-    next: *mut Waiter,\n+    next: *const Waiter,\n }\n \n // Helper struct used to clean up after a closure call with a `Drop`\n@@ -404,11 +404,11 @@ impl Once {\n                     // Create the node for our current thread that we are going to try to slot\n                     // in at the head of the linked list.\n                     let mut node = Waiter {\n-                        thread: Some(thread::current()),\n+                        thread: thread::current(),\n                         signaled: AtomicBool::new(false),\n-                        next: ptr::null_mut(),\n+                        next: ptr::null(),\n                     };\n-                    let me = &mut node as *mut Waiter as usize;\n+                    let me = &node as *const Waiter as usize;\n                     assert!(me & STATE_MASK == 0); // We assume pointers have 2 free bits that\n                                                    // we can use for state.\n \n@@ -421,7 +421,7 @@ impl Once {\n                             return; // No need anymore to enqueue ourselves.\n                         }\n \n-                        node.next = (old_head_and_status & !STATE_MASK) as *mut Waiter;\n+                        node.next = (old_head_and_status & !STATE_MASK) as *const Waiter;\n                         let old = self.state_and_queue.compare_and_swap(old_head_and_status,\n                                                                         me | RUNNING,\n                                                                         Ordering::Release);\n@@ -469,10 +469,10 @@ impl Drop for Finish<'_> {\n         // in the node it can be free'd! As a result we load the `thread` to\n         // signal ahead of time and then unpark it after the store.\n         unsafe {\n-            let mut queue = (state_and_queue & !STATE_MASK) as *mut Waiter;\n+            let mut queue = (state_and_queue & !STATE_MASK) as *const Waiter;\n             while !queue.is_null() {\n                 let next = (*queue).next;\n-                let thread = (*queue).thread.take().unwrap();\n+                let thread = (*queue).thread.clone();\n                 (*queue).signaled.store(true, Ordering::SeqCst);\n                 thread.unpark();\n                 queue = next;"}]}