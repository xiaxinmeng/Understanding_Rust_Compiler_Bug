{"sha": "f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZTZmYmM0Zjc1MWE1ZmQ0YmVmYWY5MWFkNGIxMDIyZWZiOTk1MDE=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-04-06T10:56:59Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-06-06T13:25:16Z"}, "message": "Make queries block and handle query cycles", "tree": {"sha": "ba97adcc611fcecb1375143e8c9833b23752d2bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba97adcc611fcecb1375143e8c9833b23752d2bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "html_url": "https://github.com/rust-lang/rust/commit/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "685faa2c3ee062aaf30ddf6d3daf4ef3b576979b", "url": "https://api.github.com/repos/rust-lang/rust/commits/685faa2c3ee062aaf30ddf6d3daf4ef3b576979b", "html_url": "https://github.com/rust-lang/rust/commit/685faa2c3ee062aaf30ddf6d3daf4ef3b576979b"}], "stats": {"total": 479, "additions": 469, "deletions": 10}, "files": [{"sha": "4dc818c650e344bc45db49d89c421d1b6e813cad", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "patch": "@@ -15,9 +15,12 @@ fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n lazy_static = \"1.0.0\"\n+scoped-tls = { version = \"0.1.1\", features = [\"nightly\"] }\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n polonius-engine = \"0.5.0\"\n proc_macro = { path = \"../libproc_macro\" }\n+rustc-rayon = \"0.1.0\"\n+rustc-rayon-core = \"0.1.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n@@ -26,6 +29,7 @@ serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n backtrace = \"0.3.3\"\n+parking_lot = \"0.5.5\"\n byteorder = { version = \"1.1\", features = [\"i128\"]}\n chalk-engine = { version = \"0.6.0\", default-features=false }\n "}, {"sha": "a006856f58b7dac16624f573b1b253a06b9380cf", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "patch": "@@ -67,6 +67,7 @@\n #![feature(unboxed_closures)]\n #![feature(trace_macros)]\n #![feature(trusted_len)]\n+#![feature(vec_remove_item)]\n #![feature(catch_expr)]\n #![feature(integer_atomics)]\n #![feature(test)]\n@@ -83,13 +84,17 @@ extern crate fmt_macros;\n extern crate getopts;\n extern crate graphviz;\n #[macro_use] extern crate lazy_static;\n+#[macro_use] extern crate scoped_tls;\n #[cfg(windows)]\n extern crate libc;\n extern crate polonius_engine;\n extern crate rustc_target;\n #[macro_use] extern crate rustc_data_structures;\n extern crate serialize;\n+extern crate parking_lot;\n extern crate rustc_errors as errors;\n+extern crate rustc_rayon as rayon;\n+extern crate rustc_rayon_core as rayon_core;\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;"}, {"sha": "ef584774f694c8edc9036ac139e94fada9e12b3d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "patch": "@@ -1699,16 +1699,21 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<CanonicalVarInfo> {\n pub mod tls {\n     use super::{GlobalCtxt, TyCtxt};\n \n-    use std::cell::Cell;\n     use std::fmt;\n     use std::mem;\n     use syntax_pos;\n     use ty::maps;\n     use errors::{Diagnostic, TRACK_DIAGNOSTICS};\n     use rustc_data_structures::OnDrop;\n-    use rustc_data_structures::sync::{self, Lrc};\n+    use rustc_data_structures::sync::{self, Lrc, Lock};\n     use dep_graph::OpenTask;\n \n+    #[cfg(not(parallel_queries))]\n+    use std::cell::Cell;\n+\n+    #[cfg(parallel_queries)]\n+    use rayon_core;\n+\n     /// This is the implicit state of rustc. It contains the current\n     /// TyCtxt and query. It is updated when creating a local interner or\n     /// executing a new query. Whenever there's a TyCtxt value available\n@@ -1732,16 +1737,29 @@ pub mod tls {\n         pub task: &'a OpenTask,\n     }\n \n+    #[cfg(parallel_queries)]\n+    fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n+        rayon_core::tlv::with(value, f)\n+    }\n+\n+    #[cfg(parallel_queries)]\n+    fn get_tlv() -> usize {\n+        rayon_core::tlv::get()\n+    }\n+\n     // A thread local value which stores a pointer to the current ImplicitCtxt\n+    #[cfg(not(parallel_queries))]\n     thread_local!(static TLV: Cell<usize> = Cell::new(0));\n \n+    #[cfg(not(parallel_queries))]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         let old = get_tlv();\n         let _reset = OnDrop(move || TLV.with(|tlv| tlv.set(old)));\n         TLV.with(|tlv| tlv.set(value));\n         f()\n     }\n \n+    #[cfg(not(parallel_queries))]\n     fn get_tlv() -> usize {\n         TLV.with(|tlv| tlv.get())\n     }\n@@ -1810,6 +1828,13 @@ pub mod tls {\n         where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n     {\n         with_thread_locals(|| {\n+            GCX_PTR.with(|lock| {\n+                *lock.lock() = gcx as *const _ as usize;\n+            });\n+            let _on_drop = OnDrop(move || {\n+                GCX_PTR.with(|lock| *lock.lock() = 0);\n+            });\n+\n             let tcx = TyCtxt {\n                 gcx,\n                 interners: &gcx.global_interners,\n@@ -1826,6 +1851,27 @@ pub mod tls {\n         })\n     }\n \n+    scoped_thread_local!(pub static GCX_PTR: Lock<usize>);\n+\n+    pub unsafe fn with_global<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        let gcx = GCX_PTR.with(|lock| *lock.lock());\n+        assert!(gcx != 0);\n+        let gcx = &*(gcx as *const GlobalCtxt<'_>);\n+        let tcx = TyCtxt {\n+            gcx,\n+            interners: &gcx.global_interners,\n+        };\n+        let icx = ImplicitCtxt {\n+            query: None,\n+            tcx,\n+            layout_depth: 0,\n+            task: &OpenTask::Ignore,\n+        };\n+        enter_context(&icx, |_| f(tcx))\n+    }\n+\n     /// Allows access to the current ImplicitCtxt in a closure if one is available\n     pub fn with_context_opt<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'gcx, 'tcx>>) -> R"}, {"sha": "3fe22dba6e153769866961d85de2217cca32283d", "filename": "src/librustc/ty/maps/job.rs", "status": "modified", "additions": 365, "deletions": 2, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "patch": "@@ -8,13 +8,31 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc_data_structures::sync::{Lock, Lrc};\n+#![allow(warnings)]\n+\n+use std::mem;\n+use rustc_data_structures::sync::{Lock, LockGuard, Lrc, Weak};\n+use rustc_data_structures::OnDrop;\n use syntax_pos::Span;\n use ty::tls;\n use ty::maps::Query;\n use ty::maps::plumbing::CycleError;\n use ty::context::TyCtxt;\n use errors::Diagnostic;\n+use std::process;\n+use std::fmt;\n+use std::collections::HashSet;\n+#[cfg(parallel_queries)]\n+use {\n+    rayon_core,\n+    parking_lot::{Mutex, Condvar},\n+    std::sync::atomic::Ordering,\n+    std::thread,\n+    std::iter,\n+    std::iter::FromIterator,\n+    syntax_pos::DUMMY_SP,\n+    rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher, HashStable},\n+};\n \n /// Indicates the state of a query for a given key in a query map\n pub(super) enum QueryResult<'tcx> {\n@@ -42,6 +60,9 @@ pub struct QueryJob<'tcx> {\n \n     /// Diagnostic messages which are emitted while the query executes\n     pub diagnostics: Lock<Vec<Diagnostic>>,\n+\n+    #[cfg(parallel_queries)]\n+    latch: QueryLatch,\n }\n \n impl<'tcx> QueryJob<'tcx> {\n@@ -51,6 +72,8 @@ impl<'tcx> QueryJob<'tcx> {\n             diagnostics: Lock::new(Vec::new()),\n             info,\n             parent,\n+            #[cfg(parallel_queries)]\n+            latch: QueryLatch::new(),\n         }\n     }\n \n@@ -62,6 +85,36 @@ impl<'tcx> QueryJob<'tcx> {\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n+    ) -> Result<(), CycleError<'tcx>> {\n+        #[cfg(not(parallel_queries))]\n+        {\n+            self.find_cycle_in_stack(tcx, span)\n+        }\n+\n+        #[cfg(parallel_queries)]\n+        {\n+            tls::with_related_context(tcx, move |icx| {\n+                let mut waiter = QueryWaiter {\n+                    query: &icx.query,\n+                    span,\n+                    cycle: None,\n+                    condvar: Condvar::new(),\n+                };\n+                self.latch.await(&mut waiter);\n+\n+                match waiter.cycle {\n+                    None => Ok(()),\n+                    Some(cycle) => Err(cycle)\n+                }\n+            })\n+        }\n+    }\n+\n+    #[cfg(not(parallel_queries))]\n+    fn find_cycle_in_stack<'lcx>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'lcx>,\n+        span: Span,\n     ) -> Result<(), CycleError<'tcx>> {\n         // Get the current executing query (waiter) and find the waitee amongst its parents\n         let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n@@ -93,5 +146,315 @@ impl<'tcx> QueryJob<'tcx> {\n     ///\n     /// This does nothing for single threaded rustc,\n     /// as there are no concurrent jobs which could be waiting on us\n-    pub fn signal_complete(&self) {}\n+    pub fn signal_complete(&self, tcx: TyCtxt<'_, 'tcx, '_>) {\n+        #[cfg(parallel_queries)]\n+        self.latch.set(tcx);\n+    }\n+}\n+\n+#[cfg(parallel_queries)]\n+struct QueryWaiter<'a, 'tcx: 'a> {\n+    query: &'a Option<Lrc<QueryJob<'tcx>>>,\n+    condvar: Condvar,\n+    span: Span,\n+    cycle: Option<CycleError<'tcx>>,\n+}\n+\n+#[cfg(parallel_queries)]\n+impl<'a, 'tcx> QueryWaiter<'a, 'tcx> {\n+    fn notify(&self, tcx: TyCtxt<'_, '_, '_>, registry: &rayon_core::Registry) {\n+        rayon_core::mark_unblocked(registry);\n+        self.condvar.notify_one();\n+    }\n+}\n+\n+#[cfg(parallel_queries)]\n+struct QueryLatchInfo {\n+    complete: bool,\n+    waiters: Vec<&'static mut QueryWaiter<'static, 'static>>,\n+}\n+\n+#[cfg(parallel_queries)]\n+struct QueryLatch {\n+    info: Mutex<QueryLatchInfo>,\n+}\n+\n+#[cfg(parallel_queries)]\n+impl QueryLatch {\n+    fn new() -> Self {\n+        QueryLatch {\n+            info: Mutex::new(QueryLatchInfo {\n+                complete: false,\n+                waiters: Vec::new(),\n+            }),\n+        }\n+    }\n+\n+    fn await(&self, waiter: &mut QueryWaiter<'_, '_>) {\n+        let mut info = self.info.lock();\n+        if !info.complete {\n+            let waiter = &*waiter;\n+            unsafe {\n+                #[allow(mutable_transmutes)]\n+                info.waiters.push(mem::transmute(waiter));\n+            }\n+            // If this detects a deadlock and the deadlock handler want to resume this thread\n+            // we have to be in the `wait` call. This is ensured by the deadlock handler\n+            // getting the self.info lock.\n+            rayon_core::mark_blocked();\n+            waiter.condvar.wait(&mut info);\n+        }\n+    }\n+\n+    fn set(&self, tcx: TyCtxt<'_, '_, '_>) {\n+        let mut info = self.info.lock();\n+        debug_assert!(!info.complete);\n+        info.complete = true;\n+        let registry = rayon_core::Registry::current();\n+        for waiter in info.waiters.drain(..) {\n+            waiter.notify(tcx, &registry);\n+        }\n+    }\n+\n+    fn resume_waiter(\n+        &self,\n+        waiter: usize,\n+        error: CycleError\n+    ) -> &'static mut QueryWaiter<'static, 'static> {\n+        let mut info = self.info.lock();\n+        debug_assert!(!info.complete);\n+        // Remove the waiter from the list of waiters\n+        let waiter = info.waiters.remove(waiter);\n+\n+        // Set the cycle error it will be picked it up when resumed\n+        waiter.cycle = unsafe { Some(mem::transmute(error)) };\n+\n+        waiter\n+    }\n+}\n+\n+#[cfg(parallel_queries)]\n+type Ref<'tcx> = *const QueryJob<'tcx>;\n+\n+#[cfg(parallel_queries)]\n+type Waiter<'tcx> = (Ref<'tcx>, usize);\n+\n+#[cfg(parallel_queries)]\n+fn visit_waiters<'tcx, F>(query_ref: Ref<'tcx>, mut visit: F) -> Option<Option<Waiter<'tcx>>>\n+where\n+    F: FnMut(Span, Ref<'tcx>) -> Option<Option<Waiter<'tcx>>>\n+{\n+    let query = unsafe { &*query_ref };\n+    if let Some(ref parent) = query.parent {\n+        if let Some(cycle) = visit(query.info.span, &**parent as Ref) {\n+            return Some(cycle);\n+        }\n+    }\n+    for (i, waiter) in query.latch.info.lock().waiters.iter().enumerate() {\n+        if let Some(ref waiter_query) = waiter.query {\n+            if visit(waiter.span, &**waiter_query as Ref).is_some() {\n+                return Some(Some((query_ref, i)));\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+#[cfg(parallel_queries)]\n+fn cycle_check<'tcx>(query: Ref<'tcx>,\n+                     span: Span,\n+                     stack: &mut Vec<(Span, Ref<'tcx>)>,\n+                     visited: &mut HashSet<Ref<'tcx>>) -> Option<Option<Waiter<'tcx>>> {\n+    if visited.contains(&query) {\n+        return if let Some(p) = stack.iter().position(|q| q.1 == query) {\n+            // Remove previous stack entries\n+            stack.splice(0..p, iter::empty());\n+            // Replace the span for the first query with the cycle cause\n+            stack[0].0 = span;\n+            Some(None)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    visited.insert(query);\n+    stack.push((span, query));\n+\n+    let r = visit_waiters(query, |span, successor| {\n+        cycle_check(successor, span, stack, visited)\n+    });\n+\n+    if r.is_none() {\n+        stack.pop();\n+    }\n+\n+    r\n+}\n+\n+#[cfg(parallel_queries)]\n+fn connected_to_root<'tcx>(query: Ref<'tcx>, visited: &mut HashSet<Ref<'tcx>>) -> bool {\n+    if visited.contains(&query) {\n+        return false;\n+    }\n+\n+    if unsafe { (*query).parent.is_none() } {\n+        return true;\n+    }\n+\n+    visited.insert(query);\n+\n+    let mut connected = false;\n+\n+    visit_waiters(query, |_, successor| {\n+        if connected_to_root(successor, visited) {\n+            Some(None)\n+        } else {\n+            None\n+        }\n+    }).is_some()\n+}\n+\n+#[cfg(parallel_queries)]\n+fn query_entry<'tcx>(r: Ref<'tcx>) -> QueryInfo<'tcx> {\n+    unsafe { (*r).info.clone() }\n+}\n+\n+#[cfg(parallel_queries)]\n+fn remove_cycle<'tcx>(\n+    jobs: &mut Vec<Ref<'tcx>>,\n+    wakelist: &mut Vec<&'static mut QueryWaiter<'static, 'static>>,\n+    tcx: TyCtxt<'_, 'tcx, '_>\n+) {\n+    let mut visited = HashSet::new();\n+    let mut stack = Vec::new();\n+    if let Some(waiter) = cycle_check(jobs.pop().unwrap(),\n+                                      DUMMY_SP,\n+                                      &mut stack,\n+                                      &mut visited) {\n+        // Reverse the stack so earlier entries require later entries\n+        stack.reverse();\n+\n+        let mut spans: Vec<_> = stack.iter().map(|e| e.0).collect();\n+        let queries = stack.iter().map(|e| e.1);\n+\n+        // Shift the spans so that a query is matched the span for its waitee\n+        let last = spans.pop().unwrap();\n+        spans.insert(0, last);\n+\n+        let mut stack: Vec<_> = spans.into_iter().zip(queries).collect();\n+\n+        // Remove the queries in our cycle from the list of jobs to look at\n+        for r in &stack {\n+            jobs.remove_item(&r.1);\n+        }\n+\n+        let (waitee_query, waiter_idx) = waiter.unwrap();\n+        let waitee_query = unsafe { &*waitee_query };\n+\n+        // Find the queries in the cycle which are\n+        // connected to queries outside the cycle\n+        let entry_points: Vec<Ref<'_>> = stack.iter().filter_map(|query| {\n+            // Mark all the other queries in the cycle as already visited\n+            let mut visited = HashSet::from_iter(stack.iter().filter_map(|q| {\n+                if q.1 != query.1 {\n+                    Some(q.1)\n+                } else {\n+                    None\n+                }\n+            }));\n+\n+            if connected_to_root(query.1, &mut visited) {\n+                Some(query.1)\n+            } else {\n+                None\n+            }\n+        }).collect();\n+\n+        // Deterministically pick an entry point\n+        // FIXME: Sort this instead\n+        let mut hcx = tcx.create_stable_hashing_context();\n+        let entry_point = *entry_points.iter().min_by_key(|&&q| {\n+            let mut stable_hasher = StableHasher::<u64>::new();\n+            unsafe { (*q).info.query.hash_stable(&mut hcx, &mut stable_hasher); }\n+            stable_hasher.finish()\n+        }).unwrap();\n+\n+        // Shift the stack until our entry point is first\n+        while stack[0].1 != entry_point {\n+            let last = stack.pop().unwrap();\n+            stack.insert(0, last);\n+        }\n+\n+        let mut error = CycleError {\n+            usage: None,\n+            cycle: stack.iter().map(|&(s, q)| QueryInfo {\n+                span: s,\n+                query: unsafe { (*q).info.query.clone() },\n+            } ).collect(),\n+        };\n+\n+        wakelist.push(waitee_query.latch.resume_waiter(waiter_idx, error));\n+    }\n+}\n+\n+#[cfg(parallel_queries)]\n+pub fn handle_deadlock() {\n+    use syntax;\n+    use syntax_pos;\n+\n+    let registry = rayon_core::Registry::current();\n+\n+    let gcx_ptr = tls::GCX_PTR.with(|gcx_ptr| {\n+        gcx_ptr as *const _\n+    });\n+    let gcx_ptr = unsafe { &*gcx_ptr };\n+\n+    let syntax_globals = syntax::GLOBALS.with(|syntax_globals| {\n+        syntax_globals as *const _\n+    });\n+    let syntax_globals = unsafe { &*syntax_globals };\n+\n+    let syntax_pos_globals = syntax_pos::GLOBALS.with(|syntax_pos_globals| {\n+        syntax_pos_globals as *const _\n+    });\n+    let syntax_pos_globals = unsafe { &*syntax_pos_globals };\n+    thread::spawn(move || {\n+        tls::GCX_PTR.set(gcx_ptr, || {\n+            syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n+                syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n+                    tls::with_thread_locals(|| {\n+                        unsafe {\n+                            tls::with_global(|tcx| deadlock(tcx, &registry))\n+                        }\n+                    })\n+                })\n+            })\n+        })\n+    });\n+}\n+\n+#[cfg(parallel_queries)]\n+fn deadlock(tcx: TyCtxt<'_, '_, '_>, registry: &rayon_core::Registry) {\n+    let on_panic = OnDrop(|| {\n+        eprintln!(\"deadlock handler panicked, aborting process\");\n+        process::abort();\n+    });\n+\n+    let mut wakelist = Vec::new();\n+    let mut jobs: Vec<_> = tcx.maps.collect_active_jobs().iter().map(|j| &**j as Ref).collect();\n+\n+    while jobs.len() > 0 {\n+        remove_cycle(&mut jobs, &mut wakelist, tcx);\n+    }\n+\n+    // FIXME: Panic if no cycle is detected\n+\n+    // FIXME: Write down the conditions when a deadlock happens without a cycle\n+\n+    // FIXME: Ensure this won't cause a deadlock before we return\n+    for waiter in wakelist.into_iter() {\n+        waiter.notify(tcx, registry);\n+    }\n+\n+    mem::forget(on_panic);\n }"}, {"sha": "b50b43aace760d2797f3821fa54321358eda0bbb", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "patch": "@@ -63,10 +63,12 @@ use syntax::symbol::Symbol;\n #[macro_use]\n mod plumbing;\n use self::plumbing::*;\n-pub use self::plumbing::force_from_dep_node;\n+pub use self::plumbing::{force_from_dep_node, CycleError};\n \n mod job;\n pub use self::job::{QueryJob, QueryInfo};\n+#[cfg(parallel_queries)]\n+pub use self::job::handle_deadlock;\n \n mod keys;\n pub use self::keys::Key;"}, {"sha": "2ab8d18e3e7ddaec83fc3c470c84b36d68b7e04e", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n }\n \n #[derive(Clone)]\n-pub(super) struct CycleError<'tcx> {\n+pub struct CycleError<'tcx> {\n     /// The query and related span which uses the cycle\n     pub(super) usage: Option<(Span, Query<'tcx>)>,\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n@@ -632,7 +632,15 @@ macro_rules! define_maps {\n      $($(#[$attr:meta])*\n        [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*) => {\n \n+        use std::mem;\n+        use ty::maps::job::QueryResult;\n         use rustc_data_structures::sync::Lock;\n+        use {\n+            rustc_data_structures::stable_hasher::HashStable,\n+            rustc_data_structures::stable_hasher::StableHasherResult,\n+            rustc_data_structures::stable_hasher::StableHasher,\n+            ich::StableHashingContext\n+        };\n \n         define_map_struct! {\n             tcx: $tcx,\n@@ -647,10 +655,23 @@ macro_rules! define_maps {\n                     $($name: Lock::new(QueryMap::new())),*\n                 }\n             }\n+\n+            pub fn collect_active_jobs(&self) -> Vec<Lrc<QueryJob<$tcx>>> {\n+                let mut jobs = Vec::new();\n+\n+                $(for v in self.$name.lock().active.values() {\n+                    match *v {\n+                        QueryResult::Started(ref job) => jobs.push(job.clone()),\n+                        _ => (),\n+                    }\n+                })*\n+\n+                return jobs;\n+            }\n         }\n \n         #[allow(bad_style)]\n-        #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+        #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n         pub enum Query<$tcx> {\n             $($(#[$attr])* $name($K)),*\n         }\n@@ -692,6 +713,17 @@ macro_rules! define_maps {\n             }\n         }\n \n+        impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n+            fn hash_stable<W: StableHasherResult>(&self,\n+                                                hcx: &mut StableHashingContext<'a>,\n+                                                hasher: &mut StableHasher<W>) {\n+                mem::discriminant(self).hash_stable(hcx, hasher);\n+                match *self {\n+                    $(Query::$name(key) => key.hash_stable(hcx, hasher),)*\n+                }\n+            }\n+        }\n+\n         pub mod queries {\n             use std::marker::PhantomData;\n "}, {"sha": "c2a450a1122924876ea59a772eef82743af84083", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9e6fbc4f751a5fd4befaf91ad4b1022efb99501/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=f9e6fbc4f751a5fd4befaf91ad4b1022efb99501", "patch": "@@ -49,7 +49,7 @@ use std::fs;\n use std::io::{self, Write};\n use std::iter;\n use std::path::{Path, PathBuf};\n-use rustc_data_structures::sync::{self, Lrc};\n+use rustc_data_structures::sync::{self, Lrc, Lock};\n use std::sync::mpsc;\n use syntax::{self, ast, attr, diagnostics, visit};\n use syntax::ext::base::ExtCtxt;\n@@ -69,7 +69,9 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n     opts: config::Options,\n     f: F\n ) -> R {\n-    f(opts)\n+    ty::tls::GCX_PTR.set(&Lock::new(0), || {\n+        f(opts)\n+    })\n }\n \n #[cfg(parallel_queries)]\n@@ -81,7 +83,10 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n     use syntax_pos;\n     use rayon::{ThreadPoolBuilder, ThreadPool};\n \n+    let gcx_ptr = &Lock::new(0);\n+\n     let config = ThreadPoolBuilder::new().num_threads(Session::query_threads_from_opts(&opts))\n+                                         .deadlock_handler(ty::maps::handle_deadlock)\n                                          .stack_size(16 * 1024 * 1024);\n \n     let with_pool = move |pool: &ThreadPool| {\n@@ -98,7 +103,9 @@ pub fn spawn_thread_pool<F: FnOnce(config::Options) -> R + sync::Send, R: sync::\n                 syntax::GLOBALS.set(syntax_globals, || {\n                     syntax_pos::GLOBALS.set(syntax_pos_globals, || {\n                         ty::tls::with_thread_locals(|| {\n-                            worker()\n+                            ty::tls::GCX_PTR.set(gcx_ptr, || {\n+                                worker()\n+                            })\n                         })\n                     })\n                 })"}]}