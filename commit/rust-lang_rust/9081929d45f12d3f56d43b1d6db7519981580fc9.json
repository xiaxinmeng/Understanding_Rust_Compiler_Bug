{"sha": "9081929d45f12d3f56d43b1d6db7519981580fc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwODE5MjlkNDVmMTJkM2Y1NmQ0M2IxZDZkYjc1MTk5ODE1ODBmYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T22:00:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T22:00:28Z"}, "message": "Auto merge of #66879 - RalfJung:rollup-nprxpzi, r=RalfJung\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #66379 (Rephrase docs in for ptr)\n - #66589 (Draw vertical lines correctly in compiler error messages)\n - #66613 (Allow customising ty::TraitRef's printing behavior)\n - #66766 (Panic machinery comments and tweaks)\n - #66791 (Handle GlobalCtxt directly from librustc_interface query system)\n - #66793 (Record temporary static references in generator witnesses)\n - #66808 (Cleanup error code)\n - #66826 (Clarifies how to tag users for assigning PRs)\n - #66837 (Clarify `{f32,f64}::EPSILON` docs)\n - #66844 (Miri: do not consider memory allocated by caller_location leaked)\n - #66872 (Minor documentation fix)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "23864775c3e4cab78e4612aad345352b92a28f55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23864775c3e4cab78e4612aad345352b92a28f55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9081929d45f12d3f56d43b1d6db7519981580fc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9081929d45f12d3f56d43b1d6db7519981580fc9", "html_url": "https://github.com/rust-lang/rust/commit/9081929d45f12d3f56d43b1d6db7519981580fc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9081929d45f12d3f56d43b1d6db7519981580fc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25d8a9494ca6d77361e47c1505ecf640b168819e", "url": "https://api.github.com/repos/rust-lang/rust/commits/25d8a9494ca6d77361e47c1505ecf640b168819e", "html_url": "https://github.com/rust-lang/rust/commit/25d8a9494ca6d77361e47c1505ecf640b168819e"}, {"sha": "0b1b36ccb6c84a16b097f58bb6aa249f5ce73821", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b1b36ccb6c84a16b097f58bb6aa249f5ce73821", "html_url": "https://github.com/rust-lang/rust/commit/0b1b36ccb6c84a16b097f58bb6aa249f5ce73821"}], "stats": {"total": 1001, "additions": 622, "deletions": 379}, "files": [{"sha": "8fbbd7c4a2e49b0ac2e86dae076ce6e6248ad21e", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -150,13 +150,13 @@ All pull requests are reviewed by another person. We have a bot,\n request.\n \n If you want to request that a specific person reviews your pull request,\n-you can add an `r?` to the message. For example, [Steve][steveklabnik] usually reviews\n+you can add an `r?` to the pull request description. For example, [Steve][steveklabnik] usually reviews\n documentation changes. So if you were to make a documentation change, add\n \n     r? @steveklabnik\n \n-to the end of the message, and @rust-highfive will assign [@steveklabnik][steveklabnik] instead\n-of a random person. This is entirely optional.\n+to the end of the pull request description, and [@rust-highfive][rust-highfive] will assign\n+[@steveklabnik][steveklabnik] instead of a random person. This is entirely optional.\n \n After someone has reviewed your pull request, they will leave an annotation\n on the pull request with an `r+`. It will look something like this:"}, {"sha": "466750fc7d2c63035f6f4cc46cba596ccf5827fe", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -68,7 +68,7 @@ use crate::intrinsics;\n // Any trait\n ///////////////////////////////////////////////////////////////////////////////\n \n-/// A type to emulate dynamic typing.\n+/// A trait to emulate dynamic typing.\n ///\n /// Most types implement `Any`. However, any type which contains a non-`'static` reference does not.\n /// See the [module-level documentation][mod] for more details."}, {"sha": "913c0f96d118da09e2d974915fa5a41696415823", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -26,7 +26,7 @@ pub const DIGITS: u32 = 6;\n \n /// [Machine epsilon] value for `f32`.\n ///\n-/// This is the difference between `1.0` and the next largest representable number.\n+/// This is the difference between `1.0` and the next larger representable number.\n ///\n /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "6ca830b1f38afa190f8a3b4d4a4fb4df2b756205", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -26,7 +26,7 @@ pub const DIGITS: u32 = 15;\n \n /// [Machine epsilon] value for `f64`.\n ///\n-/// This is the difference between `1.0` and the next largest representable number.\n+/// This is the difference between `1.0` and the next larger representable number.\n ///\n /// [Machine epsilon]: https://en.wikipedia.org/wiki/Machine_epsilon\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "99b372d92c8b6c4945aa5f8761a35442a71a2306", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -266,6 +266,16 @@ impl fmt::Display for Location<'_> {\n #[unstable(feature = \"std_internals\", issue = \"0\")]\n #[doc(hidden)]\n pub unsafe trait BoxMeUp {\n-    fn box_me_up(&mut self) -> *mut (dyn Any + Send);\n+    /// Take full ownership of the contents.\n+    /// The return type is actually `Box<dyn Any + Send>`, but we cannot use `Box` in libcore.\n+    ///\n+    /// After this method got called, only some dummy default value is left in `self`.\n+    /// Calling this method twice, or calling `get` after calling this method, is an error.\n+    ///\n+    /// The argument is borrowed because the panic runtime (`__rust_start_panic`) only\n+    /// gets a borrowed `dyn BoxMeUp`.\n+    fn take_box(&mut self) -> *mut (dyn Any + Send);\n+\n+    /// Just borrow the contents.\n     fn get(&mut self) -> &(dyn Any + Send);\n }"}, {"sha": "5a8d647396ddab6b3f5512f0d35e69b43332b355", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -11,13 +11,13 @@\n //! ```\n //!\n //! This definition allows for panicking with any general message, but it does not\n-//! allow for failing with a `Box<Any>` value. The reason for this is that libcore\n-//! is not allowed to allocate.\n+//! allow for failing with a `Box<Any>` value. (`PanicInfo` just contains a `&(dyn Any + Send)`,\n+//! for which we fill in a dummy value in `PanicInfo::internal_constructor`.)\n+//! The reason for this is that libcore is not allowed to allocate.\n //!\n //! This module contains a few other panicking functions, but these are just the\n //! necessary lang items for the compiler. All panics are funneled through this\n-//! one function. Currently, the actual symbol is declared in the standard\n-//! library, but the location of this may change over time.\n+//! one function. The actual symbol is declared through the `#[panic_handler]` attribute.\n \n // ignore-tidy-undocumented-unsafe\n \n@@ -72,6 +72,7 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>, location: &Location<'_>) -> ! {\n     }\n \n     // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n+    // that gets resolved to the `#[panic_handler]` function.\n     extern \"Rust\" {\n         #[lang = \"panic_impl\"]\n         fn panic_impl(pi: &PanicInfo<'_>) -> !;"}, {"sha": "1e051dbebcaf82519fce4f8ff3cced23daffe80f", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1074,17 +1074,22 @@ impl<T: ?Sized> *const T {\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n     ///\n-    /// When calling this method, you have to ensure that if the pointer is\n-    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n-    /// size of `T`) and points to an initialized instance of `T`. This applies\n-    /// even if the result of this method is unused!\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    /// - it is properly aligned\n+    /// - it must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is, the only safe approach is to ensure that they are indeed initialized.)\n     ///\n     /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. It is up to the\n-    /// caller to ensure that for the duration of this lifetime, the memory this\n-    /// pointer points to does not get written to outside of `UnsafeCell<U>`.\n+    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n+    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n+    /// the memory the pointer points to must not get mutated (except inside `UnsafeCell`).\n+    ///\n+    /// [here]: crate::ptr#safety\n     ///\n     /// # Examples\n     ///\n@@ -1929,18 +1934,23 @@ impl<T: ?Sized> *mut T {\n     /// of the returned pointer, nor can it ensure that the lifetime `'a`\n     /// returned is indeed a valid lifetime for the contained data.\n     ///\n-    /// When calling this method, you have to ensure that if the pointer is\n-    /// non-NULL, then it is properly aligned, dereferencable (for the whole\n-    /// size of `T`) and points to an initialized instance of `T`. This applies\n-    /// even if the result of this method is unused!\n+    /// When calling this method, you have to ensure that *either* the pointer is NULL *or*\n+    /// all of the following is true:\n+    /// - it is properly aligned\n+    /// - it must point to an initialized instance of T; in particular, the pointer must be\n+    ///   \"dereferencable\" in the sense defined [here].\n+    ///\n+    /// This applies even if the result of this method is unused!\n     /// (The part about being initialized is not yet fully decided, but until\n     /// it is the only safe approach is to ensure that they are indeed initialized.)\n     ///\n     /// Additionally, the lifetime `'a` returned is arbitrarily chosen and does\n-    /// not necessarily reflect the actual lifetime of the data. It is up to the\n-    /// caller to ensure that for the duration of this lifetime, the memory this\n-    /// pointer points to does not get accessed through any other pointer.\n+    /// not necessarily reflect the actual lifetime of the data. *You* must enforce\n+    /// Rust's aliasing rules. In particular, for the duration of this lifetime,\n+    /// the memory this pointer points to must not get accessed (read or written)\n+    /// through any other pointer.\n     ///\n+    /// [here]: crate::ptr#safety\n     /// [`as_ref`]: #method.as_ref\n     ///\n     /// # Examples"}, {"sha": "0c834e5c2a05c3bce0e2cd7b45e14efda6b8f582", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -94,5 +94,5 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n #[unwind(allowed)]\n pub unsafe extern \"C\" fn __rust_start_panic(payload: usize) -> u32 {\n     let payload = payload as *mut &mut dyn BoxMeUp;\n-    imp::panic(Box::from_raw((*payload).box_me_up()))\n+    imp::panic(Box::from_raw((*payload).take_box()))\n }"}, {"sha": "193b04eabb3fb77ed56be2e586fccd61f763e48b", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -93,6 +93,7 @@ macro_rules! arena_types {\n                         rustc::hir::def_id::CrateNum\n                     >\n                 >,\n+            [few] hir_forest: rustc::hir::map::Forest,\n             [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n                 syntax::symbol::Symbol,\n                 rustc::hir::def_id::DefId,"}, {"sha": "5bf5a93ad010271833671248ea41dbb6916ef412", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -200,7 +200,7 @@ pub struct Map<'hir> {\n \n     map: HirEntryMap<'hir>,\n \n-    definitions: &'hir Definitions,\n+    definitions: Definitions,\n \n     /// The reverse mapping of `node_to_hir_id`.\n     hir_to_node_id: FxHashMap<HirId, NodeId>,\n@@ -267,8 +267,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn definitions(&self) -> &'hir Definitions {\n-        self.definitions\n+    pub fn definitions(&self) -> &Definitions {\n+        &self.definitions\n     }\n \n     pub fn def_key(&self, def_id: DefId) -> DefKey {\n@@ -1251,7 +1251,7 @@ impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n pub fn map_crate<'hir>(sess: &crate::session::Session,\n                        cstore: &CrateStoreDyn,\n                        forest: &'hir Forest,\n-                       definitions: &'hir Definitions)\n+                       definitions: Definitions)\n                        -> Map<'hir> {\n     let _prof_timer = sess.prof.generic_activity(\"build_hir_map\");\n \n@@ -1260,7 +1260,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n         .map(|(node_id, &hir_id)| (hir_id, node_id)).collect();\n \n     let (map, crate_hash) = {\n-        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, definitions, cstore);\n+        let hcx = crate::ich::StableHashingContext::new(sess, &forest.krate, &definitions, cstore);\n \n         let mut collector = NodeCollector::root(sess,\n                                                 &forest.krate,"}, {"sha": "5a940f2f80aa2a70bbd98ba455b1e9f982cd1356", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1545,8 +1545,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             infer::Types(ref exp_found) => self.expected_found_str_ty(exp_found),\n             infer::Regions(ref exp_found) => self.expected_found_str(exp_found),\n             infer::Consts(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n+            infer::TraitRefs(ref exp_found) => {\n+                let pretty_exp_found = ty::error::ExpectedFound {\n+                    expected: exp_found.expected.print_only_trait_path(),\n+                    found: exp_found.found.print_only_trait_path()\n+                };\n+                self.expected_found_str(&pretty_exp_found)\n+            },\n+            infer::PolyTraitRefs(ref exp_found) => {\n+                let pretty_exp_found = ty::error::ExpectedFound {\n+                    expected: exp_found.expected.print_only_trait_path(),\n+                    found: exp_found.found.print_only_trait_path()\n+                };\n+                self.expected_found_str(&pretty_exp_found)\n+            },\n         }\n     }\n "}, {"sha": "3b4d06aab27ef6827334fab02e3049b2739831b8", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -401,15 +401,15 @@ impl NiceRegionError<'me, 'tcx> {\n                 format!(\n                     \"{}`{}` would have to be implemented for the type `{}`\",\n                     if leading_ellipsis { \"...\" } else { \"\" },\n-                    expected_trait_ref,\n+                    expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n                     \"{}`{}` must implement `{}`\",\n                     if leading_ellipsis { \"...\" } else { \"\" },\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n-                    expected_trait_ref,\n+                    expected_trait_ref.map(|tr| tr.print_only_trait_path()),\n                 )\n             };\n \n@@ -449,14 +449,14 @@ impl NiceRegionError<'me, 'tcx> {\n             let mut note = if passive_voice {\n                 format!(\n                     \"...but `{}` is actually implemented for the type `{}`\",\n-                    actual_trait_ref,\n+                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n                     \"...but `{}` actually implements `{}`\",\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n-                    actual_trait_ref,\n+                    actual_trait_ref.map(|tr| tr.print_only_trait_path()),\n                 )\n             };\n "}, {"sha": "b3ddffc8b12f1e782629aa45c9026d2f76163e23", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1292,7 +1292,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n-        self.resolve_vars_if_possible(t).to_string()\n+        self.resolve_vars_if_possible(t).print_only_trait_path().to_string()\n     }\n \n     /// If `TyVar(vid)` resolves to a type, return that type. Else, return the"}, {"sha": "05543f1d2ef7339e3e80adf8d5ee9e89eec64360", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -800,8 +800,13 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n                 // This shouldn't ever be needed, but just in case:\n                 path.push(match trait_ref {\n                     Some(trait_ref) => {\n-                        Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref,\n-                                                    self_ty))\n+                        Symbol::intern(\n+                            &format!(\n+                                \"<impl {} for {}>\",\n+                                trait_ref.print_only_trait_path(),\n+                                self_ty\n+                            )\n+                        )\n                     },\n                     None => Symbol::intern(&format!(\"<impl {}>\", self_ty)),\n                 });"}, {"sha": "90db1fe319556fc1bab17c373f1a4b3d817743bb", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -737,7 +737,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         let is_try = self.tcx.sess.source_map().span_to_snippet(span)\n                             .map(|s| &s == \"?\")\n                             .unwrap_or(false);\n-                        let is_from = format!(\"{}\", trait_ref).starts_with(\"std::convert::From<\");\n+                        let is_from =\n+                            format!(\"{}\", trait_ref.print_only_trait_path())\n+                            .starts_with(\"std::convert::From<\");\n                         let (message, note) = if is_try && is_from {\n                             (Some(format!(\n                                 \"`?` couldn't convert the error to `{}`\",\n@@ -768,7 +770,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                 format!(\n                                     \"{}the trait `{}` is not implemented for `{}`\",\n                                     pre_message,\n-                                    trait_ref,\n+                                    trait_ref.print_only_trait_path(),\n                                     trait_ref.self_ty(),\n                                 )\n                             };\n@@ -1189,7 +1191,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 if param_ty => {\n                     // Missing generic type parameter bound.\n                     let param_name = self_ty.to_string();\n-                    let constraint = trait_ref.to_string();\n+                    let constraint = trait_ref.print_only_trait_path().to_string();\n                     if suggest_constraining_type_param(\n                         generics,\n                         &mut err,\n@@ -1416,7 +1418,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     let msg = format!(\n                         \"the trait bound `{}: {}` is not satisfied\",\n                         found,\n-                        obligation.parent_trait_ref.skip_binder(),\n+                        obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n                     );\n                     if has_custom_message {\n                         err.note(&msg);\n@@ -1430,7 +1432,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                     err.span_label(span, &format!(\n                         \"expected an implementor of trait `{}`\",\n-                        obligation.parent_trait_ref.skip_binder(),\n+                        obligation.parent_trait_ref.skip_binder().print_only_trait_path(),\n                     ));\n                     err.span_suggestion(\n                         span,\n@@ -1562,7 +1564,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     } else {\n                         err.note(&format!(\n                             \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n-                            trait_ref,\n+                            trait_ref.print_only_trait_path(),\n                             trait_type,\n                             trait_ref.skip_binder().self_ty(),\n                         ));\n@@ -2226,7 +2228,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             err.span_note(span, &format!(\n                 \"future does not implement `{}` as this value is used across an await\",\n-                trait_ref,\n+                trait_ref.print_only_trait_path(),\n             ));\n \n             // Add a note for the item obligation that remains - normally a note pointing to the\n@@ -2409,7 +2411,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n                 err.note(\n                     &format!(\"required because of the requirements on the impl of `{}` for `{}`\",\n-                             parent_trait_ref,\n+                             parent_trait_ref.print_only_trait_path(),\n                              parent_trait_ref.skip_binder().self_ty()));\n                 let parent_predicate = parent_trait_ref.to_predicate();\n                 self.note_obligation_cause_code(err,"}, {"sha": "5f324527a2725b3d1aa65b095c9128cf7b1b106e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1044,7 +1044,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n                         let self_ty = trait_ref.self_ty();\n                         let cause = IntercrateAmbiguityCause::DownstreamCrate {\n-                            trait_desc: trait_ref.to_string(),\n+                            trait_desc: trait_ref.print_only_trait_path().to_string(),\n                             self_desc: if self_ty.has_concrete_skeleton() {\n                                 Some(self_ty.to_string())\n                             } else {\n@@ -1386,7 +1386,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     if !candidate_set.ambiguous && no_candidates_apply {\n                         let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n                         let self_ty = trait_ref.self_ty();\n-                        let trait_desc = trait_ref.to_string();\n+                        let trait_desc = trait_ref.print_only_trait_path().to_string();\n                         let self_desc = if self_ty.has_concrete_skeleton() {\n                             Some(self_ty.to_string())\n                         } else {"}, {"sha": "88a2db3dc622399516848966b5790bf316ea6bb4", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -417,7 +417,7 @@ fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<String>\n         w.push('>');\n     }\n \n-    write!(w, \" {} for {}\", trait_ref, tcx.type_of(impl_def_id)).unwrap();\n+    write!(w, \" {} for {}\", trait_ref.print_only_trait_path(), tcx.type_of(impl_def_id)).unwrap();\n \n     // The predicates will contain default bounds like `T: Sized`. We need to\n     // remove these bounds, and add `T: ?Sized` to any untouched type parameters."}, {"sha": "b8ddf6078bda6e1d20aabb978a6529afeadeed96", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -146,7 +146,7 @@ impl<'tcx> Children {\n                 let self_ty = trait_ref.self_ty();\n                 OverlapError {\n                     with_impl: possible_sibling,\n-                    trait_desc: trait_ref.to_string(),\n+                    trait_desc: trait_ref.print_only_trait_path().to_string(),\n                     // Only report the `Self` type if it has at least\n                     // some outer concrete shell; otherwise, it's\n                     // not adding much information."}, {"sha": "0b6937975aae1462c64eecb4c52f2811b227312d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -995,7 +995,7 @@ impl<'tcx> Deref for TyCtxt<'tcx> {\n }\n \n pub struct GlobalCtxt<'tcx> {\n-    pub arena: WorkerLocal<Arena<'tcx>>,\n+    pub arena: &'tcx WorkerLocal<Arena<'tcx>>,\n \n     interners: CtxtInterners<'tcx>,\n \n@@ -1170,6 +1170,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         local_providers: ty::query::Providers<'tcx>,\n         extern_providers: ty::query::Providers<'tcx>,\n         arenas: &'tcx AllArenas,\n+        arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         resolutions: ty::ResolverOutputs,\n         hir: hir_map::Map<'tcx>,\n         on_disk_query_result_cache: query::OnDiskCache<'tcx>,\n@@ -1225,7 +1226,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             sess: s,\n             lint_store,\n             cstore,\n-            arena: WorkerLocal::new(|_| Arena::default()),\n+            arena,\n             interners,\n             dep_graph,\n             prof: s.prof.clone(),"}, {"sha": "c941b3e5e4be98bba0b8f0e149e880351a26769e", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -449,7 +449,7 @@ pub trait PrettyPrinter<'tcx>:\n \n             p!(print(self_ty));\n             if let Some(trait_ref) = trait_ref {\n-                p!(write(\" as \"), print(trait_ref));\n+                p!(write(\" as \"), print(trait_ref.print_only_trait_path()));\n             }\n             Ok(cx)\n         })\n@@ -468,7 +468,7 @@ pub trait PrettyPrinter<'tcx>:\n \n             p!(write(\"impl \"));\n             if let Some(trait_ref) = trait_ref {\n-                p!(print(trait_ref), write(\" for \"));\n+                p!(print(trait_ref.print_only_trait_path()), write(\" for \"));\n             }\n             p!(print(self_ty));\n \n@@ -619,7 +619,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                             p!(\n                                     write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                    print(trait_ref));\n+                                    print(trait_ref.print_only_trait_path()));\n                             first = false;\n                         }\n                     }\n@@ -1696,6 +1696,30 @@ impl fmt::Display for ty::RegionKind {\n     }\n }\n \n+/// Wrapper type for `ty::TraitRef` which opts-in to pretty printing only\n+/// the trait path. That is, it will print `Trait<U>` instead of\n+/// `<T as Trait<U>>`.\n+#[derive(Copy, Clone, TypeFoldable, Lift)]\n+pub struct TraitRefPrintOnlyTraitPath<'tcx>(ty::TraitRef<'tcx>);\n+\n+impl fmt::Debug for TraitRefPrintOnlyTraitPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl ty::TraitRef<'tcx> {\n+    pub fn print_only_trait_path(self) -> TraitRefPrintOnlyTraitPath<'tcx> {\n+        TraitRefPrintOnlyTraitPath(self)\n+    }\n+}\n+\n+impl ty::Binder<ty::TraitRef<'tcx>> {\n+    pub fn print_only_trait_path(self) -> ty::Binder<TraitRefPrintOnlyTraitPath<'tcx>> {\n+        self.map_bound(|tr| tr.print_only_trait_path())\n+    }\n+}\n+\n forward_display_to_print! {\n     Ty<'tcx>,\n     &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n@@ -1705,6 +1729,7 @@ forward_display_to_print! {\n     // because `for<'tcx>` isn't possible yet.\n     ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n     ty::Binder<ty::TraitRef<'tcx>>,\n+    ty::Binder<TraitRefPrintOnlyTraitPath<'tcx>>,\n     ty::Binder<ty::FnSig<'tcx>>,\n     ty::Binder<ty::TraitPredicate<'tcx>>,\n     ty::Binder<ty::SubtypePredicate<'tcx>>,\n@@ -1739,7 +1764,7 @@ define_print_and_forward_display! {\n         // Use a type that can't appear in defaults of type parameters.\n         let dummy_self = cx.tcx().mk_ty_infer(ty::FreshTy(0));\n         let trait_ref = self.with_self_ty(cx.tcx(), dummy_self);\n-        p!(print(trait_ref))\n+        p!(print(trait_ref.print_only_trait_path()))\n     }\n \n     ty::ExistentialProjection<'tcx> {\n@@ -1783,7 +1808,11 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitRef<'tcx> {\n-        p!(print_def_path(self.def_id, self.substs));\n+        p!(write(\"<{} as {}>\", self.self_ty(), self.print_only_trait_path()))\n+    }\n+\n+    TraitRefPrintOnlyTraitPath<'tcx> {\n+        p!(print_def_path(self.0.def_id, self.0.substs));\n     }\n \n     ty::ParamTy {\n@@ -1799,7 +1828,8 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitPredicate<'tcx> {\n-        p!(print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+        p!(print(self.trait_ref.self_ty()), write(\": \"),\n+           print(self.trait_ref.print_only_trait_path()))\n     }\n \n     ty::ProjectionPredicate<'tcx> {"}, {"sha": "ffbf8813d309d4a58b760a3f98d846caa6288dd0", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -223,10 +223,7 @@ impl fmt::Debug for ty::FloatVarValue {\n \n impl fmt::Debug for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // FIXME(#59188) this is used across the compiler to print\n-        // a `TraitRef` qualified (with the Self type explicit),\n-        // instead of having a different way to make that choice.\n-        write!(f, \"<{} as {}>\", self.self_ty(), self)\n+        fmt::Display::fmt(self, f)\n     }\n }\n "}, {"sha": "0b11a9efd81d7a5a387c9fae1b58edb9c60ff431", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -682,6 +682,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.static_mutability(def_id) == Some(hir::Mutability::Mutable)\n     }\n \n+    /// Get the type of the pointer to the static that we use in MIR.\n+    pub fn static_ptr_ty(&self, def_id: DefId) -> Ty<'tcx> {\n+        // Make sure that any constants in the static's type are evaluated.\n+        let static_ty = self.normalize_erasing_regions(\n+            ty::ParamEnv::empty(),\n+            self.type_of(def_id),\n+        );\n+\n+        if self.is_mutable_static(def_id) {\n+            self.mk_mut_ptr(static_ty)\n+        } else if self.is_foreign_item(def_id) {\n+            self.mk_imm_ptr(static_ty)\n+        } else {\n+            self.mk_imm_ref(self.lifetimes.re_erased, static_ty)\n+        }\n+    }\n+\n     /// Expands the given impl trait type, stopping if the type is recursive.\n     pub fn try_expand_impl_trait_type(\n         self,"}, {"sha": "c945de8f1e1dc56020a9449523fa0cd1f0fe1c56", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 99, "deletions": 92, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -283,120 +283,127 @@ pub fn run_compiler(\n             return sess.compile_status();\n         }\n \n-        compiler.parse()?;\n-\n-        if let Some(ppm) = &sess.opts.pretty {\n-            if ppm.needs_ast_map() {\n-                compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n-                    let expanded_crate = compiler.expansion()?.take().0;\n-                    pretty::print_after_hir_lowering(\n-                        tcx,\n-                        compiler.input(),\n-                        &expanded_crate,\n+        let linker = compiler.enter(|queries| {\n+            let early_exit = || sess.compile_status().map(|_| None);\n+            queries.parse()?;\n+\n+            if let Some(ppm) = &sess.opts.pretty {\n+                if ppm.needs_ast_map() {\n+                    queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                        let expanded_crate = queries.expansion()?.take().0;\n+                        pretty::print_after_hir_lowering(\n+                            tcx,\n+                            compiler.input(),\n+                            &expanded_crate,\n+                            *ppm,\n+                            compiler.output_file().as_ref().map(|p| &**p),\n+                        );\n+                        Ok(())\n+                    })?;\n+                } else {\n+                    let krate = queries.parse()?.take();\n+                    pretty::print_after_parsing(\n+                        sess,\n+                        &compiler.input(),\n+                        &krate,\n                         *ppm,\n                         compiler.output_file().as_ref().map(|p| &**p),\n                     );\n-                    Ok(())\n-                })?;\n-            } else {\n-                let krate = compiler.parse()?.take();\n-                pretty::print_after_parsing(\n-                    sess,\n-                    &compiler.input(),\n-                    &krate,\n-                    *ppm,\n-                    compiler.output_file().as_ref().map(|p| &**p),\n-                );\n+                }\n+                return early_exit();\n             }\n-            return sess.compile_status();\n-        }\n \n-        if callbacks.after_parsing(compiler) == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n+            if callbacks.after_parsing(compiler) == Compilation::Stop {\n+                return early_exit();\n+            }\n \n-        if sess.opts.debugging_opts.parse_only ||\n-           sess.opts.debugging_opts.show_span.is_some() ||\n-           sess.opts.debugging_opts.ast_json_noexpand {\n-            return sess.compile_status();\n-        }\n+            if sess.opts.debugging_opts.parse_only ||\n+               sess.opts.debugging_opts.show_span.is_some() ||\n+               sess.opts.debugging_opts.ast_json_noexpand {\n+               return early_exit();\n+            }\n \n-        {\n-            let (_, lint_store) = &*compiler.register_plugins()?.peek();\n+            {\n+                let (_, lint_store) = &*queries.register_plugins()?.peek();\n \n-            // Lint plugins are registered; now we can process command line flags.\n-            if sess.opts.describe_lints {\n-                describe_lints(&sess, &lint_store, true);\n-                return sess.compile_status();\n+                // Lint plugins are registered; now we can process command line flags.\n+                if sess.opts.describe_lints {\n+                    describe_lints(&sess, &lint_store, true);\n+                    return early_exit();\n+                }\n             }\n-        }\n \n-        compiler.expansion()?;\n-        if callbacks.after_expansion(compiler) == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n+            queries.expansion()?;\n+            if callbacks.after_expansion(compiler) == Compilation::Stop {\n+                return early_exit();\n+            }\n \n-        compiler.prepare_outputs()?;\n+            queries.prepare_outputs()?;\n \n-        if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n-            && sess.opts.output_types.len() == 1\n-        {\n-            return sess.compile_status();\n-        }\n+            if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n+                && sess.opts.output_types.len() == 1\n+            {\n+                return early_exit();\n+            }\n \n-        compiler.global_ctxt()?;\n+            queries.global_ctxt()?;\n \n-        if sess.opts.debugging_opts.no_analysis ||\n-           sess.opts.debugging_opts.ast_json {\n-            return sess.compile_status();\n-        }\n+            if sess.opts.debugging_opts.no_analysis ||\n+               sess.opts.debugging_opts.ast_json {\n+                   return early_exit();\n+            }\n \n-        if sess.opts.debugging_opts.save_analysis {\n-            let expanded_crate = &compiler.expansion()?.peek().0;\n-            let crate_name = compiler.crate_name()?.peek().clone();\n-            compiler.global_ctxt()?.peek_mut().enter(|tcx| {\n-                let result = tcx.analysis(LOCAL_CRATE);\n-\n-                time(sess, \"save analysis\", || {\n-                    save::process_crate(\n-                        tcx,\n-                        &expanded_crate,\n-                        &crate_name,\n-                        &compiler.input(),\n-                        None,\n-                        DumpHandler::new(compiler.output_dir().as_ref().map(|p| &**p), &crate_name)\n-                    )\n-                });\n-\n-                result\n-                // AST will be dropped *after* the `after_analysis` callback\n-                // (needed by the RLS)\n-            })?;\n-        } else {\n-            // Drop AST after creating GlobalCtxt to free memory\n-            mem::drop(compiler.expansion()?.take());\n-        }\n+            if sess.opts.debugging_opts.save_analysis {\n+                let expanded_crate = &queries.expansion()?.peek().0;\n+                let crate_name = queries.crate_name()?.peek().clone();\n+                queries.global_ctxt()?.peek_mut().enter(|tcx| {\n+                    let result = tcx.analysis(LOCAL_CRATE);\n+\n+                    time(sess, \"save analysis\", || {\n+                        save::process_crate(\n+                            tcx,\n+                            &expanded_crate,\n+                            &crate_name,\n+                            &compiler.input(),\n+                            None,\n+                            DumpHandler::new(\n+                                compiler.output_dir().as_ref().map(|p| &**p), &crate_name\n+                            )\n+                        )\n+                    });\n \n-        compiler.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n+                    result\n+                    // AST will be dropped *after* the `after_analysis` callback\n+                    // (needed by the RLS)\n+                })?;\n+            } else {\n+                // Drop AST after creating GlobalCtxt to free memory\n+                mem::drop(queries.expansion()?.take());\n+            }\n \n-        if callbacks.after_analysis(compiler) == Compilation::Stop {\n-            return sess.compile_status();\n-        }\n+            queries.global_ctxt()?.peek_mut().enter(|tcx| tcx.analysis(LOCAL_CRATE))?;\n \n-        if sess.opts.debugging_opts.save_analysis {\n-            mem::drop(compiler.expansion()?.take());\n-        }\n+            if callbacks.after_analysis(compiler) == Compilation::Stop {\n+                return early_exit();\n+            }\n \n-        compiler.ongoing_codegen()?;\n+            if sess.opts.debugging_opts.save_analysis {\n+                mem::drop(queries.expansion()?.take());\n+            }\n \n-        // Drop GlobalCtxt after starting codegen to free memory\n-        mem::drop(compiler.global_ctxt()?.take());\n+            queries.ongoing_codegen()?;\n \n-        if sess.opts.debugging_opts.print_type_sizes {\n-            sess.code_stats.print_type_sizes();\n-        }\n+            if sess.opts.debugging_opts.print_type_sizes {\n+                sess.code_stats.print_type_sizes();\n+            }\n \n-        compiler.link()?;\n+            let linker = queries.linker()?;\n+            Ok(Some(linker))\n+        })?;\n+\n+        if let Some(linker) = linker {\n+            linker.link()?\n+        }\n \n         if sess.opts.debugging_opts.perf_stats {\n             sess.print_perf_stats();"}, {"sha": "273238a943b4fc9c9cce248c0a076abbce8ee768", "filename": "src/librustc_error_codes/error_codes/E0080.md", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1,14 +1,18 @@\n-This error indicates that the compiler was unable to sensibly evaluate a\n-constant expression that had to be evaluated. Attempting to divide by 0\n-or causing integer overflow are two ways to induce this error. For example:\n+A constant value failed to get evaluated.\n+\n+Erroneous code example:\n \n ```compile_fail,E0080\n enum Enum {\n     X = (1 << 500),\n-    Y = (1 / 0)\n+    Y = (1 / 0),\n }\n ```\n \n+This error indicates that the compiler was unable to sensibly evaluate a\n+constant expression that had to be evaluated. Attempting to divide by 0\n+or causing an integer overflow are two ways to induce this error.\n+\n Ensure that the expressions given can be evaluated as the desired integer type.\n See the FFI section of the Reference for more information about using a custom\n integer type:"}, {"sha": "fd5eca68e21fd5dc24be35b92c4fa4fccd0b2765", "filename": "src/librustc_error_codes/error_codes/E0081.md", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1,21 +1,23 @@\n-Enum discriminants are used to differentiate enum variants stored in memory.\n-This error indicates that the same value was used for two or more variants,\n-making them impossible to tell apart.\n+A discrimant value is present more than once.\n+\n+Erroneous code example:\n \n ```compile_fail,E0081\n-// Bad.\n enum Enum {\n     P = 3,\n-    X = 3,\n+    X = 3, // error!\n     Y = 5,\n }\n ```\n \n+Enum discriminants are used to differentiate enum variants stored in memory.\n+This error indicates that the same value was used for two or more variants,\n+making it impossible to distinguish them.\n+\n ```\n-// Good.\n enum Enum {\n     P,\n-    X = 3,\n+    X = 3, // ok!\n     Y = 5,\n }\n ```\n@@ -27,7 +29,7 @@ variants.\n ```compile_fail,E0081\n enum Bad {\n     X,\n-    Y = 0\n+    Y = 0, // error!\n }\n ```\n "}, {"sha": "03cb32803715e97eebbbfbda92d7ee3e93bed82b", "filename": "src/librustc_error_codes/error_codes/E0091.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1,5 +1,6 @@\n-You gave an unnecessary type or const parameter in a type alias. Erroneous\n-code example:\n+An unnecessary type or const parameter was given in a type alias.\n+\n+Erroneous code example:\n \n ```compile_fail,E0091\n type Foo<T> = u32; // error: type parameter `T` is unused"}, {"sha": "451913757482a87339b7d0d872a803fb5fa96f20", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -835,7 +835,7 @@ impl EmitterWriter {\n             return vec![];\n         }\n \n-        // Write the colunmn separator.\n+        // Write the column separator.\n         //\n         // After this we will have:\n         //\n@@ -906,7 +906,7 @@ impl EmitterWriter {\n         //   |  __________\n         //   | |    |\n         //   | |\n-        // 3 |\n+        // 3 | |\n         // 4 | | }\n         //   | |_\n         for &(pos, annotation) in &annotations_position {\n@@ -920,7 +920,7 @@ impl EmitterWriter {\n             if pos > 1 && (annotation.has_label() || annotation.takes_space()) {\n                 for p in line_offset + 1..=line_offset + pos {\n                     buffer.putc(p,\n-                                code_offset + annotation.start_col - margin.computed_left,\n+                                (code_offset + annotation.start_col).saturating_sub(left),\n                                 '|',\n                                 style);\n                 }"}, {"sha": "beb2465bd4a1a2ac5182667b2c8bdd9520f39dde", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1,4 +1,3 @@\n-use crate::queries::Queries;\n use crate::util;\n pub use crate::passes::BoxedResolver;\n \n@@ -36,7 +35,6 @@ pub struct Compiler {\n     pub(crate) input_path: Option<PathBuf>,\n     pub(crate) output_dir: Option<PathBuf>,\n     pub(crate) output_file: Option<PathBuf>,\n-    pub(crate) queries: Queries,\n     pub(crate) crate_name: Option<String>,\n     pub(crate) register_lints: Option<Box<dyn Fn(&Session, &mut lint::LintStore) + Send + Sync>>,\n     pub(crate) override_queries:\n@@ -169,7 +167,6 @@ pub fn run_compiler_in_existing_thread_pool<R>(\n         input_path: config.input_path,\n         output_dir: config.output_dir,\n         output_file: config.output_file,\n-        queries: Default::default(),\n         crate_name: config.crate_name,\n         register_lints: config.register_lints,\n         override_queries: config.override_queries,"}, {"sha": "e953a64f1906f952117bd90c1acb50a477b27f28", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 52, "deletions": 67, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -3,6 +3,7 @@ use crate::util;\n use crate::proc_macro_decls;\n \n use log::{info, warn, log_enabled};\n+use rustc::arena::Arena;\n use rustc::dep_graph::DepGraph;\n use rustc::hir;\n use rustc::hir::lowering::lower_crate;\n@@ -22,7 +23,7 @@ use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc_codegen_utils::link::filename_for_metadata;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n-use rustc_data_structures::sync::{Lrc, ParallelIterator, par_iter};\n+use rustc_data_structures::sync::{Lrc, Once, ParallelIterator, par_iter, WorkerLocal};\n use rustc_errors::PResult;\n use rustc_incremental;\n use rustc_mir as mir;\n@@ -739,93 +740,77 @@ pub fn default_provide_extern(providers: &mut ty::query::Providers<'_>) {\n     rustc_codegen_ssa::provide_extern(providers);\n }\n \n-declare_box_region_type!(\n-    pub BoxedGlobalCtxt,\n-    for('tcx),\n-    (&'tcx GlobalCtxt<'tcx>) -> ((), ())\n-);\n+pub struct QueryContext<'tcx>(&'tcx GlobalCtxt<'tcx>);\n \n-impl BoxedGlobalCtxt {\n+impl<'tcx> QueryContext<'tcx> {\n     pub fn enter<F, R>(&mut self, f: F) -> R\n     where\n-        F: for<'tcx> FnOnce(TyCtxt<'tcx>) -> R,\n+        F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        self.access(|gcx| ty::tls::enter_global(gcx, |tcx| f(tcx)))\n+        ty::tls::enter_global(self.0, |tcx| f(tcx))\n+    }\n+\n+    pub fn print_stats(&self) {\n+        self.0.queries.print_stats()\n     }\n }\n \n-pub fn create_global_ctxt(\n-    compiler: &Compiler,\n+pub fn create_global_ctxt<'tcx>(\n+    compiler: &'tcx Compiler,\n     lint_store: Lrc<lint::LintStore>,\n-    mut hir_forest: hir::map::Forest,\n+    hir_forest: &'tcx hir::map::Forest,\n     mut resolver_outputs: ResolverOutputs,\n     outputs: OutputFilenames,\n     crate_name: &str,\n-) -> BoxedGlobalCtxt {\n-    let sess = compiler.session().clone();\n-    let codegen_backend = compiler.codegen_backend().clone();\n-    let crate_name = crate_name.to_string();\n+    global_ctxt: &'tcx Once<GlobalCtxt<'tcx>>,\n+    all_arenas: &'tcx AllArenas,\n+    arena: &'tcx WorkerLocal<Arena<'tcx>>,\n+) -> QueryContext<'tcx> {\n+    let sess = &compiler.session();\n     let defs = mem::take(&mut resolver_outputs.definitions);\n-    let override_queries = compiler.override_queries;\n-\n-    let ((), result) = BoxedGlobalCtxt::new(static move || {\n-        let sess = &*sess;\n-\n-        let global_ctxt: Option<GlobalCtxt<'_>>;\n-        let arenas = AllArenas::new();\n-\n-        // Construct the HIR map.\n-        let hir_map = time(sess, \"indexing HIR\", || {\n-            hir::map::map_crate(sess, &*resolver_outputs.cstore, &mut hir_forest, &defs)\n-        });\n-\n-        let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n-            rustc_incremental::load_query_result_cache(sess)\n-        });\n \n-        let mut local_providers = ty::query::Providers::default();\n-        default_provide(&mut local_providers);\n-        codegen_backend.provide(&mut local_providers);\n+    // Construct the HIR map.\n+    let hir_map = time(sess, \"indexing HIR\", || {\n+        hir::map::map_crate(sess, &*resolver_outputs.cstore, &hir_forest, defs)\n+    });\n \n-        let mut extern_providers = local_providers;\n-        default_provide_extern(&mut extern_providers);\n-        codegen_backend.provide_extern(&mut extern_providers);\n+    let query_result_on_disk_cache = time(sess, \"load query result cache\", || {\n+        rustc_incremental::load_query_result_cache(sess)\n+    });\n \n-        if let Some(callback) = override_queries {\n-            callback(sess, &mut local_providers, &mut extern_providers);\n-        }\n+    let codegen_backend = compiler.codegen_backend();\n+    let mut local_providers = ty::query::Providers::default();\n+    default_provide(&mut local_providers);\n+    codegen_backend.provide(&mut local_providers);\n \n-        let gcx = TyCtxt::create_global_ctxt(\n-            sess,\n-            lint_store,\n-            local_providers,\n-            extern_providers,\n-            &arenas,\n-            resolver_outputs,\n-            hir_map,\n-            query_result_on_disk_cache,\n-            &crate_name,\n-            &outputs\n-        );\n+    let mut extern_providers = local_providers;\n+    default_provide_extern(&mut extern_providers);\n+    codegen_backend.provide_extern(&mut extern_providers);\n \n-        global_ctxt = Some(gcx);\n-        let gcx = global_ctxt.as_ref().unwrap();\n-\n-        ty::tls::enter_global(gcx, |tcx| {\n-            // Do some initialization of the DepGraph that can only be done with the\n-            // tcx available.\n-            time(tcx.sess, \"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n-        });\n+    if let Some(callback) = compiler.override_queries {\n+        callback(sess, &mut local_providers, &mut extern_providers);\n+    }\n \n-        yield BoxedGlobalCtxt::initial_yield(());\n-        box_region_allow_access!(for('tcx), (&'tcx GlobalCtxt<'tcx>), (gcx));\n+    let gcx = global_ctxt.init_locking(|| TyCtxt::create_global_ctxt(\n+        sess,\n+        lint_store,\n+        local_providers,\n+        extern_providers,\n+        &all_arenas,\n+        arena,\n+        resolver_outputs,\n+        hir_map,\n+        query_result_on_disk_cache,\n+        &crate_name,\n+        &outputs\n+    ));\n \n-        if sess.opts.debugging_opts.query_stats {\n-            gcx.queries.print_stats();\n-        }\n+    // Do some initialization of the DepGraph that can only be done with the tcx available.\n+    ty::tls::enter_global(&gcx, |tcx| {\n+        time(tcx.sess, \"dep graph tcx init\", || rustc_incremental::dep_graph_tcx_init(tcx));\n     });\n \n-    result\n+    QueryContext(gcx)\n }\n \n /// Runs the resolution, type-checking, region checking and other"}, {"sha": "6103d42c5dbcbb9e9ffed311f70bb393d2ca318e", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 142, "deletions": 69, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1,17 +1,19 @@\n use crate::interface::{Compiler, Result};\n-use crate::passes::{self, BoxedResolver, BoxedGlobalCtxt};\n+use crate::passes::{self, BoxedResolver, QueryContext};\n \n use rustc_incremental::DepGraphFuture;\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{Lrc, Once, WorkerLocal};\n+use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::util::common::{time, ErrorReported};\n+use rustc::arena::Arena;\n use rustc::hir;\n use rustc::lint;\n use rustc::session::Session;\n use rustc::lint::LintStore;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::ty::steal::Steal;\n-use rustc::ty::ResolverOutputs;\n+use rustc::ty::{AllArenas, ResolverOutputs, GlobalCtxt};\n use rustc::dep_graph::DepGraph;\n use std::cell::{Ref, RefMut, RefCell};\n use std::rc::Rc;\n@@ -44,13 +46,6 @@ impl<T> Query<T> {\n             .unwrap()\n     }\n \n-    /// Returns a stolen query result. Panics if there's already a result.\n-    pub fn give(&self, value: T) {\n-        let mut result = self.result.borrow_mut();\n-        assert!(result.is_none(), \"a result already exists\");\n-        *result = Some(Ok(value));\n-    }\n-\n     /// Borrows the query result using the RefCell. Panics if the result is stolen.\n     pub fn peek(&self) -> Ref<'_, T> {\n         Ref::map(self.result.borrow(), |r| {\n@@ -74,24 +69,54 @@ impl<T> Default for Query<T> {\n     }\n }\n \n-#[derive(Default)]\n-pub(crate) struct Queries {\n+pub struct Queries<'tcx> {\n+    compiler: &'tcx Compiler,\n+    gcx: Once<GlobalCtxt<'tcx>>,\n+\n+    all_arenas: AllArenas,\n+    arena: WorkerLocal<Arena<'tcx>>,\n+\n     dep_graph_future: Query<Option<DepGraphFuture>>,\n     parse: Query<ast::Crate>,\n     crate_name: Query<String>,\n     register_plugins: Query<(ast::Crate, Lrc<LintStore>)>,\n     expansion: Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>,\n     dep_graph: Query<DepGraph>,\n-    lower_to_hir: Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>,\n+    lower_to_hir: Query<(&'tcx hir::map::Forest, Steal<ResolverOutputs>)>,\n     prepare_outputs: Query<OutputFilenames>,\n-    global_ctxt: Query<BoxedGlobalCtxt>,\n+    global_ctxt: Query<QueryContext<'tcx>>,\n     ongoing_codegen: Query<Box<dyn Any>>,\n-    link: Query<()>,\n }\n \n-impl Compiler {\n+impl<'tcx> Queries<'tcx> {\n+    pub fn new(compiler: &'tcx Compiler) -> Queries<'tcx> {\n+        Queries {\n+            compiler,\n+            gcx: Once::new(),\n+            all_arenas: AllArenas::new(),\n+            arena: WorkerLocal::new(|_| Arena::default()),\n+            dep_graph_future: Default::default(),\n+            parse: Default::default(),\n+            crate_name: Default::default(),\n+            register_plugins: Default::default(),\n+            expansion: Default::default(),\n+            dep_graph: Default::default(),\n+            lower_to_hir: Default::default(),\n+            prepare_outputs: Default::default(),\n+            global_ctxt: Default::default(),\n+            ongoing_codegen: Default::default(),\n+        }\n+    }\n+\n+    fn session(&self) -> &Lrc<Session> {\n+        &self.compiler.sess\n+    }\n+    fn codegen_backend(&self) -> &Lrc<Box<dyn CodegenBackend>> {\n+        &self.compiler.codegen_backend()\n+    }\n+\n     pub fn dep_graph_future(&self) -> Result<&Query<Option<DepGraphFuture>>> {\n-        self.queries.dep_graph_future.compute(|| {\n+        self.dep_graph_future.compute(|| {\n             Ok(if self.session().opts.build_dep_graph() {\n                 Some(rustc_incremental::load_dep_graph(self.session()))\n             } else {\n@@ -101,8 +126,8 @@ impl Compiler {\n     }\n \n     pub fn parse(&self) -> Result<&Query<ast::Crate>> {\n-        self.queries.parse.compute(|| {\n-            passes::parse(self.session(), &self.input).map_err(\n+        self.parse.compute(|| {\n+            passes::parse(self.session(), &self.compiler.input).map_err(\n                 |mut parse_error| {\n                     parse_error.emit();\n                     ErrorReported\n@@ -112,15 +137,15 @@ impl Compiler {\n     }\n \n     pub fn register_plugins(&self) -> Result<&Query<(ast::Crate, Lrc<LintStore>)>> {\n-        self.queries.register_plugins.compute(|| {\n+        self.register_plugins.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let krate = self.parse()?.take();\n \n             let empty: &(dyn Fn(&Session, &mut lint::LintStore) + Sync + Send) = &|_, _| {};\n             let result = passes::register_plugins(\n                 self.session(),\n                 &*self.codegen_backend().metadata_loader(),\n-                self.register_lints\n+                self.compiler.register_lints\n                     .as_ref()\n                     .map(|p| &**p)\n                     .unwrap_or_else(|| empty),\n@@ -140,16 +165,16 @@ impl Compiler {\n     }\n \n     pub fn crate_name(&self) -> Result<&Query<String>> {\n-        self.queries.crate_name.compute(|| {\n-            Ok(match self.crate_name {\n+        self.crate_name.compute(|| {\n+            Ok(match self.compiler.crate_name {\n                 Some(ref crate_name) => crate_name.clone(),\n                 None => {\n                     let parse_result = self.parse()?;\n                     let krate = parse_result.peek();\n                     rustc_codegen_utils::link::find_crate_name(\n                         Some(self.session()),\n                         &krate.attrs,\n-                        &self.input\n+                        &self.compiler.input\n                     )\n                 }\n             })\n@@ -159,11 +184,11 @@ impl Compiler {\n     pub fn expansion(\n         &self\n     ) -> Result<&Query<(ast::Crate, Steal<Rc<RefCell<BoxedResolver>>>, Lrc<LintStore>)>> {\n-        self.queries.expansion.compute(|| {\n+        self.expansion.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let (krate, lint_store) = self.register_plugins()?.take();\n             passes::configure_and_expand(\n-                self.sess.clone(),\n+                self.session().clone(),\n                 lint_store.clone(),\n                 self.codegen_backend().metadata_loader(),\n                 krate,\n@@ -175,7 +200,7 @@ impl Compiler {\n     }\n \n     pub fn dep_graph(&self) -> Result<&Query<DepGraph>> {\n-        self.queries.dep_graph.compute(|| {\n+        self.dep_graph.compute(|| {\n             Ok(match self.dep_graph_future()?.take() {\n                 None => DepGraph::new_disabled(),\n                 Some(future) => {\n@@ -192,57 +217,63 @@ impl Compiler {\n     }\n \n     pub fn lower_to_hir(\n-        &self,\n-    ) -> Result<&Query<(Steal<hir::map::Forest>, Steal<ResolverOutputs>)>> {\n-        self.queries.lower_to_hir.compute(|| {\n+        &'tcx self,\n+    ) -> Result<&Query<(&'tcx hir::map::Forest, Steal<ResolverOutputs>)>> {\n+        self.lower_to_hir.compute(|| {\n             let expansion_result = self.expansion()?;\n             let peeked = expansion_result.peek();\n             let krate = &peeked.0;\n             let resolver = peeked.1.steal();\n             let lint_store = &peeked.2;\n-            let hir = Steal::new(resolver.borrow_mut().access(|resolver| {\n+            let hir = resolver.borrow_mut().access(|resolver| {\n                 passes::lower_to_hir(\n                     self.session(),\n                     lint_store,\n                     resolver,\n                     &*self.dep_graph()?.peek(),\n                     &krate\n                 )\n-            })?);\n+            })?;\n+            let hir = self.arena.alloc(hir);\n             Ok((hir, Steal::new(BoxedResolver::to_resolver_outputs(resolver))))\n         })\n     }\n \n     pub fn prepare_outputs(&self) -> Result<&Query<OutputFilenames>> {\n-        self.queries.prepare_outputs.compute(|| {\n+        self.prepare_outputs.compute(|| {\n             let expansion_result = self.expansion()?;\n             let (krate, boxed_resolver, _) = &*expansion_result.peek();\n             let crate_name = self.crate_name()?;\n             let crate_name = crate_name.peek();\n-            passes::prepare_outputs(self.session(), self, &krate, &boxed_resolver, &crate_name)\n+            passes::prepare_outputs(\n+                self.session(), self.compiler, &krate, &boxed_resolver, &crate_name\n+            )\n         })\n     }\n \n-    pub fn global_ctxt(&self) -> Result<&Query<BoxedGlobalCtxt>> {\n-        self.queries.global_ctxt.compute(|| {\n+    pub fn global_ctxt(&'tcx self) -> Result<&Query<QueryContext<'tcx>>> {\n+        self.global_ctxt.compute(|| {\n             let crate_name = self.crate_name()?.peek().clone();\n             let outputs = self.prepare_outputs()?.peek().clone();\n             let lint_store = self.expansion()?.peek().2.clone();\n-            let hir = self.lower_to_hir()?;\n-            let hir = hir.peek();\n-            let (hir_forest, resolver_outputs) = &*hir;\n+            let hir = self.lower_to_hir()?.peek();\n+            let (ref hir_forest, ref resolver_outputs) = &*hir;\n             Ok(passes::create_global_ctxt(\n-                self,\n+                self.compiler,\n                 lint_store,\n-                hir_forest.steal(),\n+                hir_forest,\n                 resolver_outputs.steal(),\n                 outputs,\n-                &crate_name))\n+                &crate_name,\n+                &self.gcx,\n+                &self.all_arenas,\n+                &self.arena,\n+            ))\n         })\n     }\n \n-    pub fn ongoing_codegen(&self) -> Result<&Query<Box<dyn Any>>> {\n-        self.queries.ongoing_codegen.compute(|| {\n+    pub fn ongoing_codegen(&'tcx self) -> Result<&Query<Box<dyn Any>>> {\n+        self.ongoing_codegen.compute(|| {\n             let outputs = self.prepare_outputs()?;\n             self.global_ctxt()?.peek_mut().enter(|tcx| {\n                 tcx.analysis(LOCAL_CRATE).ok();\n@@ -259,47 +290,89 @@ impl Compiler {\n         })\n     }\n \n-    pub fn link(&self) -> Result<&Query<()>> {\n-        self.queries.link.compute(|| {\n-            let sess = self.session();\n-\n-            let ongoing_codegen = self.ongoing_codegen()?.take();\n+    pub fn linker(&'tcx self) -> Result<Linker> {\n+        let dep_graph = self.dep_graph()?;\n+        let prepare_outputs = self.prepare_outputs()?;\n+        let ongoing_codegen = self.ongoing_codegen()?;\n \n-            self.codegen_backend().join_codegen_and_link(\n-                ongoing_codegen,\n-                sess,\n-                &*self.dep_graph()?.peek(),\n-                &*self.prepare_outputs()?.peek(),\n-            ).map_err(|_| ErrorReported)?;\n+        let sess = self.session().clone();\n+        let codegen_backend = self.codegen_backend().clone();\n \n-            Ok(())\n+        Ok(Linker {\n+            sess,\n+            dep_graph: dep_graph.peek().clone(),\n+            prepare_outputs: prepare_outputs.take(),\n+            ongoing_codegen: ongoing_codegen.take(),\n+            codegen_backend,\n         })\n     }\n+}\n+\n+pub struct Linker {\n+    sess: Lrc<Session>,\n+    dep_graph: DepGraph,\n+    prepare_outputs: OutputFilenames,\n+    ongoing_codegen: Box<dyn Any>,\n+    codegen_backend: Lrc<Box<dyn CodegenBackend>>,\n+}\n+\n+impl Linker {\n+    pub fn link(self) -> Result<()> {\n+        self.codegen_backend.join_codegen_and_link(\n+            self.ongoing_codegen,\n+            &self.sess,\n+            &self.dep_graph,\n+            &self.prepare_outputs,\n+        ).map_err(|_| ErrorReported)\n+    }\n+}\n+\n+impl Compiler {\n+    pub fn enter<F, T>(&self, f: F) -> T\n+        where F: for<'tcx> FnOnce(&'tcx Queries<'tcx>) -> T\n+    {\n+        let queries = Queries::new(&self);\n+        let ret = f(&queries);\n+\n+        if self.session().opts.debugging_opts.query_stats {\n+            if let Ok(gcx) = queries.global_ctxt() {\n+                gcx.peek().print_stats();\n+            }\n+        }\n+\n+        ret\n+    }\n \n     // This method is different to all the other methods in `Compiler` because\n     // it lacks a `Queries` entry. It's also not currently used. It does serve\n     // as an example of how `Compiler` can be used, with additional steps added\n     // between some passes. And see `rustc_driver::run_compiler` for a more\n     // complex example.\n     pub fn compile(&self) -> Result<()> {\n-        self.prepare_outputs()?;\n+        let linker = self.enter(|queries| {\n+            queries.prepare_outputs()?;\n \n-        if self.session().opts.output_types.contains_key(&OutputType::DepInfo)\n-            && self.session().opts.output_types.len() == 1\n-        {\n-            return Ok(())\n-        }\n+            if self.session().opts.output_types.contains_key(&OutputType::DepInfo)\n+                && self.session().opts.output_types.len() == 1\n+            {\n+                return Ok(None)\n+            }\n+\n+            queries.global_ctxt()?;\n \n-        self.global_ctxt()?;\n+            // Drop AST after creating GlobalCtxt to free memory.\n+            mem::drop(queries.expansion()?.take());\n \n-        // Drop AST after creating GlobalCtxt to free memory.\n-        mem::drop(self.expansion()?.take());\n+            queries.ongoing_codegen()?;\n \n-        self.ongoing_codegen()?;\n+            let linker = queries.linker()?;\n+            Ok(Some(linker))\n+        })?;\n \n-        // Drop GlobalCtxt after starting codegen to free memory.\n-        mem::drop(self.global_ctxt()?.take());\n+        if let Some(linker) = linker {\n+            linker.link()?\n+        }\n \n-        self.link().map(|_| ())\n+        Ok(())\n     }\n }"}, {"sha": "8c852854be1f99f0c697c875ed85eea403c650e1", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -933,14 +933,7 @@ fn convert_path_expr<'a, 'tcx>(\n         // We encode uses of statics as a `*&STATIC` where the `&STATIC` part is\n         // a constant reference (or constant raw pointer for `static mut`) in MIR\n         Res::Def(DefKind::Static, id) => {\n-            let ty = cx.tcx.type_of(id);\n-            let ty = if cx.tcx.is_mutable_static(id) {\n-                cx.tcx.mk_mut_ptr(ty)\n-            } else if cx.tcx.is_foreign_item(id) {\n-                cx.tcx.mk_imm_ptr(ty)\n-            } else {\n-                cx.tcx.mk_imm_ref(cx.tcx.lifetimes.re_static, ty)\n-            };\n+            let ty = cx.tcx.static_ptr_ty(id);\n             let ptr = cx.tcx.alloc_map.lock().create_static_alloc(id);\n             let temp_lifetime = cx.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n             ExprKind::Deref { arg: Expr {"}, {"sha": "f9cb40ffe9446eac23b7bd967283ab11a29a130f", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -100,7 +100,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>>(\n     // This match is just a canary for future changes to `MemoryKind`, which most likely need\n     // changes in this function.\n     match kind {\n-        MemoryKind::Stack | MemoryKind::Vtable => {},\n+        MemoryKind::Stack | MemoryKind::Vtable | MemoryKind::CallerLocation => {},\n     }\n     // Set allocation mutability as appropriate. This is used by LLVM to put things into\n     // read-only memory, and also by Miri when evluating other constants/statics that"}, {"sha": "9e07a3f1072c1c5d18a8bf4702b9fe997758d79f", "filename": "src/librustc_mir/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -28,7 +28,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let file = Scalar::Ptr(self.tag_static_base_pointer(file_ptr));\n         let file_len = Scalar::from_uint(filename.as_str().len() as u128, ptr_size);\n \n-        let location = self.allocate(loc_layout, MemoryKind::Stack);\n+        let location = self.allocate(loc_layout, MemoryKind::CallerLocation);\n \n         let file_out = self.mplace_field(location, 0)?;\n         let file_ptr_out = self.force_ptr(self.mplace_field(file_out, 0)?.ptr)?;"}, {"sha": "a8011f7abb14fe41e6699b0e6499f4091c6cad6c", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -24,11 +24,13 @@ use super::{\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n pub enum MemoryKind<T> {\n-    /// Error if deallocated except during a stack pop\n+    /// Stack memory. Error if deallocated except during a stack pop.\n     Stack,\n-    /// Error if ever deallocated\n+    /// Memory backing vtables. Error if ever deallocated.\n     Vtable,\n-    /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n+    /// Memory allocated by `caller_location` intrinsic. Error if ever deallocated.\n+    CallerLocation,\n+    /// Additional memory kinds a machine wishes to distinguish from the builtin ones.\n     Machine(T),\n }\n \n@@ -38,6 +40,7 @@ impl<T: MayLeak> MayLeak for MemoryKind<T> {\n         match self {\n             MemoryKind::Stack => false,\n             MemoryKind::Vtable => true,\n+            MemoryKind::CallerLocation => true,\n             MemoryKind::Machine(k) => k.may_leak()\n         }\n     }\n@@ -719,6 +722,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     let extra = match kind {\n                         MemoryKind::Stack => \" (stack)\".to_owned(),\n                         MemoryKind::Vtable => \" (vtable)\".to_owned(),\n+                        MemoryKind::CallerLocation => \" (caller_location)\".to_owned(),\n                         MemoryKind::Machine(m) => format!(\" ({:?})\", m),\n                     };\n                     self.dump_alloc_helper("}, {"sha": "fcbc2a3301ad1ef82849fecb35563460f41c89a4", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -84,7 +84,7 @@ where\n {\n     fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n         let TraitRef { def_id, substs } = trait_ref;\n-        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) ||\n+        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref.print_only_trait_path()) ||\n         (!self.def_id_visitor.shallow() && substs.visit_with(self))\n     }\n "}, {"sha": "fdbf729a773aa2520e4d8d45aa5c5bb7c213b7ba", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -1149,8 +1149,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let candidates = traits::supertraits(tcx, trait_ref).filter(|r| {\n                 self.trait_defines_associated_type_named(r.def_id(), binding.item_name)\n             });\n-            self.one_bound_for_assoc_type(candidates, &trait_ref.to_string(),\n-                                          binding.item_name, binding.span)\n+            self.one_bound_for_assoc_type(\n+                candidates,\n+                &trait_ref.print_only_trait_path().to_string(),\n+                binding.item_name,\n+                binding.span\n+            )\n         }?;\n \n         let (assoc_ident, def_scope) =\n@@ -1589,12 +1593,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if let Some(span) = bound_span {\n                     err.span_label(span, format!(\"ambiguous `{}` from `{}`\",\n                                                  assoc_name,\n-                                                 bound));\n+                                                 bound.print_only_trait_path()));\n                 } else {\n                     span_note!(&mut err, span,\n                                \"associated type `{}` could derive from `{}`\",\n                                ty_param_name,\n-                               bound);\n+                               bound.print_only_trait_path());\n                 }\n             }\n             err.emit();"}, {"sha": "fcf6b22f74f3c01e49c12fa836d7e3d5f7189cc5", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -185,6 +185,8 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n+\n         match &expr.kind {\n             ExprKind::Call(callee, args) => match &callee.kind {\n                 ExprKind::Path(qpath) => {\n@@ -210,13 +212,20 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                 }\n                 _ => intravisit::walk_expr(self, expr),\n             }\n+            ExprKind::Path(qpath) => {\n+                let res = self.fcx.tables.borrow().qpath_res(qpath, expr.hir_id);\n+                if let Res::Def(DefKind::Static, def_id) = res {\n+                    // Statics are lowered to temporary references or\n+                    // pointers in MIR, so record that type.\n+                    let ptr_ty = self.fcx.tcx.static_ptr_ty(def_id);\n+                    self.record(ptr_ty, scope, Some(expr), expr.span);\n+                }\n+            }\n             _ => intravisit::walk_expr(self, expr),\n         }\n \n         self.expr_count += 1;\n \n-        let scope = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n-\n         // If there are adjustments, then record the final type --\n         // this is the actual value that is being produced.\n         if let Some(adjusted_ty) = self.fcx.tables.borrow().expr_ty_adjusted_opt(expr) {"}, {"sha": "f4b53b4d10604c97e2bec40acce6e9a1887645d1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -502,7 +502,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 if !unsatisfied_predicates.is_empty() {\n                     let mut bound_list = unsatisfied_predicates.iter()\n-                        .map(|p| format!(\"`{} : {}`\", p.self_ty(), p))\n+                        .map(|p| format!(\"`{} : {}`\", p.self_ty(), p.print_only_trait_path()))\n                         .collect::<Vec<_>>();\n                     bound_list.sort();\n                     bound_list.dedup();  // #35677"}, {"sha": "3a4a4a50bf27318f85b0fb844d8a48cd8181eef8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -2002,7 +2002,7 @@ fn check_impl_items_against_trait<'tcx>(\n                              \"item `{}` is an associated const, \\\n                               which doesn't match its trait `{}`\",\n                              ty_impl_item.ident,\n-                             impl_trait_ref);\n+                             impl_trait_ref.print_only_trait_path());\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          // We can only get the spans from local trait definition\n                          // Same for E0324 and E0325\n@@ -2026,7 +2026,7 @@ fn check_impl_items_against_trait<'tcx>(\n                             \"item `{}` is an associated method, \\\n                              which doesn't match its trait `{}`\",\n                             ty_impl_item.ident,\n-                            impl_trait_ref);\n+                            impl_trait_ref.print_only_trait_path());\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, \"item in trait\");\n@@ -2045,7 +2045,7 @@ fn check_impl_items_against_trait<'tcx>(\n                             \"item `{}` is an associated type, \\\n                              which doesn't match its trait `{}`\",\n                             ty_impl_item.ident,\n-                            impl_trait_ref);\n+                            impl_trait_ref.print_only_trait_path());\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n                             err.span_label(trait_span, \"item in trait\");"}, {"sha": "650e15ea8a7c864c206841f5c353e47c38b27d02", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -35,15 +35,15 @@ impl UnsafetyChecker<'tcx> {\n                               item.span,\n                               E0199,\n                               \"implementing the trait `{}` is not unsafe\",\n-                              trait_ref);\n+                              trait_ref.print_only_trait_path());\n                 }\n \n                 (Unsafety::Unsafe, _, Unsafety::Normal, hir::ImplPolarity::Positive) => {\n                     span_err!(self.tcx.sess,\n                               item.span,\n                               E0200,\n                               \"the trait `{}` requires an `unsafe impl` declaration\",\n-                              trait_ref);\n+                              trait_ref.print_only_trait_path());\n                 }\n \n                 (Unsafety::Normal, Some(attr_name), Unsafety::Normal,"}, {"sha": "7d1f89079f8081aa85dd0d28255df6d4f3361bd4", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -343,25 +343,26 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         registry: rustc_driver::diagnostics_registry(),\n     };\n \n-    interface::run_compiler_in_existing_thread_pool(config, |compiler| {\n+    interface::run_compiler_in_existing_thread_pool(config, |compiler| compiler.enter(|queries| {\n         let sess = compiler.session();\n \n         // We need to hold on to the complete resolver, so we cause everything to be\n         // cloned for the analysis passes to use. Suboptimal, but necessary in the\n         // current architecture.\n         let resolver = {\n-            let parts = abort_on_err(compiler.expansion(), sess).peek();\n+            let parts = abort_on_err(queries.expansion(), sess).peek();\n             let resolver = parts.1.borrow();\n \n             // Before we actually clone it, let's force all the extern'd crates to\n             // actually be loaded, just in case they're only referred to inside\n             // intra-doc-links\n             resolver.borrow_mut().access(|resolver| {\n                 for extern_name in &extern_names {\n-                    resolver.resolve_str_path_error(DUMMY_SP, extern_name, TypeNS, CRATE_NODE_ID)\n-                        .unwrap_or_else(\n-                            |()| panic!(\"Unable to resolve external crate {}\", extern_name)\n-                        );\n+                    resolver.resolve_str_path_error(\n+                        DUMMY_SP, extern_name, TypeNS, CRATE_NODE_ID\n+                    ).unwrap_or_else(\n+                        |()| panic!(\"Unable to resolve external crate {}\", extern_name)\n+                    );\n                 }\n             });\n \n@@ -373,7 +374,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n             sess.fatal(\"Compilation failed, aborting rustdoc\");\n         }\n \n-        let mut global_ctxt = abort_on_err(compiler.global_ctxt(), sess).take();\n+        let mut global_ctxt = abort_on_err(queries.global_ctxt(), sess).take();\n \n         global_ctxt.enter(|tcx| {\n             tcx.analysis(LOCAL_CRATE).ok();\n@@ -447,8 +448,8 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                         },\n                         sym::plugins => {\n                             report_deprecated_attr(\"plugins = \\\"...\\\"\", diag);\n-                            eprintln!(\"WARNING: `#![doc(plugins = \\\"...\\\")]` no longer functions; \\\n-                                      see CVE-2018-1000622\");\n+                            eprintln!(\"WARNING: `#![doc(plugins = \\\"...\\\")]` \\\n+                                      no longer functions; see CVE-2018-1000622\");\n                             continue\n                         },\n                         _ => continue,\n@@ -486,7 +487,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n             (krate, ctxt.renderinfo.into_inner(), render_options)\n         })\n-    })\n+    }))\n }\n \n /// `DefId` or parameter index (`ty::ParamTy.index`) of a synthetic type parameter"}, {"sha": "d09eb0b2fc2639b059eaa6466263c513bb267794", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -85,14 +85,14 @@ pub fn run(options: Options) -> i32 {\n     let mut test_args = options.test_args.clone();\n     let display_warnings = options.display_warnings;\n \n-    let tests = interface::run_compiler(config, |compiler| -> Result<_, ErrorReported> {\n-        let lower_to_hir = compiler.lower_to_hir()?;\n+    let tests = interface::run_compiler(config, |compiler| compiler.enter(|queries| {\n+        let lower_to_hir = queries.lower_to_hir()?;\n \n-        let mut opts = scrape_test_config(lower_to_hir.peek().0.borrow().krate());\n+        let mut opts = scrape_test_config(lower_to_hir.peek().0.krate());\n         opts.display_warnings |= options.display_warnings;\n         let enable_per_target_ignores = options.enable_per_target_ignores;\n         let mut collector = Collector::new(\n-            compiler.crate_name()?.peek().to_string(),\n+            queries.crate_name()?.peek().to_string(),\n             options,\n             false,\n             opts,\n@@ -101,7 +101,8 @@ pub fn run(options: Options) -> i32 {\n             enable_per_target_ignores,\n         );\n \n-        let mut global_ctxt = compiler.global_ctxt()?.take();\n+        let mut global_ctxt = queries.global_ctxt()?.take();\n+\n         global_ctxt.enter(|tcx| {\n             let krate = tcx.hir().krate();\n             let mut hir_collector = HirCollector {\n@@ -116,8 +117,9 @@ pub fn run(options: Options) -> i32 {\n             });\n         });\n \n-        Ok(collector.tests)\n-    }).expect(\"compiler aborted in rustdoc!\");\n+        let ret : Result<_, ErrorReported> = Ok(collector.tests);\n+        ret\n+    })).expect(\"compiler aborted in rustdoc!\");\n \n     test_args.insert(0, \"rustdoctest\".to_string());\n "}, {"sha": "cd024068d2d47bfeda8c2cb7e43954280c097917", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -425,5 +425,5 @@ pub fn catch_unwind<F: FnOnce() -> R + UnwindSafe, R>(f: F) -> Result<R> {\n /// ```\n #[stable(feature = \"resume_unwind\", since = \"1.9.0\")]\n pub fn resume_unwind(payload: Box<dyn Any + Send>) -> ! {\n-    panicking::update_count_then_panic(payload)\n+    panicking::rust_panic_without_hook(payload)\n }"}, {"sha": "c028ddcd676fca021d548399a18aaa59bf6a33ce", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -20,6 +20,7 @@ use crate::sys_common::rwlock::RWLock;\n use crate::sys_common::{thread_info, util};\n use crate::sys_common::backtrace::{self, RustBacktrace};\n use crate::thread;\n+use crate::process;\n \n #[cfg(not(test))]\n use crate::io::set_panic;\n@@ -46,6 +47,8 @@ extern {\n                                 vtable_ptr: *mut usize) -> u32;\n \n     /// `payload` is actually a `*mut &mut dyn BoxMeUp` but that would cause FFI warnings.\n+    /// It cannot be `Box<dyn BoxMeUp>` because the other end of this call does not depend\n+    /// on liballoc, and thus cannot use `Box`.\n     #[unwind(allowed)]\n     fn __rust_start_panic(payload: usize) -> u32;\n }\n@@ -296,14 +299,6 @@ pub fn panicking() -> bool {\n     update_panic_count(0) != 0\n }\n \n-/// Entry point of panic from the libcore crate (`panic_impl` lang item).\n-#[cfg(not(test))]\n-#[panic_handler]\n-#[unwind(allowed)]\n-pub fn rust_begin_panic(info: &PanicInfo<'_>) -> ! {\n-    continue_panic_fmt(&info)\n-}\n-\n /// The entry point for panicking with a formatted message.\n ///\n /// This is designed to reduce the amount of code required at the call\n@@ -324,13 +319,17 @@ pub fn begin_panic_fmt(msg: &fmt::Arguments<'_>,\n         unsafe { intrinsics::abort() }\n     }\n \n+    // Just package everything into a `PanicInfo` and continue like libcore panics.\n     let (file, line, col) = *file_line_col;\n     let location = Location::internal_constructor(file, line, col);\n     let info = PanicInfo::internal_constructor(Some(msg), &location);\n-    continue_panic_fmt(&info)\n+    begin_panic_handler(&info)\n }\n \n-fn continue_panic_fmt(info: &PanicInfo<'_>) -> ! {\n+/// Entry point of panics from the libcore crate (`panic_impl` lang item).\n+#[cfg_attr(not(test), panic_handler)]\n+#[unwind(allowed)]\n+pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n     struct PanicPayload<'a> {\n         inner: &'a fmt::Arguments<'a>,\n         string: Option<String>,\n@@ -345,6 +344,7 @@ fn continue_panic_fmt(info: &PanicInfo<'_>) -> ! {\n             use crate::fmt::Write;\n \n             let inner = self.inner;\n+            // Lazily, the first time this gets called, run the actual string formatting.\n             self.string.get_or_insert_with(|| {\n                 let mut s = String::new();\n                 drop(s.write_fmt(*inner));\n@@ -354,7 +354,7 @@ fn continue_panic_fmt(info: &PanicInfo<'_>) -> ! {\n     }\n \n     unsafe impl<'a> BoxMeUp for PanicPayload<'a> {\n-        fn box_me_up(&mut self) -> *mut (dyn Any + Send) {\n+        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n             let contents = mem::take(self.fill());\n             Box::into_raw(Box::new(contents))\n         }\n@@ -378,7 +378,9 @@ fn continue_panic_fmt(info: &PanicInfo<'_>) -> ! {\n         &file_line_col);\n }\n \n-/// This is the entry point of panicking for panic!() and assert!().\n+/// This is the entry point of panicking for the non-format-string variants of\n+/// panic!() and assert!(). In particular, this is the only entry point that supports\n+/// arbitrary payloads, not just format strings.\n #[unstable(feature = \"libstd_sys_internals\",\n            reason = \"used by the panic! macro\",\n            issue = \"0\")]\n@@ -412,18 +414,18 @@ pub fn begin_panic<M: Any + Send>(msg: M, file_line_col: &(&'static str, u32, u3\n     }\n \n     unsafe impl<A: Send + 'static> BoxMeUp for PanicPayload<A> {\n-        fn box_me_up(&mut self) -> *mut (dyn Any + Send) {\n+        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n             let data = match self.inner.take() {\n                 Some(a) => Box::new(a) as Box<dyn Any + Send>,\n-                None => Box::new(()),\n+                None => process::abort(),\n             };\n             Box::into_raw(data)\n         }\n \n         fn get(&mut self) -> &(dyn Any + Send) {\n             match self.inner {\n                 Some(ref a) => a,\n-                None => &(),\n+                None => process::abort(),\n             }\n         }\n     }\n@@ -457,9 +459,12 @@ fn rust_panic_with_hook(payload: &mut dyn BoxMeUp,\n         let mut info = PanicInfo::internal_constructor(message, &location);\n         HOOK_LOCK.read();\n         match HOOK {\n-            // Some platforms know that printing to stderr won't ever actually\n+            // Some platforms (like wasm) know that printing to stderr won't ever actually\n             // print anything, and if that's the case we can skip the default\n-            // hook.\n+            // hook. Since string formatting happens lazily when calling `payload`\n+            // methods, this means we avoid formatting the string at all!\n+            // (The panic runtime might still call `payload.take_box()` though and trigger\n+            // formatting.)\n             Hook::Default if panic_output().is_none() => {}\n             Hook::Default => {\n                 info.set_payload(payload.get());\n@@ -486,14 +491,15 @@ fn rust_panic_with_hook(payload: &mut dyn BoxMeUp,\n     rust_panic(payload)\n }\n \n-/// Shim around rust_panic. Called by resume_unwind.\n-pub fn update_count_then_panic(msg: Box<dyn Any + Send>) -> ! {\n+/// This is the entry point for `resume_unwind`.\n+/// It just forwards the payload to the panic runtime.\n+pub fn rust_panic_without_hook(payload: Box<dyn Any + Send>) -> ! {\n     update_panic_count(1);\n \n     struct RewrapBox(Box<dyn Any + Send>);\n \n     unsafe impl BoxMeUp for RewrapBox {\n-        fn box_me_up(&mut self) -> *mut (dyn Any + Send) {\n+        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n             Box::into_raw(mem::replace(&mut self.0, Box::new(())))\n         }\n \n@@ -502,7 +508,7 @@ pub fn update_count_then_panic(msg: Box<dyn Any + Send>) -> ! {\n         }\n     }\n \n-    rust_panic(&mut RewrapBox(msg))\n+    rust_panic(&mut RewrapBox(payload))\n }\n \n /// An unmangled function (through `rustc_std_internal_symbol`) on which to slap"}, {"sha": "62a66aefd2deb2854d052d709b603908b9b1fc5a", "filename": "src/test/run-make-fulldeps/issue-19371/foo.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-19371%2Ffoo.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -66,6 +66,11 @@ fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n \n     interface::run_compiler(config, |compiler| {\n         // This runs all the passes prior to linking, too.\n-        compiler.link().ok();\n+        let linker = compiler.enter(|queries| {\n+            queries.linker()\n+        });\n+        if let Ok(linker) = linker {\n+            linker.link();\n+        }\n     });\n }"}, {"sha": "f0609713b4ddcb652f97d1c7c05e4c4b815761d8", "filename": "src/test/ui/async-await/issues/issue-66695-static-refs.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-66695-static-refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-66695-static-refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-66695-static-refs.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -0,0 +1,24 @@\n+// build-pass\n+// edition:2018\n+\n+static A: [i32; 5] = [1, 2, 3, 4, 5];\n+\n+async fn fun() {\n+    let u = A[async { 1 }.await];\n+    match A {\n+        i if async { true }.await => (),\n+        _ => (),\n+    }\n+}\n+\n+fn main() {\n+    async {\n+        let u = A[async { 1 }.await];\n+    };\n+    async {\n+        match A {\n+            i if async { true }.await => (),\n+            _ => (),\n+        }\n+    };\n+}"}, {"sha": "23b11593bb5d6444354972faea766d580765247f", "filename": "src/test/ui/generator/static-reference-across-yield.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fgenerator%2Fstatic-reference-across-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fgenerator%2Fstatic-reference-across-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fstatic-reference-across-yield.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -0,0 +1,16 @@\n+// build-pass\n+#![feature(generators)]\n+\n+static A: [i32; 5] = [1, 2, 3, 4, 5];\n+\n+fn main() {\n+    static || {\n+        let u = A[{yield; 1}];\n+    };\n+    static || {\n+        match A {\n+            i if { yield; true } => (),\n+            _ => (),\n+        }\n+    };\n+}"}, {"sha": "cc94680530cf253645450c2e273d23f7bb010b59", "filename": "src/test/ui/terminal-width/non-1-width-unicode-multiline-label.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.rs?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -0,0 +1,7 @@\n+// ignore-tidy-linelength\n+\n+fn main() {\n+    let unicode_is_fun = \"\u0601\u2031\u0bb9\u0bf8\u0bf5\ua9c4.\u102a\ua9c5\u2e3b\ud808\ude19\ud809\udc2b\ufdfd\ud808\udf04\ud808\ude1f\ud808\udf7c\ud808\udc4e\ud808\udc31\ud808\udf27\ud808\udd43 \ud808\ude13\ud808\udf59\ud808\ude8e\ud808\udd21\ud808\udd4c\ud808\udc4f\ud808\udc30\ud809\udc2a\ud809\udc29\ud808\ude19\ud809\udc2b\ud869\udea5\";\n+    let _ = \"\u0f00\u0f01\u0f02\u0f03\u0f04\u0f05\u0f06\u0f07\u0f08\u0f09\u0f0a\u0f0b\u0f0c\u0f0d\u0f0e\u0f0f\u0f10\u0f11\u0f12\u0f13\u0f14\u0f15\u0f16\u0f17\u0f18\u0f19\u0f1a\u0f1b\u0f1c\u0f1d\u0f1e\u0f1f\u0f20\u0f21\u0f22\u0f23\u0f24\u0f25\u0f26\u0f27\u0f28\u0f29\u0f2a\u0f2b\u0f2c\u0f2d\u0f2e\u0f2f\u0f30\u0f31\u0f32\u0f33\u0f34\u0f35\u0f36\u0f37\u0f38\u0f39\u0f3a\u0f3b\u0f3c\u0f3d\u0f3e\u0f3f\u0f40\u0f41\u0f42\u0f43\u0f44\u0f45\u0f46\u0f47\u0f48\u0f49\u0f4a\u0f4b\u0f4c\u0f4d\u0f4e\u0f4f\u0f50\u0f51\u0f52\u0f53\u0f54\u0f55\u0f56\u0f57\u0f58\u0f59\u0f5a\u0f5b\u0f5c\u0f5d\u0f5e\u0f5f\u0f60\u0f61\u0f62\u0f63\u0f64\u0f65\u0f66\u0f67\u0f68\u0f69\u0f6a\u0f6b\u0f6c\u0f6d\u0f6e\u0f6f\u0f70\u0f71\u0f72\u0f73\u0f74\u0f75\u0f76\u0f77\u0f78\u0f79\u0f7a\u0f7b\u0f7c\u0f7d\u0f7e\u0f7f\u0f80\u0f81\u0f82\u0f83\u0f84\u0f85\u0f86\u0f87\u0f88\u0f89\u0f8a\u0f8b\u0f8c\u0f8d\u0f8e\u0f8f\u0f90\u0f91\u0f92\u0f93\u0f94\u0f95\u0f96\u0f97\u0f98\u0f99\u0f9a\u0f9b\u0f9c\u0f9d\u0f9e\u0f9f\u0fa0\u0fa1\u0fa2\u0fa3\u0fa4\u0fa5\u0fa6\u0fa7\u0fa8\u0fa9\u0faa\u0fab\u0fac\u0fad\u0fae\u0faf\u0fb0\u0fb1\u0fb2\u0fb3\u0fb4\u0fb5\u0fb6\u0fb7\u0fb8\u0fb9\u0fba\u0fbb\u0fbc\u0fbd\u0fbe\u0fbf\u0fc0\u0fc1\u0fc2\u0fc3\u0fc4\u0fc5\u0fc6\u0fc7\u0fc8\u0fc9\u0fca\u0fcb\u0fcc\u0fcd\u0fce\u0fcf\u0fd0\u0fd1\u0fd2\u0fd3\u0fd4\u0fd5\u0fd6\u0fd7\u0fd8\u0fd9\u0fda\"; let _a = unicode_is_fun + \" really fun!\";\n+    //~^ ERROR binary operation `+` cannot be applied to type `&str`\n+}"}, {"sha": "9f0f990670f2dfcebfbebeabb8571e7d8f6bc25c", "filename": "src/test/ui/terminal-width/non-1-width-unicode-multiline-label.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fnon-1-width-unicode-multiline-label.stderr?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -0,0 +1,17 @@\n+error[E0369]: binary operation `+` cannot be applied to type `&str`\n+  --> $DIR/non-1-width-unicode-multiline-label.rs:5:260\n+   |\n+LL | ...\u0f7d\u0f7e\u0f7f\u0f80\u0f81\u0f82\u0f83\u0f84\u0f85\u0f86\u0f87\u0f88\u0f89\u0f8a\u0f8b\u0f8c\u0f8d\u0f8e\u0f8f\u0f90\u0f91\u0f92\u0f93\u0f94\u0f95\u0f96\u0f97\u0f98\u0f99\u0f9a\u0f9b\u0f9c\u0f9d\u0f9e\u0f9f\u0fa0\u0fa1\u0fa2\u0fa3\u0fa4\u0fa5\u0fa6\u0fa7\u0fa8\u0fa9\u0faa\u0fab\u0fac\u0fad\u0fae\u0faf\u0fb0\u0fb1\u0fb2\u0fb3\u0fb4\u0fb5\u0fb6\u0fb7\u0fb8\u0fb9\u0fba\u0fbb\u0fbc\u0fbd\u0fbe\u0fbf\u0fc0\u0fc1\u0fc2\u0fc3\u0fc4\u0fc5\u0fc6\u0fc7...\u0fcb\u0fcc\u0fcd\u0fce\u0fcf\u0fd0\u0fd1\u0fd2\u0fd3\u0fd4\u0fd5\u0fd6\u0fd7\u0fd8\u0fd9\u0fda\"; let _a = unicode_is_fun + \" really fun!\";\n+   |                                                  -------------- ^ -------------- &str\n+   |                                                  |              |\n+   |                                                  |              `+` cannot be used to concatenate two `&str` strings\n+   |                                                  &str\n+   |\n+help: `to_owned()` can be used to create an owned `String` from a string reference. String concatenation appends the string on the right to the string on the left and may require reallocation. This requires ownership of the string on the left\n+   |\n+LL |     let _ = \"\u0f00\u0f01\u0f02\u0f03\u0f04\u0f05\u0f06\u0f07\u0f08\u0f09\u0f0a\u0f0b\u0f0c\u0f0d\u0f0e\u0f0f\u0f10\u0f11\u0f12\u0f13\u0f14\u0f15\u0f16\u0f17\u0f18\u0f19\u0f1a\u0f1b\u0f1c\u0f1d\u0f1e\u0f1f\u0f20\u0f21\u0f22\u0f23\u0f24\u0f25\u0f26\u0f27\u0f28\u0f29\u0f2a\u0f2b\u0f2c\u0f2d\u0f2e\u0f2f\u0f30\u0f31\u0f32\u0f33\u0f34\u0f35\u0f36\u0f37\u0f38\u0f39\u0f3a\u0f3b\u0f3c\u0f3d\u0f3e\u0f3f\u0f40\u0f41\u0f42\u0f43\u0f44\u0f45\u0f46\u0f47\u0f48\u0f49\u0f4a\u0f4b\u0f4c\u0f4d\u0f4e\u0f4f\u0f50\u0f51\u0f52\u0f53\u0f54\u0f55\u0f56\u0f57\u0f58\u0f59\u0f5a\u0f5b\u0f5c\u0f5d\u0f5e\u0f5f\u0f60\u0f61\u0f62\u0f63\u0f64\u0f65\u0f66\u0f67\u0f68\u0f69\u0f6a\u0f6b\u0f6c\u0f6d\u0f6e\u0f6f\u0f70\u0f71\u0f72\u0f73\u0f74\u0f75\u0f76\u0f77\u0f78\u0f79\u0f7a\u0f7b\u0f7c\u0f7d\u0f7e\u0f7f\u0f80\u0f81\u0f82\u0f83\u0f84\u0f85\u0f86\u0f87\u0f88\u0f89\u0f8a\u0f8b\u0f8c\u0f8d\u0f8e\u0f8f\u0f90\u0f91\u0f92\u0f93\u0f94\u0f95\u0f96\u0f97\u0f98\u0f99\u0f9a\u0f9b\u0f9c\u0f9d\u0f9e\u0f9f\u0fa0\u0fa1\u0fa2\u0fa3\u0fa4\u0fa5\u0fa6\u0fa7\u0fa8\u0fa9\u0faa\u0fab\u0fac\u0fad\u0fae\u0faf\u0fb0\u0fb1\u0fb2\u0fb3\u0fb4\u0fb5\u0fb6\u0fb7\u0fb8\u0fb9\u0fba\u0fbb\u0fbc\u0fbd\u0fbe\u0fbf\u0fc0\u0fc1\u0fc2\u0fc3\u0fc4\u0fc5\u0fc6\u0fc7\u0fc8\u0fc9\u0fca\u0fcb\u0fcc\u0fcd\u0fce\u0fcf\u0fd0\u0fd1\u0fd2\u0fd3\u0fd4\u0fd5\u0fd6\u0fd7\u0fd8\u0fd9\u0fda\"; let _a = unicode_is_fun.to_owned() + \" really fun!\";\n+   |                                                                                                                                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "1e5ff9398321fd91a345e29371d5543f836812c4", "filename": "src/test/ui/terminal-width/non-whitespace-trimming-unicode.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fterminal-width%2Fnon-whitespace-trimming-unicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9081929d45f12d3f56d43b1d6db7519981580fc9/src%2Ftest%2Fui%2Fterminal-width%2Fnon-whitespace-trimming-unicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fterminal-width%2Fnon-whitespace-trimming-unicode.stderr?ref=9081929d45f12d3f56d43b1d6db7519981580fc9", "patch": "@@ -3,7 +3,7 @@ error[E0308]: mismatched types\n    |\n LL | ...\u266d\u266e\u266f\u2670\u2671\u2672\u2673\u2674\u2675\u2676\u2677\u2678\u2679\u267a\u267b\u267c\u267d\u267e\u267f\u2680\u2681\u2682\u2683\u2684\u2685\u2686\u2688\u26894\"; let _: () = 42;  let _: &str = \"\ud83e\udd80\u2600\u2601\u2602\u2603\u2604\u2605\u2606\u2607\u2608\u2609\u260a\u260b\u260c\u260d\u260e\u260f\u2610\u2611\u2612\u2613  \u2616\u2617\u2618\u2619\u261a\u261b\u261c\u261d\u261e\u261f\u2620\u2621\u2622\u2623\u2624\u2625\u2626\u2627\u2628\u2629\u262a\u262b\u262c\u262d\u262e\u262f\u2630\u2631\u2632\u2633\u2634\u2635\u2636\u2637\u2638\u2639\u263a\u263b\u263c\u263d\u263e\u263f\u2640\u2641\u2642\u2643\u2644...\n    |                                            --   ^^ expected `()`, found integer\n-   |                                                     |\n+   |                                            |\n    |                                            expected due to this\n \n error: aborting due to previous error"}]}