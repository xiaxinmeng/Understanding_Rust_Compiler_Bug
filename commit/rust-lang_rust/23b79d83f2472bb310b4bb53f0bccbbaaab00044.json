{"sha": "23b79d83f2472bb310b4bb53f0bccbbaaab00044", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzYjc5ZDgzZjI0NzJiYjMxMGI0YmI1M2YwYmNjYmJhYWFiMDAwNDQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-18T17:03:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-18T17:03:38Z"}, "message": "Rollup merge of #69838 - Centril:expand-module, r=petrochenkov\n\nExpansion-driven outline module parsing\n\nAfter this PR, the parser will not do any conditional compilation or loading of external module files when `mod foo;` is encountered. Instead, the parser only leaves `mod foo;` in place in the AST, with no items filled in. Expansion later kicks in and will load the actual files and do the parsing. This entails that the following is now valid:\n\n```rust\n#[cfg(FALSE)]\nmod foo {\n    mod bar {\n        mod baz; // `foo/bar/baz.rs` doesn't exist, but no error!\n    }\n}\n```\n\nFixes https://github.com/rust-lang/rust/issues/64197.\n\nr? @petrochenkov", "tree": {"sha": "1aad9e4566ff054c84f47e46f78c45fd5fb4c044", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1aad9e4566ff054c84f47e46f78c45fd5fb4c044"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23b79d83f2472bb310b4bb53f0bccbbaaab00044", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeclRqCRBK7hj4Ov3rIwAAdHIIABG+KxwjIBfgIm+bCxp/9tUH\nE/lO2/Eu5IJDESL68XA9NjOlBWVw12cnvbC02dWAuRuOgAhQxCDEbD+jAdf3weJl\nvdx3qnOGZ0QjB9WkZZkKwNdf42y7LBqIjQY63nrP1Pmc3KNEu/IF87SmMD7RrXEc\ngL4DO6dObSwGholsHYaokRcups5r5GPfLWg4l43/jkSK1j42482pSU02dhEzOIA6\nzuVeumooR8xjEZrz9WGqqCGGBoE7ob7t7B4eK692hsM9ztSHzT8cbww5xwyezUzl\nGjNa9lKqECBcfOfYWb0iBMMeJ59hIHG4OMDxK6YJFap75HEL137VNvB3gdnu0UY=\n=+wNI\n-----END PGP SIGNATURE-----\n", "payload": "tree 1aad9e4566ff054c84f47e46f78c45fd5fb4c044\nparent 4118ff61ec71a2b9869422ef1762b21051ce5e40\nparent 8caf688844e1c4ba3f3d554488efca7d0994b2b1\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584551018 +0100\ncommitter GitHub <noreply@github.com> 1584551018 +0100\n\nRollup merge of #69838 - Centril:expand-module, r=petrochenkov\n\nExpansion-driven outline module parsing\n\nAfter this PR, the parser will not do any conditional compilation or loading of external module files when `mod foo;` is encountered. Instead, the parser only leaves `mod foo;` in place in the AST, with no items filled in. Expansion later kicks in and will load the actual files and do the parsing. This entails that the following is now valid:\n\n```rust\n#[cfg(FALSE)]\nmod foo {\n    mod bar {\n        mod baz; // `foo/bar/baz.rs` doesn't exist, but no error!\n    }\n}\n```\n\nFixes https://github.com/rust-lang/rust/issues/64197.\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23b79d83f2472bb310b4bb53f0bccbbaaab00044", "html_url": "https://github.com/rust-lang/rust/commit/23b79d83f2472bb310b4bb53f0bccbbaaab00044", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23b79d83f2472bb310b4bb53f0bccbbaaab00044/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4118ff61ec71a2b9869422ef1762b21051ce5e40", "url": "https://api.github.com/repos/rust-lang/rust/commits/4118ff61ec71a2b9869422ef1762b21051ce5e40", "html_url": "https://github.com/rust-lang/rust/commit/4118ff61ec71a2b9869422ef1762b21051ce5e40"}, {"sha": "8caf688844e1c4ba3f3d554488efca7d0994b2b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8caf688844e1c4ba3f3d554488efca7d0994b2b1", "html_url": "https://github.com/rust-lang/rust/commit/8caf688844e1c4ba3f3d554488efca7d0994b2b1"}], "stats": {"total": 1192, "additions": 600, "deletions": 592}, "files": [{"sha": "a0bdb1481c6b2460c2c3eb2140adb46ccedce5c5", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -6,8 +6,6 @@\n //! Emscripten's runtime always implements those APIs and does not\n //! implement libunwind.\n \n-#![allow(private_no_mangle_fns)]\n-\n use alloc::boxed::Box;\n use core::any::Any;\n use core::mem;"}, {"sha": "1622442a5eb450dae5058eb724f3aac8a878fd1b", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -36,8 +36,6 @@\n //! Once stack has been unwound down to the handler frame level, unwinding stops\n //! and the last personality routine transfers control to the catch block.\n \n-#![allow(private_no_mangle_fns)]\n-\n use alloc::boxed::Box;\n use core::any::Any;\n "}, {"sha": "10b765a5b411b60efe5f1484e5ab3c1c6228c98c", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -45,7 +45,6 @@\n //! [llvm]: http://llvm.org/docs/ExceptionHandling.html#background-on-windows-exceptions\n \n #![allow(nonstandard_style)]\n-#![allow(private_no_mangle_fns)]\n \n use alloc::boxed::Box;\n use core::any::Any;"}, {"sha": "e3077b9897c18fcd08712eda6f611a2b4d735b76", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -2153,7 +2153,7 @@ impl FnRetTy {\n /// Module declaration.\n ///\n /// E.g., `mod foo;` or `mod foo { .. }`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, Default)]\n pub struct Mod {\n     /// A span from the first token past `{` to the last token until `}`.\n     /// For `mod foo;`, the inner span ranges from the first token"}, {"sha": "71622a3b7e657b3d6420c3cc0acf4e2df6599362", "filename": "src/librustc_builtin_macros/proc_macro_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fproc_macro_harness.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -59,7 +59,7 @@ pub fn inject(\n     handler: &rustc_errors::Handler,\n ) -> ast::Crate {\n     let ecfg = ExpansionConfig::default(\"proc_macro\".to_string());\n-    let mut cx = ExtCtxt::new(sess, ecfg, resolver);\n+    let mut cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n     let mut collect = CollectProcMacros {\n         macros: Vec::new(),"}, {"sha": "662bbe6a287a36e9399e5d3858fe6596e8e7aa2c", "filename": "src/librustc_builtin_macros/source_util.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_builtin_macros%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fsource_util.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -5,7 +5,7 @@ use rustc_ast::tokenstream::TokenStream;\n use rustc_ast_pretty::pprust;\n use rustc_expand::base::{self, *};\n use rustc_expand::panictry;\n-use rustc_parse::{self, new_sub_parser_from_file, parser::Parser, DirectoryOwnership};\n+use rustc_parse::{self, new_sub_parser_from_file, parser::Parser};\n use rustc_session::lint::builtin::INCOMPLETE_INCLUDE;\n use rustc_span::symbol::Symbol;\n use rustc_span::{self, Pos, Span};\n@@ -108,8 +108,7 @@ pub fn expand_include<'cx>(\n             return DummyResult::any(sp);\n         }\n     };\n-    let directory_ownership = DirectoryOwnership::Owned { relative: None };\n-    let p = new_sub_parser_from_file(cx.parse_sess(), &file, directory_ownership, None, sp);\n+    let p = new_sub_parser_from_file(cx.parse_sess(), &file, None, sp);\n \n     struct ExpandResult<'a> {\n         p: Parser<'a>,"}, {"sha": "f48fd6df9c98bd4e7d1797cf1a6fff4ee603b4cf", "filename": "src/librustc_builtin_macros/standard_library_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fstandard_library_imports.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -39,7 +39,7 @@ pub fn inject(\n     let call_site = DUMMY_SP.with_call_site_ctxt(expn_id);\n \n     let ecfg = ExpansionConfig::default(\"std_lib_injection\".to_string());\n-    let cx = ExtCtxt::new(sess, ecfg, resolver);\n+    let cx = ExtCtxt::new(sess, ecfg, resolver, None);\n \n     // .rev() to preserve ordering above in combination with insert(0, ...)\n     for &name in names.iter().rev() {"}, {"sha": "b87767f4a4127f650f7037f29833c0b24c42fe77", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -202,7 +202,7 @@ fn generate_test_harness(\n     let mut econfig = ExpansionConfig::default(\"test\".to_string());\n     econfig.features = Some(features);\n \n-    let ext_cx = ExtCtxt::new(sess, econfig, resolver);\n+    let ext_cx = ExtCtxt::new(sess, econfig, resolver, None);\n \n     let expn_id = ext_cx.resolver.expansion_for_ast_pass(\n         DUMMY_SP,"}, {"sha": "74c304c96b9a45490d82dd6969abdc801c6580da", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,4 +1,5 @@\n use crate::expand::{self, AstFragment, Invocation};\n+use crate::module::DirectoryOwnership;\n \n use rustc_ast::ast::{self, Attribute, Name, NodeId, PatKind};\n use rustc_ast::mut_visit::{self, MutVisitor};\n@@ -10,7 +11,7 @@ use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, DiagnosticId};\n-use rustc_parse::{self, parser, DirectoryOwnership, MACRO_ARGUMENTS};\n+use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{AstPass, ExpnData, ExpnId, ExpnKind};\n@@ -925,19 +926,23 @@ pub struct ExtCtxt<'a> {\n     pub resolver: &'a mut dyn Resolver,\n     pub current_expansion: ExpansionData,\n     pub expansions: FxHashMap<Span, Vec<String>>,\n+    /// Called directly after having parsed an external `mod foo;` in expansion.\n+    pub(super) extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate)>,\n }\n \n impl<'a> ExtCtxt<'a> {\n     pub fn new(\n         parse_sess: &'a ParseSess,\n         ecfg: expand::ExpansionConfig<'a>,\n         resolver: &'a mut dyn Resolver,\n+        extern_mod_loaded: Option<&'a dyn Fn(&ast::Crate)>,\n     ) -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess,\n             ecfg,\n-            root_path: PathBuf::new(),\n             resolver,\n+            extern_mod_loaded,\n+            root_path: PathBuf::new(),\n             current_expansion: ExpansionData {\n                 id: ExpnId::root(),\n                 depth: 0,"}, {"sha": "72c09f35dfa5573f5ce6f7f1afe4dc05ae4c9cfe", "filename": "src/librustc_expand/config.rs", "status": "renamed", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fconfig.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,14 +1,5 @@\n-//! Process the potential `cfg` attributes on a module.\n-//! Also determine if the module should be included in this configuration.\n-//!\n-//! This module properly belongs in rustc_expand, but for now it's tied into\n-//! parsing, so we leave it here to avoid complicated out-of-line dependencies.\n-//!\n-//! A principled solution to this wrong location would be to implement [#64197].\n-//!\n-//! [#64197]: https://github.com/rust-lang/rust/issues/64197\n-\n-use crate::{parse_in, validate_attr};\n+//! Conditional compilation stripping.\n+\n use rustc_ast::ast::{self, AttrItem, Attribute, MetaItem};\n use rustc_ast::attr::HasAttrs;\n use rustc_ast::mut_visit::*;\n@@ -21,6 +12,7 @@ use rustc_feature::{Feature, Features, State as FeatureState};\n use rustc_feature::{\n     ACCEPTED_FEATURES, ACTIVE_FEATURES, REMOVED_FEATURES, STABLE_REMOVED_FEATURES,\n };\n+use rustc_parse::{parse_in, validate_attr};\n use rustc_session::parse::{feature_err, ParseSess};\n use rustc_span::edition::{Edition, ALL_EDITIONS};\n use rustc_span::symbol::{sym, Symbol};\n@@ -538,12 +530,3 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n fn is_cfg(attr: &Attribute) -> bool {\n     attr.check_name(sym::cfg)\n }\n-\n-/// Process the potential `cfg` attributes on a module.\n-/// Also determine if the module should be included in this configuration.\n-pub fn process_configure_mod(sess: &ParseSess, cfg_mods: bool, attrs: &mut Vec<Attribute>) -> bool {\n-    // Don't perform gated feature checking.\n-    let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n-    strip_unconfigured.process_cfg_attrs(attrs);\n-    !cfg_mods || strip_unconfigured.in_cfg(&attrs)\n-}", "previous_filename": "src/librustc_parse/config.rs"}, {"sha": "b6cc192cc33d6c6b86d64e4816aa8757b12252d3", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,7 +1,9 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n+use crate::configure;\n use crate::hygiene::{ExpnData, ExpnId, ExpnKind, SyntaxContext};\n use crate::mbe::macro_rules::annotate_err_with_kind;\n+use crate::module::{parse_external_mod, push_directory, Directory, DirectoryOwnership};\n use crate::placeholders::{placeholder, PlaceholderExpander};\n use crate::proc_macro::collect_derives;\n \n@@ -17,10 +19,8 @@ use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n use rustc_errors::{Applicability, FatalError, PResult};\n use rustc_feature::Features;\n-use rustc_parse::configure;\n use rustc_parse::parser::Parser;\n use rustc_parse::validate_attr;\n-use rustc_parse::DirectoryOwnership;\n use rustc_session::lint::builtin::UNUSED_DOC_COMMENTS;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::{feature_err, ParseSess};\n@@ -1427,59 +1427,83 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 .make_items();\n         }\n \n+        let mut attrs = mem::take(&mut item.attrs); // We do this to please borrowck.\n+        let ident = item.ident;\n+        let span = item.span;\n+\n         match item.kind {\n             ast::ItemKind::MacCall(..) => {\n+                item.attrs = attrs;\n                 self.check_attributes(&item.attrs);\n                 item.and_then(|item| match item.kind {\n                     ItemKind::MacCall(mac) => self\n-                        .collect(\n-                            AstFragmentKind::Items,\n-                            InvocationKind::Bang { mac, span: item.span },\n-                        )\n+                        .collect(AstFragmentKind::Items, InvocationKind::Bang { mac, span })\n                         .make_items(),\n                     _ => unreachable!(),\n                 })\n             }\n-            ast::ItemKind::Mod(ast::Mod { inner, inline, .. })\n-                if item.ident != Ident::invalid() =>\n-            {\n-                let orig_directory_ownership = self.cx.current_expansion.directory_ownership;\n+            ast::ItemKind::Mod(ref mut old_mod @ ast::Mod { .. }) if ident != Ident::invalid() => {\n+                let sess = self.cx.parse_sess;\n+                let orig_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n-                module.mod_path.push(item.ident);\n \n-                if inline {\n-                    if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, sym::path) {\n-                        self.cx.current_expansion.directory_ownership =\n-                            DirectoryOwnership::Owned { relative: None };\n-                        module.directory.push(&*path.as_str());\n-                    } else {\n-                        module.directory.push(&*item.ident.as_str());\n-                    }\n+                let pushed = &mut false; // Record `parse_external_mod` pushing so we can pop.\n+                let dir = Directory { ownership: orig_ownership, path: module.directory };\n+                let Directory { ownership, path } = if old_mod.inline {\n+                    // Inline `mod foo { ... }`, but we still need to push directories.\n+                    item.attrs = attrs;\n+                    push_directory(ident, &item.attrs, dir)\n                 } else {\n-                    let path = self.cx.parse_sess.source_map().span_to_unmapped_path(inner);\n-                    let mut path = match path {\n-                        FileName::Real(path) => path,\n-                        other => PathBuf::from(other.to_string()),\n+                    // We have an outline `mod foo;` so we need to parse the file.\n+                    let (new_mod, dir) =\n+                        parse_external_mod(sess, ident, span, dir, &mut attrs, pushed);\n+\n+                    let krate = ast::Crate {\n+                        span: new_mod.inner,\n+                        module: new_mod,\n+                        attrs,\n+                        proc_macros: vec![],\n                     };\n-                    let directory_ownership = match path.file_name().unwrap().to_str() {\n-                        Some(\"mod.rs\") => DirectoryOwnership::Owned { relative: None },\n-                        Some(_) => DirectoryOwnership::Owned { relative: Some(item.ident) },\n-                        None => DirectoryOwnership::UnownedViaMod,\n+                    if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n+                        extern_mod_loaded(&krate);\n+                    }\n+\n+                    *old_mod = krate.module;\n+                    item.attrs = krate.attrs;\n+                    // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n+                    item = match self.configure(item) {\n+                        Some(node) => node,\n+                        None => {\n+                            if *pushed {\n+                                sess.included_mod_stack.borrow_mut().pop();\n+                            }\n+                            return Default::default();\n+                        }\n                     };\n-                    path.pop();\n-                    module.directory = path;\n-                    self.cx.current_expansion.directory_ownership = directory_ownership;\n-                }\n+                    dir\n+                };\n \n+                // Set the module info before we flat map.\n+                self.cx.current_expansion.directory_ownership = ownership;\n+                module.directory = path;\n+                module.mod_path.push(ident);\n                 let orig_module =\n                     mem::replace(&mut self.cx.current_expansion.module, Rc::new(module));\n+\n                 let result = noop_flat_map_item(item, self);\n+\n+                // Restore the module info.\n                 self.cx.current_expansion.module = orig_module;\n-                self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n+                self.cx.current_expansion.directory_ownership = orig_ownership;\n+                if *pushed {\n+                    sess.included_mod_stack.borrow_mut().pop();\n+                }\n                 result\n             }\n-\n-            _ => noop_flat_map_item(item, self),\n+            _ => {\n+                item.attrs = attrs;\n+                noop_flat_map_item(item, self)\n+            }\n         }\n     }\n "}, {"sha": "0320a275e5d20de35c773dd602a57768785551c4", "filename": "src/librustc_expand/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Flib.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,9 +1,11 @@\n+#![feature(bool_to_option)]\n #![feature(cow_is_borrowed)]\n #![feature(crate_visibility_modifier)]\n #![feature(decl_macro)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_span)]\n+#![feature(try_blocks)]\n \n extern crate proc_macro as pm;\n \n@@ -33,8 +35,10 @@ pub use mbe::macro_rules::compile_declarative_macro;\n crate use rustc_span::hygiene;\n pub mod base;\n pub mod build;\n+#[macro_use]\n+pub mod config;\n pub mod expand;\n-pub use rustc_parse::config;\n+pub mod module;\n pub mod proc_macro;\n \n crate mod mbe;"}, {"sha": "3de2169f1142e41560a76cdee472263724fbd08a", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,4 +1,4 @@\n-use crate::base::{DummyResult, ExpansionData, ExtCtxt, MacResult, TTMacroExpander};\n+use crate::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::base::{SyntaxExtension, SyntaxExtensionKind};\n use crate::expand::{ensure_complete_parse, parse_ast_fragment, AstFragment, AstFragmentKind};\n use crate::mbe;\n@@ -18,7 +18,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, DiagnosticBuilder, FatalError};\n use rustc_feature::Features;\n use rustc_parse::parser::Parser;\n-use rustc_parse::Directory;\n use rustc_session::parse::ParseSess;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::Transparency;\n@@ -182,6 +181,8 @@ fn generic_extension<'cx>(\n     lhses: &[mbe::TokenTree],\n     rhses: &[mbe::TokenTree],\n ) -> Box<dyn MacResult + 'cx> {\n+    let sess = cx.parse_sess;\n+\n     if cx.trace_macros() {\n         let msg = format!(\"expanding `{}! {{ {} }}`\", name, pprust::tts_to_string(arg.clone()));\n         trace_macros_note(&mut cx.expansions, sp, msg);\n@@ -209,7 +210,7 @@ fn generic_extension<'cx>(\n     // hacky, but speeds up the `html5ever` benchmark significantly. (Issue\n     // 68836 suggests a more comprehensive but more complex change to deal with\n     // this situation.)\n-    let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n+    let parser = parser_from_cx(sess, arg.clone());\n \n     for (i, lhs) in lhses.iter().enumerate() {\n         // try each arm's matchers\n@@ -222,14 +223,13 @@ fn generic_extension<'cx>(\n         // This is used so that if a matcher is not `Success(..)`ful,\n         // then the spans which became gated when parsing the unsuccessful matcher\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n-        let mut gated_spans_snapshot =\n-            mem::take(&mut *cx.parse_sess.gated_spans.spans.borrow_mut());\n+        let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n         match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n-                cx.parse_sess.gated_spans.merge(gated_spans_snapshot);\n+                sess.gated_spans.merge(gated_spans_snapshot);\n \n                 let rhs = match rhses[i] {\n                     // ignore delimiters\n@@ -258,11 +258,7 @@ fn generic_extension<'cx>(\n                     trace_macros_note(&mut cx.expansions, sp, msg);\n                 }\n \n-                let directory = Directory {\n-                    path: cx.current_expansion.module.directory.clone(),\n-                    ownership: cx.current_expansion.directory_ownership,\n-                };\n-                let mut p = Parser::new(cx.parse_sess(), tts, Some(directory), true, false, None);\n+                let mut p = Parser::new(sess, tts, false, None);\n                 p.root_module_name =\n                     cx.current_expansion.module.mod_path.last().map(|id| id.to_string());\n                 p.last_type_ascription = cx.current_expansion.prior_type_ascription;\n@@ -289,7 +285,7 @@ fn generic_extension<'cx>(\n \n         // The matcher was not `Success(..)`ful.\n         // Restore to the state before snapshotting and maybe try again.\n-        mem::swap(&mut gated_spans_snapshot, &mut cx.parse_sess.gated_spans.spans.borrow_mut());\n+        mem::swap(&mut gated_spans_snapshot, &mut sess.gated_spans.spans.borrow_mut());\n     }\n     drop(parser);\n \n@@ -309,8 +305,7 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts[..],\n                 _ => continue,\n             };\n-            let parser = parser_from_cx(&cx.current_expansion, &cx.parse_sess, arg.clone());\n-            match parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n+            match parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt) {\n                 Success(_) => {\n                     if comma_span.is_dummy() {\n                         err.note(\"you might be missing a comma\");\n@@ -392,7 +387,7 @@ pub fn compile_declarative_macro(\n         ),\n     ];\n \n-    let parser = Parser::new(sess, body, None, true, true, rustc_parse::MACRO_ARGUMENTS);\n+    let parser = Parser::new(sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n     let argument_map = match parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {\n@@ -1209,16 +1204,8 @@ fn quoted_tt_to_string(tt: &mbe::TokenTree) -> String {\n     }\n }\n \n-fn parser_from_cx<'cx>(\n-    current_expansion: &'cx ExpansionData,\n-    sess: &'cx ParseSess,\n-    tts: TokenStream,\n-) -> Parser<'cx> {\n-    let directory = Directory {\n-        path: current_expansion.module.directory.clone(),\n-        ownership: current_expansion.directory_ownership,\n-    };\n-    Parser::new(sess, tts, Some(directory), true, true, rustc_parse::MACRO_ARGUMENTS)\n+fn parser_from_cx(sess: &ParseSess, tts: TokenStream) -> Parser<'_> {\n+    Parser::new(sess, tts, true, rustc_parse::MACRO_ARGUMENTS)\n }\n \n /// Generates an appropriate parsing failure message. For EOF, this is \"unexpected end...\". For"}, {"sha": "2d5e4d4e8894d8127dba4811a8f706ab5fadfc1e", "filename": "src/librustc_expand/module.rs", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_expand%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmodule.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -0,0 +1,306 @@\n+use rustc_ast::ast::{self, Attribute, Ident, Mod};\n+use rustc_ast::{attr, token};\n+use rustc_errors::{struct_span_err, PResult};\n+use rustc_parse::new_sub_parser_from_file;\n+use rustc_session::parse::ParseSess;\n+use rustc_span::source_map::{FileName, Span};\n+use rustc_span::symbol::sym;\n+\n+use std::path::{self, Path, PathBuf};\n+\n+#[derive(Clone)]\n+pub struct Directory {\n+    pub path: PathBuf,\n+    pub ownership: DirectoryOwnership,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum DirectoryOwnership {\n+    Owned {\n+        // None if `mod.rs`, `Some(\"foo\")` if we're in `foo.rs`.\n+        relative: Option<ast::Ident>,\n+    },\n+    UnownedViaBlock,\n+    UnownedViaMod,\n+}\n+\n+/// Information about the path to a module.\n+// Public for rustfmt usage.\n+pub struct ModulePath<'a> {\n+    name: String,\n+    path_exists: bool,\n+    pub result: PResult<'a, ModulePathSuccess>,\n+}\n+\n+// Public for rustfmt usage.\n+pub struct ModulePathSuccess {\n+    pub path: PathBuf,\n+    pub ownership: DirectoryOwnership,\n+}\n+\n+crate fn parse_external_mod(\n+    sess: &ParseSess,\n+    id: ast::Ident,\n+    span: Span, // The span to blame on errors.\n+    Directory { mut ownership, path }: Directory,\n+    attrs: &mut Vec<Attribute>,\n+    pop_mod_stack: &mut bool,\n+) -> (Mod, Directory) {\n+    // We bail on the first error, but that error does not cause a fatal error... (1)\n+    let result: PResult<'_, _> = try {\n+        // Extract the file path and the new ownership.\n+        let mp = submod_path(sess, id, span, &attrs, ownership, &path)?;\n+        ownership = mp.ownership;\n+\n+        // Ensure file paths are acyclic.\n+        let mut included_mod_stack = sess.included_mod_stack.borrow_mut();\n+        error_on_circular_module(sess, span, &mp.path, &included_mod_stack)?;\n+        included_mod_stack.push(mp.path.clone());\n+        *pop_mod_stack = true; // We have pushed, so notify caller.\n+        drop(included_mod_stack);\n+\n+        // Actually parse the external file as amodule.\n+        let mut p0 = new_sub_parser_from_file(sess, &mp.path, Some(id.to_string()), span);\n+        let mut module = p0.parse_mod(&token::Eof)?;\n+        module.0.inline = false;\n+        module\n+    };\n+    // (1) ...instead, we return a dummy module.\n+    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n+    attrs.append(&mut new_attrs);\n+\n+    // Extract the directory path for submodules of `module`.\n+    let path = sess.source_map().span_to_unmapped_path(module.inner);\n+    let mut path = match path {\n+        FileName::Real(path) => path,\n+        other => PathBuf::from(other.to_string()),\n+    };\n+    path.pop();\n+\n+    (module, Directory { ownership, path })\n+}\n+\n+fn error_on_circular_module<'a>(\n+    sess: &'a ParseSess,\n+    span: Span,\n+    path: &Path,\n+    included_mod_stack: &[PathBuf],\n+) -> PResult<'a, ()> {\n+    if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n+        let mut err = String::from(\"circular modules: \");\n+        for p in &included_mod_stack[i..] {\n+            err.push_str(&p.to_string_lossy());\n+            err.push_str(\" -> \");\n+        }\n+        err.push_str(&path.to_string_lossy());\n+        return Err(sess.span_diagnostic.struct_span_err(span, &err[..]));\n+    }\n+    Ok(())\n+}\n+\n+crate fn push_directory(\n+    id: Ident,\n+    attrs: &[Attribute],\n+    Directory { mut ownership, mut path }: Directory,\n+) -> Directory {\n+    if let Some(filename) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n+        path.push(&*filename.as_str());\n+        ownership = DirectoryOwnership::Owned { relative: None };\n+    } else {\n+        // We have to push on the current module name in the case of relative\n+        // paths in order to ensure that any additional module paths from inline\n+        // `mod x { ... }` come after the relative extension.\n+        //\n+        // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n+        // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n+        if let DirectoryOwnership::Owned { relative } = &mut ownership {\n+            if let Some(ident) = relative.take() {\n+                // Remove the relative offset.\n+                path.push(&*ident.as_str());\n+            }\n+        }\n+        path.push(&*id.as_str());\n+    }\n+    Directory { ownership, path }\n+}\n+\n+fn submod_path<'a>(\n+    sess: &'a ParseSess,\n+    id: ast::Ident,\n+    span: Span,\n+    attrs: &[Attribute],\n+    ownership: DirectoryOwnership,\n+    dir_path: &Path,\n+) -> PResult<'a, ModulePathSuccess> {\n+    if let Some(path) = submod_path_from_attr(attrs, dir_path) {\n+        let ownership = match path.file_name().and_then(|s| s.to_str()) {\n+            // All `#[path]` files are treated as though they are a `mod.rs` file.\n+            // This means that `mod foo;` declarations inside `#[path]`-included\n+            // files are siblings,\n+            //\n+            // Note that this will produce weirdness when a file named `foo.rs` is\n+            // `#[path]` included and contains a `mod foo;` declaration.\n+            // If you encounter this, it's your own darn fault :P\n+            Some(_) => DirectoryOwnership::Owned { relative: None },\n+            _ => DirectoryOwnership::UnownedViaMod,\n+        };\n+        return Ok(ModulePathSuccess { ownership, path });\n+    }\n+\n+    let relative = match ownership {\n+        DirectoryOwnership::Owned { relative } => relative,\n+        DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n+    };\n+    let ModulePath { path_exists, name, result } =\n+        default_submod_path(sess, id, span, relative, dir_path);\n+    match ownership {\n+        DirectoryOwnership::Owned { .. } => Ok(result?),\n+        DirectoryOwnership::UnownedViaBlock => {\n+            let _ = result.map_err(|mut err| err.cancel());\n+            error_decl_mod_in_block(sess, span, path_exists, &name)\n+        }\n+        DirectoryOwnership::UnownedViaMod => {\n+            let _ = result.map_err(|mut err| err.cancel());\n+            error_cannot_declare_mod_here(sess, span, path_exists, &name)\n+        }\n+    }\n+}\n+\n+fn error_decl_mod_in_block<'a, T>(\n+    sess: &'a ParseSess,\n+    span: Span,\n+    path_exists: bool,\n+    name: &str,\n+) -> PResult<'a, T> {\n+    let msg = \"Cannot declare a non-inline module inside a block unless it has a path attribute\";\n+    let mut err = sess.span_diagnostic.struct_span_err(span, msg);\n+    if path_exists {\n+        let msg = format!(\"Maybe `use` the module `{}` instead of redeclaring it\", name);\n+        err.span_note(span, &msg);\n+    }\n+    Err(err)\n+}\n+\n+fn error_cannot_declare_mod_here<'a, T>(\n+    sess: &'a ParseSess,\n+    span: Span,\n+    path_exists: bool,\n+    name: &str,\n+) -> PResult<'a, T> {\n+    let mut err =\n+        sess.span_diagnostic.struct_span_err(span, \"cannot declare a new module at this location\");\n+    if !span.is_dummy() {\n+        if let FileName::Real(src_path) = sess.source_map().span_to_filename(span) {\n+            if let Some(stem) = src_path.file_stem() {\n+                let mut dest_path = src_path.clone();\n+                dest_path.set_file_name(stem);\n+                dest_path.push(\"mod.rs\");\n+                err.span_note(\n+                    span,\n+                    &format!(\n+                        \"maybe move this module `{}` to its own directory via `{}`\",\n+                        src_path.display(),\n+                        dest_path.display()\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+    if path_exists {\n+        err.span_note(\n+            span,\n+            &format!(\"... or maybe `use` the module `{}` instead of possibly redeclaring it\", name),\n+        );\n+    }\n+    Err(err)\n+}\n+\n+/// Derive a submodule path from the first found `#[path = \"path_string\"]`.\n+/// The provided `dir_path` is joined with the `path_string`.\n+// Public for rustfmt usage.\n+pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n+    // Extract path string from first `#[path = \"path_string\"]` attribute.\n+    let path_string = attr::first_attr_value_str_by_name(attrs, sym::path)?;\n+    let path_string = path_string.as_str();\n+\n+    // On windows, the base path might have the form\n+    // `\\\\?\\foo\\bar` in which case it does not tolerate\n+    // mixed `/` and `\\` separators, so canonicalize\n+    // `/` to `\\`.\n+    #[cfg(windows)]\n+    let path_string = path_string.replace(\"/\", \"\\\\\");\n+\n+    Some(dir_path.join(&*path_string))\n+}\n+\n+/// Returns a path to a module.\n+// Public for rustfmt usage.\n+pub fn default_submod_path<'a>(\n+    sess: &'a ParseSess,\n+    id: ast::Ident,\n+    span: Span,\n+    relative: Option<ast::Ident>,\n+    dir_path: &Path,\n+) -> ModulePath<'a> {\n+    // If we're in a foo.rs file instead of a mod.rs file,\n+    // we need to look for submodules in\n+    // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n+    // `./<id>.rs` and `./<id>/mod.rs`.\n+    let relative_prefix_string;\n+    let relative_prefix = if let Some(ident) = relative {\n+        relative_prefix_string = format!(\"{}{}\", ident.name, path::MAIN_SEPARATOR);\n+        &relative_prefix_string\n+    } else {\n+        \"\"\n+    };\n+\n+    let mod_name = id.name.to_string();\n+    let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n+    let secondary_path_str =\n+        format!(\"{}{}{}mod.rs\", relative_prefix, mod_name, path::MAIN_SEPARATOR);\n+    let default_path = dir_path.join(&default_path_str);\n+    let secondary_path = dir_path.join(&secondary_path_str);\n+    let default_exists = sess.source_map().file_exists(&default_path);\n+    let secondary_exists = sess.source_map().file_exists(&secondary_path);\n+\n+    let result = match (default_exists, secondary_exists) {\n+        (true, false) => Ok(ModulePathSuccess {\n+            path: default_path,\n+            ownership: DirectoryOwnership::Owned { relative: Some(id) },\n+        }),\n+        (false, true) => Ok(ModulePathSuccess {\n+            path: secondary_path,\n+            ownership: DirectoryOwnership::Owned { relative: None },\n+        }),\n+        (false, false) => {\n+            let mut err = struct_span_err!(\n+                sess.span_diagnostic,\n+                span,\n+                E0583,\n+                \"file not found for module `{}`\",\n+                mod_name,\n+            );\n+            err.help(&format!(\n+                \"to create the module `{}`, create file \\\"{}\\\"\",\n+                mod_name,\n+                default_path.display(),\n+            ));\n+            Err(err)\n+        }\n+        (true, true) => {\n+            let mut err = struct_span_err!(\n+                sess.span_diagnostic,\n+                span,\n+                E0584,\n+                \"file for module `{}` found at both {} and {}\",\n+                mod_name,\n+                default_path_str,\n+                secondary_path_str,\n+            );\n+            err.help(\"delete or rename one of them to remove the ambiguity\");\n+            Err(err)\n+        }\n+    };\n+\n+    ModulePath { name: mod_name, path_exists: default_exists || secondary_exists, result }\n+}"}, {"sha": "93f0beaa48be8efb0b21e96a17ed840188896437", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -210,14 +210,7 @@ pub fn register_plugins<'a>(\n     Ok((krate, Lrc::new(lint_store)))\n }\n \n-fn configure_and_expand_inner<'a>(\n-    sess: &'a Session,\n-    lint_store: &'a LintStore,\n-    mut krate: ast::Crate,\n-    crate_name: &str,\n-    resolver_arenas: &'a ResolverArenas<'a>,\n-    metadata_loader: &'a MetadataLoaderDyn,\n-) -> Result<(ast::Crate, Resolver<'a>)> {\n+fn pre_expansion_lint(sess: &Session, lint_store: &LintStore, krate: &ast::Crate) {\n     sess.time(\"pre_AST_expansion_lint_checks\", || {\n         rustc_lint::check_ast_crate(\n             sess,\n@@ -228,6 +221,17 @@ fn configure_and_expand_inner<'a>(\n             rustc_lint::BuiltinCombinedPreExpansionLintPass::new(),\n         );\n     });\n+}\n+\n+fn configure_and_expand_inner<'a>(\n+    sess: &'a Session,\n+    lint_store: &'a LintStore,\n+    mut krate: ast::Crate,\n+    crate_name: &str,\n+    resolver_arenas: &'a ResolverArenas<'a>,\n+    metadata_loader: &'a MetadataLoaderDyn,\n+) -> Result<(ast::Crate, Resolver<'a>)> {\n+    pre_expansion_lint(sess, lint_store, &krate);\n \n     let mut resolver = Resolver::new(sess, &krate, crate_name, metadata_loader, &resolver_arenas);\n     rustc_builtin_macros::register_builtin_macros(&mut resolver, sess.edition());\n@@ -291,7 +295,8 @@ fn configure_and_expand_inner<'a>(\n             ..rustc_expand::expand::ExpansionConfig::default(crate_name.to_string())\n         };\n \n-        let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver);\n+        let extern_mod_loaded = |k: &ast::Crate| pre_expansion_lint(sess, lint_store, k);\n+        let mut ecx = ExtCtxt::new(&sess.parse_sess, cfg, &mut resolver, Some(&extern_mod_loaded));\n \n         // Expand macros now!\n         let krate = sess.time(\"expand_crate\", || ecx.monotonic_expander().expand_crate(krate));"}, {"sha": "34da29c9747775b61d47aebb114e80e243ddff56", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -18,7 +18,7 @@ use crate::context::{EarlyContext, LintContext, LintStore};\n use crate::passes::{EarlyLintPass, EarlyLintPassObject};\n use rustc_ast::ast;\n use rustc_ast::visit as ast_visit;\n-use rustc_session::lint::{LintBuffer, LintPass};\n+use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n use rustc_session::Session;\n use rustc_span::Span;\n \n@@ -37,13 +37,7 @@ struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n     fn check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.context.buffered.take(id) {\n-            let rustc_session::lint::BufferedEarlyLint {\n-                span,\n-                msg,\n-                node_id: _,\n-                lint_id,\n-                diagnostic,\n-            } = early_lint;\n+            let BufferedEarlyLint { span, msg, node_id: _, lint_id, diagnostic } = early_lint;\n             self.context.lookup_with_diagnostics(\n                 lint_id.lint,\n                 Some(span),\n@@ -326,11 +320,9 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n     lint_buffer: Option<LintBuffer>,\n     builtin_lints: T,\n ) {\n-    let mut passes: Vec<_> = if pre_expansion {\n-        lint_store.pre_expansion_passes.iter().map(|p| (p)()).collect()\n-    } else {\n-        lint_store.early_passes.iter().map(|p| (p)()).collect()\n-    };\n+    let passes =\n+        if pre_expansion { &lint_store.pre_expansion_passes } else { &lint_store.early_passes };\n+    let mut passes: Vec<_> = passes.iter().map(|p| (p)()).collect();\n     let mut buffered = lint_buffer.unwrap_or_default();\n \n     if !sess.opts.debugging_opts.no_interleave_lints {"}, {"sha": "c31cc1b4c9f00b4d0263a091a0c5fb21dce439cf", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 5, "deletions": 46, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -3,6 +3,7 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(bindings_after_at)]\n+#![feature(try_blocks)]\n \n use rustc_ast::ast;\n use rustc_ast::token::{self, Nonterminal};\n@@ -13,7 +14,7 @@ use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n use rustc_session::parse::ParseSess;\n use rustc_span::{FileName, SourceFile, Span};\n \n-use std::path::{Path, PathBuf};\n+use std::path::Path;\n use std::str;\n \n use log::info;\n@@ -25,24 +26,6 @@ pub mod parser;\n use parser::{emit_unclosed_delims, make_unclosed_delims_error, Parser};\n pub mod lexer;\n pub mod validate_attr;\n-#[macro_use]\n-pub mod config;\n-\n-#[derive(Clone)]\n-pub struct Directory {\n-    pub path: PathBuf,\n-    pub ownership: DirectoryOwnership,\n-}\n-\n-#[derive(Copy, Clone)]\n-pub enum DirectoryOwnership {\n-    Owned {\n-        // None if `mod.rs`, `Some(\"foo\")` if we're in `foo.rs`.\n-        relative: Option<ast::Ident>,\n-    },\n-    UnownedViaBlock,\n-    UnownedViaMod,\n-}\n \n // A bunch of utility functions of the form `parse_<thing>_from_<source>`\n // where <thing> includes crate, expr, item, stmt, tts, and one that\n@@ -119,10 +102,7 @@ pub fn maybe_new_parser_from_source_str(\n     name: FileName,\n     source: String,\n ) -> Result<Parser<'_>, Vec<Diagnostic>> {\n-    let mut parser =\n-        maybe_source_file_to_parser(sess, sess.source_map().new_source_file(name, source))?;\n-    parser.recurse_into_file_modules = false;\n-    Ok(parser)\n+    maybe_source_file_to_parser(sess, sess.source_map().new_source_file(name, source))\n }\n \n /// Creates a new parser, handling errors as appropriate if the file doesn't exist.\n@@ -146,12 +126,10 @@ pub fn maybe_new_parser_from_file<'a>(\n pub fn new_sub_parser_from_file<'a>(\n     sess: &'a ParseSess,\n     path: &Path,\n-    directory_ownership: DirectoryOwnership,\n     module_name: Option<String>,\n     sp: Span,\n ) -> Parser<'a> {\n     let mut p = source_file_to_parser(sess, file_to_source_file(sess, path, Some(sp)));\n-    p.directory.ownership = directory_ownership;\n     p.root_module_name = module_name;\n     p\n }\n@@ -257,26 +235,7 @@ pub fn stream_to_parser<'a>(\n     stream: TokenStream,\n     subparser_name: Option<&'static str>,\n ) -> Parser<'a> {\n-    Parser::new(sess, stream, None, true, false, subparser_name)\n-}\n-\n-/// Given a stream, the `ParseSess` and the base directory, produces a parser.\n-///\n-/// Use this function when you are creating a parser from the token stream\n-/// and also care about the current working directory of the parser (e.g.,\n-/// you are trying to resolve modules defined inside a macro invocation).\n-///\n-/// # Note\n-///\n-/// The main usage of this function is outside of rustc, for those who uses\n-/// librustc_ast as a library. Please do not remove this function while refactoring\n-/// just because it is not used in rustc codebase!\n-pub fn stream_to_parser_with_base_dir(\n-    sess: &ParseSess,\n-    stream: TokenStream,\n-    base_dir: Directory,\n-) -> Parser<'_> {\n-    Parser::new(sess, stream, Some(base_dir), true, false, None)\n+    Parser::new(sess, stream, false, subparser_name)\n }\n \n /// Runs the given subparser `f` on the tokens of the given `attr`'s item.\n@@ -286,7 +245,7 @@ pub fn parse_in<'a, T>(\n     name: &'static str,\n     mut f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n ) -> PResult<'a, T> {\n-    let mut parser = Parser::new(sess, tts, None, false, false, Some(name));\n+    let mut parser = Parser::new(sess, tts, false, Some(name));\n     let result = f(&mut parser)?;\n     if parser.token != token::Eof {\n         parser.unexpected()?;"}, {"sha": "87255386b9e6602b101f6dbbf069cf43dd2b5c22", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -18,7 +18,6 @@ use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n \n use log::{debug, trace};\n use std::mem;\n-use std::path::PathBuf;\n \n const TURBOFISH: &str = \"use `::<...>` instead of `<...>` to specify type arguments\";\n \n@@ -41,42 +40,12 @@ pub(super) fn dummy_arg(ident: Ident) -> Param {\n }\n \n pub enum Error {\n-    FileNotFoundForModule { mod_name: String, default_path: PathBuf },\n-    DuplicatePaths { mod_name: String, default_path: String, secondary_path: String },\n     UselessDocComment,\n }\n \n impl Error {\n     fn span_err(self, sp: impl Into<MultiSpan>, handler: &Handler) -> DiagnosticBuilder<'_> {\n         match self {\n-            Error::FileNotFoundForModule { ref mod_name, ref default_path } => {\n-                let mut err = struct_span_err!(\n-                    handler,\n-                    sp,\n-                    E0583,\n-                    \"file not found for module `{}`\",\n-                    mod_name,\n-                );\n-                err.help(&format!(\n-                    \"to create the module `{}`, create file \\\"{}\\\"\",\n-                    mod_name,\n-                    default_path.display(),\n-                ));\n-                err\n-            }\n-            Error::DuplicatePaths { ref mod_name, ref default_path, ref secondary_path } => {\n-                let mut err = struct_span_err!(\n-                    handler,\n-                    sp,\n-                    E0584,\n-                    \"file for module `{}` found at both {} and {}\",\n-                    mod_name,\n-                    default_path,\n-                    secondary_path,\n-                );\n-                err.help(\"delete or rename one of them to remove the ambiguity\");\n-                err\n-            }\n             Error::UselessDocComment => {\n                 let mut err = struct_span_err!(\n                     handler,"}, {"sha": "9d70f606f3ef4339e80e6c619cd1048282bbd8d6", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -4,14 +4,15 @@ use super::{FollowedByType, Parser, PathStyle};\n \n use crate::maybe_whole;\n \n-use rustc_ast::ast::{self, Async, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n-use rustc_ast::ast::{AssocItem, AssocItemKind, ForeignItemKind, Item, ItemKind};\n-use rustc_ast::ast::{BindingMode, Block, FnDecl, FnSig, MacArgs, MacCall, MacDelimiter, Param};\n-use rustc_ast::ast::{Const, Defaultness, IsAuto, PathSegment, Unsafe, UseTree, UseTreeKind};\n+use rustc_ast::ast::{self, AttrStyle, AttrVec, Attribute, Ident, DUMMY_NODE_ID};\n+use rustc_ast::ast::{AssocItem, AssocItemKind, ForeignItemKind, Item, ItemKind, Mod};\n+use rustc_ast::ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree, UseTreeKind};\n+use rustc_ast::ast::{BindingMode, Block, FnDecl, FnSig, Param, SelfKind};\n use rustc_ast::ast::{EnumDef, Generics, StructField, TraitRef, Ty, TyKind, Variant, VariantData};\n-use rustc_ast::ast::{FnHeader, ForeignItem, Mutability, SelfKind, Visibility, VisibilityKind};\n+use rustc_ast::ast::{FnHeader, ForeignItem, PathSegment, Visibility, VisibilityKind};\n+use rustc_ast::ast::{MacArgs, MacCall, MacDelimiter};\n use rustc_ast::ptr::P;\n-use rustc_ast::token;\n+use rustc_ast::token::{self, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, PResult, StashKey};\n@@ -23,6 +24,61 @@ use log::debug;\n use std::convert::TryFrom;\n use std::mem;\n \n+impl<'a> Parser<'a> {\n+    /// Parses a source module as a crate. This is the main entry point for the parser.\n+    pub fn parse_crate_mod(&mut self) -> PResult<'a, ast::Crate> {\n+        let lo = self.token.span;\n+        let (module, attrs) = self.parse_mod(&token::Eof)?;\n+        let span = lo.to(self.token.span);\n+        let proc_macros = Vec::new(); // Filled in by `proc_macro_harness::inject()`.\n+        Ok(ast::Crate { attrs, module, span, proc_macros })\n+    }\n+\n+    /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n+    fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n+        let id = self.parse_ident()?;\n+        let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n+            Default::default()\n+        } else {\n+            self.expect(&token::OpenDelim(token::Brace))?;\n+            self.parse_mod(&token::CloseDelim(token::Brace))?\n+        };\n+        attrs.append(&mut inner_attrs);\n+        Ok((id, ItemKind::Mod(module)))\n+    }\n+\n+    /// Parses the contents of a module (inner attributes followed by module items).\n+    pub fn parse_mod(&mut self, term: &TokenKind) -> PResult<'a, (Mod, Vec<Attribute>)> {\n+        let lo = self.token.span;\n+        let attrs = self.parse_inner_attributes()?;\n+        let module = self.parse_mod_items(term, lo)?;\n+        Ok((module, attrs))\n+    }\n+\n+    /// Given a termination token, parses all of the items in a module.\n+    fn parse_mod_items(&mut self, term: &TokenKind, inner_lo: Span) -> PResult<'a, Mod> {\n+        let mut items = vec![];\n+        while let Some(item) = self.parse_item()? {\n+            items.push(item);\n+            self.maybe_consume_incorrect_semicolon(&items);\n+        }\n+\n+        if !self.eat(term) {\n+            let token_str = super::token_descr(&self.token);\n+            if !self.maybe_consume_incorrect_semicolon(&items) {\n+                let msg = &format!(\"expected item, found {}\", token_str);\n+                let mut err = self.struct_span_err(self.token.span, msg);\n+                err.span_label(self.token.span, \"expected item\");\n+                return Err(err);\n+            }\n+        }\n+\n+        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_token.span };\n+\n+        Ok(Mod { inner: inner_lo.to(hi), items, inline: true })\n+    }\n+}\n+\n pub(super) type ItemInfo = (Ident, ItemKind);\n \n impl<'a> Parser<'a> {"}, {"sha": "bb6793d08aa270dc24200d69cf5cc16e7fd0f4ea", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,6 @@\n pub mod attr;\n mod expr;\n mod item;\n-mod module;\n-pub use module::{ModulePath, ModulePathSuccess};\n mod pat;\n mod path;\n mod ty;\n@@ -13,7 +11,6 @@ mod stmt;\n use diagnostics::Error;\n \n use crate::lexer::UnmatchedBrace;\n-use crate::{Directory, DirectoryOwnership};\n \n use log::debug;\n use rustc_ast::ast::DUMMY_NODE_ID;\n@@ -28,11 +25,9 @@ use rustc_ast::util::comments::{doc_comment_style, strip_doc_comment_decoration}\n use rustc_ast_pretty::pprust;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, FatalError, PResult};\n use rustc_session::parse::ParseSess;\n-use rustc_span::source_map::respan;\n+use rustc_span::source_map::{respan, Span, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::{FileName, Span, DUMMY_SP};\n \n-use std::path::PathBuf;\n use std::{cmp, mem, slice};\n \n bitflags::bitflags! {\n@@ -93,21 +88,13 @@ pub struct Parser<'a> {\n     /// The previous token.\n     pub prev_token: Token,\n     restrictions: Restrictions,\n-    /// Used to determine the path to externally loaded source files.\n-    pub(super) directory: Directory,\n-    /// `true` to parse sub-modules in other files.\n-    // Public for rustfmt usage.\n-    pub recurse_into_file_modules: bool,\n     /// Name of the root module this parser originated from. If `None`, then the\n     /// name is not known. This does not change while the parser is descending\n     /// into modules, and sub-parsers have new values for this name.\n     pub root_module_name: Option<String>,\n     expected_tokens: Vec<TokenType>,\n     token_cursor: TokenCursor,\n     desugar_doc_comments: bool,\n-    /// `true` we should configure out of line modules as we parse.\n-    // Public for rustfmt usage.\n-    pub cfg_mods: bool,\n     /// This field is used to keep track of how many left angle brackets we have seen. This is\n     /// required in order to detect extra leading left angle brackets (`<` characters) and error\n     /// appropriately.\n@@ -355,8 +342,6 @@ impl<'a> Parser<'a> {\n     pub fn new(\n         sess: &'a ParseSess,\n         tokens: TokenStream,\n-        directory: Option<Directory>,\n-        recurse_into_file_modules: bool,\n         desugar_doc_comments: bool,\n         subparser_name: Option<&'static str>,\n     ) -> Self {\n@@ -365,19 +350,13 @@ impl<'a> Parser<'a> {\n             token: Token::dummy(),\n             prev_token: Token::dummy(),\n             restrictions: Restrictions::empty(),\n-            recurse_into_file_modules,\n-            directory: Directory {\n-                path: PathBuf::new(),\n-                ownership: DirectoryOwnership::Owned { relative: None },\n-            },\n             root_module_name: None,\n             expected_tokens: Vec::new(),\n             token_cursor: TokenCursor {\n                 frame: TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, &tokens),\n                 stack: Vec::new(),\n             },\n             desugar_doc_comments,\n-            cfg_mods: true,\n             unmatched_angle_bracket_count: 0,\n             max_angle_bracket_count: 0,\n             unclosed_delims: Vec::new(),\n@@ -389,18 +368,6 @@ impl<'a> Parser<'a> {\n         // Make parser point to the first token.\n         parser.bump();\n \n-        if let Some(directory) = directory {\n-            parser.directory = directory;\n-        } else if !parser.token.span.is_dummy() {\n-            if let Some(FileName::Real(path)) =\n-                &sess.source_map().lookup_char_pos(parser.token.span.lo()).file.unmapped_path\n-            {\n-                if let Some(directory_path) = path.parent() {\n-                    parser.directory.path = directory_path.to_path_buf();\n-                }\n-            }\n-        }\n-\n         parser\n     }\n "}, {"sha": "7b46601cc7d8026cc492f04fa432d40be511a182", "filename": "src/librustc_parse/parser/module.rs", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/rust-lang/rust/blob/4118ff61ec71a2b9869422ef1762b21051ce5e40/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4118ff61ec71a2b9869422ef1762b21051ce5e40/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=4118ff61ec71a2b9869422ef1762b21051ce5e40", "patch": "@@ -1,303 +0,0 @@\n-use super::diagnostics::Error;\n-use super::item::ItemInfo;\n-use super::Parser;\n-\n-use crate::{new_sub_parser_from_file, DirectoryOwnership};\n-\n-use rustc_ast::ast::{self, Attribute, Crate, Ident, ItemKind, Mod};\n-use rustc_ast::attr;\n-use rustc_ast::token::{self, TokenKind};\n-use rustc_errors::PResult;\n-use rustc_span::source_map::{FileName, SourceMap, Span, DUMMY_SP};\n-use rustc_span::symbol::sym;\n-\n-use std::path::{self, Path, PathBuf};\n-\n-/// Information about the path to a module.\n-// Public for rustfmt usage.\n-pub struct ModulePath {\n-    name: String,\n-    path_exists: bool,\n-    pub result: Result<ModulePathSuccess, Error>,\n-}\n-\n-// Public for rustfmt usage.\n-pub struct ModulePathSuccess {\n-    pub path: PathBuf,\n-    pub directory_ownership: DirectoryOwnership,\n-}\n-\n-impl<'a> Parser<'a> {\n-    /// Parses a source module as a crate. This is the main entry point for the parser.\n-    pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n-        let lo = self.token.span;\n-        let krate = Ok(ast::Crate {\n-            attrs: self.parse_inner_attributes()?,\n-            module: self.parse_mod_items(&token::Eof, lo)?,\n-            span: lo.to(self.token.span),\n-            // Filled in by proc_macro_harness::inject()\n-            proc_macros: Vec::new(),\n-        });\n-        krate\n-    }\n-\n-    /// Parses a `mod <foo> { ... }` or `mod <foo>;` item.\n-    pub(super) fn parse_item_mod(&mut self, attrs: &mut Vec<Attribute>) -> PResult<'a, ItemInfo> {\n-        let in_cfg = crate::config::process_configure_mod(self.sess, self.cfg_mods, attrs);\n-\n-        let id_span = self.token.span;\n-        let id = self.parse_ident()?;\n-        let (module, mut inner_attrs) = if self.eat(&token::Semi) {\n-            if in_cfg && self.recurse_into_file_modules {\n-                // This mod is in an external file. Let's go get it!\n-                let ModulePathSuccess { path, directory_ownership } =\n-                    self.submod_path(id, &attrs, id_span)?;\n-                self.eval_src_mod(path, directory_ownership, id.to_string(), id_span)?\n-            } else {\n-                (ast::Mod { inner: DUMMY_SP, items: Vec::new(), inline: false }, Vec::new())\n-            }\n-        } else {\n-            let old_directory = self.directory.clone();\n-            self.push_directory(id, &attrs);\n-\n-            self.expect(&token::OpenDelim(token::Brace))?;\n-            let mod_inner_lo = self.token.span;\n-            let inner_attrs = self.parse_inner_attributes()?;\n-            let module = self.parse_mod_items(&token::CloseDelim(token::Brace), mod_inner_lo)?;\n-\n-            self.directory = old_directory;\n-            (module, inner_attrs)\n-        };\n-        attrs.append(&mut inner_attrs);\n-        Ok((id, ItemKind::Mod(module)))\n-    }\n-\n-    /// Given a termination token, parses all of the items in a module.\n-    fn parse_mod_items(&mut self, term: &TokenKind, inner_lo: Span) -> PResult<'a, Mod> {\n-        let mut items = vec![];\n-        while let Some(item) = self.parse_item()? {\n-            items.push(item);\n-            self.maybe_consume_incorrect_semicolon(&items);\n-        }\n-\n-        if !self.eat(term) {\n-            let token_str = super::token_descr(&self.token);\n-            if !self.maybe_consume_incorrect_semicolon(&items) {\n-                let msg = &format!(\"expected item, found {}\", token_str);\n-                let mut err = self.struct_span_err(self.token.span, msg);\n-                err.span_label(self.token.span, \"expected item\");\n-                return Err(err);\n-            }\n-        }\n-\n-        let hi = if self.token.span.is_dummy() { inner_lo } else { self.prev_token.span };\n-\n-        Ok(Mod { inner: inner_lo.to(hi), items, inline: true })\n-    }\n-\n-    fn submod_path(\n-        &mut self,\n-        id: ast::Ident,\n-        outer_attrs: &[Attribute],\n-        id_sp: Span,\n-    ) -> PResult<'a, ModulePathSuccess> {\n-        if let Some(path) = Parser::submod_path_from_attr(outer_attrs, &self.directory.path) {\n-            return Ok(ModulePathSuccess {\n-                directory_ownership: match path.file_name().and_then(|s| s.to_str()) {\n-                    // All `#[path]` files are treated as though they are a `mod.rs` file.\n-                    // This means that `mod foo;` declarations inside `#[path]`-included\n-                    // files are siblings,\n-                    //\n-                    // Note that this will produce weirdness when a file named `foo.rs` is\n-                    // `#[path]` included and contains a `mod foo;` declaration.\n-                    // If you encounter this, it's your own darn fault :P\n-                    Some(_) => DirectoryOwnership::Owned { relative: None },\n-                    _ => DirectoryOwnership::UnownedViaMod,\n-                },\n-                path,\n-            });\n-        }\n-\n-        let relative = match self.directory.ownership {\n-            DirectoryOwnership::Owned { relative } => relative,\n-            DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n-        };\n-        let paths =\n-            Parser::default_submod_path(id, relative, &self.directory.path, self.sess.source_map());\n-\n-        match self.directory.ownership {\n-            DirectoryOwnership::Owned { .. } => {\n-                paths.result.map_err(|err| self.span_fatal_err(id_sp, err))\n-            }\n-            DirectoryOwnership::UnownedViaBlock => {\n-                let msg = \"Cannot declare a non-inline module inside a block \\\n-                    unless it has a path attribute\";\n-                let mut err = self.struct_span_err(id_sp, msg);\n-                if paths.path_exists {\n-                    let msg = format!(\n-                        \"Maybe `use` the module `{}` instead of redeclaring it\",\n-                        paths.name\n-                    );\n-                    err.span_note(id_sp, &msg);\n-                }\n-                Err(err)\n-            }\n-            DirectoryOwnership::UnownedViaMod => {\n-                let mut err =\n-                    self.struct_span_err(id_sp, \"cannot declare a new module at this location\");\n-                if !id_sp.is_dummy() {\n-                    let src_path = self.sess.source_map().span_to_filename(id_sp);\n-                    if let FileName::Real(src_path) = src_path {\n-                        if let Some(stem) = src_path.file_stem() {\n-                            let mut dest_path = src_path.clone();\n-                            dest_path.set_file_name(stem);\n-                            dest_path.push(\"mod.rs\");\n-                            err.span_note(\n-                                id_sp,\n-                                &format!(\n-                                    \"maybe move this module `{}` to its own \\\n-                                                directory via `{}`\",\n-                                    src_path.display(),\n-                                    dest_path.display()\n-                                ),\n-                            );\n-                        }\n-                    }\n-                }\n-                if paths.path_exists {\n-                    err.span_note(\n-                        id_sp,\n-                        &format!(\n-                            \"... or maybe `use` the module `{}` instead \\\n-                                            of possibly redeclaring it\",\n-                            paths.name\n-                        ),\n-                    );\n-                }\n-                Err(err)\n-            }\n-        }\n-    }\n-\n-    // Public for rustfmt usage.\n-    pub fn submod_path_from_attr(attrs: &[Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        if let Some(s) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n-            let s = s.as_str();\n-\n-            // On windows, the base path might have the form\n-            // `\\\\?\\foo\\bar` in which case it does not tolerate\n-            // mixed `/` and `\\` separators, so canonicalize\n-            // `/` to `\\`.\n-            #[cfg(windows)]\n-            let s = s.replace(\"/\", \"\\\\\");\n-            Some(dir_path.join(&*s))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns a path to a module.\n-    // Public for rustfmt usage.\n-    pub fn default_submod_path(\n-        id: ast::Ident,\n-        relative: Option<ast::Ident>,\n-        dir_path: &Path,\n-        source_map: &SourceMap,\n-    ) -> ModulePath {\n-        // If we're in a foo.rs file instead of a mod.rs file,\n-        // we need to look for submodules in\n-        // `./foo/<id>.rs` and `./foo/<id>/mod.rs` rather than\n-        // `./<id>.rs` and `./<id>/mod.rs`.\n-        let relative_prefix_string;\n-        let relative_prefix = if let Some(ident) = relative {\n-            relative_prefix_string = format!(\"{}{}\", ident.name, path::MAIN_SEPARATOR);\n-            &relative_prefix_string\n-        } else {\n-            \"\"\n-        };\n-\n-        let mod_name = id.name.to_string();\n-        let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n-        let secondary_path_str =\n-            format!(\"{}{}{}mod.rs\", relative_prefix, mod_name, path::MAIN_SEPARATOR);\n-        let default_path = dir_path.join(&default_path_str);\n-        let secondary_path = dir_path.join(&secondary_path_str);\n-        let default_exists = source_map.file_exists(&default_path);\n-        let secondary_exists = source_map.file_exists(&secondary_path);\n-\n-        let result = match (default_exists, secondary_exists) {\n-            (true, false) => Ok(ModulePathSuccess {\n-                path: default_path,\n-                directory_ownership: DirectoryOwnership::Owned { relative: Some(id) },\n-            }),\n-            (false, true) => Ok(ModulePathSuccess {\n-                path: secondary_path,\n-                directory_ownership: DirectoryOwnership::Owned { relative: None },\n-            }),\n-            (false, false) => {\n-                Err(Error::FileNotFoundForModule { mod_name: mod_name.clone(), default_path })\n-            }\n-            (true, true) => Err(Error::DuplicatePaths {\n-                mod_name: mod_name.clone(),\n-                default_path: default_path_str,\n-                secondary_path: secondary_path_str,\n-            }),\n-        };\n-\n-        ModulePath { name: mod_name, path_exists: default_exists || secondary_exists, result }\n-    }\n-\n-    /// Reads a module from a source file.\n-    fn eval_src_mod(\n-        &mut self,\n-        path: PathBuf,\n-        directory_ownership: DirectoryOwnership,\n-        name: String,\n-        id_sp: Span,\n-    ) -> PResult<'a, (Mod, Vec<Attribute>)> {\n-        let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n-        if let Some(i) = included_mod_stack.iter().position(|p| *p == path) {\n-            let mut err = String::from(\"circular modules: \");\n-            let len = included_mod_stack.len();\n-            for p in &included_mod_stack[i..len] {\n-                err.push_str(&p.to_string_lossy());\n-                err.push_str(\" -> \");\n-            }\n-            err.push_str(&path.to_string_lossy());\n-            return Err(self.struct_span_err(id_sp, &err[..]));\n-        }\n-        included_mod_stack.push(path.clone());\n-        drop(included_mod_stack);\n-\n-        let mut p0 =\n-            new_sub_parser_from_file(self.sess, &path, directory_ownership, Some(name), id_sp);\n-        p0.cfg_mods = self.cfg_mods;\n-        let mod_inner_lo = p0.token.span;\n-        let mod_attrs = p0.parse_inner_attributes()?;\n-        let mut m0 = p0.parse_mod_items(&token::Eof, mod_inner_lo)?;\n-        m0.inline = false;\n-        self.sess.included_mod_stack.borrow_mut().pop();\n-        Ok((m0, mod_attrs))\n-    }\n-\n-    fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) {\n-        if let Some(path) = attr::first_attr_value_str_by_name(attrs, sym::path) {\n-            self.directory.path.push(&*path.as_str());\n-            self.directory.ownership = DirectoryOwnership::Owned { relative: None };\n-        } else {\n-            // We have to push on the current module name in the case of relative\n-            // paths in order to ensure that any additional module paths from inline\n-            // `mod x { ... }` come after the relative extension.\n-            //\n-            // For example, a `mod z { ... }` inside `x/y.rs` should set the current\n-            // directory path to `/x/y/z`, not `/x/z` with a relative offset of `y`.\n-            if let DirectoryOwnership::Owned { relative } = &mut self.directory.ownership {\n-                if let Some(ident) = relative.take() {\n-                    // remove the relative offset\n-                    self.directory.path.push(&*ident.as_str());\n-                }\n-            }\n-            self.directory.path.push(&*id.as_str());\n-        }\n-    }\n-}"}, {"sha": "d40597d8fcb0c543127dc61e155dd87e54b84bd7", "filename": "src/librustc_parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fstmt.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -5,7 +5,6 @@ use super::pat::GateOr;\n use super::path::PathStyle;\n use super::{BlockMode, Parser, Restrictions, SemiColonMode};\n use crate::maybe_whole;\n-use crate::DirectoryOwnership;\n \n use rustc_ast::ast;\n use rustc_ast::ast::{AttrStyle, AttrVec, Attribute, MacCall, MacStmtStyle};\n@@ -54,7 +53,7 @@ impl<'a> Parser<'a> {\n             // that starts like a path (1 token), but it fact not a path.\n             // Also, we avoid stealing syntax from `parse_item_`.\n             self.parse_stmt_path_start(lo, attrs)?\n-        } else if let Some(item) = self.parse_stmt_item(attrs.clone())? {\n+        } else if let Some(item) = self.parse_item_common(attrs.clone(), false, true, |_| true)? {\n             // FIXME: Bad copy of attrs\n             self.mk_stmt(lo.to(item.span), StmtKind::Item(P(item)))\n         } else if self.eat(&token::Semi) {\n@@ -72,13 +71,6 @@ impl<'a> Parser<'a> {\n         Ok(Some(stmt))\n     }\n \n-    fn parse_stmt_item(&mut self, attrs: Vec<Attribute>) -> PResult<'a, Option<ast::Item>> {\n-        let old = mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n-        let item = self.parse_item_common(attrs, false, true, |_| true)?;\n-        self.directory.ownership = old;\n-        Ok(item)\n-    }\n-\n     fn parse_stmt_path_start(&mut self, lo: Span, attrs: Vec<Attribute>) -> PResult<'a, Stmt> {\n         let path = self.parse_path(PathStyle::Expr)?;\n "}, {"sha": "2512878ec65be06d77eedc820e0a9fa9edbed196", "filename": "src/librustc_parse/validate_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Flibrustc_parse%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fvalidate_attr.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -57,7 +57,7 @@ pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, Meta\n     })\n }\n \n-crate fn check_meta_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter, msg: &str) {\n+pub fn check_meta_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter, msg: &str) {\n     if let ast::MacDelimiter::Parenthesis = delim {\n         return;\n     }"}, {"sha": "9b3b381d6210ac4f81b73721bc00fa01054c850a", "filename": "src/test/incremental/change_symbol_export_status.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fincremental%2Fchange_symbol_export_status.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fincremental%2Fchange_symbol_export_status.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fchange_symbol_export_status.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -2,10 +2,8 @@\n // compile-flags: -Zquery-dep-graph\n \n #![feature(rustc_attrs)]\n-#![allow(private_no_mangle_fns)]\n-\n-#![rustc_partition_codegened(module=\"change_symbol_export_status-mod1\", cfg=\"rpass2\")]\n-#![rustc_partition_reused(module=\"change_symbol_export_status-mod2\", cfg=\"rpass2\")]\n+#![rustc_partition_codegened(module = \"change_symbol_export_status-mod1\", cfg = \"rpass2\")]\n+#![rustc_partition_reused(module = \"change_symbol_export_status-mod2\", cfg = \"rpass2\")]\n \n // This test case makes sure that a change in symbol visibility is detected by\n // our dependency tracking. We do this by changing a module's visibility to"}, {"sha": "ca1fef83cffc5fcfa249e8496d39d6c79fd71456", "filename": "src/test/pretty/issue-12590-a.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fpretty%2Fissue-12590-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fpretty%2Fissue-12590-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-12590-a.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,4 +1,5 @@\n // pp-exact\n+// pretty-compare-only\n \n // The next line should not be expanded\n "}, {"sha": "837ed1f002fc99b3bb1198397989ad9ffd087a73", "filename": "src/test/ui-fulldeps/auxiliary/linkage-visibility.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flinkage-visibility.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -2,16 +2,14 @@\n \n #![feature(rustc_private)]\n \n-// We're testing linkage visibility; the compiler warns us, but we want to\n-// do the runtime check that these functions aren't exported.\n-#![allow(private_no_mangle_fns)]\n-\n extern crate rustc_metadata;\n \n use rustc_metadata::dynamic_lib::DynamicLibrary;\n \n #[no_mangle]\n-pub fn foo() { bar(); }\n+pub fn foo() {\n+    bar();\n+}\n \n pub fn foo2<T>() {\n     fn bar2() {\n@@ -21,11 +19,11 @@ pub fn foo2<T>() {\n }\n \n #[no_mangle]\n-fn bar() { }\n+fn bar() {}\n \n #[allow(dead_code)]\n #[no_mangle]\n-fn baz() { }\n+fn baz() {}\n \n pub fn test() {\n     let lib = DynamicLibrary::open(None).unwrap();"}, {"sha": "9cb159603a8c561c1ce76152d2475ab59269782e", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,7 +1,9 @@\n // Test that macro-expanded non-inline modules behave correctly\n \n macro_rules! mod_decl {\n-    ($i:ident) => { mod $i; } //~ ERROR Cannot declare a non-inline module inside a block\n+    ($i:ident) => {\n+        mod $i; //~ ERROR Cannot declare a non-inline module inside a block\n+    };\n }\n \n mod macro_expanded_mod_helper {"}, {"sha": "f90419247c92badae27794bd1690ebbdf6ef3164", "filename": "src/test/ui/directory_ownership/macro-expanded-mod.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fmacro-expanded-mod.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,8 @@\n error: Cannot declare a non-inline module inside a block unless it has a path attribute\n-  --> $DIR/macro-expanded-mod.rs:4:25\n+  --> $DIR/macro-expanded-mod.rs:5:9\n    |\n-LL |     ($i:ident) => { mod $i; }\n-   |                         ^^\n+LL |         mod $i;\n+   |         ^^^^^^^\n ...\n LL |     mod_decl!(foo);\n    |     --------------- in this macro invocation"}, {"sha": "d034942ca5d4cc7a50ab020eeecadca5ad3a5878", "filename": "src/test/ui/directory_ownership/non-inline-mod-restriction.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdirectory_ownership%2Fnon-inline-mod-restriction.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,8 @@\n error: Cannot declare a non-inline module inside a block unless it has a path attribute\n-  --> $DIR/non-inline-mod-restriction.rs:4:9\n+  --> $DIR/non-inline-mod-restriction.rs:4:5\n    |\n LL |     mod foo;\n-   |         ^^^\n+   |     ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "dbe700355957b1ebe76edff13adb9d7108211fca", "filename": "src/test/ui/error-codes/E0583.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Ferror-codes%2FE0583.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Ferror-codes%2FE0583.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0583.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,8 @@\n error[E0583]: file not found for module `module_that_doesnt_exist`\n-  --> $DIR/E0583.rs:1:5\n+  --> $DIR/E0583.rs:1:1\n    |\n LL | mod module_that_doesnt_exist;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: to create the module `module_that_doesnt_exist`, create file \"$DIR/module_that_doesnt_exist.rs\"\n "}, {"sha": "52296042eb4a73b80b129fdda944822d3ee7e1cd", "filename": "src/test/ui/invalid-module-declaration/invalid-module-declaration.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Finvalid-module-declaration%2Finvalid-module-declaration.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Finvalid-module-declaration%2Finvalid-module-declaration.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-module-declaration%2Finvalid-module-declaration.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,8 @@\n error[E0583]: file not found for module `baz`\n-  --> $DIR/auxiliary/foo/bar.rs:1:9\n+  --> $DIR/auxiliary/foo/bar.rs:1:1\n    |\n LL | pub mod baz;\n-   |         ^^^\n+   | ^^^^^^^^^^^^\n    |\n    = help: to create the module `baz`, create file \"$DIR/auxiliary/foo/bar/baz.rs\"\n "}, {"sha": "30e2ed8b7a6233c31381c846ea2eb858f4688bbb", "filename": "src/test/ui/lint/lint-pre-expansion-extern-module.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Flint%2Flint-pre-expansion-extern-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Flint%2Flint-pre-expansion-extern-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-pre-expansion-extern-module.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -0,0 +1,7 @@\n+// check-pass\n+// compile-flags: -W rust-2018-compatibility\n+// error-pattern: `try` is a keyword in the 2018 edition\n+\n+fn main() {}\n+\n+mod lint_pre_expansion_extern_module_aux;"}, {"sha": "c683a3fa670ae36d0221836ce468b89fbdf57c12", "filename": "src/test/ui/lint/lint-pre-expansion-extern-module.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Flint%2Flint-pre-expansion-extern-module.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Flint%2Flint-pre-expansion-extern-module.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-pre-expansion-extern-module.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -0,0 +1,10 @@\n+warning: `try` is a keyword in the 2018 edition\n+  --> $DIR/lint_pre_expansion_extern_module_aux.rs:3:8\n+   |\n+LL | pub fn try() {}\n+   |        ^^^ help: you can use a raw identifier to stay compatible: `r#try`\n+   |\n+   = note: `-W keyword-idents` implied by `-W rust-2018-compatibility`\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+"}, {"sha": "71dec40ea44f0d67ed0a8f533753f8763541bb7b", "filename": "src/test/ui/lint/lint_pre_expansion_extern_module_aux.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Flint%2Flint_pre_expansion_extern_module_aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Flint%2Flint_pre_expansion_extern_module_aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint_pre_expansion_extern_module_aux.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -0,0 +1,3 @@\n+// ignore-test: not a test\n+\n+pub fn try() {}"}, {"sha": "91b3fe15c4be7a87a4b8525988378e29831eb974", "filename": "src/test/ui/missing_non_modrs_mod/missing_non_modrs_mod.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,8 @@\n error[E0583]: file not found for module `missing`\n-  --> $DIR/foo.rs:4:5\n+  --> $DIR/foo.rs:4:1\n    |\n LL | mod missing;\n-   |     ^^^^^^^\n+   | ^^^^^^^^^^^^\n    |\n    = help: to create the module `missing`, create file \"$DIR/foo/missing.rs\"\n "}, {"sha": "f519de46c767f9627419778a00845c35a4750ab1", "filename": "src/test/ui/missing_non_modrs_mod/missing_non_modrs_mod_inline.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,8 @@\n error[E0583]: file not found for module `missing`\n-  --> $DIR/foo_inline.rs:4:9\n+  --> $DIR/foo_inline.rs:4:5\n    |\n LL |     mod missing;\n-   |         ^^^^^^^\n+   |     ^^^^^^^^^^^^\n    |\n    = help: to create the module `missing`, create file \"$DIR/foo_inline/inline/missing.rs\"\n "}, {"sha": "7b182421d34e3c0b1d7f1f2ccf95e876ad1f2f23", "filename": "src/test/ui/mod/mod_file_disambig.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fmod%2Fmod_file_disambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fmod%2Fmod_file_disambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmod%2Fmod_file_disambig.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -2,4 +2,5 @@ mod mod_file_disambig_aux; //~ ERROR file for module `mod_file_disambig_aux` fou\n \n fn main() {\n     assert_eq!(mod_file_aux::bar(), 10);\n+    //~^ ERROR failed to resolve: use of undeclared type or module `mod_file_aux`\n }"}, {"sha": "490633a3fb0ab15b620d9b362251b724e403eb58", "filename": "src/test/ui/mod/mod_file_disambig.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fmod%2Fmod_file_disambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fmod%2Fmod_file_disambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmod%2Fmod_file_disambig.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,11 +1,18 @@\n error[E0584]: file for module `mod_file_disambig_aux` found at both mod_file_disambig_aux.rs and mod_file_disambig_aux/mod.rs\n-  --> $DIR/mod_file_disambig.rs:1:5\n+  --> $DIR/mod_file_disambig.rs:1:1\n    |\n LL | mod mod_file_disambig_aux;\n-   |     ^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: delete or rename one of them to remove the ambiguity\n \n-error: aborting due to previous error\n+error[E0433]: failed to resolve: use of undeclared type or module `mod_file_aux`\n+  --> $DIR/mod_file_disambig.rs:4:16\n+   |\n+LL |     assert_eq!(mod_file_aux::bar(), 10);\n+   |                ^^^^^^^^^^^^ use of undeclared type or module `mod_file_aux`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0584`.\n+Some errors have detailed explanations: E0433, E0584.\n+For more information about an error, try `rustc --explain E0433`."}, {"sha": "1ae36a1f7605eb1a47403e393af05314b6f02a7c", "filename": "src/test/ui/parser/circular_modules_main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -6,5 +6,5 @@ pub fn hi_str() -> String {\n }\n \n fn main() {\n-    circular_modules_hello::say_hello();\n+    circular_modules_hello::say_hello(); //~ ERROR cannot find function `say_hello` in module\n }"}, {"sha": "90f81c64835b74ae0eca9f50703c1cf2b79b94be", "filename": "src/test/ui/parser/circular_modules_main.stderr", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fcircular_modules_main.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,20 @@\n error: circular modules: $DIR/circular_modules_hello.rs -> $DIR/circular_modules_main.rs -> $DIR/circular_modules_hello.rs\n-  --> $DIR/circular_modules_main.rs:2:5\n+  --> $DIR/circular_modules_main.rs:2:1\n    |\n LL | mod circular_modules_hello;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0425]: cannot find function `say_hello` in module `circular_modules_hello`\n+  --> $DIR/circular_modules_main.rs:9:29\n+   |\n+LL |     circular_modules_hello::say_hello();\n+   |                             ^^^^^^^^^ not found in `circular_modules_hello`\n+   |\n+help: possible candidate is found in another module, you can import it into scope\n+   |\n+LL | use circular_modules_hello::say_hello;\n+   |\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0425`."}, {"sha": "bdb5c91ff91eb084cee75f781937ef5eb2309be4", "filename": "src/test/ui/parser/issue-5806.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fissue-5806.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fissue-5806.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-5806.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,8 @@\n error: couldn't read $DIR/../parser: $ACCESS_DENIED_MSG (os error $ACCESS_DENIED_CODE)\n-  --> $DIR/issue-5806.rs:5:5\n+  --> $DIR/issue-5806.rs:5:1\n    |\n LL | mod foo;\n-   |     ^^^\n+   | ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "f4a27b52ec5b48f113221558dbe3aef4f62ac09a", "filename": "src/test/ui/parser/mod_file_not_exist.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,9 @@\n // ignore-windows\n \n mod not_a_real_file; //~ ERROR file not found for module `not_a_real_file`\n-//~^ HELP to create the module `not_a_real_file`, create file \"\n+//~^ HELP to create the module `not_a_real_file`, create file\n \n fn main() {\n     assert_eq!(mod_file_aux::bar(), 10);\n+    //~^ ERROR failed to resolve: use of undeclared type or module `mod_file_aux`\n }"}, {"sha": "087ae9fe3e016c92e9cc1ebfc0e3510b86f4dd0b", "filename": "src/test/ui/parser/mod_file_not_exist.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,11 +1,18 @@\n error[E0583]: file not found for module `not_a_real_file`\n-  --> $DIR/mod_file_not_exist.rs:3:5\n+  --> $DIR/mod_file_not_exist.rs:3:1\n    |\n LL | mod not_a_real_file;\n-   |     ^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: to create the module `not_a_real_file`, create file \"$DIR/not_a_real_file.rs\"\n \n-error: aborting due to previous error\n+error[E0433]: failed to resolve: use of undeclared type or module `mod_file_aux`\n+  --> $DIR/mod_file_not_exist.rs:7:16\n+   |\n+LL |     assert_eq!(mod_file_aux::bar(), 10);\n+   |                ^^^^^^^^^^^^ use of undeclared type or module `mod_file_aux`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0583`.\n+Some errors have detailed explanations: E0433, E0583.\n+For more information about an error, try `rustc --explain E0433`."}, {"sha": "4b7d7a02bbe78cc468d605715b09cdda7c16f2bf", "filename": "src/test/ui/parser/mod_file_not_exist_windows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -5,4 +5,5 @@ mod not_a_real_file; //~ ERROR file not found for module `not_a_real_file`\n \n fn main() {\n     assert_eq!(mod_file_aux::bar(), 10);\n+    //~^ ERROR failed to resolve: use of undeclared type or module `mod_file_aux`\n }"}, {"sha": "d67205cfdf1007cf9959fb3ed835fea809f119d5", "filename": "src/test/ui/parser/mod_file_not_exist_windows.stderr", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,11 +1,18 @@\n error[E0583]: file not found for module `not_a_real_file`\n-  --> $DIR/mod_file_not_exist_windows.rs:3:5\n+  --> $DIR/mod_file_not_exist_windows.rs:3:1\n    |\n LL | mod not_a_real_file;\n-   |     ^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: to create the module `not_a_real_file`, create file \"$DIR/not_a_real_file.rs\"\n \n-error: aborting due to previous error\n+error[E0433]: failed to resolve: use of undeclared type or module `mod_file_aux`\n+  --> $DIR/mod_file_not_exist_windows.rs:7:16\n+   |\n+LL |     assert_eq!(mod_file_aux::bar(), 10);\n+   |                ^^^^^^^^^^^^ use of undeclared type or module `mod_file_aux`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0583`.\n+Some errors have detailed explanations: E0433, E0583.\n+For more information about an error, try `rustc --explain E0433`."}, {"sha": "cd1add73d58400b7ea41d757995f34b334a1e831", "filename": "src/test/ui/parser/mod_file_with_path_attr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_with_path_attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fmod_file_with_path_attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmod_file_with_path_attr.stderr?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -1,8 +1,8 @@\n error: couldn't read $DIR/not_a_real_file.rs: $FILE_NOT_FOUND_MSG (os error 2)\n-  --> $DIR/mod_file_with_path_attr.rs:4:5\n+  --> $DIR/mod_file_with_path_attr.rs:4:1\n    |\n LL | mod m;\n-   |     ^\n+   | ^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "1b4669a439ffe0fa574d11fc406769f6d74c796f", "filename": "src/test/ui/parser/stripped-nested-outline-mod-pass.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fstripped-nested-outline-mod-pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b79d83f2472bb310b4bb53f0bccbbaaab00044/src%2Ftest%2Fui%2Fparser%2Fstripped-nested-outline-mod-pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstripped-nested-outline-mod-pass.rs?ref=23b79d83f2472bb310b4bb53f0bccbbaaab00044", "patch": "@@ -0,0 +1,13 @@\n+// Expansion drives parsing, so conditional compilation will strip\n+// out outline modules and we will never attempt parsing them.\n+\n+// check-pass\n+\n+fn main() {}\n+\n+#[cfg(FALSE)]\n+mod foo {\n+    mod bar {\n+        mod baz; // This was an error before.\n+    }\n+}"}]}