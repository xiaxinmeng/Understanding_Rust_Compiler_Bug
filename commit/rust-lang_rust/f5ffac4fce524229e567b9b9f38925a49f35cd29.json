{"sha": "f5ffac4fce524229e567b9b9f38925a49f35cd29", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1ZmZhYzRmY2U1MjQyMjllNTY3YjliOWYzODkyNWE0OWYzNWNkMjk=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-09-26T04:52:36Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2018-09-26T04:52:36Z"}, "message": "Implement unnecesary_filter_map lint", "tree": {"sha": "11fd17ac5135eca902987bf988d8ea841e40d38b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/11fd17ac5135eca902987bf988d8ea841e40d38b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5ffac4fce524229e567b9b9f38925a49f35cd29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ffac4fce524229e567b9b9f38925a49f35cd29", "html_url": "https://github.com/rust-lang/rust/commit/f5ffac4fce524229e567b9b9f38925a49f35cd29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5ffac4fce524229e567b9b9f38925a49f35cd29/comments", "author": null, "committer": null, "parents": [{"sha": "cdde22c2cc01c62474b2b73a93e6ad4a4498e230", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdde22c2cc01c62474b2b73a93e6ad4a4498e230", "html_url": "https://github.com/rust-lang/rust/commit/cdde22c2cc01c62474b2b73a93e6ad4a4498e230"}], "stats": {"total": 217, "additions": 214, "deletions": 3}, "files": [{"sha": "c9bea1e8ef5ebe9e90d7838a5957c9782f577865", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5ffac4fce524229e567b9b9f38925a49f35cd29/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/f5ffac4fce524229e567b9b9f38925a49f35cd29/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=f5ffac4fce524229e567b9b9f38925a49f35cd29", "patch": "@@ -864,6 +864,7 @@ All notable changes to this project will be documented in this file.\n [`unit_arg`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unit_arg\n [`unit_cmp`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unit_cmp\n [`unnecessary_cast`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unnecessary_cast\n+[`unnecessary_filter_map`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n [`unnecessary_fold`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unnecessary_fold\n [`unnecessary_mut_passed`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang-nursery.github.io/rust-clippy/master/index.html#unnecessary_operation"}, {"sha": "b8684b38631af0f3567e216253076dd3115cf837", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ffac4fce524229e567b9b9f38925a49f35cd29/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/f5ffac4fce524229e567b9b9f38925a49f35cd29/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=f5ffac4fce524229e567b9b9f38925a49f35cd29", "patch": "@@ -9,7 +9,7 @@ We are currently in the process of discussing Clippy 1.0 via the RFC process in\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 278 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n+[There are 279 lints included in this crate!](https://rust-lang-nursery.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "9af4850b15c2cb72b111bf41500153cd94a22b92", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5ffac4fce524229e567b9b9f38925a49f35cd29/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ffac4fce524229e567b9b9f38925a49f35cd29/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f5ffac4fce524229e567b9b9f38925a49f35cd29", "patch": "@@ -614,6 +614,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         methods::SINGLE_CHAR_PATTERN,\n         methods::STRING_EXTEND_CHARS,\n         methods::TEMPORARY_CSTRING_AS_PTR,\n+        methods::UNNECESSARY_FILTER_MAP,\n         methods::UNNECESSARY_FOLD,\n         methods::USELESS_ASREF,\n         methods::WRONG_SELF_CONVENTION,\n@@ -829,6 +830,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n         methods::CLONE_ON_COPY,\n         methods::FILTER_NEXT,\n         methods::SEARCH_IS_SOME,\n+        methods::UNNECESSARY_FILTER_MAP,\n         methods::USELESS_ASREF,\n         misc::SHORT_CIRCUIT_STATEMENT,\n         misc_early::REDUNDANT_CLOSURE_CALL,"}, {"sha": "a0c9e34b8619e9a6a9890363f3453c343a155c6b", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 165, "deletions": 1, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/f5ffac4fce524229e567b9b9f38925a49f35cd29/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ffac4fce524229e567b9b9f38925a49f35cd29/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=f5ffac4fce524229e567b9b9f38925a49f35cd29", "patch": "@@ -1,5 +1,6 @@\n use crate::rustc::hir;\n use crate::rustc::hir::def::Def;\n+use crate::rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use crate::rustc::lint::{in_external_macro, LateContext, LateLintPass, Lint, LintArray, LintContext, LintPass};\n use crate::rustc::ty::{self, Ty};\n use crate::rustc::{declare_tool_lint, lint_array};\n@@ -8,6 +9,7 @@ use crate::syntax::ast;\n use crate::syntax::source_map::{BytePos, Span};\n use crate::utils::paths;\n use crate::utils::sugg;\n+use crate::utils::usage::mutated_variables;\n use crate::utils::{\n     get_arg_name, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of, is_self, is_self_ty,\n     iter_input_pats, last_path_segment, match_def_path, match_path, match_qpath, match_trait_method, match_type,\n@@ -692,6 +694,27 @@ declare_clippy_lint! {\n     \"using `fold` when a more succinct alternative exists\"\n }\n \n+\n+/// **What it does:** Checks for `filter_map` calls which could be replaced by `filter` or `map`.\n+///\n+/// **Why is this bad?** Complexity\n+///\n+/// **Known problems:** None\n+///\n+/// **Example:**\n+/// ```rust\n+/// let _ = (0..3).filter_map(|x| if x > 2 { Some(x) } else { None });\n+/// ```\n+/// This could be written as:\n+/// ```rust\n+/// let _ = (0..3).filter(|&x| x > 2);\n+/// ```\n+declare_clippy_lint! {\n+    pub UNNECESSARY_FILTER_MAP,\n+    complexity,\n+    \"using `filter_map` when a more succinct alternative exists\"\n+}\n+\n impl LintPass for Pass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n@@ -725,7 +748,8 @@ impl LintPass for Pass {\n             STRING_EXTEND_CHARS,\n             ITER_CLONED_COLLECT,\n             USELESS_ASREF,\n-            UNNECESSARY_FOLD\n+            UNNECESSARY_FOLD,\n+            UNNECESSARY_FILTER_MAP\n         )\n     }\n }\n@@ -791,6 +815,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     lint_asref(cx, expr, \"as_mut\", arglists[0]);\n                 } else if let Some(arglists) = method_chain_args(expr, &[\"fold\"]) {\n                     lint_unnecessary_fold(cx, expr, arglists[0]);\n+                } else if let Some(arglists) = method_chain_args(expr, &[\"filter_map\"]) {\n+                    unnecessary_filter_map::lint(cx, expr, arglists[0]);\n                 }\n \n                 lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n@@ -1398,6 +1424,144 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n     };\n }\n \n+mod unnecessary_filter_map {\n+    use super::*;\n+\n+    pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr]) {\n+\n+        if !match_trait_method(cx, expr, &paths::ITERATOR) {\n+            return;\n+        }\n+\n+        if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].node {\n+\n+            let body = cx.tcx.hir.body(body_id);\n+            let arg_id = body.arguments[0].pat.id;\n+            let mutates_arg = match mutated_variables(&body.value, cx) {\n+                    Some(used_mutably) => used_mutably.contains(&arg_id),\n+                    None => true,\n+            };\n+\n+            let (mut found_mapping, mut found_filtering) = check_expression(&cx, arg_id, &body.value);\n+\n+            let mut return_visitor = ReturnVisitor::new(&cx, arg_id);\n+            return_visitor.visit_expr(&body.value);\n+            found_mapping |= return_visitor.found_mapping;\n+            found_filtering |= return_visitor.found_filtering;\n+\n+            if !found_filtering {\n+                span_lint(\n+                    cx,\n+                    UNNECESSARY_FILTER_MAP,\n+                    expr.span,\n+                    \"this `.filter_map` can be written more simply using `.map`\",\n+                );\n+                return;\n+            }\n+\n+            if !found_mapping && !mutates_arg {\n+                span_lint(\n+                    cx,\n+                    UNNECESSARY_FILTER_MAP,\n+                    expr.span,\n+                    \"this `.filter_map` can be written more simply using `.filter`\",\n+                );\n+                return;\n+            }\n+        }\n+    }\n+\n+    // returns (found_mapping, found_filtering)\n+    fn check_expression<'a, 'tcx: 'a>(cx: &'a LateContext<'a, 'tcx>, arg_id: ast::NodeId, expr: &'tcx hir::Expr) -> (bool, bool) {\n+        match &expr.node {\n+            hir::ExprKind::Call(ref func, ref args) => {\n+                if_chain! {\n+                    if let hir::ExprKind::Path(ref path) = func.node;\n+                    then {\n+                        if match_qpath(path, &paths::OPTION_SOME) {\n+                            if_chain! {\n+                                if let hir::ExprKind::Path(path) = &args[0].node;\n+                                if let Def::Local(ref local) = cx.tables.qpath_def(path, args[0].hir_id);\n+                                then {\n+                                    if arg_id == *local {\n+                                        return (false, false)\n+                                    }\n+                                }\n+                            }\n+                            return (true, false);\n+                        } else {\n+                            // We don't know. It might do anything.\n+                            return (true, true);\n+                        }\n+                    }\n+                }\n+                (true, true)\n+            },\n+            hir::ExprKind::Block(ref block, _) => {\n+                if let Some(expr) = &block.expr {\n+                    check_expression(cx, arg_id, &expr)\n+                } else {\n+                    (false, false)\n+                }\n+            },\n+            // There must be an else_arm or there will be a type error\n+            hir::ExprKind::If(_, ref if_arm, Some(ref else_arm)) => {\n+                let if_check = check_expression(cx, arg_id, if_arm);\n+                let else_check = check_expression(cx, arg_id, else_arm);\n+                (if_check.0 | else_check.0, if_check.1 | else_check.1)\n+            },\n+            hir::ExprKind::Match(_, ref arms, _) => {\n+                let mut found_mapping = false;\n+                let mut found_filtering = false;\n+                for arm in arms {\n+                    let (m, f) = check_expression(cx, arg_id, &arm.body);\n+                    found_mapping |= m;\n+                    found_filtering |= f;\n+                }\n+                (found_mapping, found_filtering)\n+            },\n+            hir::ExprKind::Path(path) if match_qpath(path, &paths::OPTION_NONE) => (false, true),\n+            _ => (true, true)\n+        }\n+    }\n+\n+    struct ReturnVisitor<'a, 'tcx: 'a> {\n+        cx: &'a LateContext<'a, 'tcx>,\n+        arg_id: ast::NodeId,\n+        // Found a non-None return that isn't Some(input)\n+        found_mapping: bool,\n+        // Found a return that isn't Some\n+        found_filtering: bool,\n+    }\n+\n+    impl<'a, 'tcx: 'a> ReturnVisitor<'a, 'tcx> {\n+        fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: ast::NodeId) -> ReturnVisitor<'a, 'tcx> {\n+            ReturnVisitor {\n+                cx,\n+                arg_id,\n+                found_mapping: false,\n+                found_filtering: false,\n+            }\n+        }\n+    }\n+\n+    impl<'a, 'tcx> Visitor<'tcx> for ReturnVisitor<'a, 'tcx> {\n+        fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+            if let hir::ExprKind::Ret(Some(expr)) = &expr.node {\n+                let (found_mapping, found_filtering) = check_expression(self.cx, self.arg_id, expr);\n+                self.found_mapping |= found_mapping;\n+                self.found_filtering |= found_filtering;\n+            } else {\n+                walk_expr(self, expr);\n+            }\n+        }\n+\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+            NestedVisitorMap::None\n+        }\n+    }\n+}\n+\n fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {"}, {"sha": "111c6ce5a8c579e6a664be46a60bcf5b964faee1", "filename": "tests/ui/methods.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f5ffac4fce524229e567b9b9f38925a49f35cd29/tests%2Fui%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5ffac4fce524229e567b9b9f38925a49f35cd29/tests%2Fui%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.rs?ref=f5ffac4fce524229e567b9b9f38925a49f35cd29", "patch": "@@ -443,3 +443,17 @@ fn main() {\n     let opt = Some(0);\n     let _ = opt.unwrap();\n }\n+\n+/// Checks implementation of `UNNECESSARY_FILTER_MAP` lint\n+fn unnecessary_filter_map() {\n+    let _ = (0..4).filter_map(|x| if x > 1 { Some(x) } else { None });\n+    let _ = (0..4).filter_map(|x| { if x > 1 { return Some(x); }; None });\n+    let _ = (0..4).filter_map(|x| match x {\n+        0 | 1 => None,\n+        _ => Some(x),\n+    });\n+\n+    let _ = (0..4).filter_map(|x| Some(x + 1));\n+\n+    let _ = (0..4).filter_map(i32::checked_abs);\n+}"}, {"sha": "b006813e26d0037616c14ec26e679cfcabb4b076", "filename": "tests/ui/methods.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f5ffac4fce524229e567b9b9f38925a49f35cd29/tests%2Fui%2Fmethods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5ffac4fce524229e567b9b9f38925a49f35cd29/tests%2Fui%2Fmethods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmethods.stderr?ref=f5ffac4fce524229e567b9b9f38925a49f35cd29", "patch": "@@ -453,5 +453,35 @@ error: used unwrap() on an Option value. If you don't want to handle the None ca\n     |\n     = note: `-D clippy::option-unwrap-used` implied by `-D warnings`\n \n-error: aborting due to 56 previous errors\n+error: this `.filter_map` can be written more simply using `.filter`\n+   --> $DIR/methods.rs:449:13\n+    |\n+449 |     let _ = (0..4).filter_map(|x| if x > 1 { Some(x) } else { None });\n+    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    |\n+    = note: `-D clippy::unnecessary-filter-map` implied by `-D warnings`\n+\n+error: this `.filter_map` can be written more simply using `.filter`\n+   --> $DIR/methods.rs:450:13\n+    |\n+450 |     let _ = (0..4).filter_map(|x| { if x > 1 { return Some(x); }; None });\n+    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this `.filter_map` can be written more simply using `.filter`\n+   --> $DIR/methods.rs:451:13\n+    |\n+451 |       let _ = (0..4).filter_map(|x| match x {\n+    |  _____________^\n+452 | |         0 | 1 => None,\n+453 | |         _ => Some(x),\n+454 | |     });\n+    | |______^\n+\n+error: this `.filter_map` can be written more simply using `.map`\n+   --> $DIR/methods.rs:456:13\n+    |\n+456 |     let _ = (0..4).filter_map(|x| Some(x + 1));\n+    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 60 previous errors\n "}]}