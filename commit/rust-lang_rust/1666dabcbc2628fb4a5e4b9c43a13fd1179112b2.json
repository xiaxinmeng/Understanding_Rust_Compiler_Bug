{"sha": "1666dabcbc2628fb4a5e4b9c43a13fd1179112b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NjZkYWJjYmMyNjI4ZmI0YTVlNGI5YzQzYTEzZmQxMTc5MTEyYjI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-28T23:04:57Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T18:31:47Z"}, "message": "std: Remove ms-taking methods from timers", "tree": {"sha": "15de007539e273b21ef7c0f4bbcb35add797f9d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15de007539e273b21ef7c0f4bbcb35add797f9d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1666dabcbc2628fb4a5e4b9c43a13fd1179112b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1666dabcbc2628fb4a5e4b9c43a13fd1179112b2", "html_url": "https://github.com/rust-lang/rust/commit/1666dabcbc2628fb4a5e4b9c43a13fd1179112b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1666dabcbc2628fb4a5e4b9c43a13fd1179112b2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51e9728292ec4b89de095e2f0c2e92aa60927a88", "url": "https://api.github.com/repos/rust-lang/rust/commits/51e9728292ec4b89de095e2f0c2e92aa60927a88", "html_url": "https://github.com/rust-lang/rust/commit/51e9728292ec4b89de095e2f0c2e92aa60927a88"}], "stats": {"total": 221, "additions": 49, "deletions": 172}, "files": [{"sha": "d9d6bb0f1b3c68f34170f1de916203d64ab1836e", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 49, "deletions": 172, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/1666dabcbc2628fb4a5e4b9c43a13fd1179112b2/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1666dabcbc2628fb4a5e4b9c43a13fd1179112b2/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=1666dabcbc2628fb4a5e4b9c43a13fd1179112b2", "patch": "@@ -79,15 +79,10 @@ fn in_ms(d: Duration) -> u64 {\n \n /// Sleep the current task for the specified duration.\n pub fn sleep(duration: Duration) {\n-    sleep_ms(in_ms(duration))\n-}\n-\n-/// Sleep the current task for `msecs` milliseconds.\n-pub fn sleep_ms(msecs: u64) {\n     let timer = Timer::new();\n     let mut timer = timer.ok().expect(\"timer::sleep: could not create a Timer\");\n \n-    timer.sleep_ms(msecs)\n+    timer.sleep(duration)\n }\n \n impl Timer {\n@@ -108,14 +103,6 @@ impl Timer {\n         self.obj.sleep(in_ms(duration));\n     }\n \n-    /// Blocks the current task for `msecs` milliseconds.\n-    ///\n-    /// Note that this function will cause any other receivers for this timer to\n-    /// be invalidated (the other end will be closed).\n-    pub fn sleep_ms(&mut self, msecs: u64) {\n-        self.obj.sleep(msecs);\n-    }\n-\n     /// Creates a oneshot receiver which will have a notification sent when\n     /// the specified duration has elapsed.\n     ///\n@@ -133,46 +120,6 @@ impl Timer {\n         return rx\n     }\n \n-    /// Creates a oneshot receiver which will have a notification sent when\n-    /// `msecs` milliseconds has elapsed.\n-    ///\n-    /// This does *not* block the current task, but instead returns immediately.\n-    ///\n-    /// Note that this invalidates any previous receiver which has been created\n-    /// by this timer, and that the returned receiver will be invalidated once\n-    /// the timer is destroyed (when it falls out of scope). In particular, if\n-    /// this is called in method-chaining style, the receiver will be\n-    /// invalidated at the end of that statement, and all `recv` calls will\n-    /// fail.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::io::Timer;\n-    ///\n-    /// let mut timer = Timer::new().unwrap();\n-    /// let ten_milliseconds = timer.oneshot(10);\n-    ///\n-    /// for _ in range(0u, 100) { /* do work */ }\n-    ///\n-    /// // blocks until 10 ms after the `oneshot` call\n-    /// ten_milliseconds.recv();\n-    /// ```\n-    ///\n-    /// ```rust\n-    /// use std::io::Timer;\n-    ///\n-    /// // Incorrect, method chaining-style:\n-    /// let mut five_ms = Timer::new().unwrap().oneshot(5);\n-    /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv()\n-    /// ```\n-    pub fn oneshot_ms(&mut self, msecs: u64) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-        self.obj.oneshot(msecs, box TimerCallback { tx: tx });\n-        return rx\n-    }\n-\n     /// Creates a receiver which will have a continuous stream of notifications\n     /// being sent each time the specified duration has elapsed.\n     ///\n@@ -191,54 +138,6 @@ impl Timer {\n         self.obj.period(in_ms(duration), box TimerCallback { tx: tx });\n         return rx\n     }\n-\n-    /// Creates a receiver which will have a continuous stream of notifications\n-    /// being sent every `msecs` milliseconds.\n-    ///\n-    /// This does *not* block the current task, but instead returns\n-    /// immediately. The first notification will not be received immediately,\n-    /// but rather after `msec` milliseconds have passed.\n-    ///\n-    /// Note that this invalidates any previous receiver which has been created\n-    /// by this timer, and that the returned receiver will be invalidated once\n-    /// the timer is destroyed (when it falls out of scope). In particular, if\n-    /// this is called in method-chaining style, the receiver will be\n-    /// invalidated at the end of that statement, and all `recv` calls will\n-    /// fail.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::io::Timer;\n-    ///\n-    /// let mut timer = Timer::new().unwrap();\n-    /// let ten_milliseconds = timer.periodic(10);\n-    ///\n-    /// for _ in range(0u, 100) { /* do work */ }\n-    ///\n-    /// // blocks until 10 ms after the `periodic` call\n-    /// ten_milliseconds.recv();\n-    ///\n-    /// for _ in range(0u, 100) { /* do work */ }\n-    ///\n-    /// // blocks until 20 ms after the `periodic` call (*not* 10ms after the\n-    /// // previous `recv`)\n-    /// ten_milliseconds.recv();\n-    /// ```\n-    ///\n-    /// ```rust\n-    /// use std::io::Timer;\n-    ///\n-    /// // Incorrect, method chaining-style.\n-    /// let mut five_ms = Timer::new().unwrap().periodic(5);\n-    /// // The timer object was destroyed, so this will always fail:\n-    /// // five_ms.recv()\n-    /// ```\n-    pub fn periodic_ms(&mut self, msecs: u64) -> Receiver<()> {\n-        let (tx, rx) = channel();\n-        self.obj.period(msecs, box TimerCallback { tx: tx });\n-        return rx\n-    }\n }\n \n impl Callback for TimerCallback {\n@@ -249,101 +148,103 @@ impl Callback for TimerCallback {\n \n #[cfg(test)]\n mod test {\n-    iotest!(fn test_io_timer_sleep_ms_simple() {\n+    use time::Duration;\n+\n+    iotest!(fn test_io_timer_sleep_simple() {\n         let mut timer = Timer::new().unwrap();\n-        timer.sleep_ms(1);\n+        timer.sleep(Duration::milliseconds(1));\n     })\n \n-    iotest!(fn test_io_timer_sleep_oneshot_ms() {\n+    iotest!(fn test_io_timer_sleep_oneshot() {\n         let mut timer = Timer::new().unwrap();\n-        timer.oneshot_ms(1).recv();\n+        timer.oneshot(Duration::milliseconds(1)).recv();\n     })\n \n-    iotest!(fn test_io_timer_sleep_oneshot_ms_forget() {\n+    iotest!(fn test_io_timer_sleep_oneshot_forget() {\n         let mut timer = Timer::new().unwrap();\n-        timer.oneshot_ms(100000000000);\n+        timer.oneshot(Duration::milliseconds(100000000000));\n     })\n \n-    iotest!(fn oneshot_ms_twice() {\n+    iotest!(fn oneshot_twice() {\n         let mut timer = Timer::new().unwrap();\n-        let rx1 = timer.oneshot_ms(10000);\n-        let rx = timer.oneshot_ms(1);\n+        let rx1 = timer.oneshot(Duration::milliseconds(10000));\n+        let rx = timer.oneshot(1);\n         rx.recv();\n         assert_eq!(rx1.recv_opt(), Err(()));\n     })\n \n-    iotest!(fn test_io_timer_oneshot_ms_then_sleep() {\n+    iotest!(fn test_io_timer_oneshot_then_sleep() {\n         let mut timer = Timer::new().unwrap();\n-        let rx = timer.oneshot_ms(100000000000);\n-        timer.sleep_ms(1); // this should invalidate rx\n+        let rx = timer.oneshot(Duration::milliseconds(100000000000));\n+        timer.sleep(Duration::milliseconds(1)); // this should invalidate rx\n \n         assert_eq!(rx.recv_opt(), Err(()));\n     })\n \n-    iotest!(fn test_io_timer_sleep_periodic_ms() {\n+    iotest!(fn test_io_timer_sleep_periodic() {\n         let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic_ms(1);\n+        let rx = timer.periodic(Duration::milliseconds(1));\n         rx.recv();\n         rx.recv();\n         rx.recv();\n     })\n \n-    iotest!(fn test_io_timer_sleep_periodic_ms_forget() {\n+    iotest!(fn test_io_timer_sleep_periodic_forget() {\n         let mut timer = Timer::new().unwrap();\n-        timer.periodic_ms(100000000000);\n+        timer.periodic(Duration::milliseconds(100000000000));\n     })\n \n-    iotest!(fn test_io_timer_sleep_ms_standalone() {\n-        sleep_ms(1)\n+    iotest!(fn test_io_timer_sleep_standalone() {\n+        sleep(Duration::milliseconds(1))\n     })\n \n-    iotest!(fn oneshot_ms() {\n+    iotest!(fn oneshot() {\n         let mut timer = Timer::new().unwrap();\n \n-        let rx = timer.oneshot_ms(1);\n+        let rx = timer.oneshot(Duration::milliseconds(1));\n         rx.recv();\n         assert!(rx.recv_opt().is_err());\n \n-        let rx = timer.oneshot_ms(1);\n+        let rx = timer.oneshot(Duration::milliseconds(1));\n         rx.recv();\n         assert!(rx.recv_opt().is_err());\n     })\n \n     iotest!(fn override() {\n         let mut timer = Timer::new().unwrap();\n-        let orx = timer.oneshot_ms(100);\n-        let prx = timer.periodic_ms(100);\n-        timer.sleep_ms(1);\n+        let orx = timer.oneshot(Duration::milliseconds(100));\n+        let prx = timer.periodic(Duration::milliseconds(100));\n+        timer.sleep(Duration::milliseconds(1));\n         assert_eq!(orx.recv_opt(), Err(()));\n         assert_eq!(prx.recv_opt(), Err(()));\n-        timer.oneshot_ms(1).recv();\n+        timer.oneshot(Duration::milliseconds(1)).recv();\n     })\n \n-    iotest!(fn period_ms() {\n+    iotest!(fn period() {\n         let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic_ms(1);\n+        let rx = timer.periodic(Duration::milliseconds(1));\n         rx.recv();\n         rx.recv();\n-        let rx2 = timer.periodic_ms(1);\n+        let rx2 = timer.periodic(Durtion::milliseconds(1));\n         rx2.recv();\n         rx2.recv();\n     })\n \n-    iotest!(fn sleep_ms() {\n+    iotest!(fn sleep() {\n         let mut timer = Timer::new().unwrap();\n-        timer.sleep_ms(1);\n-        timer.sleep_ms(1);\n+        timer.sleep(Duration::milliseconds(1));\n+        timer.sleep(Duration::milliseconds(1));\n     })\n \n-    iotest!(fn oneshot_ms_fail() {\n+    iotest!(fn oneshot_fail() {\n         let mut timer = Timer::new().unwrap();\n-        let _rx = timer.oneshot_ms(1);\n+        let _rx = timer.oneshot(Duration::milliseconds(1));\n         fail!();\n     } #[should_fail])\n \n-    iotest!(fn period_ms_fail() {\n+    iotest!(fn period_fail() {\n         let mut timer = Timer::new().unwrap();\n-        let _rx = timer.periodic_ms(1);\n+        let _rx = timer.periodic(Duration::milliseconds(1));\n         fail!();\n     } #[should_fail])\n \n@@ -355,7 +256,7 @@ mod test {\n     iotest!(fn closing_channel_during_drop_doesnt_kill_everything() {\n         // see issue #10375\n         let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic_ms(1000);\n+        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n         spawn(proc() {\n             let _ = timer_rx.recv_opt();\n@@ -368,82 +269,58 @@ mod test {\n     iotest!(fn reset_doesnt_switch_tasks() {\n         // similar test to the one above.\n         let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic_ms(1000);\n+        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n         spawn(proc() {\n             let _ = timer_rx.recv_opt();\n         });\n \n-        timer.oneshot_ms(1);\n+        timer.oneshot(Duration::milliseconds(1));\n     })\n \n     iotest!(fn reset_doesnt_switch_tasks2() {\n         // similar test to the one above.\n         let mut timer = Timer::new().unwrap();\n-        let timer_rx = timer.periodic_ms(1000);\n+        let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n         spawn(proc() {\n             let _ = timer_rx.recv_opt();\n         });\n \n-        timer.sleep_ms(1);\n+        timer.sleep(Duration::milliseconds(1));\n     })\n \n     iotest!(fn sender_goes_away_oneshot() {\n         let rx = {\n             let mut timer = Timer::new().unwrap();\n-            timer.oneshot_ms(1000)\n+            timer.oneshot(Duration::milliseconds(1000))\n         };\n         assert_eq!(rx.recv_opt(), Err(()));\n     })\n \n     iotest!(fn sender_goes_away_period() {\n         let rx = {\n             let mut timer = Timer::new().unwrap();\n-            timer.periodic_ms(1000)\n+            timer.periodic(Duration::milliseconds(1000))\n         };\n         assert_eq!(rx.recv_opt(), Err(()));\n     })\n \n     iotest!(fn receiver_goes_away_oneshot() {\n         let mut timer1 = Timer::new().unwrap();\n-        timer1.oneshot_ms(1);\n+        timer1.oneshot(Duration::milliseconds(1));\n         let mut timer2 = Timer::new().unwrap();\n         // while sleeping, the previous timer should fire and not have its\n         // callback do something terrible.\n-        timer2.sleep_ms(2);\n+        timer2.sleep(Duration::milliseconds(2));\n     })\n \n     iotest!(fn receiver_goes_away_period() {\n         let mut timer1 = Timer::new().unwrap();\n-        timer1.periodic_ms(1);\n+        timer1.periodic(Duration::milliseconds(1));\n         let mut timer2 = Timer::new().unwrap();\n         // while sleeping, the previous timer should fire and not have its\n         // callback do something terrible.\n-        timer2.sleep_ms(2);\n-    })\n-\n-\n-    iotest!(fn test_io_timer_sleep_duration_simple() {\n-        use time::Duration;\n-        let mut timer = Timer::new().unwrap();\n-        timer.sleep(Duration::seconds(1));\n-    })\n-\n-    iotest!(fn test_io_timer_sleep_oneshot_duration() {\n-        use time::Duration;\n-        let mut timer = Timer::new().unwrap();\n-        timer.oneshot(Duration::seconds(1)).recv();\n+        timer2.sleep(Duration::milliseconds(2));\n     })\n-\n-    iotest!(fn test_io_timer_sleep_periodic_duration() {\n-        use time::Duration;\n-        let mut timer = Timer::new().unwrap();\n-        let rx = timer.periodic(Duration::seconds(1));\n-        rx.recv();\n-        rx.recv();\n-        rx.recv();\n-    })\n-\n-\n }"}]}