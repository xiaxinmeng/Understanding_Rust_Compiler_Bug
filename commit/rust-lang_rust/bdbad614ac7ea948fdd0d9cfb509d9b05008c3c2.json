{"sha": "bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYmFkNjE0YWM3ZWE5NDhmZGQwZDljZmI1MDlkOWIwNTAwOGMzYzI=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-07T18:42:30Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-07T22:18:48Z"}, "message": "Remove rust_cond_lock and sys::condition (rename to little_lock)", "tree": {"sha": "f9dbfb1ce10048c92d24b0f2d05b14750170c769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f9dbfb1ce10048c92d24b0f2d05b14750170c769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "html_url": "https://github.com/rust-lang/rust/commit/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32e4fd62e968cba994aa4e4a85b00c072fe58bc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/32e4fd62e968cba994aa4e4a85b00c072fe58bc1", "html_url": "https://github.com/rust-lang/rust/commit/32e4fd62e968cba994aa4e4a85b00c072fe58bc1"}], "stats": {"total": 180, "additions": 39, "deletions": 141}, "files": [{"sha": "f51c7b1caefdb1b0f134364c1c239a4c2efb54bd", "filename": "mk/rt.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "patch": "@@ -71,7 +71,6 @@ RUNTIME_CS_$(1) := \\\n               rt/rust_cc.cpp \\\n               rt/rust_debug.cpp \\\n               rt/rust_box_annihilator.cpp \\\n-              rt/rust_cond_lock.cpp \\\n               rt/memory_region.cpp \\\n               rt/boxed_region.cpp \\\n               rt/arch/$$(HOST_$(1))/context.cpp \\"}, {"sha": "c84db57bd39938e77b8a3cfc716840dbbd639554", "filename": "src/libcore/arc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Flibcore%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Flibcore%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farc.rs?ref=bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "patch": "@@ -83,11 +83,11 @@ fn clone<T: const send>(rc: &arc<T>) -> arc<T> {\n }\n \n // An arc over mutable data that is protected by a lock.\n-type ex_data<T: send> = {lock: sys::lock_and_signal, mut data: T};\n+type ex_data<T: send> = {lock: sys::little_lock, mut data: T};\n type exclusive<T: send> = arc_destruct<ex_data<T>>;\n \n fn exclusive<T:send >(-data: T) -> exclusive<T> {\n-    let data = ~{mut count: 1, data: {lock: sys::lock_and_signal(),\n+    let data = ~{mut count: 1, data: {lock: sys::little_lock(),\n                                       data: data}};\n     unsafe {\n         let ptr = unsafe::reinterpret_cast(data);\n@@ -126,13 +126,13 @@ impl methods<T: send> for exclusive<T> {\n      * will guarantee a memory leak of all involved ARCs. Using exclusive\n      * ARCs inside of other ARCs is safe in absence of circular references.\n      */\n-    unsafe fn with<U>(f: fn(sys::condition, x: &mut T) -> U) -> U {\n+    unsafe fn with<U>(f: fn(x: &mut T) -> U) -> U {\n         let ptr: ~arc_data<ex_data<T>> =\n             unsafe::reinterpret_cast(self.data);\n         assert ptr.count > 0;\n         let r = {\n             let rec: &ex_data<T> = &(*ptr).data;\n-            rec.lock.lock_cond(|c| f(c, &mut rec.data))\n+            do rec.lock.lock { f(&mut rec.data) }\n         };\n         unsafe::forget(ptr);\n         r\n@@ -184,7 +184,7 @@ mod tests {\n             let total = total.clone();\n             futures += ~[future::spawn(|| {\n                 for uint::range(0u, count) |_i| {\n-                    do total.with |_cond, count| {\n+                    do total.with |count| {\n                         **count += 1u;\n                     }\n                 }\n@@ -193,7 +193,7 @@ mod tests {\n \n         for futures.each |f| { f.get() }\n \n-        do total.with |_cond, total| {\n+        do total.with |total| {\n             assert **total == num_tasks * count\n         };\n     }"}, {"sha": "0d684a99cbaa03eabebe95004aac01e6ced94005", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "patch": "@@ -1027,7 +1027,7 @@ type shared_chan<T: send> = arc::exclusive<chan<T>>;\n impl chan<T: send> of channel<T> for shared_chan<T> {\n     fn send(+x: T) {\n         let mut xx = some(x);\n-        do self.with |_c, chan| {\n+        do self.with |chan| {\n             let mut x = none;\n             x <-> xx;\n             chan.send(option::unwrap(x))"}, {"sha": "879865a988a181df92dd1b3c09c81e5ed12aecb6", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 18, "deletions": 63, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "patch": "@@ -7,7 +7,7 @@ export min_align_of;\n export pref_align_of;\n export refcount;\n export log_str;\n-export lock_and_signal, condition, methods;\n+export little_lock, methods;\n export shape_eq, shape_lt, shape_le;\n \n import task::atomically;\n@@ -18,18 +18,16 @@ enum type_desc = {\n     // Remaining fields not listed\n };\n \n-type rust_cond_lock = *libc::c_void;\n+type rust_little_lock = *libc::c_void;\n \n #[abi = \"cdecl\"]\n extern mod rustrt {\n     pure fn shape_log_str(t: *sys::type_desc, data: *()) -> ~str;\n \n-    fn rust_create_cond_lock() -> rust_cond_lock;\n-    fn rust_destroy_cond_lock(lock: rust_cond_lock);\n-    fn rust_lock_cond_lock(lock: rust_cond_lock);\n-    fn rust_unlock_cond_lock(lock: rust_cond_lock);\n-    fn rust_wait_cond_lock(lock: rust_cond_lock);\n-    fn rust_signal_cond_lock(lock: rust_cond_lock) -> bool;\n+    fn rust_create_little_lock() -> rust_little_lock;\n+    fn rust_destroy_little_lock(lock: rust_little_lock);\n+    fn rust_lock_little_lock(lock: rust_little_lock);\n+    fn rust_unlock_little_lock(lock: rust_little_lock);\n }\n \n #[abi = \"rust-intrinsic\"]\n@@ -100,52 +98,30 @@ pure fn log_str<T>(t: T) -> ~str {\n     }\n }\n \n-class lock_and_signal {\n-    let lock: rust_cond_lock;\n+class little_lock {\n+    let l: rust_little_lock;\n     new() {\n-        self.lock = rustrt::rust_create_cond_lock();\n+        self.l = rustrt::rust_create_little_lock();\n     }\n-    drop { rustrt::rust_destroy_cond_lock(self.lock); }\n+    drop { rustrt::rust_destroy_little_lock(self.l); }\n }\n \n-enum condition {\n-    condition_(rust_cond_lock)\n-}\n-\n-class unlock {\n-    let lock: rust_cond_lock;\n-    new(lock: rust_cond_lock) { self.lock = lock; }\n-    drop { rustrt::rust_unlock_cond_lock(self.lock); }\n-}\n-\n-impl methods for lock_and_signal {\n+impl methods for little_lock {\n     unsafe fn lock<T>(f: fn() -> T) -> T {\n-        do atomically {\n-            rustrt::rust_lock_cond_lock(self.lock);\n-            let _r = unlock(self.lock);\n-            f()\n+        class unlock {\n+            let l: rust_little_lock;\n+            new(l: rust_little_lock) { self.l = l; }\n+            drop { rustrt::rust_unlock_little_lock(self.l); }\n         }\n-    }\n \n-    unsafe fn lock_cond<T>(f: fn(condition) -> T) -> T {\n         do atomically {\n-            rustrt::rust_lock_cond_lock(self.lock);\n-            let _r = unlock(self.lock);\n-            f(condition_(self.lock))\n+            rustrt::rust_lock_little_lock(self.l);\n+            let _r = unlock(self.l);\n+            f()\n         }\n     }\n }\n \n-impl methods for condition {\n-    fn wait() {\n-        rustrt::rust_wait_cond_lock(*self);\n-    }\n-\n-    fn signal() -> bool {\n-        rustrt::rust_signal_cond_lock(*self)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n \n@@ -193,27 +169,6 @@ mod tests {\n         assert pref_align_of::<uint>() == 8u;\n         assert pref_align_of::<*uint>() == 8u;\n     }\n-\n-    #[test]\n-    #[ignore] // this can go into infinite loops\n-    fn condition_variable() {\n-        let lock = arc::arc(lock_and_signal());\n-        let lock2 = arc::clone(&lock);\n-\n-        do task::spawn |move lock2| {\n-            let lock = arc::get(&lock2);\n-            do (*lock).lock_cond |c| {\n-                c.wait();\n-            }\n-        }\n-\n-        let mut signaled = false;\n-        while !signaled {\n-            do (*arc::get(&lock)).lock_cond |c| {\n-                signaled = c.signal()\n-            }\n-        }\n-    }\n }\n \n // Local Variables:"}, {"sha": "04882373b3723b0701c1734948cfbdbc5330f2a8", "filename": "src/libcore/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "patch": "@@ -740,12 +740,12 @@ enum ancestor_list = option<arc::exclusive<ancestor_node>>;\n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n fn access_group<U>(x: taskgroup_arc, blk: fn(taskgroup_inner) -> U) -> U {\n-    unsafe { x.with(|_c, tg| blk(tg)) }\n+    unsafe { x.with(blk) }\n }\n #[inline(always)]\n fn access_ancestors<U>(x: arc::exclusive<ancestor_node>,\n                        blk: fn(x: &mut ancestor_node) -> U) -> U {\n-    unsafe { x.with(|_c, nobe| blk(nobe)) }\n+    unsafe { x.with(blk) }\n }\n \n // Iterates over an ancestor list."}, {"sha": "465eb6efe38440f254ba7056db36d4e44ccc092e", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 8, "deletions": 41, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "patch": "@@ -7,7 +7,6 @@\n #include \"sync/timer.h\"\n #include \"rust_abi.h\"\n #include \"rust_port.h\"\n-#include \"rust_cond_lock.h\"\n \n #include <time.h>\n \n@@ -882,56 +881,24 @@ bool rust_task_is_unwinding(rust_task *rt) {\n     return rt->unwinding;\n }\n \n-extern \"C\" rust_cond_lock*\n-rust_create_cond_lock() {\n-    return new rust_cond_lock();\n+extern \"C\" lock_and_signal*\n+rust_create_little_lock() {\n+    return new lock_and_signal();\n }\n \n extern \"C\" void\n-rust_destroy_cond_lock(rust_cond_lock *lock) {\n+rust_destroy_little_lock(lock_and_signal *lock) {\n     delete lock;\n }\n \n extern \"C\" void\n-rust_lock_cond_lock(rust_cond_lock *lock) {\n-    lock->lock.lock();\n+rust_lock_little_lock(lock_and_signal *lock) {\n+    lock->lock();\n }\n \n extern \"C\" void\n-rust_unlock_cond_lock(rust_cond_lock *lock) {\n-    lock->lock.unlock();\n-}\n-\n-// The next two functions do not use the built in condition variable features\n-// because the Rust schedule is not aware of them, and they can block the\n-// scheduler thread.\n-\n-extern \"C\" void\n-rust_wait_cond_lock(rust_cond_lock *lock) {\n-    assert(false && \"condition->wait() is totally broken! Don't use it!\");\n-    rust_task *task = rust_get_current_task();\n-    lock->lock.must_have_lock();\n-    assert(NULL == lock->waiting);\n-    lock->waiting = task;\n-    task->block(lock, \"waiting for signal\");\n-    lock->lock.unlock();\n-    bool killed = task->yield();\n-    assert(!killed && \"unimplemented\");\n-    lock->lock.lock();\n-}\n-\n-extern \"C\" bool\n-rust_signal_cond_lock(rust_cond_lock *lock) {\n-    assert(false && \"condition->signal() is totally broken! Don't use it!\");\n-    lock->lock.must_have_lock();\n-    if(NULL == lock->waiting) {\n-        return false;\n-    }\n-    else {\n-        lock->waiting->wakeup(lock);\n-        lock->waiting = NULL;\n-        return true;\n-    }\n+rust_unlock_little_lock(lock_and_signal *lock) {\n+    lock->unlock();\n }\n \n // set/get/atexit task_local_data can run on the rust stack for speed."}, {"sha": "cdeccfdc26ca59e1a316a6f2f4e7e046a4c625c2", "filename": "src/rt/rust_cond_lock.cpp", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/32e4fd62e968cba994aa4e4a85b00c072fe58bc1/src%2Frt%2Frust_cond_lock.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/32e4fd62e968cba994aa4e4a85b00c072fe58bc1/src%2Frt%2Frust_cond_lock.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cond_lock.cpp?ref=32e4fd62e968cba994aa4e4a85b00c072fe58bc1", "patch": "@@ -1,6 +0,0 @@\n-#include \"rust_cond_lock.h\"\n-\n-rust_cond_lock::rust_cond_lock()\n-    : waiting(NULL)\n-{\n-}"}, {"sha": "0adafd59678ec349cb4c3c851097d5c22822f4be", "filename": "src/rt/rust_cond_lock.h", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/32e4fd62e968cba994aa4e4a85b00c072fe58bc1/src%2Frt%2Frust_cond_lock.h", "raw_url": "https://github.com/rust-lang/rust/raw/32e4fd62e968cba994aa4e4a85b00c072fe58bc1/src%2Frt%2Frust_cond_lock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_cond_lock.h?ref=32e4fd62e968cba994aa4e4a85b00c072fe58bc1", "patch": "@@ -1,15 +0,0 @@\n-// -*- c++ -*-\n-// A lock and condition variable pair that is useable from Rust.\n-\n-#pragma once\n-\n-#include \"sync/lock_and_signal.h\"\n-#include \"rust_globals.h\"\n-#include \"rust_task.h\"\n-\n-struct rust_cond_lock : public rust_cond {\n-    rust_cond_lock();\n-\n-    lock_and_signal lock;\n-    rust_task *waiting;\n-};"}, {"sha": "9710d4acb2795538f1ab85fc8818b0eafbecc1f8", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=bdbad614ac7ea948fdd0d9cfb509d9b05008c3c2", "patch": "@@ -185,12 +185,10 @@ rust_task_inhibit_yield\n rust_task_allow_yield\n rust_task_kill_other\n rust_task_kill_all\n-rust_create_cond_lock\n-rust_destroy_cond_lock\n-rust_lock_cond_lock\n-rust_unlock_cond_lock\n-rust_wait_cond_lock\n-rust_signal_cond_lock\n+rust_create_little_lock\n+rust_destroy_little_lock\n+rust_lock_little_lock\n+rust_unlock_little_lock\n rust_get_task_local_data\n rust_set_task_local_data\n rust_task_local_data_atexit"}]}