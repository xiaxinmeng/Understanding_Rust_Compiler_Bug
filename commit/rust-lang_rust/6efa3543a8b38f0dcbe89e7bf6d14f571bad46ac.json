{"sha": "6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZmEzNTQzYThiMzhmMGRjYmU4OWU3YmY2ZDE0ZjU3MWJhZDQ2YWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-14T02:49:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-14T02:49:29Z"}, "message": "auto merge of #4922 : jbclements/rust/add-deriving-eq-to-asts, r=catamorphism\n\nr?\r\n\r\nApply deriving_eq to the data structures in ast.rs, and get rid of the custom definitions of eq that were everywhere. resulting ast.rs is about 400 lines shorter.\r\n\r\nAlso: add a few test cases and a bunch of comments.\r\n\r\nAlso: change ast_ty_to_ty_cache to use node ids rather than ast::ty's. I believe this was a suggestion related to my changes, and it appears to pass all tests.\r\n\r\nAlso: tiny doc fix, remove references to crate keywords.", "tree": {"sha": "52ddd48eee689ac78b216e2165a63d9ea90ffa39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52ddd48eee689ac78b216e2165a63d9ea90ffa39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "html_url": "https://github.com/rust-lang/rust/commit/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ae74bef188fe4f1fff69c0fa85d308c40bce7f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ae74bef188fe4f1fff69c0fa85d308c40bce7f8", "html_url": "https://github.com/rust-lang/rust/commit/0ae74bef188fe4f1fff69c0fa85d308c40bce7f8"}, {"sha": "f9d789fa083220cc9d84cbea94868606600c64a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d789fa083220cc9d84cbea94868606600c64a9", "html_url": "https://github.com/rust-lang/rust/commit/f9d789fa083220cc9d84cbea94868606600c64a9"}], "stats": {"total": 796, "additions": 241, "deletions": 555}, "files": [{"sha": "3013fe0e0eb8edace2ad12631a2e5b89890d0593", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -202,13 +202,7 @@ grammar as double-quoted strings. Other tokens have exact rules given.\n \n ### Keywords\n \n-The keywords in [crate files](#crate-files) are the following strings:\n-\n-~~~~~~~~ {.keyword}\n-mod priv pub use\n-~~~~~~~~\n-\n-The keywords in [source files](#source-files) are the following strings:\n+The keywords are the following strings:\n \n ~~~~~~~~ {.keyword}\n as assert"}, {"sha": "23c9f349cdbdf45a39c33df02300130b1da17d11", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -262,7 +262,7 @@ struct ctxt_ {\n     needs_drop_cache: HashMap<t, bool>,\n     needs_unwind_cleanup_cache: HashMap<t, bool>,\n     mut tc_cache: LinearMap<uint, TypeContents>,\n-    ast_ty_to_ty_cache: HashMap<@ast::Ty, ast_ty_to_ty_cache_entry>,\n+    ast_ty_to_ty_cache: HashMap<node_id, ast_ty_to_ty_cache_entry>,\n     enum_var_cache: HashMap<def_id, @~[VariantInfo]>,\n     trait_method_cache: HashMap<def_id, @~[method]>,\n     ty_param_bounds: HashMap<ast::node_id, param_bounds>,"}, {"sha": "3ee604426c9f78737cd056971e7a6e97b6997f04", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -277,7 +277,7 @@ pub fn ast_ty_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n \n     let tcx = self.tcx();\n \n-    match tcx.ast_ty_to_ty_cache.find(&ast_ty) {\n+    match tcx.ast_ty_to_ty_cache.find(&ast_ty.id) {\n       Some(ty::atttce_resolved(ty)) => return ty,\n       Some(ty::atttce_unresolved) => {\n         tcx.sess.span_fatal(ast_ty.span, ~\"illegal recursive type; \\\n@@ -287,7 +287,7 @@ pub fn ast_ty_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n       None => { /* go on */ }\n     }\n \n-    tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n+    tcx.ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_unresolved);\n     let typ = match /*bad*/copy ast_ty.node {\n       ast::ty_nil => ty::mk_nil(tcx),\n       ast::ty_bot => ty::mk_bot(tcx),\n@@ -409,7 +409,7 @@ pub fn ast_ty_to_ty<AC: AstConv, RS: region_scope Copy Durable>(\n       }\n     };\n \n-    tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_resolved(typ));\n+    tcx.ast_ty_to_ty_cache.insert(ast_ty.id, ty::atttce_resolved(typ));\n     return typ;\n }\n "}, {"sha": "053df524bf7da39ba4453fd35665f4d1f480a65d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 122, "deletions": 515, "changes": 637, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -69,6 +69,7 @@ pub type fn_ident = Option<ident>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct path {\n     span: span,\n     global: bool,\n@@ -83,23 +84,18 @@ pub type node_id = int;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct def_id {\n     crate: crate_num,\n     node: node_id,\n }\n \n-pub impl def_id : cmp::Eq {\n-    pure fn eq(&self, other: &def_id) -> bool {\n-        (*self).crate == (*other).crate && (*self).node == (*other).node\n-    }\n-    pure fn ne(&self, other: &def_id) -> bool { !(*self).eq(other) }\n-}\n-\n pub const local_crate: crate_num = 0;\n pub const crate_node_id: node_id = 0;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n@@ -111,6 +107,7 @@ pub enum ty_param_bound {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct ty_param {\n     ident: ident,\n     id: node_id,\n@@ -119,6 +116,7 @@ pub struct ty_param {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum def {\n     def_fn(def_id, purity),\n     def_static_method(/* method */ def_id,\n@@ -147,143 +145,16 @@ pub enum def {\n     def_label(node_id)\n }\n \n-pub impl def : cmp::Eq {\n-    pure fn eq(&self, other: &def) -> bool {\n-        match (*self) {\n-            def_fn(e0a, e1a) => {\n-                match (*other) {\n-                    def_fn(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_static_method(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    def_static_method(e0b, e1b, e2b) =>\n-                    e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            def_self(e0a, e1a) => {\n-                match (*other) {\n-                    def_self(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_self_ty(e0a) => {\n-                match (*other) {\n-                    def_self_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_mod(e0a) => {\n-                match (*other) {\n-                    def_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_foreign_mod(e0a) => {\n-                match (*other) {\n-                    def_foreign_mod(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_const(e0a) => {\n-                match (*other) {\n-                    def_const(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_arg(e0a, e1a, e2a) => {\n-                match (*other) {\n-                    def_arg(e0b, e1b, e2b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            def_local(e0a, e1a) => {\n-                match (*other) {\n-                    def_local(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_variant(e0a, e1a) => {\n-                match (*other) {\n-                    def_variant(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_ty(e0a) => {\n-                match (*other) {\n-                    def_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_prim_ty(e0a) => {\n-                match (*other) {\n-                    def_prim_ty(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_ty_param(e0a, e1a) => {\n-                match (*other) {\n-                    def_ty_param(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_binding(e0a, e1a) => {\n-                match (*other) {\n-                    def_binding(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            def_use(e0a) => {\n-                match (*other) {\n-                    def_use(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_upvar(e0a, e1a, e2a, e3a) => {\n-                match (*other) {\n-                    def_upvar(e0b, e1b, e2b, e3b) =>\n-                        e0a == e0b && e1a == e1b && e2a == e2b && e3a == e3b,\n-                    _ => false\n-                }\n-            }\n-            def_struct(e0a) => {\n-                match (*other) {\n-                    def_struct(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_typaram_binder(e0a) => {\n-                match (*other) {\n-                    def_typaram_binder(e1a) => e0a == e1a,\n-                    _ => false\n-                }\n-            }\n-            def_region(e0a) => {\n-                match (*other) {\n-                    def_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            def_label(e0a) => {\n-                match (*other) {\n-                    def_label(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &def) -> bool { !(*self).eq(other) }\n-}\n \n // The set of meta_items that define the compilation environment of the crate,\n // used to drive conditional compilation\n pub type crate_cfg = ~[@meta_item];\n \n pub type crate = spanned<crate_>;\n \n+#[auto_encode]\n+#[auto_decode]\n+#[deriving_eq]\n pub struct crate_ {\n     module: _mod,\n     attrs: ~[attribute],\n@@ -294,6 +165,7 @@ pub type meta_item = spanned<meta_item_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum meta_item_ {\n     meta_word(~str),\n     meta_list(~str, ~[@meta_item]),\n@@ -304,6 +176,7 @@ pub type blk = spanned<blk_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct blk_ {\n     view_items: ~[@view_item],\n     stmts: ~[@stmt],\n@@ -314,6 +187,7 @@ pub struct blk_ {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct pat {\n     id: node_id,\n     node: pat_,\n@@ -322,6 +196,7 @@ pub struct pat {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct field_pat {\n     ident: ident,\n     pat: @pat,\n@@ -352,6 +227,7 @@ pub impl binding_mode : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -377,6 +253,7 @@ pub enum pat_ {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum mutability { m_mutbl, m_imm, m_const, }\n \n pub impl mutability : to_bytes::IterBytes {\n@@ -385,13 +262,6 @@ pub impl mutability : to_bytes::IterBytes {\n     }\n }\n \n-pub impl mutability : cmp::Eq {\n-    pure fn eq(&self, other: &mutability) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &mutability) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]\n@@ -440,6 +310,7 @@ pub impl Sigil : ToStr {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),   // [1,2,3,4]\n@@ -450,6 +321,7 @@ pub enum vstore {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum expr_vstore {\n     // FIXME (#3469): Change uint to @expr (actually only constant exprs)\n     expr_vstore_fixed(Option<uint>),   // [1,2,3,4]\n@@ -462,6 +334,7 @@ pub enum expr_vstore {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum binop {\n     add,\n     subtract,\n@@ -483,15 +356,9 @@ pub enum binop {\n     gt,\n }\n \n-pub impl binop : cmp::Eq {\n-    pure fn eq(&self, other: &binop) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -500,50 +367,11 @@ pub enum unop {\n     neg\n }\n \n-pub impl unop : cmp::Eq {\n-    pure fn eq(&self, other: &unop) -> bool {\n-        match (*self) {\n-            box(e0a) => {\n-                match (*other) {\n-                    box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            uniq(e0a) => {\n-                match (*other) {\n-                    uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            deref => {\n-                match (*other) {\n-                    deref => true,\n-                    _ => false\n-                }\n-            }\n-            not => {\n-                match (*other) {\n-                    not => true,\n-                    _ => false\n-                }\n-            }\n-            neg => {\n-                match (*other) {\n-                    neg => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &unop) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n // Generally, after typeck you can get the inferred value\n // using ty::resolved_T(...).\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum inferable<T> {\n     expl(T),\n     infer(node_id)\n@@ -561,29 +389,10 @@ pub impl<T: to_bytes::IterBytes> inferable<T> : to_bytes::IterBytes {\n     }\n }\n \n-pub impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n-    pure fn eq(&self, other: &inferable<T>) -> bool {\n-        match (*self) {\n-            expl(ref e0a) => {\n-                match (*other) {\n-                    expl(ref e0b) => (*e0a) == (*e0b),\n-                    _ => false\n-                }\n-            }\n-            infer(e0a) => {\n-                match (*other) {\n-                    infer(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &inferable<T>) -> bool { !(*self).eq(other) }\n-}\n-\n // \"resolved\" mode: the real modes.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum rmode { by_ref, by_val, by_copy }\n \n pub impl rmode : to_bytes::IterBytes {\n@@ -592,21 +401,14 @@ pub impl rmode : to_bytes::IterBytes {\n     }\n }\n \n-\n-pub impl rmode : cmp::Eq {\n-    pure fn eq(&self, other: &rmode) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &rmode) -> bool { !(*self).eq(other) }\n-}\n-\n // inferable mode.\n pub type mode = inferable<rmode>;\n \n pub type stmt = spanned<stmt_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n@@ -624,6 +426,7 @@ pub enum stmt_ {\n // a refinement on pat.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct local_ {\n     is_mutbl: bool,\n     ty: @Ty,\n@@ -638,10 +441,12 @@ pub type decl = spanned<decl_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct arm {\n     pats: ~[@pat],\n     guard: Option<@expr>,\n@@ -650,6 +455,7 @@ pub struct arm {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct field_ {\n     mutbl: mutability,\n     ident: ident,\n@@ -660,22 +466,12 @@ pub type field = spanned<field_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum blk_check_mode { default_blk, unsafe_blk, }\n \n-pub impl blk_check_mode : cmp::Eq {\n-    pure fn eq(&self, other: &blk_check_mode) -> bool {\n-        match ((*self), (*other)) {\n-            (default_blk, default_blk) => true,\n-            (unsafe_blk, unsafe_blk) => true,\n-            (default_blk, _) => false,\n-            (unsafe_blk, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &blk_check_mode) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct expr {\n     id: node_id,\n     // Extra node ID is only used for index, assign_op, unary, binary, method\n@@ -687,6 +483,7 @@ pub struct expr {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum log_level { error, debug, log_other }\n // 0 = error, 1 = debug, 2 = log_other\n \n@@ -701,6 +498,7 @@ pub enum CallSugar {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -777,12 +575,22 @@ pub enum expr_ {\n //\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n pub enum token_tree {\n+    // a single token\n     tt_tok(span, ::parse::token::Token),\n+    // a delimited sequence (the delimiters appear as the first\n+    // and last elements of the vector)\n     tt_delim(~[token_tree]),\n-    // These only make sense for right-hand-sides of MBE macros\n+    // These only make sense for right-hand-sides of MBE macros:\n+\n+    // a kleene-style repetition sequence with a span, a tt_forest,\n+    // an optional separator (?), and a boolean where true indicates\n+    // zero or more (*), and false indicates one or more (+).\n     tt_seq(span, ~[token_tree], Option<::parse::token::Token>, bool),\n+\n+    // a syntactic variable that will be filled in by macro expansion.\n     tt_nonterminal(span, ident)\n }\n \n@@ -842,6 +650,7 @@ pub type matcher = spanned<matcher_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum matcher_ {\n     // match one token\n     match_tok(::parse::token::Token),\n@@ -856,6 +665,7 @@ pub type mac = spanned<mac_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum mac_ {\n     mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n }\n@@ -864,6 +674,7 @@ pub type lit = spanned<lit_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum lit_ {\n     lit_str(@~str),\n     lit_int(i64, int_ty),\n@@ -875,47 +686,19 @@ pub enum lit_ {\n     lit_bool(bool),\n }\n \n-pub impl lit_: cmp::Eq {\n-    pure fn eq(&self, other: &lit_) -> bool {\n-        match ((*self), *other) {\n-            (lit_str(a), lit_str(b)) => a == b,\n-            (lit_int(val_a, ty_a), lit_int(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_uint(val_a, ty_a), lit_uint(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_int_unsuffixed(a), lit_int_unsuffixed(b)) => a == b,\n-            (lit_float(val_a, ty_a), lit_float(val_b, ty_b)) => {\n-                val_a == val_b && ty_a == ty_b\n-            }\n-            (lit_float_unsuffixed(a), lit_float_unsuffixed(b)) => a == b,\n-            (lit_nil, lit_nil) => true,\n-            (lit_bool(a), lit_bool(b)) => a == b,\n-            (lit_str(_), _) => false,\n-            (lit_int(*), _) => false,\n-            (lit_uint(*), _) => false,\n-            (lit_int_unsuffixed(*), _) => false,\n-            (lit_float(*), _) => false,\n-            (lit_float_unsuffixed(*), _) => false,\n-            (lit_nil, _) => false,\n-            (lit_bool(_), _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &lit_) -> bool { !(*self).eq(other) }\n-}\n-\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct mt {\n     ty: @Ty,\n     mutbl: mutability,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct ty_field_ {\n     ident: ident,\n     mt: mt,\n@@ -925,6 +708,7 @@ pub type ty_field = spanned<ty_field_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct ty_method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -938,6 +722,7 @@ pub struct ty_method {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -948,6 +733,7 @@ pub enum trait_method {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n pub impl int_ty : ToStr {\n@@ -962,28 +748,9 @@ pub impl int_ty : to_bytes::IterBytes {\n     }\n }\n \n-pub impl int_ty : cmp::Eq {\n-    pure fn eq(&self, other: &int_ty) -> bool {\n-        match ((*self), (*other)) {\n-            (ty_i, ty_i) => true,\n-            (ty_char, ty_char) => true,\n-            (ty_i8, ty_i8) => true,\n-            (ty_i16, ty_i16) => true,\n-            (ty_i32, ty_i32) => true,\n-            (ty_i64, ty_i64) => true,\n-            (ty_i, _) => false,\n-            (ty_char, _) => false,\n-            (ty_i8, _) => false,\n-            (ty_i16, _) => false,\n-            (ty_i32, _) => false,\n-            (ty_i64, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &int_ty) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n pub impl uint_ty : ToStr {\n@@ -998,26 +765,9 @@ pub impl uint_ty : to_bytes::IterBytes {\n     }\n }\n \n-pub impl uint_ty : cmp::Eq {\n-    pure fn eq(&self, other: &uint_ty) -> bool {\n-        match ((*self), (*other)) {\n-            (ty_u, ty_u) => true,\n-            (ty_u8, ty_u8) => true,\n-            (ty_u16, ty_u16) => true,\n-            (ty_u32, ty_u32) => true,\n-            (ty_u64, ty_u64) => true,\n-            (ty_u, _) => false,\n-            (ty_u8, _) => false,\n-            (ty_u16, _) => false,\n-            (ty_u32, _) => false,\n-            (ty_u64, _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &uint_ty) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum float_ty { ty_f, ty_f32, ty_f64, }\n \n pub impl float_ty : ToStr {\n@@ -1032,18 +782,10 @@ pub impl float_ty : to_bytes::IterBytes {\n     }\n }\n \n-pub impl float_ty : cmp::Eq {\n-    pure fn eq(&self, other: &float_ty) -> bool {\n-        match ((*self), (*other)) {\n-            (ty_f, ty_f) | (ty_f32, ty_f32) | (ty_f64, ty_f64) => true,\n-            (ty_f, _) | (ty_f32, _) | (ty_f64, _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &float_ty) -> bool { !(*self).eq(other) }\n-}\n-\n+// NB Eq method appears below.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct Ty {\n     id: node_id,\n     node: ty_,\n@@ -1053,6 +795,7 @@ pub struct Ty {\n // Not represented directly in the AST, referred to by name through a ty_path.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -1061,53 +804,17 @@ pub enum prim_ty {\n     ty_bool,\n }\n \n-pub impl prim_ty : cmp::Eq {\n-    pure fn eq(&self, other: &prim_ty) -> bool {\n-        match (*self) {\n-            ty_int(e0a) => {\n-                match (*other) {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match (*other) {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match (*other) {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_str => {\n-                match (*other) {\n-                    ty_str => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match (*other) {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &prim_ty) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct region {\n     id: node_id,\n     node: region_,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum region_ {\n     re_anon,\n     re_static,\n@@ -1140,6 +847,7 @@ pub impl Onceness : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct TyClosure {\n     sigil: Sigil,\n     region: Option<@region>,\n@@ -1150,6 +858,7 @@ pub struct TyClosure {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct TyBareFn {\n     purity: purity,\n     abi: Abi,\n@@ -1158,6 +867,7 @@ pub struct TyBareFn {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -1179,17 +889,6 @@ pub enum ty_ {\n     ty_infer,\n }\n \n-// Equality and byte-iter (hashing) can be quite approximate for AST types.\n-// since we only care about this for normalizing them to \"real\" types.\n-pub impl Ty : cmp::Eq {\n-    pure fn eq(&self, other: &Ty) -> bool {\n-        ptr::addr_of(&(*self)) == ptr::addr_of(&(*other))\n-    }\n-    pure fn ne(&self, other: &Ty) -> bool {\n-        ptr::addr_of(&(*self)) != ptr::addr_of(&(*other))\n-    }\n-}\n-\n pub impl Ty : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         to_bytes::iter_bytes_2(&self.span.lo, &self.span.hi, lsb0, f);\n@@ -1198,6 +897,7 @@ pub impl Ty : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct arg {\n     mode: mode,\n     is_mutbl: bool,\n@@ -1208,6 +908,7 @@ pub struct arg {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct fn_decl {\n     inputs: ~[arg],\n     output: @Ty,\n@@ -1216,6 +917,7 @@ pub struct fn_decl {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum purity {\n     pure_fn, // declared with \"pure fn\"\n     unsafe_fn, // declared with \"unsafe fn\"\n@@ -1240,15 +942,9 @@ pub impl purity : to_bytes::IterBytes {\n     }\n }\n \n-pub impl purity : cmp::Eq {\n-    pure fn eq(&self, other: &purity) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &purity) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n@@ -1261,20 +957,9 @@ pub impl ret_style : to_bytes::IterBytes {\n     }\n }\n \n-pub impl ret_style : cmp::Eq {\n-    pure fn eq(&self, other: &ret_style) -> bool {\n-        match ((*self), (*other)) {\n-            (noreturn, noreturn) => true,\n-            (return_val, return_val) => true,\n-            (noreturn, _) => false,\n-            (return_val, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &ret_style) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum self_ty_ {\n     sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n@@ -1284,54 +969,11 @@ pub enum self_ty_ {\n     sty_uniq(mutability)                // by-unique-pointer self: `~self`\n }\n \n-pub impl self_ty_ : cmp::Eq {\n-    pure fn eq(&self, other: &self_ty_) -> bool {\n-        match (*self) {\n-            sty_static => {\n-                match (*other) {\n-                    sty_static => true,\n-                    _ => false\n-                }\n-            }\n-            sty_by_ref => {\n-                match (*other) {\n-                    sty_by_ref => true,\n-                    _ => false\n-                }\n-            }\n-            sty_value => {\n-                match (*other) {\n-                    sty_value => true,\n-                    _ => false\n-                }\n-            }\n-            sty_region(e0a) => {\n-                match (*other) {\n-                    sty_region(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_box(e0a) => {\n-                match (*other) {\n-                    sty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            sty_uniq(e0a) => {\n-                match (*other) {\n-                    sty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &self_ty_) -> bool { !(*self).eq(other) }\n-}\n-\n pub type self_ty = spanned<self_ty_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct method {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1348,13 +990,15 @@ pub struct method {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct _mod {\n     view_items: ~[@view_item],\n     items: ~[@item],\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum foreign_abi {\n     foreign_abi_rust_intrinsic,\n     foreign_abi_cdecl,\n@@ -1364,31 +1008,12 @@ pub enum foreign_abi {\n // Foreign mods can be named or anonymous\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum foreign_mod_sort { named, anonymous }\n \n-pub impl foreign_mod_sort : cmp::Eq {\n-    pure fn eq(&self, other: &foreign_mod_sort) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &foreign_mod_sort) -> bool { !(*self).eq(other) }\n-}\n-\n-pub impl foreign_abi : cmp::Eq {\n-    pure fn eq(&self, other: &foreign_abi) -> bool {\n-        match ((*self), (*other)) {\n-            (foreign_abi_rust_intrinsic, foreign_abi_rust_intrinsic) => true,\n-            (foreign_abi_cdecl, foreign_abi_cdecl) => true,\n-            (foreign_abi_stdcall, foreign_abi_stdcall) => true,\n-            (foreign_abi_rust_intrinsic, _) => false,\n-            (foreign_abi_cdecl, _) => false,\n-            (foreign_abi_stdcall, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &foreign_abi) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct foreign_mod {\n     sort: foreign_mod_sort,\n     abi: ident,\n@@ -1398,13 +1023,15 @@ pub struct foreign_mod {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct variant_arg {\n     ty: @Ty,\n     id: node_id,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n@@ -1413,17 +1040,20 @@ pub enum variant_kind {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct enum_def_ {\n     variants: ~[variant],\n     common: Option<@struct_def>,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum enum_def = enum_def_;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct variant_ {\n     name: ident,\n     attrs: ~[attribute],\n@@ -1437,6 +1067,7 @@ pub type variant = spanned<variant_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct path_list_ident_ {\n     name: ident,\n     id: node_id,\n@@ -1446,19 +1077,14 @@ pub type path_list_ident = spanned<path_list_ident_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum namespace { module_ns, type_value_ns }\n \n-pub impl namespace : cmp::Eq {\n-    pure fn eq(&self, other: &namespace) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &namespace) -> bool { !(*self).eq(other) }\n-}\n-\n pub type view_path = spanned<view_path_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -1477,6 +1103,7 @@ pub enum view_path_ {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct view_item {\n     node: view_item_,\n     attrs: ~[attribute],\n@@ -1486,6 +1113,7 @@ pub struct view_item {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum view_item_ {\n     view_item_use(ident, ~[@meta_item], node_id),\n     view_item_import(~[@view_path]),\n@@ -1499,18 +1127,13 @@ pub type attribute = spanned<attribute_>;\n // distinguished for pretty-printing.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum attr_style { attr_outer, attr_inner, }\n \n-pub impl attr_style : cmp::Eq {\n-    pure fn eq(&self, other: &attr_style) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &attr_style) -> bool { !(*self).eq(other) }\n-}\n-\n // doc-comments are promoted to attributes that have is_sugared_doc = true\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct attribute_ {\n     style: attr_style,\n     value: meta_item,\n@@ -1526,31 +1149,20 @@ pub struct attribute_ {\n  */\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct trait_ref {\n     path: @path,\n     ref_id: node_id,\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum visibility { public, private, inherited }\n \n-pub impl visibility : cmp::Eq {\n-    pure fn eq(&self, other: &visibility) -> bool {\n-        match ((*self), (*other)) {\n-            (public, public) => true,\n-            (private, private) => true,\n-            (inherited, inherited) => true,\n-            (public, _) => false,\n-            (private, _) => false,\n-            (inherited, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &visibility) -> bool { !(*self).eq(other) }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n@@ -1561,40 +1173,15 @@ pub type struct_field = spanned<struct_field_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum struct_field_kind {\n     named_field(ident, struct_mutability, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n-pub impl struct_field_kind : cmp::Eq {\n-    pure fn eq(&self, other: &struct_field_kind) -> bool {\n-        match (*self) {\n-            named_field(ident_a, struct_mutability_a, visibility_a) => {\n-                match *other {\n-                    named_field(ident_b, struct_mutability_b, visibility_b)\n-                            => {\n-                        ident_a == ident_b &&\n-                        struct_mutability_a == struct_mutability_b &&\n-                        visibility_a == visibility_b\n-                    }\n-                    unnamed_field => false\n-                }\n-            }\n-            unnamed_field => {\n-                match *other {\n-                    named_field(*) => false,\n-                    unnamed_field => true\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &struct_field_kind) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct struct_def {\n     fields: ~[@struct_field], /* fields */\n     /* (not including ctor or dtor) */\n@@ -1611,6 +1198,7 @@ pub struct struct_def {\n  */\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1622,6 +1210,7 @@ pub struct item {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum item_ {\n     item_const(@Ty, @expr),\n     item_fn(fn_decl, purity, ~[ty_param], blk),\n@@ -1632,14 +1221,15 @@ pub enum item_ {\n     item_struct(@struct_def, ~[ty_param]),\n     item_trait(~[ty_param], ~[@trait_ref], ~[trait_method]),\n     item_impl(~[ty_param],\n-              Option<@trait_ref>, /* (optional) trait this impl implements */\n-              @Ty, /* self */\n+              Option<@trait_ref>, // (optional) trait this impl implements\n+              @Ty, // self\n               ~[@method]),\n     item_mac(mac),\n }\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum struct_mutability { struct_mutable, struct_immutable }\n \n pub impl struct_mutability : to_bytes::IterBytes {\n@@ -1648,24 +1238,11 @@ pub impl struct_mutability : to_bytes::IterBytes {\n     }\n }\n \n-pub impl struct_mutability : cmp::Eq {\n-    pure fn eq(&self, other: &struct_mutability) -> bool {\n-        match ((*self), (*other)) {\n-            (struct_mutable, struct_mutable) => true,\n-            (struct_immutable, struct_immutable) => true,\n-            (struct_mutable, _) => false,\n-            (struct_immutable, _) => false,\n-        }\n-    }\n-    pure fn ne(&self, other: &struct_mutability) -> bool {\n-        !(*self).eq(other)\n-    }\n-}\n-\n pub type struct_dtor = spanned<struct_dtor_>;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct struct_dtor_ {\n     id: node_id,\n     attrs: ~[attribute],\n@@ -1675,6 +1252,7 @@ pub struct struct_dtor_ {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct foreign_item {\n     ident: ident,\n     attrs: ~[attribute],\n@@ -1686,6 +1264,7 @@ pub struct foreign_item {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, ~[ty_param]),\n     foreign_item_const(@Ty)\n@@ -1696,14 +1275,42 @@ pub enum foreign_item_ {\n // that we trans.\n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_foreign(@foreign_item),\n     ii_dtor(struct_dtor, ident, ~[ty_param], def_id /* parent id */)\n }\n \n-\n+#[cfg(test)]\n+mod test {\n+    use std;\n+    use codemap::*;\n+    use super::*;\n+\n+    //are asts encodable?\n+\n+    // it looks like this *will* be a compiler bug, after\n+    // I get deriving_eq for crates into incoming :)\n+    /*\n+    #[test] fn check_asts_encodable() {\n+        let bogus_span = span {lo:BytePos(10),\n+                               hi:BytePos(20),\n+                               expn_info:None};\n+        let _e : crate =\n+            spanned{\n+            node: crate_{\n+                module: _mod {view_items: ~[], items: ~[]},\n+                attrs: ~[],\n+                config: ~[]\n+            },\n+            span: bogus_span};\n+        // doesn't matter which encoder we use....\n+        let _f = (_e as std::serialize::Encodable::<std::json::Encoder>);\n+    }\n+    */\n+}\n //\n // Local Variables:\n // mode: rust"}, {"sha": "10a4e12bef4fc66a4405a88d4467b1e5806d30c2", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -130,6 +130,7 @@ pub struct span {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub struct spanned<T> { node: T, span: span }\n \n pub impl span : cmp::Eq {"}, {"sha": "c924acd577d321cf9b72c505add9f231f5f5f910", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -44,8 +44,8 @@ pub struct SyntaxExpanderTT {\n     span: Option<span>\n }\n \n-pub type SyntaxExpanderTTFun = fn@(ext_ctxt, span, ~[ast::token_tree])\n-                                -> MacResult;\n+pub type SyntaxExpanderTTFun\n+    = fn@(ext_ctxt, span, ~[ast::token_tree]) -> MacResult;\n \n pub struct SyntaxExpanderTTItem {\n     expander: SyntaxExpanderTTItemFun,\n@@ -78,9 +78,11 @@ pub enum SyntaxExtension {\n // A temporary hard-coded map of methods for expanding syntax extension\n // AST nodes into full ASTs\n pub fn syntax_expander_table() -> HashMap<~str, SyntaxExtension> {\n+    // utility function to simplify creating NormalTT syntax extensions\n     fn builtin_normal_tt(f: SyntaxExpanderTTFun) -> SyntaxExtension {\n         NormalTT(SyntaxExpanderTT{expander: f, span: None})\n     }\n+    // utility function to simplify creating ItemTT syntax extensions\n     fn builtin_item_tt(f: SyntaxExpanderTTItemFun) -> SyntaxExtension {\n         ItemTT(SyntaxExpanderTTItem{expander: f, span: None})\n     }\n@@ -112,8 +114,8 @@ pub fn syntax_expander_table() -> HashMap<~str, SyntaxExtension> {\n                                 ext::deriving::expand_deriving_iter_bytes));\n \n     // Quasi-quoting expanders\n-    syntax_expanders.insert(\n-        ~\"quote_tokens\", builtin_normal_tt(ext::quote::expand_quote_tokens));\n+    syntax_expanders.insert(~\"quote_tokens\",\n+                       builtin_normal_tt(ext::quote::expand_quote_tokens));\n     syntax_expanders.insert(~\"quote_expr\",\n                             builtin_normal_tt(ext::quote::expand_quote_expr));\n     syntax_expanders.insert(~\"quote_ty\","}, {"sha": "e7b5005d8dbf4899050f29f3e1c04746ed4d4174", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -20,6 +20,8 @@ use core::option::{None, Option, Some};\n use core::option;\n use std::oldmap::HashMap;\n \n+// seq_sep : a sequence separator (token)\n+// and whether a trailing separator is allowed.\n pub type seq_sep = {\n     sep: Option<token::Token>,\n     trailing_sep_allowed: bool\n@@ -51,6 +53,8 @@ pub impl Parser {\n                    + token_to_str(self.reader, self.token) + ~\"`\");\n     }\n \n+    // expect and consume the token t. Signal an error if\n+    // the next token is not t.\n     fn expect(t: token::Token) {\n         if self.token == t {\n             self.bump();\n@@ -88,6 +92,8 @@ pub impl Parser {\n         return self.parse_ident();\n     }\n \n+    // consume token 'tok' if it exists. Returns true if the given\n+    // token was present, false otherwise.\n     fn eat(tok: token::Token) -> bool {\n         return if self.token == tok { self.bump(); true } else { false };\n     }\n@@ -185,6 +191,8 @@ pub impl Parser {\n         }\n     }\n \n+    // expect and consume a GT. if a >> is seen, replace it\n+    // with a single > and continue.\n     fn expect_gt() {\n         if self.token == token::GT {\n             self.bump();\n@@ -202,6 +210,8 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a sequence bracketed by '<' and '>', stopping\n+    // before the '>'.\n     fn parse_seq_to_before_gt<T: Copy>(sep: Option<token::Token>,\n                                        f: fn(Parser) -> T) -> ~[T] {\n         let mut first = true;\n@@ -211,7 +221,7 @@ pub impl Parser {\n             match sep {\n               Some(ref t) => {\n                 if first { first = false; }\n-                else { self.expect((*t)); }\n+                else { self.expect(*t); }\n               }\n               _ => ()\n             }\n@@ -229,6 +239,7 @@ pub impl Parser {\n         return v;\n     }\n \n+    // parse a sequence bracketed by '<' and '>'\n     fn parse_seq_lt_gt<T: Copy>(sep: Option<token::Token>,\n                                 f: fn(Parser) -> T) -> spanned<~[T]> {\n         let lo = self.span.lo;\n@@ -239,14 +250,19 @@ pub impl Parser {\n         return spanned(lo, hi, result);\n     }\n \n+    // parse a sequence, including the closing delimiter. The function\n+    // f must consume tokens until reaching the next separator or\n+    // closing bracket.\n     fn parse_seq_to_end<T: Copy>(ket: token::Token, sep: seq_sep,\n                                  f: fn(Parser) -> T) -> ~[T] {\n         let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         return val;\n     }\n \n-\n+    // parse a sequence, not including the closing delimiter. The function\n+    // f must consume tokens until reaching the next separator or\n+    // closing bracket.\n     fn parse_seq_to_before_end<T: Copy>(ket: token::Token, sep: seq_sep,\n                                         f: fn(Parser) -> T) -> ~[T] {\n         let mut first: bool = true;\n@@ -255,7 +271,7 @@ pub impl Parser {\n             match sep.sep {\n               Some(ref t) => {\n                 if first { first = false; }\n-                else { self.expect((*t)); }\n+                else { self.expect(*t); }\n               }\n               _ => ()\n             }\n@@ -265,6 +281,9 @@ pub impl Parser {\n         return v;\n     }\n \n+    // parse a sequence, including the closing delimiter. The function\n+    // f must consume tokens until reaching the next separator or\n+    // closing bracket.\n     fn parse_unspanned_seq<T: Copy>(bra: token::Token,\n                                     ket: token::Token,\n                                     sep: seq_sep,"}, {"sha": "12038898a9d1c8fc732642d3dd3cf44a0e7d3fe7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -183,7 +183,6 @@ pub fn new_parser_from_file(sess: parse_sess,\n           let srdr = lexer::new_string_reader(sess.span_diagnostic,\n                                               filemap,\n                                               sess.interner);\n-\n           Ok(Parser(sess, cfg, srdr as reader))\n \n       }\n@@ -222,3 +221,58 @@ pub fn new_parser_from_tts(sess: parse_sess, cfg: ast::crate_cfg,\n     return Parser(sess, cfg, trdr as reader)\n }\n \n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use std::serialize::Encodable;\n+    use std;\n+    use core::dvec;\n+    use core::str;\n+    use util::testing::*;\n+\n+    #[test] fn to_json_str (val: Encodable<std::json::Encoder>) -> ~str {\n+        let bw = @io::BytesWriter {bytes: dvec::DVec(), pos: 0};\n+        val.encode(~std::json::Encoder(bw as io::Writer));\n+        str::from_bytes(bw.bytes.data)\n+    }\n+\n+    #[test] fn alltts () {\n+        let tts = parse_tts_from_source_str(\n+            ~\"bogofile\",\n+            @~\"fn foo (x : int) { x; }\",\n+            ~[],\n+            new_parse_sess(None));\n+        check_equal(to_json_str(tts as Encodable::<std::json::Encoder>),\n+                    ~\"[[\\\"tt_tok\\\",[,[\\\"IDENT\\\",[\\\"fn\\\",false]]]],\\\n+                      [\\\"tt_tok\\\",[,[\\\"IDENT\\\",[\\\"foo\\\",false]]]],\\\n+                      [\\\"tt_delim\\\",[[[\\\"tt_tok\\\",[,[\\\"LPAREN\\\",[]]]],\\\n+                      [\\\"tt_tok\\\",[,[\\\"IDENT\\\",[\\\"x\\\",false]]]],\\\n+                      [\\\"tt_tok\\\",[,[\\\"COLON\\\",[]]]],\\\n+                      [\\\"tt_tok\\\",[,[\\\"IDENT\\\",[\\\"int\\\",false]]]],\\\n+                      [\\\"tt_tok\\\",[,[\\\"RPAREN\\\",[]]]]]]],\\\n+                      [\\\"tt_delim\\\",[[[\\\"tt_tok\\\",[,[\\\"LBRACE\\\",[]]]],\\\n+                      [\\\"tt_tok\\\",[,[\\\"IDENT\\\",[\\\"x\\\",false]]]],\\\n+                      [\\\"tt_tok\\\",[,[\\\"SEMI\\\",[]]]],\\\n+                      [\\\"tt_tok\\\",[,[\\\"RBRACE\\\",[]]]]]]]]\"\n+                   );\n+        let ast1 = new_parser_from_tts(new_parse_sess(None),~[],tts)\n+            .parse_item(~[]);\n+        let ast2 = parse_item_from_source_str(\n+            ~\"bogofile\",\n+            @~\"fn foo (x : int) { x; }\",\n+            ~[],~[],\n+            new_parse_sess(None));\n+        check_equal(ast1,ast2);\n+    }\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// End:\n+//"}, {"sha": "41ccf39e2cee1d178b9f8c001ca1f9908ced75f1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -182,7 +182,8 @@ pure fn maybe_append(+lhs: ~[attribute], rhs: Option<~[attribute]>)\n \n /* ident is handled by common.rs */\n \n-pub fn Parser(sess: parse_sess,\n+pub fn Parser(sess: parse_sess\n+              ,\n               cfg: ast::crate_cfg,\n               +rdr: reader) -> Parser {\n \n@@ -1238,6 +1239,8 @@ pub impl Parser {\n         return e;\n     }\n \n+    // parse an optional separator followed by a kleene-style\n+    // repetition token (+ or *).\n     fn parse_sep_and_zerok() -> (Option<token::Token>, bool) {\n         if self.token == token::BINOP(token::STAR)\n             || self.token == token::BINOP(token::PLUS) {\n@@ -1258,20 +1261,18 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a single token tree from the input.\n     fn parse_token_tree() -> token_tree {\n         maybe_whole!(deref self, nt_tt);\n \n-        fn parse_tt_tok(p: Parser, delim_ok: bool) -> token_tree {\n+        fn parse_non_delim_tt_tok(p: Parser) -> token_tree {\n             maybe_whole!(deref p, nt_tt);\n             match p.token {\n               token::RPAREN | token::RBRACE | token::RBRACKET\n-              if !delim_ok => {\n+              => {\n                 p.fatal(~\"incorrect close delimiter: `\"\n                            + token_to_str(p.reader, p.token) + ~\"`\");\n               }\n-              token::EOF => {\n-                p.fatal(~\"file ended in the middle of a macro invocation\");\n-              }\n               /* we ought to allow different depths of unquotation */\n               token::DOLLAR if p.quote_depth > 0u => {\n                 p.bump();\n@@ -1282,32 +1283,43 @@ pub impl Parser {\n                                           seq_sep_none(),\n                                           |p| p.parse_token_tree());\n                     let (s, z) = p.parse_sep_and_zerok();\n-                    return tt_seq(mk_sp(sp.lo ,p.span.hi), seq.node, s, z);\n+                    tt_seq(mk_sp(sp.lo ,p.span.hi), seq.node, s, z)\n                 } else {\n-                    return tt_nonterminal(sp, p.parse_ident());\n+                    tt_nonterminal(sp, p.parse_ident())\n                 }\n               }\n-              _ => { /* ok */ }\n+              _ => {\n+                  parse_any_tt_tok(p)\n+              }\n             }\n+        }\n+\n+        // turn the next token into a tt_tok:\n+        fn parse_any_tt_tok(p: Parser) -> token_tree{\n             let res = tt_tok(p.span, p.token);\n             p.bump();\n-            return res;\n+            res\n         }\n \n-        return match self.token {\n+        match self.token {\n+          token::EOF => {\n+                self.fatal(~\"file ended in the middle of a macro invocation\");\n+          }\n           token::LPAREN | token::LBRACE | token::LBRACKET => {\n               // tjc: ??????\n             let ket = token::flip_delimiter(copy self.token);\n             tt_delim(vec::append(\n-                ~[parse_tt_tok(self, true)],\n+                // the open delimiter:\n+                ~[parse_any_tt_tok(self)],\n                 vec::append(\n                     self.parse_seq_to_before_end(\n                         ket, seq_sep_none(),\n                         |p| p.parse_token_tree()),\n-                    ~[parse_tt_tok(self, true)])))\n+                    // the close delimiter:\n+                    ~[parse_any_tt_tok(self)])))\n           }\n-          _ => parse_tt_tok(self, false)\n-        };\n+          _ => parse_non_delim_tt_tok(self)\n+        }\n     }\n \n     fn parse_all_token_trees() -> ~[token_tree] {\n@@ -3999,6 +4011,7 @@ pub impl Parser {\n     }\n }\n \n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "92d25d5d19378c89dbb5629ff8433c32e6677bd6", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=6efa3543a8b38f0dcbe89e7bf6d14f571bad46ac", "patch": "@@ -25,6 +25,7 @@ use std::oldmap::HashMap;\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum binop {\n     PLUS,\n     MINUS,\n@@ -86,6 +87,7 @@ pub enum Token {\n     LIT_STR(ast::ident),\n \n     /* Name components */\n+    // an identifier contains an \"is_mod_name\" boolean.\n     IDENT(ast::ident, bool),\n     UNDERSCORE,\n     LIFETIME(ast::ident),\n@@ -517,12 +519,6 @@ pub fn reserved_keyword_table() -> HashMap<~str, ()> {\n     words\n }\n \n-impl binop : cmp::Eq {\n-    pure fn eq(&self, other: &binop) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &binop) -> bool { !(*self).eq(other) }\n-}\n \n impl Token : cmp::Eq {\n     pure fn eq(&self, other: &Token) -> bool {"}]}