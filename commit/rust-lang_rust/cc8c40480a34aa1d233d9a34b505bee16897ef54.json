{"sha": "cc8c40480a34aa1d233d9a34b505bee16897ef54", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOGM0MDQ4MGEzNGFhMWQyMzNkOWEzNGI1MDViZWUxNjg5N2VmNTQ=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-03-04T02:48:12Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2021-03-04T06:47:34Z"}, "message": "Print warning if proc-macro built by old rustc", "tree": {"sha": "861635c3c5f12feffbd087086ba8d15acbdec9b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/861635c3c5f12feffbd087086ba8d15acbdec9b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc8c40480a34aa1d233d9a34b505bee16897ef54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc8c40480a34aa1d233d9a34b505bee16897ef54", "html_url": "https://github.com/rust-lang/rust/commit/cc8c40480a34aa1d233d9a34b505bee16897ef54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc8c40480a34aa1d233d9a34b505bee16897ef54/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0669abda4aa2a544ad8ab465fba0853ff8379c23", "url": "https://api.github.com/repos/rust-lang/rust/commits/0669abda4aa2a544ad8ab465fba0853ff8379c23", "html_url": "https://github.com/rust-lang/rust/commit/0669abda4aa2a544ad8ab465fba0853ff8379c23"}], "stats": {"total": 221, "additions": 148, "deletions": 73}, "files": [{"sha": "941d0fe9e21c65f5a957b34e75872cf0839b7b1d", "filename": "crates/proc_macro_api/src/lib.rs", "status": "modified", "additions": 17, "deletions": 73, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/cc8c40480a34aa1d233d9a34b505bee16897ef54/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8c40480a34aa1d233d9a34b505bee16897ef54/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Flib.rs?ref=cc8c40480a34aa1d233d9a34b505bee16897ef54", "patch": "@@ -8,12 +8,12 @@\n pub mod msg;\n mod process;\n mod rpc;\n+mod version;\n \n use base_db::{Env, ProcMacro};\n use std::{\n     ffi::OsStr,\n-    fs::File,\n-    io::{self, Read},\n+    io,\n     path::{Path, PathBuf},\n     sync::Arc,\n };\n@@ -24,10 +24,6 @@ use crate::process::{ProcMacroProcessSrv, ProcMacroProcessThread};\n \n pub use rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind};\n \n-use memmap::Mmap;\n-use object::read::{File as BinaryFile, Object, ObjectSection};\n-use snap::read::FrameDecoder as SnapDecoder;\n-\n #[derive(Debug, Clone)]\n struct ProcMacroProcessExpander {\n     process: Arc<ProcMacroProcessSrv>,\n@@ -80,6 +76,21 @@ impl ProcMacroClient {\n     }\n \n     pub fn by_dylib_path(&self, dylib_path: &Path) -> Vec<ProcMacro> {\n+        match version::read_info(dylib_path) {\n+            Ok(info) => {\n+                if info.version.0 < 1 || info.version.1 < 47 {\n+                    eprintln!(\"proc-macro {} built by {:#?} is not supported by Rust Analyzer, please update your rust version.\", dylib_path.to_string_lossy(), info);\n+                }\n+            }\n+            Err(err) => {\n+                eprintln!(\n+                    \"proc-macro {} failed to find the given version. Reason: {}\",\n+                    dylib_path.to_string_lossy(),\n+                    err\n+                );\n+            }\n+        }\n+\n         let macros = match self.process.find_proc_macros(dylib_path) {\n             Err(err) => {\n                 eprintln!(\"Failed to find proc macros. Error: {:#?}\", err);\n@@ -107,71 +118,4 @@ impl ProcMacroClient {\n             })\n             .collect()\n     }\n-\n-    // This is used inside self.read_version() to locate the \".rustc\" section\n-    // from a proc macro crate's binary file.\n-    fn read_section<'a>(&self, dylib_binary: &'a [u8], section_name: &str) -> io::Result<&'a [u8]> {\n-        BinaryFile::parse(dylib_binary)\n-            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?\n-            .section_by_name(section_name)\n-            .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, \"section read error\"))?\n-            .data()\n-            .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))\n-    }\n-\n-    // Check the version of rustc that was used to compile a proc macro crate's\n-    // binary file.\n-    // A proc macro crate binary's \".rustc\" section has following byte layout:\n-    // * [b'r',b'u',b's',b't',0,0,0,5] is the first 8 bytes\n-    // * ff060000 734e6150 is followed, it's the snappy format magic bytes,\n-    //   means bytes from here(including this sequence) are compressed in\n-    //   snappy compression format. Version info is inside here, so decompress\n-    //   this.\n-    // The bytes you get after decompressing the snappy format portion has\n-    // following layout:\n-    // * [b'r',b'u',b's',b't',0,0,0,5] is the first 8 bytes(again)\n-    // * [crate root bytes] next 4 bytes is to store crate root position,\n-    //   according to rustc's source code comment\n-    // * [length byte] next 1 byte tells us how many bytes we should read next\n-    //   for the version string's utf8 bytes\n-    // * [version string bytes encoded in utf8] <- GET THIS BOI\n-    // * [some more bytes that we don really care but still there] :-)\n-    // Check this issue for more about the bytes layout:\n-    // https://github.com/rust-analyzer/rust-analyzer/issues/6174\n-    #[allow(unused)]\n-    fn read_version(&self, dylib_path: &Path) -> io::Result<String> {\n-        let dylib_file = File::open(dylib_path)?;\n-        let dylib_mmaped = unsafe { Mmap::map(&dylib_file) }?;\n-\n-        let dot_rustc = self.read_section(&dylib_mmaped, \".rustc\")?;\n-\n-        let header = &dot_rustc[..8];\n-        const EXPECTED_HEADER: [u8; 8] = [b'r', b'u', b's', b't', 0, 0, 0, 5];\n-        // check if header is valid\n-        if header != EXPECTED_HEADER {\n-            return Err(io::Error::new(\n-                io::ErrorKind::InvalidData,\n-                format!(\"only metadata version 5 is supported, section header was: {:?}\", header),\n-            ));\n-        }\n-\n-        let snappy_portion = &dot_rustc[8..];\n-\n-        let mut snappy_decoder = SnapDecoder::new(snappy_portion);\n-\n-        // the bytes before version string bytes, so this basically is:\n-        // 8 bytes for [b'r',b'u',b's',b't',0,0,0,5]\n-        // 4 bytes for [crate root bytes]\n-        // 1 byte for length of version string\n-        // so 13 bytes in total, and we should check the 13th byte\n-        // to know the length\n-        let mut bytes_before_version = [0u8; 13];\n-        snappy_decoder.read_exact(&mut bytes_before_version)?;\n-        let length = bytes_before_version[12]; // what? can't use -1 indexing?\n-\n-        let mut version_string_utf8 = vec![0u8; length as usize];\n-        snappy_decoder.read_exact(&mut version_string_utf8)?;\n-        let version_string = String::from_utf8(version_string_utf8);\n-        version_string.map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))\n-    }\n }"}, {"sha": "80cd183a08bbd11d604f38ed472c701035690d4d", "filename": "crates/proc_macro_api/src/version.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/cc8c40480a34aa1d233d9a34b505bee16897ef54/crates%2Fproc_macro_api%2Fsrc%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc8c40480a34aa1d233d9a34b505bee16897ef54/crates%2Fproc_macro_api%2Fsrc%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fversion.rs?ref=cc8c40480a34aa1d233d9a34b505bee16897ef54", "patch": "@@ -0,0 +1,131 @@\n+//! Reading proc-macro rustc version information from binary data\n+\n+use std::{\n+    fs::File,\n+    io::{self, Read},\n+    path::Path,\n+};\n+\n+use memmap::Mmap;\n+use object::read::{File as BinaryFile, Object, ObjectSection};\n+use snap::read::FrameDecoder as SnapDecoder;\n+\n+#[derive(Debug)]\n+pub(crate) struct RustCInfo {\n+    pub(crate) version: (usize, usize, usize),\n+    pub(crate) channel: String,\n+    pub(crate) commit: String,\n+    pub(crate) date: String,\n+}\n+\n+pub(crate) fn read_info(dylib_path: &Path) -> io::Result<RustCInfo> {\n+    macro_rules! err {\n+        ($e:literal) => {\n+            io::Error::new(io::ErrorKind::InvalidData, $e)\n+        };\n+    }\n+\n+    let ver_str = read_version(dylib_path)?;\n+    let mut items = ver_str.split_whitespace();\n+    let tag = items.next().ok_or(err!(\"version format error\"))?;\n+    if tag != \"rustc\" {\n+        return Err(err!(\"version format error (No rustc tag)\"));\n+    }\n+\n+    let version_part = items.next().ok_or(err!(\"no version string\"))?;\n+    let mut version_parts = version_part.split(\"-\");\n+    let version = version_parts.next().ok_or(err!(\"no version\"))?;\n+    let channel = version_parts.next().unwrap_or_default().to_string();\n+\n+    let commit = items.next().ok_or(err!(\"no commit info\"))?;\n+    // remove (\n+    if commit.len() == 0 {\n+        return Err(err!(\"commit format error\"));\n+    }\n+    let commit = commit[1..].to_string();\n+    let date = items.next().ok_or(err!(\"no date info\"))?;\n+    // remove )\n+    if date.len() == 0 {\n+        return Err(err!(\"date format error\"));\n+    }\n+    let date = date[0..date.len() - 2].to_string();\n+\n+    let version_numbers = version\n+        .split(\".\")\n+        .map(|it| it.parse::<usize>())\n+        .collect::<Result<Vec<_>, _>>()\n+        .map_err(|_| err!(\"version number error\"))?;\n+\n+    if version_numbers.len() != 3 {\n+        return Err(err!(\"version number format error\"));\n+    }\n+    let version = (version_numbers[0], version_numbers[1], version_numbers[2]);\n+\n+    Ok(RustCInfo { version, channel, commit, date })\n+}\n+\n+// This is used inside read_version() to locate the \".rustc\" section\n+// from a proc macro crate's binary file.\n+fn read_section<'a>(dylib_binary: &'a [u8], section_name: &str) -> io::Result<&'a [u8]> {\n+    BinaryFile::parse(dylib_binary)\n+        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?\n+        .section_by_name(section_name)\n+        .ok_or_else(|| io::Error::new(io::ErrorKind::InvalidData, \"section read error\"))?\n+        .data()\n+        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))\n+}\n+\n+// Check the version of rustc that was used to compile a proc macro crate's\n+// binary file.\n+// A proc macro crate binary's \".rustc\" section has following byte layout:\n+// * [b'r',b'u',b's',b't',0,0,0,5] is the first 8 bytes\n+// * ff060000 734e6150 is followed, it's the snappy format magic bytes,\n+//   means bytes from here(including this sequence) are compressed in\n+//   snappy compression format. Version info is inside here, so decompress\n+//   this.\n+// The bytes you get after decompressing the snappy format portion has\n+// following layout:\n+// * [b'r',b'u',b's',b't',0,0,0,5] is the first 8 bytes(again)\n+// * [crate root bytes] next 4 bytes is to store crate root position,\n+//   according to rustc's source code comment\n+// * [length byte] next 1 byte tells us how many bytes we should read next\n+//   for the version string's utf8 bytes\n+// * [version string bytes encoded in utf8] <- GET THIS BOI\n+// * [some more bytes that we don really care but still there] :-)\n+// Check this issue for more about the bytes layout:\n+// https://github.com/rust-analyzer/rust-analyzer/issues/6174\n+fn read_version(dylib_path: &Path) -> io::Result<String> {\n+    let dylib_file = File::open(dylib_path)?;\n+    let dylib_mmaped = unsafe { Mmap::map(&dylib_file) }?;\n+\n+    let dot_rustc = read_section(&dylib_mmaped, \".rustc\")?;\n+\n+    let header = &dot_rustc[..8];\n+    const EXPECTED_HEADER: [u8; 8] = [b'r', b'u', b's', b't', 0, 0, 0, 5];\n+    // check if header is valid\n+    if header != EXPECTED_HEADER {\n+        return Err(io::Error::new(\n+            io::ErrorKind::InvalidData,\n+            format!(\"only metadata version 5 is supported, section header was: {:?}\", header),\n+        ));\n+    }\n+\n+    let snappy_portion = &dot_rustc[8..];\n+\n+    let mut snappy_decoder = SnapDecoder::new(snappy_portion);\n+\n+    // the bytes before version string bytes, so this basically is:\n+    // 8 bytes for [b'r',b'u',b's',b't',0,0,0,5]\n+    // 4 bytes for [crate root bytes]\n+    // 1 byte for length of version string\n+    // so 13 bytes in total, and we should check the 13th byte\n+    // to know the length\n+    let mut bytes_before_version = [0u8; 13];\n+    snappy_decoder.read_exact(&mut bytes_before_version)?;\n+    let length = bytes_before_version[12]; // what? can't use -1 indexing?\n+\n+    let mut version_string_utf8 = vec![0u8; length as usize];\n+    snappy_decoder.read_exact(&mut version_string_utf8)?;\n+    let version_string = String::from_utf8(version_string_utf8);\n+    version_string.map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))\n+}"}]}