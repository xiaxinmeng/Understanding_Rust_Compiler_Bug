{"sha": "7d28ab8ba2c9af56aa3f75524978c0863848ac0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMjhhYjhiYTJjOWFmNTZhYTNmNzU1MjQ5NzhjMDg2Mzg0OGFjMGI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-04-04T17:06:07Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-04-04T17:06:07Z"}, "message": "Remove the trans_const_place and TransPlaceInterpreter hack", "tree": {"sha": "6f9a98794d49e226380df10d9b470752fefa6dc4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f9a98794d49e226380df10d9b470752fefa6dc4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d28ab8ba2c9af56aa3f75524978c0863848ac0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d28ab8ba2c9af56aa3f75524978c0863848ac0b", "html_url": "https://github.com/rust-lang/rust/commit/7d28ab8ba2c9af56aa3f75524978c0863848ac0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d28ab8ba2c9af56aa3f75524978c0863848ac0b/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac1c5d69544450d30785d001224f7233da48cbda", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac1c5d69544450d30785d001224f7233da48cbda", "html_url": "https://github.com/rust-lang/rust/commit/ac1c5d69544450d30785d001224f7233da48cbda"}], "stats": {"total": 184, "additions": 28, "deletions": 156}, "files": [{"sha": "eea2e3c1f00e160c2a91b93f1b695e4ddbe5640a", "filename": "src/constant.rs", "status": "modified", "additions": 28, "deletions": 156, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/7d28ab8ba2c9af56aa3f75524978c0863848ac0b/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d28ab8ba2c9af56aa3f75524978c0863848ac0b/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=7d28ab8ba2c9af56aa3f75524978c0863848ac0b", "patch": "@@ -1,18 +1,12 @@\n-use std::borrow::Cow;\n-\n use rustc_span::DUMMY_SP;\n \n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n-    read_target_uint, AllocId, Allocation, ConstValue, GlobalAlloc, InterpResult, Scalar,\n+    read_target_uint, AllocId, Allocation, ConstValue, GlobalAlloc, Pointer, Scalar,\n };\n use rustc_middle::ty::{Const, ConstKind};\n use rustc_target::abi::Align;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_mir::interpret::{\n-    ImmTy, InterpCx, Machine, Memory, MemoryKind, OpTy, PlaceTy, Pointer,\n-    StackPopCleanup, StackPopJump,\n-};\n \n use cranelift_codegen::ir::GlobalValue;\n use cranelift_module::*;\n@@ -84,6 +78,7 @@ pub(crate) fn trans_const_value<'tcx>(\n ) -> CValue<'tcx> {\n     let ty = fx.monomorphize(&const_.ty);\n     let layout = fx.layout_of(ty);\n+    assert!(!layout.is_unsized(), \"sized const value\");\n \n     if layout.is_zst() {\n         return CValue::by_ref(\n@@ -99,7 +94,15 @@ pub(crate) fn trans_const_value<'tcx>(\n     match const_val {\n         ConstValue::Scalar(x) => {\n             if fx.clif_type(layout.ty).is_none() {\n-                return trans_const_place(fx, const_).to_cvalue(fx);\n+                let (size, align) = (layout.size, layout.align.pref);\n+                let mut alloc = Allocation::from_bytes(\n+                    std::iter::repeat(0).take(size.bytes_usize()).collect::<Vec<u8>>(),\n+                    align,\n+                );\n+                let ptr = Pointer::new(AllocId(!0), Size::ZERO); // The alloc id is never used\n+                alloc.write_scalar(fx, ptr, x.into(), size).unwrap();\n+                let alloc = fx.tcx.intern_const_alloc(alloc);\n+                return CValue::by_ref(pointer_for_allocation(fx, alloc), layout);\n             }\n \n             match x {\n@@ -140,68 +143,35 @@ pub(crate) fn trans_const_value<'tcx>(\n             }\n         }\n         ConstValue::ByRef { alloc, offset } => {\n-            let alloc_id = fx.tcx.alloc_map.lock().create_memory_alloc(alloc);\n-            fx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n-            let data_id = data_id_for_alloc_id(fx.module, alloc_id, alloc.align);\n-            let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-            let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n-            assert!(!layout.is_unsized(), \"unsized ConstValue::ByRef not supported\");\n             CValue::by_ref(\n-                crate::pointer::Pointer::new(global_ptr)\n+                pointer_for_allocation(fx, alloc)\n                     .offset_i64(fx, i64::try_from(offset.bytes()).unwrap()),\n                 layout,\n             )\n         }\n-        ConstValue::Slice { data: _, start: _, end: _ } => {\n-            trans_const_place(fx, const_).to_cvalue(fx)\n+        ConstValue::Slice { data, start, end } => {\n+            let ptr = pointer_for_allocation(fx, data)\n+                .offset_i64(fx, i64::try_from(start).unwrap())\n+                .get_addr(fx);\n+            let len = fx.bcx.ins().iconst(fx.pointer_type, i64::try_from(end.checked_sub(start).unwrap()).unwrap());\n+            CValue::by_val_pair(ptr, len, layout)\n         }\n     }\n }\n \n-fn trans_const_place<'tcx>(\n+fn pointer_for_allocation<'tcx>(\n     fx: &mut FunctionCx<'_, 'tcx, impl Backend>,\n-    const_: &'tcx Const<'tcx>,\n-) -> CPlace<'tcx> {\n-    // Adapted from https://github.com/rust-lang/rust/pull/53671/files#diff-e0b58bb6712edaa8595ad7237542c958L551\n-    let result = || -> InterpResult<'tcx, &'tcx Allocation> {\n-        let mut ecx = InterpCx::new(\n-            fx.tcx.at(DUMMY_SP),\n-            ty::ParamEnv::reveal_all(),\n-            TransPlaceInterpreter,\n-            (),\n-        );\n-        ecx.push_stack_frame(\n-            fx.instance,\n-            fx.mir,\n-            None,\n-            StackPopCleanup::None { cleanup: false },\n-        )\n-        .unwrap();\n-        let op = ecx.eval_operand(\n-            &Operand::Constant(Box::new(Constant {\n-                span: DUMMY_SP,\n-                user_ty: None,\n-                literal: const_,\n-            })),\n-            None,\n-        )?;\n-        let ptr = ecx.allocate(op.layout, MemoryKind::Stack);\n-        ecx.copy_op(op, ptr.into())?;\n-        let alloc = ecx\n-            .memory\n-            .get_raw(ptr.to_ref().to_scalar()?.assert_ptr().alloc_id)?;\n-        Ok(fx.tcx.intern_const_alloc(alloc.clone()))\n-    };\n-    let alloc = result().expect(\"unable to convert ConstKind to Allocation\");\n-\n-    //println!(\"const value: {:?} allocation: {:?}\", value, alloc);\n+    alloc: &'tcx Allocation,\n+) -> crate::pointer::Pointer {\n     let alloc_id = fx.tcx.alloc_map.lock().create_memory_alloc(alloc);\n     fx.constants_cx.todo.push(TodoItem::Alloc(alloc_id));\n     let data_id = data_id_for_alloc_id(fx.module, alloc_id, alloc.align);\n+\n     let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n     #[cfg(debug_assertions)]\n     fx.add_comment(local_data_id, format!(\"{:?}\", alloc_id));\n-    cplace_for_dataid(fx, fx.layout_of(const_.ty), local_data_id)\n+    let global_ptr = fx.bcx.ins().global_value(fx.pointer_type, local_data_id);\n+    crate::pointer::Pointer::new(global_ptr)\n }\n \n fn data_id_for_alloc_id<B: Backend>(\n@@ -286,13 +256,14 @@ fn cplace_for_dataid<'tcx>(\n }\n \n fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut Module<impl Backend>, cx: &mut ConstantCx) {\n-    let memory = Memory::<TransPlaceInterpreter>::new(tcx.at(DUMMY_SP), ());\n-\n     while let Some(todo_item) = cx.todo.pop() {\n         let (data_id, alloc) = match todo_item {\n             TodoItem::Alloc(alloc_id) => {\n                 //println!(\"alloc_id {}\", alloc_id);\n-                let alloc = memory.get_raw(alloc_id).unwrap();\n+                let alloc = match tcx.alloc_map.lock().get(alloc_id).unwrap() {\n+                    GlobalAlloc::Memory(alloc) => alloc,\n+                    GlobalAlloc::Function(_) | GlobalAlloc::Static(_) => unreachable!(),\n+                };\n                 let data_id = data_id_for_alloc_id(module, alloc_id, alloc.align);\n                 (data_id, alloc)\n             }\n@@ -388,105 +359,6 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut Module<impl Backend>, cx: &mu\n     assert!(cx.todo.is_empty(), \"{:?}\", cx.todo);\n }\n \n-struct TransPlaceInterpreter;\n-\n-impl<'mir, 'tcx> Machine<'mir, 'tcx> for TransPlaceInterpreter {\n-    type MemoryKind = !;\n-    type ExtraFnVal = !;\n-    type PointerTag = ();\n-    type AllocExtra = ();\n-    type MemoryExtra = ();\n-    type FrameExtra = ();\n-    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation<()>)>;\n-\n-    const CHECK_ALIGN: bool = true;\n-    const GLOBAL_KIND: Option<!> = None;\n-\n-    fn enforce_validity(_: &InterpCx<'mir, 'tcx, Self>) -> bool {\n-        false\n-    }\n-\n-    fn before_terminator(_: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        panic!();\n-    }\n-\n-    fn find_mir_or_eval_fn(\n-        _: &mut InterpCx<'mir, 'tcx, Self>,\n-        _: Instance<'tcx>,\n-        _: &[OpTy<'tcx>],\n-        _: Option<(PlaceTy<'tcx>, BasicBlock)>,\n-        _: Option<BasicBlock>,\n-    ) -> InterpResult<'tcx, Option<&'mir Body<'tcx>>> {\n-        panic!();\n-    }\n-\n-    fn call_intrinsic(\n-        _: &mut InterpCx<'mir, 'tcx, Self>,\n-        _: Instance<'tcx>,\n-        _: &[OpTy<'tcx>],\n-        _: Option<(PlaceTy<'tcx>, BasicBlock)>,\n-        _: Option<BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        panic!();\n-    }\n-\n-    fn binary_ptr_op(\n-        _: &InterpCx<'mir, 'tcx, Self>,\n-        _: mir::BinOp,\n-        _: ImmTy<'tcx>,\n-        _: ImmTy<'tcx>,\n-    ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n-        panic!();\n-    }\n-\n-    fn ptr_to_int(_: &Memory<'mir, 'tcx, Self>, _: Pointer<()>) -> InterpResult<'tcx, u64> {\n-        panic!();\n-    }\n-\n-    fn box_alloc(_: &mut InterpCx<'mir, 'tcx, Self>, _: PlaceTy<'tcx>) -> InterpResult<'tcx> {\n-        panic!();\n-    }\n-\n-    fn init_allocation_extra<'b>(\n-        _: &(),\n-        _: AllocId,\n-        alloc: Cow<'b, Allocation>,\n-        _: Option<MemoryKind<!>>,\n-    ) -> (Cow<'b, Allocation<(), ()>>, ()) {\n-        (alloc, ())\n-    }\n-\n-    fn tag_global_base_pointer(_: &(), _: AllocId) -> Self::PointerTag {\n-        ()\n-    }\n-\n-    fn call_extra_fn(\n-        _: &mut InterpCx<'mir, 'tcx, Self>,\n-        _: !,\n-        _: &[OpTy<'tcx, ()>],\n-        _: Option<(PlaceTy<'tcx, ()>, BasicBlock)>,\n-        _: Option<BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        unreachable!();\n-    }\n-\n-    fn stack_push(_: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    fn stack_pop(_: &mut InterpCx<'mir, 'tcx, Self>, _: (), _: bool) -> InterpResult<'tcx, StackPopJump> {\n-        Ok(StackPopJump::Normal)\n-    }\n-\n-    fn assert_panic(\n-        _: &mut InterpCx<'mir, 'tcx, Self>,\n-        _: &mir::AssertKind<Operand<'tcx>>,\n-        _: Option<BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n-        unreachable!()\n-    }\n-}\n-\n pub(crate) fn mir_operand_get_const_val<'tcx>(\n     fx: &FunctionCx<'_, 'tcx, impl Backend>,\n     operand: &Operand<'tcx>,"}]}