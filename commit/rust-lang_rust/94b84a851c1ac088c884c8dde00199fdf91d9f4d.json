{"sha": "94b84a851c1ac088c884c8dde00199fdf91d9f4d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0Yjg0YTg1MWMxYWMwODhjODg0YzhkZGUwMDE5OWZkZjkxZDlmNGQ=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T19:29:34Z"}, "committer": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2013-08-22T23:31:58Z"}, "message": "std: all of the calls in rt::uv::file take a &Loop", "tree": {"sha": "27bd672a1f6938318a12fa93b99fbce629407a15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27bd672a1f6938318a12fa93b99fbce629407a15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94b84a851c1ac088c884c8dde00199fdf91d9f4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94b84a851c1ac088c884c8dde00199fdf91d9f4d", "html_url": "https://github.com/rust-lang/rust/commit/94b84a851c1ac088c884c8dde00199fdf91d9f4d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94b84a851c1ac088c884c8dde00199fdf91d9f4d/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f01e26535738601524deba9e5f0a496527ee9d92", "url": "https://api.github.com/repos/rust-lang/rust/commits/f01e26535738601524deba9e5f0a496527ee9d92", "html_url": "https://github.com/rust-lang/rust/commit/f01e26535738601524deba9e5f0a496527ee9d92"}], "stats": {"total": 87, "additions": 43, "deletions": 44}, "files": [{"sha": "1a20ae82f17f105e31a52e96edba2367b9ac0c4e", "filename": "src/libstd/rt/uv/file.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/94b84a851c1ac088c884c8dde00199fdf91d9f4d/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b84a851c1ac088c884c8dde00199fdf91d9f4d/src%2Flibstd%2Frt%2Fuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Ffile.rs?ref=94b84a851c1ac088c884c8dde00199fdf91d9f4d", "patch": "@@ -37,7 +37,7 @@ impl FsRequest {\n         fs_req\n     }\n \n-    fn open_common<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int,\n+    fn open_common<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int,\n                cb: Option<FsCallback>) -> int {\n         let complete_cb_ptr = match cb {\n             Some(_) => compl_cb as *u8,\n@@ -54,17 +54,17 @@ impl FsRequest {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn open<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int,\n+    pub fn open<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int,\n                cb: FsCallback) {\n         FsRequest::open_common(loop_, path, flags, mode, Some(cb));\n     }\n \n-    pub fn open_sync<P: PathLike>(loop_: Loop, path: &P, flags: int, mode: int) -> Result<int, UvError> {\n+    pub fn open_sync<P: PathLike>(loop_: &Loop, path: &P, flags: int, mode: int) -> Result<int, UvError> {\n         let result = FsRequest::open_common(loop_, path, flags, mode, None);\n-        sync_cleanup(&loop_, result)\n+        sync_cleanup(loop_, result)\n     }\n \n-    fn unlink_common<P: PathLike>(loop_: Loop, path: &P, cb: Option<FsCallback>) -> int {\n+    fn unlink_common<P: PathLike>(loop_: &Loop, path: &P, cb: Option<FsCallback>) -> int {\n         let complete_cb_ptr = match cb {\n             Some(_) => compl_cb as *u8,\n             None => 0 as *u8\n@@ -80,13 +80,13 @@ impl FsRequest {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn unlink<P: PathLike>(loop_: Loop, path: &P, cb: FsCallback) {\n+    pub fn unlink<P: PathLike>(loop_: &Loop, path: &P, cb: FsCallback) {\n         let result = FsRequest::unlink_common(loop_, path, Some(cb));\n-        sync_cleanup(&loop_, result);\n+        sync_cleanup(loop_, result);\n     }\n-    pub fn unlink_sync<P: PathLike>(loop_: Loop, path: &P) -> Result<int, UvError> {\n+    pub fn unlink_sync<P: PathLike>(loop_: &Loop, path: &P) -> Result<int, UvError> {\n         let result = FsRequest::unlink_common(loop_, path, None);\n-        sync_cleanup(&loop_, result)\n+        sync_cleanup(loop_, result)\n     }\n \n     pub fn install_req_data(&self, cb: Option<FsCallback>) {\n@@ -158,7 +158,7 @@ impl FileDescriptor {\n     }\n \n     // as per bnoordhuis in #libuv: offset >= 0 uses prwrite instead of write\n-    fn write_common(&mut self, loop_: Loop, buf: Buf, offset: i64, cb: Option<FsCallback>)\n+    fn write_common(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: Option<FsCallback>)\n           -> int {\n         let complete_cb_ptr = match cb {\n             Some(_) => compl_cb as *u8,\n@@ -177,16 +177,16 @@ impl FileDescriptor {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn write(&mut self, loop_: Loop, buf: Buf, offset: i64, cb: FsCallback) {\n+    pub fn write(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: FsCallback) {\n         self.write_common(loop_, buf, offset, Some(cb));\n     }\n-    pub fn write_sync(&mut self, loop_: Loop, buf: Buf, offset: i64)\n+    pub fn write_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n           -> Result<int, UvError> {\n         let result = self.write_common(loop_, buf, offset, None);\n-        sync_cleanup(&loop_, result)\n+        sync_cleanup(loop_, result)\n     }\n \n-    fn read_common(&mut self, loop_: Loop, buf: Buf,\n+    fn read_common(&mut self, loop_: &Loop, buf: Buf,\n                    offset: i64, cb: Option<FsCallback>)\n           -> int {\n         let complete_cb_ptr = match cb {\n@@ -205,16 +205,16 @@ impl FileDescriptor {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn read(&mut self, loop_: Loop, buf: Buf, offset: i64, cb: FsCallback) {\n+    pub fn read(&mut self, loop_: &Loop, buf: Buf, offset: i64, cb: FsCallback) {\n         self.read_common(loop_, buf, offset, Some(cb));\n     }\n-    pub fn read_sync(&mut self, loop_: Loop, buf: Buf, offset: i64)\n+    pub fn read_sync(&mut self, loop_: &Loop, buf: Buf, offset: i64)\n           -> Result<int, UvError> {\n         let result = self.read_common(loop_, buf, offset, None);\n-        sync_cleanup(&loop_, result)\n+        sync_cleanup(loop_, result)\n     }\n \n-    fn close_common(self, loop_: Loop, cb: Option<FsCallback>) -> int {\n+    fn close_common(self, loop_: &Loop, cb: Option<FsCallback>) -> int {\n         let complete_cb_ptr = match cb {\n             Some(_) => compl_cb as *u8,\n             None => 0 as *u8\n@@ -228,12 +228,12 @@ impl FileDescriptor {\n         if is_sync { req.cleanup_and_delete(); }\n         result\n     }\n-    pub fn close(self, loop_: Loop, cb: FsCallback) {\n+    pub fn close(self, loop_: &Loop, cb: FsCallback) {\n         self.close_common(loop_, Some(cb));\n     }\n-    pub fn close_sync(self, loop_: Loop) -> Result<int, UvError> {\n+    pub fn close_sync(self, loop_: &Loop) -> Result<int, UvError> {\n         let result = self.close_common(loop_, None);\n-        sync_cleanup(&loop_, result)\n+        sync_cleanup(loop_, result)\n     }\n }\n extern fn compl_cb(req: *uv_fs_t) {\n@@ -301,26 +301,25 @@ mod test {\n             let read_buf = slice_to_uv_buf(read_mem);\n             let read_buf_ptr: *Buf = &read_buf;\n             let p = Path(path_str);\n-            do FsRequest::open(loop_, &p, create_flags as int, mode as int)\n+            do FsRequest::open(&loop_, &p, create_flags as int, mode as int)\n             |req, uverr| {\n-                let loop_ = req.get_loop();\n                 assert!(uverr.is_none());\n                 let mut fd = FileDescriptor::from_open_req(req);\n                 let raw_fd = fd.native_handle();\n                 let buf = unsafe { *write_buf_ptr };\n-                do fd.write(loop_, buf, -1) |_, uverr| {\n+                do fd.write(&req.get_loop(), buf, -1) |req, uverr| {\n                     let fd = FileDescriptor(raw_fd);\n-                    do fd.close(loop_) |req, _| {\n+                    do fd.close(&req.get_loop()) |req, _| {\n                         let loop_ = req.get_loop();\n                         assert!(uverr.is_none());\n-                        do FsRequest::open(loop_, &Path(path_str), read_flags as int,0)\n+                        do FsRequest::open(&loop_, &Path(path_str), read_flags as int,0)\n                             |req, uverr| {\n                             assert!(uverr.is_none());\n                             let loop_ = req.get_loop();\n                             let mut fd = FileDescriptor::from_open_req(req);\n                             let raw_fd = fd.native_handle();\n                             let read_buf = unsafe { *read_buf_ptr };\n-                            do fd.read(loop_, read_buf, 0) |req, uverr| {\n+                            do fd.read(&loop_, read_buf, 0) |req, uverr| {\n                                 assert!(uverr.is_none());\n                                 let loop_ = req.get_loop();\n                                 // we know nread >=0 because uverr is none..\n@@ -334,8 +333,9 @@ mod test {\n                                                 read_buf.base, nread))\n                                     };\n                                     assert!(read_str == ~\"hello\");\n-                                    do FileDescriptor(raw_fd).close(loop_) |_,uverr| {\n+                                    do FileDescriptor(raw_fd).close(&loop_) |req,uverr| {\n                                         assert!(uverr.is_none());\n+                                        let loop_ = &req.get_loop();\n                                         do FsRequest::unlink(loop_, &Path(path_str))\n                                         |_,uverr| {\n                                             assert!(uverr.is_none());\n@@ -367,26 +367,26 @@ mod test {\n             let write_val = \"hello\".as_bytes().to_owned();\n             let write_buf = slice_to_uv_buf(write_val);\n             // open/create\n-            let result = FsRequest::open_sync(loop_, &Path(path_str),\n+            let result = FsRequest::open_sync(&loop_, &Path(path_str),\n                                                    create_flags as int, mode as int);\n             assert!(result.is_ok());\n             let mut fd = FileDescriptor(result.unwrap() as i32);\n             // write\n-            let result = fd.write_sync(loop_, write_buf, -1);\n+            let result = fd.write_sync(&loop_, write_buf, -1);\n             assert!(result.is_ok());\n             // close\n-            let result = fd.close_sync(loop_);\n+            let result = fd.close_sync(&loop_);\n             assert!(result.is_ok());\n             // re-open\n-            let result = FsRequest::open_sync(loop_, &Path(path_str),\n+            let result = FsRequest::open_sync(&loop_, &Path(path_str),\n                                                    read_flags as int,0);\n             assert!(result.is_ok());\n             let len = 1028;\n             let mut fd = FileDescriptor(result.unwrap() as i32);\n             // read\n             let read_mem: ~[u8] = vec::from_elem(len, 0u8);\n             let buf = slice_to_uv_buf(read_mem);\n-            let result = fd.read_sync(loop_, buf, 0);\n+            let result = fd.read_sync(&loop_, buf, 0);\n             assert!(result.is_ok());\n             let nread = result.unwrap();\n             // nread == 0 would be EOF.. we know it's >= zero because otherwise\n@@ -396,10 +396,10 @@ mod test {\n                     read_mem.slice(0, nread as uint));\n                 assert!(read_str == ~\"hello\");\n                 // close\n-                let result = fd.close_sync(loop_);\n+                let result = fd.close_sync(&loop_);\n                 assert!(result.is_ok());\n                 // unlink\n-                let result = FsRequest::unlink_sync(loop_, &Path(path_str));\n+                let result = FsRequest::unlink_sync(&loop_, &Path(path_str));\n                 assert!(result.is_ok());\n             } else { fail!(\"nread was 0.. wudn't expectin' that.\"); }\n             loop_.close();\n@@ -416,7 +416,7 @@ mod test {\n         file_test_full_simple_impl_sync();\n     }\n \n-    fn naive_print(loop_: Loop, input: &str) {\n+    fn naive_print(loop_: &Loop, input: &str) {\n         let mut stdout = FileDescriptor(STDOUT_FILENO);\n         let write_val = input.as_bytes();\n         let write_buf = slice_to_uv_buf(write_val);\n@@ -427,7 +427,7 @@ mod test {\n     fn file_test_write_to_stdout() {\n         do run_in_bare_thread {\n             let mut loop_ = Loop::new();\n-            naive_print(loop_, \"zanzibar!\\n\");\n+            naive_print(&loop_, \"zanzibar!\\n\");\n             loop_.run();\n             loop_.close();\n         };"}, {"sha": "63ff446ecf02b644b100d05bfff32298b38413f9", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94b84a851c1ac088c884c8dde00199fdf91d9f4d/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94b84a851c1ac088c884c8dde00199fdf91d9f4d/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=94b84a851c1ac088c884c8dde00199fdf91d9f4d", "patch": "@@ -468,7 +468,6 @@ impl IoFactory for UvIoFactory {\n \n     fn fs_open<P: PathLike>(&mut self, path: &P, flags: int, mode: int)\n         -> Result<~RtioFileStream, IoError> {\n-        let loop_ = Loop {handle: self.uv_loop().native_handle()};\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<~RtioFileStream,\n                                            IoError>> = &result_cell;\n@@ -477,8 +476,9 @@ impl IoFactory for UvIoFactory {\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n             let path = path_cell.take();\n-            do file::FsRequest::open(loop_, path, flags, mode) |req,err| {\n+            do file::FsRequest::open(self.uv_loop(), path, flags, mode) |req,err| {\n                 if err.is_none() {\n+                    let loop_ = Loop {handle: req.get_loop().native_handle()};\n                     let home = get_handle_to_current_scheduler!();\n                     let fd = file::FileDescriptor(req.get_result());\n                     let fs = ~UvFileStream::new(\n@@ -500,15 +500,14 @@ impl IoFactory for UvIoFactory {\n     }\n \n     fn fs_unlink<P: PathLike>(&mut self, path: &P) -> Result<(), IoError> {\n-        let loop_ = Loop {handle: self.uv_loop().native_handle()};\n         let result_cell = Cell::new_empty();\n         let result_cell_ptr: *Cell<Result<(), IoError>> = &result_cell;\n         let path_cell = Cell::new(path);\n         let scheduler = Local::take::<Scheduler>();\n         do scheduler.deschedule_running_task_and_then |_, task| {\n             let task_cell = Cell::new(task);\n             let path = path_cell.take();\n-            do file::FsRequest::unlink(loop_, path) |_, err| {\n+            do file::FsRequest::unlink(self.uv_loop(), path) |_, err| {\n                 let res = match err {\n                     None => Ok(()),\n                     Some(err) => Err(uv_error_to_io_error(err))\n@@ -1088,7 +1087,7 @@ impl UvFileStream {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n                 let task_cell = Cell::new(task);\n-                do self_.fd.read(self.loop_, buf, offset) |req, uverr| {\n+                do self_.fd.read(&self_.loop_, buf, offset) |req, uverr| {\n                     let res = match uverr  {\n                         None => Ok(req.get_result() as int),\n                         Some(err) => Err(uv_error_to_io_error(err))\n@@ -1110,7 +1109,7 @@ impl UvFileStream {\n             do scheduler.deschedule_running_task_and_then |_, task| {\n                 let buf = unsafe { slice_to_uv_buf(*buf_ptr) };\n                 let task_cell = Cell::new(task);\n-                do self_.fd.write(self.loop_, buf, offset) |_, uverr| {\n+                do self_.fd.write(&self_.loop_, buf, offset) |_, uverr| {\n                     let res = match uverr  {\n                         None => Ok(()),\n                         Some(err) => Err(uv_error_to_io_error(err))\n@@ -1133,7 +1132,7 @@ impl Drop for UvFileStream {\n                 let scheduler = Local::take::<Scheduler>();\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     let task_cell = Cell::new(task);\n-                    do self_.fd.close(self.loop_) |_,_| {\n+                    do self_.fd.close(&self.loop_) |_,_| {\n                         let scheduler = Local::take::<Scheduler>();\n                         scheduler.resume_blocked_task_immediately(task_cell.take());\n                     };"}]}