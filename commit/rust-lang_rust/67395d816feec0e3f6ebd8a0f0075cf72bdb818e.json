{"sha": "67395d816feec0e3f6ebd8a0f0075cf72bdb818e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3Mzk1ZDgxNmZlZWMwZTNmNmViZDhhMGYwMDc1Y2Y3MmJkYjgxOGU=", "commit": {"author": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2016-02-29T10:51:05Z"}, "committer": {"name": "Adolfo Ochagav\u00eda", "email": "aochagavia92@gmail.com", "date": "2016-03-15T21:50:18Z"}, "message": "Refactor rustc_trans::save\n\nMove rustc_trans::*Data to own module\nAdd new data to rustc_trans::save\nCreate a Dump trait implemented by structs that dump save analysis data\nSplit dump_csv into a DumpVisitor and a CsvDumper", "tree": {"sha": "86946d29909d5b0c0abbb7a011d02e6359e9dcbe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86946d29909d5b0c0abbb7a011d02e6359e9dcbe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67395d816feec0e3f6ebd8a0f0075cf72bdb818e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67395d816feec0e3f6ebd8a0f0075cf72bdb818e", "html_url": "https://github.com/rust-lang/rust/commit/67395d816feec0e3f6ebd8a0f0075cf72bdb818e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/comments", "author": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aochagavia", "id": 5196584, "node_id": "MDQ6VXNlcjUxOTY1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5196584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aochagavia", "html_url": "https://github.com/aochagavia", "followers_url": "https://api.github.com/users/aochagavia/followers", "following_url": "https://api.github.com/users/aochagavia/following{/other_user}", "gists_url": "https://api.github.com/users/aochagavia/gists{/gist_id}", "starred_url": "https://api.github.com/users/aochagavia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aochagavia/subscriptions", "organizations_url": "https://api.github.com/users/aochagavia/orgs", "repos_url": "https://api.github.com/users/aochagavia/repos", "events_url": "https://api.github.com/users/aochagavia/events{/privacy}", "received_events_url": "https://api.github.com/users/aochagavia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e125f04a54ec65eac0ecd3cb68e180210a06fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e125f04a54ec65eac0ecd3cb68e180210a06fa", "html_url": "https://github.com/rust-lang/rust/commit/f6e125f04a54ec65eac0ecd3cb68e180210a06fa"}], "stats": {"total": 2612, "additions": 1459, "deletions": 1153}, "files": [{"sha": "2a5b7d9567be779ae22a115dd78cd61ef02e507e", "filename": "src/librustc_trans/save/csv_dumper.rs", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/rust-lang/rust/blob/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fcsv_dumper.rs?ref=67395d816feec0e3f6ebd8a0f0075cf72bdb818e", "patch": "@@ -0,0 +1,566 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::Write;\n+\n+use middle::def_id::{DefId, DefIndex};\n+use syntax::codemap::Span;\n+\n+use super::data::*;\n+use super::dump::Dump;\n+use super::span_utils::SpanUtils;\n+\n+pub struct CsvDumper<'a, 'b, W: 'b> {\n+    output: &'b mut W,\n+    dump_spans: bool,\n+    span: SpanUtils<'a>\n+}\n+\n+impl<'a, 'b, W: Write> CsvDumper<'a, 'b, W> {\n+    pub fn new(writer: &'b mut W, span: SpanUtils<'a>) -> CsvDumper<'a, 'b, W> {\n+        CsvDumper { output: writer, dump_spans: false, span: span }\n+    }\n+\n+    fn record(&mut self, kind: &str, span: Span, values: String) {\n+        let span_str = self.span.extent_str(span);\n+        if let Err(_) = write!(self.output, \"{},{}{}\\n\", kind, span_str, values) {\n+            error!(\"Error writing output\");\n+        }\n+    }\n+\n+    fn record_raw(&mut self, info: &str) {\n+        if let Err(_) = write!(self.output, \"{}\", info) {\n+            error!(\"Error writing output '{}'\", info);\n+        }\n+    }\n+\n+    pub fn dump_span(&mut self, kind: &str, span: Span) {\n+        assert!(self.dump_spans);\n+        let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n+                             kind,\n+                             self.span.extent_str(span),\n+                             escape(self.span.snippet(span)));\n+        self.record_raw(&result);\n+    }\n+}\n+\n+impl<'a, 'b, W: Write + 'b> Dump for CsvDumper<'a, 'b, W> {\n+    fn crate_prelude(&mut self, span: Span, data: CratePreludeData) {\n+        let crate_root = data.crate_root.unwrap_or(\"<no source>\".to_owned());\n+\n+        let values = make_values_str(&[\n+            (\"name\", &data.crate_name),\n+            (\"crate_root\", &crate_root)\n+        ]);\n+\n+        self.record(\"crate\", span, values);\n+\n+        for c in data.external_crates {\n+            let num = c.num.to_string();\n+            let lo_loc = self.span.sess.codemap().lookup_char_pos(span.lo);\n+            let file_name = SpanUtils::make_path_string(&lo_loc.file.name);\n+            let values = make_values_str(&[\n+                (\"name\", &c.name),\n+                (\"crate\", &num),\n+                (\"file_name\", &file_name)\n+            ]);\n+\n+            self.record_raw(&format!(\"external_crate{}\\n\", values));\n+        }\n+\n+        self.record_raw(\"end_external_crates\\n\");\n+    }\n+\n+    fn enum_data(&mut self, span: Span, data: EnumData) {\n+        if self.dump_spans {\n+            self.dump_span(\"enum\", span);\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"qualname\", &data.qualname),\n+            (\"scopeid\", &scope),\n+            (\"value\", &data.value)\n+        ]);\n+\n+        self.record(\"enum\", data.span, values);\n+    }\n+\n+    fn extern_crate(&mut self, span: Span, data: ExternCrateData) {\n+        if self.dump_spans {\n+            self.dump_span(\"extern_crate\", span);\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let crate_num = data.crate_num.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"name\", &data.name),\n+            (\"location\", &data.location),\n+            (\"crate\", &crate_num),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"extern_crate\", data.span, values);\n+    }\n+\n+    fn impl_data(&mut self, span: Span, data: ImplData) {\n+        if self.dump_spans {\n+            self.dump_span(\"impl\", span);\n+            return;\n+        }\n+\n+        let self_ref = data.self_ref.unwrap_or(null_def_id());\n+        let trait_ref = data.trait_ref.unwrap_or(null_def_id());\n+\n+        let id = data.id.to_string();\n+        let ref_id = self_ref.index.as_usize().to_string();\n+        let ref_id_crate = self_ref.krate.to_string();\n+        let trait_id = trait_ref.index.as_usize().to_string();\n+        let trait_id_crate = trait_ref.krate.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_id_crate),\n+            (\"traitid\", &trait_id),\n+            (\"traitidcrate\", &trait_id_crate),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"impl\", data.span, values);\n+    }\n+\n+    fn inheritance(&mut self, data: InheritanceData) {\n+       if self.dump_spans {\n+           return;\n+       }\n+\n+       let base_id = data.base_id.index.as_usize().to_string();\n+       let base_crate = data.base_id.krate.to_string();\n+       let deriv_id = data.deriv_id.to_string();\n+       let deriv_crate = 0.to_string();\n+       let values = make_values_str(&[\n+           (\"base\", &base_id),\n+           (\"basecrate\", &base_crate),\n+           (\"derived\", &deriv_id),\n+           (\"derivedcrate\", &deriv_crate)\n+       ]);\n+\n+       self.record(\"inheritance\", data.span, values);\n+    }\n+\n+    fn function(&mut self, span: Span, data: FunctionData) {\n+        if self.dump_spans {\n+            self.dump_span(\"function\", span);\n+            return;\n+        }\n+\n+        let (decl_id, decl_crate) = match data.declaration {\n+            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n+            None => (String::new(), String::new())\n+        };\n+\n+        let id = data.id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"qualname\", &data.qualname),\n+            (\"declid\", &decl_id),\n+            (\"declidcrate\", &decl_crate),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"function\", data.span, values);\n+    }\n+\n+    fn function_ref(&mut self, span: Span, data: FunctionRefData) {\n+        if self.dump_spans {\n+            self.dump_span(\"fn_ref\", span);\n+            return;\n+        }\n+\n+        let ref_id = data.ref_id.index.as_usize().to_string();\n+        let ref_crate = data.ref_id.krate.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n+            (\"qualname\", \"\"),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"fn_ref\", data.span, values);\n+    }\n+\n+    fn function_call(&mut self, span: Span, data: FunctionCallData) {\n+        if self.dump_spans {\n+            self.dump_span(\"fn_call\", span);\n+            return;\n+        }\n+\n+        let ref_id = data.ref_id.index.as_usize().to_string();\n+        let ref_crate = data.ref_id.krate.to_string();\n+        let qualname = String::new();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n+            (\"qualname\", &qualname),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"fn_call\", data.span, values);\n+    }\n+\n+    fn method(&mut self, span: Span, data: MethodData) {\n+        if self.dump_spans {\n+            self.dump_span(\"method_decl\", span);\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"qualname\", &data.qualname),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"method_decl\", span, values);\n+    }\n+\n+    fn method_call(&mut self, span: Span, data: MethodCallData) {\n+        if self.dump_spans {\n+            self.dump_span(\"method_call\", span);\n+            return;\n+        }\n+\n+        let (dcn, dck) = match data.decl_id {\n+            Some(declid) => (declid.index.as_usize().to_string(), declid.krate.to_string()),\n+            None => (String::new(), String::new()),\n+        };\n+\n+        let ref_id = data.ref_id.unwrap_or(null_def_id());\n+\n+        let def_id = ref_id.index.as_usize().to_string();\n+        let def_crate = ref_id.krate.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"refid\", &def_id),\n+            (\"refidcrate\", &def_crate),\n+            (\"declid\", &dcn),\n+            (\"declidcrate\", &dck),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"method_call\", data.span, values);\n+    }\n+\n+    fn macro_data(&mut self, span: Span, data: MacroData) {\n+        if self.dump_spans {\n+            self.dump_span(\"macro\", span);\n+            return;\n+        }\n+\n+        let values = make_values_str(&[\n+            (\"name\", &data.name),\n+            (\"qualname\", &data.qualname)\n+        ]);\n+\n+        self.record(\"macro\", data.span, values);\n+    }\n+\n+    fn macro_use(&mut self, span: Span, data: MacroUseData) {\n+        if self.dump_spans {\n+            self.dump_span(\"macro_use\", span);\n+            return;\n+        }\n+\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"callee_name\", &data.name),\n+            (\"qualname\", &data.qualname),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"macro_use\", data.span, values);\n+    }\n+\n+    fn mod_data(&mut self, data: ModData) {\n+        if self.dump_spans {\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"qualname\", &data.qualname),\n+            (\"scopeid\", &scope),\n+            (\"def_file\", &data.filename)\n+        ]);\n+\n+        self.record(\"module\", data.span, values);\n+    }\n+\n+    fn mod_ref(&mut self, span: Span, data: ModRefData) {\n+        if self.dump_spans {\n+            self.dump_span(\"mod_ref\", span);\n+            return;\n+        }\n+\n+        let (ref_id, ref_crate) = match data.ref_id {\n+            Some(rid) => (rid.index.as_usize().to_string(), rid.krate.to_string()),\n+            None => (0.to_string(), 0.to_string())\n+        };\n+\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n+            (\"qualname\", &data.qualname),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"mod_ref\", data.span, values);\n+    }\n+\n+    fn struct_data(&mut self, span: Span, data: StructData) {\n+        if self.dump_spans {\n+            self.dump_span(\"struct\", span);\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let ctor_id = data.ctor_id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"ctor_id\", &ctor_id),\n+            (\"qualname\", &data.qualname),\n+            (\"scopeid\", &scope),\n+            (\"value\", &data.value)\n+        ]);\n+\n+        self.record(\"struct\", data.span, values);\n+    }\n+\n+    fn struct_variant(&mut self, span: Span, data: StructVariantData) {\n+        if self.dump_spans {\n+            self.dump_span(\"variant_struct\", span);\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"ctor_id\", &id),\n+            (\"qualname\", &data.qualname),\n+            (\"type\", &data.type_value),\n+            (\"value\", &data.value),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"variant_struct\", data.span, values);\n+    }\n+\n+    fn trait_data(&mut self, span: Span, data: TraitData) {\n+        if self.dump_spans {\n+            self.dump_span(\"trait\", span);\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"qualname\", &data.qualname),\n+            (\"scopeid\", &scope),\n+            (\"value\", &data.value)\n+        ]);\n+\n+        self.record(\"trait\", data.span, values);\n+    }\n+\n+    fn tuple_variant(&mut self, span: Span, data: TupleVariantData) {\n+        if self.dump_spans {\n+            self.dump_span(\"variant\", span);\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"name\", &data.name),\n+            (\"qualname\", &data.qualname),\n+            (\"type\", &data.type_value),\n+            (\"value\", &data.value),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"variant\", data.span, values);\n+    }\n+\n+    fn type_ref(&mut self, span: Span, data: TypeRefData) {\n+        if self.dump_spans {\n+            self.dump_span(\"type_ref\", span);\n+            return;\n+        }\n+\n+        let (ref_id, ref_crate) = match data.ref_id {\n+            Some(id) => (id.index.as_usize().to_string(), id.krate.to_string()),\n+            None => (0.to_string(), 0.to_string())\n+        };\n+\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n+            (\"qualname\", &data.qualname),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"type_ref\", data.span, values);\n+    }\n+\n+    fn typedef(&mut self, span: Span, data: TypedefData) {\n+        if self.dump_spans {\n+            self.dump_span(\"typedef\", span);\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"qualname\", &data.qualname),\n+            (\"value\", &data.value)\n+        ]);\n+\n+        self.record(\"typedef\", data.span, values);\n+    }\n+\n+    fn use_data(&mut self, span: Span, data: UseData) {\n+        if self.dump_spans {\n+            self.dump_span(\"use_alias\", span);\n+            return;\n+        }\n+\n+        let mod_id = data.mod_id.unwrap_or(null_def_id());\n+\n+        let id = data.id.to_string();\n+        let ref_id = mod_id.index.as_usize().to_string();\n+        let ref_crate = mod_id.krate.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n+            (\"name\", &data.name),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"use_alias\", data.span, values);\n+    }\n+\n+    fn use_glob(&mut self, span: Span, data: UseGlobData) {\n+        if self.dump_spans {\n+            self.dump_span(\"use_glob\", span);\n+            return;\n+        }\n+\n+        let names = data.names.join(\", \");\n+\n+        let id = data.id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"value\", &names),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"use_glob\", data.span, values);\n+    }\n+\n+    fn variable(&mut self, span: Span, data: VariableData) {\n+        if self.dump_spans {\n+            self.dump_span(\"variable\", span);\n+            return;\n+        }\n+\n+        let id = data.id.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"id\", &id),\n+            (\"name\", &data.name),\n+            (\"qualname\", &data.qualname),\n+            (\"value\", &data.value),\n+            (\"type\", &data.type_value),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"variable\", data.span, values);\n+    }\n+\n+    fn variable_ref(&mut self, span: Span, data: VariableRefData) {\n+        if self.dump_spans {\n+            self.dump_span(\"var_ref\", span);\n+            return;\n+        }\n+\n+        let ref_id = data.ref_id.index.as_usize().to_string();\n+        let ref_crate = data.ref_id.krate.to_string();\n+        let scope = data.scope.to_string();\n+        let values = make_values_str(&[\n+            (\"refid\", &ref_id),\n+            (\"refidcrate\", &ref_crate),\n+            (\"qualname\", \"\"),\n+            (\"scopeid\", &scope)\n+        ]);\n+\n+        self.record(\"var_ref\", data.span, values)\n+    }\n+}\n+\n+// Helper function to escape quotes in a string\n+fn escape(s: String) -> String {\n+    s.replace(\"\\\"\", \"\\\"\\\"\")\n+}\n+\n+fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n+    let pairs = pairs.into_iter().map(|&(f, v)| {\n+        // Never take more than 1020 chars\n+        if v.len() > 1020 {\n+            (f, &v[..1020])\n+        } else {\n+            (f, v)\n+        }\n+    });\n+\n+    let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from(v))));\n+    strs.fold(String::new(), |mut s, ss| {\n+        s.push_str(&ss[..]);\n+        s\n+    })\n+}\n+\n+fn null_def_id() -> DefId {\n+    DefId {\n+        krate: 0,\n+        index: DefIndex::new(0),\n+    }\n+}"}, {"sha": "3eaaa3fc4930c1edf576419c4feb66b8669761da", "filename": "src/librustc_trans/save/data.rs", "status": "added", "additions": 394, "deletions": 0, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdata.rs?ref=67395d816feec0e3f6ebd8a0f0075cf72bdb818e", "patch": "@@ -0,0 +1,394 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Structs representing the analysis data from a crate.\n+//!\n+//! The `Dump` trait can be used together with `DumpVisitor` in order to\n+//! retrieve the data from a crate.\n+\n+use std::hash::Hasher;\n+\n+use middle::def_id::DefId;\n+use middle::ty;\n+use syntax::ast::{CrateNum, NodeId};\n+use syntax::codemap::Span;\n+\n+#[macro_export]\n+macro_rules! down_cast_data {\n+    ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n+        let $id = if let super::Data::$kind(data) = $id {\n+            data\n+        } else {\n+            $this.sess.span_bug($sp, &format!(\"unexpected data kind: {:?}\", $id));\n+        }\n+    };\n+}\n+\n+pub struct CrateData {\n+    pub name: String,\n+    pub number: u32,\n+}\n+\n+/// Data for any entity in the Rust language. The actual data contained varies\n+/// with the kind of entity being queried. See the nested structs for details.\n+#[derive(Debug)]\n+pub enum Data {\n+    /// Data for Enums.\n+    EnumData(EnumData),\n+    /// Data for extern crates.\n+    ExternCrateData(ExternCrateData),\n+    /// Data about a function call.\n+    FunctionCallData(FunctionCallData),\n+    /// Data for all kinds of functions and methods.\n+    FunctionData(FunctionData),\n+    /// Data about a function ref.\n+    FunctionRefData(FunctionRefData),\n+    /// Data for impls.\n+    ImplData(ImplData2),\n+    /// Data for trait inheritance.\n+    InheritanceData(InheritanceData),\n+    /// Data about a macro declaration.\n+    MacroData(MacroData),\n+    /// Data about a macro use.\n+    MacroUseData(MacroUseData),\n+    /// Data about a method call.\n+    MethodCallData(MethodCallData),\n+    /// Data for method declarations (methods with a body are treated as functions).\n+    MethodData(MethodData),\n+    /// Data for modules.\n+    ModData(ModData),\n+    /// Data for a reference to a module.\n+    ModRefData(ModRefData),\n+    /// Data for a struct declaration.\n+    StructData(StructData),\n+    /// Data for a struct variant.\n+    StructVariantDat(StructVariantData),\n+    /// Data for a trait declaration.\n+    TraitData(TraitData),\n+    /// Data for a tuple variant.\n+    TupleVariantData(TupleVariantData),\n+    /// Data for a typedef.\n+    TypeDefData(TypedefData),\n+    /// Data for a reference to a type or trait.\n+    TypeRefData(TypeRefData),\n+    /// Data for a use statement.\n+    UseData(UseData),\n+    /// Data for a global use statement.\n+    UseGlobData(UseGlobData),\n+    /// Data for local and global variables (consts and statics), and fields.\n+    VariableData(VariableData),\n+    /// Data for the use of some variable (e.g., the use of a local variable, which\n+    /// will refere to that variables declaration).\n+    VariableRefData(VariableRefData),\n+}\n+\n+/// Data for the prelude of a crate.\n+#[derive(Debug)]\n+pub struct CratePreludeData {\n+    pub crate_name: String,\n+    pub crate_root: Option<String>,\n+    pub external_crates: Vec<ExternalCrateData>\n+}\n+\n+/// Data for external crates in the prelude of a crate.\n+#[derive(Debug)]\n+pub struct ExternalCrateData {\n+    pub name: String,\n+    pub num: CrateNum\n+}\n+\n+/// Data for enum declarations.\n+#[derive(Clone, Debug)]\n+pub struct EnumData {\n+    pub id: NodeId,\n+    pub value: String,\n+    pub qualname: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+}\n+\n+/// Data for extern crates.\n+#[derive(Debug)]\n+pub struct ExternCrateData {\n+    pub id: NodeId,\n+    pub name: String,\n+    pub crate_num: CrateNum,\n+    pub location: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+}\n+\n+/// Data about a function call.\n+#[derive(Debug)]\n+pub struct FunctionCallData {\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: DefId,\n+}\n+\n+/// Data for all kinds of functions and methods.\n+#[derive(Clone, Debug)]\n+pub struct FunctionData {\n+    pub id: NodeId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub declaration: Option<DefId>,\n+    pub span: Span,\n+    pub scope: NodeId,\n+}\n+\n+/// Data about a function call.\n+#[derive(Debug)]\n+pub struct FunctionRefData {\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: DefId,\n+}\n+\n+#[derive(Debug)]\n+pub struct ImplData {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub trait_ref: Option<DefId>,\n+    pub self_ref: Option<DefId>,\n+}\n+\n+#[derive(Debug)]\n+// FIXME: this struct should not exist. However, removing it requires heavy\n+// refactoring of dump_visitor.rs. See PR 31838 for more info.\n+pub struct ImplData2 {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    // FIXME: I'm not really sure inline data is the best way to do this. Seems\n+    // OK in this case, but generalising leads to returning chunks of AST, which\n+    // feels wrong.\n+    pub trait_ref: Option<TypeRefData>,\n+    pub self_ref: Option<TypeRefData>,\n+}\n+\n+#[derive(Debug)]\n+pub struct InheritanceData {\n+    pub span: Span,\n+    pub base_id: DefId,\n+    pub deriv_id: NodeId\n+}\n+\n+/// Data about a macro declaration.\n+#[derive(Debug)]\n+pub struct MacroData {\n+    pub span: Span,\n+    pub name: String,\n+    pub qualname: String,\n+}\n+\n+/// Data about a macro use.\n+#[derive(Debug)]\n+pub struct MacroUseData {\n+    pub span: Span,\n+    pub name: String,\n+    pub qualname: String,\n+    // Because macro expansion happens before ref-ids are determined,\n+    // we use the callee span to reference the associated macro definition.\n+    pub callee_span: Span,\n+    pub scope: NodeId,\n+    pub imported: bool,\n+}\n+\n+/// Data about a method call.\n+#[derive(Debug)]\n+pub struct MethodCallData {\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: Option<DefId>,\n+    pub decl_id: Option<DefId>,\n+}\n+\n+/// Data for method declarations (methods with a body are treated as functions).\n+#[derive(Clone, Debug)]\n+pub struct MethodData {\n+    pub id: NodeId,\n+    pub qualname: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+}\n+\n+/// Data for modules.\n+#[derive(Debug)]\n+pub struct ModData {\n+    pub id: NodeId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub filename: String,\n+}\n+\n+/// Data for a reference to a module.\n+#[derive(Debug)]\n+pub struct ModRefData {\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: Option<DefId>,\n+    pub qualname: String\n+}\n+\n+#[derive(Debug)]\n+pub struct StructData {\n+    pub span: Span,\n+    pub id: NodeId,\n+    pub ctor_id: NodeId,\n+    pub qualname: String,\n+    pub scope: NodeId,\n+    pub value: String\n+}\n+\n+#[derive(Debug)]\n+pub struct StructVariantData {\n+    pub span: Span,\n+    pub id: NodeId,\n+    pub qualname: String,\n+    pub type_value: String,\n+    pub value: String,\n+    pub scope: NodeId\n+}\n+\n+#[derive(Debug)]\n+pub struct TraitData {\n+    pub span: Span,\n+    pub id: NodeId,\n+    pub qualname: String,\n+    pub scope: NodeId,\n+    pub value: String\n+}\n+\n+#[derive(Debug)]\n+pub struct TupleVariantData {\n+    pub span: Span,\n+    pub id: NodeId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub type_value: String,\n+    pub value: String,\n+    pub scope: NodeId\n+}\n+\n+/// Data for a typedef.\n+#[derive(Debug)]\n+pub struct TypedefData {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub qualname: String,\n+    pub value: String,\n+}\n+\n+/// Data for a reference to a type or trait.\n+#[derive(Clone, Debug)]\n+pub struct TypeRefData {\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: Option<DefId>,\n+    pub qualname: String,\n+}\n+\n+#[derive(Debug)]\n+pub struct UseData {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub name: String,\n+    pub mod_id: Option<DefId>,\n+    pub scope: NodeId\n+}\n+\n+#[derive(Debug)]\n+pub struct UseGlobData {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub names: Vec<String>,\n+    pub scope: NodeId\n+}\n+\n+/// Data for local and global variables (consts and statics).\n+#[derive(Debug)]\n+pub struct VariableData {\n+    pub id: NodeId,\n+    pub name: String,\n+    pub qualname: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub value: String,\n+    pub type_value: String,\n+}\n+\n+/// Data for the use of some item (e.g., the use of a local variable, which\n+/// will refer to that variables declaration (by ref_id)).\n+#[derive(Debug)]\n+pub struct VariableRefData {\n+    pub name: String,\n+    pub span: Span,\n+    pub scope: NodeId,\n+    pub ref_id: DefId,\n+}\n+\n+// Emitted ids are used to cross-reference items across crates. DefIds and\n+// NodeIds do not usually correspond in any way. The strategy is to use the\n+// index from the DefId as a crate-local id. However, within a crate, DefId\n+// indices and NodeIds can overlap. So, we must adjust the NodeIds. If an\n+// item can be identified by a DefId as well as a NodeId, then we use the\n+// DefId index as the id. If it can't, then we have to use the NodeId, but\n+// need to adjust it so it will not clash with any possible DefId index.\n+pub fn normalize_node_id<'a>(tcx: &ty::TyCtxt<'a>, id: NodeId) -> usize {\n+    match tcx.map.opt_local_def_id(id) {\n+        Some(id) => id.index.as_usize(),\n+        None => id as usize + tcx.map.num_local_def_ids()\n+    }\n+}\n+\n+// Macro to implement a normalize() function (see below for usage)\n+macro_rules! impl_normalize {\n+    ($($t:ty => $($field:ident),*);*) => {\n+        $(\n+            impl $t {\n+                pub fn normalize<'a>(mut self, tcx: &ty::TyCtxt<'a>) -> $t {\n+                    $(\n+                        self.$field = normalize_node_id(tcx, self.$field) as u32;\n+                    )*\n+                    self\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl_normalize! {\n+    EnumData => id, scope;\n+    ExternCrateData => id, scope;\n+    FunctionCallData => scope;\n+    FunctionData => id, scope;\n+    FunctionRefData => scope;\n+    ImplData => id, scope;\n+    InheritanceData => deriv_id;\n+    MacroUseData => scope;\n+    MethodCallData => scope;\n+    MethodData => id, scope;\n+    ModData => id, scope;\n+    ModRefData => scope;\n+    StructData => ctor_id, id, scope;\n+    StructVariantData => id, scope;\n+    TupleVariantData => id, scope;\n+    TraitData => id, scope;\n+    TypedefData => id;\n+    TypeRefData => scope;\n+    UseData => id, scope;\n+    UseGlobData => id, scope;\n+    VariableData => id;\n+    VariableRefData => scope\n+}"}, {"sha": "b0cc7926f4e3491331053c2824ab9575c8f11f3a", "filename": "src/librustc_trans/save/dump.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fdump.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fdump.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump.rs?ref=67395d816feec0e3f6ebd8a0f0075cf72bdb818e", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::codemap::Span;\n+\n+use super::data::*;\n+\n+pub trait Dump {\n+    fn crate_prelude(&mut self, _: Span, _: CratePreludeData) {}\n+    fn enum_data(&mut self, _: Span, _: EnumData) {}\n+    fn extern_crate(&mut self, _: Span, _: ExternCrateData) {}\n+    fn impl_data(&mut self, _: Span, _: ImplData) {}\n+    fn inheritance(&mut self, _: InheritanceData) {}\n+    fn function(&mut self, _: Span, _: FunctionData) {}\n+    fn function_ref(&mut self, _: Span, _: FunctionRefData) {}\n+    fn function_call(&mut self, _: Span, _: FunctionCallData) {}\n+    fn method(&mut self, _: Span, _: MethodData) {}\n+    fn method_call(&mut self, _: Span, _: MethodCallData) {}\n+    fn macro_data(&mut self, _: Span, _: MacroData) {}\n+    fn macro_use(&mut self, _: Span, _: MacroUseData) {}\n+    fn mod_data(&mut self, _: ModData) {}\n+    fn mod_ref(&mut self, _: Span, _: ModRefData) {}\n+    fn struct_data(&mut self, _: Span, _: StructData) {}\n+    fn struct_variant(&mut self, _: Span, _: StructVariantData) {}\n+    fn trait_data(&mut self, _: Span, _: TraitData) {}\n+    fn tuple_variant(&mut self, _: Span, _: TupleVariantData) {}\n+    fn type_ref(&mut self, _: Span, _: TypeRefData) {}\n+    fn typedef(&mut self, _: Span, _: TypedefData) {}\n+    fn use_data(&mut self, _: Span, _: UseData) {}\n+    fn use_glob(&mut self, _: Span, _: UseGlobData) {}\n+    fn variable(&mut self, _: Span, _: VariableData) {}\n+    fn variable_ref(&mut self, _: Span, _: VariableRefData) {}\n+}"}, {"sha": "65f48d1ff5eb5be555eeb7984db70a9a11d01365", "filename": "src/librustc_trans/save/dump_visitor.rs", "status": "renamed", "additions": 415, "deletions": 273, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_visitor.rs?ref=67395d816feec0e3f6ebd8a0f0075cf72bdb818e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Output a CSV file containing the output from rustc's analysis. The data is\n+//! Write the output of rustc's analysis to an implementor of Dump. The data is\n //! primarily designed to be used as input to the DXR tool, specifically its\n //! Rust plugin. It could also be used by IDEs or other code browsing, search, or\n //! cross-referencing tools.\n@@ -23,22 +23,18 @@\n //!\n //! SpanUtils is used to manipulate spans. In particular, to extract sub-spans\n //! from spans (e.g., the span for `bar` from the above example path).\n-//! Recorder is used for recording the output in csv format. FmtStrs separates\n-//! the format of the output away from extracting it from the compiler.\n-//! DumpCsvVisitor walks the AST and processes it.\n-\n-\n-use super::{escape, generated_code, recorder, SaveContext, PathCollector, Data};\n+//! DumpVisitor walks the AST and processes it, and an implementor of Dump\n+//! is used for recording the output in a format-agnostic way (see CsvDumper\n+//! for an example).\n \n use session::Session;\n \n use middle::def::Def;\n use middle::def_id::DefId;\n use middle::ty::{self, TyCtxt};\n \n-use std::fs::File;\n-use std::hash::*;\n use std::collections::HashSet;\n+use std::hash::*;\n \n use syntax::ast::{self, NodeId, PatKind};\n use syntax::codemap::*;\n@@ -49,8 +45,11 @@ use syntax::ptr::P;\n \n use rustc_front::lowering::{lower_expr, LoweringContext};\n \n+use super::{escape, generated_code, SaveContext, PathCollector};\n+use super::data::*;\n+use super::dump::Dump;\n use super::span_utils::SpanUtils;\n-use super::recorder::{Recorder, FmtStrs};\n+use super::recorder;\n \n macro_rules! down_cast_data {\n     ($id:ident, $kind:ident, $this:ident, $sp:expr) => {\n@@ -62,14 +61,14 @@ macro_rules! down_cast_data {\n     };\n }\n \n-pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n+pub struct DumpVisitor<'l, 'tcx: 'l, D: 'l> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n     sess: &'l Session,\n     tcx: &'l TyCtxt<'tcx>,\n     analysis: &'l ty::CrateAnalysis<'l>,\n+    dumper: &'l mut D,\n \n     span: SpanUtils<'l>,\n-    fmt: FmtStrs<'l, 'tcx>,\n \n     cur_scope: NodeId,\n \n@@ -82,33 +81,30 @@ pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n \n }\n \n-impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n+impl <'l, 'tcx, D> DumpVisitor<'l, 'tcx, D>\n+where D: Dump\n+{\n     pub fn new(tcx: &'l TyCtxt<'tcx>,\n                lcx: &'l LoweringContext<'l>,\n                analysis: &'l ty::CrateAnalysis<'l>,\n-               output_file: Box<File>)\n-               -> DumpCsvVisitor<'l, 'tcx> {\n+               dumper: &'l mut D)\n+               -> DumpVisitor<'l, 'tcx, D> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n-        DumpCsvVisitor {\n+        DumpVisitor {\n             sess: &tcx.sess,\n             tcx: tcx,\n             save_ctxt: SaveContext::from_span_utils(tcx, lcx, span_utils.clone()),\n             analysis: analysis,\n+            dumper: dumper,\n             span: span_utils.clone(),\n-            fmt: FmtStrs::new(box Recorder {\n-                                  out: output_file,\n-                                  dump_spans: false,\n-                              },\n-                              span_utils,\n-                              tcx),\n             cur_scope: 0,\n             mac_defs: HashSet::new(),\n             mac_uses: HashSet::new(),\n         }\n     }\n \n     fn nest<F>(&mut self, scope_id: NodeId, f: F)\n-        where F: FnOnce(&mut DumpCsvVisitor<'l, 'tcx>)\n+        where F: FnOnce(&mut DumpVisitor<'l, 'tcx, D>)\n     {\n         let parent_scope = self.cur_scope;\n         self.cur_scope = scope_id;\n@@ -118,22 +114,29 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n     pub fn dump_crate_info(&mut self, name: &str, krate: &ast::Crate) {\n         let source_file = self.tcx.sess.local_crate_source_file.as_ref();\n-        let crate_root = match source_file {\n-            Some(source_file) => match source_file.file_name() {\n+        let crate_root = source_file.map(|source_file| {\n+            match source_file.file_name() {\n                 Some(_) => source_file.parent().unwrap().display().to_string(),\n                 None => source_file.display().to_string(),\n-            },\n-            None => \"<no source>\".to_owned(),\n-        };\n+            }\n+        });\n+\n+        // Info about all the external crates referenced from this crate.\n+        let external_crates = self.save_ctxt.get_external_crates().into_iter().map(|c| {\n+            ExternalCrateData {\n+                name: c.name,\n+                num: c.number\n+            }\n+        }).collect();\n \n         // The current crate.\n-        self.fmt.crate_str(krate.span, name, &crate_root);\n+        let data = CratePreludeData {\n+            crate_name: name.into(),\n+            crate_root: crate_root,\n+            external_crates: external_crates\n+        };\n \n-        // Dump info about all the external crates referenced from this crate.\n-        for c in &self.save_ctxt.get_external_crates() {\n-            self.fmt.external_crate_str(krate.span, &c.name, c.number);\n-        }\n-        self.fmt.recorder.record(\"end_external_crates\\n\");\n+        self.dumper.crate_prelude(krate.span, data);\n     }\n \n     // Return all non-empty prefixes of a path.\n@@ -198,7 +201,12 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             } else {\n                 qualname.clone()\n             };\n-            self.fmt.sub_mod_ref_str(path.span, *span, &qualname, self.cur_scope);\n+            self.dumper.mod_ref(path.span, ModRefData {\n+                span: *span,\n+                qualname: qualname,\n+                scope: self.cur_scope,\n+                ref_id: None\n+            }.normalize(&self.tcx));\n         }\n     }\n \n@@ -218,7 +226,12 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             } else {\n                 qualname.clone()\n             };\n-            self.fmt.sub_mod_ref_str(path.span, *span, &qualname, self.cur_scope);\n+            self.dumper.mod_ref(path.span, ModRefData {\n+                span: *span,\n+                qualname: qualname,\n+                scope: self.cur_scope,\n+                ref_id: None\n+            }.normalize(&self.tcx));\n         }\n     }\n \n@@ -234,15 +247,25 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         // write the trait part of the sub-path\n         let (ref span, ref qualname) = sub_paths[len-2];\n-        self.fmt.sub_type_ref_str(path.span, *span, &qualname);\n+        self.dumper.type_ref(path.span, TypeRefData {\n+            ref_id: None,\n+            span: *span,\n+            qualname: qualname.to_owned(),\n+            scope: 0\n+        });\n \n         // write the other sub-paths\n         if len <= 2 {\n             return;\n         }\n         let sub_paths = &sub_paths[..len-2];\n         for &(ref span, ref qualname) in sub_paths {\n-            self.fmt.sub_mod_ref_str(path.span, *span, &qualname, self.cur_scope);\n+            self.dumper.mod_ref(path.span, ModRefData {\n+                span: *span,\n+                qualname: qualname.to_owned(),\n+                scope: self.cur_scope,\n+                ref_id: None\n+            }.normalize(&self.tcx));\n         }\n     }\n \n@@ -260,7 +283,16 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n+    fn process_def_kind(&mut self,\n+                        ref_id: NodeId,\n+                        span: Span,\n+                        sub_span: Option<Span>,\n+                        def_id: DefId,\n+                        scope: NodeId) {\n+        if self.span.filter_generated(sub_span, span) {\n+            return;\n+        }\n+\n         let def_map = self.tcx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n             self.sess.span_bug(span,\n@@ -270,29 +302,54 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let def = def_map.get(&ref_id).unwrap().full_def();\n         match def {\n             Def::Mod(_) |\n-            Def::ForeignMod(_) => Some(recorder::ModRef),\n-            Def::Struct(..) => Some(recorder::TypeRef),\n+            Def::ForeignMod(_) => {\n+                self.dumper.mod_ref(span, ModRefData {\n+                    span: sub_span.expect(\"No span found for mod ref\"),\n+                    ref_id: Some(def_id),\n+                    scope: scope,\n+                    qualname: String::new()\n+                }.normalize(&self.tcx));\n+            }\n+            Def::Struct(..) |\n             Def::Enum(..) |\n             Def::TyAlias(..) |\n             Def::AssociatedTy(..) |\n-            Def::Trait(_) => Some(recorder::TypeRef),\n+            Def::Trait(_) => {\n+                self.dumper.type_ref(span, TypeRefData {\n+                    span: sub_span.expect(\"No span found for type ref\"),\n+                    ref_id: Some(def_id),\n+                    scope: scope,\n+                    qualname: String::new()\n+                }.normalize(&self.tcx));\n+            }\n             Def::Static(_, _) |\n             Def::Const(_) |\n             Def::AssociatedConst(..) |\n             Def::Local(..) |\n             Def::Variant(..) |\n-            Def::Upvar(..) => Some(recorder::VarRef),\n-\n-            Def::Fn(..) => Some(recorder::FnRef),\n-\n+            Def::Upvar(..) => {\n+                self.dumper.variable_ref(span, VariableRefData {\n+                    span: sub_span.expect(\"No span found for var ref\"),\n+                    ref_id: def_id,\n+                    scope: scope,\n+                    name: String::new()\n+                }.normalize(&self.tcx));\n+            }\n+            Def::Fn(..) => {\n+                self.dumper.function_ref(span, FunctionRefData {\n+                    span: sub_span.expect(\"No span found for fn ref\"),\n+                    ref_id: def_id,\n+                    scope: scope\n+                }.normalize(&self.tcx));\n+            }\n             Def::SelfTy(..) |\n             Def::Label(_) |\n             Def::TyParam(..) |\n             Def::Method(..) |\n             Def::PrimTy(_) |\n             Def::Err => {\n                 self.sess.span_bug(span,\n-                                   &format!(\"lookup_def_kind for unexpected item: {:?}\", def));\n+                                   &format!(\"process_def_kind for unexpected item: {:?}\", def));\n             }\n         }\n     }\n@@ -307,12 +364,18 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 let typ = self.tcx.node_types().get(&id).unwrap().to_string();\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n-                self.fmt.formal_str(p.span,\n-                                    span_utils.span_for_last_ident(p.span),\n-                                    id,\n-                                    qualname,\n-                                    &path_to_string(p),\n-                                    &typ);\n+                let sub_span = span_utils.span_for_last_ident(p.span);\n+                if !self.span.filter_generated(sub_span, p.span) {\n+                    self.dumper.variable(p.span, VariableData {\n+                        id: id,\n+                        span: sub_span.expect(\"No span found for variable\"),\n+                        name: path_to_string(p),\n+                        qualname: format!(\"{}::{}\", qualname, path_to_string(p)),\n+                        type_value: typ,\n+                        value: String::new(),\n+                        scope: 0\n+                    }.normalize(&self.tcx));\n+                }\n             }\n         }\n     }\n@@ -328,19 +391,19 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         if let Some(method_data) = self.save_ctxt.get_method_data(id, name, span) {\n \n             if body.is_some() {\n-                self.fmt.method_str(span,\n-                                    Some(method_data.span),\n-                                    method_data.id,\n-                                    &method_data.qualname,\n-                                    method_data.declaration,\n-                                    method_data.scope);\n+                if !self.span.filter_generated(Some(method_data.span), span) {\n+                    self.dumper.function(span, method_data.clone().normalize(&self.tcx));\n+                }\n                 self.process_formals(&sig.decl.inputs, &method_data.qualname);\n             } else {\n-                self.fmt.method_decl_str(span,\n-                                         Some(method_data.span),\n-                                         method_data.id,\n-                                         &method_data.qualname,\n-                                         method_data.scope);\n+                if !self.span.filter_generated(Some(method_data.span), span) {\n+                    self.dumper.method(span, MethodData {\n+                        id: method_data.id,\n+                        span: method_data.span,\n+                        scope: method_data.scope,\n+                        qualname: method_data.qualname.clone(),\n+                    }.normalize(&self.tcx));\n+                }\n             }\n             self.process_generic_params(&sig.generics, span, &method_data.qualname, id);\n         }\n@@ -363,25 +426,22 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n         let trait_ref_data = self.save_ctxt.get_trait_ref_data(trait_ref, self.cur_scope);\n         if let Some(trait_ref_data) = trait_ref_data {\n-            self.fmt.ref_str(recorder::TypeRef,\n-                             trait_ref.path.span,\n-                             Some(trait_ref_data.span),\n-                             trait_ref_data.ref_id,\n-                             trait_ref_data.scope);\n+            if !self.span.filter_generated(Some(trait_ref_data.span), trait_ref.path.span) {\n+                self.dumper.type_ref(trait_ref.path.span, trait_ref_data.normalize(&self.tcx));\n+            }\n+\n             visit::walk_path(self, &trait_ref.path);\n         }\n     }\n \n     fn process_struct_field_def(&mut self, field: &ast::StructField, parent_id: NodeId) {\n         let field_data = self.save_ctxt.get_field_data(field, parent_id);\n-        if let Some(field_data) = field_data {\n-            self.fmt.field_str(field.span,\n-                               Some(field_data.span),\n-                               field_data.id,\n-                               &field_data.name,\n-                               &field_data.qualname,\n-                               &field_data.type_value,\n-                               field_data.scope);\n+        if let Some(mut field_data) = field_data {\n+            if !self.span.filter_generated(Some(field_data.span), field.span) {\n+                field_data.scope = normalize_node_id(&self.tcx, field_data.scope) as u32;\n+                field_data.value = String::new();\n+                self.dumper.variable(field.span, field_data.normalize(&self.tcx));\n+            }\n         }\n     }\n \n@@ -403,7 +463,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                prefix,\n                                escape(self.span.snippet(param_ss)),\n                                id);\n-            self.fmt.typedef_str(full_span, Some(param_ss), param.id, &name, \"\");\n+            if !self.span.filter_generated(Some(param_ss), full_span) {\n+                self.dumper.typedef(full_span, TypedefData {\n+                    span: param_ss,\n+                    id: param.id,\n+                    qualname: name,\n+                    value: String::new()\n+                }.normalize(&self.tcx));\n+            }\n         }\n         self.visit_generics(generics);\n     }\n@@ -415,11 +482,9 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                   body: &ast::Block) {\n         if let Some(fn_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(fn_data, FunctionData, self, item.span);\n-            self.fmt.fn_str(item.span,\n-                            Some(fn_data.span),\n-                            fn_data.id,\n-                            &fn_data.qualname,\n-                            fn_data.scope);\n+            if !self.span.filter_generated(Some(fn_data.span), item.span) {\n+                self.dumper.function(item.span, fn_data.clone().normalize(&self.tcx));\n+            }\n \n             self.process_formals(&decl.inputs, &fn_data.qualname);\n             self.process_generic_params(ty_params, item.span, &fn_data.qualname, item.id);\n@@ -439,14 +504,11 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_static_or_const_item(&mut self, item: &ast::Item, typ: &ast::Ty, expr: &ast::Expr) {\n         if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(var_data, VariableData, self, item.span);\n-            self.fmt.static_str(item.span,\n-                                Some(var_data.span),\n-                                var_data.id,\n-                                &var_data.name,\n-                                &var_data.qualname,\n-                                &var_data.value,\n-                                &var_data.type_value,\n-                                var_data.scope);\n+            if !self.span.filter_generated(Some(var_data.span), item.span) {\n+                let mut var_data = var_data;\n+                var_data.scope = normalize_node_id(&self.tcx, var_data.scope) as u32;\n+                self.dumper.variable(item.span, var_data.normalize(&self.tcx));\n+            }\n         }\n         self.visit_ty(&typ);\n         self.visit_expr(expr);\n@@ -462,14 +524,17 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n \n-        self.fmt.static_str(span,\n-                            sub_span,\n-                            id,\n-                            &name.as_str(),\n-                            &qualname,\n-                            &self.span.snippet(expr.span),\n-                            &ty_to_string(&typ),\n-                            self.cur_scope);\n+        if !self.span.filter_generated(sub_span, span) {\n+            self.dumper.variable(span, VariableData {\n+                span: sub_span.expect(\"No span found for variable\"),\n+                id: id,\n+                name: name.to_string(),\n+                qualname: qualname,\n+                value: self.span.snippet(expr.span),\n+                type_value: ty_to_string(&typ),\n+                scope: normalize_node_id(&self.tcx, self.cur_scope) as u32\n+            }.normalize(&self.tcx));\n+        }\n \n         // walk type and init value\n         self.visit_ty(typ);\n@@ -484,13 +549,17 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Struct);\n-        self.fmt.struct_str(item.span,\n-                            sub_span,\n-                            item.id,\n-                            def.id(),\n-                            &qualname,\n-                            self.cur_scope,\n-                            &val);\n+        if !self.span.filter_generated(sub_span, item.span) {\n+            self.dumper.struct_data(item.span, StructData {\n+                span: sub_span.expect(\"No span found for struct\"),\n+                id: item.id,\n+                ctor_id: def.id(),\n+                qualname: qualname.clone(),\n+                scope: self.cur_scope,\n+                value: val\n+            }.normalize(&self.tcx));\n+        }\n+\n \n         // fields\n         for field in def.fields() {\n@@ -511,12 +580,10 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             Some(data) => data,\n         };\n         down_cast_data!(enum_data, EnumData, self, item.span);\n-        self.fmt.enum_str(item.span,\n-                          Some(enum_data.span),\n-                          enum_data.id,\n-                          &enum_data.qualname,\n-                          enum_data.scope,\n-                          &enum_data.value);\n+        let normalized = enum_data.clone().normalize(&self.tcx);\n+        if !self.span.filter_generated(Some(normalized.span), item.span) {\n+            self.dumper.enum_data(item.span, normalized);\n+        }\n \n         for variant in &enum_definition.variants {\n             let name = &variant.node.name.name.as_str();\n@@ -527,23 +594,31 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n             match variant.node.data {\n                 ast::VariantData::Struct(..) => {\n-                    self.fmt.struct_variant_str(variant.span,\n-                                                self.span.span_for_first_ident(variant.span),\n-                                                variant.node.data.id(),\n-                                                &qualname,\n-                                                &enum_data.qualname,\n-                                                &val,\n-                                                enum_data.scope);\n+                    let sub_span = self.span.span_for_first_ident(variant.span);\n+                    if !self.span.filter_generated(sub_span, variant.span) {\n+                        self.dumper.struct_variant(variant.span, StructVariantData {\n+                            span: sub_span.expect(\"No span found for struct variant\"),\n+                            id: variant.node.data.id(),\n+                            qualname: qualname,\n+                            type_value: enum_data.qualname.clone(),\n+                            value: val,\n+                            scope: enum_data.scope\n+                        }.normalize(&self.tcx));\n+                    }\n                 }\n                 _ => {\n-                    self.fmt.tuple_variant_str(variant.span,\n-                                               self.span.span_for_first_ident(variant.span),\n-                                               variant.node.data.id(),\n-                                               name,\n-                                               &qualname,\n-                                               &enum_data.qualname,\n-                                               &val,\n-                                               enum_data.scope);\n+                    let sub_span = self.span.span_for_first_ident(variant.span);\n+                    if !self.span.filter_generated(sub_span, variant.span) {\n+                        self.dumper.tuple_variant(variant.span, TupleVariantData {\n+                            span: sub_span.expect(\"No span found for tuple variant\"),\n+                            id: variant.node.data.id(),\n+                            name: name.to_string(),\n+                            qualname: qualname,\n+                            type_value: enum_data.qualname.clone(),\n+                            value: val,\n+                            scope: enum_data.scope\n+                        }.normalize(&self.tcx));\n+                    }\n                 }\n             }\n \n@@ -567,27 +642,27 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             down_cast_data!(impl_data, ImplData, self, item.span);\n             if let Some(ref self_ref) = impl_data.self_ref {\n                 has_self_ref = true;\n-                self.fmt.ref_str(recorder::TypeRef,\n-                                 item.span,\n-                                 Some(self_ref.span),\n-                                 self_ref.ref_id,\n-                                 self_ref.scope);\n+                if !self.span.filter_generated(Some(self_ref.span), item.span) {\n+                    self.dumper.type_ref(item.span, self_ref.clone().normalize(&self.tcx));\n+                }\n             }\n             if let Some(ref trait_ref_data) = impl_data.trait_ref {\n-                self.fmt.ref_str(recorder::TypeRef,\n-                                 item.span,\n-                                 Some(trait_ref_data.span),\n-                                 trait_ref_data.ref_id,\n-                                 trait_ref_data.scope);\n+                if !self.span.filter_generated(Some(trait_ref_data.span), item.span) {\n+                    self.dumper.type_ref(item.span, trait_ref_data.clone().normalize(&self.tcx));\n+                }\n+\n                 visit::walk_path(self, &trait_ref.as_ref().unwrap().path);\n             }\n \n-            self.fmt.impl_str(item.span,\n-                              Some(impl_data.span),\n-                              impl_data.id,\n-                              impl_data.self_ref.map(|data| data.ref_id),\n-                              impl_data.trait_ref.map(|data| data.ref_id),\n-                              impl_data.scope);\n+            if !self.span.filter_generated(Some(impl_data.span), item.span) {\n+                self.dumper.impl_data(item.span, ImplData {\n+                    id: impl_data.id,\n+                    span: impl_data.span,\n+                    scope: impl_data.scope,\n+                    trait_ref: impl_data.trait_ref.map(|d| d.ref_id.unwrap()),\n+                    self_ref: impl_data.self_ref.map(|d| d.ref_id.unwrap())\n+                }.normalize(&self.tcx));\n+            }\n         }\n         if !has_self_ref {\n             self.visit_ty(&typ);\n@@ -606,12 +681,15 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n         let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n         let val = self.span.snippet(item.span);\n         let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Trait);\n-        self.fmt.trait_str(item.span,\n-                           sub_span,\n-                           item.id,\n-                           &qualname,\n-                           self.cur_scope,\n-                           &val);\n+        if !self.span.filter_generated(sub_span, item.span) {\n+            self.dumper.trait_data(item.span, TraitData {\n+                span: sub_span.expect(\"No span found for trait\"),\n+                id: item.id,\n+                qualname: qualname.clone(),\n+                scope: self.cur_scope,\n+                value: val\n+            }.normalize(&self.tcx));\n+        }\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n@@ -625,17 +703,25 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             };\n \n             let trait_ref = &trait_ref.trait_ref;\n-            match self.lookup_type_ref(trait_ref.ref_id) {\n-                Some(id) => {\n-                    let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n-                    self.fmt.ref_str(recorder::TypeRef,\n-                                     trait_ref.path.span,\n-                                     sub_span,\n-                                     id,\n-                                     self.cur_scope);\n-                    self.fmt.inherit_str(trait_ref.path.span, sub_span, id, item.id);\n+            if let Some(id) = self.lookup_type_ref(trait_ref.ref_id) {\n+                let sub_span = self.span.sub_span_for_type_name(trait_ref.path.span);\n+                if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n+                    self.dumper.type_ref(trait_ref.path.span, TypeRefData {\n+                        span: sub_span.expect(\"No span found for trait ref\"),\n+                        ref_id: Some(id),\n+                        scope: self.cur_scope,\n+                        qualname: String::new()\n+                    }.normalize(&self.tcx));\n+                }\n+\n+                if !self.span.filter_generated(sub_span, trait_ref.path.span) {\n+                    let sub_span = sub_span.expect(\"No span for inheritance\");\n+                    self.dumper.inheritance(InheritanceData {\n+                        span: sub_span,\n+                        base_id: id,\n+                        deriv_id: item.id\n+                    }.normalize(&self.tcx));\n                 }\n-                None => (),\n             }\n         }\n \n@@ -650,12 +736,9 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     fn process_mod(&mut self, item: &ast::Item) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, ModData, self, item.span);\n-            self.fmt.mod_str(item.span,\n-                             Some(mod_data.span),\n-                             mod_data.id,\n-                             &mod_data.qualname,\n-                             mod_data.scope,\n-                             &mod_data.filename);\n+            if !self.span.filter_generated(Some(mod_data.span), item.span) {\n+                self.dumper.mod_data(mod_data.normalize(&self.tcx));\n+            }\n         }\n     }\n \n@@ -674,31 +757,55 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                                                 self.span.snippet(path.span)))\n             }\n         };\n+\n         match path_data {\n-            Data::VariableRefData(ref vrd) => {\n-                self.fmt.ref_str(ref_kind.unwrap_or(recorder::VarRef),\n-                                 path.span,\n-                                 Some(vrd.span),\n-                                 vrd.ref_id,\n-                                 vrd.scope);\n+            Data::VariableRefData(vrd) => {\n+                // FIXME: this whole block duplicates the code in process_def_kind\n+                if !self.span.filter_generated(Some(vrd.span), path.span) {\n+                    match ref_kind {\n+                        Some(recorder::TypeRef) => {\n+                            self.dumper.type_ref(path.span, TypeRefData {\n+                                span: vrd.span,\n+                                ref_id: Some(vrd.ref_id),\n+                                scope: vrd.scope,\n+                                qualname: String::new()\n+                            }.normalize(&self.tcx));\n+                        }\n+                        Some(recorder::FnRef) => {\n+                            self.dumper.function_ref(path.span, FunctionRefData {\n+                                span: vrd.span,\n+                                ref_id: vrd.ref_id,\n+                                scope: vrd.scope\n+                            }.normalize(&self.tcx));\n+                        }\n+                        Some(recorder::ModRef) => {\n+                            self.dumper.mod_ref(path.span, ModRefData {\n+                                span: vrd.span,\n+                                ref_id: Some(vrd.ref_id),\n+                                scope: vrd.scope,\n+                                qualname: String::new()\n+                            }.normalize(&self.tcx));\n+                        }\n+                        Some(recorder::VarRef) | None\n+                            => self.dumper.variable_ref(path.span, vrd.normalize(&self.tcx))\n+                    }\n+                }\n \n             }\n-            Data::TypeRefData(ref trd) => {\n-                self.fmt.ref_str(recorder::TypeRef,\n-                                 path.span,\n-                                 Some(trd.span),\n-                                 trd.ref_id,\n-                                 trd.scope);\n+            Data::TypeRefData(trd) => {\n+                if !self.span.filter_generated(Some(trd.span), path.span) {\n+                    self.dumper.type_ref(path.span, trd.normalize(&self.tcx));\n+                }\n             }\n-            Data::MethodCallData(ref mcd) => {\n-                self.fmt.meth_call_str(path.span,\n-                                       Some(mcd.span),\n-                                       mcd.ref_id,\n-                                       mcd.decl_id,\n-                                       mcd.scope);\n+            Data::MethodCallData(mcd) => {\n+                if !self.span.filter_generated(Some(mcd.span), path.span) {\n+                    self.dumper.method_call(path.span, mcd.normalize(&self.tcx));\n+                }\n             }\n             Data::FunctionCallData(fcd) => {\n-                self.fmt.fn_call_str(path.span, Some(fcd.span), fcd.ref_id, fcd.scope);\n+                if !self.span.filter_generated(Some(fcd.span), path.span) {\n+                    self.dumper.function_call(path.span, fcd.normalize(&self.tcx));\n+                }\n             }\n             _ => {\n                 self.sess.span_bug(path.span,\n@@ -739,22 +846,19 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n \n         if let Some(struct_lit_data) = self.save_ctxt.get_expr_data(ex) {\n             down_cast_data!(struct_lit_data, TypeRefData, self, ex.span);\n-            self.fmt.ref_str(recorder::TypeRef,\n-                             ex.span,\n-                             Some(struct_lit_data.span),\n-                             struct_lit_data.ref_id,\n-                             struct_lit_data.scope);\n+            if !self.span.filter_generated(Some(struct_lit_data.span), ex.span) {\n+                self.dumper.type_ref(ex.span, struct_lit_data.normalize(&self.tcx));\n+            }\n+\n             let scope = self.save_ctxt.enclosing_scope(ex.id);\n \n             for field in fields {\n                 if let Some(field_data) = self.save_ctxt\n                                               .get_field_ref_data(field, variant, scope) {\n \n-                    self.fmt.ref_str(recorder::VarRef,\n-                                     field.ident.span,\n-                                     Some(field_data.span),\n-                                     field_data.ref_id,\n-                                     field_data.scope);\n+                    if !self.span.filter_generated(Some(field_data.span), field.ident.span) {\n+                        self.dumper.variable_ref(field.ident.span, field_data.normalize(&self.tcx));\n+                    }\n                 }\n \n                 self.visit_expr(&field.expr)\n@@ -765,13 +869,11 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     }\n \n     fn process_method_call(&mut self, ex: &ast::Expr, args: &Vec<P<ast::Expr>>) {\n-        if let Some(call_data) = self.save_ctxt.get_expr_data(ex) {\n-            down_cast_data!(call_data, MethodCallData, self, ex.span);\n-            self.fmt.meth_call_str(ex.span,\n-                                   Some(call_data.span),\n-                                   call_data.ref_id,\n-                                   call_data.decl_id,\n-                                   call_data.scope);\n+        if let Some(mcd) = self.save_ctxt.get_expr_data(ex) {\n+            down_cast_data!(mcd, MethodCallData, self, ex.span);\n+            if !self.span.filter_generated(Some(mcd.span), ex.span) {\n+                self.dumper.method_call(ex.span, mcd.normalize(&self.tcx));\n+            }\n         }\n \n         // walk receiver and args\n@@ -789,7 +891,14 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n                 for &Spanned { node: ref field, span } in fields {\n                     let sub_span = self.span.span_for_first_ident(span);\n                     if let Some(f) = variant.find_field_named(field.ident.name) {\n-                        self.fmt.ref_str(recorder::VarRef, span, sub_span, f.did, self.cur_scope);\n+                        if !self.span.filter_generated(sub_span, span) {\n+                            self.dumper.variable_ref(span, VariableRefData {\n+                                span: sub_span.expect(\"No span fund for var ref\"),\n+                                ref_id: f.did,\n+                                scope: self.cur_scope,\n+                                name: String::new()\n+                            }.normalize(&self.tcx));\n+                        }\n                     }\n                     self.visit_pat(&field.pat);\n                 }\n@@ -818,12 +927,17 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);\n             // Rust uses the id of the pattern for var lookups, so we'll use it too.\n-            self.fmt.variable_str(p.span,\n-                                  sub_span,\n-                                  id,\n-                                  &path_to_string(p),\n-                                  &value,\n-                                  &typ);\n+            if !self.span.filter_generated(sub_span, p.span) {\n+                self.dumper.variable(p.span, VariableData {\n+                    span: sub_span.expect(\"No span found for variable\"),\n+                    id: id,\n+                    name: path_to_string(p),\n+                    qualname: format!(\"{}${}\", path_to_string(p), id),\n+                    value: value,\n+                    type_value: typ,\n+                    scope: 0\n+                }.normalize(&self.tcx));\n+            }\n         }\n     }\n \n@@ -848,21 +962,30 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n             && !data.imported {\n             self.mac_defs.insert(data.callee_span);\n             if let Some(sub_span) = self.span.span_for_macro_def_name(data.callee_span) {\n-                self.fmt.macro_str(data.callee_span, sub_span,\n-                                   data.name.clone(), qualname.clone());\n+                self.dumper.macro_data(data.callee_span, MacroData {\n+                    span: sub_span,\n+                    name: data.name.clone(),\n+                    qualname: qualname.clone()\n+                });\n             }\n         }\n         if !self.mac_uses.contains(&data.span) {\n             self.mac_uses.insert(data.span);\n             if let Some(sub_span) = self.span.span_for_macro_use_name(data.span) {\n-                self.fmt.macro_use_str(data.span, sub_span, data.name,\n-                                       qualname, data.scope);\n+                self.dumper.macro_use(data.span, MacroUseData {\n+                    span: sub_span,\n+                    name: data.name,\n+                    qualname: qualname,\n+                    scope: data.scope,\n+                    callee_span: data.callee_span,\n+                    imported: data.imported\n+                }.normalize(&self.tcx));\n             }\n         }\n     }\n }\n \n-impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n+impl<'l, 'tcx, 'v, D: Dump + 'l> Visitor<'v> for DumpVisitor<'l, 'tcx, D> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         use syntax::ast::ItemKind::*;\n         self.process_macro_use(item.span, item.id);\n@@ -873,14 +996,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                         let sub_span = self.span.span_for_last_ident(path.span);\n                         let mod_id = match self.lookup_type_ref(item.id) {\n                             Some(def_id) => {\n-                                match self.lookup_def_kind(item.id, path.span) {\n-                                    Some(kind) => self.fmt.ref_str(kind,\n-                                                                   path.span,\n-                                                                   sub_span,\n-                                                                   def_id,\n-                                                                   self.cur_scope),\n-                                    None => {}\n-                                }\n+                                let scope = self.cur_scope;\n+                                self.process_def_kind(item.id, path.span, sub_span, def_id, scope);\n+\n                                 Some(def_id)\n                             }\n                             None => None,\n@@ -894,53 +1012,51 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                             None => sub_span,\n                         };\n \n-                        self.fmt.use_alias_str(path.span,\n-                                               sub_span,\n-                                               item.id,\n-                                               mod_id,\n-                                               &ident.name.as_str(),\n-                                               self.cur_scope);\n+                        if !self.span.filter_generated(sub_span, path.span) {\n+                            self.dumper.use_data(path.span, UseData {\n+                                span: sub_span.expect(\"No span found for use\"),\n+                                id: item.id,\n+                                mod_id: mod_id,\n+                                name: ident.name.to_string(),\n+                                scope: self.cur_scope\n+                            }.normalize(&self.tcx));\n+                        }\n                         self.write_sub_paths_truncated(path, true);\n                     }\n                     ast::ViewPathGlob(ref path) => {\n                         // Make a comma-separated list of names of imported modules.\n-                        let mut name_string = String::new();\n+                        let mut names = vec![];\n                         let glob_map = &self.analysis.glob_map;\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&item.id) {\n                             for n in glob_map.get(&item.id).unwrap() {\n-                                if !name_string.is_empty() {\n-                                    name_string.push_str(\", \");\n-                                }\n-                                name_string.push_str(&n.as_str());\n+                                names.push(n.to_string());\n                             }\n                         }\n \n                         let sub_span = self.span\n                                            .sub_span_of_token(path.span, token::BinOp(token::Star));\n-                        self.fmt.use_glob_str(path.span,\n-                                              sub_span,\n-                                              item.id,\n-                                              &name_string,\n-                                              self.cur_scope);\n+                        if !self.span.filter_generated(sub_span, path.span) {\n+                            self.dumper.use_glob(path.span, UseGlobData {\n+                                span: sub_span.expect(\"No span found for use glob\"),\n+                                id: item.id,\n+                                names: names,\n+                                scope: self.cur_scope\n+                            }.normalize(&self.tcx));\n+                        }\n                         self.write_sub_paths(path, true);\n                     }\n                     ast::ViewPathList(ref path, ref list) => {\n                         for plid in list {\n                             match plid.node {\n                                 ast::PathListItemKind::Ident { id, .. } => {\n-                                    match self.lookup_type_ref(id) {\n-                                        Some(def_id) => match self.lookup_def_kind(id, plid.span) {\n-                                            Some(kind) => {\n-                                                self.fmt.ref_str(kind,\n-                                                                 plid.span,\n-                                                                 Some(plid.span),\n-                                                                 def_id,\n-                                                                 self.cur_scope);\n-                                            }\n-                                            None => (),\n-                                        },\n-                                        None => (),\n+                                    let scope = self.cur_scope;\n+                                    if let Some(def_id) = self.lookup_type_ref(id) {\n+                                        self.process_def_kind(id,\n+                                                              plid.span,\n+                                                              Some(plid.span),\n+                                                              def_id,\n+                                                              scope);\n                                     }\n                                 }\n                                 ast::PathListItemKind::Mod { .. } => (),\n@@ -961,13 +1077,17 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                     Some(cnum) => cnum,\n                     None => 0,\n                 };\n-                self.fmt.extern_crate_str(item.span,\n-                                          alias_span,\n-                                          item.id,\n-                                          cnum,\n-                                          &item.ident.name.as_str(),\n-                                          &location,\n-                                          self.cur_scope);\n+\n+                if !self.span.filter_generated(alias_span, item.span) {\n+                    self.dumper.extern_crate(item.span, ExternCrateData {\n+                        id: item.id,\n+                        name: item.ident.name.to_string(),\n+                        crate_num: cnum,\n+                        location: location,\n+                        span: alias_span.expect(\"No span found for extern crate\"),\n+                        scope: self.cur_scope,\n+                    }.normalize(&self.tcx));\n+                }\n             }\n             Fn(ref decl, _, _, _, ref ty_params, ref body) =>\n                 self.process_fn(item, &decl, ty_params, &body),\n@@ -994,7 +1114,14 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 let qualname = format!(\"::{}\", self.tcx.map.path_to_string(item.id));\n                 let value = ty_to_string(&ty);\n                 let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Type);\n-                self.fmt.typedef_str(item.span, sub_span, item.id, &qualname, &value);\n+                if !self.span.filter_generated(sub_span, item.span) {\n+                    self.dumper.typedef(item.span, TypedefData {\n+                        span: sub_span.expect(\"No span found for typedef\"),\n+                        id: item.id,\n+                        qualname: qualname.clone(),\n+                        value: value\n+                    }.normalize(&self.tcx));\n+                }\n \n                 self.visit_ty(&ty);\n                 self.process_generic_params(ty_params, item.span, &qualname, item.id);\n@@ -1065,12 +1192,16 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n         self.process_macro_use(t.span, t.id);\n         match t.node {\n             ast::TyKind::Path(_, ref path) => {\n-                match self.lookup_type_ref(t.id) {\n-                    Some(id) => {\n-                        let sub_span = self.span.sub_span_for_type_name(t.span);\n-                        self.fmt.ref_str(recorder::TypeRef, t.span, sub_span, id, self.cur_scope);\n+                if let Some(id) = self.lookup_type_ref(t.id) {\n+                    let sub_span = self.span.sub_span_for_type_name(t.span);\n+                    if !self.span.filter_generated(sub_span, t.span) {\n+                        self.dumper.type_ref(t.span, TypeRefData {\n+                            span: sub_span.expect(\"No span found for type ref\"),\n+                            ref_id: Some(id),\n+                            scope: self.cur_scope,\n+                            qualname: String::new()\n+                        }.normalize(&self.tcx));\n                     }\n-                    None => (),\n                 }\n \n                 self.write_sub_paths_truncated(path, false);\n@@ -1105,11 +1236,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                 if let Some(field_data) = self.save_ctxt.get_expr_data(ex) {\n                     down_cast_data!(field_data, VariableRefData, self, ex.span);\n-                    self.fmt.ref_str(recorder::VarRef,\n-                                     ex.span,\n-                                     Some(field_data.span),\n-                                     field_data.ref_id,\n-                                     field_data.scope);\n+                    if !self.span.filter_generated(Some(field_data.span), ex.span) {\n+                        self.dumper.variable_ref(ex.span, field_data.normalize(&self.tcx));\n+                    }\n                 }\n             }\n             ast::ExprKind::TupField(ref sub_ex, idx) => {\n@@ -1120,11 +1249,14 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                 match *ty {\n                     ty::TyStruct(def, _) => {\n                         let sub_span = self.span.sub_span_after_token(ex.span, token::Dot);\n-                        self.fmt.ref_str(recorder::VarRef,\n-                                         ex.span,\n-                                         sub_span,\n-                                         def.struct_variant().fields[idx.node].did,\n-                                         self.cur_scope);\n+                        if !self.span.filter_generated(sub_span, ex.span) {\n+                            self.dumper.variable_ref(ex.span, VariableRefData {\n+                                span: sub_span.expect(\"No span found for var ref\"),\n+                                ref_id: def.struct_variant().fields[idx.node].did,\n+                                scope: self.cur_scope,\n+                                name: String::new()\n+                            }.normalize(&self.tcx));\n+                        }\n                     }\n                     ty::TyTuple(_) => {}\n                     _ => self.sess.span_bug(ex.span,\n@@ -1208,7 +1340,17 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n \n                     assert!(p.segments.len() == 1,\n                             \"qualified path for local variable def in arm\");\n-                    self.fmt.variable_str(p.span, Some(p.span), id, &path_to_string(p), &value, \"\")\n+                    if !self.span.filter_generated(Some(p.span), p.span) {\n+                        self.dumper.variable(p.span, VariableData {\n+                            span: p.span,\n+                            id: id,\n+                            name: path_to_string(p),\n+                            qualname: format!(\"{}${}\", path_to_string(p), id),\n+                            value: value,\n+                            type_value: String::new(),\n+                            scope: 0\n+                        }.normalize(&self.tcx));\n+                    }\n                 }\n                 Def::Variant(..) | Def::Enum(..) |\n                 Def::TyAlias(..) | Def::Struct(..) => {", "previous_filename": "src/librustc_trans/save/dump_csv.rs"}, {"sha": "78e91e00baa711500a543974f45b962ad806b892", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 44, "deletions": 166, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67395d816feec0e3f6ebd8a0f0075cf72bdb818e/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=67395d816feec0e3f6ebd8a0f0075cf72bdb818e", "patch": "@@ -28,172 +28,43 @@ use syntax::parse::token::{self, keywords};\n use syntax::visit::{self, Visitor};\n use syntax::print::pprust::ty_to_string;\n \n-use self::span_utils::SpanUtils;\n-\n+mod csv_dumper;\n+#[macro_use]\n+mod data;\n+mod dump;\n+mod dump_visitor;\n #[macro_use]\n pub mod span_utils;\n-pub mod recorder;\n \n-mod dump_csv;\n+pub use self::csv_dumper::CsvDumper;\n+pub use self::data::*;\n+pub use self::dump::Dump;\n+pub use self::dump_visitor::DumpVisitor;\n+use self::span_utils::SpanUtils;\n+\n+// FIXME this is legacy code and should be removed\n+pub mod recorder {\n+    pub use self::Row::*;\n+\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    pub enum Row {\n+        TypeRef,\n+        ModRef,\n+        VarRef,\n+        FnRef,\n+    }\n+}\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: &'l TyCtxt<'tcx>,\n     lcx: &'l lowering::LoweringContext<'l>,\n     span_utils: SpanUtils<'l>,\n }\n \n-pub struct CrateData {\n-    pub name: String,\n-    pub number: u32,\n-}\n-\n-/// Data for any entity in the Rust language. The actual data contained varied\n-/// with the kind of entity being queried. See the nested structs for details.\n-#[derive(Debug)]\n-pub enum Data {\n-    /// Data for all kinds of functions and methods.\n-    FunctionData(FunctionData),\n-    /// Data for local and global variables (consts and statics), and fields.\n-    VariableData(VariableData),\n-    /// Data for modules.\n-    ModData(ModData),\n-    /// Data for Enums.\n-    EnumData(EnumData),\n-    /// Data for impls.\n-    ImplData(ImplData),\n-\n-    /// Data for the use of some variable (e.g., the use of a local variable, which\n-    /// will refere to that variables declaration).\n-    VariableRefData(VariableRefData),\n-    /// Data for a reference to a type or trait.\n-    TypeRefData(TypeRefData),\n-    /// Data for a reference to a module.\n-    ModRefData(ModRefData),\n-    /// Data about a function call.\n-    FunctionCallData(FunctionCallData),\n-    /// Data about a method call.\n-    MethodCallData(MethodCallData),\n-    /// Data about a macro use.\n-    MacroUseData(MacroUseData),\n-}\n-\n-/// Data for all kinds of functions and methods.\n-#[derive(Debug)]\n-pub struct FunctionData {\n-    pub id: NodeId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub declaration: Option<DefId>,\n-    pub span: Span,\n-    pub scope: NodeId,\n-}\n-\n-/// Data for local and global variables (consts and statics).\n-#[derive(Debug)]\n-pub struct VariableData {\n-    pub id: NodeId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub value: String,\n-    pub type_value: String,\n-}\n-\n-/// Data for modules.\n-#[derive(Debug)]\n-pub struct ModData {\n-    pub id: NodeId,\n-    pub name: String,\n-    pub qualname: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub filename: String,\n-}\n-\n-/// Data for enum declarations.\n-#[derive(Debug)]\n-pub struct EnumData {\n-    pub id: NodeId,\n-    pub value: String,\n-    pub qualname: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-}\n-\n-#[derive(Debug)]\n-pub struct ImplData {\n-    pub id: NodeId,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    // FIXME: I'm not really sure inline data is the best way to do this. Seems\n-    // OK in this case, but generalising leads to returning chunks of AST, which\n-    // feels wrong.\n-    pub trait_ref: Option<TypeRefData>,\n-    pub self_ref: Option<TypeRefData>,\n-}\n-\n-/// Data for the use of some item (e.g., the use of a local variable, which\n-/// will refer to that variables declaration (by ref_id)).\n-#[derive(Debug)]\n-pub struct VariableRefData {\n-    pub name: String,\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: DefId,\n-}\n-\n-/// Data for a reference to a type or trait.\n-#[derive(Debug)]\n-pub struct TypeRefData {\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: DefId,\n-}\n-\n-/// Data for a reference to a module.\n-#[derive(Debug)]\n-pub struct ModRefData {\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: DefId,\n-}\n-\n-/// Data about a function call.\n-#[derive(Debug)]\n-pub struct FunctionCallData {\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: DefId,\n-}\n-\n-/// Data about a method call.\n-#[derive(Debug)]\n-pub struct MethodCallData {\n-    pub span: Span,\n-    pub scope: NodeId,\n-    pub ref_id: Option<DefId>,\n-    pub decl_id: Option<DefId>,\n-}\n-\n-/// Data about a macro use.\n-#[derive(Debug)]\n-pub struct MacroUseData {\n-    pub span: Span,\n-    pub name: String,\n-    // Because macro expansion happens before ref-ids are determined,\n-    // we use the callee span to reference the associated macro definition.\n-    pub callee_span: Span,\n-    pub scope: NodeId,\n-    pub imported: bool,\n-}\n-\n macro_rules! option_try(\n     ($e:expr) => (match $e { Some(e) => e, None => return None })\n );\n \n-\n-\n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n     pub fn new(tcx: &'l TyCtxt<'tcx>,\n                lcx: &'l lowering::LoweringContext<'l>)\n@@ -325,7 +196,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                             TypeRefData {\n                                 span: sub_span.unwrap(),\n                                 scope: parent,\n-                                ref_id: id,\n+                                ref_id: Some(id),\n+                                qualname: String::new() // FIXME: generate the real qualname\n                             }\n                         });\n                     }\n@@ -340,7 +212,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                           .and_then(|tr| self.get_trait_ref_data(tr, parent));\n \n                 filter!(self.span_utils, sub_span, typ.span, None);\n-                Some(Data::ImplData(ImplData {\n+                Some(Data::ImplData(ImplData2 {\n                     id: item.id,\n                     span: sub_span.unwrap(),\n                     scope: parent,\n@@ -477,7 +349,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Some(TypeRefData {\n                 span: sub_span.unwrap(),\n                 scope: parent,\n-                ref_id: def_id,\n+                ref_id: Some(def_id),\n+                qualname: String::new() // FIXME: generate the real qualname\n             })\n         })\n     }\n@@ -518,7 +391,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                         Some(Data::TypeRefData(TypeRefData {\n                             span: sub_span.unwrap(),\n                             scope: self.enclosing_scope(expr.id),\n-                            ref_id: def.did,\n+                            ref_id: Some(def.did),\n+                            qualname: String::new() // FIXME: generate the real qualname\n                         }))\n                     }\n                     _ => {\n@@ -586,8 +460,9 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Def::TyParam(_, _, def_id, _) => {\n                 Some(Data::TypeRefData(TypeRefData {\n                     span: sub_span.unwrap(),\n-                    ref_id: def_id,\n+                    ref_id: Some(def_id),\n                     scope: self.enclosing_scope(id),\n+                    qualname: String::new() // FIXME: generate the real qualname\n                 }))\n             }\n             Def::Method(decl_id) => {\n@@ -635,9 +510,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             }\n             Def::Mod(def_id) => {\n                 Some(Data::ModRefData(ModRefData {\n-                    ref_id: def_id,\n+                    ref_id: Some(def_id),\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(id),\n+                    qualname: String::new() // FIXME: generate the real qualname\n                 }))\n             }\n             _ => None,\n@@ -708,6 +584,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                         callee_span: mac_span,\n                                         scope: self.enclosing_scope(id),\n                                         imported: true,\n+                                        qualname: String::new()// FIXME: generate the real qualname\n                                     });\n         }\n \n@@ -717,6 +594,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             callee_span: callee_span,\n             scope: self.enclosing_scope(id),\n             imported: false,\n+            qualname: String::new() // FIXME: generate the real qualname\n         })\n     }\n \n@@ -833,16 +711,16 @@ pub fn process_crate<'l, 'tcx>(tcx: &'l TyCtxt<'tcx>,\n     out_name.push_str(&tcx.sess.opts.cg.extra_filename);\n     out_name.push_str(\".csv\");\n     root_path.push(&out_name);\n-    let output_file = match File::create(&root_path) {\n-        Ok(f) => box f,\n-        Err(e) => {\n-            let disp = root_path.display();\n-            tcx.sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n-        }\n-    };\n+    let mut output_file = File::create(&root_path).unwrap_or_else(|e| {\n+        let disp = root_path.display();\n+        tcx.sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n+    });\n     root_path.pop();\n \n-    let mut visitor = dump_csv::DumpCsvVisitor::new(tcx, lcx, analysis, output_file);\n+    let utils = SpanUtils::new(&tcx.sess);\n+    let mut dumper = CsvDumper::new(&mut output_file, utils);\n+    let mut visitor = DumpVisitor::new(tcx, lcx, analysis, &mut dumper);\n+    // FIXME: we don't write anything!\n \n     visitor.dump_crate_info(cratename, krate);\n     visit::walk_crate(&mut visitor, krate);"}, {"sha": "7ca2cf998bd2d8074ef6021e69e97962761ce7b9", "filename": "src/librustc_trans/save/recorder.rs", "status": "removed", "additions": 0, "deletions": 714, "changes": 714, "blob_url": "https://github.com/rust-lang/rust/blob/f6e125f04a54ec65eac0ecd3cb68e180210a06fa/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6e125f04a54ec65eac0ecd3cb68e180210a06fa/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=f6e125f04a54ec65eac0ecd3cb68e180210a06fa", "patch": "@@ -1,714 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub use self::Row::*;\n-\n-use super::escape;\n-use super::span_utils::SpanUtils;\n-\n-use middle::cstore::LOCAL_CRATE;\n-use middle::def_id::{CRATE_DEF_INDEX, DefId};\n-use middle::ty::TyCtxt;\n-\n-use std::io::Write;\n-\n-use syntax::ast;\n-use syntax::ast::NodeId;\n-use syntax::codemap::*;\n-\n-const CRATE_ROOT_DEF_ID: DefId = DefId {\n-    krate: LOCAL_CRATE,\n-    index: CRATE_DEF_INDEX,\n-};\n-\n-pub struct Recorder {\n-    // output file\n-    pub out: Box<Write + 'static>,\n-    pub dump_spans: bool,\n-}\n-\n-impl Recorder {\n-    pub fn record(&mut self, info: &str) {\n-        match write!(self.out, \"{}\", info) {\n-            Err(_) => error!(\"Error writing output '{}'\", info),\n-            _ => (),\n-        }\n-    }\n-\n-    pub fn dump_span(&mut self, su: SpanUtils, kind: &str, span: Span, _sub_span: Option<Span>) {\n-        assert!(self.dump_spans);\n-        let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n-                             kind,\n-                             su.extent_str(span),\n-                             escape(su.snippet(span)));\n-        self.record(&result[..]);\n-    }\n-}\n-\n-pub struct FmtStrs<'a, 'tcx: 'a> {\n-    pub recorder: Box<Recorder>,\n-    span: SpanUtils<'a>,\n-    tcx: &'a TyCtxt<'tcx>,\n-}\n-\n-macro_rules! s { ($e:expr) => { format!(\"{}\", $e) }}\n-macro_rules! svec {\n-    ($($e:expr),*) => ({\n-        // leading _ to allow empty construction without a warning.\n-        let mut _temp = ::std::vec::Vec::new();\n-        $(_temp.push(s!($e));)*\n-        _temp\n-    })\n-}\n-\n-// FIXME recorder should operate on super::Data, rather than lots of ad hoc\n-// data.\n-\n-#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub enum Row {\n-    Variable,\n-    Enum,\n-    Variant,\n-    VariantStruct,\n-    Function,\n-    MethodDecl,\n-    Struct,\n-    Trait,\n-    Impl,\n-    Module,\n-    UseAlias,\n-    UseGlob,\n-    ExternCrate,\n-    Inheritance,\n-    MethodCall,\n-    Typedef,\n-    ExternalCrate,\n-    Crate,\n-    FnCall,\n-    ModRef,\n-    VarRef,\n-    TypeRef,\n-    FnRef,\n-    Macro,\n-    MacroUse,\n-}\n-\n-impl<'a, 'tcx: 'a> FmtStrs<'a, 'tcx> {\n-    pub fn new(rec: Box<Recorder>,\n-               span: SpanUtils<'a>,\n-               tcx: &'a TyCtxt<'tcx>)\n-               -> FmtStrs<'a, 'tcx> {\n-        FmtStrs {\n-            recorder: rec,\n-            span: span,\n-            tcx: tcx,\n-        }\n-    }\n-\n-    // Emitted ids are used to cross-reference items across crates. DefIds and\n-    // NodeIds do not usually correspond in any way. The strategy is to use the\n-    // index from the DefId as a crate-local id. However, within a crate, DefId\n-    // indices and NodeIds can overlap. So, we must adjust the NodeIds. If an\n-    // item can be identified by a DefId as well as a NodeId, then we use the\n-    // DefId index as the id. If it can't, then we have to use the NodeId, but\n-    // need to adjust it so it will not clash with any possible DefId index.\n-    fn normalize_node_id(&self, id: NodeId) -> usize {\n-        match self.tcx.map.opt_local_def_id(id) {\n-            Some(id) => id.index.as_usize(),\n-            None => id as usize + self.tcx.map.num_local_def_ids()\n-        }\n-    }\n-\n-    // A map from kind of item to a tuple of\n-    //   a string representation of the name\n-    //   a vector of field names\n-    //   whether this kind requires a span\n-    //   whether dump_spans should dump for this kind\n-    fn lookup_row(r: Row) -> (&'static str, Vec<&'static str>, bool, bool) {\n-        match r {\n-            Variable => (\"variable\",\n-                         vec!(\"id\", \"name\", \"qualname\", \"value\", \"type\", \"scopeid\"),\n-                         true,\n-                         true),\n-            Enum => (\"enum\",\n-                     vec!(\"id\", \"qualname\", \"scopeid\", \"value\"),\n-                     true,\n-                     true),\n-            Variant => (\"variant\",\n-                        vec!(\"id\", \"name\", \"qualname\", \"type\", \"value\", \"scopeid\"),\n-                        true,\n-                        true),\n-            VariantStruct => (\"variant_struct\",\n-                              vec!(\"id\", \"ctor_id\", \"qualname\", \"type\", \"value\", \"scopeid\"),\n-                              true,\n-                              true),\n-            Function => (\"function\",\n-                         vec!(\"id\", \"qualname\", \"declid\", \"declidcrate\", \"scopeid\"),\n-                         true,\n-                         true),\n-            MethodDecl => (\"method_decl\",\n-                           vec!(\"id\", \"qualname\", \"scopeid\"),\n-                           true,\n-                           true),\n-            Struct => (\"struct\",\n-                       vec!(\"id\", \"ctor_id\", \"qualname\", \"scopeid\", \"value\"),\n-                       true,\n-                       true),\n-            Trait => (\"trait\",\n-                      vec!(\"id\", \"qualname\", \"scopeid\", \"value\"),\n-                      true,\n-                      true),\n-            Impl => (\"impl\",\n-                     vec!(\"id\",\n-                          \"refid\",\n-                          \"refidcrate\",\n-                          \"traitid\",\n-                          \"traitidcrate\",\n-                          \"scopeid\"),\n-                     true,\n-                     true),\n-            Module => (\"module\",\n-                       vec!(\"id\", \"qualname\", \"scopeid\", \"def_file\"),\n-                       true,\n-                       false),\n-            UseAlias => (\"use_alias\",\n-                         vec!(\"id\", \"refid\", \"refidcrate\", \"name\", \"scopeid\"),\n-                         true,\n-                         true),\n-            UseGlob => (\"use_glob\", vec!(\"id\", \"value\", \"scopeid\"), true, true),\n-            ExternCrate => (\"extern_crate\",\n-                            vec!(\"id\", \"name\", \"location\", \"crate\", \"scopeid\"),\n-                            true,\n-                            true),\n-            Inheritance => (\"inheritance\",\n-                            vec!(\"base\", \"basecrate\", \"derived\", \"derivedcrate\"),\n-                            true,\n-                            false),\n-            MethodCall => (\"method_call\",\n-                           vec!(\"refid\", \"refidcrate\", \"declid\", \"declidcrate\", \"scopeid\"),\n-                           true,\n-                           true),\n-            Typedef => (\"typedef\", vec!(\"id\", \"qualname\", \"value\"), true, true),\n-            ExternalCrate => (\"external_crate\",\n-                              vec!(\"name\", \"crate\", \"file_name\"),\n-                              false,\n-                              false),\n-            Crate => (\"crate\", vec!(\"name\", \"crate_root\"), true, false),\n-            FnCall => (\"fn_call\",\n-                       vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n-                       true,\n-                       true),\n-            ModRef => (\"mod_ref\",\n-                       vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n-                       true,\n-                       true),\n-            VarRef => (\"var_ref\",\n-                       vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n-                       true,\n-                       true),\n-            TypeRef => (\"type_ref\",\n-                        vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n-                        true,\n-                        true),\n-            FnRef => (\"fn_ref\",\n-                      vec!(\"refid\", \"refidcrate\", \"qualname\", \"scopeid\"),\n-                      true,\n-                      true),\n-            Macro => (\"macro\",\n-                         vec!(\"name\", \"qualname\"),\n-                         true,\n-                         true),\n-            MacroUse => (\"macro_use\",\n-                         vec!(\"callee_name\", \"qualname\", \"scopeid\"),\n-                         true,\n-                         true),\n-        }\n-    }\n-\n-    pub fn make_values_str(&self,\n-                           kind: &'static str,\n-                           fields: &Vec<&'static str>,\n-                           values: Vec<String>,\n-                           span: Span)\n-                           -> Option<String> {\n-        if values.len() != fields.len() {\n-            self.span.sess.span_bug(span,\n-                                    &format!(\"Mismatch between length of fields for '{}', \\\n-                                              expected '{}', found '{}'\",\n-                                             kind,\n-                                             fields.len(),\n-                                             values.len()));\n-        }\n-\n-        let values = values.iter().map(|s| {\n-            // Never take more than 1020 chars\n-            if s.len() > 1020 {\n-                &s[..1020]\n-            } else {\n-                &s[..]\n-            }\n-        });\n-\n-        let pairs = fields.iter().zip(values);\n-        let strs = pairs.map(|(f, v)| format!(\",{},\\\"{}\\\"\", f, escape(String::from(v))));\n-        Some(strs.fold(String::new(),\n-                       |mut s, ss| {\n-                           s.push_str(&ss[..]);\n-                           s\n-                       }))\n-    }\n-\n-    pub fn record_without_span(&mut self, kind: Row, values: Vec<String>, span: Span) {\n-        let (label, ref fields, needs_span, dump_spans) = FmtStrs::lookup_row(kind);\n-\n-        if needs_span {\n-            self.span.sess.span_bug(span,\n-                                    &format!(\"Called record_without_span for '{}' which does \\\n-                                              requires a span\",\n-                                             label));\n-        }\n-        assert!(!dump_spans);\n-\n-        if self.recorder.dump_spans {\n-            return;\n-        }\n-\n-        let values_str = match self.make_values_str(label, fields, values, span) {\n-            Some(vs) => vs,\n-            None => return,\n-        };\n-\n-        let mut result = String::from(label);\n-        result.push_str(&values_str[..]);\n-        result.push_str(\"\\n\");\n-        self.recorder.record(&result[..]);\n-    }\n-\n-    pub fn record_with_span(&mut self,\n-                            kind: Row,\n-                            span: Span,\n-                            sub_span: Span,\n-                            values: Vec<String>) {\n-        let (label, ref fields, needs_span, dump_spans) = FmtStrs::lookup_row(kind);\n-\n-        if self.recorder.dump_spans {\n-            if dump_spans {\n-                self.recorder.dump_span(self.span.clone(), label, span, Some(sub_span));\n-            }\n-            return;\n-        }\n-\n-        if !needs_span {\n-            self.span.sess.span_bug(span,\n-                                    &format!(\"Called record_with_span for '{}' which does not \\\n-                                              require a span\",\n-                                             label));\n-        }\n-\n-        let values_str = match self.make_values_str(label, fields, values, span) {\n-            Some(vs) => vs,\n-            None => return,\n-        };\n-        let result = format!(\"{},{}{}\\n\",\n-                             label,\n-                             self.span.extent_str(sub_span),\n-                             values_str);\n-        self.recorder.record(&result[..]);\n-    }\n-\n-    pub fn check_and_record(&mut self,\n-                            kind: Row,\n-                            span: Span,\n-                            sub_span: Option<Span>,\n-                            values: Vec<String>) {\n-        filter!(self.span, sub_span, span);\n-        match sub_span {\n-            Some(sub_span) => self.record_with_span(kind, span, sub_span, values),\n-            None => {\n-                let (label, _, _, _) = FmtStrs::lookup_row(kind);\n-                self.span.report_span_err(label, span);\n-            }\n-        }\n-    }\n-\n-    pub fn variable_str(&mut self,\n-                        span: Span,\n-                        sub_span: Option<Span>,\n-                        id: NodeId,\n-                        name: &str,\n-                        value: &str,\n-                        typ: &str) {\n-        // Getting a fully qualified name for a variable is hard because in\n-        // the local case they can be overridden in one block and there is no nice way\n-        // to refer to such a scope in english, so we just hack it by appending the\n-        // variable def's node id\n-        let mut qualname = String::from(name);\n-        qualname.push_str(\"$\");\n-        qualname.push_str(&id.to_string());\n-        let id = self.normalize_node_id(id);\n-        self.check_and_record(Variable,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, qualname, value, typ, 0));\n-    }\n-\n-    // formal parameters\n-    pub fn formal_str(&mut self,\n-                      span: Span,\n-                      sub_span: Option<Span>,\n-                      id: NodeId,\n-                      fn_name: &str,\n-                      name: &str,\n-                      typ: &str) {\n-        let mut qualname = String::from(fn_name);\n-        qualname.push_str(\"::\");\n-        qualname.push_str(name);\n-        let id = self.normalize_node_id(id);\n-        self.check_and_record(Variable,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, qualname, \"\", typ, 0));\n-    }\n-\n-    // value is the initialising expression of the static if it is not mut, otherwise \"\".\n-    pub fn static_str(&mut self,\n-                      span: Span,\n-                      sub_span: Option<Span>,\n-                      id: NodeId,\n-                      name: &str,\n-                      qualname: &str,\n-                      value: &str,\n-                      typ: &str,\n-                      scope_id: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(Variable,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, qualname, value, typ, scope_id));\n-    }\n-\n-    pub fn field_str(&mut self,\n-                     span: Span,\n-                     sub_span: Option<Span>,\n-                     id: NodeId,\n-                     name: &str,\n-                     qualname: &str,\n-                     typ: &str,\n-                     scope_id: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(Variable,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, qualname, \"\", typ, scope_id));\n-    }\n-\n-    pub fn enum_str(&mut self,\n-                    span: Span,\n-                    sub_span: Option<Span>,\n-                    id: NodeId,\n-                    name: &str,\n-                    scope_id: NodeId,\n-                    value: &str) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(Enum, span, sub_span, svec!(id, name, scope_id, value));\n-    }\n-\n-    pub fn tuple_variant_str(&mut self,\n-                             span: Span,\n-                             sub_span: Option<Span>,\n-                             id: NodeId,\n-                             name: &str,\n-                             qualname: &str,\n-                             typ: &str,\n-                             val: &str,\n-                             scope_id: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(Variant,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, qualname, typ, val, scope_id));\n-    }\n-\n-    pub fn struct_variant_str(&mut self,\n-                              span: Span,\n-                              sub_span: Option<Span>,\n-                              id: NodeId,\n-                              name: &str,\n-                              typ: &str,\n-                              val: &str,\n-                              scope_id: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let ctor_id = id;\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(VariantStruct,\n-                              span,\n-                              sub_span,\n-                              svec!(id, ctor_id, name, typ, val, scope_id));\n-    }\n-\n-    pub fn fn_str(&mut self,\n-                  span: Span,\n-                  sub_span: Option<Span>,\n-                  id: NodeId,\n-                  name: &str,\n-                  scope_id: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(Function,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, \"\", \"\", scope_id));\n-    }\n-\n-    pub fn method_str(&mut self,\n-                      span: Span,\n-                      sub_span: Option<Span>,\n-                      id: NodeId,\n-                      name: &str,\n-                      decl_id: Option<DefId>,\n-                      scope_id: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        let values = match decl_id {\n-            Some(decl_id) => svec!(id,\n-                                   name,\n-                                   decl_id.index.as_usize(),\n-                                   decl_id.krate,\n-                                   scope_id),\n-            None => svec!(id, name, \"\", \"\", scope_id),\n-        };\n-        self.check_and_record(Function, span, sub_span, values);\n-    }\n-\n-    pub fn method_decl_str(&mut self,\n-                           span: Span,\n-                           sub_span: Option<Span>,\n-                           id: NodeId,\n-                           name: &str,\n-                           scope_id: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(MethodDecl, span, sub_span, svec!(id, name, scope_id));\n-    }\n-\n-    pub fn struct_str(&mut self,\n-                      span: Span,\n-                      sub_span: Option<Span>,\n-                      id: NodeId,\n-                      ctor_id: NodeId,\n-                      name: &str,\n-                      scope_id: NodeId,\n-                      value: &str) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        let ctor_id = self.normalize_node_id(ctor_id);\n-        self.check_and_record(Struct,\n-                              span,\n-                              sub_span,\n-                              svec!(id, ctor_id, name, scope_id, value));\n-    }\n-\n-    pub fn trait_str(&mut self,\n-                     span: Span,\n-                     sub_span: Option<Span>,\n-                     id: NodeId,\n-                     name: &str,\n-                     scope_id: NodeId,\n-                     value: &str) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(Trait, span, sub_span, svec!(id, name, scope_id, value));\n-    }\n-\n-    pub fn impl_str(&mut self,\n-                    span: Span,\n-                    sub_span: Option<Span>,\n-                    id: NodeId,\n-                    ref_id: Option<DefId>,\n-                    trait_id: Option<DefId>,\n-                    scope_id: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let scope_id = self.normalize_node_id(scope_id);\n-        let ref_id = ref_id.unwrap_or(CRATE_ROOT_DEF_ID);\n-        let trait_id = trait_id.unwrap_or(CRATE_ROOT_DEF_ID);\n-        self.check_and_record(Impl,\n-                              span,\n-                              sub_span,\n-                              svec!(id,\n-                                    ref_id.index.as_usize(),\n-                                    ref_id.krate,\n-                                    trait_id.index.as_usize(),\n-                                    trait_id.krate,\n-                                    scope_id));\n-    }\n-\n-    pub fn mod_str(&mut self,\n-                   span: Span,\n-                   sub_span: Option<Span>,\n-                   id: NodeId,\n-                   name: &str,\n-                   parent: NodeId,\n-                   filename: &str) {\n-        let id = self.normalize_node_id(id);\n-        let parent = self.normalize_node_id(parent);\n-        self.check_and_record(Module,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, parent, filename));\n-    }\n-\n-    pub fn use_alias_str(&mut self,\n-                         span: Span,\n-                         sub_span: Option<Span>,\n-                         id: NodeId,\n-                         mod_id: Option<DefId>,\n-                         name: &str,\n-                         parent: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let parent = self.normalize_node_id(parent);\n-        let mod_id = mod_id.unwrap_or(CRATE_ROOT_DEF_ID);\n-        self.check_and_record(UseAlias,\n-                              span,\n-                              sub_span,\n-                              svec!(id, mod_id.index.as_usize(), mod_id.krate, name, parent));\n-    }\n-\n-    pub fn use_glob_str(&mut self,\n-                        span: Span,\n-                        sub_span: Option<Span>,\n-                        id: NodeId,\n-                        values: &str,\n-                        parent: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let parent = self.normalize_node_id(parent);\n-        self.check_and_record(UseGlob, span, sub_span, svec!(id, values, parent));\n-    }\n-\n-    pub fn extern_crate_str(&mut self,\n-                            span: Span,\n-                            sub_span: Option<Span>,\n-                            id: NodeId,\n-                            cnum: ast::CrateNum,\n-                            name: &str,\n-                            loc: &str,\n-                            parent: NodeId) {\n-        let id = self.normalize_node_id(id);\n-        let parent = self.normalize_node_id(parent);\n-        self.check_and_record(ExternCrate,\n-                              span,\n-                              sub_span,\n-                              svec!(id, name, loc, cnum, parent));\n-    }\n-\n-    pub fn inherit_str(&mut self,\n-                       span: Span,\n-                       sub_span: Option<Span>,\n-                       base_id: DefId,\n-                       deriv_id: NodeId) {\n-        let deriv_id = self.normalize_node_id(deriv_id);\n-        self.check_and_record(Inheritance,\n-                              span,\n-                              sub_span,\n-                              svec!(base_id.index.as_usize(), base_id.krate, deriv_id, 0));\n-    }\n-\n-    pub fn fn_call_str(&mut self,\n-                       span: Span,\n-                       sub_span: Option<Span>,\n-                       id: DefId,\n-                       scope_id: NodeId) {\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(FnCall,\n-                              span,\n-                              sub_span,\n-                              svec!(id.index.as_usize(), id.krate, \"\", scope_id));\n-    }\n-\n-    pub fn meth_call_str(&mut self,\n-                         span: Span,\n-                         sub_span: Option<Span>,\n-                         defid: Option<DefId>,\n-                         declid: Option<DefId>,\n-                         scope_id: NodeId) {\n-        let scope_id = self.normalize_node_id(scope_id);\n-        let defid = defid.unwrap_or(CRATE_ROOT_DEF_ID);\n-        let (dcn, dck) = match declid {\n-            Some(declid) => (s!(declid.index.as_usize()), s!(declid.krate)),\n-            None => (\"\".to_string(), \"\".to_string()),\n-        };\n-        self.check_and_record(MethodCall,\n-                              span,\n-                              sub_span,\n-                              svec!(defid.index.as_usize(), defid.krate, dcn, dck, scope_id));\n-    }\n-\n-    pub fn sub_mod_ref_str(&mut self, span: Span, sub_span: Span, qualname: &str, parent: NodeId) {\n-        let parent = self.normalize_node_id(parent);\n-        self.record_with_span(ModRef, span, sub_span, svec!(0, 0, qualname, parent));\n-    }\n-\n-    pub fn typedef_str(&mut self,\n-                       span: Span,\n-                       sub_span: Option<Span>,\n-                       id: NodeId,\n-                       qualname: &str,\n-                       value: &str) {\n-        let id = self.normalize_node_id(id);\n-        self.check_and_record(Typedef, span, sub_span, svec!(id, qualname, value));\n-    }\n-\n-    pub fn crate_str(&mut self, span: Span, name: &str, crate_root: &str) {\n-        self.record_with_span(Crate, span, span, svec!(name, crate_root));\n-    }\n-\n-    pub fn external_crate_str(&mut self, span: Span, name: &str, num: ast::CrateNum) {\n-        let lo_loc = self.span.sess.codemap().lookup_char_pos(span.lo);\n-        self.record_without_span(ExternalCrate,\n-                                 svec!(name, num, SpanUtils::make_path_string(&lo_loc.file.name)),\n-                                 span);\n-    }\n-\n-    pub fn sub_type_ref_str(&mut self, span: Span, sub_span: Span, qualname: &str) {\n-        self.record_with_span(TypeRef, span, sub_span, svec!(0, 0, qualname, 0));\n-    }\n-\n-    // A slightly generic function for a reference to an item of any kind.\n-    pub fn ref_str(&mut self,\n-                   kind: Row,\n-                   span: Span,\n-                   sub_span: Option<Span>,\n-                   id: DefId,\n-                   scope_id: NodeId) {\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.check_and_record(kind,\n-                              span,\n-                              sub_span,\n-                              svec!(id.index.as_usize(), id.krate, \"\", scope_id));\n-    }\n-\n-    pub fn macro_str(&mut self, span: Span, sub_span: Span, name: String, qualname: String) {\n-        self.record_with_span(Macro, span, sub_span, svec!(name, qualname));\n-    }\n-\n-    pub fn macro_use_str(&mut self,\n-                         span: Span,\n-                         sub_span: Span,\n-                         name: String,\n-                         qualname: String,\n-                         scope_id: NodeId) {\n-        let scope_id = self.normalize_node_id(scope_id);\n-        self.record_with_span(MacroUse, span, sub_span,\n-                              svec!(name, qualname, scope_id));\n-    }\n-}"}]}