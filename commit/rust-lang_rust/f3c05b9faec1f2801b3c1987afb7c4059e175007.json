{"sha": "f3c05b9faec1f2801b3c1987afb7c4059e175007", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzYzA1YjlmYWVjMWYyODAxYjNjMTk4N2FmYjdjNDA1OWUxNzUwMDc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-29T19:58:52Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-07-29T19:58:52Z"}, "message": "Turn on kind propagation for typarams. Annotate a bunch of typarams in rustc and libstd.", "tree": {"sha": "cac1890a896873cfe98460bbcd67a388dbd6382a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cac1890a896873cfe98460bbcd67a388dbd6382a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3c05b9faec1f2801b3c1987afb7c4059e175007", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c05b9faec1f2801b3c1987afb7c4059e175007", "html_url": "https://github.com/rust-lang/rust/commit/f3c05b9faec1f2801b3c1987afb7c4059e175007", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3c05b9faec1f2801b3c1987afb7c4059e175007/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c34d74315f8d336c91c00819c4c12cd655990a59", "url": "https://api.github.com/repos/rust-lang/rust/commits/c34d74315f8d336c91c00819c4c12cd655990a59", "html_url": "https://github.com/rust-lang/rust/commit/c34d74315f8d336c91c00819c4c12cd655990a59"}], "stats": {"total": 180, "additions": 89, "deletions": 91}, "files": [{"sha": "a54b8622bb0b349c2222f6b8568c13aa08ccce37", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=f3c05b9faec1f2801b3c1987afb7c4059e175007", "patch": "@@ -150,7 +150,7 @@ fn parse_ty_constr_arg(st: @pstate, sd: str_def) ->\n     }\n }\n \n-fn parse_constr[T](st: @pstate, sd: str_def, pser: arg_parser[T]) ->\n+fn parse_constr[@T](st: @pstate, sd: str_def, pser: arg_parser[T]) ->\n    @ty::constr_general[T] {\n     let sp = {lo: 0u, hi: 0u}; // FIXME: use a real span\n     let args: (@sp_constr_arg[T])[] = ~[];"}, {"sha": "37ca0632cabd38572a6a6133a9e5d3f9d7f7d282", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f3c05b9faec1f2801b3c1987afb7c4059e175007", "patch": "@@ -1129,10 +1129,7 @@ fn type_kind(cx: &ctxt, ty: &t) -> ast::kind {\n       ty_var(_) { fail; }\n \n       ty_param(_,k) {\n-        // FIXME: when you turn this on, the stdlib will break; be sure\n-        // to have a snapshot done that understands kinds before doing so.\n-\n-        // result = kind::lower_kind(result, k);\n+        result = kind::lower_kind(result, k);\n       }\n \n       ty_constr(t, _) {"}, {"sha": "a501cfaf8f1e4f70cd595cbc6bca714c660d8476", "filename": "src/lib/deque.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=f3c05b9faec1f2801b3c1987afb7c4059e175007", "patch": "@@ -16,7 +16,7 @@ type t[T] =\n         fn get(int) -> T ;\n     };\n \n-fn create[T]() -> t[T] {\n+fn create[@T]() -> t[T] {\n     type cell[T] = option::t[T];\n \n     let initial_capacity: uint = 32u; // 2^5\n@@ -26,7 +26,7 @@ fn create[T]() -> t[T] {\n       */\n \n \n-    fn grow[T](nelts: uint, lo: uint, elts: &(cell[T])[mutable ]) ->\n+    fn grow[@T](nelts: uint, lo: uint, elts: &(cell[T])[mutable ]) ->\n        (cell[T])[mutable ] {\n         assert (nelts == ivec::len(elts));\n         let rv = ~[mutable ];\n@@ -42,13 +42,13 @@ fn create[T]() -> t[T] {\n \n         ret rv;\n     }\n-    fn get[T](elts: &(cell[T])[mutable ], i: uint) -> T {\n+    fn get[@T](elts: &(cell[T])[mutable ], i: uint) -> T {\n         ret alt elts.(i) { option::some(t) { t } _ { fail } };\n     }\n-    obj deque[T](mutable nelts: uint,\n-                 mutable lo: uint,\n-                 mutable hi: uint,\n-                 mutable elts: (cell[T])[mutable ]) {\n+    obj deque[@T](mutable nelts: uint,\n+                  mutable lo: uint,\n+                  mutable hi: uint,\n+                  mutable elts: (cell[T])[mutable ]) {\n         fn size() -> uint { ret nelts; }\n         fn add_front(t: &T) {\n             let oldlo: uint = lo;"}, {"sha": "eed4837d83fc62c8a331bbbdd297d35e57c99bc1", "filename": "src/lib/ivec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fivec.rs?ref=f3c05b9faec1f2801b3c1987afb7c4059e175007", "patch": "@@ -168,7 +168,7 @@ fn grow_fn[T](v: &mutable T[], n: uint, init_fn: fn(uint) -> T ) {\n /// Sets the element at position `index` to `val`. If `index` is past the end\n /// of the vector, expands the vector by replicating `initval` to fill the\n /// intervening space.\n-fn grow_set[T](v: &mutable T[mutable ], index: uint, initval: &T, val: &T) {\n+fn grow_set[@T](v: &mutable T[mutable ], index: uint, initval: &T, val: &T) {\n     if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n     v.(index) = val;\n }"}, {"sha": "cd38d0f6cd797646f003aac5652ff948a12b0c94", "filename": "src/lib/list.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=f3c05b9faec1f2801b3c1987afb7c4059e175007", "patch": "@@ -8,7 +8,7 @@ import option::none;\n // our recursion rules do not permit that.\n tag list[T] { cons(T, @list[T]); nil; }\n \n-fn from_vec[T](v: vec[T]) -> list[T] {\n+fn from_vec[@T](v: vec[T]) -> list[T] {\n     let l = nil[T];\n     // FIXME: This would be faster and more space efficient if it looped over\n     // a reverse vector iterator. Unfortunately generic iterators seem not to\n@@ -18,7 +18,7 @@ fn from_vec[T](v: vec[T]) -> list[T] {\n     ret l;\n }\n \n-fn foldl[T, U](ls_: &list[T], u: &U, f: fn(&T, &U) -> U ) -> U {\n+fn foldl[@T, @U](ls_: &list[T], u: &U, f: fn(&T, &U) -> U ) -> U {\n     let accum: U = u;\n     let ls = ls_;\n     while true {\n@@ -30,7 +30,7 @@ fn foldl[T, U](ls_: &list[T], u: &U, f: fn(&T, &U) -> U ) -> U {\n     ret accum;\n }\n \n-fn find[T, U](ls_: &list[T], f: fn(&T) -> option::t[U] ) -> option::t[U] {\n+fn find[@T, @U](ls_: &list[T], f: fn(&T) -> option::t[U] ) -> option::t[U] {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -43,7 +43,7 @@ fn find[T, U](ls_: &list[T], f: fn(&T) -> option::t[U] ) -> option::t[U] {\n     ret none;\n }\n \n-fn has[T](ls_: &list[T], elt: &T) -> bool {\n+fn has[@T](ls_: &list[T], elt: &T) -> bool {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -60,11 +60,11 @@ fn length[T](ls: &list[T]) -> uint {\n     ret foldl[T, uint](ls, 0u, bind count[T](_, _));\n }\n \n-fn cdr[T](ls: &list[T]) -> list[T] { alt ls { cons(_, tl) { ret *tl; } } }\n+fn cdr[@T](ls: &list[T]) -> list[T] { alt ls { cons(_, tl) { ret *tl; } } }\n \n-fn car[T](ls: &list[T]) -> T { alt ls { cons(hd, _) { ret hd; } } }\n+fn car[@T](ls: &list[T]) -> T { alt ls { cons(hd, _) { ret hd; } } }\n \n-fn append[T](l: &list[T], m: &list[T]) -> list[T] {\n+fn append[@T](l: &list[T], m: &list[T]) -> list[T] {\n     alt l {\n       nil. { ret m; }\n       cons(x, xs) {"}, {"sha": "6ce93d4592f1a7e9e7918cf08c4cdb05f39f0c26", "filename": "src/lib/map.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=f3c05b9faec1f2801b3c1987afb7c4059e175007", "patch": "@@ -19,9 +19,9 @@ type hashmap[K, V] =\n     };\n type hashset[K] = hashmap[K, ()];\n \n-fn set_add[K](set: hashset[K], key: &K) -> bool { ret set.insert(key, ()); }\n+fn set_add[@K](set: hashset[K], key: &K) -> bool { ret set.insert(key, ()); }\n \n-fn mk_hashmap[K, V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n+fn mk_hashmap[@K, @V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n     let initial_capacity: uint = 32u; // 2^5\n \n     let load_factor: util::rational = {num: 3, den: 4};\n@@ -53,10 +53,10 @@ fn mk_hashmap[K, V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n      * will fail.\n      */\n \n-    fn insert_common[K,\n-                     V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                        bkts: &(bucket[K, V])[mutable ], nbkts: uint, key: &K,\n-                        val: &V) -> bool {\n+    fn insert_common[@K,\n+                     @V](hasher: &hashfn[K], eqer: &eqfn[K],\n+                         bkts: &(bucket[K, V])[mutable ], nbkts: uint,\n+                         key: &K, val: &V) -> bool {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n@@ -78,9 +78,9 @@ fn mk_hashmap[K, V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n         fail; // full table\n \n     }\n-    fn find_common[K,\n-                   V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                      bkts: &(bucket[K, V])[mutable ], nbkts: uint, key: &K)\n+    fn find_common[@K,\n+                   @V](hasher: &hashfn[K], eqer: &eqfn[K],\n+                       bkts: &(bucket[K, V])[mutable ], nbkts: uint, key: &K)\n        -> option::t[V] {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n@@ -101,10 +101,10 @@ fn mk_hashmap[K, V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n         }\n         ret option::none[V];\n     }\n-    fn rehash[K,\n-              V](hasher: &hashfn[K], eqer: &eqfn[K],\n-                 oldbkts: &(bucket[K, V])[mutable ], noldbkts: uint,\n-                 newbkts: &(bucket[K, V])[mutable ], nnewbkts: uint) {\n+    fn rehash[@K,\n+              @V](hasher: &hashfn[K], eqer: &eqfn[K],\n+                  oldbkts: &(bucket[K, V])[mutable ], noldbkts: uint,\n+                  newbkts: &(bucket[K, V])[mutable ], nnewbkts: uint) {\n         for b: bucket[K, V]  in oldbkts {\n             alt b {\n               some(k_, v_) {\n@@ -116,13 +116,13 @@ fn mk_hashmap[K, V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n             }\n         }\n     }\n-    obj hashmap[K,\n-                V](hasher: hashfn[K],\n-                   eqer: eqfn[K],\n-                   mutable bkts: (bucket[K, V])[mutable ],\n-                   mutable nbkts: uint,\n-                   mutable nelts: uint,\n-                   lf: util::rational) {\n+    obj hashmap[@K,\n+                @V](hasher: hashfn[K],\n+                    eqer: eqfn[K],\n+                    mutable bkts: (bucket[K, V])[mutable ],\n+                    mutable nbkts: uint,\n+                    mutable nelts: uint,\n+                    lf: util::rational) {\n         fn size() -> uint { ret nelts; }\n         fn insert(key: &K, val: &V) -> bool {\n             let load: util::rational =\n@@ -199,17 +199,17 @@ fn mk_hashmap[K, V](hasher: &hashfn[K], eqer: &eqfn[K]) -> hashmap[K, V] {\n \n // Hash map constructors for basic types\n \n-fn new_str_hash[V]() -> hashmap[str, V] {\n+fn new_str_hash[@V]() -> hashmap[str, V] {\n     ret mk_hashmap(str::hash, str::eq);\n }\n \n-fn new_int_hash[V]() -> hashmap[int, V] {\n+fn new_int_hash[@V]() -> hashmap[int, V] {\n     fn hash_int(x: &int) -> uint { ret x as uint; }\n     fn eq_int(a: &int, b: &int) -> bool { ret a == b; }\n     ret mk_hashmap[int, V](hash_int, eq_int);\n }\n \n-fn new_uint_hash[V]() -> hashmap[uint, V] {\n+fn new_uint_hash[@V]() -> hashmap[uint, V] {\n     fn hash_uint(x: &uint) -> uint { ret x; }\n     fn eq_uint(a: &uint, b: &uint) -> bool { ret a == b; }\n     ret mk_hashmap[uint, V](hash_uint, eq_uint);"}, {"sha": "909e40c5c6b3b1814b1d39932bfd4706a2958e92", "filename": "src/lib/sort.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=f3c05b9faec1f2801b3c1987afb7c4059e175007", "patch": "@@ -11,7 +11,7 @@ export quick_sort3;\n \n type lteq[T] = fn(&T, &T) -> bool ;\n \n-fn merge_sort[T](le: lteq[T], v: vec[T]) -> vec[T] {\n+fn merge_sort[@T](le: lteq[T], v: vec[T]) -> vec[T] {\n     fn merge[T](le: lteq[T], a: vec[T], b: vec[T]) -> vec[T] {\n         let rs: vec[T] = [];\n         let a_len: uint = len[T](a);\n@@ -36,13 +36,13 @@ fn merge_sort[T](le: lteq[T], v: vec[T]) -> vec[T] {\n     ret merge[T](le, merge_sort[T](le, a), merge_sort[T](le, b));\n }\n \n-fn swap[T](arr: vec[mutable T], x: uint, y: uint) {\n+fn swap[@T](arr: vec[mutable T], x: uint, y: uint) {\n     let a = arr.(x);\n     arr.(x) = arr.(y);\n     arr.(y) = a;\n }\n \n-fn part[T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n+fn part[@T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n            right: uint, pivot: uint) -> uint {\n     let pivot_value = arr.(pivot);\n     swap[T](arr, pivot, right);\n@@ -59,7 +59,7 @@ fn part[T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n     ret storage_index;\n }\n \n-fn qsort[T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n+fn qsort[@T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n             right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -72,7 +72,7 @@ fn qsort[T](compare_func: lteq[T], arr: vec[mutable T], left: uint,\n     }\n }\n \n-fn quick_sort[T](compare_func: lteq[T], arr: vec[mutable T]) {\n+fn quick_sort[@T](compare_func: lteq[T], arr: vec[mutable T]) {\n     if len[T](arr) == 0u { ret; }\n     qsort[T](compare_func, arr, 0u, len[T](arr) - 1u);\n }\n@@ -82,7 +82,7 @@ fn quick_sort[T](compare_func: lteq[T], arr: vec[mutable T]) {\n // http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n // According to these slides this is the algorithm of choice for\n // 'randomly ordered keys, abstract compare' & 'small number of key values'\n-fn qsort3[T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n+fn qsort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n              arr: vec[mutable T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr.(right);\n@@ -130,7 +130,7 @@ fn qsort3[T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n     qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n-fn quick_sort3[T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n+fn quick_sort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n                   arr: vec[mutable T]) {\n     if vec::len[T](arr) == 0u { ret; }\n     qsort3[T](compare_func_lt, compare_func_eq, arr, 0,\n@@ -144,8 +144,8 @@ mod ivector {\n \n     type lteq[T] = fn(&T, &T) -> bool ;\n \n-    fn merge_sort[T](le: lteq[T], v: &T[]) -> T[] {\n-        fn merge[T](le: lteq[T], a: &T[], b: &T[]) -> T[] {\n+    fn merge_sort[@T](le: lteq[T], v: &T[]) -> T[] {\n+        fn merge[@T](le: lteq[T], a: &T[], b: &T[]) -> T[] {\n             let rs: T[] = ~[];\n             let a_len: uint = ilen[T](a);\n             let a_ix: uint = 0u;\n@@ -169,13 +169,13 @@ mod ivector {\n         ret merge[T](le, merge_sort[T](le, a), merge_sort[T](le, b));\n     }\n \n-    fn swap[T](arr: &T[mutable ], x: uint, y: uint) {\n+    fn swap[@T](arr: &T[mutable ], x: uint, y: uint) {\n         let a = arr.(x);\n         arr.(x) = arr.(y);\n         arr.(y) = a;\n     }\n \n-    fn part[T](compare_func: lteq[T], arr: &T[mutable ], left: uint,\n+    fn part[@T](compare_func: lteq[T], arr: &T[mutable ], left: uint,\n                right: uint, pivot: uint) -> uint {\n         let pivot_value = arr.(pivot);\n         swap[T](arr, pivot, right);\n@@ -192,7 +192,7 @@ mod ivector {\n         ret storage_index;\n     }\n \n-    fn qsort[T](compare_func: lteq[T], arr: &T[mutable ], left: uint,\n+    fn qsort[@T](compare_func: lteq[T], arr: &T[mutable ], left: uint,\n                 right: uint) {\n         if right > left {\n             let pivot = (left + right) / 2u;\n@@ -205,7 +205,7 @@ mod ivector {\n         }\n     }\n \n-    fn quick_sort[T](compare_func: lteq[T], arr: &T[mutable ]) {\n+    fn quick_sort[@T](compare_func: lteq[T], arr: &T[mutable ]) {\n         if ilen[T](arr) == 0u { ret; }\n         qsort[T](compare_func, arr, 0u, ilen[T](arr) - 1u);\n     }\n@@ -216,7 +216,7 @@ mod ivector {\n     // According to these slides this is the algorithm of choice for\n     // 'randomly ordered keys, abstract compare' & 'small number of key\n     // values'\n-    fn qsort3[T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n+    fn qsort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n                  arr: &T[mutable ], left: int, right: int) {\n         if right <= left { ret; }\n         let v: T = arr.(right);\n@@ -264,7 +264,7 @@ mod ivector {\n         qsort3[T](compare_func_lt, compare_func_eq, arr, i, right);\n     }\n \n-    fn quick_sort3[T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n+    fn quick_sort3[@T](compare_func_lt: lteq[T], compare_func_eq: lteq[T],\n                       arr: &T[mutable ]) {\n         if ilen[T](arr) == 0u { ret; }\n         qsort3[T](compare_func_lt, compare_func_eq, arr, 0,"}, {"sha": "0bf6475d297b0fa35876c208d88ab966296b61a3", "filename": "src/lib/vec.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=f3c05b9faec1f2801b3c1987afb7c4059e175007", "patch": "@@ -60,14 +60,14 @@ fn empty_mut[T]() -> vec[mutable T] { ret alloc_mut[T](0u); }\n \n type init_op[T] = fn(uint) -> T ;\n \n-fn init_fn[T](op: &init_op[T], n_elts: uint) -> vec[T] {\n+fn init_fn[@T](op: &init_op[T], n_elts: uint) -> vec[T] {\n     let v: vec[T] = alloc[T](n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += [op(i)]; i += 1u; }\n     ret v;\n }\n \n-fn init_fn_mut[T](op: &init_op[T], n_elts: uint) -> vec[mutable T] {\n+fn init_fn_mut[@T](op: &init_op[T], n_elts: uint) -> vec[mutable T] {\n     let v: vec[mutable T] = alloc_mut[T](n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += [mutable op(i)]; i += 1u; }\n@@ -76,7 +76,7 @@ fn init_fn_mut[T](op: &init_op[T], n_elts: uint) -> vec[mutable T] {\n \n // init_elt: creates and returns a vector of length n_elts, filled with\n // that many copies of element t.\n-fn init_elt[T](t: &T, n_elts: uint) -> vec[T] {\n+fn init_elt[@T](t: &T, n_elts: uint) -> vec[T] {\n     /**\n      * FIXME (issue #81): should be:\n      *\n@@ -91,7 +91,7 @@ fn init_elt[T](t: &T, n_elts: uint) -> vec[T] {\n     ret v;\n }\n \n-fn init_elt_mut[T](t: &T, n_elts: uint) -> vec[mutable T] {\n+fn init_elt_mut[@T](t: &T, n_elts: uint) -> vec[mutable T] {\n     let v: vec[mutable T] = alloc_mut[T](n_elts);\n     let i: uint = n_elts;\n     while i > 0u { i -= 1u; v += [mutable t]; }\n@@ -113,15 +113,15 @@ fn print_debug_info[T](v: array[T]) { rustrt::vec_print_debug_info[T](v); }\n \n // FIXME: typestate precondition (list is non-empty)\n // Returns the last element of v.\n-fn last[T](v: array[T]) -> option::t[T] {\n+fn last[@T](v: array[T]) -> option::t[T] {\n     let l = len[T](v);\n     if l == 0u { ret none[T]; }\n     ret some[T](v.(l - 1u));\n }\n \n \n // Returns elements from [start..end) from v.\n-fn slice[T](v: array[T], start: uint, end: uint) -> vec[T] {\n+fn slice[@T](v: array[T], start: uint, end: uint) -> vec[T] {\n     assert (start <= end);\n     assert (end <= len[T](v));\n     let result = alloc[T](end - start);\n@@ -132,7 +132,7 @@ fn slice[T](v: array[T], start: uint, end: uint) -> vec[T] {\n \n \n // FIXME: Should go away eventually.\n-fn slice_mut[T](v: array[T], start: uint, end: uint) -> vec[mutable T] {\n+fn slice_mut[@T](v: array[T], start: uint, end: uint) -> vec[mutable T] {\n     assert (start <= end);\n     assert (end <= len[T](v));\n     let result = alloc_mut[T](end - start);\n@@ -141,15 +141,15 @@ fn slice_mut[T](v: array[T], start: uint, end: uint) -> vec[mutable T] {\n     ret result;\n }\n \n-fn shift[T](v: &mutable array[T]) -> T {\n+fn shift[@T](v: &mutable array[T]) -> T {\n     let ln = len[T](v);\n     assert (ln > 0u);\n     let e = v.(0);\n     v = slice[T](v, 1u, ln);\n     ret e;\n }\n \n-fn pop[T](v: &mutable array[T]) -> T {\n+fn pop[@T](v: &mutable array[T]) -> T {\n     let ln = len[T](v);\n     assert (ln > 0u);\n     ln -= 1u;\n@@ -158,58 +158,59 @@ fn pop[T](v: &mutable array[T]) -> T {\n     ret e;\n }\n \n-fn top[T](v: &array[T]) -> T {\n+fn top[@T](v: &array[T]) -> T {\n     let ln = len[T](v);\n     assert (ln > 0u);\n     ret v.(ln - 1u);\n }\n \n-fn push[T](v: &mutable array[T], t: &T) { v += [t]; }\n+fn push[@T](v: &mutable array[T], t: &T) { v += [t]; }\n \n-fn unshift[T](v: &mutable array[T], t: &T) {\n+fn unshift[@T](v: &mutable array[T], t: &T) {\n     let rs = alloc[T](len[T](v) + 1u);\n     rs += [t];\n     rs += v;\n     v = rs;\n }\n \n-fn grow[T](v: &mutable array[T], n: uint, initval: &T) {\n+fn grow[@T](v: &mutable array[T], n: uint, initval: &T) {\n     let i: uint = n;\n     while i > 0u { i -= 1u; v += [initval]; }\n }\n \n-fn grow_set[T](v: &mutable vec[mutable T], index: uint, initval: &T,\n+fn grow_set[@T](v: &mutable vec[mutable T], index: uint, initval: &T,\n                val: &T) {\n     let length = vec::len(v);\n     if index >= length { grow(v, index - length + 1u, initval); }\n     v.(index) = val;\n }\n \n-fn grow_init_fn[T](v: &mutable array[T], n: uint, init_fn: fn() -> T ) {\n+fn grow_init_fn[@T](v: &mutable array[T], n: uint, init_fn: fn() -> T ) {\n     let i: uint = n;\n     while i > 0u { i -= 1u; v += [init_fn()]; }\n }\n \n-fn grow_init_fn_set[T](v: &mutable array[T], index: uint, init_fn: fn() -> T,\n+fn grow_init_fn_set[@T](v: &mutable array[T], index: uint, init_fn: fn() -> T,\n                        val: &T) {\n     let length = vec::len(v);\n     if index >= length { grow_init_fn(v, index - length + 1u, init_fn); }\n     v.(index) = val;\n }\n \n-fn map[T, U](f: &fn(&T) -> U , v: &vec[T]) -> vec[U] {\n+fn map[@T, @U](f: &fn(&T) -> U , v: &vec[T]) -> vec[U] {\n     let rs: vec[U] = alloc[U](len[T](v));\n     for ve: T  in v { rs += [f(ve)]; }\n     ret rs;\n }\n \n-fn filter_map[T, U](f: &fn(&T) -> option::t[U] , v: &vec[T]) -> vec[U] {\n+fn filter_map[@T, @U](f: &fn(&T) -> option::t[U] , v: &vec[T]) -> vec[U] {\n     let rs: vec[U] = [];\n     for ve: T  in v { alt f(ve) { some(elt) { rs += [elt]; } none. { } } }\n     ret rs;\n }\n \n-fn map2[T, U, V](f: &operator2[T, U, V], v0: &vec[T], v1: &vec[U]) -> vec[V] {\n+fn map2[@T, @U, @V](f: &operator2[T, U, V], v0: &vec[T], v1: &vec[U])\n+    -> vec[V] {\n     let v0_len = len[T](v0);\n     if v0_len != len[U](v1) { fail; }\n     let u: vec[V] = alloc[V](v0_len);\n@@ -218,12 +219,12 @@ fn map2[T, U, V](f: &operator2[T, U, V], v0: &vec[T], v1: &vec[U]) -> vec[V] {\n     ret u;\n }\n \n-fn find[T](f: fn(&T) -> bool , v: &vec[T]) -> option::t[T] {\n+fn find[@T](f: fn(&T) -> bool , v: &vec[T]) -> option::t[T] {\n     for elt: T  in v { if f(elt) { ret some[T](elt); } }\n     ret none[T];\n }\n \n-fn position[T](x: &T, v: &array[T]) -> option::t[uint] {\n+fn position[@T](x: &T, v: &array[T]) -> option::t[uint] {\n     let i: uint = 0u;\n     while i < len(v) { if x == v.(i) { ret some[uint](i); } i += 1u; }\n     ret none[uint];\n@@ -246,7 +247,7 @@ fn count[T](x: &T, v: &array[T]) -> uint {\n     ret cnt;\n }\n \n-fn foldl[T, U](p: fn(&U, &T) -> U , z: &U, v: &vec[T]) -> U {\n+fn foldl[@T, @U](p: fn(&U, &T) -> U , z: &U, v: &vec[T]) -> U {\n     let sz = len[T](v);\n     if sz == 0u {\n         ret z;\n@@ -256,7 +257,7 @@ fn foldl[T, U](p: fn(&U, &T) -> U , z: &U, v: &vec[T]) -> U {\n     }\n }\n \n-fn unzip[T, U](v: &vec[{_0: T, _1: U}]) -> {_0: vec[T], _1: vec[U]} {\n+fn unzip[@T, @U](v: &vec[{_0: T, _1: U}]) -> {_0: vec[T], _1: vec[U]} {\n     let sz = len(v);\n     if sz == 0u {\n         ret {_0: alloc[T](0u), _1: alloc[U](0u)};\n@@ -271,7 +272,7 @@ fn unzip[T, U](v: &vec[{_0: T, _1: U}]) -> {_0: vec[T], _1: vec[U]} {\n \n \n // FIXME make the lengths being equal a constraint\n-fn zip[T, U](v: &vec[T], u: &vec[U]) -> vec[{_0: T, _1: U}] {\n+fn zip[@T, @U](v: &vec[T], u: &vec[U]) -> vec[{_0: T, _1: U}] {\n     let sz = len(v);\n     assert (sz == len(u));\n     if sz == 0u {\n@@ -297,45 +298,45 @@ fn all[T](f: &fn(&T) -> bool , v: &vec[T]) -> bool {\n     ret true;\n }\n \n-fn clone[T](v: &vec[T]) -> vec[T] { ret slice[T](v, 0u, len[T](v)); }\n+fn clone[@T](v: &vec[T]) -> vec[T] { ret slice[T](v, 0u, len[T](v)); }\n \n-fn plus_option[T](v: &mutable vec[T], o: &option::t[T]) {\n+fn plus_option[@T](v: &mutable vec[T], o: &option::t[T]) {\n     alt o { none. { } some(x) { v += [x]; } }\n }\n \n-fn cat_options[T](v: &vec[option::t[T]]) -> vec[T] {\n+fn cat_options[@T](v: &vec[option::t[T]]) -> vec[T] {\n     let rs: vec[T] = [];\n     for o: option::t[T]  in v { alt o { none. { } some(t) { rs += [t]; } } }\n     ret rs;\n }\n \n \n // TODO: Remove in favor of built-in \"freeze\" operation when it's implemented.\n-fn freeze[T](v: vec[mutable T]) -> vec[T] {\n+fn freeze[@T](v: vec[mutable T]) -> vec[T] {\n     let result: vec[T] = [];\n     for elem: T  in v { result += [elem]; }\n     ret result;\n }\n \n \n // Swaps two elements in a vector\n-fn swap[T](v: &vec[mutable T], a: uint, b: uint) {\n+fn swap[@T](v: &vec[mutable T], a: uint, b: uint) {\n     let t: T = v.(a);\n     v.(a) = v.(b);\n     v.(b) = t;\n }\n \n \n // In place vector reversal\n-fn reverse[T](v: &vec[mutable T]) {\n+fn reverse[@T](v: &vec[mutable T]) {\n     let i: uint = 0u;\n     let ln = len[T](v);\n     while i < ln / 2u { swap(v, i, ln - i - 1u); i += 1u; }\n }\n \n \n // Functional vector reversal. Returns a reversed copy of v.\n-fn reversed[T](v: vec[T]) -> vec[T] {\n+fn reversed[@T](v: vec[T]) -> vec[T] {\n     let rs: vec[T] = [];\n     let i = len[T](v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n@@ -347,7 +348,7 @@ fn reversed[T](v: vec[T]) -> vec[T] {\n \n /// Truncates the vector to length `new_len`.\n /// FIXME: This relies on a typechecker bug (covariance vs. invariance).\n-fn truncate[T](v: &mutable vec[mutable? T], new_len: uint) {\n+fn truncate[@T](v: &mutable vec[mutable? T], new_len: uint) {\n     v = slice[T](v, 0u, new_len);\n }\n // Local Variables:"}, {"sha": "724ffc8b70d8bb8776e93146353f64c3413ce96f", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3c05b9faec1f2801b3c1987afb7c4059e175007/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=f3c05b9faec1f2801b3c1987afb7c4059e175007", "patch": "@@ -1,4 +1,4 @@\n-fn swap[T](v: &vec[mutable T], i: int, j: int) { v.(i) <-> v.(j); }\n+fn swap[@T](v: &vec[mutable T], i: int, j: int) { v.(i) <-> v.(j); }\n \n fn main() {\n     let a: vec[mutable int] = [mutable 0, 1, 2, 3, 4, 5, 6];"}]}