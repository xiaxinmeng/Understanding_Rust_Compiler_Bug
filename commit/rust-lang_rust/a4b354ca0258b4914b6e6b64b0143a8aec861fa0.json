{"sha": "a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0YjM1NGNhMDI1OGI0OTE0YjZlNmI2NGIwMTQzYThhZWM4NjFmYTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-07T03:48:25Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T18:30:15Z"}, "message": "core: Add binary_search and binary_search_elem methods to slices.\n\nThese are like the existing bsearch methods but if the search fails,\nit returns the next insertion point.\n\nThe new `binary_search` returns a `BinarySearchResult` that is either\n`Found` or `NotFound`. For convenience, the `found` and `not_found`\nmethods convert to `Option`, ala `Result`.\n\nDeprecate bsearch and bsearch_elem.", "tree": {"sha": "4054b1c1f9b69e42bcd90724b085998062a7dfcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4054b1c1f9b69e42bcd90724b085998062a7dfcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "html_url": "https://github.com/rust-lang/rust/commit/a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76d46af6d405ac29d2d508705eacdcffad63e4c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/76d46af6d405ac29d2d508705eacdcffad63e4c1", "html_url": "https://github.com/rust-lang/rust/commit/76d46af6d405ac29d2d508705eacdcffad63e4c1"}], "stats": {"total": 233, "additions": 186, "deletions": 47}, "files": [{"sha": "7663cd1e3466abb3d0bfb1ff5d67d455e8aa86f7", "filename": "src/etc/unicode.py", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "patch": "@@ -293,13 +293,12 @@ def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableVector;\n-    use core::option::None;\n-    r.bsearch(|&(lo,hi)| {\n+    use core::slice::ImmutableSlice;\n+    r.binary_search(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n         else { Greater }\n-    }) != None\n+    }).found().is_some()\n }\\n\n \"\"\")\n \n@@ -352,9 +351,10 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     f.write(\"pub mod conversions {\")\n     f.write(\"\"\"\n     use core::cmp::{Equal, Less, Greater};\n-    use core::slice::ImmutableVector;\n+    use core::slice::ImmutableSlice;\n     use core::tuple::Tuple2;\n     use core::option::{Option, Some, None};\n+    use core::slice;\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n@@ -371,11 +371,14 @@ def emit_conversions_module(f, lowerupper, upperlower):\n     }\n \n     fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n-        table.bsearch(|&(key, _)| {\n+        match table.binary_search(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n             else { Greater }\n-        })\n+        }) {\n+            slice::Found(i) => Some(i),\n+            slice::NotFound(_) => None,\n+        }\n     }\n \n \"\"\")\n@@ -387,8 +390,8 @@ def emit_conversions_module(f, lowerupper, upperlower):\n \n def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n     f.write(\"\"\"pub mod grapheme {\n-    use core::option::{Some, None};\n-    use core::slice::ImmutableVector;\n+    use core::slice::ImmutableSlice;\n+    use core::slice;\n \n     #[allow(non_camel_case_types)]\n     #[deriving(Clone)]\n@@ -400,16 +403,16 @@ def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n         use core::cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(lo, hi, _)| {\n+        match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, cat) = r[idx];\n                 cat\n             }\n-            None => GC_Any\n+            slice::NotFound(_) => GC_Any\n         }\n     }\n \n@@ -427,20 +430,21 @@ def emit_grapheme_module(f, grapheme_table, grapheme_cats):\n def emit_charwidth_module(f, width_table):\n     f.write(\"pub mod charwidth {\\n\")\n     f.write(\"    use core::option::{Option, Some, None};\\n\")\n-    f.write(\"    use core::slice::ImmutableVector;\\n\")\n+    f.write(\"    use core::slice::ImmutableSlice;\\n\")\n+    f.write(\"    use core::slice;\\n\")\n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n         use core::cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(lo, hi, _, _)| {\n+        match r.binary_search(|&(lo, hi, _, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, r_ncjk, r_cjk) = r[idx];\n                 if is_cjk { r_cjk } else { r_ncjk }\n             }\n-            None => 1\n+            slice::NotFound(_) => 1\n         }\n     }\n \"\"\")\n@@ -525,19 +529,19 @@ def comp_pfun(char):\n \n     f.write(\"\"\"\n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        use core::option::{Some, None};\n         use core::cmp::{Equal, Less, Greater};\n-        use core::slice::ImmutableVector;\n-        match r.bsearch(|&(lo, hi, _)| {\n+        use core::slice::ImmutableSlice;\n+        use core::slice;\n+        match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, result) = r[idx];\n                 result\n             }\n-            None => 0\n+            slice::NotFound(_) => 0\n         }\n     }\\n\n \"\"\")"}, {"sha": "aac5b24fa6f02e4bbba57ac5f3ab60af2ad65a1d", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "patch": "@@ -102,6 +102,7 @@ pub use core::slice::{Chunks, Slice, ImmutableSlice, ImmutablePartialEqSlice};\n pub use core::slice::{ImmutableOrdSlice, MutableSlice, Items, MutItems};\n pub use core::slice::{MutSplits, MutChunks};\n pub use core::slice::{bytes, MutableCloneableSlice};\n+pub use core::slice::{BinarySearchResult, Found, NotFound};\n \n // Functional utilities\n "}, {"sha": "4f6c346a4118dc4565c7e0930fee9eb4e220e75f", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "patch": "@@ -51,6 +51,7 @@ use raw::{Repr};\n // Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n use RawSlice = raw::Slice;\n \n+\n //\n // Extension traits\n //\n@@ -205,8 +206,25 @@ pub trait ImmutableSlice<'a, T> {\n      * Returns the index where the comparator returned `Equal`, or `None` if\n      * not found.\n      */\n+    #[deprecated = \"use binary_search\"]\n     fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n \n+    /**\n+     * Binary search a sorted vector with a comparator function.\n+     *\n+     * The comparator function should implement an order consistent\n+     * with the sort order of the underlying vector, returning an\n+     * order code that indicates whether its argument is `Less`,\n+     * `Equal` or `Greater` the desired target.\n+     *\n+     * If the value is found then `Found` is returned, containing the\n+     * index of the matching element; if the value is not found then\n+     * `NotFound` is returned, containing the index where a matching\n+     * element could be inserted while maintaining sorted order.\n+     */\n+    #[unstable]\n+    fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult;\n+\n     /**\n      * Returns an immutable reference to the first element in this slice\n      * and adjusts the slice in place so that it no longer contains\n@@ -377,6 +395,7 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n     }\n \n \n+    #[deprecated = \"use binary_search\"]\n     fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n         let mut base : uint = 0;\n         let mut lim : uint = self.len();\n@@ -396,6 +415,26 @@ impl<'a,T> ImmutableSlice<'a, T> for &'a [T] {\n         return None;\n     }\n \n+    #[unstable]\n+    fn binary_search(&self, f: |&T| -> Ordering) -> BinarySearchResult {\n+        let mut base : uint = 0;\n+        let mut lim : uint = self.len();\n+\n+        while lim != 0 {\n+            let ix = base + (lim >> 1);\n+            match f(&self[ix]) {\n+                Equal => return Found(ix),\n+                Less => {\n+                    base = ix + 1;\n+                    lim -= 1;\n+                }\n+                Greater => ()\n+            }\n+            lim >>= 1;\n+        }\n+        return NotFound(base);\n+    }\n+\n     fn shift_ref(&mut self) -> Option<&'a T> {\n         unsafe {\n             let s: &mut RawSlice<T> = transmute(self);\n@@ -826,13 +865,31 @@ pub trait ImmutableOrdSlice<T: Ord> {\n      *\n      * Returns the index of the element or None if not found.\n      */\n+    #[deprecated = \"use binary_search_elem\"]\n     fn bsearch_elem(&self, x: &T) -> Option<uint>;\n+\n+    /**\n+     * Binary search a sorted vector for a given element.\n+     *\n+     * If the value is found then `Found` is returned, containing the\n+     * index of the matching element; if the value is not found then\n+     * `NotFound` is returned, containing the index where a matching\n+     * element could be inserted while maintaining sorted order.\n+     */\n+    #[unstable]\n+    fn binary_search_elem(&self, x: &T) -> BinarySearchResult;\n }\n \n impl<'a, T: Ord> ImmutableOrdSlice<T> for &'a [T] {\n+    #[deprecated = \"use binary_search_elem\"]\n     fn bsearch_elem(&self, x: &T) -> Option<uint> {\n         self.bsearch(|p| p.cmp(x))\n     }\n+\n+    #[unstable]\n+    fn binary_search_elem(&self, x: &T) -> BinarySearchResult {\n+        self.binary_search(|p| p.cmp(x))\n+    }\n }\n \n /// Trait for &[T] where T is Cloneable\n@@ -1337,6 +1394,41 @@ impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n \n \n \n+/// The result of calling `binary_search`.\n+///\n+/// `Found` means the search succeeded, and the contained value is the\n+/// index of the matching element. `NotFound` means the search\n+/// succeeded, and the contained value is an index where a matching\n+/// value could be inserted while maintaining sort order.\n+#[deriving(PartialEq, Show)]\n+pub enum BinarySearchResult {\n+    /// The index of the found value.\n+    Found(uint),\n+    /// The index where the value should have been found.\n+    NotFound(uint)\n+}\n+\n+impl BinarySearchResult {\n+    /// Converts a `Found` to `Some`, `NotFound` to `None`.\n+    /// Similar to `Result::ok`.\n+    pub fn found(&self) -> Option<uint> {\n+        match *self {\n+            Found(i) => Some(i),\n+            NotFound(_) => None\n+        }\n+    }\n+\n+    /// Convert a `Found` to `None`, `NotFound` to `Some`.\n+    /// Similar to `Result::err`.\n+    pub fn not_found(&self) -> Option<uint> {\n+        match *self {\n+            Found(_) => None,\n+            NotFound(i) => Some(i)\n+        }\n+    }\n+}\n+\n+\n \n //\n // Free functions"}, {"sha": "3864321586ca67f643efbe9190c3c8dd8e6958ac", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "patch": "@@ -28,4 +28,5 @@ mod option;\n mod ptr;\n mod raw;\n mod result;\n+mod slice;\n mod tuple;"}, {"sha": "1288756dea4a5991e668aac6cd12680a8172f369", "filename": "src/libcoretest/slice.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::slice::{Found, NotFound};\n+\n+#[test]\n+fn binary_search_not_found() {\n+    let b = [1i, 2, 4, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    let b = [1i, 2, 4, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    let b = [1i, 2, 4, 6, 7, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&6)) == Found(3));\n+    let b = [1i, 2, 4, 6, 7, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&5)) == NotFound(3));\n+    let b = [1i, 2, 4, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&8)) == Found(4));\n+    let b = [1i, 2, 4, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(4));\n+    let b = [1i, 2, 4, 6, 7, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&8)) == Found(5));\n+    let b = [1i, 2, 4, 5, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&7)) == NotFound(5));\n+    let b = [1i, 2, 4, 5, 6, 8, 9];\n+    assert!(b.binary_search(|v| v.cmp(&0)) == NotFound(0));\n+    let b = [1i, 2, 4, 5, 6, 8];\n+    assert!(b.binary_search(|v| v.cmp(&9)) == NotFound(6));\n+}"}, {"sha": "6bf3e149066dc7fdcf176ac02b3f6561dcca6136", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "patch": "@@ -35,6 +35,7 @@\n \n use std::cmp;\n use std::mem;\n+use std::slice;\n use std::slice::MutableSlice;\n use compile::{\n     Program,\n@@ -222,8 +223,8 @@ impl<'r, 't> Nfa<'r, 't> {\n                     let negate = flags & FLAG_NEGATED > 0;\n                     let casei = flags & FLAG_NOCASE > 0;\n                     let found = ranges.as_slice();\n-                    let found = found.bsearch(|&rc| class_cmp(casei, c, rc));\n-                    let found = found.is_some();\n+                    let found = found.binary_search(|&rc| class_cmp(casei, c, rc))\n+                        .found().is_some();\n                     if found ^ negate {\n                         self.add(nlist, pc+1, caps);\n                     }\n@@ -513,15 +514,15 @@ pub fn is_word(c: Option<char>) -> bool {\n     // Try the common ASCII case before invoking binary search.\n     match c {\n         '_' | '0' .. '9' | 'a' .. 'z' | 'A' .. 'Z' => true,\n-        _ => PERLW.bsearch(|&(start, end)| {\n+        _ => PERLW.binary_search(|&(start, end)| {\n             if c >= start && c <= end {\n                 Equal\n             } else if start > c {\n                 Greater\n             } else {\n                 Less\n             }\n-        }).is_some()\n+        }).found().is_some()\n     }\n }\n "}, {"sha": "a60e95c38272bf4f08c071587cc23a7a99a991d9", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "patch": "@@ -15,20 +15,21 @@\n \n use core::cmp::{Equal, Less, Greater};\n use core::option::{Option, Some, None};\n+use core::slice;\n use core::slice::ImmutableSlice;\n use tables::normalization::{canonical_table, compatibility_table, composition_table};\n \n fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'static [T]> {\n-    match r.bsearch(|&(val, _)| {\n+    match r.binary_search(|&(val, _)| {\n         if c == val { Equal }\n         else if val < c { Less }\n         else { Greater }\n     }) {\n-        Some(idx) => {\n+        slice::Found(idx) => {\n             let (_, result) = r[idx];\n             Some(result)\n         }\n-        None => None\n+        slice::NotFound(_) => None\n     }\n }\n \n@@ -82,16 +83,16 @@ pub fn compose(a: char, b: char) -> Option<char> {\n         match bsearch_table(a, composition_table) {\n             None => None,\n             Some(candidates) => {\n-                match candidates.bsearch(|&(val, _)| {\n+                match candidates.binary_search(|&(val, _)| {\n                     if b == val { Equal }\n                     else if val < b { Less }\n                     else { Greater }\n                 }) {\n-                    Some(idx) => {\n+                    slice::Found(idx) => {\n                         let (_, result) = candidates[idx];\n                         Some(result)\n                     }\n-                    None => None\n+                    slice::NotFound(_) => None\n                 }\n             }\n         }"}, {"sha": "d6010cd8d7bfbbd467664ccb9b1c237e2d44cf1e", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4b354ca0258b4914b6e6b64b0143a8aec861fa0/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=a4b354ca0258b4914b6e6b64b0143a8aec861fa0", "patch": "@@ -15,12 +15,11 @@\n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::{Equal, Less, Greater};\n     use core::slice::ImmutableSlice;\n-    use core::option::None;\n-    r.bsearch(|&(lo,hi)| {\n+    r.binary_search(|&(lo,hi)| {\n         if lo <= c && c <= hi { Equal }\n         else if hi < c { Less }\n         else { Greater }\n-    }) != None\n+    }).found().is_some()\n }\n \n pub mod general_category {\n@@ -6228,19 +6227,19 @@ pub mod normalization {\n \n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, u8)]) -> u8 {\n-        use core::option::{Some, None};\n         use core::cmp::{Equal, Less, Greater};\n         use core::slice::ImmutableSlice;\n-        match r.bsearch(|&(lo, hi, _)| {\n+        use core::slice;\n+        match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, result) = r[idx];\n                 result\n             }\n-            None => 0\n+            slice::NotFound(_) => 0\n         }\n     }\n \n@@ -6357,6 +6356,7 @@ pub mod conversions {\n     use core::slice::ImmutableSlice;\n     use core::tuple::Tuple2;\n     use core::option::{Option, Some, None};\n+    use core::slice;\n \n     pub fn to_lower(c: char) -> char {\n         match bsearch_case_table(c, LuLl_table) {\n@@ -6373,11 +6373,14 @@ pub mod conversions {\n     }\n \n     fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n-        table.bsearch(|&(key, _)| {\n+        match table.binary_search(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n             else { Greater }\n-        })\n+        }) {\n+            slice::Found(i) => Some(i),\n+            slice::NotFound(_) => None,\n+        }\n     }\n \n     static LuLl_table: &'static [(char, char)] = &[\n@@ -6916,19 +6919,20 @@ pub mod conversions {\n pub mod charwidth {\n     use core::option::{Option, Some, None};\n     use core::slice::ImmutableSlice;\n+    use core::slice;\n \n     fn bsearch_range_value_table(c: char, is_cjk: bool, r: &'static [(char, char, u8, u8)]) -> u8 {\n         use core::cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(lo, hi, _, _)| {\n+        match r.binary_search(|&(lo, hi, _, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, r_ncjk, r_cjk) = r[idx];\n                 if is_cjk { r_cjk } else { r_ncjk }\n             }\n-            None => 1\n+            slice::NotFound(_) => 1\n         }\n     }\n \n@@ -7112,8 +7116,8 @@ pub mod charwidth {\n }\n \n pub mod grapheme {\n-    use core::option::{Some, None};\n     use core::slice::ImmutableSlice;\n+    use core::slice;\n \n     #[allow(non_camel_case_types)]\n     #[deriving(Clone)]\n@@ -7132,16 +7136,16 @@ pub mod grapheme {\n \n     fn bsearch_range_value_table(c: char, r: &'static [(char, char, GraphemeCat)]) -> GraphemeCat {\n         use core::cmp::{Equal, Less, Greater};\n-        match r.bsearch(|&(lo, hi, _)| {\n+        match r.binary_search(|&(lo, hi, _)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n         }) {\n-            Some(idx) => {\n+            slice::Found(idx) => {\n                 let (_, _, cat) = r[idx];\n                 cat\n             }\n-            None => GC_Any\n+            slice::NotFound(_) => GC_Any\n         }\n     }\n "}]}