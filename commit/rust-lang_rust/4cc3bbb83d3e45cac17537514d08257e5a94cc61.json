{"sha": "4cc3bbb83d3e45cac17537514d08257e5a94cc61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYzNiYmI4M2QzZTQ1Y2FjMTc1Mzc1MTRkMDgyNTdlNWE5NGNjNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-28T22:46:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-28T22:46:37Z"}, "message": "auto merge of #8095 : jmgrosen/rust/no-iterator-prefixes, r=pcwalton\n\nResolves #8093", "tree": {"sha": "06847a2011422228a2e2d77abf56bed38681d4de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/06847a2011422228a2e2d77abf56bed38681d4de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cc3bbb83d3e45cac17537514d08257e5a94cc61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cc3bbb83d3e45cac17537514d08257e5a94cc61", "html_url": "https://github.com/rust-lang/rust/commit/4cc3bbb83d3e45cac17537514d08257e5a94cc61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cc3bbb83d3e45cac17537514d08257e5a94cc61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6dc5e2c61f828aeeb2eeffbb235938edbe18c809", "url": "https://api.github.com/repos/rust-lang/rust/commits/6dc5e2c61f828aeeb2eeffbb235938edbe18c809", "html_url": "https://github.com/rust-lang/rust/commit/6dc5e2c61f828aeeb2eeffbb235938edbe18c809"}, {"sha": "a0f0f3012eb785063b2dff467b66d28e76d43feb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f0f3012eb785063b2dff467b66d28e76d43feb", "html_url": "https://github.com/rust-lang/rust/commit/a0f0f3012eb785063b2dff467b66d28e76d43feb"}], "stats": {"total": 179, "additions": 90, "deletions": 89}, "files": [{"sha": "92a120592ffdc0c4240653cff3b6d5889803ae32", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4cc3bbb83d3e45cac17537514d08257e5a94cc61/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc3bbb83d3e45cac17537514d08257e5a94cc61/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=4cc3bbb83d3e45cac17537514d08257e5a94cc61", "patch": "@@ -18,7 +18,8 @@\n use std::iterator::{Iterator, IteratorUtil, EnumerateIterator, FilterMapIterator, InvertIterator};\n use std::uint;\n use std::util::replace;\n-use std::vec::{VecIterator, VecMutIterator, VecConsumeIterator};\n+use std::vec::{VecIterator, VecMutIterator};\n+use std::vec;\n \n #[allow(missing_doc)]\n pub struct SmallIntMap<T> {\n@@ -204,7 +205,7 @@ impl<V> SmallIntMap<V> {\n     /// Empties the hash map, moving all values into the specified closure\n     pub fn consume(&mut self)\n         -> FilterMapIterator<(uint, Option<V>), (uint, V),\n-                EnumerateIterator<VecConsumeIterator<Option<V>>>>\n+                EnumerateIterator<vec::ConsumeIterator<Option<V>>>>\n     {\n         let values = replace(&mut self.v, ~[]);\n         values.consume_iter().enumerate().filter_map(|(i, v)| {"}, {"sha": "d78d0cd8e639d16dbacb902695ea52f193307b13", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4cc3bbb83d3e45cac17537514d08257e5a94cc61/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc3bbb83d3e45cac17537514d08257e5a94cc61/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=4cc3bbb83d3e45cac17537514d08257e5a94cc61", "patch": "@@ -538,7 +538,7 @@ pub struct HashMapMutIterator<'self, K, V> {\n \n /// HashMap consume iterator\n pub struct HashMapConsumeIterator<K, V> {\n-    priv iter: vec::VecConsumeRevIterator<Option<Bucket<K, V>>>,\n+    priv iter: vec::ConsumeRevIterator<Option<Bucket<K, V>>>,\n }\n \n /// HashSet iterator\n@@ -549,7 +549,7 @@ pub struct HashSetIterator<'self, K> {\n \n /// HashSet consume iterator\n pub struct HashSetConsumeIterator<K> {\n-    priv iter: vec::VecConsumeRevIterator<Option<Bucket<K, ()>>>,\n+    priv iter: vec::ConsumeRevIterator<Option<Bucket<K, ()>>>,\n }\n \n impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V> {"}, {"sha": "cbd1e47b29b0ed8cbbf09a31d982fe14317d1a3d", "filename": "src/libstd/str.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4cc3bbb83d3e45cac17537514d08257e5a94cc61/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc3bbb83d3e45cac17537514d08257e5a94cc61/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=4cc3bbb83d3e45cac17537514d08257e5a94cc61", "patch": "@@ -281,7 +281,7 @@ impl<'self, C: CharEq> CharEq for &'self [C] {\n \n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n-pub struct StrCharSplitIterator<'self,Sep> {\n+pub struct CharSplitIterator<'self,Sep> {\n     priv string: &'self str,\n     priv position: uint,\n     priv sep: Sep,\n@@ -296,13 +296,13 @@ pub struct StrCharSplitIterator<'self,Sep> {\n /// An iterator over the words of a string, separated by an sequence of whitespace\n pub type WordIterator<'self> =\n     FilterIterator<'self, &'self str,\n-             StrCharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n+             CharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n \n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n pub type AnyLineIterator<'self> =\n-    MapIterator<'self, &'self str, &'self str, StrCharSplitIterator<'self, char>>;\n+    MapIterator<'self, &'self str, &'self str, CharSplitIterator<'self, char>>;\n \n-impl<'self, Sep: CharEq> Iterator<&'self str> for StrCharSplitIterator<'self, Sep> {\n+impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitIterator<'self, Sep> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self str> {\n         if self.finished { return None }\n@@ -349,7 +349,7 @@ impl<'self, Sep: CharEq> Iterator<&'self str> for StrCharSplitIterator<'self, Se\n /// An iterator over the start and end indicies of the matches of a\n /// substring within a larger string\n #[deriving(Clone)]\n-pub struct StrMatchesIndexIterator<'self> {\n+pub struct MatchesIndexIterator<'self> {\n     priv haystack: &'self str,\n     priv needle: &'self str,\n     priv position: uint,\n@@ -358,13 +358,13 @@ pub struct StrMatchesIndexIterator<'self> {\n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[deriving(Clone)]\n-pub struct StrStrSplitIterator<'self> {\n-    priv it: StrMatchesIndexIterator<'self>,\n+pub struct StrSplitIterator<'self> {\n+    priv it: MatchesIndexIterator<'self>,\n     priv last_end: uint,\n     priv finished: bool\n }\n \n-impl<'self> Iterator<(uint, uint)> for StrMatchesIndexIterator<'self> {\n+impl<'self> Iterator<(uint, uint)> for MatchesIndexIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n         // See Issue #1932 for why this is a naive search\n@@ -395,7 +395,7 @@ impl<'self> Iterator<(uint, uint)> for StrMatchesIndexIterator<'self> {\n     }\n }\n \n-impl<'self> Iterator<&'self str> for StrStrSplitIterator<'self> {\n+impl<'self> Iterator<&'self str> for StrSplitIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<&'self str> {\n         if self.finished { return None; }\n@@ -1126,17 +1126,17 @@ impl Mutable for ~str {\n pub trait StrSlice<'self> {\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n-    fn iter(&self) -> StrCharIterator<'self>;\n-    fn rev_iter(&self) -> StrCharRevIterator<'self>;\n-    fn bytes_iter(&self) -> StrBytesIterator<'self>;\n-    fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self>;\n-    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> StrCharSplitIterator<'self, Sep>;\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> StrCharSplitIterator<'self, Sep>;\n+    fn iter(&self) -> CharIterator<'self>;\n+    fn rev_iter(&self) -> CharRevIterator<'self>;\n+    fn bytes_iter(&self) -> BytesIterator<'self>;\n+    fn bytes_rev_iter(&self) -> BytesRevIterator<'self>;\n+    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitIterator<'self, Sep>;\n     fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n-        -> StrCharSplitIterator<'self, Sep>;\n-    fn matches_index_iter(&self, sep: &'self str) -> StrMatchesIndexIterator<'self>;\n-    fn split_str_iter(&self, &'self str) -> StrStrSplitIterator<'self>;\n-    fn line_iter(&self) -> StrCharSplitIterator<'self, char>;\n+        -> CharSplitIterator<'self, Sep>;\n+    fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self>;\n+    fn split_str_iter(&self, &'self str) -> StrSplitIterator<'self>;\n+    fn line_iter(&self) -> CharSplitIterator<'self, char>;\n     fn any_line_iter(&self) -> AnyLineIterator<'self>;\n     fn word_iter(&self) -> WordIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n@@ -1222,30 +1222,30 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ~~~\n     #[inline]\n-    fn iter(&self) -> StrCharIterator<'self> {\n-        StrCharIterator {\n+    fn iter(&self) -> CharIterator<'self> {\n+        CharIterator {\n             index: 0,\n             string: *self\n         }\n     }\n     /// An iterator over the characters of `self`, in reverse order.\n     #[inline]\n-    fn rev_iter(&self) -> StrCharRevIterator<'self> {\n-        StrCharRevIterator {\n+    fn rev_iter(&self) -> CharRevIterator<'self> {\n+        CharRevIterator {\n             index: self.len(),\n             string: *self\n         }\n     }\n \n     /// An iterator over the bytes of `self`\n     #[inline]\n-    fn bytes_iter(&self) -> StrBytesIterator<'self> {\n-        StrBytesIterator { it: self.as_bytes().iter() }\n+    fn bytes_iter(&self) -> BytesIterator<'self> {\n+        BytesIterator { it: self.as_bytes().iter() }\n     }\n     /// An iterator over the bytes of `self`, in reverse order\n     #[inline]\n-    fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self> {\n-        StrBytesRevIterator { it: self.as_bytes().rev_iter() }\n+    fn bytes_rev_iter(&self) -> BytesRevIterator<'self> {\n+        BytesRevIterator { it: self.as_bytes().rev_iter() }\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -1261,15 +1261,15 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n     /// ~~~\n     #[inline]\n-    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> StrCharSplitIterator<'self, Sep> {\n+    fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep> {\n         self.split_options_iter(sep, self.len(), true)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, restricted to splitting at most `count`\n     /// times.\n     #[inline]\n-    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> StrCharSplitIterator<'self, Sep> {\n+    fn splitn_iter<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitIterator<'self, Sep> {\n         self.split_options_iter(sep, count, true)\n     }\n \n@@ -1279,9 +1279,9 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// exists.\n     #[inline]\n     fn split_options_iter<Sep: CharEq>(&self, sep: Sep, count: uint, allow_trailing_empty: bool)\n-        -> StrCharSplitIterator<'self, Sep> {\n+        -> CharSplitIterator<'self, Sep> {\n         let only_ascii = sep.only_ascii();\n-        StrCharSplitIterator {\n+        CharSplitIterator {\n             string: *self,\n             position: 0,\n             sep: sep,\n@@ -1294,9 +1294,9 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// An iterator over the start and end indices of each match of\n     /// `sep` within `self`.\n     #[inline]\n-    fn matches_index_iter(&self, sep: &'self str) -> StrMatchesIndexIterator<'self> {\n+    fn matches_index_iter(&self, sep: &'self str) -> MatchesIndexIterator<'self> {\n         assert!(!sep.is_empty())\n-        StrMatchesIndexIterator {\n+        MatchesIndexIterator {\n             haystack: *self,\n             needle: sep,\n             position: 0\n@@ -1313,8 +1313,8 @@ impl<'self> StrSlice<'self> for &'self str {\n      * ~~~\n      */\n     #[inline]\n-    fn split_str_iter(&self, sep: &'self str) -> StrStrSplitIterator<'self> {\n-        StrStrSplitIterator {\n+    fn split_str_iter(&self, sep: &'self str) -> StrSplitIterator<'self> {\n+        StrSplitIterator {\n             it: self.matches_index_iter(sep),\n             last_end: 0,\n             finished: false\n@@ -1324,7 +1324,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// An iterator over the lines of a string (subsequences separated\n     /// by `\\n`).\n     #[inline]\n-    fn line_iter(&self) -> StrCharSplitIterator<'self, char> {\n+    fn line_iter(&self) -> CharSplitIterator<'self, char> {\n         self.split_options_iter('\\n', self.len(), false)\n     }\n \n@@ -2253,12 +2253,12 @@ impl Clone for @str {\n /// External iterator for a string's characters. Use with the `std::iterator`\n /// module.\n #[deriving(Clone)]\n-pub struct StrCharIterator<'self> {\n+pub struct CharIterator<'self> {\n     priv index: uint,\n     priv string: &'self str,\n }\n \n-impl<'self> Iterator<char> for StrCharIterator<'self> {\n+impl<'self> Iterator<char> for CharIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         if self.index < self.string.len() {\n@@ -2273,12 +2273,12 @@ impl<'self> Iterator<char> for StrCharIterator<'self> {\n /// External iterator for a string's characters in reverse order. Use\n /// with the `std::iterator` module.\n #[deriving(Clone)]\n-pub struct StrCharRevIterator<'self> {\n+pub struct CharRevIterator<'self> {\n     priv index: uint,\n     priv string: &'self str,\n }\n \n-impl<'self> Iterator<char> for StrCharRevIterator<'self> {\n+impl<'self> Iterator<char> for CharRevIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         if self.index > 0 {\n@@ -2294,11 +2294,11 @@ impl<'self> Iterator<char> for StrCharRevIterator<'self> {\n /// External iterator for a string's bytes. Use with the `std::iterator`\n /// module.\n #[deriving(Clone)]\n-pub struct StrBytesIterator<'self> {\n+pub struct BytesIterator<'self> {\n     priv it: vec::VecIterator<'self, u8>\n }\n \n-impl<'self> Iterator<u8> for StrBytesIterator<'self> {\n+impl<'self> Iterator<u8> for BytesIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<u8> {\n         self.it.next().map_consume(|&x| x)\n@@ -2308,11 +2308,11 @@ impl<'self> Iterator<u8> for StrBytesIterator<'self> {\n /// External iterator for a string's bytes in reverse order. Use with\n /// the `std::iterator` module.\n #[deriving(Clone)]\n-pub struct StrBytesRevIterator<'self> {\n-    priv it: vec::VecRevIterator<'self, u8>\n+pub struct BytesRevIterator<'self> {\n+    priv it: vec::RevIterator<'self, u8>\n }\n \n-impl<'self> Iterator<u8> for StrBytesRevIterator<'self> {\n+impl<'self> Iterator<u8> for BytesRevIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<u8> {\n         self.it.next().map_consume(|&x| x)"}, {"sha": "7c25d0911949fb0e6533cc9260b3196ff15f2c78", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4cc3bbb83d3e45cac17537514d08257e5a94cc61/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc3bbb83d3e45cac17537514d08257e5a94cc61/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=4cc3bbb83d3e45cac17537514d08257e5a94cc61", "patch": "@@ -157,14 +157,14 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function.\n-pub struct VecSplitIterator<'self, T> {\n+pub struct SplitIterator<'self, T> {\n     priv v: &'self [T],\n     priv n: uint,\n     priv pred: &'self fn(t: &T) -> bool,\n     priv finished: bool\n }\n \n-impl<'self, T> Iterator<&'self [T]> for VecSplitIterator<'self, T> {\n+impl<'self, T> Iterator<&'self [T]> for SplitIterator<'self, T> {\n     fn next(&mut self) -> Option<&'self [T]> {\n         if self.finished { return None; }\n \n@@ -190,14 +190,14 @@ impl<'self, T> Iterator<&'self [T]> for VecSplitIterator<'self, T> {\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function, from back to front.\n-pub struct VecRSplitIterator<'self, T> {\n+pub struct RSplitIterator<'self, T> {\n     priv v: &'self [T],\n     priv n: uint,\n     priv pred: &'self fn(t: &T) -> bool,\n     priv finished: bool\n }\n \n-impl<'self, T> Iterator<&'self [T]> for VecRSplitIterator<'self, T> {\n+impl<'self, T> Iterator<&'self [T]> for RSplitIterator<'self, T> {\n     fn next(&mut self) -> Option<&'self [T]> {\n         if self.finished { return None; }\n \n@@ -435,12 +435,12 @@ pub fn each_permutation<T:Clone>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n \n /// An iterator over the (overlapping) slices of length `size` within\n /// a vector.\n-pub struct VecWindowIter<'self, T> {\n+pub struct WindowIter<'self, T> {\n     priv v: &'self [T],\n     priv size: uint\n }\n \n-impl<'self, T> Iterator<&'self [T]> for VecWindowIter<'self, T> {\n+impl<'self, T> Iterator<&'self [T]> for WindowIter<'self, T> {\n     fn next(&mut self) -> Option<&'self [T]> {\n         if self.size > self.v.len() {\n             None\n@@ -454,12 +454,12 @@ impl<'self, T> Iterator<&'self [T]> for VecWindowIter<'self, T> {\n \n /// An iterator over a vector in (non-overlapping) chunks (`size`\n /// elements at a time).\n-pub struct VecChunkIter<'self, T> {\n+pub struct ChunkIter<'self, T> {\n     priv v: &'self [T],\n     priv size: uint\n }\n \n-impl<'self, T> Iterator<&'self [T]> for VecChunkIter<'self, T> {\n+impl<'self, T> Iterator<&'self [T]> for ChunkIter<'self, T> {\n     fn next(&mut self) -> Option<&'self [T]> {\n         if self.size == 0 {\n             None\n@@ -691,14 +691,14 @@ pub trait ImmutableVector<'self, T> {\n     fn slice_from(&self, start: uint) -> &'self [T];\n     fn slice_to(&self, end: uint) -> &'self [T];\n     fn iter(self) -> VecIterator<'self, T>;\n-    fn rev_iter(self) -> VecRevIterator<'self, T>;\n-    fn split_iter(self, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T>;\n-    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T>;\n-    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T>;\n-    fn rsplitn_iter(self,  n: uint, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T>;\n+    fn rev_iter(self) -> RevIterator<'self, T>;\n+    fn split_iter(self, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T>;\n+    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T>;\n+    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T>;\n+    fn rsplitn_iter(self,  n: uint, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T>;\n \n-    fn window_iter(self, size: uint) -> VecWindowIter<'self, T>;\n-    fn chunk_iter(self, size: uint) -> VecChunkIter<'self, T>;\n+    fn window_iter(self, size: uint) -> WindowIter<'self, T>;\n+    fn chunk_iter(self, size: uint) -> ChunkIter<'self, T>;\n \n     fn head(&self) -> &'self T;\n     fn head_opt(&self) -> Option<&'self T>;\n@@ -774,22 +774,22 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n-    fn rev_iter(self) -> VecRevIterator<'self, T> {\n+    fn rev_iter(self) -> RevIterator<'self, T> {\n         self.iter().invert()\n     }\n \n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`.\n     #[inline]\n-    fn split_iter(self, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T> {\n+    fn split_iter(self, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T> {\n         self.splitn_iter(uint::max_value, pred)\n     }\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`, limited to splitting\n     /// at most `n` times.\n     #[inline]\n-    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecSplitIterator<'self, T> {\n-        VecSplitIterator {\n+    fn splitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> SplitIterator<'self, T> {\n+        SplitIterator {\n             v: self,\n             n: n,\n             pred: pred,\n@@ -800,16 +800,16 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     /// separated by elements that match `pred`. This starts at the\n     /// end of the vector and works backwards.\n     #[inline]\n-    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T> {\n+    fn rsplit_iter(self, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T> {\n         self.rsplitn_iter(uint::max_value, pred)\n     }\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n     /// at most `n` times. This starts at the end of the vector and\n     /// works backwards.\n     #[inline]\n-    fn rsplitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> VecRSplitIterator<'self, T> {\n-        VecRSplitIterator {\n+    fn rsplitn_iter(self, n: uint, pred: &'self fn(&T) -> bool) -> RSplitIterator<'self, T> {\n+        RSplitIterator {\n             v: self,\n             n: n,\n             pred: pred,\n@@ -839,9 +839,9 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      * ~~~\n      *\n      */\n-    fn window_iter(self, size: uint) -> VecWindowIter<'self, T> {\n+    fn window_iter(self, size: uint) -> WindowIter<'self, T> {\n         assert!(size != 0);\n-        VecWindowIter { v: self, size: size }\n+        WindowIter { v: self, size: size }\n     }\n \n     /**\n@@ -868,9 +868,9 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      * ~~~\n      *\n      */\n-    fn chunk_iter(self, size: uint) -> VecChunkIter<'self, T> {\n+    fn chunk_iter(self, size: uint) -> ChunkIter<'self, T> {\n         assert!(size != 0);\n-        VecChunkIter { v: self, size: size }\n+        ChunkIter { v: self, size: size }\n     }\n \n     /// Returns the first element of a vector, failing if the vector is empty.\n@@ -1086,8 +1086,8 @@ impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n \n #[allow(missing_doc)]\n pub trait OwnedVector<T> {\n-    fn consume_iter(self) -> VecConsumeIterator<T>;\n-    fn consume_rev_iter(self) -> VecConsumeRevIterator<T>;\n+    fn consume_iter(self) -> ConsumeIterator<T>;\n+    fn consume_rev_iter(self) -> ConsumeRevIterator<T>;\n \n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n@@ -1128,14 +1128,14 @@ impl<T> OwnedVector<T> for ~[T] {\n     ///   println(s);\n     /// }\n     /// ~~~\n-    fn consume_iter(self) -> VecConsumeIterator<T> {\n-        VecConsumeIterator { v: self, idx: 0 }\n+    fn consume_iter(self) -> ConsumeIterator<T> {\n+        ConsumeIterator { v: self, idx: 0 }\n     }\n     /// Creates a consuming iterator that moves out of the vector in\n     /// reverse order. Also see `consume_iter`, however note that this\n     /// is more efficient.\n-    fn consume_rev_iter(self) -> VecConsumeRevIterator<T> {\n-        VecConsumeRevIterator { v: self }\n+    fn consume_rev_iter(self) -> ConsumeRevIterator<T> {\n+        ConsumeRevIterator { v: self }\n     }\n \n     /**\n@@ -1657,7 +1657,7 @@ pub trait MutableVector<'self, T> {\n     fn mut_slice_from(self, start: uint) -> &'self mut [T];\n     fn mut_slice_to(self, end: uint) -> &'self mut [T];\n     fn mut_iter(self) -> VecMutIterator<'self, T>;\n-    fn mut_rev_iter(self) -> VecMutRevIterator<'self, T>;\n+    fn mut_rev_iter(self) -> MutRevIterator<'self, T>;\n \n     fn swap(self, a: uint, b: uint);\n \n@@ -1751,7 +1751,7 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n \n     #[inline]\n-    fn mut_rev_iter(self) -> VecMutRevIterator<'self, T> {\n+    fn mut_rev_iter(self) -> MutRevIterator<'self, T> {\n         self.mut_iter().invert()\n     }\n \n@@ -2166,7 +2166,7 @@ pub struct VecIterator<'self, T> {\n iterator!{impl VecIterator -> &'self T}\n double_ended_iterator!{impl VecIterator -> &'self T}\n random_access_iterator!{impl VecIterator -> &'self T}\n-pub type VecRevIterator<'self, T> = InvertIterator<VecIterator<'self, T>>;\n+pub type RevIterator<'self, T> = InvertIterator<VecIterator<'self, T>>;\n \n impl<'self, T> Clone for VecIterator<'self, T> {\n     fn clone(&self) -> VecIterator<'self, T> { *self }\n@@ -2182,16 +2182,16 @@ pub struct VecMutIterator<'self, T> {\n iterator!{impl VecMutIterator -> &'self mut T}\n double_ended_iterator!{impl VecMutIterator -> &'self mut T}\n random_access_iterator!{impl VecMutIterator -> &'self mut T}\n-pub type VecMutRevIterator<'self, T> = InvertIterator<VecMutIterator<'self, T>>;\n+pub type MutRevIterator<'self, T> = InvertIterator<VecMutIterator<'self, T>>;\n \n /// An iterator that moves out of a vector.\n #[deriving(Clone)]\n-pub struct VecConsumeIterator<T> {\n+pub struct ConsumeIterator<T> {\n     priv v: ~[T],\n     priv idx: uint,\n }\n \n-impl<T> Iterator<T> for VecConsumeIterator<T> {\n+impl<T> Iterator<T> for ConsumeIterator<T> {\n     fn next(&mut self) -> Option<T> {\n         // this is peculiar, but is required for safety with respect\n         // to dtors. It traverses the first half of the vec, and\n@@ -2213,11 +2213,11 @@ impl<T> Iterator<T> for VecConsumeIterator<T> {\n \n /// An iterator that moves out of a vector in reverse order.\n #[deriving(Clone)]\n-pub struct VecConsumeRevIterator<T> {\n+pub struct ConsumeRevIterator<T> {\n     priv v: ~[T]\n }\n \n-impl<T> Iterator<T> for VecConsumeRevIterator<T> {\n+impl<T> Iterator<T> for ConsumeRevIterator<T> {\n     fn next(&mut self) -> Option<T> {\n         self.v.pop_opt()\n     }"}]}