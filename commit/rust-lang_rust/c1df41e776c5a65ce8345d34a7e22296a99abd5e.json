{"sha": "c1df41e776c5a65ce8345d34a7e22296a99abd5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZGY0MWU3NzZjNWE2NWNlODM0NWQzNGE3ZTIyMjk2YTk5YWJkNWU=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-12-30T23:57:49Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2016-03-14T22:04:39Z"}, "message": "Add some basic comments about how specialization fits into the rest of the trait machinery", "tree": {"sha": "66a6d269c8129db180ba3593a19adfce27b64abe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66a6d269c8129db180ba3593a19adfce27b64abe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1df41e776c5a65ce8345d34a7e22296a99abd5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1df41e776c5a65ce8345d34a7e22296a99abd5e", "html_url": "https://github.com/rust-lang/rust/commit/c1df41e776c5a65ce8345d34a7e22296a99abd5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1df41e776c5a65ce8345d34a7e22296a99abd5e/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed8d059d8d49491b736ea88edd8f2b57a866c44a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed8d059d8d49491b736ea88edd8f2b57a866c44a", "html_url": "https://github.com/rust-lang/rust/commit/ed8d059d8d49491b736ea88edd8f2b57a866c44a"}], "stats": {"total": 43, "additions": 43, "deletions": 0}, "files": [{"sha": "ff72f9dd07e36096819e2244644099a136cc63c4", "filename": "src/librustc/middle/traits/README.md", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c1df41e776c5a65ce8345d34a7e22296a99abd5e/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c1df41e776c5a65ce8345d34a7e22296a99abd5e/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md?ref=c1df41e776c5a65ce8345d34a7e22296a99abd5e", "patch": "@@ -428,3 +428,43 @@ We used to try and draw finer-grained distinctions, but that led to a\n serious of annoying and weird bugs like #22019 and #18290. This simple\n rule seems to be pretty clearly safe and also still retains a very\n high hit rate (~95% when compiling rustc).\n+\n+# Specialization\n+\n+Defined in the `specialize` module.\n+\n+The basic strategy is to build up a *specialization graph* during\n+coherence checking. Insertion into the graph locates the right place\n+to put an impl in the specialization hierarchy; if there is no right\n+place (due to partial overlap but no containment), you get an overlap\n+error. Specialization is consulted when selecting an impl (of course),\n+and the graph is consulted when propagating defaults down the\n+specialization hierarchy.\n+\n+You might expect that the specialization graph would be used during\n+selection -- i.e., when actually performing specialization. This is\n+not done for two reasons:\n+\n+- It's merely an optimization: given a set of candidates that apply,\n+  we can determine the most specialized one by comparing them directly\n+  for specialization, rather than consulting the graph. Given that we\n+  also cache the results of selection, the benefit of this\n+  optimization is questionable.\n+\n+- To build the specialization graph in the first place, we need to use\n+  selection (because we need to determine whether one impl specializes\n+  another). Dealing with this reentrancy would require some additional\n+  mode switch for selection. Given that there seems to be no strong\n+  reason to use the graph anyway, we stick with a simpler approach in\n+  selection, and use the graph only for propagating default\n+  implementations.\n+\n+Trait impl selection can succeed even when multiple impls can apply,\n+as long as they are part of the same specialization family. In that\n+case, it returns a *single* impl on success -- this is the most\n+specialized impl *known* to apply. However, if there are any inference\n+variables in play, the returned impl may not be the actual impl we\n+will use at trans time. Thus, we take special care to avoid projecting\n+associated types unless either (1) the associated type does not use\n+`default` and thus cannot be overridden or (2) all input types are\n+known concretely."}, {"sha": "30897e9289d9bca17ca9ad00a220204cfc0aa88e", "filename": "src/librustc/middle/traits/specialize.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c1df41e776c5a65ce8345d34a7e22296a99abd5e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1df41e776c5a65ce8345d34a7e22296a99abd5e/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fspecialize.rs?ref=c1df41e776c5a65ce8345d34a7e22296a99abd5e", "patch": "@@ -13,6 +13,9 @@\n //\n // At the moment, this implementation support only the simple \"chain\" rule:\n // If any two impls overlap, one must be a strict subset of the other.\n+//\n+// See traits/README.md for a bit more detail on how specialization\n+// fits together with the rest of the trait machinery.\n \n use super::util;\n use super::SelectionContext;"}]}