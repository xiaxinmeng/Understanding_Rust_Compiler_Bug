{"sha": "5f0d724e298ee4e19bef4e863c176dd87ef6400f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMGQ3MjRlMjk4ZWU0ZTE5YmVmNGU4NjNjMTc2ZGQ4N2VmNjQwMGY=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-04T08:46:47Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2020-09-26T05:20:51Z"}, "message": "Move str's impl of iterations to new mod", "tree": {"sha": "10bc74dfc966daa6f9126fabd19b5effc874d535", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10bc74dfc966daa6f9126fabd19b5effc874d535"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f0d724e298ee4e19bef4e863c176dd87ef6400f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f0d724e298ee4e19bef4e863c176dd87ef6400f", "html_url": "https://github.com/rust-lang/rust/commit/5f0d724e298ee4e19bef4e863c176dd87ef6400f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f0d724e298ee4e19bef4e863c176dd87ef6400f/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b533fccf39501bd5ca8a436da6f2d8b5999664d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b533fccf39501bd5ca8a436da6f2d8b5999664d", "html_url": "https://github.com/rust-lang/rust/commit/5b533fccf39501bd5ca8a436da6f2d8b5999664d"}], "stats": {"total": 2690, "additions": 1368, "deletions": 1322}, "files": [{"sha": "993df96a2d1a67b3d6a4758b648f1b9b582b7c8a", "filename": "library/core/src/str/iter.rs", "status": "added", "additions": 1255, "deletions": 0, "changes": 1255, "blob_url": "https://github.com/rust-lang/rust/blob/5f0d724e298ee4e19bef4e863c176dd87ef6400f/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f0d724e298ee4e19bef4e863c176dd87ef6400f/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fiter.rs?ref=5f0d724e298ee4e19bef4e863c176dd87ef6400f", "patch": "@@ -0,0 +1,1255 @@\n+//! Iterators for `str` methods.\n+\n+use crate::char;\n+use crate::fmt::{self, Write};\n+use crate::iter::TrustedRandomAccess;\n+use crate::iter::{Chain, FlatMap, Flatten};\n+use crate::iter::{Copied, Filter, FusedIterator, Map, TrustedLen};\n+use crate::ops::Try;\n+use crate::option;\n+use crate::slice::{self, Split as SliceSplit};\n+\n+use super::from_utf8_unchecked;\n+use super::pattern::Pattern;\n+use super::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n+use super::LinesAnyMap;\n+use super::{next_code_point, next_code_point_reverse, utf8_is_cont_byte};\n+use super::{BytesIsNotEmpty, UnsafeBytesToStr};\n+use super::{CharEscapeDebugContinue, CharEscapeDefault, CharEscapeUnicode};\n+use super::{IsAsciiWhitespace, IsNotEmpty, IsWhitespace};\n+\n+/// An iterator over the [`char`]s of a string slice.\n+///\n+///\n+/// This struct is created by the [`chars`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`char`]: prim@char\n+/// [`chars`]: str::chars\n+#[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Chars<'a> {\n+    pub(super) iter: slice::Iter<'a, u8>,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for Chars<'a> {\n+    type Item = char;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<char> {\n+        next_code_point(&mut self.iter).map(|ch| {\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n+            unsafe { char::from_u32_unchecked(ch) }\n+        })\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        // length in `char` is equal to the number of non-continuation bytes\n+        let bytes_len = self.iter.len();\n+        let mut cont_bytes = 0;\n+        for &byte in self.iter {\n+            cont_bytes += utf8_is_cont_byte(byte) as usize;\n+        }\n+        bytes_len - cont_bytes\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let len = self.iter.len();\n+        // `(len + 3)` can't overflow, because we know that the `slice::Iter`\n+        // belongs to a slice in memory which has a maximum length of\n+        // `isize::MAX` (that's well below `usize::MAX`).\n+        ((len + 3) / 4, Some(len))\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<char> {\n+        // No need to go through the entire string.\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"chars_debug_impl\", since = \"1.38.0\")]\n+impl fmt::Debug for Chars<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Chars(\")?;\n+        f.debug_list().entries(self.clone()).finish()?;\n+        write!(f, \")\")?;\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for Chars<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<char> {\n+        next_code_point_reverse(&mut self.iter).map(|ch| {\n+            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n+            unsafe { char::from_u32_unchecked(ch) }\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for Chars<'_> {}\n+\n+impl<'a> Chars<'a> {\n+    /// Views the underlying data as a subslice of the original data.\n+    ///\n+    /// This has the same lifetime as the original slice, and so the\n+    /// iterator can continue to be used while this exists.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let mut chars = \"abc\".chars();\n+    ///\n+    /// assert_eq!(chars.as_str(), \"abc\");\n+    /// chars.next();\n+    /// assert_eq!(chars.as_str(), \"bc\");\n+    /// chars.next();\n+    /// chars.next();\n+    /// assert_eq!(chars.as_str(), \"\");\n+    /// ```\n+    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n+    #[inline]\n+    pub fn as_str(&self) -> &'a str {\n+        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n+        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n+    }\n+}\n+\n+/// An iterator over the [`char`]s of a string slice, and their positions.\n+///\n+/// This struct is created by the [`char_indices`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`char`]: prim@char\n+/// [`char_indices`]: str::char_indices\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct CharIndices<'a> {\n+    pub(super) front_offset: usize,\n+    pub(super) iter: Chars<'a>,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for CharIndices<'a> {\n+    type Item = (usize, char);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, char)> {\n+        let pre_len = self.iter.iter.len();\n+        match self.iter.next() {\n+            None => None,\n+            Some(ch) => {\n+                let index = self.front_offset;\n+                let len = self.iter.iter.len();\n+                self.front_offset += pre_len - len;\n+                Some((index, ch))\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<(usize, char)> {\n+        // No need to go through the entire string.\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for CharIndices<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, char)> {\n+        self.iter.next_back().map(|ch| {\n+            let index = self.front_offset + self.iter.iter.len();\n+            (index, ch)\n+        })\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for CharIndices<'_> {}\n+\n+impl<'a> CharIndices<'a> {\n+    /// Views the underlying data as a subslice of the original data.\n+    ///\n+    /// This has the same lifetime as the original slice, and so the\n+    /// iterator can continue to be used while this exists.\n+    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n+    #[inline]\n+    pub fn as_str(&self) -> &'a str {\n+        self.iter.as_str()\n+    }\n+}\n+\n+/// An iterator over the bytes of a string slice.\n+///\n+/// This struct is created by the [`bytes`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`bytes`]: str::bytes\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone, Debug)]\n+pub struct Bytes<'a>(pub(super) Copied<slice::Iter<'a, u8>>);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Iterator for Bytes<'_> {\n+    type Item = u8;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.0.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.0.count()\n+    }\n+\n+    #[inline]\n+    fn last(self) -> Option<Self::Item> {\n+        self.0.last()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        self.0.nth(n)\n+    }\n+\n+    #[inline]\n+    fn all<F>(&mut self, f: F) -> bool\n+    where\n+        F: FnMut(Self::Item) -> bool,\n+    {\n+        self.0.all(f)\n+    }\n+\n+    #[inline]\n+    fn any<F>(&mut self, f: F) -> bool\n+    where\n+        F: FnMut(Self::Item) -> bool,\n+    {\n+        self.0.any(f)\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.0.find(predicate)\n+    }\n+\n+    #[inline]\n+    fn position<P>(&mut self, predicate: P) -> Option<usize>\n+    where\n+        P: FnMut(Self::Item) -> bool,\n+    {\n+        self.0.position(predicate)\n+    }\n+\n+    #[inline]\n+    fn rposition<P>(&mut self, predicate: P) -> Option<usize>\n+    where\n+        P: FnMut(Self::Item) -> bool,\n+    {\n+        self.0.rposition(predicate)\n+    }\n+\n+    #[inline]\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> u8 {\n+        // SAFETY: the caller must uphold the safety contract\n+        // for `Iterator::__iterator_get_unchecked`.\n+        unsafe { self.0.__iterator_get_unchecked(idx) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl DoubleEndedIterator for Bytes<'_> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<u8> {\n+        self.0.next_back()\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        self.0.nth_back(n)\n+    }\n+\n+    #[inline]\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.0.rfind(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ExactSizeIterator for Bytes<'_> {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.0.len()\n+    }\n+\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for Bytes<'_> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl TrustedLen for Bytes<'_> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl TrustedRandomAccess for Bytes<'_> {\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n+/// This macro generates a Clone impl for string pattern API\n+/// wrapper types of the form X<'a, P>\n+macro_rules! derive_pattern_clone {\n+    (clone $t:ident with |$s:ident| $e:expr) => {\n+        impl<'a, P> Clone for $t<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: Clone>,\n+        {\n+            fn clone(&self) -> Self {\n+                let $s = self;\n+                $e\n+            }\n+        }\n+    };\n+}\n+\n+/// This macro generates two public iterator structs\n+/// wrapping a private internal one that makes use of the `Pattern` API.\n+///\n+/// For all patterns `P: Pattern<'a>` the following items will be\n+/// generated (generics omitted):\n+///\n+/// struct $forward_iterator($internal_iterator);\n+/// struct $reverse_iterator($internal_iterator);\n+///\n+/// impl Iterator for $forward_iterator\n+/// { /* internal ends up calling Searcher::next_match() */ }\n+///\n+/// impl DoubleEndedIterator for $forward_iterator\n+///       where P::Searcher: DoubleEndedSearcher\n+/// { /* internal ends up calling Searcher::next_match_back() */ }\n+///\n+/// impl Iterator for $reverse_iterator\n+///       where P::Searcher: ReverseSearcher\n+/// { /* internal ends up calling Searcher::next_match_back() */ }\n+///\n+/// impl DoubleEndedIterator for $reverse_iterator\n+///       where P::Searcher: DoubleEndedSearcher\n+/// { /* internal ends up calling Searcher::next_match() */ }\n+///\n+/// The internal one is defined outside the macro, and has almost the same\n+/// semantic as a DoubleEndedIterator by delegating to `pattern::Searcher` and\n+/// `pattern::ReverseSearcher` for both forward and reverse iteration.\n+///\n+/// \"Almost\", because a `Searcher` and a `ReverseSearcher` for a given\n+/// `Pattern` might not return the same elements, so actually implementing\n+/// `DoubleEndedIterator` for it would be incorrect.\n+/// (See the docs in `str::pattern` for more details)\n+///\n+/// However, the internal struct still represents a single ended iterator from\n+/// either end, and depending on pattern is also a valid double ended iterator,\n+/// so the two wrapper structs implement `Iterator`\n+/// and `DoubleEndedIterator` depending on the concrete pattern type, leading\n+/// to the complex impls seen above.\n+macro_rules! generate_pattern_iterators {\n+    {\n+        // Forward iterator\n+        forward:\n+            $(#[$forward_iterator_attribute:meta])*\n+            struct $forward_iterator:ident;\n+\n+        // Reverse iterator\n+        reverse:\n+            $(#[$reverse_iterator_attribute:meta])*\n+            struct $reverse_iterator:ident;\n+\n+        // Stability of all generated items\n+        stability:\n+            $(#[$common_stability_attribute:meta])*\n+\n+        // Internal almost-iterator that is being delegated to\n+        internal:\n+            $internal_iterator:ident yielding ($iterty:ty);\n+\n+        // Kind of delegation - either single ended or double ended\n+        delegate $($t:tt)*\n+    } => {\n+        $(#[$forward_iterator_attribute])*\n+        $(#[$common_stability_attribute])*\n+        pub struct $forward_iterator<'a, P: Pattern<'a>>(pub(super) $internal_iterator<'a, P>);\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> fmt::Debug for $forward_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: fmt::Debug>,\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                f.debug_tuple(stringify!($forward_iterator))\n+                    .field(&self.0)\n+                    .finish()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P: Pattern<'a>> Iterator for $forward_iterator<'a, P> {\n+            type Item = $iterty;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$iterty> {\n+                self.0.next()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> Clone for $forward_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: Clone>,\n+        {\n+            fn clone(&self) -> Self {\n+                $forward_iterator(self.0.clone())\n+            }\n+        }\n+\n+        $(#[$reverse_iterator_attribute])*\n+        $(#[$common_stability_attribute])*\n+        pub struct $reverse_iterator<'a, P: Pattern<'a>>(pub(super) $internal_iterator<'a, P>);\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> fmt::Debug for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: fmt::Debug>,\n+        {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                f.debug_tuple(stringify!($reverse_iterator))\n+                    .field(&self.0)\n+                    .finish()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> Iterator for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n+        {\n+            type Item = $iterty;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$iterty> {\n+                self.0.next_back()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> Clone for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: Clone>,\n+        {\n+            fn clone(&self) -> Self {\n+                $reverse_iterator(self.0.clone())\n+            }\n+        }\n+\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n+        impl<'a, P: Pattern<'a>> FusedIterator for $forward_iterator<'a, P> {}\n+\n+        #[stable(feature = \"fused\", since = \"1.26.0\")]\n+        impl<'a, P> FusedIterator for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n+        {}\n+\n+        generate_pattern_iterators!($($t)* with $(#[$common_stability_attribute])*,\n+                                                $forward_iterator,\n+                                                $reverse_iterator, $iterty);\n+    };\n+    {\n+        double ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+    } => {\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> DoubleEndedIterator for $forward_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n+        {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$iterty> {\n+                self.0.next_back()\n+            }\n+        }\n+\n+        $(#[$common_stability_attribute])*\n+        impl<'a, P> DoubleEndedIterator for $reverse_iterator<'a, P>\n+        where\n+            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n+        {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$iterty> {\n+                self.0.next()\n+            }\n+        }\n+    };\n+    {\n+        single ended; with $(#[$common_stability_attribute:meta])*,\n+                           $forward_iterator:ident,\n+                           $reverse_iterator:ident, $iterty:ty\n+    } => {}\n+}\n+\n+derive_pattern_clone! {\n+    clone SplitInternal\n+    with |s| SplitInternal { matcher: s.matcher.clone(), ..*s }\n+}\n+\n+pub(super) struct SplitInternal<'a, P: Pattern<'a>> {\n+    pub(super) start: usize,\n+    pub(super) end: usize,\n+    pub(super) matcher: P::Searcher,\n+    pub(super) allow_trailing_empty: bool,\n+    pub(super) finished: bool,\n+}\n+\n+impl<'a, P> fmt::Debug for SplitInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInternal\")\n+            .field(\"start\", &self.start)\n+            .field(\"end\", &self.end)\n+            .field(\"matcher\", &self.matcher)\n+            .field(\"allow_trailing_empty\", &self.allow_trailing_empty)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n+    #[inline]\n+    fn get_end(&mut self) -> Option<&'a str> {\n+        if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n+            self.finished = true;\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n+            unsafe {\n+                let string = self.matcher.haystack().get_unchecked(self.start..self.end);\n+                Some(string)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n+            Some((a, b)) => unsafe {\n+                let elt = haystack.get_unchecked(self.start..a);\n+                self.start = b;\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn next_inclusive(&mut self) -> Option<&'a str> {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.start is either the start of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(self.start..b);\n+                self.start = b;\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => {\n+                    if self.finished {\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n+            Some((a, b)) => unsafe {\n+                let elt = haystack.get_unchecked(b..self.end);\n+                self.end = a;\n+                Some(elt)\n+            },\n+            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n+            None => unsafe {\n+                self.finished = true;\n+                Some(haystack.get_unchecked(self.start..self.end))\n+            },\n+        }\n+    }\n+\n+    #[inline]\n+    fn next_back_inclusive(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        if self.finished {\n+            return None;\n+        }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back_inclusive() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => {\n+                    if self.finished {\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(b..self.end);\n+                self.end = b;\n+                Some(elt)\n+            },\n+            // SAFETY: self.start is either the start of the original string,\n+            // or start of a substring that represents the part of the string that hasn't\n+            // iterated yet. Either way, it is guaranteed to lie on unicode boundary.\n+            // self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n+            None => unsafe {\n+                self.finished = true;\n+                Some(haystack.get_unchecked(self.start..self.end))\n+            },\n+        }\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`split`].\n+        ///\n+        /// [`split`]: str::split\n+        struct Split;\n+    reverse:\n+        /// Created with the method [`rsplit`].\n+        ///\n+        /// [`rsplit`]: str::rsplit\n+        struct RSplit;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`split_terminator`].\n+        ///\n+        /// [`split_terminator`]: str::split_terminator\n+        struct SplitTerminator;\n+    reverse:\n+        /// Created with the method [`rsplit_terminator`].\n+        ///\n+        /// [`rsplit_terminator`]: str::rsplit_terminator\n+        struct RSplitTerminator;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+derive_pattern_clone! {\n+    clone SplitNInternal\n+    with |s| SplitNInternal { iter: s.iter.clone(), ..*s }\n+}\n+\n+pub(super) struct SplitNInternal<'a, P: Pattern<'a>> {\n+    pub(super) iter: SplitInternal<'a, P>,\n+    /// The number of splits remaining\n+    pub(super) count: usize,\n+}\n+\n+impl<'a, P> fmt::Debug for SplitNInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitNInternal\")\n+            .field(\"iter\", &self.iter)\n+            .field(\"count\", &self.count)\n+            .finish()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        match self.count {\n+            0 => None,\n+            1 => {\n+                self.count = 0;\n+                self.iter.get_end()\n+            }\n+            _ => {\n+                self.count -= 1;\n+                self.iter.next()\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        match self.count {\n+            0 => None,\n+            1 => {\n+                self.count = 0;\n+                self.iter.get_end()\n+            }\n+            _ => {\n+                self.count -= 1;\n+                self.iter.next_back()\n+            }\n+        }\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`splitn`].\n+        ///\n+        /// [`splitn`]: str::splitn\n+        struct SplitN;\n+    reverse:\n+        /// Created with the method [`rsplitn`].\n+        ///\n+        /// [`rsplitn`]: str::rsplitn\n+        struct RSplitN;\n+    stability:\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    internal:\n+        SplitNInternal yielding (&'a str);\n+    delegate single ended;\n+}\n+\n+derive_pattern_clone! {\n+    clone MatchIndicesInternal\n+    with |s| MatchIndicesInternal(s.0.clone())\n+}\n+\n+pub(super) struct MatchIndicesInternal<'a, P: Pattern<'a>>(pub(super) P::Searcher);\n+\n+impl<'a, P> fmt::Debug for MatchIndicesInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MatchIndicesInternal\").field(&self.0).finish()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, &'a str)> {\n+        self.0\n+            .next_match()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n+            .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, &'a str)>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        self.0\n+            .next_match_back()\n+            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n+            .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`match_indices`].\n+        ///\n+        /// [`match_indices`]: str::match_indices\n+        struct MatchIndices;\n+    reverse:\n+        /// Created with the method [`rmatch_indices`].\n+        ///\n+        /// [`rmatch_indices`]: str::rmatch_indices\n+        struct RMatchIndices;\n+    stability:\n+        #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+    internal:\n+        MatchIndicesInternal yielding ((usize, &'a str));\n+    delegate double ended;\n+}\n+\n+derive_pattern_clone! {\n+    clone MatchesInternal\n+    with |s| MatchesInternal(s.0.clone())\n+}\n+\n+pub(super) struct MatchesInternal<'a, P: Pattern<'a>>(pub(super) P::Searcher);\n+\n+impl<'a, P> fmt::Debug for MatchesInternal<'a, P>\n+where\n+    P: Pattern<'a, Searcher: fmt::Debug>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"MatchesInternal\").field(&self.0).finish()\n+    }\n+}\n+\n+impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n+        self.0.next_match().map(|(a, b)| unsafe {\n+            // Indices are known to be on utf8 boundaries\n+            self.0.haystack().get_unchecked(a..b)\n+        })\n+    }\n+\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n+    {\n+        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n+        self.0.next_match_back().map(|(a, b)| unsafe {\n+            // Indices are known to be on utf8 boundaries\n+            self.0.haystack().get_unchecked(a..b)\n+        })\n+    }\n+}\n+\n+generate_pattern_iterators! {\n+    forward:\n+        /// Created with the method [`matches`].\n+        ///\n+        /// [`matches`]: str::matches\n+        struct Matches;\n+    reverse:\n+        /// Created with the method [`rmatches`].\n+        ///\n+        /// [`rmatches`]: str::rmatches\n+        struct RMatches;\n+    stability:\n+        #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+    internal:\n+        MatchesInternal yielding (&'a str);\n+    delegate double ended;\n+}\n+\n+/// An iterator over the lines of a string, as string slices.\n+///\n+/// This struct is created with the [`lines`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`lines`]: str::lines\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone, Debug)]\n+pub struct Lines<'a>(pub(super) Map<SplitTerminator<'a, char>, LinesAnyMap>);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> Iterator for Lines<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a str> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a> DoubleEndedIterator for Lines<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for Lines<'_> {}\n+\n+/// Created with the method [`lines_any`].\n+///\n+/// [`lines_any`]: str::lines_any\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")]\n+#[derive(Clone, Debug)]\n+#[allow(deprecated)]\n+pub struct LinesAny<'a>(pub(super) Lines<'a>);\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n+impl<'a> Iterator for LinesAny<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n+impl<'a> DoubleEndedIterator for LinesAny<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+#[allow(deprecated)]\n+impl FusedIterator for LinesAny<'_> {}\n+\n+/// An iterator over the non-whitespace substrings of a string,\n+/// separated by any amount of whitespace.\n+///\n+/// This struct is created by the [`split_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_whitespace`]: str::split_whitespace\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+#[derive(Clone, Debug)]\n+pub struct SplitWhitespace<'a> {\n+    pub(super) inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n+}\n+\n+/// An iterator over the non-ASCII-whitespace substrings of a string,\n+/// separated by any amount of ASCII whitespace.\n+///\n+/// This struct is created by the [`split_ascii_whitespace`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_ascii_whitespace`]: str::split_ascii_whitespace\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct SplitAsciiWhitespace<'a> {\n+    pub(super) inner:\n+        Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n+}\n+\n+/// An iterator over the substrings of a string,\n+/// terminated by a substring matching to a predicate function\n+/// Unlike `Split`, it contains the matched part as a terminator\n+/// of the subslice.\n+///\n+/// This struct is created by the [`split_inclusive`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_inclusive`]: str::split_inclusive\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+pub struct SplitInclusive<'a, P: Pattern<'a>>(pub(super) SplitInternal<'a, P>);\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> Iterator for SplitWhitespace<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a str> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n+impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for SplitWhitespace<'_> {}\n+\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+impl<'a> Iterator for SplitAsciiWhitespace<'a> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a str> {\n+        self.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+impl FusedIterator for SplitAsciiWhitespace<'_> {}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a>> Iterator for SplitInclusive<'a, P> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a, Searcher: fmt::Debug>> fmt::Debug for SplitInclusive<'a, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusive\").field(\"0\", &self.0).finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a, Searcher: Clone>> Clone for SplitInclusive<'a, P> {\n+    fn clone(&self) -> Self {\n+        SplitInclusive(self.0.clone())\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n+    for SplitInclusive<'a, P>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n+\n+/// An iterator of [`u16`] over the string encoded as UTF-16.\n+///\n+/// This struct is created by the [`encode_utf16`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`encode_utf16`]: str::encode_utf16\n+#[derive(Clone)]\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub struct EncodeUtf16<'a> {\n+    pub(super) chars: Chars<'a>,\n+    pub(super) extra: u16,\n+}\n+\n+#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n+impl fmt::Debug for EncodeUtf16<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"EncodeUtf16 { .. }\")\n+    }\n+}\n+\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+impl<'a> Iterator for EncodeUtf16<'a> {\n+    type Item = u16;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<u16> {\n+        if self.extra != 0 {\n+            let tmp = self.extra;\n+            self.extra = 0;\n+            return Some(tmp);\n+        }\n+\n+        let mut buf = [0; 2];\n+        self.chars.next().map(|ch| {\n+            let n = ch.encode_utf16(&mut buf).len();\n+            if n == 2 {\n+                self.extra = buf[1];\n+            }\n+            buf[0]\n+        })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (low, high) = self.chars.size_hint();\n+        // every char gets either one u16 or two u16,\n+        // so this iterator is between 1 or 2 times as\n+        // long as the underlying iterator.\n+        (low, high.and_then(|n| n.checked_mul(2)))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl FusedIterator for EncodeUtf16<'_> {}\n+\n+/// The return type of [`str::escape_debug`].\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDebug<'a> {\n+    pub(super) inner: Chain<\n+        Flatten<option::IntoIter<char::EscapeDebug>>,\n+        FlatMap<Chars<'a>, char::EscapeDebug, CharEscapeDebugContinue>,\n+    >,\n+}\n+\n+/// The return type of [`str::escape_default`].\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeDefault<'a> {\n+    pub(super) inner: FlatMap<Chars<'a>, char::EscapeDefault, CharEscapeDefault>,\n+}\n+\n+/// The return type of [`str::escape_unicode`].\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+#[derive(Clone, Debug)]\n+pub struct EscapeUnicode<'a> {\n+    pub(super) inner: FlatMap<Chars<'a>, char::EscapeUnicode, CharEscapeUnicode>,\n+}\n+\n+macro_rules! escape_types_impls {\n+    ($( $Name: ident ),+) => {$(\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> fmt::Display for $Name<'a> {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                self.clone().try_for_each(|c| f.write_char(c))\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> Iterator for $Name<'a> {\n+            type Item = char;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<char> { self.inner.next() }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+            #[inline]\n+            fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+                Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+            {\n+                self.inner.try_fold(init, fold)\n+            }\n+\n+            #[inline]\n+            fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+                where Fold: FnMut(Acc, Self::Item) -> Acc,\n+            {\n+                self.inner.fold(init, fold)\n+            }\n+        }\n+\n+        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+        impl<'a> FusedIterator for $Name<'a> {}\n+    )+}\n+}\n+\n+escape_types_impls!(EscapeDebug, EscapeDefault, EscapeUnicode);"}, {"sha": "02b85ebfe49355d0ae3e8906b1bb12d403f6e0cf", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 113, "deletions": 1322, "changes": 1435, "blob_url": "https://github.com/rust-lang/rust/blob/5f0d724e298ee4e19bef4e863c176dd87ef6400f/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f0d724e298ee4e19bef4e863c176dd87ef6400f/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=5f0d724e298ee4e19bef4e863c176dd87ef6400f", "patch": "@@ -9,20 +9,15 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n mod error;\n+mod iter;\n mod traits;\n \n use self::pattern::Pattern;\n use self::pattern::{DoubleEndedSearcher, ReverseSearcher, Searcher};\n \n use crate::char;\n-use crate::fmt::{self, Write};\n-use crate::iter::TrustedRandomAccess;\n-use crate::iter::{Chain, FlatMap, Flatten};\n-use crate::iter::{Copied, Filter, FusedIterator, Map, TrustedLen};\n use crate::mem;\n-use crate::ops::Try;\n-use crate::option;\n-use crate::slice::{self, SliceIndex, Split as SliceSplit};\n+use crate::slice::{self, SliceIndex};\n \n pub mod pattern;\n \n@@ -36,6 +31,41 @@ pub use error::{ParseBoolError, Utf8Error};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use traits::FromStr;\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use iter::{Bytes, CharIndices, Chars, Lines, SplitWhitespace};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[allow(deprecated)]\n+pub use iter::LinesAny;\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use iter::{RSplit, RSplitTerminator, Split, SplitTerminator};\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use iter::{RSplitN, SplitN};\n+\n+#[stable(feature = \"str_matches\", since = \"1.2.0\")]\n+pub use iter::{Matches, RMatches};\n+\n+#[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n+pub use iter::{MatchIndices, RMatchIndices};\n+\n+#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n+pub use iter::EncodeUtf16;\n+\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+pub use iter::{EscapeDebug, EscapeDefault, EscapeUnicode};\n+\n+#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n+pub use iter::SplitAsciiWhitespace;\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n+use iter::SplitInclusive;\n+\n+use iter::MatchIndicesInternal;\n+use iter::SplitInternal;\n+use iter::{MatchesInternal, SplitNInternal};\n+\n /*\n Section: Creating a string\n */\n@@ -224,1057 +254,105 @@ pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n     // are valid UTF-8, thus the cast to `*mut str` is safe.\n     // Also, the pointer dereference is safe because that pointer\n     // comes from a reference which is guaranteed to be valid for writes.\n-    unsafe { &mut *(v as *mut [u8] as *mut str) }\n-}\n-\n-/*\n-Section: Iterators\n-*/\n-\n-/// An iterator over the [`char`]s of a string slice.\n-///\n-///\n-/// This struct is created by the [`chars`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`char`]: prim@char\n-/// [`chars`]: str::chars\n-#[derive(Clone)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Chars<'a> {\n-    iter: slice::Iter<'a, u8>,\n-}\n-\n-/// Returns the initial codepoint accumulator for the first byte.\n-/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n-/// for width 3, and 3 bits for width 4.\n-#[inline]\n-fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n-    (byte & (0x7F >> width)) as u32\n-}\n-\n-/// Returns the value of `ch` updated with continuation byte `byte`.\n-#[inline]\n-fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n-    (ch << 6) | (byte & CONT_MASK) as u32\n-}\n-\n-/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n-/// bits `10`).\n-#[inline]\n-fn utf8_is_cont_byte(byte: u8) -> bool {\n-    (byte & !CONT_MASK) == TAG_CONT_U8\n-}\n-\n-#[inline]\n-fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n-    match opt {\n-        Some(&byte) => byte,\n-        None => 0,\n-    }\n-}\n-\n-/// Reads the next code point out of a byte iterator (assuming a\n-/// UTF-8-like encoding).\n-#[unstable(feature = \"str_internals\", issue = \"none\")]\n-#[inline]\n-pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n-    // Decode UTF-8\n-    let x = *bytes.next()?;\n-    if x < 128 {\n-        return Some(x as u32);\n-    }\n-\n-    // Multibyte case follows\n-    // Decode from a byte combination out of: [[[x y] z] w]\n-    // NOTE: Performance is sensitive to the exact formulation here\n-    let init = utf8_first_byte(x, 2);\n-    let y = unwrap_or_0(bytes.next());\n-    let mut ch = utf8_acc_cont_byte(init, y);\n-    if x >= 0xE0 {\n-        // [[x y z] w] case\n-        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n-        let z = unwrap_or_0(bytes.next());\n-        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n-        ch = init << 12 | y_z;\n-        if x >= 0xF0 {\n-            // [x y z w] case\n-            // use only the lower 3 bits of `init`\n-            let w = unwrap_or_0(bytes.next());\n-            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n-        }\n-    }\n-\n-    Some(ch)\n-}\n-\n-/// Reads the last code point out of a byte iterator (assuming a\n-/// UTF-8-like encoding).\n-#[inline]\n-fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\n-where\n-    I: DoubleEndedIterator<Item = &'a u8>,\n-{\n-    // Decode UTF-8\n-    let w = match *bytes.next_back()? {\n-        next_byte if next_byte < 128 => return Some(next_byte as u32),\n-        back_byte => back_byte,\n-    };\n-\n-    // Multibyte case follows\n-    // Decode from a byte combination out of: [x [y [z w]]]\n-    let mut ch;\n-    let z = unwrap_or_0(bytes.next_back());\n-    ch = utf8_first_byte(z, 2);\n-    if utf8_is_cont_byte(z) {\n-        let y = unwrap_or_0(bytes.next_back());\n-        ch = utf8_first_byte(y, 3);\n-        if utf8_is_cont_byte(y) {\n-            let x = unwrap_or_0(bytes.next_back());\n-            ch = utf8_first_byte(x, 4);\n-            ch = utf8_acc_cont_byte(ch, y);\n-        }\n-        ch = utf8_acc_cont_byte(ch, z);\n-    }\n-    ch = utf8_acc_cont_byte(ch, w);\n-\n-    Some(ch)\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Chars<'a> {\n-    type Item = char;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<char> {\n-        next_code_point(&mut self.iter).map(|ch| {\n-            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n-            unsafe { char::from_u32_unchecked(ch) }\n-        })\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        // length in `char` is equal to the number of non-continuation bytes\n-        let bytes_len = self.iter.len();\n-        let mut cont_bytes = 0;\n-        for &byte in self.iter {\n-            cont_bytes += utf8_is_cont_byte(byte) as usize;\n-        }\n-        bytes_len - cont_bytes\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = self.iter.len();\n-        // `(len + 3)` can't overflow, because we know that the `slice::Iter`\n-        // belongs to a slice in memory which has a maximum length of\n-        // `isize::MAX` (that's well below `usize::MAX`).\n-        ((len + 3) / 4, Some(len))\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<char> {\n-        // No need to go through the entire string.\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"chars_debug_impl\", since = \"1.38.0\")]\n-impl fmt::Debug for Chars<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"Chars(\")?;\n-        f.debug_list().entries(self.clone()).finish()?;\n-        write!(f, \")\")?;\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for Chars<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<char> {\n-        next_code_point_reverse(&mut self.iter).map(|ch| {\n-            // SAFETY: `str` invariant says `ch` is a valid Unicode Scalar Value.\n-            unsafe { char::from_u32_unchecked(ch) }\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for Chars<'_> {}\n-\n-impl<'a> Chars<'a> {\n-    /// Views the underlying data as a subslice of the original data.\n-    ///\n-    /// This has the same lifetime as the original slice, and so the\n-    /// iterator can continue to be used while this exists.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// let mut chars = \"abc\".chars();\n-    ///\n-    /// assert_eq!(chars.as_str(), \"abc\");\n-    /// chars.next();\n-    /// assert_eq!(chars.as_str(), \"bc\");\n-    /// chars.next();\n-    /// chars.next();\n-    /// assert_eq!(chars.as_str(), \"\");\n-    /// ```\n-    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n-    #[inline]\n-    pub fn as_str(&self) -> &'a str {\n-        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n-        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n-    }\n-}\n-\n-/// An iterator over the [`char`]s of a string slice, and their positions.\n-///\n-/// This struct is created by the [`char_indices`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`char`]: prim@char\n-/// [`char_indices`]: str::char_indices\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct CharIndices<'a> {\n-    front_offset: usize,\n-    iter: Chars<'a>,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for CharIndices<'a> {\n-    type Item = (usize, char);\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, char)> {\n-        let pre_len = self.iter.iter.len();\n-        match self.iter.next() {\n-            None => None,\n-            Some(ch) => {\n-                let index = self.front_offset;\n-                let len = self.iter.iter.len();\n-                self.front_offset += pre_len - len;\n-                Some((index, ch))\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<(usize, char)> {\n-        // No need to go through the entire string.\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for CharIndices<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, char)> {\n-        self.iter.next_back().map(|ch| {\n-            let index = self.front_offset + self.iter.iter.len();\n-            (index, ch)\n-        })\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for CharIndices<'_> {}\n-\n-impl<'a> CharIndices<'a> {\n-    /// Views the underlying data as a subslice of the original data.\n-    ///\n-    /// This has the same lifetime as the original slice, and so the\n-    /// iterator can continue to be used while this exists.\n-    #[stable(feature = \"iter_to_slice\", since = \"1.4.0\")]\n-    #[inline]\n-    pub fn as_str(&self) -> &'a str {\n-        self.iter.as_str()\n-    }\n-}\n-\n-/// An iterator over the bytes of a string slice.\n-///\n-/// This struct is created by the [`bytes`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`bytes`]: str::bytes\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone, Debug)]\n-pub struct Bytes<'a>(Copied<slice::Iter<'a, u8>>);\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Iterator for Bytes<'_> {\n-    type Item = u8;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u8> {\n-        self.0.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.0.size_hint()\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.0.count()\n-    }\n-\n-    #[inline]\n-    fn last(self) -> Option<Self::Item> {\n-        self.0.last()\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        self.0.nth(n)\n-    }\n-\n-    #[inline]\n-    fn all<F>(&mut self, f: F) -> bool\n-    where\n-        F: FnMut(Self::Item) -> bool,\n-    {\n-        self.0.all(f)\n-    }\n-\n-    #[inline]\n-    fn any<F>(&mut self, f: F) -> bool\n-    where\n-        F: FnMut(Self::Item) -> bool,\n-    {\n-        self.0.any(f)\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.0.find(predicate)\n-    }\n-\n-    #[inline]\n-    fn position<P>(&mut self, predicate: P) -> Option<usize>\n-    where\n-        P: FnMut(Self::Item) -> bool,\n-    {\n-        self.0.position(predicate)\n-    }\n-\n-    #[inline]\n-    fn rposition<P>(&mut self, predicate: P) -> Option<usize>\n-    where\n-        P: FnMut(Self::Item) -> bool,\n-    {\n-        self.0.rposition(predicate)\n-    }\n-\n-    #[inline]\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> u8 {\n-        // SAFETY: the caller must uphold the safety contract\n-        // for `Iterator::__iterator_get_unchecked`.\n-        unsafe { self.0.__iterator_get_unchecked(idx) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl DoubleEndedIterator for Bytes<'_> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<u8> {\n-        self.0.next_back()\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        self.0.nth_back(n)\n-    }\n-\n-    #[inline]\n-    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.0.rfind(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl ExactSizeIterator for Bytes<'_> {\n-    #[inline]\n-    fn len(&self) -> usize {\n-        self.0.len()\n-    }\n-\n-    #[inline]\n-    fn is_empty(&self) -> bool {\n-        self.0.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for Bytes<'_> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl TrustedLen for Bytes<'_> {}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl TrustedRandomAccess for Bytes<'_> {\n-    fn may_have_side_effect() -> bool {\n-        false\n-    }\n-}\n-\n-/// This macro generates a Clone impl for string pattern API\n-/// wrapper types of the form X<'a, P>\n-macro_rules! derive_pattern_clone {\n-    (clone $t:ident with |$s:ident| $e:expr) => {\n-        impl<'a, P> Clone for $t<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: Clone>,\n-        {\n-            fn clone(&self) -> Self {\n-                let $s = self;\n-                $e\n-            }\n-        }\n-    };\n-}\n-\n-/// This macro generates two public iterator structs\n-/// wrapping a private internal one that makes use of the `Pattern` API.\n-///\n-/// For all patterns `P: Pattern<'a>` the following items will be\n-/// generated (generics omitted):\n-///\n-/// struct $forward_iterator($internal_iterator);\n-/// struct $reverse_iterator($internal_iterator);\n-///\n-/// impl Iterator for $forward_iterator\n-/// { /* internal ends up calling Searcher::next_match() */ }\n-///\n-/// impl DoubleEndedIterator for $forward_iterator\n-///       where P::Searcher: DoubleEndedSearcher\n-/// { /* internal ends up calling Searcher::next_match_back() */ }\n-///\n-/// impl Iterator for $reverse_iterator\n-///       where P::Searcher: ReverseSearcher\n-/// { /* internal ends up calling Searcher::next_match_back() */ }\n-///\n-/// impl DoubleEndedIterator for $reverse_iterator\n-///       where P::Searcher: DoubleEndedSearcher\n-/// { /* internal ends up calling Searcher::next_match() */ }\n-///\n-/// The internal one is defined outside the macro, and has almost the same\n-/// semantic as a DoubleEndedIterator by delegating to `pattern::Searcher` and\n-/// `pattern::ReverseSearcher` for both forward and reverse iteration.\n-///\n-/// \"Almost\", because a `Searcher` and a `ReverseSearcher` for a given\n-/// `Pattern` might not return the same elements, so actually implementing\n-/// `DoubleEndedIterator` for it would be incorrect.\n-/// (See the docs in `str::pattern` for more details)\n-///\n-/// However, the internal struct still represents a single ended iterator from\n-/// either end, and depending on pattern is also a valid double ended iterator,\n-/// so the two wrapper structs implement `Iterator`\n-/// and `DoubleEndedIterator` depending on the concrete pattern type, leading\n-/// to the complex impls seen above.\n-macro_rules! generate_pattern_iterators {\n-    {\n-        // Forward iterator\n-        forward:\n-            $(#[$forward_iterator_attribute:meta])*\n-            struct $forward_iterator:ident;\n-\n-        // Reverse iterator\n-        reverse:\n-            $(#[$reverse_iterator_attribute:meta])*\n-            struct $reverse_iterator:ident;\n-\n-        // Stability of all generated items\n-        stability:\n-            $(#[$common_stability_attribute:meta])*\n-\n-        // Internal almost-iterator that is being delegated to\n-        internal:\n-            $internal_iterator:ident yielding ($iterty:ty);\n-\n-        // Kind of delegation - either single ended or double ended\n-        delegate $($t:tt)*\n-    } => {\n-        $(#[$forward_iterator_attribute])*\n-        $(#[$common_stability_attribute])*\n-        pub struct $forward_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> fmt::Debug for $forward_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: fmt::Debug>,\n-        {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                f.debug_tuple(stringify!($forward_iterator))\n-                    .field(&self.0)\n-                    .finish()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P: Pattern<'a>> Iterator for $forward_iterator<'a, P> {\n-            type Item = $iterty;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$iterty> {\n-                self.0.next()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> Clone for $forward_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: Clone>,\n-        {\n-            fn clone(&self) -> Self {\n-                $forward_iterator(self.0.clone())\n-            }\n-        }\n-\n-        $(#[$reverse_iterator_attribute])*\n-        $(#[$common_stability_attribute])*\n-        pub struct $reverse_iterator<'a, P: Pattern<'a>>($internal_iterator<'a, P>);\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> fmt::Debug for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: fmt::Debug>,\n-        {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                f.debug_tuple(stringify!($reverse_iterator))\n-                    .field(&self.0)\n-                    .finish()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> Iterator for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n-        {\n-            type Item = $iterty;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$iterty> {\n-                self.0.next_back()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> Clone for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: Clone>,\n-        {\n-            fn clone(&self) -> Self {\n-                $reverse_iterator(self.0.clone())\n-            }\n-        }\n-\n-        #[stable(feature = \"fused\", since = \"1.26.0\")]\n-        impl<'a, P: Pattern<'a>> FusedIterator for $forward_iterator<'a, P> {}\n-\n-        #[stable(feature = \"fused\", since = \"1.26.0\")]\n-        impl<'a, P> FusedIterator for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: ReverseSearcher<'a>>,\n-        {}\n-\n-        generate_pattern_iterators!($($t)* with $(#[$common_stability_attribute])*,\n-                                                $forward_iterator,\n-                                                $reverse_iterator, $iterty);\n-    };\n-    {\n-        double ended; with $(#[$common_stability_attribute:meta])*,\n-                           $forward_iterator:ident,\n-                           $reverse_iterator:ident, $iterty:ty\n-    } => {\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> DoubleEndedIterator for $forward_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n-        {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$iterty> {\n-                self.0.next_back()\n-            }\n-        }\n-\n-        $(#[$common_stability_attribute])*\n-        impl<'a, P> DoubleEndedIterator for $reverse_iterator<'a, P>\n-        where\n-            P: Pattern<'a, Searcher: DoubleEndedSearcher<'a>>,\n-        {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$iterty> {\n-                self.0.next()\n-            }\n-        }\n-    };\n-    {\n-        single ended; with $(#[$common_stability_attribute:meta])*,\n-                           $forward_iterator:ident,\n-                           $reverse_iterator:ident, $iterty:ty\n-    } => {}\n-}\n-\n-derive_pattern_clone! {\n-    clone SplitInternal\n-    with |s| SplitInternal { matcher: s.matcher.clone(), ..*s }\n-}\n-\n-struct SplitInternal<'a, P: Pattern<'a>> {\n-    start: usize,\n-    end: usize,\n-    matcher: P::Searcher,\n-    allow_trailing_empty: bool,\n-    finished: bool,\n-}\n-\n-impl<'a, P> fmt::Debug for SplitInternal<'a, P>\n-where\n-    P: Pattern<'a, Searcher: fmt::Debug>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SplitInternal\")\n-            .field(\"start\", &self.start)\n-            .field(\"end\", &self.end)\n-            .field(\"matcher\", &self.matcher)\n-            .field(\"allow_trailing_empty\", &self.allow_trailing_empty)\n-            .field(\"finished\", &self.finished)\n-            .finish()\n-    }\n-}\n-\n-impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n-    #[inline]\n-    fn get_end(&mut self) -> Option<&'a str> {\n-        if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n-            self.finished = true;\n-            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n-            unsafe {\n-                let string = self.matcher.haystack().get_unchecked(self.start..self.end);\n-                Some(string)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        if self.finished {\n-            return None;\n-        }\n-\n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match() {\n-            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n-            Some((a, b)) => unsafe {\n-                let elt = haystack.get_unchecked(self.start..a);\n-                self.start = b;\n-                Some(elt)\n-            },\n-            None => self.get_end(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn next_inclusive(&mut self) -> Option<&'a str> {\n-        if self.finished {\n-            return None;\n-        }\n-\n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match() {\n-            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n-            // and self.start is either the start of the original string,\n-            // or `b` was assigned to it, so it also lies on unicode boundary.\n-            Some((_, b)) => unsafe {\n-                let elt = haystack.get_unchecked(self.start..b);\n-                self.start = b;\n-                Some(elt)\n-            },\n-            None => self.get_end(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        if self.finished {\n-            return None;\n-        }\n-\n-        if !self.allow_trailing_empty {\n-            self.allow_trailing_empty = true;\n-            match self.next_back() {\n-                Some(elt) if !elt.is_empty() => return Some(elt),\n-                _ => {\n-                    if self.finished {\n-                        return None;\n-                    }\n-                }\n-            }\n-        }\n-\n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match_back() {\n-            // SAFETY: `Searcher` guarantees that `a` and `b` lie on unicode boundaries.\n-            Some((a, b)) => unsafe {\n-                let elt = haystack.get_unchecked(b..self.end);\n-                self.end = a;\n-                Some(elt)\n-            },\n-            // SAFETY: `self.start` and `self.end` always lie on unicode boundaries.\n-            None => unsafe {\n-                self.finished = true;\n-                Some(haystack.get_unchecked(self.start..self.end))\n-            },\n-        }\n-    }\n-\n-    #[inline]\n-    fn next_back_inclusive(&mut self) -> Option<&'a str>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        if self.finished {\n-            return None;\n-        }\n-\n-        if !self.allow_trailing_empty {\n-            self.allow_trailing_empty = true;\n-            match self.next_back_inclusive() {\n-                Some(elt) if !elt.is_empty() => return Some(elt),\n-                _ => {\n-                    if self.finished {\n-                        return None;\n-                    }\n-                }\n-            }\n-        }\n-\n-        let haystack = self.matcher.haystack();\n-        match self.matcher.next_match_back() {\n-            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n-            // and self.end is either the end of the original string,\n-            // or `b` was assigned to it, so it also lies on unicode boundary.\n-            Some((_, b)) => unsafe {\n-                let elt = haystack.get_unchecked(b..self.end);\n-                self.end = b;\n-                Some(elt)\n-            },\n-            // SAFETY: self.start is either the start of the original string,\n-            // or start of a substring that represents the part of the string that hasn't\n-            // iterated yet. Either way, it is guaranteed to lie on unicode boundary.\n-            // self.end is either the end of the original string,\n-            // or `b` was assigned to it, so it also lies on unicode boundary.\n-            None => unsafe {\n-                self.finished = true;\n-                Some(haystack.get_unchecked(self.start..self.end))\n-            },\n-        }\n-    }\n-}\n-\n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`split`].\n-        ///\n-        /// [`split`]: str::split\n-        struct Split;\n-    reverse:\n-        /// Created with the method [`rsplit`].\n-        ///\n-        /// [`rsplit`]: str::rsplit\n-        struct RSplit;\n-    stability:\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    internal:\n-        SplitInternal yielding (&'a str);\n-    delegate double ended;\n-}\n-\n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`split_terminator`].\n-        ///\n-        /// [`split_terminator`]: str::split_terminator\n-        struct SplitTerminator;\n-    reverse:\n-        /// Created with the method [`rsplit_terminator`].\n-        ///\n-        /// [`rsplit_terminator`]: str::rsplit_terminator\n-        struct RSplitTerminator;\n-    stability:\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    internal:\n-        SplitInternal yielding (&'a str);\n-    delegate double ended;\n-}\n-\n-derive_pattern_clone! {\n-    clone SplitNInternal\n-    with |s| SplitNInternal { iter: s.iter.clone(), ..*s }\n-}\n-\n-struct SplitNInternal<'a, P: Pattern<'a>> {\n-    iter: SplitInternal<'a, P>,\n-    /// The number of splits remaining\n-    count: usize,\n-}\n-\n-impl<'a, P> fmt::Debug for SplitNInternal<'a, P>\n-where\n-    P: Pattern<'a, Searcher: fmt::Debug>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SplitNInternal\")\n-            .field(\"iter\", &self.iter)\n-            .field(\"count\", &self.count)\n-            .finish()\n-    }\n-}\n-\n-impl<'a, P: Pattern<'a>> SplitNInternal<'a, P> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        match self.count {\n-            0 => None,\n-            1 => {\n-                self.count = 0;\n-                self.iter.get_end()\n-            }\n-            _ => {\n-                self.count -= 1;\n-                self.iter.next()\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        match self.count {\n-            0 => None,\n-            1 => {\n-                self.count = 0;\n-                self.iter.get_end()\n-            }\n-            _ => {\n-                self.count -= 1;\n-                self.iter.next_back()\n-            }\n-        }\n-    }\n+    unsafe { &mut *(v as *mut [u8] as *mut str) }\n }\n \n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`splitn`].\n-        ///\n-        /// [`splitn`]: str::splitn\n-        struct SplitN;\n-    reverse:\n-        /// Created with the method [`rsplitn`].\n-        ///\n-        /// [`rsplitn`]: str::rsplitn\n-        struct RSplitN;\n-    stability:\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    internal:\n-        SplitNInternal yielding (&'a str);\n-    delegate single ended;\n+/// Returns the initial codepoint accumulator for the first byte.\n+/// The first byte is special, only want bottom 5 bits for width 2, 4 bits\n+/// for width 3, and 3 bits for width 4.\n+#[inline]\n+fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n+    (byte & (0x7F >> width)) as u32\n }\n \n-derive_pattern_clone! {\n-    clone MatchIndicesInternal\n-    with |s| MatchIndicesInternal(s.0.clone())\n+/// Returns the value of `ch` updated with continuation byte `byte`.\n+#[inline]\n+fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n+    (ch << 6) | (byte & CONT_MASK) as u32\n }\n \n-struct MatchIndicesInternal<'a, P: Pattern<'a>>(P::Searcher);\n+/// Checks whether the byte is a UTF-8 continuation byte (i.e., starts with the\n+/// bits `10`).\n+#[inline]\n+fn utf8_is_cont_byte(byte: u8) -> bool {\n+    (byte & !CONT_MASK) == TAG_CONT_U8\n+}\n \n-impl<'a, P> fmt::Debug for MatchIndicesInternal<'a, P>\n-where\n-    P: Pattern<'a, Searcher: fmt::Debug>,\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"MatchIndicesInternal\").field(&self.0).finish()\n+#[inline]\n+fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n+    match opt {\n+        Some(&byte) => byte,\n+        None => 0,\n     }\n }\n \n-impl<'a, P: Pattern<'a>> MatchIndicesInternal<'a, P> {\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, &'a str)> {\n-        self.0\n-            .next_match()\n-            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n-            .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n+/// Reads the next code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[unstable(feature = \"str_internals\", issue = \"none\")]\n+#[inline]\n+pub fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n+    // Decode UTF-8\n+    let x = *bytes.next()?;\n+    if x < 128 {\n+        return Some(x as u32);\n     }\n \n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, &'a str)>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        self.0\n-            .next_match_back()\n-            // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n-            .map(|(start, end)| unsafe { (start, self.0.haystack().get_unchecked(start..end)) })\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [[[x y] z] w]\n+    // NOTE: Performance is sensitive to the exact formulation here\n+    let init = utf8_first_byte(x, 2);\n+    let y = unwrap_or_0(bytes.next());\n+    let mut ch = utf8_acc_cont_byte(init, y);\n+    if x >= 0xE0 {\n+        // [[x y z] w] case\n+        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n+        let z = unwrap_or_0(bytes.next());\n+        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n+        ch = init << 12 | y_z;\n+        if x >= 0xF0 {\n+            // [x y z w] case\n+            // use only the lower 3 bits of `init`\n+            let w = unwrap_or_0(bytes.next());\n+            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n+        }\n     }\n-}\n \n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`match_indices`].\n-        ///\n-        /// [`match_indices`]: str::match_indices\n-        struct MatchIndices;\n-    reverse:\n-        /// Created with the method [`rmatch_indices`].\n-        ///\n-        /// [`rmatch_indices`]: str::rmatch_indices\n-        struct RMatchIndices;\n-    stability:\n-        #[stable(feature = \"str_match_indices\", since = \"1.5.0\")]\n-    internal:\n-        MatchIndicesInternal yielding ((usize, &'a str));\n-    delegate double ended;\n-}\n-\n-derive_pattern_clone! {\n-    clone MatchesInternal\n-    with |s| MatchesInternal(s.0.clone())\n+    Some(ch)\n }\n \n-struct MatchesInternal<'a, P: Pattern<'a>>(P::Searcher);\n-\n-impl<'a, P> fmt::Debug for MatchesInternal<'a, P>\n+/// Reads the last code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[inline]\n+fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\n where\n-    P: Pattern<'a, Searcher: fmt::Debug>,\n+    I: DoubleEndedIterator<Item = &'a u8>,\n {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"MatchesInternal\").field(&self.0).finish()\n-    }\n-}\n-\n-impl<'a, P: Pattern<'a>> MatchesInternal<'a, P> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n-        self.0.next_match().map(|(a, b)| unsafe {\n-            // Indices are known to be on utf8 boundaries\n-            self.0.haystack().get_unchecked(a..b)\n-        })\n-    }\n-\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str>\n-    where\n-        P::Searcher: ReverseSearcher<'a>,\n-    {\n-        // SAFETY: `Searcher` guarantees that `start` and `end` lie on unicode boundaries.\n-        self.0.next_match_back().map(|(a, b)| unsafe {\n-            // Indices are known to be on utf8 boundaries\n-            self.0.haystack().get_unchecked(a..b)\n-        })\n-    }\n-}\n-\n-generate_pattern_iterators! {\n-    forward:\n-        /// Created with the method [`matches`].\n-        ///\n-        /// [`matches`]: str::matches\n-        struct Matches;\n-    reverse:\n-        /// Created with the method [`rmatches`].\n-        ///\n-        /// [`rmatches`]: str::rmatches\n-        struct RMatches;\n-    stability:\n-        #[stable(feature = \"str_matches\", since = \"1.2.0\")]\n-    internal:\n-        MatchesInternal yielding (&'a str);\n-    delegate double ended;\n-}\n-\n-/// An iterator over the lines of a string, as string slices.\n-///\n-/// This struct is created with the [`lines`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`lines`]: str::lines\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone, Debug)]\n-pub struct Lines<'a>(Map<SplitTerminator<'a, char>, LinesAnyMap>);\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for Lines<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.0.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.0.size_hint()\n-    }\n+    // Decode UTF-8\n+    let w = match *bytes.next_back()? {\n+        next_byte if next_byte < 128 => return Some(next_byte as u32),\n+        back_byte => back_byte,\n+    };\n \n-    #[inline]\n-    fn last(mut self) -> Option<&'a str> {\n-        self.next_back()\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [x [y [z w]]]\n+    let mut ch;\n+    let z = unwrap_or_0(bytes.next_back());\n+    ch = utf8_first_byte(z, 2);\n+    if utf8_is_cont_byte(z) {\n+        let y = unwrap_or_0(bytes.next_back());\n+        ch = utf8_first_byte(y, 3);\n+        if utf8_is_cont_byte(y) {\n+            let x = unwrap_or_0(bytes.next_back());\n+            ch = utf8_first_byte(x, 4);\n+            ch = utf8_acc_cont_byte(ch, y);\n+        }\n+        ch = utf8_acc_cont_byte(ch, z);\n     }\n-}\n+    ch = utf8_acc_cont_byte(ch, w);\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> DoubleEndedIterator for Lines<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.0.next_back()\n-    }\n+    Some(ch)\n }\n \n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for Lines<'_> {}\n-\n-/// Created with the method [`lines_any`].\n-///\n-/// [`lines_any`]: str::lines_any\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_deprecated(since = \"1.4.0\", reason = \"use lines()/Lines instead now\")]\n-#[derive(Clone, Debug)]\n-#[allow(deprecated)]\n-pub struct LinesAny<'a>(Lines<'a>);\n-\n impl_fn_for_zst! {\n     /// A nameable, cloneable fn type\n     #[derive(Clone)]\n@@ -1285,35 +363,6 @@ impl_fn_for_zst! {\n     };\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a> Iterator for LinesAny<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.0.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.0.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[allow(deprecated)]\n-impl<'a> DoubleEndedIterator for LinesAny<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.0.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-#[allow(deprecated)]\n-impl FusedIterator for LinesAny<'_> {}\n-\n /*\n Section: UTF-8 validation\n */\n@@ -3869,44 +2918,6 @@ impl Default for &mut str {\n     }\n }\n \n-/// An iterator over the non-whitespace substrings of a string,\n-/// separated by any amount of whitespace.\n-///\n-/// This struct is created by the [`split_whitespace`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`split_whitespace`]: str::split_whitespace\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-#[derive(Clone, Debug)]\n-pub struct SplitWhitespace<'a> {\n-    inner: Filter<Split<'a, IsWhitespace>, IsNotEmpty>,\n-}\n-\n-/// An iterator over the non-ASCII-whitespace substrings of a string,\n-/// separated by any amount of ASCII whitespace.\n-///\n-/// This struct is created by the [`split_ascii_whitespace`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`split_ascii_whitespace`]: str::split_ascii_whitespace\n-#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n-#[derive(Clone, Debug)]\n-pub struct SplitAsciiWhitespace<'a> {\n-    inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n-}\n-\n-/// An iterator over the substrings of a string,\n-/// terminated by a substring matching to a predicate function\n-/// Unlike `Split`, it contains the matched part as a terminator\n-/// of the subslice.\n-///\n-/// This struct is created by the [`split_inclusive`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`split_inclusive`]: str::split_inclusive\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-pub struct SplitInclusive<'a, P: Pattern<'a>>(SplitInternal<'a, P>);\n-\n impl_fn_for_zst! {\n     #[derive(Clone)]\n     struct IsWhitespace impl Fn = |c: char| -> bool {\n@@ -3934,223 +2945,3 @@ impl_fn_for_zst! {\n         unsafe { from_utf8_unchecked(bytes) }\n     };\n }\n-\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> Iterator for SplitWhitespace<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.inner.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<&'a str> {\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n-impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.inner.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for SplitWhitespace<'_> {}\n-\n-#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n-impl<'a> Iterator for SplitAsciiWhitespace<'a> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.inner.next()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<&'a str> {\n-        self.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n-impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.inner.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n-impl FusedIterator for SplitAsciiWhitespace<'_> {}\n-\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a>> Iterator for SplitInclusive<'a, P> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.0.next_inclusive()\n-    }\n-}\n-\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a, Searcher: fmt::Debug>> fmt::Debug for SplitInclusive<'a, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SplitInclusive\").field(\"0\", &self.0).finish()\n-    }\n-}\n-\n-// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a, Searcher: Clone>> Clone for SplitInclusive<'a, P> {\n-    fn clone(&self) -> Self {\n-        SplitInclusive(self.0.clone())\n-    }\n-}\n-\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n-    for SplitInclusive<'a, P>\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.0.next_back_inclusive()\n-    }\n-}\n-\n-#[unstable(feature = \"split_inclusive\", issue = \"72360\")]\n-impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n-\n-/// An iterator of [`u16`] over the string encoded as UTF-16.\n-///\n-/// This struct is created by the [`encode_utf16`] method on [`str`].\n-/// See its documentation for more.\n-///\n-/// [`encode_utf16`]: str::encode_utf16\n-#[derive(Clone)]\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-pub struct EncodeUtf16<'a> {\n-    chars: Chars<'a>,\n-    extra: u16,\n-}\n-\n-#[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl fmt::Debug for EncodeUtf16<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.pad(\"EncodeUtf16 { .. }\")\n-    }\n-}\n-\n-#[stable(feature = \"encode_utf16\", since = \"1.8.0\")]\n-impl<'a> Iterator for EncodeUtf16<'a> {\n-    type Item = u16;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<u16> {\n-        if self.extra != 0 {\n-            let tmp = self.extra;\n-            self.extra = 0;\n-            return Some(tmp);\n-        }\n-\n-        let mut buf = [0; 2];\n-        self.chars.next().map(|ch| {\n-            let n = ch.encode_utf16(&mut buf).len();\n-            if n == 2 {\n-                self.extra = buf[1];\n-            }\n-            buf[0]\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (low, high) = self.chars.size_hint();\n-        // every char gets either one u16 or two u16,\n-        // so this iterator is between 1 or 2 times as\n-        // long as the underlying iterator.\n-        (low, high.and_then(|n| n.checked_mul(2)))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl FusedIterator for EncodeUtf16<'_> {}\n-\n-/// The return type of [`str::escape_debug`].\n-#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-#[derive(Clone, Debug)]\n-pub struct EscapeDebug<'a> {\n-    inner: Chain<\n-        Flatten<option::IntoIter<char::EscapeDebug>>,\n-        FlatMap<Chars<'a>, char::EscapeDebug, CharEscapeDebugContinue>,\n-    >,\n-}\n-\n-/// The return type of [`str::escape_default`].\n-#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-#[derive(Clone, Debug)]\n-pub struct EscapeDefault<'a> {\n-    inner: FlatMap<Chars<'a>, char::EscapeDefault, CharEscapeDefault>,\n-}\n-\n-/// The return type of [`str::escape_unicode`].\n-#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-#[derive(Clone, Debug)]\n-pub struct EscapeUnicode<'a> {\n-    inner: FlatMap<Chars<'a>, char::EscapeUnicode, CharEscapeUnicode>,\n-}\n-\n-macro_rules! escape_types_impls {\n-    ($( $Name: ident ),+) => {$(\n-        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-        impl<'a> fmt::Display for $Name<'a> {\n-            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-                self.clone().try_for_each(|c| f.write_char(c))\n-            }\n-        }\n-\n-        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-        impl<'a> Iterator for $Name<'a> {\n-            type Item = char;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<char> { self.inner.next() }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n-\n-            #[inline]\n-            fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n-                Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n-            {\n-                self.inner.try_fold(init, fold)\n-            }\n-\n-            #[inline]\n-            fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-                where Fold: FnMut(Acc, Self::Item) -> Acc,\n-            {\n-                self.inner.fold(init, fold)\n-            }\n-        }\n-\n-        #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n-        impl<'a> FusedIterator for $Name<'a> {}\n-    )+}\n-}\n-\n-escape_types_impls!(EscapeDebug, EscapeDefault, EscapeUnicode);"}]}