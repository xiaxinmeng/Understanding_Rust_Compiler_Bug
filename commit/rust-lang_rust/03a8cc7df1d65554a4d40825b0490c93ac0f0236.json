{"sha": "03a8cc7df1d65554a4d40825b0490c93ac0f0236", "node_id": "C_kwDOAAsO6NoAKDAzYThjYzdkZjFkNjU1NTRhNGQ0MDgyNWIwNDkwYzkzYWMwZjAyMzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-21T16:03:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-21T16:03:38Z"}, "message": "Auto merge of #93505 - lcnr:substsref-vs-ty-list, r=michaelwoerister\n\nsafely `transmute<&List<Ty<'tcx>>, &List<GenericArg<'tcx>>>`\n\nThis PR has 3 relevant steps which are is split in distinct commits.\n\nThe first commit now interns `List<Ty<'tcx>>` and `List<GenericArg<'tcx>>` together, potentially reusing memory while allowing free conversions between these two using `List<Ty<'tcx>>::as_substs()` and `SubstsRef<'tcx>::try_as_type_list()`.\n\nUsing this, we then use `&'tcx List<Ty<'tcx>>` instead of a `SubstsRef<'tcx>` for tuple fields, simplifying a bunch of code.\n\nFinally, as tuple fields and other generic arguments now use a different `TypeFoldable<'tcx>` impl, we optimize the impl for `List<Ty<'tcx>>` improving perf by slightly less than 1% in tuple heavy benchmarks.", "tree": {"sha": "c56dda3c041905a13e82de2cf2961caf72f7b7cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c56dda3c041905a13e82de2cf2961caf72f7b7cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03a8cc7df1d65554a4d40825b0490c93ac0f0236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03a8cc7df1d65554a4d40825b0490c93ac0f0236", "html_url": "https://github.com/rust-lang/rust/commit/03a8cc7df1d65554a4d40825b0490c93ac0f0236", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03a8cc7df1d65554a4d40825b0490c93ac0f0236/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1103d2e914b67c18b0deb86073c26c6aefda761d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1103d2e914b67c18b0deb86073c26c6aefda761d", "html_url": "https://github.com/rust-lang/rust/commit/1103d2e914b67c18b0deb86073c26c6aefda761d"}, {"sha": "80f56cdc2a749f1262518d2aa7597cf908b9e059", "url": "https://api.github.com/repos/rust-lang/rust/commits/80f56cdc2a749f1262518d2aa7597cf908b9e059", "html_url": "https://github.com/rust-lang/rust/commit/80f56cdc2a749f1262518d2aa7597cf908b9e059"}], "stats": {"total": 499, "additions": 289, "deletions": 210}, "files": [{"sha": "baa59efbf8df24861aaed0e184b44e2e3da0d4e8", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -2298,7 +2298,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // Closure arguments are wrapped in a tuple, so we need to get the first\n                 // from that.\n                 if let ty::Tuple(elems) = argument_ty.kind() {\n-                    let argument_ty = elems.first()?.expect_ty();\n+                    let &argument_ty = elems.first()?;\n                     if let ty::Ref(_, _, _) = argument_ty.kind() {\n                         return Some(AnnotatedBorrowFnSignature::Closure {\n                             argument_ty,"}, {"sha": "5d1d291d3b4338194b6b57fb8a0f710605eedfdd", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -480,7 +480,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> = &mut vec![(ty, hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n-            match (&ty.kind(), &hir_ty.kind) {\n+            match (ty.kind(), &hir_ty.kind) {\n                 // Check if the `ty` is `&'X ..` where `'X`\n                 // is the region we are looking for -- if so, and we have a `&T`\n                 // on the RHS, then we want to highlight the `&` like so:\n@@ -532,9 +532,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 // The following cases don't have lifetimes, so we\n                 // just worry about trying to match up the rustc type\n                 // with the HIR types:\n-                (ty::Tuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n-                    search_stack\n-                        .extend(iter::zip(elem_tys.iter().map(|k| k.expect_ty()), *elem_hir_tys));\n+                (&ty::Tuple(elem_tys), hir::TyKind::Tup(elem_hir_tys)) => {\n+                    search_stack.extend(iter::zip(elem_tys, *elem_hir_tys));\n                 }\n \n                 (ty::Slice(elem_ty), hir::TyKind::Slice(elem_hir_ty))"}, {"sha": "b87a9e6567bbbfac6012a74644c26105898eb5af", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -832,9 +832,10 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                     return match substs\n                         .as_closure()\n                         .tupled_upvars_ty()\n-                        .tuple_element_ty(field.index())\n+                        .tuple_fields()\n+                        .get(field.index())\n                     {\n-                        Some(ty) => Ok(ty),\n+                        Some(&ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange {\n                             field_count: substs.as_closure().upvar_tys().count(),\n                         }),\n@@ -852,7 +853,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }\n                 ty::Tuple(tys) => {\n                     return match tys.get(field.index()) {\n-                        Some(&ty) => Ok(ty.expect_ty()),\n+                        Some(&ty) => Ok(ty),\n                         None => Err(FieldAccessError::OutOfRange { field_count: tys.len() }),\n                     };\n                 }"}, {"sha": "d21a9d86e5b8b4e176b7d3b424f05f9253de29e5", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -641,15 +641,13 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let (&output, tuplized_inputs) =\n                     inputs_and_output.skip_binder().split_last().unwrap();\n                 assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n-                let ty::Tuple(inputs) = tuplized_inputs[0].kind() else {\n+                let &ty::Tuple(inputs) = tuplized_inputs[0].kind() else {\n                     bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]);\n                 };\n \n                 ty::Binder::bind_with_vars(\n                     tcx.mk_type_list(\n-                        iter::once(closure_ty)\n-                            .chain(inputs.iter().map(|k| k.expect_ty()))\n-                            .chain(iter::once(output)),\n+                        iter::once(closure_ty).chain(inputs).chain(iter::once(output)),\n                     ),\n                     bound_vars,\n                 )"}, {"sha": "a249e5fa8ac9c78b9f996f25d976e7585381afca", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n             .unzip();\n         let return_layout = self.layout_of(return_ty);\n         let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.types().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n+            tup.iter().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n         } else {\n             vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n         };\n@@ -199,7 +199,7 @@ pub(crate) fn codegen_fn_prelude<'tcx>(fx: &mut FunctionCx<'_, '_, 'tcx>, start_\n                 };\n \n                 let mut params = Vec::new();\n-                for (i, _arg_ty) in tupled_arg_tys.types().enumerate() {\n+                for (i, _arg_ty) in tupled_arg_tys.iter().enumerate() {\n                     let arg_abi = arg_abis_iter.next().unwrap();\n                     let param =\n                         cvalue_for_param(fx, Some(local), Some(i), arg_abi, &mut block_params_iter);"}, {"sha": "d3e36be3244f1da891df8b93f97b1d6113c50b76", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -90,10 +90,9 @@ fn clif_pair_type_from_ty<'tcx>(\n     ty: Ty<'tcx>,\n ) -> Option<(types::Type, types::Type)> {\n     Some(match ty.kind() {\n-        ty::Tuple(substs) if substs.len() == 2 => {\n-            let mut types = substs.types();\n-            let a = clif_type_from_ty(tcx, types.next().unwrap())?;\n-            let b = clif_type_from_ty(tcx, types.next().unwrap())?;\n+        ty::Tuple(types) if types.len() == 2 => {\n+            let a = clif_type_from_ty(tcx, types[0])?;\n+            let b = clif_type_from_ty(tcx, types[1])?;\n             if a.is_vector() || b.is_vector() {\n                 return None;\n             }"}, {"sha": "ef87b7b1a7e07557b7854a374e236c60d0766fc1", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -752,9 +752,8 @@ pub fn type_metadata<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, t: Ty<'tcx>) -> &'ll\n                 prepare_enum_metadata(cx, t, def.did, unique_type_id, vec![]).finalize(cx)\n             }\n         },\n-        ty::Tuple(elements) => {\n-            let tys: Vec<_> = elements.iter().map(|k| k.expect_ty()).collect();\n-            prepare_tuple_metadata(cx, t, &tys, unique_type_id, NO_SCOPE_METADATA).finalize(cx)\n+        ty::Tuple(tys) => {\n+            prepare_tuple_metadata(cx, t, tys, unique_type_id, NO_SCOPE_METADATA).finalize(cx)\n         }\n         // Type parameters from polymorphized functions.\n         ty::Param(_) => MetadataCreationResult::new(param_type_metadata(cx, t), false),"}, {"sha": "1561277b7049f1b9b3f50b2d9848938ff49f884f", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -86,7 +86,7 @@ fn push_debuginfo_type_name<'tcx>(\n             }\n \n             for component_type in component_types {\n-                push_debuginfo_type_name(tcx, component_type.expect_ty(), true, output, visited);\n+                push_debuginfo_type_name(tcx, component_type, true, output, visited);\n                 push_arg_separator(cpp_like_debuginfo, output);\n             }\n             if !component_types.is_empty() {"}, {"sha": "c42ff168d8c65d292adc60a6e6165aead3a55bb1", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -69,7 +69,7 @@ use rustc_middle::ty::{\n     self,\n     error::TypeError,\n     subst::{GenericArgKind, Subst, SubstsRef},\n-    Binder, Region, Ty, TyCtxt, TypeFoldable,\n+    Binder, List, Region, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::{sym, BytePos, DesugaringKind, MultiSpan, Pos, Span};\n use rustc_target::spec::abi;\n@@ -1361,7 +1361,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let mut values =\n                     (DiagnosticStyledString::normal(\"(\"), DiagnosticStyledString::normal(\"(\"));\n                 let len = substs1.len();\n-                for (i, (left, right)) in substs1.types().zip(substs2.types()).enumerate() {\n+                for (i, (left, right)) in substs1.iter().zip(substs2).enumerate() {\n                     let (x1, x2) = self.cmp(left, right);\n                     (values.0).0.extend(x1.0);\n                     (values.1).0.extend(x2.0);\n@@ -2042,8 +2042,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // If a tuple of length one was expected and the found expression has\n                         // parentheses around it, perhaps the user meant to write `(expr,)` to\n                         // build a tuple (issue #86100)\n-                        (ty::Tuple(_), _) => {\n-                            self.emit_tuple_wrap_err(&mut err, span, found, expected)\n+                        (ty::Tuple(fields), _) => {\n+                            self.emit_tuple_wrap_err(&mut err, span, found, fields)\n                         }\n                         // If a character was expected and the found expression is a string literal\n                         // containing a single character, perhaps the user meant to write `'c'` to\n@@ -2111,12 +2111,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'tcx>,\n         span: Span,\n         found: Ty<'tcx>,\n-        expected: Ty<'tcx>,\n+        expected_fields: &List<Ty<'tcx>>,\n     ) {\n-        let [expected_tup_elem] = &expected.tuple_fields().collect::<Vec<_>>()[..]\n-            else { return };\n+        let [expected_tup_elem] = expected_fields[..] else { return };\n \n-        if !same_type_modulo_infer(*expected_tup_elem, found) {\n+        if !same_type_modulo_infer(expected_tup_elem, found) {\n             return;\n         }\n "}, {"sha": "1f5041301307a83ab6b3385a1c7ba78ac2753cd5", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -254,7 +254,9 @@ fn closure_args(fn_sig: &ty::PolyFnSig<'_>) -> String {\n         .skip_binder()\n         .iter()\n         .next()\n-        .map(|args| args.tuple_fields().map(|arg| arg.to_string()).collect::<Vec<_>>().join(\", \"))\n+        .map(|args| {\n+            args.tuple_fields().iter().map(|arg| arg.to_string()).collect::<Vec<_>>().join(\", \")\n+        })\n         .unwrap_or_default()\n }\n "}, {"sha": "30b5f9b34d099ac8bad304c2b0418501c8f28455", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -2621,7 +2621,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n                 }\n                 Tuple(..) => {\n                     // Proceed recursively, check all fields.\n-                    ty.tuple_fields().find_map(|field| ty_find_init_error(tcx, field, init))\n+                    ty.tuple_fields().iter().find_map(|field| ty_find_init_error(tcx, field, init))\n                 }\n                 // Conservative fallback.\n                 _ => None,\n@@ -2934,7 +2934,7 @@ impl ClashingExternDeclarations {\n                                 )\n                         }\n                         (Tuple(a_substs), Tuple(b_substs)) => {\n-                            a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n+                            a_substs.iter().eq_by(b_substs.iter(), |a_ty, b_ty| {\n                                 structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n                             })\n                         }"}, {"sha": "b71ffa43d85dc088bab45af9cf46f93440f57e1d", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -246,7 +246,7 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     } else {\n                         vec![]\n                     };\n-                    for (i, ty) in tys.iter().map(|k| k.expect_ty()).enumerate() {\n+                    for (i, ty) in tys.iter().enumerate() {\n                         let descr_post = &format!(\" in tuple element {}\", i);\n                         let span = *spans.get(i).unwrap_or(&span);\n                         if check_must_use_ty(cx, ty, expr, span, descr_pre, descr_post, plural_len)"}, {"sha": "935a9b8e95d6bee59b811ce1a6f7ce0b3c0ca282", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -428,7 +428,7 @@ fn use_verbose<'tcx>(ty: Ty<'tcx>, fn_def: bool) -> bool {\n         ty::Int(_) | ty::Uint(_) | ty::Bool | ty::Char | ty::Float(_) => false,\n         // Unit type\n         ty::Tuple(g_args) if g_args.is_empty() => false,\n-        ty::Tuple(g_args) => g_args.iter().any(|g_arg| use_verbose(g_arg.expect_ty(), fn_def)),\n+        ty::Tuple(g_args) => g_args.iter().any(|g_arg| use_verbose(g_arg, fn_def)),\n         ty::Array(ty, _) => use_verbose(ty, fn_def),\n         ty::FnDef(..) => fn_def,\n         _ => true,"}, {"sha": "23f9849e83171976a513b6bf710fe239f9a5f9ee", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                 let field_def = &variant_def.fields[f.index()];\n                 field_def.ty(tcx, substs)\n             }\n-            ty::Tuple(ref tys) => tys[f.index()].expect_ty(),\n+            ty::Tuple(tys) => tys[f.index()],\n             _ => bug!(\"extracting field of non-tuple non-adt: {:?}\", self),\n         };\n         debug!(\"field_ty self: {:?} f: {:?} yields: {:?}\", self, f, answer);"}, {"sha": "4b4fcaa9c1874af8557e595df5f4602e9d7b5be4", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 37, "deletions": 12, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -101,7 +101,6 @@ pub struct CtxtInterners<'tcx> {\n     // Specifically use a speedy hash algorithm for these hash sets, since\n     // they're accessed quite often.\n     type_: InternedSet<'tcx, TyS<'tcx>>,\n-    type_list: InternedSet<'tcx, List<Ty<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind>,\n@@ -129,7 +128,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arena,\n             type_: Default::default(),\n-            type_list: Default::default(),\n             substs: Default::default(),\n             region: Default::default(),\n             poly_existential_predicates: Default::default(),\n@@ -1657,6 +1655,8 @@ macro_rules! nop_lift {\n             type Lifted = $lifted;\n             fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n                 if tcx.interners.$set.contains_pointer_to(&InternedInSet(self.0.0)) {\n+                    // SAFETY: `self` is interned and therefore valid\n+                    // for the entire lifetime of the `TyCtxt`.\n                     Some(unsafe { mem::transmute(self) })\n                 } else {\n                     None\n@@ -1666,6 +1666,25 @@ macro_rules! nop_lift {\n     };\n }\n \n+// Can't use the macros as we have reuse the `substs` here.\n+//\n+// See `intern_type_list` for more info.\n+impl<'a, 'tcx> Lift<'tcx> for &'a List<Ty<'a>> {\n+    type Lifted = &'tcx List<Ty<'tcx>>;\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        if self.is_empty() {\n+            return Some(List::empty());\n+        }\n+        if tcx.interners.substs.contains_pointer_to(&InternedInSet(self.as_substs())) {\n+            // SAFETY: `self` is interned and therefore valid\n+            // for the entire lifetime of the `TyCtxt`.\n+            Some(unsafe { mem::transmute::<&'a List<Ty<'a>>, &'tcx List<Ty<'tcx>>>(self) })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n macro_rules! nop_list_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n@@ -1690,7 +1709,6 @@ nop_lift! {const_; Const<'a> => Const<'tcx>}\n nop_lift_old! {const_allocation; &'a Allocation => &'tcx Allocation}\n nop_lift! {predicate; Predicate<'a> => Predicate<'tcx>}\n \n-nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate<'a>> => ty::Binder<'tcx, ExistentialPredicate<'tcx>>}\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n nop_list_lift! {canonical_var_infos; CanonicalVarInfo<'a> => CanonicalVarInfo<'tcx>}\n@@ -2189,7 +2207,6 @@ macro_rules! slice_interners {\n }\n \n slice_interners!(\n-    type_list: _intern_type_list(Ty<'tcx>),\n     substs: _intern_substs(GenericArg<'tcx>),\n     canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo<'tcx>),\n     poly_existential_predicates:\n@@ -2259,7 +2276,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> PolyFnSig<'tcx> {\n         sig.map_bound(|s| {\n             let params_iter = match s.inputs()[0].kind() {\n-                ty::Tuple(params) => params.into_iter().map(|k| k.expect_ty()),\n+                ty::Tuple(params) => params.into_iter(),\n                 _ => bug!(),\n             };\n             self.mk_fn_sig(params_iter, s.output(), s.c_variadic, unsafety, abi::Abi::Rust)\n@@ -2421,15 +2438,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn intern_tup(self, ts: &[Ty<'tcx>]) -> Ty<'tcx> {\n-        let kinds: Vec<_> = ts.iter().map(|&t| GenericArg::from(t)).collect();\n-        self.mk_ty(Tuple(self.intern_substs(&kinds)))\n+        self.mk_ty(Tuple(self.intern_type_list(&ts)))\n     }\n \n     pub fn mk_tup<I: InternAs<[Ty<'tcx>], Ty<'tcx>>>(self, iter: I) -> I::Output {\n-        iter.intern_with(|ts| {\n-            let kinds: Vec<_> = ts.iter().map(|&t| GenericArg::from(t)).collect();\n-            self.mk_ty(Tuple(self.intern_substs(&kinds)))\n-        })\n+        iter.intern_with(|ts| self.mk_ty(Tuple(self.intern_type_list(&ts))))\n     }\n \n     #[inline]\n@@ -2611,7 +2624,19 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx List<Ty<'tcx>> {\n-        if ts.is_empty() { List::empty() } else { self._intern_type_list(ts) }\n+        if ts.is_empty() {\n+            List::empty()\n+        } else {\n+            // Actually intern type lists as lists of `GenericArg`s.\n+            //\n+            // Transmuting from `Ty<'tcx>` to `GenericArg<'tcx>` is sound\n+            // as explained in ty_slice_as_generic_arg`. With this,\n+            // we guarantee that even when transmuting between `List<Ty<'tcx>>`\n+            // and `List<GenericArg<'tcx>>`, the uniqueness requirement for\n+            // lists is upheld.\n+            let substs = self._intern_substs(ty::subst::ty_slice_as_generic_args(ts));\n+            substs.try_as_type_list().unwrap()\n+        }\n     }\n \n     pub fn intern_substs(self, ts: &[GenericArg<'tcx>]) -> &'tcx List<GenericArg<'tcx>> {"}, {"sha": "934a6a878feb52a27c4391aa42611dbe2549ced8", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -116,9 +116,10 @@ impl<'tcx> Ty<'tcx> {\n                 }\n                 _ => true,\n             }),\n-            Projection(ProjectionTy { substs: args, .. }) | Adt(_, args) | Tuple(args) => {\n+            Projection(ProjectionTy { substs: args, .. }) | Adt(_, args) => {\n                 args.iter().all(generic_arg_is_suggestible)\n             }\n+            Tuple(args) => args.iter().all(|ty| ty.is_suggestable()),\n             Slice(ty) | RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => ty.is_suggestable(),\n             Array(ty, c) => ty.is_suggestable() && const_is_suggestable(c.val()),\n             _ => true,"}, {"sha": "7a3d615862cbae4d20a7f6be3c76bfa0fc399d88", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -201,8 +201,8 @@ impl FlagComputation {\n                 self.add_ty(ty);\n             }\n \n-            &ty::Tuple(ref substs) => {\n-                self.add_substs(substs);\n+            &ty::Tuple(types) => {\n+                self.add_tys(types);\n             }\n \n             &ty::FnDef(_, substs) => {"}, {"sha": "54a345daec8a5b1815d8a667b33064a94de58a2c", "filename": "compiler/rustc_middle/src/ty/impls_ty.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fimpls_ty.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -61,6 +61,36 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArg<'t\n     }\n }\n \n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::subst::GenericArgKind<'tcx> {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        match self {\n+            // WARNING: We dedup cache the `HashStable` results for `List`\n+            // while ignoring types and freely transmute\n+            // between `List<Ty<'tcx>>` and `List<GenericArg<'tcx>>`.\n+            // See `fn intern_type_list` for more details.\n+            //\n+            // We therefore hash types without adding a hash for their discriminant.\n+            //\n+            // In order to make it very unlikely for the sequence of bytes being hashed for\n+            // a `GenericArgKind::Type` to be the same as the sequence of bytes being\n+            // hashed for one of the other variants, we hash a `0xFF` byte before hashing\n+            // their discriminant (since the discriminant of `TyKind` is unlikely to ever start\n+            // with 0xFF).\n+            ty::subst::GenericArgKind::Type(ty) => ty.hash_stable(hcx, hasher),\n+            ty::subst::GenericArgKind::Const(ct) => {\n+                0xFFu8.hash_stable(hcx, hasher);\n+                mem::discriminant(self).hash_stable(hcx, hasher);\n+                ct.hash_stable(hcx, hasher);\n+            }\n+            ty::subst::GenericArgKind::Lifetime(lt) => {\n+                0xFFu8.hash_stable(hcx, hasher);\n+                mem::discriminant(self).hash_stable(hcx, hasher);\n+                lt.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         mem::discriminant(self).hash_stable(hcx, hasher);"}, {"sha": "e2289b44b5c5b554891197bded06df5d4e43f91b", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -207,10 +207,9 @@ pub(crate) fn type_uninhabited_from<'tcx>(\n \n         Never => DefIdForest::full(),\n \n-        Tuple(ref tys) => DefIdForest::union(\n-            tcx,\n-            tys.iter().map(|ty| ty.expect_ty().uninhabited_from(tcx, param_env)),\n-        ),\n+        Tuple(ref tys) => {\n+            DefIdForest::union(tcx, tys.iter().map(|ty| ty.uninhabited_from(tcx, param_env)))\n+        }\n \n         Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n             Some(0) | None => DefIdForest::empty(),"}, {"sha": "4c4271662032d892583b28059eb5f173954c3d7f", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -628,7 +628,7 @@ fn polymorphize<'tcx>(\n     } else {\n         None\n     };\n-    let has_upvars = upvars_ty.map_or(false, |ty| ty.tuple_fields().count() > 0);\n+    let has_upvars = upvars_ty.map_or(false, |ty| !ty.tuple_fields().is_empty());\n     debug!(\"polymorphize: upvars_ty={:?} has_upvars={:?}\", upvars_ty, has_upvars);\n \n     struct PolymorphizationFolder<'tcx> {"}, {"sha": "b7b36c4945978cb4ceeda90f0ad3de78fdf3e5e3", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -712,9 +712,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     if tys.len() == 0 { StructKind::AlwaysSized } else { StructKind::MaybeUnsized };\n \n                 univariant(\n-                    &tys.iter()\n-                        .map(|k| self.layout_of(k.expect_ty()))\n-                        .collect::<Result<Vec<_>, _>>()?,\n+                    &tys.iter().map(|k| self.layout_of(k)).collect::<Result<Vec<_>, _>>()?,\n                     &ReprOptions::default(),\n                     kind,\n                 )?\n@@ -2382,7 +2380,7 @@ where\n                     }\n                 },\n \n-                ty::Tuple(tys) => TyMaybeWithLayout::Ty(tys[i].expect_ty()),\n+                ty::Tuple(tys) => TyMaybeWithLayout::Ty(tys[i]),\n \n                 // ADTs.\n                 ty::Adt(def, substs) => {\n@@ -3012,7 +3010,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             if let Some(input) = sig.inputs().last() {\n                 if let ty::Tuple(tupled_arguments) = input.kind() {\n                     inputs = &sig.inputs()[0..sig.inputs().len() - 1];\n-                    tupled_arguments.iter().map(|k| k.expect_ty()).collect()\n+                    tupled_arguments\n                 } else {\n                     bug!(\n                         \"argument to function with \\\"rust-call\\\" ABI \\\n@@ -3027,7 +3025,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n         } else {\n             assert!(sig.c_variadic || extra_args.is_empty());\n-            extra_args.to_vec()\n+            extra_args\n         };\n \n         let target = &self.tcx.sess.target;\n@@ -3155,8 +3153,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             ret: arg_of(sig.output(), None)?,\n             args: inputs\n                 .iter()\n-                .cloned()\n-                .chain(extra_args)\n+                .copied()\n+                .chain(extra_args.iter().copied())\n                 .chain(caller_location)\n                 .enumerate()\n                 .map(|(i, ty)| arg_of(ty, Some(i)))"}, {"sha": "8d7f6d84c7c38d8090e331143508442bd4c7cc9d", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -287,7 +287,6 @@ fn characteristic_def_id_of_type_cached<'a>(\n         ty::Ref(_, ty, _) => characteristic_def_id_of_type_cached(ty, visited),\n \n         ty::Tuple(ref tys) => tys.iter().find_map(|ty| {\n-            let ty = ty.expect_ty();\n             if visited.insert(ty) {\n                 return characteristic_def_id_of_type_cached(ty, visited);\n             }"}, {"sha": "5c5d059878179e0650419b5c0a407d390363cb23", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -845,7 +845,7 @@ pub trait PrettyPrinter<'tcx>:\n                         write(\"{}{}(\", if paren_needed { \"(\" } else { \"\" }, name)\n                     );\n \n-                    for (idx, ty) in arg_tys.tuple_fields().enumerate() {\n+                    for (idx, ty) in arg_tys.tuple_fields().iter().enumerate() {\n                         if idx > 0 {\n                             p!(\", \");\n                         }\n@@ -1032,12 +1032,11 @@ pub trait PrettyPrinter<'tcx>:\n                 // Special-case `Fn(...) -> ...` and resugar it.\n                 let fn_trait_kind = cx.tcx().fn_trait_kind_from_lang_item(principal.def_id);\n                 if !cx.tcx().sess.verbose() && fn_trait_kind.is_some() {\n-                    if let ty::Tuple(ref args) = principal.substs.type_at(0).kind() {\n+                    if let ty::Tuple(tys) = principal.substs.type_at(0).kind() {\n                         let mut projections = predicates.projection_bounds();\n                         if let (Some(proj), None) = (projections.next(), projections.next()) {\n-                            let tys: Vec<_> = args.iter().map(|k| k.expect_ty()).collect();\n                             p!(pretty_fn_sig(\n-                                &tys,\n+                                tys,\n                                 false,\n                                 proj.skip_binder().term.ty().expect(\"Return type was a const\")\n                             ));"}, {"sha": "42ddbcc1e2f3b839d4618fe1966fa2d8893319ef", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -501,9 +501,7 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n \n         (&ty::Tuple(as_), &ty::Tuple(bs)) => {\n             if as_.len() == bs.len() {\n-                Ok(tcx.mk_tup(\n-                    iter::zip(as_, bs).map(|(a, b)| relation.relate(a.expect_ty(), b.expect_ty())),\n-                )?)\n+                Ok(tcx.mk_tup(iter::zip(as_, bs).map(|(a, b)| relation.relate(a, b)))?)\n             } else if !(as_.is_empty() || bs.is_empty()) {\n                 Err(TypeError::TupleSize(expected_found(relation, as_.len(), bs.len())))\n             } else {"}, {"sha": "42d7b141166f478b3d119a4196d6281f2b96a082", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -889,19 +889,6 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::Existentia\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n-    fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n-        self,\n-        folder: &mut F,\n-    ) -> Result<Self, F::Error> {\n-        ty::util::fold_list(self, folder, |tcx, v| tcx.intern_type_list(v))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        self.iter().try_for_each(|t| t.visit_with(visitor))\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n     fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n         self,"}, {"sha": "02a4df637d88946b25ac850550ca5d0bafeb44c4", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -200,8 +200,7 @@ pub enum TyKind<'tcx> {\n     Never,\n \n     /// A tuple type. For example, `(i32, bool)`.\n-    /// Use `Ty::tuple_fields` to iterate over the field types.\n-    Tuple(SubstsRef<'tcx>),\n+    Tuple(&'tcx List<Ty<'tcx>>),\n \n     /// The projection of an associated type. For example,\n     /// `<T as Trait<..>>::N`.\n@@ -2155,18 +2154,9 @@ impl<'tcx> Ty<'tcx> {\n \n     /// Iterates over tuple fields.\n     /// Panics when called on anything but a tuple.\n-    pub fn tuple_fields(self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> {\n+    pub fn tuple_fields(self) -> &'tcx List<Ty<'tcx>> {\n         match self.kind() {\n-            Tuple(substs) => substs.iter().map(|field| field.expect_ty()),\n-            _ => bug!(\"tuple_fields called on non-tuple\"),\n-        }\n-    }\n-\n-    /// Get the `i`-th element of a tuple.\n-    /// Panics when called on anything but a tuple.\n-    pub fn tuple_element_ty(self, i: usize) -> Option<Ty<'tcx>> {\n-        match self.kind() {\n-            Tuple(substs) => substs.iter().nth(i).map(|field| field.expect_ty()),\n+            Tuple(substs) => substs,\n             _ => bug!(\"tuple_fields called on non-tuple\"),\n         }\n     }\n@@ -2367,7 +2357,7 @@ impl<'tcx> Ty<'tcx> {\n \n             ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => false,\n \n-            ty::Tuple(tys) => tys.iter().all(|ty| ty.expect_ty().is_trivially_sized(tcx)),\n+            ty::Tuple(tys) => tys.iter().all(|ty| ty.is_trivially_sized(tcx)),\n \n             ty::Adt(def, _substs) => def.sized_constraint(tcx).is_empty(),\n "}, {"sha": "364ba07a44167affe43aaf9913de32cdd1f0a612", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -20,6 +20,7 @@ use std::marker::PhantomData;\n use std::mem;\n use std::num::NonZeroUsize;\n use std::ops::ControlFlow;\n+use std::slice;\n \n /// An entity in the Rust type system, which can be one of\n /// several kinds (types, lifetimes, and consts).\n@@ -40,13 +41,38 @@ const TYPE_TAG: usize = 0b00;\n const REGION_TAG: usize = 0b01;\n const CONST_TAG: usize = 0b10;\n \n-#[derive(Debug, TyEncodable, TyDecodable, PartialEq, Eq, PartialOrd, Ord, HashStable)]\n+#[derive(Debug, TyEncodable, TyDecodable, PartialEq, Eq, PartialOrd, Ord)]\n pub enum GenericArgKind<'tcx> {\n     Lifetime(ty::Region<'tcx>),\n     Type(Ty<'tcx>),\n     Const(ty::Const<'tcx>),\n }\n \n+/// This function goes from `&'a [Ty<'tcx>]` to `&'a [GenericArg<'tcx>]`\n+///\n+/// This is sound as, for types, `GenericArg` is just\n+/// `NonZeroUsize::new_unchecked(ty as *const _ as usize)` as\n+/// long as we use `0` for the `TYPE_TAG`.\n+pub fn ty_slice_as_generic_args<'a, 'tcx>(ts: &'a [Ty<'tcx>]) -> &'a [GenericArg<'tcx>] {\n+    assert_eq!(TYPE_TAG, 0);\n+    // SAFETY: the whole slice is valid and immutable.\n+    // `Ty` and `GenericArg` is explained above.\n+    unsafe { slice::from_raw_parts(ts.as_ptr().cast(), ts.len()) }\n+}\n+\n+impl<'tcx> List<Ty<'tcx>> {\n+    /// Allows to freely switch betwen `List<Ty<'tcx>>` and `List<GenericArg<'tcx>>`.\n+    ///\n+    /// As lists are interned, `List<Ty<'tcx>>` and `List<GenericArg<'tcx>>` have\n+    /// be interned together, see `intern_type_list` for more details.\n+    #[inline]\n+    pub fn as_substs(&'tcx self) -> SubstsRef<'tcx> {\n+        assert_eq!(TYPE_TAG, 0);\n+        // SAFETY: `List<T>` is `#[repr(C)]`. `Ty` and `GenericArg` is explained above.\n+        unsafe { &*(self as *const List<Ty<'tcx>> as *const List<GenericArg<'tcx>>) }\n+    }\n+}\n+\n impl<'tcx> GenericArgKind<'tcx> {\n     #[inline]\n     fn pack(self) -> GenericArg<'tcx> {\n@@ -208,6 +234,17 @@ pub type InternalSubsts<'tcx> = List<GenericArg<'tcx>>;\n pub type SubstsRef<'tcx> = &'tcx InternalSubsts<'tcx>;\n \n impl<'a, 'tcx> InternalSubsts<'tcx> {\n+    /// Checks whether all elements of this list are types, if so, transmute.\n+    pub fn try_as_type_list(&'tcx self) -> Option<&'tcx List<Ty<'tcx>>> {\n+        if self.iter().all(|arg| matches!(arg.unpack(), GenericArgKind::Type(_))) {\n+            assert_eq!(TYPE_TAG, 0);\n+            // SAFETY: All elements are types, see `List<Ty<'tcx>>::as_substs`.\n+            Some(unsafe { &*(self as *const List<GenericArg<'tcx>> as *const List<Ty<'tcx>>) })\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Interpret these substitutions as the substitutions of a closure type.\n     /// Closure substitutions have a particular structure controlled by the\n     /// compiler that encodes information like the signature and closure kind;\n@@ -422,6 +459,45 @@ impl<'tcx> TypeFoldable<'tcx> for SubstsRef<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n+    fn try_super_fold_with<F: FallibleTypeFolder<'tcx>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        // This code is fairly hot, though not as hot as `SubstsRef`.\n+        //\n+        // When compiling stage 2, I get the following results:\n+        //\n+        // len |   total   |   %\n+        // --- | --------- | -----\n+        //  2  |  15083590 |  48.1\n+        //  3  |   7540067 |  24.0\n+        //  1  |   5300377 |  16.9\n+        //  4  |   1351897 |   4.3\n+        //  0  |   1256849 |   4.0\n+        //\n+        // I've tried it with some private repositories and got\n+        // close to the same result, with 4 and 0 swapping places\n+        // sometimes.\n+        match self.len() {\n+            2 => {\n+                let param0 = self[0].try_fold_with(folder)?;\n+                let param1 = self[1].try_fold_with(folder)?;\n+                if param0 == self[0] && param1 == self[1] {\n+                    Ok(self)\n+                } else {\n+                    Ok(folder.tcx().intern_type_list(&[param0, param1]))\n+                }\n+            }\n+            _ => ty::util::fold_list(self, folder, |tcx, v| tcx.intern_type_list(v)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n //"}, {"sha": "c13aecd1b14aa3b9f89e1493f4b7ca71f7e74deb", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -248,7 +248,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 }\n \n                 ty::Tuple(tys) if let Some((&last_ty, _)) = tys.split_last() => {\n-                    ty = last_ty.expect_ty();\n+                    ty = last_ty;\n                 }\n \n                 ty::Tuple(_) => break,\n@@ -319,9 +319,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n                 (&Tuple(a_tys), &Tuple(b_tys)) if a_tys.len() == b_tys.len() => {\n-                    if let Some(a_last) = a_tys.last() {\n-                        a = a_last.expect_ty();\n-                        b = b_tys.last().unwrap().expect_ty();\n+                    if let Some(&a_last) = a_tys.last() {\n+                        a = a_last;\n+                        b = *b_tys.last().unwrap();\n                     } else {\n                         break;\n                     }\n@@ -746,7 +746,7 @@ impl<'tcx> Ty<'tcx> {\n             | ty::FnDef(..)\n             | ty::Error(_)\n             | ty::FnPtr(_) => true,\n-            ty::Tuple(_) => self.tuple_fields().all(|f| Self::is_trivially_freeze(f)),\n+            ty::Tuple(fields) => fields.iter().all(Self::is_trivially_freeze),\n             ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_freeze(),\n             ty::Adt(..)\n             | ty::Bound(..)\n@@ -786,7 +786,7 @@ impl<'tcx> Ty<'tcx> {\n             | ty::FnDef(..)\n             | ty::Error(_)\n             | ty::FnPtr(_) => true,\n-            ty::Tuple(_) => self.tuple_fields().all(|f| Self::is_trivially_unpin(f)),\n+            ty::Tuple(fields) => fields.iter().all(Self::is_trivially_unpin),\n             ty::Slice(elem_ty) | ty::Array(elem_ty, _) => elem_ty.is_trivially_unpin(),\n             ty::Adt(..)\n             | ty::Bound(..)\n@@ -1042,7 +1042,7 @@ pub fn needs_drop_components<'tcx>(\n             }\n         }\n         // If any field needs drop, then the whole tuple does.\n-        ty::Tuple(..) => ty.tuple_fields().try_fold(SmallVec::new(), move |mut acc, elem| {\n+        ty::Tuple(fields) => fields.iter().try_fold(SmallVec::new(), move |mut acc, elem| {\n             acc.extend(needs_drop_components(elem, target_layout)?);\n             Ok(acc)\n         }),\n@@ -1092,7 +1092,7 @@ pub fn is_trivially_const_drop<'tcx>(ty: Ty<'tcx>) -> bool {\n \n         ty::Array(ty, _) | ty::Slice(ty) => is_trivially_const_drop(ty),\n \n-        ty::Tuple(tys) => tys.iter().all(|ty| is_trivially_const_drop(ty.expect_ty())),\n+        ty::Tuple(tys) => tys.iter().all(|ty| is_trivially_const_drop(ty)),\n     }\n }\n "}, {"sha": "9f57e1a977a93ecff4ecb94d3ccd8ac20913c286", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -175,10 +175,10 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n             | ty::Opaque(_, substs)\n             | ty::Closure(_, substs)\n             | ty::Generator(_, substs, _)\n-            | ty::Tuple(substs)\n             | ty::FnDef(_, substs) => {\n                 stack.extend(substs.iter().rev());\n             }\n+            ty::Tuple(ts) => stack.extend(ts.as_substs().iter().rev()),\n             ty::GeneratorWitness(ts) => {\n                 stack.extend(ts.skip_binder().iter().rev().map(|ty| ty.into()));\n             }"}, {"sha": "389f711099ba085a83376a855fb834058ea22e22", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -256,7 +256,7 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n             // We must have inferred the capture types since we are building MIR, therefore\n             // it's safe to call `tuple_element_ty` and we can unwrap here because\n             // we know that the capture exists and is the `capture_index`-th capture.\n-            let var_ty = substs.tupled_upvars_ty().tuple_element_ty(capture_index).unwrap();\n+            let var_ty = substs.tupled_upvars_ty().tuple_fields()[capture_index];\n \n             upvar_resolved_place_builder =\n                 upvar_resolved_place_builder.field(Field::new(capture_index), var_ty);"}, {"sha": "1c4c668c0f27370938d2a6329ec1b955757c8d92", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -1209,7 +1209,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     ) -> Self {\n         let ret = match constructor {\n             Single | Variant(_) => match ty.kind() {\n-                ty::Tuple(fs) => Fields::wildcards_from_tys(cx, fs.iter().map(|ty| ty.expect_ty())),\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(cx, fs.iter()),\n                 ty::Ref(_, rty, _) => Fields::wildcards_from_tys(cx, once(*rty)),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n@@ -1315,11 +1315,8 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                 match pat.ty.kind() {\n                     ty::Tuple(fs) => {\n                         ctor = Single;\n-                        let mut wilds: SmallVec<[_; 2]> = fs\n-                            .iter()\n-                            .map(|ty| ty.expect_ty())\n-                            .map(DeconstructedPat::wildcard)\n-                            .collect();\n+                        let mut wilds: SmallVec<[_; 2]> =\n+                            fs.iter().map(DeconstructedPat::wildcard).collect();\n                         for pat in subpatterns {\n                             wilds[pat.field.index()] = mkpat(&pat.pattern);\n                         }"}, {"sha": "774df75211364a2d98794f36faeef621b8536744", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -866,10 +866,7 @@ where\n                 let tys: Vec<_> = substs.as_generator().upvar_tys().collect();\n                 self.open_drop_for_tuple(&tys)\n             }\n-            ty::Tuple(..) => {\n-                let tys: Vec<_> = ty.tuple_fields().collect();\n-                self.open_drop_for_tuple(&tys)\n-            }\n+            ty::Tuple(fields) => self.open_drop_for_tuple(fields),\n             ty::Adt(def, substs) => {\n                 if def.is_box() {\n                     self.open_drop_for_box(def, substs)"}, {"sha": "6075f572a651c21a3f58e21c8949ac527d15bd4f", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -843,12 +843,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     // FIXME: enable the general case stated above ^.\n                     let ty = value.layout.ty;\n                     // Only do it for tuples\n-                    if let ty::Tuple(substs) = ty.kind() {\n+                    if let ty::Tuple(types) = ty.kind() {\n                         // Only do it if tuple is also a pair with two scalars\n-                        if substs.len() == 2 {\n+                        if let [ty1, ty2] = types[..] {\n                             let alloc = self.use_ecx(|this| {\n-                                let ty1 = substs[0].expect_ty();\n-                                let ty2 = substs[1].expect_ty();\n                                 let ty_is_scalar = |ty| {\n                                     this.ecx.layout_of(ty).ok().map(|layout| layout.abi.is_scalar())\n                                         == Some(true)"}, {"sha": "6078abcbb8f3b78ee4978b4a08edef85dbd24f91", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -692,8 +692,7 @@ impl<'tcx> Inliner<'tcx> {\n             // The `tmp0`, `tmp1`, and `tmp2` in our example abonve.\n             let tuple_tmp_args = tuple_tys.iter().enumerate().map(|(i, ty)| {\n                 // This is e.g., `tuple_tmp.0` in our example above.\n-                let tuple_field =\n-                    Operand::Move(tcx.mk_place_field(tuple, Field::new(i), ty.expect_ty()));\n+                let tuple_field = Operand::Move(tcx.mk_place_field(tuple, Field::new(i), ty));\n \n                 // Spill to a local to make e.g., `tmp0`.\n                 self.create_temp_if_necessary(tuple_field, callsite, caller_body)"}, {"sha": "6d082748939ac4118a161ec9caeab9ec0687a4e8", "filename": "compiler/rustc_mir_transform/src/remove_uninit_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fremove_uninit_drops.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -148,8 +148,8 @@ fn is_needs_drop_and_init<'tcx>(\n             })\n         }\n \n-        ty::Tuple(_) => ty\n-            .tuple_fields()\n+        ty::Tuple(fields) => fields\n+            .iter()\n             .enumerate()\n             .map(|(f, f_ty)| (Field::from_usize(f), f_ty, mpi))\n             .any(field_needs_drop_and_init),"}, {"sha": "9533e869bc59682a9c6b72f34c15aa58010b14b6", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -461,10 +461,10 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n \n     fn tuple_like_shim<I>(&mut self, dest: Place<'tcx>, src: Place<'tcx>, tys: I)\n     where\n-        I: Iterator<Item = Ty<'tcx>>,\n+        I: IntoIterator<Item = Ty<'tcx>>,\n     {\n         let mut previous_field = None;\n-        for (i, ity) in tys.enumerate() {\n+        for (i, ity) in tys.into_iter().enumerate() {\n             let field = Field::new(i);\n             let src_field = self.tcx.mk_place_field(src, field, ity);\n "}, {"sha": "62b5436142f5a35bafd3a418017718bd10429337", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -446,7 +446,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n             ty::Tuple(tys) => {\n                 self.push(\"T\");\n-                for ty in tys.iter().map(|k| k.expect_ty()) {\n+                for ty in tys.iter() {\n                     self = ty.print(self)?;\n                 }\n                 self.push(\"E\");"}, {"sha": "8746d66ebb6e5ca0ae3911b602bf9edbc87e4db1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -834,10 +834,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n                 let expected = match expected_ty.kind() {\n-                    ty::Tuple(ref tys) => tys\n-                        .iter()\n-                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n-                        .collect(),\n+                    ty::Tuple(ref tys) => {\n+                        tys.iter().map(|t| ArgKind::from_expected_ty(t, Some(span))).collect()\n+                    }\n                     _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n                 };\n "}, {"sha": "e162e943e363bfec81c00befb0052af00e961c88", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -1301,7 +1301,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     if tcx.fn_trait_kind_from_lang_item(trait_ref.def_id()).is_some() =>\n                 {\n                     tcx.mk_fn_sig(\n-                        inputs.iter().map(|k| k.expect_ty()),\n+                        inputs.iter(),\n                         tcx.mk_ty_infer(ty::TyVar(ty::TyVid::from_u32(0))),\n                         false,\n                         hir::Unsafety::Normal,"}, {"sha": "066f3ffada57a3ee0ce0b95a76bb52f939bd28ee", "filename": "compiler/rustc_trait_selection/src/traits/query/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -108,7 +108,7 @@ pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n \n         // (T1..Tn) and closures have same properties as T1..Tn --\n         // check if *any* of those are trivial.\n-        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n+        ty::Tuple(tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t)),\n         ty::Closure(_, ref substs) => {\n             trivial_dropck_outlives(tcx, substs.as_closure().tupled_upvars_ty())\n         }"}, {"sha": "56d7f301b854e1a3280b38be1bd7e4bb228945cc", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -1015,9 +1015,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // Check that the source tuple with the target's\n                 // last element is equal to the target.\n-                let new_tuple = tcx.mk_tup(\n-                    a_mid.iter().map(|k| k.expect_ty()).chain(iter::once(b_last.expect_ty())),\n-                );\n+                let new_tuple = tcx.mk_tup(a_mid.iter().copied().chain(iter::once(b_last)));\n                 let InferOk { obligations, .. } = self\n                     .infcx\n                     .at(&obligation.cause, obligation.param_env)\n@@ -1033,8 +1031,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         obligation.cause.clone(),\n                         obligation.predicate.def_id(),\n                         obligation.recursion_depth + 1,\n-                        a_last.expect_ty(),\n-                        &[b_last],\n+                        a_last,\n+                        &[b_last.into()],\n                     )\n                 }));\n             }\n@@ -1097,7 +1095,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     stack.push(ty);\n                 }\n                 ty::Tuple(tys) => {\n-                    stack.extend(tys.iter().map(|ty| ty.expect_ty()));\n+                    stack.extend(tys.iter());\n                 }\n                 ty::Closure(_, substs) => {\n                     stack.push(substs.as_closure().tupled_upvars_ty());"}, {"sha": "0ed29036e4bdbbcd66ff3a04b118c1b94ef447b7", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -1852,9 +1852,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => None,\n \n             ty::Tuple(tys) => Where(\n-                obligation\n-                    .predicate\n-                    .rebind(tys.last().into_iter().map(|k| k.expect_ty()).collect()),\n+                obligation.predicate.rebind(tys.last().map_or_else(Vec::new, |&last| vec![last])),\n             ),\n \n             ty::Adt(def, substs) => {\n@@ -1917,7 +1915,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Tuple(tys) => {\n                 // (*) binder moved here\n-                Where(obligation.predicate.rebind(tys.iter().map(|k| k.expect_ty()).collect()))\n+                Where(obligation.predicate.rebind(tys.iter().collect()))\n             }\n \n             ty::Closure(_, substs) => {\n@@ -1997,7 +1995,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Tuple(ref tys) => {\n                 // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                t.rebind(tys.iter().map(|k| k.expect_ty()).collect())\n+                t.rebind(tys.iter().collect())\n             }\n \n             ty::Closure(_, ref substs) => {"}, {"sha": "7da5c50d2307d3ee2051dbe927fa6f710a76539e", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -529,8 +529,8 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n                 ty::Tuple(ref tys) => {\n                     if let Some((_last, rest)) = tys.split_last() {\n-                        for elem in rest {\n-                            self.require_sized(elem.expect_ty(), traits::TupleElem);\n+                        for &elem in rest {\n+                            self.require_sized(elem, traits::TupleElem);\n                         }\n                     }\n                 }"}, {"sha": "8d4b97571a6a33c7d069df56513b10f35b2b438f", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -565,7 +565,7 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         // FIXME(chalk): actually get hidden ty\n         self.interner\n             .tcx\n-            .mk_ty(ty::Tuple(self.interner.tcx.intern_substs(&[])))\n+            .mk_ty(ty::Tuple(self.interner.tcx.intern_type_list(&[])))\n             .lower_into(self.interner)\n     }\n "}, {"sha": "2cd179526bf13c2bb48a8105a62773b558fcd035", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -326,7 +326,9 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             ty::Generator(_def_id, _substs, _) => unimplemented!(),\n             ty::GeneratorWitness(_) => unimplemented!(),\n             ty::Never => chalk_ir::TyKind::Never,\n-            ty::Tuple(substs) => chalk_ir::TyKind::Tuple(substs.len(), substs.lower_into(interner)),\n+            ty::Tuple(types) => {\n+                chalk_ir::TyKind::Tuple(types.len(), types.as_substs().lower_into(interner))\n+            }\n             ty::Projection(proj) => chalk_ir::TyKind::Alias(proj.lower_into(interner)),\n             ty::Opaque(def_id, substs) => {\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n@@ -398,7 +400,9 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n             TyKind::Generator(..) => unimplemented!(),\n             TyKind::GeneratorWitness(..) => unimplemented!(),\n             TyKind::Never => ty::Never,\n-            TyKind::Tuple(_len, substitution) => ty::Tuple(substitution.lower_into(interner)),\n+            TyKind::Tuple(_len, substitution) => {\n+                ty::Tuple(substitution.lower_into(interner).try_as_type_list().unwrap())\n+            }\n             TyKind::Slice(ty) => ty::Slice(ty.lower_into(interner)),\n             TyKind::Raw(mutbl, ty) => ty::RawPtr(ty::TypeAndMut {\n                 ty: ty.lower_into(interner),"}, {"sha": "3658f8e57356ba58f920632c04739238b644a6e8", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -198,14 +198,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n \n         ty::Tuple(tys) => rustc_data_structures::stack::ensure_sufficient_stack(|| {\n             for ty in tys.iter() {\n-                dtorck_constraint_for_ty(\n-                    tcx,\n-                    span,\n-                    for_ty,\n-                    depth + 1,\n-                    ty.expect_ty(),\n-                    constraints,\n-                )?;\n+                dtorck_constraint_for_ty(tcx, span, for_ty, depth + 1, ty, constraints)?;\n             }\n             Ok::<_, NoSolution>(())\n         })?,"}, {"sha": "11a57688580a67025100b68ccadb057fd2f66837", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -70,9 +70,9 @@ fn are_inner_types_recursive<'tcx>(\n ) -> Representability {\n     debug!(\"are_inner_types_recursive({:?}, {:?}, {:?})\", ty, seen, shadow_seen);\n     match ty.kind() {\n-        ty::Tuple(..) => {\n+        ty::Tuple(fields) => {\n             // Find non representable\n-            fold_repr(ty.tuple_fields().map(|ty| {\n+            fold_repr(fields.iter().map(|ty| {\n                 is_type_structurally_recursive(\n                     tcx,\n                     sp,"}, {"sha": "e6ce3447548de4cf2e9894b5af4b149e06d9fd54", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -24,7 +24,7 @@ fn sized_constraint_for_ty<'tcx>(\n \n         Tuple(ref tys) => match tys.last() {\n             None => vec![],\n-            Some(ty) => sized_constraint_for_ty(tcx, adtdef, ty.expect_ty()),\n+            Some(&ty) => sized_constraint_for_ty(tcx, adtdef, ty),\n         },\n \n         Adt(adt, substs) => {\n@@ -461,9 +461,9 @@ pub fn conservative_is_privately_uninhabited_raw<'tcx>(\n                 })\n             })\n         }\n-        ty::Tuple(..) => {\n+        ty::Tuple(fields) => {\n             debug!(\"ty::Tuple(..) =>\");\n-            ty.tuple_fields().any(|ty| tcx.conservative_is_privately_uninhabited(param_env.and(ty)))\n+            fields.iter().any(|ty| tcx.conservative_is_privately_uninhabited(param_env.and(ty)))\n         }\n         ty::Array(ty, len) => {\n             debug!(\"ty::Array(ty, len) =>\");"}, {"sha": "57076d97246785deaaa67fea5da12fbf9f1e081b", "filename": "compiler/rustc_typeck/src/check/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcast.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n             ty::Tuple(fields) => match fields.last() {\n                 None => Some(PointerKind::Thin),\n-                Some(f) => self.pointer_kind(f.expect_ty(), span)?,\n+                Some(&f) => self.pointer_kind(f, span)?,\n             },\n \n             // Pointers to foreign types are thin, despite being unsized"}, {"sha": "59c8febdc30daab1570b8b6b94417a64d2b5fe11", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -270,7 +270,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             debug!(\"deduce_sig_from_projection: arg_param_ty={:?}\", arg_param_ty);\n \n             match arg_param_ty.kind() {\n-                ty::Tuple(tys) => tys.into_iter().map(|k| k.expect_ty()).collect::<Vec<_>>(),\n+                &ty::Tuple(tys) => tys,\n                 _ => return None,\n             }\n         } else {\n@@ -286,7 +286,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let sig = projection.rebind(self.tcx.mk_fn_sig(\n             input_tys.iter(),\n-            &ret_param_ty,\n+            ret_param_ty,\n             false,\n             hir::Unsafety::Normal,\n             Abi::Rust,"}, {"sha": "b08ee414fa7b4a2abd234bcb66517a39cf5a14f5", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -1291,7 +1291,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let elt_ts_iter = elts.iter().enumerate().map(|(i, e)| match flds {\n             Some(fs) if i < fs.len() => {\n-                let ety = fs[i].expect_ty();\n+                let ety = fs[i];\n                 self.check_expr_coercable_to_type(&e, ety, None);\n                 ety\n             }\n@@ -1877,13 +1877,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let fstr = field.as_str();\n                     if let Ok(index) = fstr.parse::<usize>() {\n                         if fstr == index.to_string() {\n-                            if let Some(field_ty) = tys.get(index) {\n+                            if let Some(&field_ty) = tys.get(index) {\n                                 let adjustments = self.adjust_steps(&autoderef);\n                                 self.apply_adjustments(base, adjustments);\n                                 self.register_predicates(autoderef.into_obligations());\n \n                                 self.write_field_index(expr.hir_id, index);\n-                                return field_ty.expect_ty();\n+                                return field_ty;\n                             }\n                         }\n                     }"}, {"sha": "d3d42a1f37c757ee61c3784a9683301d96287c22", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -147,12 +147,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                     let expected_input_tys = match expected_input_tys.get(0) {\n                         Some(&ty) => match ty.kind() {\n-                            ty::Tuple(ref tys) => tys.iter().map(|k| k.expect_ty()).collect(),\n+                            ty::Tuple(tys) => tys.iter().collect(),\n                             _ => vec![],\n                         },\n                         None => vec![],\n                     };\n-                    (arg_types.iter().map(|k| k.expect_ty()).collect(), expected_input_tys)\n+                    (arg_types.iter().collect(), expected_input_tys)\n                 }\n                 _ => {\n                     // Otherwise, there's a mismatch, so clear out what we're expecting, and set\n@@ -495,12 +495,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_input_tys: &[Ty<'tcx>],\n         provided_args: &'tcx [hir::Expr<'tcx>],\n     ) -> Option<FnArgsAsTuple<'_>> {\n-        let [expected_arg_type] = &expected_input_tys[..] else { return None };\n+        let [expected_arg_type] = expected_input_tys[..] else { return None };\n \n-        let ty::Tuple(expected_elems) = self.resolve_vars_if_possible(*expected_arg_type).kind()\n+        let &ty::Tuple(expected_types) = self.resolve_vars_if_possible(expected_arg_type).kind()\n             else { return None };\n \n-        let expected_types: Vec<_> = expected_elems.iter().map(|k| k.expect_ty()).collect();\n         let supplied_types: Vec<_> = provided_args.iter().map(|arg| self.check_expr(arg)).collect();\n \n         let all_match = iter::zip(expected_types, supplied_types)"}, {"sha": "9684237be831369603321854d1701f72cc37dff7", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -539,16 +539,16 @@ pub fn check_must_not_suspend_ty<'tcx>(\n             }\n             has_emitted\n         }\n-        ty::Tuple(_) => {\n+        ty::Tuple(fields) => {\n             let mut has_emitted = false;\n             let comps = match data.expr.map(|e| &e.kind) {\n                 Some(hir::ExprKind::Tup(comps)) => {\n-                    debug_assert_eq!(comps.len(), ty.tuple_fields().count());\n+                    debug_assert_eq!(comps.len(), fields.len());\n                     Some(comps)\n                 }\n                 _ => None,\n             };\n-            for (i, ty) in ty.tuple_fields().enumerate() {\n+            for (i, ty) in fields.iter().enumerate() {\n                 let descr_post = &format!(\" in tuple element {}\", i);\n                 let span = comps.and_then(|c| c.get(i)).map(|e| e.span).unwrap_or(data.source_span);\n                 if check_must_not_suspend_ty("}, {"sha": "77ab1d1de42112fbc3fab5de73cabe0488befd6b", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -9,7 +9,6 @@ use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::{HirId, Pat, PatKind};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::{self, Adt, BindingMode, Ty, TypeFoldable};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n use rustc_span::hygiene::DesugaringKind;\n@@ -1072,7 +1071,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             (ty::Adt(_, substs), [field], false) => {\n                 let field_ty = self.field_ty(pat_span, field, substs);\n                 match field_ty.kind() {\n-                    ty::Tuple(_) => field_ty.tuple_fields().count() == subpats.len(),\n+                    ty::Tuple(fields) => fields.len() == subpats.len(),\n                     _ => false,\n                 }\n             }\n@@ -1183,13 +1182,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let max_len = cmp::max(expected_len, elements.len());\n \n         let element_tys_iter = (0..max_len).map(|_| {\n-            GenericArg::from(self.next_ty_var(\n+            self.next_ty_var(\n                 // FIXME: `MiscVariable` for now -- obtaining the span and name information\n                 // from all tuple elements isn't trivial.\n                 TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span },\n-            ))\n+            )\n         });\n-        let element_tys = tcx.mk_substs(element_tys_iter);\n+        let element_tys = tcx.mk_type_list(element_tys_iter);\n         let pat_ty = tcx.mk_ty(ty::Tuple(element_tys));\n         if let Some(mut err) = self.demand_eqtype_pat_diag(span, expected, pat_ty, ti) {\n             err.emit();\n@@ -1202,7 +1201,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tcx.mk_tup(element_tys_iter)\n         } else {\n             for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, element_tys[i].expect_ty(), def_bm, ti);\n+                self.check_pat(elem, element_tys[i], def_bm, ti);\n             }\n             pat_ty\n         }"}, {"sha": "257846324b888307145e064e96a9a48f8a4b852f", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -1448,7 +1448,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 )\n             }\n \n-            ty::Tuple(..) => {\n+            ty::Tuple(fields) => {\n                 // Only Field projections can be applied to a tuple.\n                 assert!(\n                     captured_by_move_projs.iter().all(|projs| matches!(\n@@ -1457,7 +1457,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ))\n                 );\n \n-                base_path_ty.tuple_fields().enumerate().any(|(i, element_ty)| {\n+                fields.iter().enumerate().any(|(i, element_ty)| {\n                     let paths_using_field = captured_by_move_projs\n                         .iter()\n                         .filter_map(|projs| {"}, {"sha": "196e476b0e37a7dfcd15af491ca113a3377037f6", "filename": "compiler/rustc_typeck/src/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fconstraints.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -278,7 +278,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::Tuple(subtys) => {\n                 for subty in subtys {\n-                    self.add_constraints_from_ty(current, subty.expect_ty(), variance);\n+                    self.add_constraints_from_ty(current, subty, variance);\n                 }\n             }\n "}, {"sha": "76994f2ee17127d3ba75ab94a30071389694d657", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -1543,7 +1543,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n                 DynTrait(bounds, lifetime)\n             }\n-            ty::Tuple(t) => Tuple(t.iter().map(|t| t.expect_ty().clean(cx)).collect()),\n+            ty::Tuple(t) => Tuple(t.iter().map(|t| t.clean(cx)).collect()),\n \n             ty::Projection(ref data) => data.clean(cx),\n "}, {"sha": "c2d1d4756fd8172d86cf8562e4544ca849d90f86", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -109,7 +109,7 @@ fn external_generic_args(\n \n     if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() {\n         let inputs = match ty_kind.unwrap() {\n-            ty::Tuple(tys) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n+            ty::Tuple(tys) => tys.iter().map(|t| t.clean(cx)).collect(),\n             _ => return GenericArgs::AngleBracketed { args, bindings: bindings.into() },\n         };\n         let output = None;"}, {"sha": "ea9b68d1a40e3982a01dfa16b56541b940691cd3", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -193,7 +193,7 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n                 || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n                     && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n         },\n-        ty::Tuple(substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n+        ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n         ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n         ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n             mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)"}, {"sha": "677b8cdf2ba0c80bc64dc4618a074cd6f349ec5b", "filename": "src/tools/clippy/clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -58,8 +58,8 @@ fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, see\n         // This type doesn't implement drop, so no side effects here.\n         // Check if any component type has any.\n         match ty.kind() {\n-            ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, *ty, seen),\n+            ty::Tuple(fields) => fields.iter().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n+            &ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n             ty::Adt(adt, subs) => adt\n                 .all_fields()\n                 .map(|f| f.ty(cx.tcx, subs))"}, {"sha": "ce9ca15430e421cd16455c52b80508ebda522b59", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -142,7 +142,7 @@ fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Sp\n             size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n                 && is_interior_mutable_type(cx, inner_ty, span)\n         },\n-        Tuple(..) => ty.tuple_fields().any(|ty| is_interior_mutable_type(cx, ty, span)),\n+        Tuple(fields) => fields.iter().any(|ty| is_interior_mutable_type(cx, ty, span)),\n         Adt(def, substs) => {\n             // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n             // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`"}, {"sha": "5168ca67b6abb86c135264f6bb7b273474e2db20", "filename": "src/tools/clippy/clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -202,8 +202,8 @@ fn ty_allowed_with_raw_pointer_heuristic<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'t\n \n     // The type is known to be `!Send` and `!Copy`\n     match ty.kind() {\n-        ty::Tuple(_) => ty\n-            .tuple_fields()\n+        ty::Tuple(fields) => fields\n+            .iter()\n             .all(|ty| ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait)),\n         ty::Array(ty, _) | ty::Slice(ty) => ty_allowed_with_raw_pointer_heuristic(cx, *ty, send_trait),\n         ty::Adt(_, substs) => {"}, {"sha": "a57c819cb22567f78a2f3c5fed977b3026ee65b1", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -2,7 +2,7 @@ use super::TRANSMUTE_UNDEFINED_REPR;\n use clippy_utils::diagnostics::span_lint_and_then;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::subst::{GenericArg, Subst};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TypeAndMut};\n use rustc_span::Span;\n \n@@ -246,11 +246,10 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                 continue;\n             },\n             ty::Tuple(args) => {\n-                let mut iter = args.iter().map(GenericArg::expect_ty);\n-                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, *ty)) else {\n+                let Some(sized_ty) =  args.iter().find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n                     return ReducedTy::OrderedFields(ty);\n                 };\n-                if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n+                if args.iter().all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n                     continue;\n                 }"}, {"sha": "0d39226d970350f8e9a8e8a133d317aa4082d2a9", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a8cc7df1d65554a4d40825b0490c93ac0f0236/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=03a8cc7df1d65554a4d40825b0490c93ac0f0236", "patch": "@@ -169,7 +169,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n         },\n-        ty::Tuple(substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n+        ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n                 if let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() {\n@@ -249,11 +249,11 @@ pub fn is_non_aggregate_primitive_type(ty: Ty<'_>) -> bool {\n /// Returns `true` if the given type is a primitive (a `bool` or `char`, any integer or\n /// floating-point number type, a `str`, or an array, slice, or tuple of those types).\n pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n+    match *ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n         ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n-        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(*inner_type),\n-        ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n+        ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n+        ty::Tuple(inner_types) => inner_types.iter().all(is_recursively_primitive_type),\n         _ => false,\n     }\n }\n@@ -393,9 +393,9 @@ pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n \n /// Checks if a given type looks safe to be uninitialized.\n pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n-        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, *component),\n-        ty::Tuple(types) => types.types().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n+    match *ty.kind() {\n+        ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n+        ty::Tuple(types) => types.iter().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n         ty::Adt(adt, _) => cx.tcx.lang_items().maybe_uninit() == Some(adt.did),\n         _ => false,\n     }\n@@ -426,8 +426,8 @@ impl<'tcx> ExprFnSig<'tcx> {\n     pub fn input(self, i: usize) -> Binder<'tcx, Ty<'tcx>> {\n         match self {\n             Self::Sig(sig) => sig.input(i),\n-            Self::Closure(sig) => sig.input(0).map_bound(|ty| ty.tuple_element_ty(i).unwrap()),\n-            Self::Trait(inputs, _) => inputs.map_bound(|ty| ty.tuple_element_ty(i).unwrap()),\n+            Self::Closure(sig) => sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n+            Self::Trait(inputs, _) => inputs.map_bound(|ty| ty.tuple_fields()[i]),\n         }\n     }\n "}]}