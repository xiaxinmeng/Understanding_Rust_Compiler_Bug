{"sha": "767ffced9106c76647abf6b024bd05ba02d702b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2N2ZmY2VkOTEwNmM3NjY0N2FiZjZiMDI0YmQwNWJhMDJkNzAyYjQ=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-03T00:56:47Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2018-12-26T21:27:08Z"}, "message": "Made suggestion diagnostics more consistent for enum variant names, relative to method names.", "tree": {"sha": "219ca4fc50f3a072f5aee21ee6ae247c065a1e7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/219ca4fc50f3a072f5aee21ee6ae247c065a1e7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/767ffced9106c76647abf6b024bd05ba02d702b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/767ffced9106c76647abf6b024bd05ba02d702b4", "html_url": "https://github.com/rust-lang/rust/commit/767ffced9106c76647abf6b024bd05ba02d702b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/767ffced9106c76647abf6b024bd05ba02d702b4/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecacad07708a7ef756b45eae828d0c3b1e209c2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecacad07708a7ef756b45eae828d0c3b1e209c2c", "html_url": "https://github.com/rust-lang/rust/commit/ecacad07708a7ef756b45eae828d0c3b1e209c2c"}], "stats": {"total": 153, "additions": 84, "deletions": 69}, "files": [{"sha": "67f330536b85e84ddc246ceb25d3ac8d2b9912f3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=767ffced9106c76647abf6b024bd05ba02d702b4", "patch": "@@ -1277,7 +1277,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                                      ref_id: ast::NodeId,\n                                      span: Span,\n                                      ty: Ty<'tcx>,\n-                                     ty_hir: &hir::Ty,\n+                                     qself: &hir::Ty,\n                                      ty_path_def: Def,\n                                      item_segment: &hir::PathSegment)\n                                      -> (Ty<'tcx>, Def)\n@@ -1292,11 +1292,11 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         // Check if we have an enum variant here.\n         if let ty::Adt(adt_def, _) = ty.sty {\n             if adt_def.is_enum() {\n-                if allow_type_alias_enum_variants(tcx, ty_hir, span) {\n-                    let variant_def = adt_def.variants.iter().find(|vd| {\n-                        tcx.hygienic_eq(assoc_name, vd.ident, adt_def.did)\n-                    });\n-                    if let Some(variant_def) = variant_def {\n+                let variant_def = adt_def.variants.iter().find(|vd| {\n+                    tcx.hygienic_eq(assoc_name, vd.ident, adt_def.did)\n+                });\n+                if let Some(variant_def) = variant_def {\n+                    if allow_type_alias_enum_variants(tcx, qself, span) {\n                         let def = Def::Variant(variant_def.did);\n                         return (ty, def);\n                     }"}, {"sha": "4c96d476caa220dbddd8c23646e9c8938c44a61c", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=767ffced9106c76647abf6b024bd05ba02d702b4", "patch": "@@ -8,7 +8,7 @@ mod suggest;\n \n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n-pub use self::suggest::TraitInfo;\n+pub use self::suggest::{SelfSource, TraitInfo};\n \n use check::FnCtxt;\n use namespace::Namespace;\n@@ -361,7 +361,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         span: Span,\n                         method_name: ast::Ident,\n                         self_ty: Ty<'tcx>,\n-                        self_ty_hir: &hir::Ty,\n+                        qself: &hir::Ty,\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n         debug!(\"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n@@ -375,11 +375,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Check if we have an enum variant here.\n         if let ty::Adt(adt_def, _) = self_ty.sty {\n             if adt_def.is_enum() {\n-                if allow_type_alias_enum_variants(tcx, self_ty_hir, span) {\n-                    let variant_def = adt_def.variants.iter().find(|vd| {\n-                        tcx.hygienic_eq(method_name, vd.ident, adt_def.did)\n-                    });\n-                    if let Some(variant_def) = variant_def {\n+                let variant_def = adt_def.variants.iter().find(|vd| {\n+                    tcx.hygienic_eq(method_name, vd.ident, adt_def.did)\n+                });\n+                if let Some(variant_def) = variant_def {\n+                    if allow_type_alias_enum_variants(tcx, qself, span) {\n                         let def = Def::VariantCtor(variant_def.did, variant_def.ctor_kind);\n                         return Ok(def);\n                     }"}, {"sha": "b368250b32d97214798ce716e1a8e8da3d36c110", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 39, "deletions": 31, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=767ffced9106c76647abf6b024bd05ba02d702b4", "patch": "@@ -6,7 +6,7 @@ use errors::{Applicability, DiagnosticBuilder};\n use middle::lang_items::FnOnceTraitLangItem;\n use namespace::Namespace;\n use rustc_data_structures::sync::Lrc;\n-use rustc::hir::{self, Node};\n+use rustc::hir::{self, ExprKind, Node, QPath};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::map as hir_map;\n@@ -60,13 +60,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn report_method_error(&self,\n-                               span: Span,\n-                               rcvr_ty: Ty<'tcx>,\n-                               item_name: ast::Ident,\n-                               rcvr_expr: Option<&hir::Expr>,\n-                               error: MethodError<'tcx>,\n-                               args: Option<&'gcx [hir::Expr]>) {\n+    pub fn report_method_error<'b>(&self,\n+                                   span: Span,\n+                                   rcvr_ty: Ty<'tcx>,\n+                                   item_name: ast::Ident,\n+                                   source: SelfSource<'b>,\n+                                   error: MethodError<'tcx>,\n+                                   args: Option<&'gcx [hir::Expr]>) {\n         // Avoid suggestions when we don't know what's going on.\n         if rcvr_ty.references_error() {\n             return;\n@@ -212,10 +212,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         .filter_map(|info|\n                             self.associated_item(info.def_id, item_name, Namespace::Value)\n                         );\n-                    if let (true, false, Some(expr), Some(_)) = (actual.is_numeric(),\n-                                                                 actual.has_concrete_skeleton(),\n-                                                                 rcvr_expr,\n-                                                                 candidates.next()) {\n+                    if let (true, false, SelfSource::MethodCall(expr), Some(_)) =\n+                           (actual.is_numeric(),\n+                            actual.has_concrete_skeleton(),\n+                            source,\n+                            candidates.next()) {\n                         let mut err = struct_span_err!(\n                             tcx.sess,\n                             span,\n@@ -231,7 +232,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             \"f32\"\n                         };\n                         match expr.node {\n-                            hir::ExprKind::Lit(ref lit) => {\n+                            ExprKind::Lit(ref lit) => {\n                                 // numeric literal\n                                 let snippet = tcx.sess.source_map().span_to_snippet(lit.span)\n                                     .unwrap_or_else(|_| \"<numeric literal>\".to_owned());\n@@ -247,9 +248,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n-                            hir::ExprKind::Path(ref qpath) => {\n+                            ExprKind::Path(ref qpath) => {\n                                 // local binding\n-                                if let &hir::QPath::Resolved(_, ref path) = &qpath {\n+                                if let &QPath::Resolved(_, ref path) = &qpath {\n                                     if let hir::def::Def::Local(node_id) = path.def {\n                                         let span = tcx.hir().span(node_id);\n                                         let snippet = tcx.sess.source_map().span_to_snippet(span)\n@@ -294,15 +295,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     } else {\n                         let mut err = struct_span_err!(\n                             tcx.sess,\n-                            span,\n+                            item_name.span,\n                             E0599,\n                             \"no {} named `{}` found for type `{}` in the current scope\",\n                             item_kind,\n                             item_name,\n                             ty_str\n                         );\n                         if let Some(suggestion) = suggestion {\n-                            err.note(&format!(\"did you mean `{}::{}`?\", ty_str, suggestion));\n+                            // enum variant\n+                            err.help(&format!(\"did you mean `{}`?\", suggestion));\n                         }\n                         err\n                     }\n@@ -326,7 +328,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // If the method name is the name of a field with a function or closure type,\n                 // give a helping note that it has to be called as `(x.f)(...)`.\n-                if let Some(expr) = rcvr_expr {\n+                if let SelfSource::MethodCall(expr) = source {\n                     for (ty, _) in self.autoderef(span, rcvr_ty) {\n                         if let ty::Adt(def, substs) = ty.sty {\n                             if !def.is_enum() {\n@@ -377,10 +379,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n \n-                    if let Some(expr) = rcvr_expr {\n+                    if let SelfSource::MethodCall(expr) = source {\n                         if let Ok(expr_string) = tcx.sess.source_map().span_to_snippet(expr.span) {\n                             report_function!(expr.span, expr_string);\n-                        } else if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) =\n+                        } else if let ExprKind::Path(QPath::Resolved(_, ref path)) =\n                             expr.node\n                         {\n                             if let Some(segment) = path.segments.last() {\n@@ -396,7 +398,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     err.span_label(span, \"this is an associated function, not a method\");\n                 }\n                 if static_sources.len() == 1 {\n-                    if let Some(expr) = rcvr_expr {\n+                    if let SelfSource::MethodCall(expr) = source {\n                         err.span_suggestion_with_applicability(expr.span.to(span),\n                                             \"use associated function syntax instead\",\n                                             format!(\"{}::{}\",\n@@ -433,7 +435,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                   span,\n                                                   rcvr_ty,\n                                                   item_name,\n-                                                  rcvr_expr,\n+                                                  source,\n                                                   out_of_scope_traits);\n                 }\n \n@@ -571,18 +573,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn suggest_traits_to_import(&self,\n-                                err: &mut DiagnosticBuilder,\n-                                span: Span,\n-                                rcvr_ty: Ty<'tcx>,\n-                                item_name: ast::Ident,\n-                                rcvr_expr: Option<&hir::Expr>,\n-                                valid_out_of_scope_traits: Vec<DefId>) {\n+    fn suggest_traits_to_import<'b>(&self,\n+                                    err: &mut DiagnosticBuilder,\n+                                    span: Span,\n+                                    rcvr_ty: Ty<'tcx>,\n+                                    item_name: ast::Ident,\n+                                    source: SelfSource<'b>,\n+                                    valid_out_of_scope_traits: Vec<DefId>) {\n         if self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n             return;\n         }\n \n-        let type_is_local = self.type_derefs_to_local(span, rcvr_ty, rcvr_expr);\n+        let type_is_local = self.type_derefs_to_local(span, rcvr_ty, source);\n \n         // There are no traits implemented, so lets suggest some traits to\n         // implement, by finding ones that have the item name, and are\n@@ -663,14 +665,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // This occurs for UFCS desugaring of `T::method`, where there is no\n         // receiver expression for the method call, and thus no autoderef.\n-        if rcvr_expr.is_none() {\n+        if let SelfSource::QPath(_) = source {\n             return is_local(self.resolve_type_vars_with_obligations(rcvr_ty));\n         }\n \n         self.autoderef(span, rcvr_ty).any(|(ty, _)| is_local(ty))\n     }\n }\n \n+#[derive(Copy, Clone)]\n+pub enum SelfSource<'a> {\n+    QPath(&'a hir::Ty),\n+    MethodCall(&'a hir::Expr /* rcvr */),\n+}\n+\n #[derive(Copy, Clone)]\n pub struct TraitInfo {\n     pub def_id: DefId,"}, {"sha": "37739eb655fb3f61f53ebe577f9bf1e5363ae1db", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=767ffced9106c76647abf6b024bd05ba02d702b4", "patch": "@@ -142,7 +142,7 @@ use self::autoderef::Autoderef;\n use self::callee::DeferredCallResolution;\n use self::coercion::{CoerceMany, DynamicCoerceMany};\n pub use self::compare_method::{compare_impl_method, compare_const_impl};\n-use self::method::MethodCallee;\n+use self::method::{MethodCallee, SelfSource};\n use self::TupleArgumentsFlag::*;\n \n /// The type of a local binding, including the revealed type for anon types.\n@@ -3244,7 +3244,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.report_method_error(span,\n                                              rcvr_t,\n                                              segment.ident,\n-                                             Some(rcvr),\n+                                             SelfSource::MethodCall(rcvr),\n                                              error,\n                                              Some(args));\n                 }\n@@ -4558,7 +4558,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n-        let (ty, ty_hir, item_segment) = match *qpath {\n+        let (ty, qself, item_segment) = match *qpath {\n             hir::QPath::Resolved(ref opt_qself, ref path) => {\n                 return (path.def,\n                         opt_qself.as_ref().map(|qself| self.to_ty(qself)),\n@@ -4575,15 +4575,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return (*cached_def, Some(ty), slice::from_ref(&**item_segment))\n         }\n         let item_name = item_segment.ident;\n-        let def = match self.resolve_ufcs(span, item_name, ty, ty_hir, node_id) {\n+        let def = match self.resolve_ufcs(span, item_name, ty, qself, node_id) {\n             Ok(def) => def,\n             Err(error) => {\n                 let def = match error {\n                     method::MethodError::PrivateMatch(def, _) => def,\n                     _ => Def::Err,\n                 };\n                 if item_name.name != keywords::Invalid.name() {\n-                    self.report_method_error(span, ty, item_name, None, error, None);\n+                    self.report_method_error(span,\n+                                             ty,\n+                                             item_name,\n+                                             SelfSource::QPath(qself),\n+                                             error,\n+                                             None);\n                 }\n                 def\n             }\n@@ -5114,7 +5119,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Case 2. Reference to a variant constructor.\n             Def::VariantCtor(def_id, ..) => {\n-                if tcx.features().type_alias_enum_variants {\n+                if self.tcx.features().type_alias_enum_variants {\n                     let adt_def = self_ty.and_then(|t| t.ty_adt_def());\n                     let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n                         debug_assert!(adt_def.is_enum());\n@@ -5192,16 +5197,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             node_id,\n         );\n \n+        let tcx = self.tcx;\n+\n         let path_segs = self.def_ids_for_path_segments(segments, self_ty, def);\n \n         let mut user_self_ty = None;\n         match def {\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n-                let container = self.tcx.associated_item(def_id).container;\n+                let container = tcx.associated_item(def_id).container;\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n-                        callee::check_legal_trait_for_method_call(self.tcx, span, trait_did)\n+                        callee::check_legal_trait_for_method_call(tcx, span, trait_did)\n                     }\n                     ty::ImplContainer(impl_def_id) => {\n                         if segments.len() == 1 {\n@@ -5231,7 +5238,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match def {\n                 Def::VariantCtor(_, _) if self_ty.is_some() => true,\n                 _ => false,\n-            };\n+            }\n         } else {\n             false\n         };\n@@ -5249,7 +5256,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Local(nid) | Def::Upvar(nid, ..) => {\n                 let ty = self.local_ty(span, nid).decl_ty;\n                 let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(self.tcx.hir().node_to_hir_id(node_id), ty);\n+                self.write_ty(tcx.hir().node_to_hir_id(node_id), ty);\n                 return (ty, def);\n             }\n             _ => {}\n@@ -5265,13 +5272,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut infer_args_for_err = FxHashSet::default();\n         for &PathSeg(def_id, index) in &path_segs {\n             let seg = &segments[index];\n-            let generics = self.tcx.generics_of(def_id);\n+            let generics = tcx.generics_of(def_id);\n             // Argument-position `impl Trait` is treated as a normal generic\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n             let suppress_errors = AstConv::check_generic_arg_count_for_call(\n-                self.tcx,\n+                tcx,\n                 span,\n                 &generics,\n                 &seg,\n@@ -5284,7 +5291,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         let has_self = path_segs.last().map(|PathSeg(def_id, _)| {\n-            self.tcx.generics_of(*def_id).has_self\n+            tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n         let mut new_def = def;\n@@ -5297,10 +5304,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Some(adt_def) if adt_def.has_ctor() => {\n                         let variant = adt_def.non_enum_variant();\n                         new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                        (variant.did, self.tcx.type_of(variant.did))\n+                        (variant.did, tcx.type_of(variant.did))\n                     }\n                     _ => {\n-                        let mut err = self.tcx.sess.struct_span_err(span,\n+                        let mut err = tcx.sess.struct_span_err(span,\n                             \"the `Self` constructor can only be used with tuple or unit structs\");\n                         if let Some(adt_def) = adt_def {\n                             match adt_def.adt_kind() {\n@@ -5318,14 +5325,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         err.emit();\n \n-                        (impl_def_id, self.tcx.types.err)\n+                        (impl_def_id, tcx.types.err)\n                     }\n                 }\n             }\n             Def::VariantCtor(_, _) if self_ty.is_some() => {\n                 let def_id = def.def_id();\n \n-                let ty = self.tcx.type_of(def_id);\n+                let ty = tcx.type_of(def_id);\n                 if tcx.features().type_alias_enum_variants {\n                     if let Some(self_ty) = self_ty {\n                         match ty.ty_adt_def() {\n@@ -5343,13 +5350,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // The things we are substituting into the type should not contain\n                 // escaping late-bound regions, and nor should the base type scheme.\n-                let ty = self.tcx.type_of(def_id);\n+                let ty = tcx.type_of(def_id);\n                 (def_id, ty)\n             }\n         };\n \n         let substs = AstConv::create_substs_for_generic_args(\n-            self.tcx,\n+            tcx,\n             def_id,\n             &[][..],\n             has_self,\n@@ -5395,10 +5402,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             // If we have a default, then we it doesn't matter that we're not\n                             // inferring the type arguments: we provide the default where any\n                             // is missing.\n-                            let default = self.tcx.type_of(param.def_id);\n+                            let default = tcx.type_of(param.def_id);\n                             self.normalize_ty(\n                                 span,\n-                                default.subst_spanned(self.tcx, substs.unwrap(), Some(span))\n+                                default.subst_spanned(tcx, substs.unwrap(), Some(span))\n                             ).into()\n                         } else {\n                             // If no type arguments were provided, we have to infer them.\n@@ -5415,7 +5422,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(!ty.has_escaping_bound_vars());\n \n         // First, store the \"user substs\" for later.\n-        let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n+        let hir_id = tcx.hir().node_to_hir_id(node_id);\n         self.write_user_substs_from_substs(hir_id, substs, user_self_ty);\n \n         // Add all the obligations that are required, substituting and\n@@ -5434,7 +5441,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // is inherent, there is no `Self` parameter, instead, the impl needs\n             // type parameters, which we can infer by unifying the provided `Self`\n             // with the substituted impl type.\n-            let ty = self.tcx.type_of(impl_def_id);\n+            let ty = tcx.type_of(impl_def_id);\n \n             let impl_ty = self.instantiate_type_scheme(span, &substs, &ty);\n             match self.at(&self.misc(span), self.param_env).sup(impl_ty, self_ty) {"}, {"sha": "4950ea319271b78d5fdcfdb83b9074675a451157", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/767ffced9106c76647abf6b024bd05ba02d702b4/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=767ffced9106c76647abf6b024bd05ba02d702b4", "patch": "@@ -132,12 +132,12 @@ pub struct TypeAndSubsts<'tcx> {\n }\n \n fn allow_type_alias_enum_variants<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                                  ty_hir: &hir::Ty,\n+                                                  qself: &hir::Ty,\n                                                   span: Span) -> bool {\n     let allow_feature = tcx.features().type_alias_enum_variants;\n     if !allow_feature {\n         // Only print error if we know the type is an alias.\n-        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ty_hir.node {\n+        if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = qself.node {\n             if let Def::TyAlias(_) = path.def {\n                 let mut err = tcx.sess.struct_span_err(\n                     span,"}]}