{"sha": "88b6e93d35c34e143ba060a617e71c8af10fa15e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4YjZlOTNkMzVjMzRlMTQzYmEwNjBhNjE3ZTcxYzhhZjEwZmExNWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-31T23:36:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-31T23:36:48Z"}, "message": "auto merge of #18177 : nick29581/rust/ufcs2, r=nikomatsakis\n\nr?\r\n\r\ncloses #18061", "tree": {"sha": "c38cb8832d54949ec5619656da528b9a9cf9767f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c38cb8832d54949ec5619656da528b9a9cf9767f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/88b6e93d35c34e143ba060a617e71c8af10fa15e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/88b6e93d35c34e143ba060a617e71c8af10fa15e", "html_url": "https://github.com/rust-lang/rust/commit/88b6e93d35c34e143ba060a617e71c8af10fa15e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/88b6e93d35c34e143ba060a617e71c8af10fa15e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e834243b6837a2386d623e1d546a3d25057b8f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e834243b6837a2386d623e1d546a3d25057b8f5", "html_url": "https://github.com/rust-lang/rust/commit/5e834243b6837a2386d623e1d546a3d25057b8f5"}, {"sha": "060566f08a5c6b2343880516799971755183744f", "url": "https://api.github.com/repos/rust-lang/rust/commits/060566f08a5c6b2343880516799971755183744f", "html_url": "https://github.com/rust-lang/rust/commit/060566f08a5c6b2343880516799971755183744f"}], "stats": {"total": 403, "additions": 263, "deletions": 140}, "files": [{"sha": "d92623636f49df78a102433a615ccd09cef9dc73", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -32,10 +32,9 @@ use syntax::parse::token;\n \n use std::collections::hashmap::HashMap;\n \n-pub struct StaticMethodInfo {\n+pub struct MethodInfo {\n     pub name: ast::Name,\n     pub def_id: ast::DefId,\n-    pub fn_style: ast::FnStyle,\n     pub vis: ast::Visibility,\n }\n \n@@ -178,11 +177,11 @@ pub fn get_type_name_if_impl(cstore: &cstore::CStore, def: ast::DefId)\n     decoder::get_type_name_if_impl(&*cdata, def.node)\n }\n \n-pub fn get_static_methods_if_impl(cstore: &cstore::CStore,\n+pub fn get_methods_if_impl(cstore: &cstore::CStore,\n                                   def: ast::DefId)\n-                               -> Option<Vec<StaticMethodInfo> > {\n+                               -> Option<Vec<MethodInfo> > {\n     let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_static_methods_if_impl(cstore.intr.clone(), &*cdata, def.node)\n+    decoder::get_methods_if_impl(cstore.intr.clone(), &*cdata, def.node)\n }\n \n pub fn get_item_attrs(cstore: &cstore::CStore,"}, {"sha": "213f32a1d182c5759724aa98724ef374b35675d9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -15,7 +15,7 @@\n use back::svh::Svh;\n use metadata::cstore::crate_metadata;\n use metadata::common::*;\n-use metadata::csearch::StaticMethodInfo;\n+use metadata::csearch::MethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n@@ -111,10 +111,9 @@ enum Family {\n     ImmStatic,             // c\n     MutStatic,             // b\n     Fn,                    // f\n-    UnsafeFn,              // u\n     CtorFn,                // o\n     StaticMethod,          // F\n-    UnsafeStaticMethod,    // U\n+    Method,                // h\n     Type,                  // y\n     ForeignType,           // T\n     Mod,                   // m\n@@ -137,10 +136,9 @@ fn item_family(item: rbml::Doc) -> Family {\n       'c' => ImmStatic,\n       'b' => MutStatic,\n       'f' => Fn,\n-      'u' => UnsafeFn,\n       'o' => CtorFn,\n       'F' => StaticMethod,\n-      'U' => UnsafeStaticMethod,\n+      'h' => Method,\n       'y' => Type,\n       'T' => ForeignType,\n       'm' => Mod,\n@@ -309,15 +307,9 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n         ImmStatic => DlDef(def::DefStatic(did, false)),\n         MutStatic => DlDef(def::DefStatic(did, true)),\n         Struct    => DlDef(def::DefStruct(did)),\n-        UnsafeFn  => DlDef(def::DefFn(did, ast::UnsafeFn, false)),\n-        Fn        => DlDef(def::DefFn(did, ast::NormalFn, false)),\n-        CtorFn    => DlDef(def::DefFn(did, ast::NormalFn, true)),\n-        StaticMethod | UnsafeStaticMethod => {\n-            let fn_style = if fam == UnsafeStaticMethod {\n-                ast::UnsafeFn\n-            } else {\n-                ast::NormalFn\n-            };\n+        Fn        => DlDef(def::DefFn(did, false)),\n+        CtorFn    => DlDef(def::DefFn(did, true)),\n+        Method | StaticMethod => {\n             // def_static_method carries an optional field of its enclosing\n             // trait or enclosing impl (if this is an inherent static method).\n             // So we need to detect whether this is in a trait or not, which\n@@ -331,7 +323,12 @@ fn item_to_def_like(item: rbml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n                 def::FromImpl(item_reqd_and_translated_parent_item(cnum,\n                                                                    item))\n             };\n-            DlDef(def::DefStaticMethod(did, provenance, fn_style))\n+            match fam {\n+                // We don't bother to get encode/decode the trait id, we don't need it.\n+                Method => DlDef(def::DefMethod(did, None, provenance)),\n+                StaticMethod => DlDef(def::DefStaticMethod(did, provenance)),\n+                _ => panic!()\n+            }\n         }\n         Type | ForeignType => DlDef(def::DefTy(did, false)),\n         Mod => DlDef(def::DefMod(did)),\n@@ -518,7 +515,7 @@ fn each_child_of_item_or_crate(intr: Rc<IdentInterner>,\n                         None => {}\n                         Some(impl_method_doc) => {\n                             match item_family(impl_method_doc) {\n-                                StaticMethod | UnsafeStaticMethod => {\n+                                StaticMethod => {\n                                     // Hand off the static method\n                                     // to the callback.\n                                     let static_method_name =\n@@ -905,10 +902,10 @@ pub fn get_type_name_if_impl(cdata: Cmd,\n     ret\n }\n \n-pub fn get_static_methods_if_impl(intr: Rc<IdentInterner>,\n+pub fn get_methods_if_impl(intr: Rc<IdentInterner>,\n                                   cdata: Cmd,\n                                   node_id: ast::NodeId)\n-                               -> Option<Vec<StaticMethodInfo> > {\n+                               -> Option<Vec<MethodInfo> > {\n     let item = lookup_item(node_id, cdata.data());\n     if item_family(item) != Impl {\n         return None;\n@@ -927,31 +924,23 @@ pub fn get_static_methods_if_impl(intr: Rc<IdentInterner>,\n         true\n     });\n \n-    let mut static_impl_methods = Vec::new();\n+    let mut impl_methods = Vec::new();\n     for impl_method_id in impl_method_ids.iter() {\n         let impl_method_doc = lookup_item(impl_method_id.node, cdata.data());\n         let family = item_family(impl_method_doc);\n         match family {\n-            StaticMethod | UnsafeStaticMethod => {\n-                let fn_style;\n-                match item_family(impl_method_doc) {\n-                    StaticMethod => fn_style = ast::NormalFn,\n-                    UnsafeStaticMethod => fn_style = ast::UnsafeFn,\n-                    _ => panic!()\n-                }\n-\n-                static_impl_methods.push(StaticMethodInfo {\n+            StaticMethod | Method => {\n+                impl_methods.push(MethodInfo {\n                     name: item_name(&*intr, impl_method_doc),\n                     def_id: item_def_id(impl_method_doc, cdata),\n-                    fn_style: fn_style,\n                     vis: item_visibility(impl_method_doc),\n                 });\n             }\n             _ => {}\n         }\n     }\n \n-    return Some(static_impl_methods);\n+    return Some(impl_methods);\n }\n \n /// If node_id is the constructor of a tuple struct, retrieve the NodeId of"}, {"sha": "a5d3cc1f12c29cc6118abcf793f91697d988d83b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 28, "deletions": 42, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -835,12 +835,11 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n     encode_method_fty(ecx, rbml_w, &method_ty.fty);\n     encode_visibility(rbml_w, method_ty.vis);\n     encode_explicit_self(rbml_w, &method_ty.explicit_self);\n-    let fn_style = method_ty.fty.fn_style;\n     match method_ty.explicit_self {\n         ty::StaticExplicitSelfCategory => {\n-            encode_family(rbml_w, fn_style_static_method_family(fn_style));\n+            encode_family(rbml_w, STATIC_METHOD_FAMILY);\n         }\n-        _ => encode_family(rbml_w, style_fn_family(fn_style))\n+        _ => encode_family(rbml_w, METHOD_FAMILY)\n     }\n     encode_provided_source(rbml_w, method_ty.provided_source);\n }\n@@ -964,20 +963,9 @@ fn encode_inlined_item(ecx: &EncodeContext,\n     (*eii)(ecx, rbml_w, ii)\n }\n \n-fn style_fn_family(s: FnStyle) -> char {\n-    match s {\n-        UnsafeFn => 'u',\n-        NormalFn => 'f',\n-    }\n-}\n-\n-fn fn_style_static_method_family(s: FnStyle) -> char {\n-    match s {\n-        UnsafeFn => 'U',\n-        NormalFn => 'F',\n-    }\n-}\n-\n+const FN_FAMILY: char = 'f';\n+const STATIC_METHOD_FAMILY: char = 'F';\n+const METHOD_FAMILY: char = 'h';\n \n fn should_inline(attrs: &[Attribute]) -> bool {\n     use syntax::attr::*;\n@@ -1081,11 +1069,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ItemFn(ref decl, fn_style, _, ref generics, _) => {\n+      ItemFn(ref decl, _, _, ref generics, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n-        encode_family(rbml_w, style_fn_family(fn_style));\n+        encode_family(rbml_w, FN_FAMILY);\n         let tps_len = generics.ty_params.len();\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n@@ -1402,13 +1390,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     match method_ty.explicit_self {\n                         ty::StaticExplicitSelfCategory => {\n                             encode_family(rbml_w,\n-                                          fn_style_static_method_family(\n-                                              method_ty.fty.fn_style));\n+                                          STATIC_METHOD_FAMILY);\n                         }\n                         _ => {\n                             encode_family(rbml_w,\n-                                          style_fn_family(\n-                                              method_ty.fty.fn_style));\n+                                          METHOD_FAMILY);\n                         }\n                     }\n                     let pty = ty::lookup_item_type(tcx,\n@@ -1432,30 +1418,30 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_parent_sort(rbml_w, 't');\n \n             let trait_item = &ms[i];\n-            match &ms[i] {\n-                &RequiredMethod(ref tm) => {\n-                    encode_attributes(rbml_w, tm.attrs.as_slice());\n+            let encode_trait_item = |rbml_w: &mut Encoder| {\n+                // If this is a static method, we've already\n+                // encoded this.\n+                if is_nonstatic_method {\n+                    // FIXME: I feel like there is something funny\n+                    // going on.\n+                    let pty = ty::lookup_item_type(tcx, item_def_id.def_id());\n+                    encode_bounds_and_type(rbml_w, ecx, &pty);\n+                }\n+            };\n+            match trait_item {\n+                &RequiredMethod(ref m) => {\n+                    encode_attributes(rbml_w, m.attrs.as_slice());\n+                    encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n-                    encode_method_argument_names(rbml_w, &*tm.decl);\n+                    encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 &ProvidedMethod(ref m) => {\n                     encode_attributes(rbml_w, m.attrs.as_slice());\n-                    // If this is a static method, we've already\n-                    // encoded this.\n-                    if is_nonstatic_method {\n-                        // FIXME: I feel like there is something funny\n-                        // going on.\n-                        let pty = ty::lookup_item_type(tcx,\n-                                                       item_def_id.def_id());\n-                        encode_bounds_and_type(rbml_w, ecx, &pty);\n-                    }\n+                    encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n-                    encode_inlined_item(ecx,\n-                                        rbml_w,\n-                                        IITraitItemRef(def_id, trait_item));\n-                    encode_method_argument_names(rbml_w,\n-                                                 &*m.pe_fn_decl());\n+                    encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n+                    encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n                 }\n \n                 &TypeTraitItem(ref associated_type) => {\n@@ -1493,7 +1479,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n     encode_visibility(rbml_w, nitem.vis);\n     match nitem.node {\n       ForeignItemFn(..) => {\n-        encode_family(rbml_w, style_fn_family(NormalFn));\n+        encode_family(rbml_w, FN_FAMILY);\n         encode_bounds_and_type(rbml_w, ecx,\n                                &lookup_item_type(ecx.tcx,local_def(nitem.id)));\n         encode_name(rbml_w, nitem.ident.name);"}, {"sha": "3d2bd763a1434628f12159d555996f50e45f0a52", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -440,8 +440,8 @@ fn decode_def(dcx: &DecodeContext, doc: rbml::Doc) -> def::Def {\n impl tr for def::Def {\n     fn tr(&self, dcx: &DecodeContext) -> def::Def {\n         match *self {\n-          def::DefFn(did, p, is_ctor) => def::DefFn(did.tr(dcx), p, is_ctor),\n-          def::DefStaticMethod(did, wrapped_did2, p) => {\n+          def::DefFn(did, is_ctor) => def::DefFn(did.tr(dcx), is_ctor),\n+          def::DefStaticMethod(did, wrapped_did2) => {\n             def::DefStaticMethod(did.tr(dcx),\n                                    match wrapped_did2 {\n                                     def::FromTrait(did2) => {\n@@ -450,8 +450,7 @@ impl tr for def::Def {\n                                     def::FromImpl(did2) => {\n                                         def::FromImpl(did2.tr(dcx))\n                                     }\n-                                   },\n-                                   p)\n+                                   })\n           }\n           def::DefMethod(did0, did1, p) => {\n             def::DefMethod(did0.tr(dcx), did1.map(|did1| did1.tr(dcx)), p)"}, {"sha": "a71f714a2efd707eeb0914ad151c5180641e5c8b", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -14,8 +14,8 @@ use syntax::ast_util::local_def;\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum Def {\n-    DefFn(ast::DefId, ast::FnStyle, bool /* is_ctor */),\n-    DefStaticMethod(/* method */ ast::DefId, MethodProvenance, ast::FnStyle),\n+    DefFn(ast::DefId, bool /* is_ctor */),\n+    DefStaticMethod(/* method */ ast::DefId, MethodProvenance),\n     DefSelfTy(/* trait id */ ast::NodeId),\n     DefMod(ast::DefId),\n     DefForeignMod(ast::DefId),\n@@ -58,7 +58,7 @@ pub enum MethodProvenance {\n impl Def {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n-            DefFn(id, _, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n+            DefFn(id, _) | DefStaticMethod(id, _) | DefMod(id) |\n             DefForeignMod(id) | DefStatic(id, _) |\n             DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(id) |\n             DefTyParam(_, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |"}, {"sha": "2c7c360bb1df60eea03d5f34338e73b0eb44e940", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -121,7 +121,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprPath(..) => {\n                 match ty::resolve_expr(self.tcx, expr) {\n-                    DefFn(did, _, _) if self.def_id_is_transmute(did) => {\n+                    DefFn(did, _) if self.def_id_is_transmute(did) => {\n                         let typ = ty::node_id_to_type(self.tcx, expr.id);\n                         match ty::get(typ).sty {\n                             ty_bare_fn(ref bare_fn_ty)"}, {"sha": "3d10289227745aa7595e29c54ff583a76bdb77aa", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 17, "deletions": 29, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -41,7 +41,7 @@ use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt};\n use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyProc, TyQPath};\n use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n use syntax::ast::{TypeImplItem, UnboxedFnTyParamBound, UnnamedField};\n-use syntax::ast::{UnsafeFn, Variant, ViewItem, ViewItemExternCrate};\n+use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast;\n@@ -1250,11 +1250,11 @@ impl<'a> Resolver<'a> {\n                                   sp, is_public);\n                 parent\n             }\n-            ItemFn(_, fn_style, _, _, _) => {\n+            ItemFn(_, _, _, _, _) => {\n                 let name_bindings =\n                     self.add_child(name, parent.clone(), ForbidDuplicateValues, sp);\n \n-                let def = DefFn(local_def(item.id), fn_style, false);\n+                let def = DefFn(local_def(item.id), false);\n                 name_bindings.define_value(def, sp, is_public);\n                 parent\n             }\n@@ -1392,8 +1392,7 @@ impl<'a> Resolver<'a> {\n                                             // Static methods become\n                                             // `DefStaticMethod`s.\n                                             DefStaticMethod(local_def(method.id),\n-                                                            FromImpl(local_def(item.id)),\n-                                                                     method.pe_fn_style())\n+                                                            FromImpl(local_def(item.id)))\n                                         }\n                                         _ => {\n                                             // Non-static methods become\n@@ -1483,8 +1482,7 @@ impl<'a> Resolver<'a> {\n                                     // Static methods become `DefStaticMethod`s.\n                                     (DefStaticMethod(\n                                             local_def(ty_m.id),\n-                                            FromTrait(local_def(item.id)),\n-                                            ty_m.fn_style),\n+                                            FromTrait(local_def(item.id))),\n                                      StaticMethodTraitItemKind)\n                                 }\n                                 _ => {\n@@ -1711,7 +1709,7 @@ impl<'a> Resolver<'a> {\n \n         match foreign_item.node {\n             ForeignItemFn(_, ref generics) => {\n-                let def = DefFn(local_def(foreign_item.id), UnsafeFn, false);\n+                let def = DefFn(local_def(foreign_item.id), false);\n                 name_bindings.define_value(def, foreign_item.span, is_public);\n \n                 self.with_type_parameter_rib(\n@@ -1832,12 +1830,12 @@ impl<'a> Resolver<'a> {\n                 child_name_bindings.define_value(def, DUMMY_SP, is_exported);\n             }\n           }\n-          DefFn(ctor_id, _, true) => {\n+          DefFn(ctor_id, true) => {\n             child_name_bindings.define_value(\n                 csearch::get_tuple_struct_definition_if_ctor(&self.session.cstore, ctor_id)\n                     .map_or(def, |_| DefStruct(ctor_id)), DUMMY_SP, is_public);\n           }\n-          DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) => {\n+          DefFn(..) | DefStaticMethod(..) | DefStatic(..) | DefConst(..) | DefMethod(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n             child_name_bindings.define_value(def, DUMMY_SP, is_public);\n@@ -1902,11 +1900,6 @@ impl<'a> Resolver<'a> {\n             // Record the def ID and fields of this struct.\n             self.structs.insert(def_id, fields);\n           }\n-          DefMethod(..) => {\n-              debug!(\"(building reduced graph for external crate) \\\n-                      ignoring {}\", def);\n-              // Ignored; handled elsewhere.\n-          }\n           DefLocal(..) | DefPrimTy(..) | DefTyParam(..) |\n           DefUse(..) | DefUpvar(..) | DefRegion(..) |\n           DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n@@ -1957,15 +1950,14 @@ impl<'a> Resolver<'a> {\n                 }\n             }\n             DlImpl(def) => {\n-                // We only process static methods of impls here.\n                 match csearch::get_type_name_if_impl(&self.session.cstore, def) {\n                     None => {}\n                     Some(final_name) => {\n-                        let static_methods_opt =\n-                            csearch::get_static_methods_if_impl(&self.session.cstore, def);\n-                        match static_methods_opt {\n-                            Some(ref static_methods) if\n-                                static_methods.len() >= 1 => {\n+                        let methods_opt =\n+                            csearch::get_methods_if_impl(&self.session.cstore, def);\n+                        match methods_opt {\n+                            Some(ref methods) if\n+                                methods.len() >= 1 => {\n                                 debug!(\"(building reduced graph for \\\n                                         external crate) processing \\\n                                         static methods for type name {}\",\n@@ -2015,9 +2007,8 @@ impl<'a> Resolver<'a> {\n                                 // Add each static method to the module.\n                                 let new_parent =\n                                     ModuleReducedGraphParent(type_module);\n-                                for static_method_info in\n-                                        static_methods.iter() {\n-                                    let name = static_method_info.name;\n+                                for method_info in methods.iter() {\n+                                    let name = method_info.name;\n                                     debug!(\"(building reduced graph for \\\n                                              external crate) creating \\\n                                              static method '{}'\",\n@@ -2028,10 +2019,7 @@ impl<'a> Resolver<'a> {\n                                                        new_parent.clone(),\n                                                        OverwriteDuplicates,\n                                                        DUMMY_SP);\n-                                    let def = DefFn(\n-                                        static_method_info.def_id,\n-                                        static_method_info.fn_style,\n-                                        false);\n+                                    let def = DefFn(method_info.def_id, false);\n \n                                     method_name_bindings.define_value(\n                                         def, DUMMY_SP,\n@@ -5646,7 +5634,7 @@ impl<'a> Resolver<'a> {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n                     match binding.def_for_namespace(ValueNS) {\n-                        Some(DefStaticMethod(_, provenance, _)) => {\n+                        Some(DefStaticMethod(_, provenance)) => {\n                             match provenance {\n                                 FromImpl(_) => return StaticMethod(p_str),\n                                 FromTrait(_) => unreachable!()"}, {"sha": "90a21d479037894013dc9f893ea902116847397d", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -241,7 +241,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefRegion(_) |\n             def::DefTyParamBinder(_) |\n             def::DefLabel(_) |\n-            def::DefStaticMethod(_, _, _) |\n+            def::DefStaticMethod(..) |\n             def::DefTyParam(..) |\n             def::DefUse(_) |\n             def::DefMethod(..) |\n@@ -783,7 +783,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                        sub_span,\n                                                        def_id,\n                                                         self.cur_scope),\n-            def::DefStaticMethod(declid, provenence, _) => {\n+            def::DefStaticMethod(declid, provenence) => {\n                 let sub_span = self.span.sub_span_for_meth_name(ex.span);\n                 let defid = if declid.krate == ast::LOCAL_CRATE {\n                     let ti = ty::impl_or_trait_item(&self.analysis.ty_cx,\n@@ -825,7 +825,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                        Some(declid),\n                                        self.cur_scope);\n             },\n-            def::DefFn(def_id, _, _) => self.fmt.fn_call_str(ex.span,\n+            def::DefFn(def_id, _) => self.fmt.fn_call_str(ex.span,\n                                                              sub_span,\n                                                              def_id,\n                                                              self.cur_scope),\n@@ -835,7 +835,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n         // modules or types in the path prefix\n         match *def {\n-            def::DefStaticMethod(_, _, _) => {\n+            def::DefStaticMethod(..) => {\n                 self.write_sub_path_trait_truncated(path);\n             },\n             def::DefLocal(_) |"}, {"sha": "6addd9144409c9c6693165c5bad565005808d9be", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -144,7 +144,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n         debug!(\"trans_def(def={}, ref_expr={})\", def.repr(bcx.tcx()), ref_expr.repr(bcx.tcx()));\n         let expr_ty = node_id_type(bcx, ref_expr.id);\n         match def {\n-            def::DefFn(did, _, _) if {\n+            def::DefFn(did, _) if {\n                 let maybe_def_id = inline::get_local_instance(bcx.ccx(), did);\n                 let maybe_ast_node = maybe_def_id.and_then(|def_id| bcx.tcx().map\n                                                                              .find(def_id.node));\n@@ -159,19 +159,19 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     data: NamedTupleConstructor(substs, 0)\n                 }\n             }\n-            def::DefFn(did, _, _) if match ty::get(expr_ty).sty {\n+            def::DefFn(did, _) if match ty::get(expr_ty).sty {\n                 ty::ty_bare_fn(ref f) => f.abi == synabi::RustIntrinsic,\n                 _ => false\n             } => {\n                 let substs = node_id_substs(bcx, ExprId(ref_expr.id));\n                 let def_id = inline::maybe_instantiate_inline(bcx.ccx(), did);\n                 Callee { bcx: bcx, data: Intrinsic(def_id.node, substs) }\n             }\n-            def::DefFn(did, _, _) | def::DefMethod(did, _, def::FromImpl(_)) |\n-            def::DefStaticMethod(did, def::FromImpl(_), _) => {\n+            def::DefFn(did, _) | def::DefMethod(did, _, def::FromImpl(_)) |\n+            def::DefStaticMethod(did, def::FromImpl(_)) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, did, ExprId(ref_expr.id)))\n             }\n-            def::DefStaticMethod(meth_did, def::FromTrait(trait_did), _) |\n+            def::DefStaticMethod(meth_did, def::FromTrait(trait_did)) |\n             def::DefMethod(meth_did, _, def::FromTrait(trait_did)) => {\n                 fn_callee(bcx, meth::trans_static_method_callee(bcx, meth_did,\n                                                                 trait_did,"}, {"sha": "44613e85a82cb90cf417f88510ce9b679bd7c91b", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -554,7 +554,7 @@ pub fn get_wrapper_for_bare_fn(ccx: &CrateContext,\n                                is_local: bool) -> ValueRef {\n \n     let def_id = match def {\n-        def::DefFn(did, _, _) | def::DefStaticMethod(did, _, _) |\n+        def::DefFn(did, _) | def::DefStaticMethod(did, _) |\n         def::DefVariant(_, did, _) | def::DefStruct(did) => did,\n         _ => {\n             ccx.sess().bug(format!(\"get_wrapper_for_bare_fn: \\"}, {"sha": "6ba6ff6fb2113ea4023d1d2037f82372159ab50d", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -629,7 +629,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n \n             let opt_def = cx.tcx().def_map.borrow().find_copy(&e.id);\n             match opt_def {\n-                Some(def::DefFn(def_id, _fn_style, _)) => {\n+                Some(def::DefFn(def_id, _)) => {\n                     if !ast_util::is_local(def_id) {\n                         let ty = csearch::get_type(cx.tcx(), def_id).ty;\n                         base::trans_external_path(cx, def_id, ty)"}, {"sha": "f516c6106a9918715235973a246ea9da628a67d4", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -1189,13 +1189,13 @@ fn trans_def_fn_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n     let llfn = match def {\n-        def::DefFn(did, _, _) |\n+        def::DefFn(did, _) |\n         def::DefStruct(did) | def::DefVariant(_, did, _) |\n-        def::DefStaticMethod(did, def::FromImpl(_), _) |\n+        def::DefStaticMethod(did, def::FromImpl(_)) |\n         def::DefMethod(did, _, def::FromImpl(_)) => {\n             callee::trans_fn_ref(bcx, did, ExprId(ref_expr.id))\n         }\n-        def::DefStaticMethod(impl_did, def::FromTrait(trait_did), _) |\n+        def::DefStaticMethod(impl_did, def::FromTrait(trait_did)) |\n         def::DefMethod(impl_did, _, def::FromTrait(trait_did)) => {\n             meth::trans_static_method_callee(bcx, impl_did,\n                                              trait_did, ref_expr.id)"}, {"sha": "b9af31665a11313ca5e672d66355f739660b9b54", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -3626,7 +3626,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 // end (like `UnitStruct`) which means this is an ExprPath to a DefFn. But in case\n                 // of unit structs this is should not be interpreted as function pointer but as\n                 // call to the constructor.\n-                def::DefFn(_, _, true) => RvalueDpsExpr,\n+                def::DefFn(_, true) => RvalueDpsExpr,\n \n                 // Fn pointers are just scalar values.\n                 def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) => RvalueDatumExpr,"}, {"sha": "f334d8016927dfee5de0a9ef62d6b9a57a495c9a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -4990,7 +4990,7 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n           let typ = fcx.local_ty(sp, nid);\n           return no_params(typ);\n       }\n-      def::DefFn(id, _, _) | def::DefStaticMethod(id, _, _) | def::DefMethod(id, _, _) |\n+      def::DefFn(id, _) | def::DefStaticMethod(id, _) | def::DefMethod(id, _, _) |\n       def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n       def::DefStruct(id) | def::DefConst(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);"}, {"sha": "d87d8776d4a6cecb27236f3b858b09789d0013ee", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -73,10 +73,10 @@ fn try_inline_def(cx: &DocContext, tcx: &ty::ctxt,\n             record_extern_fqn(cx, did, clean::TypeTrait);\n             clean::TraitItem(build_external_trait(cx, tcx, did))\n         }\n-        def::DefFn(did, style, false) => {\n+        def::DefFn(did, false) => {\n             // If this function is a tuple struct constructor, we just skip it\n             record_extern_fqn(cx, did, clean::TypeFunction);\n-            clean::FunctionItem(build_external_function(cx, tcx, did, style))\n+            clean::FunctionItem(build_external_function(cx, tcx, did))\n         }\n         def::DefStruct(did) => {\n             record_extern_fqn(cx, did, clean::TypeStruct);\n@@ -167,15 +167,14 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n     }\n }\n \n-fn build_external_function(cx: &DocContext, tcx: &ty::ctxt,\n-                           did: ast::DefId,\n-                           style: ast::FnStyle) -> clean::Function {\n+fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Function {\n     let t = ty::lookup_item_type(tcx, did);\n+    let (decl, style) = match ty::get(t.ty).sty {\n+        ty::ty_bare_fn(ref f) => ((did, &f.sig).clean(cx), f.fn_style),\n+        _ => panic!(\"bad function\"),\n+    };\n     clean::Function {\n-        decl: match ty::get(t.ty).sty {\n-            ty::ty_bare_fn(ref f) => (did, &f.sig).clean(cx),\n-            _ => panic!(\"bad function\"),\n-        },\n+        decl: decl,\n         generics: (&t.generics, subst::FnSpace).clean(cx),\n         fn_style: style,\n     }"}, {"sha": "c128588918e28183a150caa7fbf84d8e82edc9b8", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -2124,7 +2124,7 @@ fn resolve_type(cx: &DocContext, path: Path,\n \n fn register_def(cx: &DocContext, def: def::Def) -> ast::DefId {\n     let (did, kind) = match def {\n-        def::DefFn(i, _, _) => (i, TypeFunction),\n+        def::DefFn(i, _) => (i, TypeFunction),\n         def::DefTy(i, false) => (i, TypeTypedef),\n         def::DefTy(i, true) => (i, TypeEnum),\n         def::DefTrait(i) => (i, TypeTrait),"}, {"sha": "d02222931e5de093ad3ab8cb2b814b3a942bdadd", "filename": "src/test/auxiliary/method_self_arg1.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Ftest%2Fauxiliary%2Fmethod_self_arg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Ftest%2Fauxiliary%2Fmethod_self_arg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmethod_self_arg1.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+static mut COUNT: u64 = 1;\n+\n+pub fn get_count() -> u64 { unsafe { COUNT } }\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn foo(self, x: &Foo) {\n+        unsafe { COUNT *= 2; }\n+        // Test internal call.\n+        Foo::bar(&self);\n+        Foo::bar(x);\n+\n+        Foo::baz(self);\n+        Foo::baz(*x);\n+\n+        Foo::qux(box self);\n+        Foo::qux(box *x);\n+    }\n+\n+    pub fn bar(&self) {\n+        unsafe { COUNT *= 3; }\n+    }\n+\n+    pub fn baz(self) {\n+        unsafe { COUNT *= 5; }\n+    }\n+\n+    pub fn qux(self: Box<Foo>) {\n+        unsafe { COUNT *= 7; }\n+    }\n+}"}, {"sha": "99eb665388b26c721ff2cb707ea48a91f517a730", "filename": "src/test/auxiliary/method_self_arg2.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmethod_self_arg2.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+static mut COUNT: u64 = 1;\n+\n+pub fn get_count() -> u64 { unsafe { COUNT } }\n+\n+pub struct Foo;\n+\n+impl Foo {\n+    pub fn run_trait(self) {\n+        unsafe { COUNT *= 17; }\n+        // Test internal call.\n+        Bar::foo1(&self);\n+        Bar::foo2(self);\n+        Bar::foo3(box self);\n+\n+        Bar::bar1(&self);\n+        Bar::bar2(self);\n+        Bar::bar3(box self);\n+    }\n+}\n+\n+pub trait Bar {\n+    fn foo1(&self);\n+    fn foo2(self);\n+    fn foo3(self: Box<Self>);\n+\n+    fn bar1(&self) {\n+        unsafe { COUNT *= 7; }\n+    }\n+    fn bar2(self) {\n+        unsafe { COUNT *= 11; }\n+    }\n+    fn bar3(self: Box<Self>) {\n+        unsafe { COUNT *= 13; }\n+    }\n+}\n+\n+impl Bar for Foo {\n+    fn foo1(&self) {\n+        unsafe { COUNT *= 2; }\n+    }\n+\n+    fn foo2(self) {\n+        unsafe { COUNT *= 3; }\n+    }\n+\n+    fn foo3(self: Box<Foo>) {\n+        unsafe { COUNT *= 5; }\n+    }\n+}"}, {"sha": "d4a0d514a7da668c5575cfbcce576d0e5d35a54c", "filename": "src/test/run-pass/method-self-arg-aux1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Ftest%2Frun-pass%2Fmethod-self-arg-aux1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Ftest%2Frun-pass%2Fmethod-self-arg-aux1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-self-arg-aux1.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test method calls with self as an argument (cross-crate)\n+\n+// aux-build:method_self_arg1.rs\n+extern crate method_self_arg1;\n+use method_self_arg1::Foo;\n+\n+fn main() {\n+    let x = Foo;\n+    // Test external call.\n+    Foo::bar(&x);\n+    Foo::baz(x);\n+    Foo::qux(box x);\n+\n+    x.foo(&x);\n+\n+    assert!(method_self_arg1::get_count() == 2u64*3*3*3*5*5*5*7*7*7);\n+}"}, {"sha": "b94f1ae6ba64ed313c8e28297eb16265f2c8b782", "filename": "src/test/run-pass/method-self-arg-aux2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Ftest%2Frun-pass%2Fmethod-self-arg-aux2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/88b6e93d35c34e143ba060a617e71c8af10fa15e/src%2Ftest%2Frun-pass%2Fmethod-self-arg-aux2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-self-arg-aux2.rs?ref=88b6e93d35c34e143ba060a617e71c8af10fa15e", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test method calls with self as an argument (cross-crate)\n+\n+// aux-build:method_self_arg2.rs\n+extern crate method_self_arg2;\n+use method_self_arg2::{Foo, Bar};\n+\n+fn main() {\n+    let x = Foo;\n+    // Test external call.\n+    Bar::foo1(&x);\n+    Bar::foo2(x);\n+    Bar::foo3(box x);\n+\n+    Bar::bar1(&x);\n+    Bar::bar2(x);\n+    Bar::bar3(box x);\n+\n+    x.run_trait();\n+\n+    assert!(method_self_arg2::get_count() == 2u64*2*3*3*5*5*7*7*11*11*13*13*17);\n+}"}]}