{"sha": "576b640a02d7363746aacab9d2f1b91c6b685688", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NmI2NDBhMDJkNzM2Mzc0NmFhY2FiOWQyZjFiOTFjNmI2ODU2ODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-23T01:39:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-23T01:39:54Z"}, "message": "Auto merge of #54262 - matthewjasper:explain-in-typeck, r=nikomatsakis\n\n[NLL] Record more infomation on free region constraints in typeck\n\nChanges:\n\n* Makes the span of the MIR return place point to the return type\n* Don't try to use a path to a type alias as a path to the adt it aliases (fixes an ICE)\n* Don't claim that `self` is declared outside of the function. [see this test](https://github.com/rust-lang/rust/commit/f2995d5b1ad0401a80ac4579ebc89295818c3eed#diff-0c9e6b1b204f42129b481df9ce459d44)\n* Remove boring/interesting distinction and instead add a `ConstraintCategory` to the constraint.\n* Add categories for implicit `Sized` and `Copy` requirements, for closure bounds, for user type annotations and `impl Trait`.\n* Don't use the span of the first statement for Locations::All bounds (even if it happens to work on the tests we have)\n\nFuture work:\n\n* Fine tuning the heuristic used to choose the place the report the error.\n* Reporting multiple places (behind a flag)\n* Better closure bounds reporting. This probably requires some discussion.\n\nr? @nikomatsakis", "tree": {"sha": "a82e76374d854367ebd06e569a6be717a52416dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a82e76374d854367ebd06e569a6be717a52416dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/576b640a02d7363746aacab9d2f1b91c6b685688", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/576b640a02d7363746aacab9d2f1b91c6b685688", "html_url": "https://github.com/rust-lang/rust/commit/576b640a02d7363746aacab9d2f1b91c6b685688", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/576b640a02d7363746aacab9d2f1b91c6b685688/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6e3d7fa3113aaa64602507f39d4627c427742ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6e3d7fa3113aaa64602507f39d4627c427742ff", "html_url": "https://github.com/rust-lang/rust/commit/c6e3d7fa3113aaa64602507f39d4627c427742ff"}, {"sha": "bd0895d7d011cc4c6bef4f95e6df64d2fee6ff73", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd0895d7d011cc4c6bef4f95e6df64d2fee6ff73", "html_url": "https://github.com/rust-lang/rust/commit/bd0895d7d011cc4c6bef4f95e6df64d2fee6ff73"}], "stats": {"total": 1286, "additions": 746, "deletions": 540}, "files": [{"sha": "c6f910c4ad7a4b638a896d5bbdfc55b533bf51e5", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n+    pub fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         def_id: DefId,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,"}, {"sha": "2e018f746f38937f697ed7cc856f6fb8780f8020", "filename": "src/librustc_mir/borrow_check/nll/constraints/graph.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fgraph.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -9,10 +9,12 @@\n // except according to those terms.\n \n use borrow_check::nll::type_check::Locations;\n-use borrow_check::nll::constraints::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraints::{ConstraintCategory, ConstraintIndex};\n+use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use rustc::ty::RegionVid;\n use rustc_data_structures::graph;\n use rustc_data_structures::indexed_vec::IndexVec;\n+use syntax_pos::DUMMY_SP;\n \n /// The construct graph organizes the constraints by their end-points.\n /// It can be used to view a `R1: R2` constraint as either an edge `R1\n@@ -174,7 +176,8 @@ impl<'s, D: ConstraintGraphDirecton> Iterator for Edges<'s, D> {\n             Some(OutlivesConstraint {\n                 sup: self.static_region,\n                 sub: next_static_idx.into(),\n-                locations: Locations::All,\n+                locations: Locations::All(DUMMY_SP),\n+                category: ConstraintCategory::Internal,\n             })\n         } else {\n             None"}, {"sha": "76ebc06bfd2f612617bfc144948a1f4ce6472f10", "filename": "src/librustc_mir/borrow_check/nll/constraints/mod.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraints%2Fmod.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -23,6 +23,42 @@ crate struct ConstraintSet {\n     constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n }\n \n+/// Constraints can be categorized to determine whether and why they are\n+/// interesting. Order of variants indicates sort order of the category,\n+/// thereby influencing diagnostic output.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n+pub enum ConstraintCategory {\n+    Return,\n+    TypeAnnotation,\n+    Cast,\n+    CallArgument,\n+\n+    /// A constraint that came from checking the body of a closure.\n+    ///\n+    /// Ideally we would give an explanation that points to the relevant part\n+    /// of the closure's body.\n+    ClosureBounds,\n+    CopyBound,\n+    SizedBound,\n+    Assignment,\n+    OpaqueType,\n+\n+    /// A \"boring\" constraint (caused by the given location) is one that\n+    /// the user probably doesn't want to see described in diagnostics,\n+    /// because it is kind of an artifact of the type system setup.\n+    /// Example: `x = Foo { field: y }` technically creates\n+    /// intermediate regions representing the \"type of `Foo { field: y\n+    /// }`\", and data flows from `y` into those variables, but they\n+    /// are not very interesting. The assignment into `x` on the other\n+    /// hand might be.\n+    Boring,\n+    // Boring and applicable everywhere.\n+    BoringNoLocation,\n+\n+    /// A constraint that doesn't correspond to anything the user sees.\n+    Internal,\n+}\n+\n impl ConstraintSet {\n     crate fn push(&mut self, constraint: OutlivesConstraint) {\n         debug!(\n@@ -87,6 +123,9 @@ pub struct OutlivesConstraint {\n \n     /// Where did this constraint arise?\n     pub locations: Locations,\n+\n+    /// What caused this constraint?\n+    pub category: ConstraintCategory,\n }\n \n impl fmt::Debug for OutlivesConstraint {"}, {"sha": "ee900afc44de8872548a0afe32330b702d544752", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -88,11 +88,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 sup,\n                 sub,\n                 locations,\n+                category,\n             } = constraint;\n             with_msg(&format!(\n-                \"{:?}: {:?} due to {:?}\",\n+                \"{:?}: {:?} due to {:?} at {:?}\",\n                 sup,\n                 sub,\n+                category,\n                 locations,\n             ))?;\n         }"}, {"sha": "d287116029ad1045edbaf0d6053446db449539a3", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 22, "deletions": 130, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::constraints::OutlivesConstraint;\n+use borrow_check::nll::constraints::{OutlivesConstraint, ConstraintCategory};\n use borrow_check::nll::region_infer::RegionInferenceContext;\n-use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n-use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKind};\n-use rustc::ty::{self, TyCtxt, RegionVid};\n+use rustc::mir::{Location, Mir};\n+use rustc::ty::{self, RegionVid};\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::{Diagnostic, DiagnosticBuilder};\n use std::collections::VecDeque;\n@@ -29,19 +28,6 @@ mod var_name;\n \n use self::region_name::RegionName;\n \n-/// Constraints that are considered interesting can be categorized to\n-/// determine why they are interesting. Order of variants indicates\n-/// sort order of the category, thereby influencing diagnostic output.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]\n-enum ConstraintCategory {\n-    Cast,\n-    Assignment,\n-    Return,\n-    CallArgument,\n-    Other,\n-    Boring,\n-}\n-\n impl fmt::Display for ConstraintCategory {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Must end with a space. Allows for empty names to be provided.\n@@ -50,7 +36,14 @@ impl fmt::Display for ConstraintCategory {\n             ConstraintCategory::Return => write!(f, \"returning this value \"),\n             ConstraintCategory::Cast => write!(f, \"cast \"),\n             ConstraintCategory::CallArgument => write!(f, \"argument \"),\n-            _ => write!(f, \"\"),\n+            ConstraintCategory::TypeAnnotation => write!(f, \"type annotation \"),\n+            ConstraintCategory::ClosureBounds => write!(f, \"closure body \"),\n+            ConstraintCategory::SizedBound => write!(f, \"proving this value is `Sized` \"),\n+            ConstraintCategory::CopyBound => write!(f, \"copying this value \"),\n+            ConstraintCategory::OpaqueType => write!(f, \"opaque type \"),\n+            ConstraintCategory::Boring\n+            | ConstraintCategory::BoringNoLocation\n+            | ConstraintCategory::Internal => write!(f, \"\"),\n         }\n     }\n }\n@@ -72,7 +65,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn best_blame_constraint(\n         &self,\n         mir: &Mir<'tcx>,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> (ConstraintCategory, Span, RegionVid) {\n@@ -97,7 +89,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // Classify each of the constraints along the path.\n         let mut categorized_path: Vec<(ConstraintCategory, Span)> = path\n             .iter()\n-            .map(|&index| self.classify_constraint(index, mir, tcx))\n+            .map(|constraint| (constraint.category, constraint.locations.span(mir)))\n             .collect();\n         debug!(\n             \"best_blame_constraint: categorized_path={:#?}\",\n@@ -130,12 +122,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n \n             match categorized_path[i].0 {\n-                ConstraintCategory::Boring => false,\n-                ConstraintCategory::Other => {\n-                    // other isn't interesting when the two lifetimes\n-                    // are unified.\n-                    constraint_sup_scc != self.constraint_sccs.scc(constraint.sub)\n-                }\n+                ConstraintCategory::OpaqueType\n+                | ConstraintCategory::Boring\n+                | ConstraintCategory::BoringNoLocation\n+                | ConstraintCategory::Internal => false,\n                 _ => constraint_sup_scc != target_scc,\n             }\n         });\n@@ -221,106 +211,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         None\n     }\n \n-    /// This function will return true if a constraint is interesting and false if a constraint\n-    /// is not. It is useful in filtering constraint paths to only interesting points.\n-    fn constraint_is_interesting(&self, constraint: OutlivesConstraint) -> bool {\n-        debug!(\n-            \"constraint_is_interesting: locations={:?} constraint={:?}\",\n-            constraint.locations, constraint\n-        );\n-\n-        match constraint.locations {\n-            Locations::Interesting(_) | Locations::All => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// This function classifies a constraint from a location.\n-    fn classify_constraint(\n-        &self,\n-        constraint: OutlivesConstraint,\n-        mir: &Mir<'tcx>,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-    ) -> (ConstraintCategory, Span) {\n-        debug!(\"classify_constraint: constraint={:?}\", constraint);\n-        let span = constraint.locations.span(mir);\n-        let location = constraint\n-            .locations\n-            .from_location()\n-            .unwrap_or(Location::START);\n-\n-        if !self.constraint_is_interesting(constraint) {\n-            return (ConstraintCategory::Boring, span);\n-        }\n-\n-        let data = &mir[location.block];\n-        debug!(\n-            \"classify_constraint: location={:?} data={:?}\",\n-            location, data\n-        );\n-        let category = if location.statement_index == data.statements.len() {\n-            if let Some(ref terminator) = data.terminator {\n-                debug!(\"classify_constraint: terminator.kind={:?}\", terminator.kind);\n-                match terminator.kind {\n-                    TerminatorKind::DropAndReplace { .. } => ConstraintCategory::Assignment,\n-                    // Classify calls differently depending on whether or not\n-                    // the sub region appears in the destination type (so the\n-                    // sup region is in the return type). If the return type\n-                    // contains the sub-region, then this is either an\n-                    // assignment or a return, depending on whether we are\n-                    // writing to the RETURN_PLACE or not.\n-                    //\n-                    // The idea here is that the region is being propagated\n-                    // from an input into the output place, so it's a kind of\n-                    // assignment. Otherwise, if the sub-region only appears in\n-                    // the argument types, then use the CallArgument\n-                    // classification.\n-                    TerminatorKind::Call { destination: Some((ref place, _)), .. } => {\n-                        if tcx.any_free_region_meets(\n-                            &place.ty(mir, tcx).to_ty(tcx),\n-                            |region| self.to_region_vid(region) == constraint.sub,\n-                        ) {\n-                            match place {\n-                                Place::Local(mir::RETURN_PLACE) => ConstraintCategory::Return,\n-                                _ => ConstraintCategory::Assignment,\n-                            }\n-                        } else {\n-                            ConstraintCategory::CallArgument\n-                        }\n-                    }\n-                    TerminatorKind::Call { destination: None, .. } => {\n-                        ConstraintCategory::CallArgument\n-                    }\n-                    _ => ConstraintCategory::Other,\n-                }\n-            } else {\n-                ConstraintCategory::Other\n-            }\n-        } else {\n-            let statement = &data.statements[location.statement_index];\n-            debug!(\"classify_constraint: statement.kind={:?}\", statement.kind);\n-            match statement.kind {\n-                StatementKind::Assign(ref place, ref rvalue) => {\n-                    debug!(\"classify_constraint: place={:?} rvalue={:?}\", place, rvalue);\n-                    if *place == Place::Local(mir::RETURN_PLACE) {\n-                        ConstraintCategory::Return\n-                    } else {\n-                        match rvalue {\n-                            Rvalue::Cast(..) => ConstraintCategory::Cast,\n-                            Rvalue::Use(..) | Rvalue::Aggregate(..) => {\n-                                ConstraintCategory::Assignment\n-                            }\n-                            _ => ConstraintCategory::Other,\n-                        }\n-                    }\n-                }\n-                _ => ConstraintCategory::Other,\n-            }\n-        };\n-\n-        (category, span)\n-    }\n-\n     /// Report an error because the universal region `fr` was required to outlive\n     /// `outlived_fr` but it is not known to do so. For example:\n     ///\n@@ -342,7 +232,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let (category, span, _) = self.best_blame_constraint(\n             mir,\n-            infcx.tcx,\n             fr,\n             |r| r == outlived_fr\n         );\n@@ -392,7 +281,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let escapes_from = if infcx.tcx.is_closure(mir_def_id) { \"closure\" } else { \"function\" };\n \n-        if fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none() {\n+        // Revert to the normal error in these cases.\n+        // Assignments aren't \"escapes\" in function items.\n+        if (fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none())\n+            || (category == ConstraintCategory::Assignment && escapes_from == \"function\")\n+        {\n             return self.report_general_error(mir, infcx, mir_def_id,\n                                              fr, true, outlived_fr, false,\n                                              category, span, errors_buffer);\n@@ -572,11 +465,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     crate fn find_outlives_blame_span(\n         &self,\n         mir: &Mir<'tcx>,\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n         fr1: RegionVid,\n         fr2: RegionVid,\n     ) -> Span {\n-        let (_, span, _) = self.best_blame_constraint(mir, tcx, fr1, |r| r == fr2);\n+        let (_, span, _) = self.best_blame_constraint(mir, fr1, |r| r == fr2);\n         span\n     }\n }"}, {"sha": "f704ee61c8847e951b7f7f3fbb4193bb85e5db0e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -452,16 +452,23 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     ty::Adt(_adt_def, substs),\n                     hir::TyKind::Path(hir::QPath::Resolved(None, path)),\n                 ) => {\n-                    if let Some(last_segment) = path.segments.last() {\n-                        if let Some(name) = self.match_adt_and_segment(\n-                            substs,\n-                            needle_fr,\n-                            last_segment,\n-                            counter,\n-                            diag,\n-                            search_stack,\n-                        ) {\n-                            return Some(name);\n+                    match path.def {\n+                        // Type parameters of the type alias have no reason to\n+                        // be the same as those of the ADT.\n+                        // FIXME: We should be able to do something similar to\n+                        // match_adt_and_segment in this case.\n+                        hir::def::Def::TyAlias(_) => (),\n+                        _ => if let Some(last_segment) = path.segments.last() {\n+                            if let Some(name) = self.match_adt_and_segment(\n+                                substs,\n+                                needle_fr,\n+                                last_segment,\n+                                counter,\n+                                diag,\n+                                search_stack,\n+                            ) {\n+                                return Some(name);\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "75f14a6bbdac8f87b2de738ff0881d783e08c541", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1062,7 +1062,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 longer_fr, shorter_fr,\n             );\n \n-            let blame_span = self.find_outlives_blame_span(mir, infcx.tcx, longer_fr, shorter_fr);\n+            let blame_span = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n@@ -1147,7 +1147,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-        let span = self.find_outlives_blame_span(mir, infcx.tcx, longer_fr, error_region);\n+        let span = self.find_outlives_blame_span(mir, longer_fr, error_region);\n \n         // Obviously, this error message is far from satisfactory.\n         // At present, though, it only appears in unit tests --"}, {"sha": "430c8d673921b57cde4e0b2fe153d3254427ba91", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use borrow_check::location::LocationTable;\n-use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{RegionTest, TypeTest};\n use borrow_check::nll::type_check::Locations;\n@@ -30,6 +30,7 @@ crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n+    category: ConstraintCategory,\n     outlives_constraints: &'a mut ConstraintSet,\n     type_tests: &'a mut Vec<TypeTest<'tcx>>,\n     all_facts: &'a mut Option<AllFacts>,\n@@ -44,6 +45,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n+        category: ConstraintCategory,\n         outlives_constraints: &'a mut ConstraintSet,\n         type_tests: &'a mut Vec<TypeTest<'tcx>>,\n         all_facts: &'a mut Option<AllFacts>,\n@@ -56,6 +58,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n             implicit_region_bound,\n             param_env,\n             locations,\n+            category,\n             outlives_constraints,\n             type_tests,\n             all_facts,\n@@ -183,6 +186,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n         self.outlives_constraints.push(OutlivesConstraint {\n             locations: self.locations,\n+            category: self.category,\n             sub,\n             sup,\n         });"}, {"sha": "61c612b3c01186a263a252d3de7cd76f5d56ba26", "filename": "src/librustc_mir/borrow_check/nll/type_check/free_region_relations.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Ffree_region_relations.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -14,6 +14,7 @@ use borrow_check::nll::type_check::constraint_conversion;\n use borrow_check::nll::type_check::{Locations, MirTypeckRegionConstraints};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n+use borrow_check::nll::constraints::ConstraintCategory;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::free_region_map::FreeRegionRelations;\n use rustc::infer::region_constraints::GenericKind;\n@@ -23,6 +24,7 @@ use rustc::traits::query::type_op::{self, TypeOp};\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use std::rc::Rc;\n+use syntax_pos::DUMMY_SP;\n \n #[derive(Debug)]\n crate struct UniversalRegionRelations<'tcx> {\n@@ -283,7 +285,8 @@ impl UniversalRegionRelationsBuilder<'cx, 'gcx, 'tcx> {\n                 &self.region_bound_pairs,\n                 self.implicit_region_bound,\n                 self.param_env,\n-                Locations::All,\n+                Locations::All(DUMMY_SP),\n+                ConstraintCategory::Internal,\n                 &mut self.constraints.outlives_constraints,\n                 &mut self.constraints.type_tests,\n                 &mut self.all_facts,"}, {"sha": "6c7e2e9b72e302165969b287cea4ad404605f203", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -29,8 +29,9 @@ use rustc::ty::subst::Subst;\n use rustc::ty::Ty;\n \n use rustc_data_structures::indexed_vec::Idx;\n+use syntax_pos::Span;\n \n-use super::{Locations, TypeChecker};\n+use super::{ConstraintCategory, Locations, TypeChecker};\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     pub(super) fn equate_inputs_and_outputs(\n@@ -56,7 +57,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             );\n \n             let mir_input_ty = mir.local_decls[local].ty;\n-            self.equate_normalized_input_or_output(normalized_input_ty, mir_input_ty);\n+            let mir_input_span = mir.local_decls[local].source_info.span;\n+            self.equate_normalized_input_or_output(\n+                normalized_input_ty,\n+                mir_input_ty,\n+                mir_input_span,\n+            );\n         }\n \n         assert!(\n@@ -65,16 +71,19 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         );\n         if let Some(mir_yield_ty) = mir.yield_ty {\n             let ur_yield_ty = universal_regions.yield_ty.unwrap();\n-            self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty);\n+            let yield_span = mir.local_decls[RETURN_PLACE].source_info.span;\n+            self.equate_normalized_input_or_output(ur_yield_ty, mir_yield_ty, yield_span);\n         }\n \n         // Return types are a bit more complex. They may contain existential `impl Trait`\n         // types.\n         let param_env = self.param_env;\n         let mir_output_ty = mir.local_decls[RETURN_PLACE].ty;\n+        let output_span = mir.local_decls[RETURN_PLACE].source_info.span;\n         let opaque_type_map =\n             self.fully_perform_op(\n-                Locations::All,\n+                Locations::All(output_span),\n+                ConstraintCategory::BoringNoLocation,\n                 CustomTypeOp::new(\n                     |infcx| {\n                         let mut obligations = ObligationAccumulator::default();\n@@ -152,26 +161,38 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         // prove that `T: Iterator` where `T` is the type we\n         // instantiated it with).\n         if let Some(opaque_type_map) = opaque_type_map {\n-            self.fully_perform_op(\n-                Locations::All,\n-                CustomTypeOp::new(\n-                    |_cx| {\n-                        infcx.constrain_opaque_types(&opaque_type_map, universal_region_relations);\n-                        Ok(InferOk {\n-                            value: (),\n-                            obligations: vec![],\n-                        })\n-                    },\n-                    || \"opaque_type_map\".to_string(),\n-                ),\n-            ).unwrap();\n+            for (opaque_def_id, opaque_decl) in opaque_type_map {\n+                self.fully_perform_op(\n+                    Locations::All(infcx.tcx.def_span(opaque_def_id)),\n+                    ConstraintCategory::OpaqueType,\n+                    CustomTypeOp::new(\n+                        |_cx| {\n+                            infcx.constrain_opaque_type(\n+                                opaque_def_id,\n+                                &opaque_decl,\n+                                universal_region_relations\n+                            );\n+                            Ok(InferOk {\n+                                value: (),\n+                                obligations: vec![],\n+                            })\n+                        },\n+                        || \"opaque_type_map\".to_string(),\n+                    ),\n+                ).unwrap();\n+            }\n         }\n     }\n \n-    fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+    fn equate_normalized_input_or_output(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, span: Span) {\n         debug!(\"equate_normalized_input_or_output(a={:?}, b={:?})\", a, b);\n \n-        if let Err(terr) = self.eq_types(a, b, Locations::All) {\n+        if let Err(terr) = self.eq_types(\n+            a,\n+            b,\n+            Locations::All(span),\n+            ConstraintCategory::BoringNoLocation,\n+        ) {\n             span_mirbug!(\n                 self,\n                 Location::START,"}, {"sha": "e706c1adaddfbb00a9b51e0c280718f44f0a0420", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::nll::constraints::ConstraintCategory;\n use borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n use borrow_check::nll::type_check::liveness::liveness_map::{LiveVar, NllLivenessMap};\n use borrow_check::nll::type_check::liveness::local_use_map::LocalUseMap;\n-use borrow_check::nll::type_check::AtLocation;\n+use borrow_check::nll::type_check::NormalizeLocation;\n use borrow_check::nll::type_check::TypeChecker;\n use dataflow::move_paths::indexes::MovePathIndex;\n use dataflow::move_paths::MoveData;\n@@ -487,7 +488,11 @@ impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n         if let Some(data) = &drop_data.region_constraint_data {\n             for &drop_location in drop_locations {\n                 self.typeck\n-                    .push_region_constraints(drop_location.boring(), data);\n+                    .push_region_constraints(\n+                        drop_location.to_locations(),\n+                        ConstraintCategory::Boring,\n+                        data,\n+                    );\n             }\n         }\n "}, {"sha": "a20d7cc561979555ed39308e75d2833adecc584e", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 242, "deletions": 145, "changes": 387, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -13,7 +13,7 @@\n \n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n-use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::constraints::{ConstraintCategory, ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n@@ -252,7 +252,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 constant.ty,\n                 ty::Variance::Invariant,\n                 user_ty,\n-                location.boring(),\n+                location.to_locations(),\n+                ConstraintCategory::Boring,\n             ) {\n                 span_mirbug!(\n                     self,\n@@ -281,7 +282,8 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 local_decl.ty,\n                 ty::Variance::Invariant,\n                 user_ty,\n-                Locations::All,\n+                Locations::All(local_decl.source_info.span),\n+                ConstraintCategory::TypeAnnotation,\n             ) {\n                 span_mirbug!(\n                     self,\n@@ -364,14 +366,19 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             let instantiated_predicates = tcx.predicates_of(def_id).instantiate(tcx, substs);\n             type_checker.normalize_and_prove_instantiated_predicates(\n                 instantiated_predicates,\n-                location.boring(),\n+                location.to_locations(),\n             );\n         }\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", constant.literal.ty);\n \n         if let Err(terr) = self.cx\n-            .eq_types(constant.literal.ty, constant.ty, location.boring())\n+            .eq_types(\n+                constant.literal.ty,\n+                constant.ty,\n+                location.to_locations(),\n+                ConstraintCategory::Boring,\n+            )\n         {\n             span_mirbug!(\n                 self,\n@@ -417,7 +424,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) = self.cx.eq_types(ty, sty, location.boring()) {\n+                if let Err(terr) = self.cx.eq_types(\n+                    ty,\n+                    sty,\n+                    location.to_locations(),\n+                    ConstraintCategory::Boring,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         place,\n@@ -461,7 +473,11 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             // (e.g., #29149). Note that we decide to use Copy before knowing whether the bounds\n             // fully apply: in effect, the rule is that if a value of some type could implement\n             // Copy, then it must.\n-            self.cx.prove_trait_ref(trait_ref, location.interesting());\n+            self.cx.prove_trait_ref(\n+                trait_ref,\n+                location.to_locations(),\n+                ConstraintCategory::CopyBound,\n+            );\n         }\n         place_ty\n     }\n@@ -560,7 +576,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(place, fty);\n                 match self.field_ty(place, base, field, location) {\n-                    Ok(ty) => if let Err(terr) = self.cx.eq_types(ty, fty, location.boring()) {\n+                    Ok(ty) => if let Err(terr) = self.cx.eq_types(\n+                        ty,\n+                        fty,\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring,\n+                    ) {\n                         span_mirbug!(\n                             self,\n                             place,\n@@ -740,43 +761,32 @@ pub enum Locations {\n     /// user-given type annotations; e.g., if the user wrote `let mut\n     /// x: &'static u32 = ...`, we would ensure that all values\n     /// assigned to `x` are of `'static` lifetime.\n-    All,\n-\n-    /// A \"boring\" constraint (caused by the given location) is one that\n-    /// the user probably doesn't want to see described in diagnostics,\n-    /// because it is kind of an artifact of the type system setup.\n     ///\n-    /// Example: `x = Foo { field: y }` technically creates\n-    /// intermediate regions representing the \"type of `Foo { field: y\n-    /// }`\", and data flows from `y` into those variables, but they\n-    /// are not very interesting. The assignment into `x` on the other\n-    /// hand might be.\n-    Boring(Location),\n-\n-    /// An *important* outlives constraint (caused by the given\n-    /// location) is one that would be useful to highlight in\n-    /// diagnostics, because it represents a point where references\n-    /// flow from one spot to another (e.g., `x = y`)\n-    Interesting(Location),\n+    /// The span points to the place the constraint arose. For example,\n+    /// it points to the type in a user-given type annotation. If\n+    /// there's no sensible span then it's DUMMY_SP.\n+    All(Span),\n+\n+    /// An outlives constraint that only has to hold at a single location,\n+    /// usually it represents a point where references flow from one spot to\n+    /// another (e.g., `x = y`)\n+    Single(Location),\n }\n \n impl Locations {\n     pub fn from_location(&self) -> Option<Location> {\n         match self {\n-            Locations::All => None,\n-            Locations::Boring(from_location) | Locations::Interesting(from_location) => {\n-                Some(*from_location)\n-            }\n+            Locations::All(_) => None,\n+            Locations::Single(from_location) => Some(*from_location),\n         }\n     }\n \n     /// Gets a span representing the location.\n     pub fn span(&self, mir: &Mir<'_>) -> Span {\n-        let span_location = match self {\n-            Locations::All => Location::START,\n-            Locations::Boring(l) | Locations::Interesting(l) => *l,\n-        };\n-        mir.source_info(span_location).span\n+        match self {\n+            Locations::All(span) => *span,\n+            Locations::Single(l) => mir.source_info(*l).span,\n+        }\n     }\n }\n \n@@ -816,12 +826,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn fully_perform_op<R>(\n         &mut self,\n         locations: Locations,\n+        category: ConstraintCategory,\n         op: impl type_op::TypeOp<'gcx, 'tcx, Output = R>,\n     ) -> Fallible<R> {\n         let (r, opt_data) = op.fully_perform(self.infcx)?;\n \n         if let Some(data) = &opt_data {\n-            self.push_region_constraints(locations, data);\n+            self.push_region_constraints(locations, category, data);\n         }\n \n         Ok(r)\n@@ -830,6 +841,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     fn push_region_constraints(\n         &mut self,\n         locations: Locations,\n+        category: ConstraintCategory,\n         data: &[QueryRegionConstraint<'tcx>],\n     ) {\n         debug!(\n@@ -846,29 +858,44 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 self.implicit_region_bound,\n                 self.param_env,\n                 locations,\n+                category,\n                 &mut borrowck_context.constraints.outlives_constraints,\n                 &mut borrowck_context.constraints.type_tests,\n                 &mut borrowck_context.all_facts,\n             ).convert_all(&data);\n         }\n     }\n \n-    fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n+    fn sub_types(\n+        &mut self,\n+        sub: Ty<'tcx>,\n+        sup: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n         relate_tys::sub_types(\n             self.infcx,\n             sub,\n             sup,\n             locations,\n+            category,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n \n-    fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n+    fn eq_types(\n+        &mut self,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) -> Fallible<()> {\n         relate_tys::eq_types(\n             self.infcx,\n             a,\n             b,\n             locations,\n+            category,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n@@ -879,13 +906,15 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         v: ty::Variance,\n         b: CanonicalTy<'tcx>,\n         locations: Locations,\n+        category: ConstraintCategory,\n     ) -> Fallible<()> {\n         relate_tys::relate_type_and_user_type(\n             self.infcx,\n             a,\n             v,\n             b,\n             locations,\n+            category,\n             self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n@@ -903,21 +932,22 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n-                let is_temp = if let Place::Local(l) = *place {\n-                    l != RETURN_PLACE && !mir.local_decls[l].is_user_variable.is_some()\n-                } else {\n-                    false\n-                };\n-\n-                let locations = if is_temp {\n-                    location.boring()\n-                } else {\n-                    location.interesting()\n+                let category = match *place {\n+                    Place::Local(RETURN_PLACE) => ConstraintCategory::Return,\n+                    Place::Local(l) if !mir.local_decls[l].is_user_variable.is_some() => {\n+                        ConstraintCategory::Boring\n+                    }\n+                    _ => ConstraintCategory::Assignment,\n                 };\n \n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n+                if let Err(terr) = self.sub_types(\n+                    rv_ty,\n+                    place_ty,\n+                    location.to_locations(),\n+                    category,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -933,7 +963,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         rv_ty,\n                         ty::Variance::Invariant,\n                         user_ty,\n-                        location.boring(),\n+                        location.to_locations(),\n+                        ConstraintCategory::Boring,\n                     ) {\n                         span_mirbug!(\n                             self,\n@@ -952,7 +983,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         def_id: tcx.lang_items().sized_trait().unwrap(),\n                         substs: tcx.mk_substs_trait(place_ty, &[]),\n                     };\n-                    self.prove_trait_ref(trait_ref, location.interesting());\n+                    self.prove_trait_ref(\n+                        trait_ref,\n+                        location.to_locations(),\n+                    ConstraintCategory::SizedBound,\n+                    );\n                 }\n             }\n             StatementKind::SetDiscriminant {\n@@ -983,7 +1018,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             StatementKind::AscribeUserType(ref place, variance, c_ty) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 if let Err(terr) =\n-                    self.relate_type_and_user_type(place_ty, variance, c_ty, Locations::All)\n+                    self.relate_type_and_user_type(\n+                        place_ty,\n+                        variance,\n+                        c_ty,\n+                        Locations::All(stmt.source_info.span),\n+                        ConstraintCategory::TypeAnnotation,\n+                    )\n                 {\n                     span_mirbug!(\n                         self,\n@@ -1035,8 +1076,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let place_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n \n-                let locations = term_location.interesting();\n-                if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n+                let locations = term_location.to_locations();\n+                if let Err(terr) = self.sub_types(\n+                    rv_ty,\n+                    place_ty,\n+                    locations,\n+                    ConstraintCategory::Assignment,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1053,7 +1099,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ..\n             } => {\n                 let discr_ty = discr.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(discr_ty, switch_ty, term_location.boring()) {\n+                if let Err(terr) = self.sub_types(\n+                    discr_ty,\n+                    switch_ty,\n+                    term_location.to_locations(),\n+                    ConstraintCategory::Assignment,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1093,7 +1144,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 self.prove_predicates(\n                     sig.inputs().iter().map(|ty| ty::Predicate::WellFormed(ty)),\n-                    term_location.boring(),\n+                    term_location.to_locations(),\n+                    ConstraintCategory::Boring,\n                 );\n \n                 // The ordinary liveness rules will ensure that all\n@@ -1139,7 +1191,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 match mir.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n                     Some(ty) => {\n-                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.interesting())\n+                        if let Err(terr) = self.sub_types(\n+                            value_ty,\n+                            ty,\n+                            term_location.to_locations(),\n+                            ConstraintCategory::Return,\n+                        )\n                         {\n                             span_mirbug!(\n                                 self,\n@@ -1168,19 +1225,22 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match *destination {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                let is_temp = if let Place::Local(l) = *dest {\n-                    l != RETURN_PLACE && !mir.local_decls[l].is_user_variable.is_some()\n-                } else {\n-                    false\n+                let category = match *dest {\n+                    Place::Local(RETURN_PLACE) => ConstraintCategory::Return,\n+                    Place::Local(l) if !mir.local_decls[l].is_user_variable.is_some() => {\n+                        ConstraintCategory::Boring\n+                    }\n+                    _ => ConstraintCategory::Assignment,\n                 };\n \n-                let locations = if is_temp {\n-                    term_location.boring()\n-                } else {\n-                    term_location.interesting()\n-                };\n+                let locations = term_location.to_locations();\n \n-                if let Err(terr) = self.sub_types(sig.output(), dest_ty, locations) {\n+                if let Err(terr) = self.sub_types(\n+                    sig.output(),\n+                    dest_ty,\n+                    locations,\n+                    category,\n+                ) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -1221,7 +1281,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n-            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, term_location.interesting()) {\n+            if let Err(terr) = self.sub_types(\n+                op_arg_ty,\n+                fn_arg,\n+                term_location.to_locations(),\n+                ConstraintCategory::CallArgument,\n+            ) {\n                 span_mirbug!(\n                     self,\n                     term,\n@@ -1470,7 +1535,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     substs: tcx.mk_substs_trait(operand_ty, &[]),\n                 };\n \n-                self.prove_trait_ref(trait_ref, location.interesting());\n+                self.prove_trait_ref(\n+                    trait_ref,\n+                    location.to_locations(),\n+                    ConstraintCategory::CopyBound,\n+                );\n             },\n \n             Rvalue::NullaryOp(_, ty) => {\n@@ -1485,91 +1554,116 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     substs: tcx.mk_substs_trait(ty, &[]),\n                 };\n \n-                self.prove_trait_ref(trait_ref, location.interesting());\n+                self.prove_trait_ref(\n+                    trait_ref,\n+                    location.to_locations(),\n+                    ConstraintCategory::SizedBound,\n+                );\n             }\n \n-            Rvalue::Cast(cast_kind, op, ty) => match cast_kind {\n-                CastKind::ReifyFnPointer => {\n-                    let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n+            Rvalue::Cast(cast_kind, op, ty) => {\n+                match cast_kind {\n+                    CastKind::ReifyFnPointer => {\n+                        let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n \n-                    // The type that we see in the fcx is like\n-                    // `foo::<'a, 'b>`, where `foo` is the path to a\n-                    // function definition. When we extract the\n-                    // signature, it comes from the `fn_sig` query,\n-                    // and hence may contain unnormalized results.\n-                    let fn_sig = self.normalize(fn_sig, location);\n+                        // The type that we see in the fcx is like\n+                        // `foo::<'a, 'b>`, where `foo` is the path to a\n+                        // function definition. When we extract the\n+                        // signature, it comes from the `fn_sig` query,\n+                        // and hence may contain unnormalized results.\n+                        let fn_sig = self.normalize(fn_sig, location);\n \n-                    let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n+                        let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n-                        span_mirbug!(\n+                        if let Err(terr) = self.eq_types(\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        ) {\n+                            span_mirbug!(\n                             self,\n                             rvalue,\n                             \"equating {:?} with {:?} yields {:?}\",\n                             ty_fn_ptr_from,\n                             ty,\n                             terr\n                         );\n+                        }\n                     }\n-                }\n \n-                CastKind::ClosureFnPointer => {\n-                    let sig = match op.ty(mir, tcx).sty {\n-                        ty::Closure(def_id, substs) => {\n-                            substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n-                        }\n-                        _ => bug!(),\n-                    };\n-                    let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig);\n+                    CastKind::ClosureFnPointer => {\n+                        let sig = match op.ty(mir, tcx).sty {\n+                            ty::Closure(def_id, substs) => {\n+                                substs.closure_sig_ty(def_id, tcx).fn_sig(tcx)\n+                            }\n+                            _ => bug!(),\n+                        };\n+                        let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n-                        span_mirbug!(\n+                        if let Err(terr) = self.eq_types(\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        ) {\n+                            span_mirbug!(\n                             self,\n                             rvalue,\n                             \"equating {:?} with {:?} yields {:?}\",\n                             ty_fn_ptr_from,\n                             ty,\n                             terr\n                         );\n+                        }\n                     }\n-                }\n \n-                CastKind::UnsafeFnPointer => {\n-                    let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n+                    CastKind::UnsafeFnPointer => {\n+                        let fn_sig = op.ty(mir, tcx).fn_sig(tcx);\n \n-                    // The type that we see in the fcx is like\n-                    // `foo::<'a, 'b>`, where `foo` is the path to a\n-                    // function definition. When we extract the\n-                    // signature, it comes from the `fn_sig` query,\n-                    // and hence may contain unnormalized results.\n-                    let fn_sig = self.normalize(fn_sig, location);\n+                        // The type that we see in the fcx is like\n+                        // `foo::<'a, 'b>`, where `foo` is the path to a\n+                        // function definition. When we extract the\n+                        // signature, it comes from the `fn_sig` query,\n+                        // and hence may contain unnormalized results.\n+                        let fn_sig = self.normalize(fn_sig, location);\n \n-                    let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n+                        let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n-                        span_mirbug!(\n+                        if let Err(terr) = self.eq_types(\n+                            ty_fn_ptr_from,\n+                            ty,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        ) {\n+                            span_mirbug!(\n                             self,\n                             rvalue,\n                             \"equating {:?} with {:?} yields {:?}\",\n                             ty_fn_ptr_from,\n                             ty,\n                             terr\n                         );\n+                        }\n                     }\n-                }\n \n-                CastKind::Unsize => {\n-                    let &ty = ty;\n-                    let trait_ref = ty::TraitRef {\n-                        def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n-                        substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty.into()]),\n-                    };\n+                    CastKind::Unsize => {\n+                        let &ty = ty;\n+                        let trait_ref = ty::TraitRef {\n+                            def_id: tcx.lang_items().coerce_unsized_trait().unwrap(),\n+                            substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty.into()]),\n+                        };\n \n-                    self.prove_trait_ref(trait_ref, location.interesting());\n-                }\n+                        self.prove_trait_ref(\n+                            trait_ref,\n+                            location.to_locations(),\n+                            ConstraintCategory::Cast,\n+                        );\n+                    }\n \n-                CastKind::Misc => {}\n-            },\n+                    CastKind::Misc => {}\n+                }\n+            }\n \n             Rvalue::Ref(region, _borrow_kind, borrowed_place) => {\n                 self.add_reborrow_constraint(location, region, borrowed_place);\n@@ -1644,7 +1738,12 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             };\n             let operand_ty = operand.ty(mir, tcx);\n \n-            if let Err(terr) = self.sub_types(operand_ty, field_ty, location.boring()) {\n+            if let Err(terr) = self.sub_types(\n+                operand_ty,\n+                field_ty,\n+                location.to_locations(),\n+                ConstraintCategory::Boring,\n+            ) {\n                 span_mirbug!(\n                     self,\n                     rvalue,\n@@ -1723,7 +1822,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             constraints.outlives_constraints.push(OutlivesConstraint {\n                                 sup: ref_region.to_region_vid(),\n                                 sub: borrow_region.to_region_vid(),\n-                                locations: location.boring(),\n+                                locations: location.to_locations(),\n+                                category: ConstraintCategory::Boring,\n                             });\n \n                             if let Some(all_facts) = all_facts {\n@@ -1839,8 +1939,11 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         *substs,\n                     );\n \n-                    // Hmm, are these constraints *really* boring?\n-                    self.push_region_constraints(location.boring(), &closure_constraints);\n+                    self.push_region_constraints(\n+                        location.to_locations(),\n+                        ConstraintCategory::ClosureBounds,\n+                        &closure_constraints,\n+                    );\n                 }\n \n                 tcx.predicates_of(*def_id).instantiate(tcx, substs.substs)\n@@ -1855,16 +1958,22 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n         self.normalize_and_prove_instantiated_predicates(\n             instantiated_predicates,\n-            location.boring(),\n+            location.to_locations(),\n         );\n     }\n \n-    fn prove_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>, locations: Locations) {\n+    fn prove_trait_ref(\n+        &mut self,\n+        trait_ref: ty::TraitRef<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n         self.prove_predicates(\n             Some(ty::Predicate::Trait(\n                 trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n             )),\n             locations,\n+            category,\n         );\n     }\n \n@@ -1875,26 +1984,32 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     ) {\n         for predicate in instantiated_predicates.predicates {\n             let predicate = self.normalize(predicate, locations);\n-            self.prove_predicate(predicate, locations);\n+            self.prove_predicate(predicate, locations, ConstraintCategory::Boring);\n         }\n     }\n \n     fn prove_predicates(\n         &mut self,\n         predicates: impl IntoIterator<Item = ty::Predicate<'tcx>>,\n         locations: Locations,\n+        category: ConstraintCategory,\n     ) {\n         for predicate in predicates {\n             debug!(\n                 \"prove_predicates(predicate={:?}, locations={:?})\",\n                 predicate, locations,\n             );\n \n-            self.prove_predicate(predicate, locations);\n+            self.prove_predicate(predicate, locations, category);\n         }\n     }\n \n-    fn prove_predicate(&mut self, predicate: ty::Predicate<'tcx>, locations: Locations) {\n+    fn prove_predicate(\n+        &mut self,\n+        predicate: ty::Predicate<'tcx>,\n+        locations: Locations,\n+        category: ConstraintCategory,\n+    ) {\n         debug!(\n             \"prove_predicate(predicate={:?}, location={:?})\",\n             predicate, locations,\n@@ -1903,6 +2018,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             locations,\n+            category,\n             param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n         ).unwrap_or_else(|NoSolution| {\n             span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n@@ -1943,6 +2059,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         let param_env = self.param_env;\n         self.fully_perform_op(\n             location.to_locations(),\n+            ConstraintCategory::Boring,\n             param_env.and(type_op::normalize::Normalize::new(value)),\n         ).unwrap_or_else(|NoSolution| {\n             span_mirbug!(self, NoSolution, \"failed to normalize `{:?}`\", value);\n@@ -1996,26 +2113,6 @@ impl MirPass for TypeckMir {\n     }\n }\n \n-pub trait AtLocation {\n-    /// Indicates a \"boring\" constraint that the user probably\n-    /// woudln't want to see highlights.\n-    fn boring(self) -> Locations;\n-\n-    /// Indicates an \"interesting\" edge, which is of significance only\n-    /// for diagnostics.\n-    fn interesting(self) -> Locations;\n-}\n-\n-impl AtLocation for Location {\n-    fn boring(self) -> Locations {\n-        Locations::Boring(self)\n-    }\n-\n-    fn interesting(self) -> Locations {\n-        Locations::Interesting(self)\n-    }\n-}\n-\n trait NormalizeLocation: fmt::Debug + Copy {\n     fn to_locations(self) -> Locations;\n }\n@@ -2028,6 +2125,6 @@ impl NormalizeLocation for Locations {\n \n impl NormalizeLocation for Location {\n     fn to_locations(self) -> Locations {\n-        self.boring()\n+        Locations::Single(self)\n     }\n }"}, {"sha": "130b4b31d08e830e4efe91eda5eaa5c3384f1b0c", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::constraints::OutlivesConstraint;\n+use borrow_check::nll::constraints::{ConstraintCategory, OutlivesConstraint};\n use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n@@ -28,13 +28,15 @@ pub(super) fn sub_types<'tcx>(\n     a: Ty<'tcx>,\n     b: Ty<'tcx>,\n     locations: Locations,\n+    category: ConstraintCategory,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<()> {\n     debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n         infcx,\n         ty::Variance::Covariant,\n         locations,\n+        category,\n         borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n@@ -47,13 +49,15 @@ pub(super) fn eq_types<'tcx>(\n     a: Ty<'tcx>,\n     b: Ty<'tcx>,\n     locations: Locations,\n+    category: ConstraintCategory,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<()> {\n     debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n     TypeRelating::new(\n         infcx,\n         ty::Variance::Invariant,\n         locations,\n+        category,\n         borrowck_context,\n         ty::List::empty(),\n     ).relate(&a, &b)?;\n@@ -69,6 +73,7 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n     v: ty::Variance,\n     b: CanonicalTy<'tcx>,\n     locations: Locations,\n+    category: ConstraintCategory,\n     borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n ) -> Fallible<()> {\n     debug!(\n@@ -89,6 +94,7 @@ pub(super) fn relate_type_and_user_type<'tcx>(\n         infcx,\n         v1,\n         locations,\n+        category,\n         borrowck_context,\n         b_variables,\n     ).relate(&b_value, &a)?;\n@@ -124,6 +130,8 @@ struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n     /// Where (and why) is this relation taking place?\n     locations: Locations,\n \n+    category: ConstraintCategory,\n+\n     /// This will be `Some` when we are running the type check as part\n     /// of NLL, and `None` if we are running a \"sanity check\".\n     borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n@@ -161,6 +169,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n         infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n         ambient_variance: ty::Variance,\n         locations: Locations,\n+        category: ConstraintCategory,\n         borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n         canonical_var_infos: CanonicalVarInfos<'tcx>,\n     ) -> Self {\n@@ -171,6 +180,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n             borrowck_context,\n             locations,\n             canonical_var_values,\n+            category,\n             a_scopes: vec![],\n             b_scopes: vec![],\n         }\n@@ -264,6 +274,7 @@ impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n                     sup,\n                     sub,\n                     locations: self.locations,\n+                    category: self.category,\n                 });\n \n             // FIXME all facts!"}, {"sha": "f75ce7b08162d35a95e1135c78643f403f9c7b86", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 49, "deletions": 14, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -40,16 +40,44 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n     let id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n     // Figure out what primary body this item has.\n-    let body_id = match tcx.hir.get(id) {\n+    let (body_id, return_ty_span) = match tcx.hir.get(id) {\n         Node::Variant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n         Node::StructCtor(ctor) =>\n             return create_constructor_shim(tcx, id, ctor),\n \n-        _ => match tcx.hir.maybe_body_owned_by(id) {\n-            Some(body) => body,\n-            None => span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id),\n-        },\n+        Node::Expr(hir::Expr { node: hir::ExprKind::Closure(_, decl, body_id, _, _), .. })\n+        | Node::Item(hir::Item { node: hir::ItemKind::Fn(decl, _, _, body_id), .. })\n+        | Node::ImplItem(\n+            hir::ImplItem {\n+                node: hir::ImplItemKind::Method(hir::MethodSig { decl, .. }, body_id),\n+                ..\n+            }\n+        )\n+        | Node::TraitItem(\n+            hir::TraitItem {\n+                node: hir::TraitItemKind::Method(\n+                    hir::MethodSig { decl, .. },\n+                    hir::TraitMethod::Provided(body_id),\n+                ),\n+                ..\n+            }\n+        ) => {\n+            (*body_id, decl.output.span())\n+        }\n+        Node::Item(hir::Item { node: hir::ItemKind::Static(ty, _, body_id), .. })\n+        | Node::Item(hir::Item { node: hir::ItemKind::Const(ty, body_id), .. })\n+        | Node::ImplItem(hir::ImplItem { node: hir::ImplItemKind::Const(ty, body_id), .. })\n+        | Node::TraitItem(\n+            hir::TraitItem { node: hir::TraitItemKind::Const(ty, Some(body_id)), .. }\n+        ) => {\n+            (*body_id, ty.span)\n+        }\n+        Node::AnonConst(hir::AnonConst { body, id, .. }) => {\n+            (*body, tcx.hir.span(*id))\n+        }\n+\n+        _ => span_bug!(tcx.hir.span(id), \"can't build MIR for {:?}\", def_id),\n     };\n \n     tcx.infer_ctxt().enter(|infcx| {\n@@ -124,9 +152,9 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             };\n \n             build::construct_fn(cx, id, arguments, safety, abi,\n-                                return_ty, yield_ty, body)\n+                                return_ty, yield_ty, return_ty_span, body)\n         } else {\n-            build::construct_const(cx, body_id)\n+            build::construct_const(cx, body_id, return_ty_span)\n         };\n \n         // Convert the Mir to global types.\n@@ -494,6 +522,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                                    abi: Abi,\n                                    return_ty: Ty<'gcx>,\n                                    yield_ty: Option<Ty<'gcx>>,\n+                                   return_ty_span: Span,\n                                    body: &'gcx hir::Body)\n                                    -> Mir<'tcx>\n     where A: Iterator<Item=ArgInfo<'gcx>>\n@@ -547,6 +576,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         arguments.len(),\n         safety,\n         return_ty,\n+        return_ty_span,\n         upvar_decls);\n \n     let fn_def_id = tcx.hir.local_def_id(fn_id);\n@@ -601,15 +631,17 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     mir\n }\n \n-fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n-                                   body_id: hir::BodyId)\n-                                   -> Mir<'tcx> {\n+fn construct_const<'a, 'gcx, 'tcx>(\n+    hir: Cx<'a, 'gcx, 'tcx>,\n+    body_id: hir::BodyId,\n+    ty_span: Span,\n+) -> Mir<'tcx> {\n     let tcx = hir.tcx();\n     let ast_expr = &tcx.hir.body(body_id).value;\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir.body_owner(body_id);\n     let span = tcx.hir.span(owner_id);\n-    let mut builder = Builder::new(hir.clone(), span, 0, Safety::Safe, ty, vec![]);\n+    let mut builder = Builder::new(hir.clone(), span, 0, Safety::Safe, ty, ty_span,vec![]);\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n@@ -637,7 +669,7 @@ fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let owner_id = hir.tcx().hir.body_owner(body_id);\n     let span = hir.tcx().hir.span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, vec![]);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, vec![]);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n     builder.finish(None)\n@@ -649,6 +681,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n            arg_count: usize,\n            safety: Safety,\n            return_ty: Ty<'tcx>,\n+           return_span: Span,\n            upvar_decls: Vec<UpvarDecl>)\n            -> Builder<'a, 'gcx, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n@@ -665,8 +698,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             push_unsafe_count: 0,\n             unpushed_unsafe: safety,\n             breakable_scopes: vec![],\n-            local_decls: IndexVec::from_elem_n(LocalDecl::new_return_place(return_ty,\n-                                                                             span), 1),\n+            local_decls: IndexVec::from_elem_n(\n+                LocalDecl::new_return_place(return_ty, return_span),\n+                1,\n+            ),\n             upvar_decls,\n             var_indices: NodeMap(),\n             unit_temp: None,"}, {"sha": "044a3f70b4a636261b9051bcb77d39edde4ed13d", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.krisskross.nll.stderr", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.krisskross.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.krisskross.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.krisskross.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,23 +1,24 @@\n error: unsatisfied lifetime constraints\n-  --> $DIR/project-fn-ret-contravariant.rs:53:12\n+  --> $DIR/project-fn-ret-contravariant.rs:55:4\n    |\n LL | fn transmute<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n    |              -- -- lifetime `'b` defined here\n    |              |\n    |              lifetime `'a` defined here\n-LL |    let a = bar(foo, y);\n-   |            ^^^^^^^^^^^ assignment requires that `'b` must outlive `'a`\n+...\n+LL |    (a, b) //[krisskross]~ ERROR 55:5: 55:6: lifetime mismatch [E0623]\n+   |    ^^^^^^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/project-fn-ret-contravariant.rs:54:12\n+  --> $DIR/project-fn-ret-contravariant.rs:55:4\n    |\n LL | fn transmute<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n    |              -- -- lifetime `'b` defined here\n    |              |\n    |              lifetime `'a` defined here\n-LL |    let a = bar(foo, y);\n-LL |    let b = bar(foo, x);\n-   |            ^^^^^^^^^^^ assignment requires that `'a` must outlive `'b`\n+...\n+LL |    (a, b) //[krisskross]~ ERROR 55:5: 55:6: lifetime mismatch [E0623]\n+   |    ^^^^^^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "10f70b525e055c1bba36da3b0370760f862594fd", "filename": "src/test/ui/associated-types/cache/project-fn-ret-contravariant.transmute.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.transmute.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -14,7 +14,7 @@ LL | fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n    |        |\n    |        lifetime `'a` defined here\n LL |    bar(foo, x) //[transmute]~ ERROR E0495\n-   |    ^^^^^^^^^^^ requires that `'a` must outlive `'b`\n+   |    ^^^^^^^^^^^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1cb687856942d4b20a349b3ed927e28f504003b9", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.krisskross.nll.stderr", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.krisskross.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,23 +1,24 @@\n error: unsatisfied lifetime constraints\n-  --> $DIR/project-fn-ret-invariant.rs:63:12\n+  --> $DIR/project-fn-ret-invariant.rs:65:4\n    |\n LL | fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n    |              -- -- lifetime `'b` defined here\n    |              |\n    |              lifetime `'a` defined here\n-LL |    let a = bar(foo, y); //[krisskross]~ ERROR E0623\n-   |            ^^^^^^^^^^^ assignment requires that `'b` must outlive `'a`\n+...\n+LL |    (a, b) //[krisskross]~ ERROR E0623\n+   |    ^^^^^^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/project-fn-ret-invariant.rs:64:12\n+  --> $DIR/project-fn-ret-invariant.rs:65:4\n    |\n LL | fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n    |              -- -- lifetime `'b` defined here\n    |              |\n    |              lifetime `'a` defined here\n-LL |    let a = bar(foo, y); //[krisskross]~ ERROR E0623\n-LL |    let b = bar(foo, x);\n-   |            ^^^^^^^^^^^ assignment requires that `'a` must outlive `'b`\n+...\n+LL |    (a, b) //[krisskross]~ ERROR E0623\n+   |    ^^^^^^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2329adb5deab1de1a8834b4440a129e59361653d", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.transmute.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -8,15 +8,15 @@ LL |    bar(foo, x) //[transmute]~ ERROR E0495\n    |    ^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/project-fn-ret-invariant.rs:58:13\n+  --> $DIR/project-fn-ret-invariant.rs:58:4\n    |\n LL | fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n    |        -- -- lifetime `'b` defined here\n    |        |\n    |        lifetime `'a` defined here\n ...\n LL |    bar(foo, x) //[transmute]~ ERROR E0495\n-   |             ^ requires that `'a` must outlive `'b`\n+   |    ^^^^^^^^^^^ function was supposed to return data with lifetime `'b` but it is returning data with lifetime `'a`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5803b5e355a2cacd5c89a399c579bd3d566b795c", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.nll.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -5,10 +5,10 @@ LL |     const fn into_inner(self) -> T { self.0 } //~ destructors cannot be eva\n    |                         ^^^^ constant functions cannot evaluate destructors\n \n error: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:51:5\n+  --> $DIR/min_const_fn.rs:51:36\n    |\n LL |     const fn get_mut(&mut self) -> &mut T { &mut self.0 }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                    ^^^^^^\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:56:28\n@@ -17,10 +17,10 @@ LL |     const fn into_inner_lt(self) -> T { self.0 } //~ destructors cannot be\n    |                            ^^^^ constant functions cannot evaluate destructors\n \n error: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:58:5\n+  --> $DIR/min_const_fn.rs:58:42\n    |\n LL |     const fn get_mut_lt(&'a mut self) -> &mut T { &mut self.0 }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                          ^^^^^^\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:63:27\n@@ -29,16 +29,16 @@ LL |     const fn into_inner_s(self) -> T { self.0 } //~ ERROR destructors\n    |                           ^^^^ constant functions cannot evaluate destructors\n \n error: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:65:5\n+  --> $DIR/min_const_fn.rs:65:38\n    |\n LL |     const fn get_mut_s(&mut self) -> &mut T { &mut self.0 }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                      ^^^^^^\n \n error: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:70:5\n+  --> $DIR/min_const_fn.rs:70:39\n    |\n LL |     const fn get_mut_sq(&mut self) -> &mut T { &mut self.0 }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                       ^^^^^^\n \n error: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:88:16\n@@ -155,10 +155,10 @@ LL | impl<T: Sync + Sized> Foo<T> {\n    |      ^\n \n error: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:137:1\n+  --> $DIR/min_const_fn.rs:137:24\n    |\n LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:139:34\n@@ -173,10 +173,10 @@ LL | const fn no_apit(_x: impl std::fmt::Debug) {} //~ ERROR trait bounds other\n    |                      ^^^^^^^^^^^^^^^^^^^^\n \n error: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:142:1\n+  --> $DIR/min_const_fn.rs:142:23\n    |\n LL | const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn is unstable\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^^^^^^^^^^^^^^^^^^^^\n \n error: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:143:23\n@@ -185,10 +185,10 @@ LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds o\n    |                       ^^\n \n error: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:144:1\n+  --> $DIR/min_const_fn.rs:144:32\n    |\n LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0597]: borrowed value does not live long enough\n   --> $DIR/min_const_fn.rs:144:64\n@@ -213,10 +213,10 @@ LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n \n error: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:154:1\n+  --> $DIR/min_const_fn.rs:154:27\n    |\n LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                           ^^^^\n \n error: aborting due to 36 previous errors\n "}, {"sha": "6779b8a761461dcdacb7476628290a88e082e587", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -5,10 +5,10 @@ LL |     const fn into_inner(self) -> T { self.0 } //~ destructors cannot be eva\n    |                         ^^^^ constant functions cannot evaluate destructors\n \n error: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:51:5\n+  --> $DIR/min_const_fn.rs:51:36\n    |\n LL |     const fn get_mut(&mut self) -> &mut T { &mut self.0 }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                    ^^^^^^\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:56:28\n@@ -17,10 +17,10 @@ LL |     const fn into_inner_lt(self) -> T { self.0 } //~ destructors cannot be\n    |                            ^^^^ constant functions cannot evaluate destructors\n \n error: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:58:5\n+  --> $DIR/min_const_fn.rs:58:42\n    |\n LL |     const fn get_mut_lt(&'a mut self) -> &mut T { &mut self.0 }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                          ^^^^^^\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/min_const_fn.rs:63:27\n@@ -29,16 +29,16 @@ LL |     const fn into_inner_s(self) -> T { self.0 } //~ ERROR destructors\n    |                           ^^^^ constant functions cannot evaluate destructors\n \n error: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:65:5\n+  --> $DIR/min_const_fn.rs:65:38\n    |\n LL |     const fn get_mut_s(&mut self) -> &mut T { &mut self.0 }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                      ^^^^^^\n \n error: mutable references in const fn are unstable\n-  --> $DIR/min_const_fn.rs:70:5\n+  --> $DIR/min_const_fn.rs:70:39\n    |\n LL |     const fn get_mut_sq(&mut self) -> &mut T { &mut self.0 }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                       ^^^^^^\n \n error: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:88:16\n@@ -155,10 +155,10 @@ LL | impl<T: Sync + Sized> Foo<T> {\n    |      ^\n \n error: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:137:1\n+  --> $DIR/min_const_fn.rs:137:24\n    |\n LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:139:34\n@@ -173,10 +173,10 @@ LL | const fn no_apit(_x: impl std::fmt::Debug) {} //~ ERROR trait bounds other\n    |                      ^^^^^^^^^^^^^^^^^^^^\n \n error: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:142:1\n+  --> $DIR/min_const_fn.rs:142:23\n    |\n LL | const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn is unstable\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^^^^^^^^^^^^^^^^^^^^\n \n error: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:143:23\n@@ -185,10 +185,10 @@ LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds o\n    |                       ^^\n \n error: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:144:1\n+  --> $DIR/min_const_fn.rs:144:32\n    |\n LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: trait bounds other than `Sized` on const fn parameters are unstable\n   --> $DIR/min_const_fn.rs:149:41\n@@ -203,10 +203,10 @@ LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n \n error: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:154:1\n+  --> $DIR/min_const_fn.rs:154:27\n    |\n LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                           ^^^^\n \n error: aborting due to 35 previous errors\n "}, {"sha": "485d35662445d27600b8ecfabc3bc7399e056e17", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -36,10 +36,10 @@ LL |     move |_| println!(\"{}\", y)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'b`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:34:5\n+  --> $DIR/must_outlive_least_region_or_bound.rs:32:51\n    |\n-LL |     x\n-   |     ^\n+LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n+   |                                                   ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "7e9aa90c6c50c495ce265d71bed5e6aeeb0e5813", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -4,7 +4,7 @@ error: unsatisfied lifetime constraints\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n    |                         - let's call the lifetime of this reference `'1`\n LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^ cast requires that `'1` must outlive `'static`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n help: to allow this impl Trait to capture borrowed data with lifetime `'1`, add `'_` as a constraint\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n@@ -16,7 +16,7 @@ error: unsatisfied lifetime constraints\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n    |                    -- lifetime `'a` defined here\n LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^ cast requires that `'a` must outlive `'static`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n help: to allow this impl Trait to capture borrowed data with lifetime `'a`, add `'a` as a constraint\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {"}, {"sha": "18258ef1f9dc991e0aebd87bfce29ad55cc4ed12", "filename": "src/test/ui/impl-trait/type_parameters_captured.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftype_parameters_captured.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,8 +1,8 @@\n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/type_parameters_captured.rs:19:5\n+  --> $DIR/type_parameters_captured.rs:17:20\n    |\n-LL |     x\n-   |     ^\n+LL | fn foo<T>(x: T) -> impl Any + 'static {\n+   |                    ^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n "}, {"sha": "201a3b3d54a3fcb79b6d347a7086304af1a49e88", "filename": "src/test/ui/issues/issue-10291.nll.stderr", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fissues%2Fissue-10291.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fissues%2Fissue-10291.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10291.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,10 +1,13 @@\n error: unsatisfied lifetime constraints\n-  --> $DIR/issue-10291.rs:12:5\n+  --> $DIR/issue-10291.rs:12:65\n    |\n-LL | fn test<'x>(x: &'x isize) {\n-   |         -- lifetime `'x` defined here\n-LL |     drop::<Box<for<'z> FnMut(&'z isize) -> &'z isize>>(Box::new(|z| {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ requires that `'x` must outlive `'static`\n+LL |   fn test<'x>(x: &'x isize) {\n+   |           -- lifetime `'x` defined here\n+LL |       drop::<Box<for<'z> FnMut(&'z isize) -> &'z isize>>(Box::new(|z| {\n+   |  _________________________________________________________________^\n+LL | |         x //~ ERROR E0312\n+LL | |     }));\n+   | |_____^ closure body requires that `'x` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "e4aafd7b66e405e8d82ffb4da14b4649c60ed9e3", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-2.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -6,7 +6,7 @@ LL | fn foo(&mut (ref mut v, w): &mut (&u8, &u8), x: &u8) {\n    |                                   |\n    |                                   let's call the lifetime of this reference `'2`\n LL |     *v = x; //~ ERROR lifetime mismatch\n-   |     ^^^^^^ requires that `'1` must outlive `'2`\n+   |     ^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error: aborting due to previous error\n "}, {"sha": "934cdcd2ef28cecbf51712f18156aed99a00eb8e", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-both-are-structs-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-2.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -6,7 +6,7 @@ LL | fn foo(mut x: Ref, y: Ref) {\n    |        |\n    |        has type `Ref<'_, '2>`\n LL |     x.b = y.b; //~ ERROR lifetime mismatch\n-   |     ^^^^^^^^^ requires that `'1` must outlive `'2`\n+   |     ^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error: aborting due to previous error\n "}, {"sha": "cbfd9d478091e994aabd92569b7d8c4d221f8be5", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-both-are-structs-3.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-3.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -7,7 +7,7 @@ LL | fn foo(mut x: Ref) {\n    |        has type `Ref<'_, '1>`\n    |        has type `Ref<'2, '_>`\n LL |     x.a = x.b; //~ ERROR lifetime mismatch\n-   |     ^^^^^^^^^ requires that `'1` must outlive `'2`\n+   |     ^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error: aborting due to previous error\n "}, {"sha": "4f0efe24cf70a3b558ffce4ee1754c9cbbc959e2", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-both-are-structs-4.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-4.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -7,7 +7,7 @@ LL | fn foo(mut x: Ref) {\n    |        has type `Ref<'_, '1>`\n    |        has type `Ref<'2, '_>`\n LL |     x.a = x.b; //~ ERROR lifetime mismatch\n-   |     ^^^^^^^^^ requires that `'1` must outlive `'2`\n+   |     ^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error: aborting due to previous error\n "}, {"sha": "fc1fab7aab5bb208132aed2824bf5a31d1db5950", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-one-is-struct-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-2.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -6,7 +6,7 @@ LL | fn foo(mut x: Ref, y: &u32) {\n    |        |\n    |        has type `Ref<'_, '1>`\n LL |     y = x.b; //~ ERROR lifetime mismatch\n-   |     ^^^^^^^ requires that `'1` must outlive `'2`\n+   |     ^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error[E0384]: cannot assign to immutable argument `y`\n   --> $DIR/ex3-both-anon-regions-one-is-struct-2.rs:14:5"}, {"sha": "8100fa89c2d0ac453a04cf2eec4c4f4413bff7a1", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-one-is-struct-3.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-3.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -6,7 +6,7 @@ LL | fn foo(mut y: Ref, x: &u32) {\n    |        |\n    |        has type `Ref<'_, '2>`\n LL |     y.b = x; //~ ERROR lifetime mismatch\n-   |     ^^^^^^^ requires that `'1` must outlive `'2`\n+   |     ^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error: aborting due to previous error\n "}, {"sha": "1c4a8b665893210bf0a402cc9b542352bfbed927", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-one-is-struct-4.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct-4.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -6,7 +6,7 @@ LL | fn foo(mut y: Ref, x: &u32) {\n    |        |\n    |        has type `Ref<'_, '2>`\n LL |     y.b = x; //~ ERROR lifetime mismatch\n-   |     ^^^^^^^ requires that `'1` must outlive `'2`\n+   |     ^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error: aborting due to previous error\n "}, {"sha": "2a4c5a685f16a524dcad341a4072bacfae7fd145", "filename": "src/test/ui/lifetimes/lifetime-errors/ex3-both-anon-regions-one-is-struct.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-errors%2Fex3-both-anon-regions-one-is-struct.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -6,7 +6,7 @@ LL | fn foo(mut x: Ref, y: &u32) {\n    |        |\n    |        has type `Ref<'_, '2>`\n LL |     x.b = y; //~ ERROR lifetime mismatch\n-   |     ^^^^^^^ requires that `'1` must outlive `'2`\n+   |     ^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error: aborting due to previous error\n "}, {"sha": "1f9cb6d050fb0cd3c427e07e9818ac75038ee667", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -13,7 +13,7 @@ error: unsatisfied lifetime constraints\n   --> $DIR/escape-argument-callee.rs:36:45\n    |\n LL |         let mut closure = expect_sig(|p, y| *p = y);\n-   |                                       -  -  ^^^^^^ requires that `'1` must outlive `'2`\n+   |                                       -  -  ^^^^^^ assignment requires that `'1` must outlive `'2`\n    |                                       |  |\n    |                                       |  has type `&'1 i32`\n    |                                       has type `&mut &'2 i32`"}, {"sha": "2e1249a5e81264e07e6859ce9b8c333f95d1362c", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -34,19 +34,20 @@ LL | | }\n    = note: defining type: DefId(0/0:6 ~ propagate_approximated_ref[317d]::supply[0]) with substs []\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-ref.rs:53:5\n+  --> $DIR/propagate-approximated-ref.rs:53:47\n    |\n LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n    |             --  -- lifetime `'b` defined here\n    |             |\n    |             lifetime `'a` defined here\n-LL | /     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+   |  _______________________________________________^\n LL | |         //~^ ERROR unsatisfied lifetime constraints\n LL | |\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(x, y, x.get())\n LL | |     });\n-   | |______^ argument requires that `'a` must outlive `'b`\n+   | |_____^ closure body requires that `'a` must outlive `'b`\n \n error: aborting due to previous error\n "}, {"sha": "9f1d9d21d11c00a8cb006838fdeea0a6544c42e7", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -49,14 +49,21 @@ LL | |     });\n    | |______^ `cell_a` escapes the function body here\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:29\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:47\n    |\n-LL | fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-   |           --  -- lifetime `'b` defined here\n-   |           |\n-   |           lifetime `'a` defined here\n-LL |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-   |                             ^^^^^^^ requires that `'a` must outlive `'b`\n+LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |             --  -- lifetime `'b` defined here\n+   |             |\n+   |             lifetime `'a` defined here\n+LL |       establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+   |  _______________________________________________^\n+LL | |         //~^ ERROR borrowed data escapes outside of function\n+LL | |         //~| ERROR unsatisfied lifetime constraints\n+LL | |\n+LL | |         // Only works if 'x: 'y:\n+LL | |         demand_y(x, y, x.get())\n+LL | |     });\n+   | |_____^ closure body requires that `'a` must outlive `'b`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4e72fe4bb28aa9caf70face2b5626deac2481496", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -47,14 +47,20 @@ LL | |     });\n    | |______^ `cell_a` escapes the function body here\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:29\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:47\n    |\n-LL | fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-   |           --  -- lifetime `'b` defined here\n-   |           |\n-   |           lifetime `'a` defined here\n-LL |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-   |                             ^^^^^^^ requires that `'a` must outlive `'b`\n+LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |             --  -- lifetime `'b` defined here\n+   |             |\n+   |             lifetime `'a` defined here\n+LL |       establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+   |  _______________________________________________^\n+LL | |         //~^ ERROR borrowed data escapes outside of function\n+LL | |         //~| ERROR unsatisfied lifetime constraints\n+LL | |         // Only works if 'x: 'y:\n+LL | |         demand_y(x, y, x.get())\n+LL | |     });\n+   | |_____^ closure body requires that `'a` must outlive `'b`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "de60b23ef6b974eb3f1931fc78e66ea0606e1f2b", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -34,19 +34,20 @@ LL | | }\n    = note: defining type: DefId(0/0:6 ~ propagate_approximated_val[317d]::test[0]) with substs []\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-val.rs:46:5\n+  --> $DIR/propagate-approximated-val.rs:46:45\n    |\n LL |   fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n    |           --  -- lifetime `'b` defined here\n    |           |\n    |           lifetime `'a` defined here\n-LL | /     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+LL |       establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+   |  _____________________________________________^\n LL | |         //~^ ERROR unsatisfied lifetime constraints\n LL | |\n LL | |         // Only works if 'x: 'y:\n LL | |         demand_y(outlives1, outlives2, x.get())\n LL | |     });\n-   | |______^ argument requires that `'a` must outlive `'b`\n+   | |_____^ closure body requires that `'a` must outlive `'b`\n \n error: aborting due to previous error\n "}, {"sha": "eddad056995a7162a3939c6d4755f2c2362b67a6", "filename": "src/test/ui/nll/issue-50716.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-50716.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,11 +1,11 @@\n-error: borrowed data escapes outside of function\n+error: unsatisfied lifetime constraints\n   --> $DIR/issue-50716.rs:25:14\n    |\n LL | fn foo<'a, T: 'static>(s: Box<<&'a T as A>::X>)\n-   |                        - `s` is a reference that is only valid in the function body\n+   |        -- lifetime `'a` defined here\n ...\n LL |     let _x = *s; //~ ERROR\n-   |              ^^ `s` escapes the function body here\n+   |              ^^ proving this value is `Sized` requires that `'a` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "af577e8499b095f43c6cbe861474c591fff8de73", "filename": "src/test/ui/nll/issue-52113.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -40,11 +40,11 @@ fn produce3<'a, 'b: 'a>(data: &'a mut Vec<&'a u32>, value: &'b u32) -> impl Bazi\n }\n \n fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n-    let x = move || { //~ ERROR unsatisfied lifetime constraints\n+    let x = move || {\n         let value: &'a u32 = value;\n         data.push(value);\n     };\n-    x\n+    x   //~ ERROR unsatisfied lifetime constraints\n }\n \n fn main() { }"}, {"sha": "45a192de454ef6e7e57de378db4393ad998ebd91", "filename": "src/test/ui/nll/issue-52113.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,12 +1,13 @@\n error: unsatisfied lifetime constraints\n-  --> $DIR/issue-52113.rs:43:9\n+  --> $DIR/issue-52113.rs:47:5\n    |\n LL | fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n    |                --  -- lifetime `'b` defined here\n    |                |\n    |                lifetime `'a` defined here\n-LL |     let x = move || { //~ ERROR unsatisfied lifetime constraints\n-   |         ^ requires that `'a` must outlive `'b`\n+...\n+LL |     x   //~ ERROR unsatisfied lifetime constraints\n+   |     ^ returning this value requires that `'a` must outlive `'b`\n \n error: aborting due to previous error\n "}, {"sha": "83a594941c0a5a08a2b6512f06f0407ae62a10b5", "filename": "src/test/ui/nll/issue-52742.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fissue-52742.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fissue-52742.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52742.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -6,7 +6,7 @@ LL |     fn take_bar(&mut self, b: Bar<'_>) {\n    |                 |\n    |                 has type `&mut Foo<'_, '2>`\n LL |         self.y = b.z\n-   |         ^^^^^^^^^^^^ requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^^ assignment requires that `'1` must outlive `'2`\n \n error: aborting due to previous error\n "}, {"sha": "c878be9e2a2dcd58834a98271db43c1e2f821dd9", "filename": "src/test/ui/nll/mir_check_cast_reify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -44,8 +44,8 @@ fn bar<'a>(x: &'a u32) -> &'static u32 {\n     // The MIR type checker must therefore relate `'?0` to `'?1` and `'?2`\n     // as part of checking the `ReifyFnPointer`.\n     let f: fn(_) -> _ = foo;\n-    //~^ ERROR unsatisfied lifetime constraints\n     f(x)\n+    //~^ ERROR unsatisfied lifetime constraints\n }\n \n fn main() {}"}, {"sha": "fdb71b17287d9a8b57f243dd93310c4cf448cdbc", "filename": "src/test/ui/nll/mir_check_cast_reify.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,11 +1,11 @@\n error: unsatisfied lifetime constraints\n-  --> $DIR/mir_check_cast_reify.rs:46:25\n+  --> $DIR/mir_check_cast_reify.rs:47:5\n    |\n LL | fn bar<'a>(x: &'a u32) -> &'static u32 {\n    |        -- lifetime `'a` defined here\n ...\n-LL |     let f: fn(_) -> _ = foo;\n-   |                         ^^^ cast requires that `'a` must outlive `'static`\n+LL |     f(x)\n+   |     ^^^^ returning this value requires that `'a` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "be91a946857e3b916778cc0bd59d4b4ffd95eeb6", "filename": "src/test/ui/nll/mir_check_cast_unsafe_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -16,8 +16,8 @@ fn bar<'a>(input: &'a u32, f: fn(&'a u32) -> &'a u32) -> &'static u32 {\n     // Here the NLL checker must relate the types in `f` to the types\n     // in `g`. These are related via the `UnsafeFnPointer` cast.\n     let g: unsafe fn(_) -> _ = f;\n-    //~^ ERROR unsatisfied lifetime constraints\n     unsafe { g(input) }\n+    //~^ ERROR unsatisfied lifetime constraints\n }\n \n fn main() {}"}, {"sha": "c14fb93a525e5bd4ef7de01384362c218561fbbb", "filename": "src/test/ui/nll/mir_check_cast_unsafe_fn.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,11 +1,11 @@\n error: unsatisfied lifetime constraints\n-  --> $DIR/mir_check_cast_unsafe_fn.rs:18:32\n+  --> $DIR/mir_check_cast_unsafe_fn.rs:19:14\n    |\n LL | fn bar<'a>(input: &'a u32, f: fn(&'a u32) -> &'a u32) -> &'static u32 {\n    |        -- lifetime `'a` defined here\n ...\n-LL |     let g: unsafe fn(_) -> _ = f;\n-   |                                ^ cast requires that `'a` must outlive `'static`\n+LL |     unsafe { g(input) }\n+   |              ^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "526dfb6013386b222d020be4eb648aafe7100a97", "filename": "src/test/ui/nll/mir_check_cast_unsize.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -4,7 +4,7 @@ error: unsatisfied lifetime constraints\n LL | fn bar<'a>(x: &'a u32) -> &'static dyn Debug {\n    |        -- lifetime `'a` defined here\n LL |     x\n-   |     ^ cast requires that `'a` must outlive `'static`\n+   |     ^ returning this value requires that `'a` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "9a83872b965c9f74db93476f64b543feed6d764a", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -5,10 +5,10 @@ LL |     let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n    |                                                          ^^^^^^^^^\n \n error: higher-ranked subtype error\n-  --> $DIR/hr-fn-aaa-as-aba.rs:32:58\n+  --> $DIR/hr-fn-aaa-as-aba.rs:32:9\n    |\n LL |     let _: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n-   |                                                          ^^^^^^^^^\n+   |         ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "64eb7353638676d2e453ddf9f32a102f3d744dc9", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -15,11 +15,11 @@\n use std::fmt::Debug;\n \n fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: Debug,\n {\n     x\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn correct_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n@@ -30,11 +30,11 @@ where\n }\n \n fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n where\n     T: 'b + Debug,\n {\n     x\n-    //~^ ERROR the parameter type `T` may not live long enough [E0309]\n }\n \n fn outlives_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a"}, {"sha": "61d2d2d6d82d83c3ced2f877bec8b9831d0f3353", "filename": "src/test/ui/nll/ty-outlives/impl-trait-outlives.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-outlives.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,16 +1,16 @@\n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:21:5\n+  --> $DIR/impl-trait-outlives.rs:17:35\n    |\n-LL |     x\n-   |     ^\n+LL | fn no_region<'a, T>(x: Box<T>) -> impl Debug + 'a\n+   |                                   ^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n \n error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/impl-trait-outlives.rs:36:5\n+  --> $DIR/impl-trait-outlives.rs:32:42\n    |\n-LL |     x\n-   |     ^\n+LL | fn wrong_region<'a, 'b, T>(x: Box<T>) -> impl Debug + 'a\n+   |                                          ^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n "}, {"sha": "4bd96ab4e713d6a5a4aa8032f06a3d85b5576847", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -32,24 +32,24 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/projection-one-region-closure.rs:55:29\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`...\n+\n error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-closure.rs:55:5\n+  --> $DIR/projection-one-region-closure.rs:55:29\n    |\n LL | fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                          --  -- lifetime `'b` defined here\n    |                          |\n    |                          lifetime `'a` defined here\n ...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-one-region-closure.rs:55:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`...\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n   --> $DIR/projection-one-region-closure.rs:66:29\n@@ -86,24 +86,24 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/projection-one-region-closure.rs:66:29\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+\n error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-closure.rs:66:5\n+  --> $DIR/projection-one-region-closure.rs:66:29\n    |\n LL | fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                           --  -- lifetime `'b` defined here\n    |                           |\n    |                           lifetime `'a` defined here\n ...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-one-region-closure.rs:66:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n   --> $DIR/projection-one-region-closure.rs:87:29\n@@ -140,24 +140,24 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/projection-one-region-closure.rs:87:29\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+\n error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-closure.rs:87:5\n+  --> $DIR/projection-one-region-closure.rs:87:29\n    |\n LL | fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                        --  -- lifetime `'b` defined here\n    |                        |\n    |                        lifetime `'a` defined here\n ...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-one-region-closure.rs:87:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n   --> $DIR/projection-one-region-closure.rs:99:29"}, {"sha": "ccf70a77bffc1fbd24d65060ef4a443abe4f1ddd", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -32,15 +32,15 @@ LL | | }\n            ]\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:47:5\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:47:29\n    |\n LL | fn no_relationships_late<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                          --  -- lifetime `'b` defined here\n    |                          |\n    |                          lifetime `'a` defined here\n ...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:57:29\n@@ -77,15 +77,15 @@ LL | | }\n            ]\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:57:5\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:57:29\n    |\n LL | fn no_relationships_early<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                           --  -- lifetime `'b` defined here\n    |                           |\n    |                           lifetime `'a` defined here\n ...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:77:29\n@@ -122,15 +122,15 @@ LL | | }\n            ]\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:77:5\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:77:29\n    |\n LL | fn projection_outlives<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                        --  -- lifetime `'b` defined here\n    |                        |\n    |                        lifetime `'a` defined here\n ...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:87:29"}, {"sha": "372b803082f1134c5e699076bd4888d3bfd965da", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -235,15 +235,15 @@ LL | | }\n            ]\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:105:5\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:105:29\n    |\n LL | fn two_regions<'a, 'b, T>(cell: Cell<&'a ()>, t: T)\n    |                --  -- lifetime `'b` defined here\n    |                |\n    |                lifetime `'a` defined here\n ...\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ closure body requires that `'b` must outlive `'a`\n \n note: External requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:115:29"}, {"sha": "6e480dcaac08fe9820bce20c4ec87b28dc7268e2", "filename": "src/test/ui/nll/type-alias-free-regions.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.rs?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -0,0 +1,33 @@\n+// Test that we don't assume that type aliases have the same type parameters\n+// as the type they alias and then panic when we see this.\n+\n+#![feature(nll)]\n+\n+type a<'a> = &'a isize;\n+type b<'a> = Box<a<'a>>;\n+\n+struct c<'a> {\n+    f: Box<b<'a>>\n+}\n+\n+trait FromBox<'a> {\n+    fn from_box(b: Box<b>) -> Self;\n+}\n+\n+impl<'a> FromBox<'a> for c<'a> {\n+    fn from_box(b: Box<b>) -> Self {\n+        c { f: b } //~ ERROR\n+    }\n+}\n+\n+trait FromTuple<'a> {\n+    fn from_tuple( b: (b,)) -> Self;\n+}\n+\n+impl<'a> FromTuple<'a> for c<'a> {\n+    fn from_tuple(b: (b,)) -> Self {\n+        c { f: Box::new(b.0) } //~ ERROR\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "05f2c9309446a1e42e6c624f98acaf5833cb7a4f", "filename": "src/test/ui/nll/type-alias-free-regions.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -0,0 +1,22 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/type-alias-free-regions.rs:19:9\n+   |\n+LL | impl<'a> FromBox<'a> for c<'a> {\n+   |      -- lifetime `'a` defined here\n+LL |     fn from_box(b: Box<b>) -> Self {\n+   |                 - has type `std::boxed::Box<std::boxed::Box<&'1 isize>>`\n+LL |         c { f: b } //~ ERROR\n+   |         ^^^^^^^^^^ returning this value requires that `'1` must outlive `'a`\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/type-alias-free-regions.rs:29:9\n+   |\n+LL | impl<'a> FromTuple<'a> for c<'a> {\n+   |      -- lifetime `'a` defined here\n+LL |     fn from_tuple(b: (b,)) -> Self {\n+   |                   - has type `(std::boxed::Box<&'1 isize>,)`\n+LL |         c { f: Box::new(b.0) } //~ ERROR\n+   |         ^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'a`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "f359608462d1d4c49ca7a7ba7c3b0b4d1bdd7160", "filename": "src/test/ui/nll/user-annotations/patterns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fpatterns.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -131,12 +131,12 @@ LL |     y //~ ERROR\n    |     ^ returning this value requires that `'a` must outlive `'static`\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/patterns.rs:117:40\n+  --> $DIR/patterns.rs:117:9\n    |\n LL | fn a_to_static_then_static<'a>(x: &'a u32) -> &'static u32 {\n    |                            -- lifetime `'a` defined here\n LL |     let (y, _z): (&'static u32, u32) = (x, 44); //~ ERROR\n-   |                                        ^^^^^^^ requires that `'a` must outlive `'static`\n+   |         ^^^^^^^ type annotation requires that `'a` must outlive `'static`\n \n error: aborting due to 14 previous errors\n "}, {"sha": "a6bfcf1d3699a417c26d4487a5b6ad491b14b5f4", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-rptr-box-error.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-box-error.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-box-error.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-box-error.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,10 +1,10 @@\n-error: borrowed data escapes outside of function\n+error: unsatisfied lifetime constraints\n   --> $DIR/object-lifetime-default-from-rptr-box-error.rs:25:5\n    |\n LL | fn c<'a>(t: &'a Box<Test+'a>, mut ss: SomeStruct<'a>) {\n-   |          - `t` is a reference that is only valid in the function body\n+   |      -- lifetime `'a` defined here\n LL |     ss.t = t; //~ ERROR mismatched types\n-   |     ^^^^^^^^ `t` escapes the function body here\n+   |     ^^^^^^^^ assignment requires that `'a` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "396ff1302b1513a7bd72016b0c01b24fd52a2b4a", "filename": "src/test/ui/object-lifetime/object-lifetime-default-from-rptr-struct-error.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-struct-error.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-struct-error.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-from-rptr-struct-error.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,10 +1,10 @@\n-error: borrowed data escapes outside of function\n+error: unsatisfied lifetime constraints\n   --> $DIR/object-lifetime-default-from-rptr-struct-error.rs:31:5\n    |\n LL | fn c<'a>(t: &'a MyBox<Test+'a>, mut ss: SomeStruct<'a>) {\n-   |          - `t` is a reference that is only valid in the function body\n+   |      -- lifetime `'a` defined here\n LL |     ss.t = t; //~ ERROR mismatched types\n-   |     ^^^^^^^^ `t` escapes the function body here\n+   |     ^^^^^^^^ assignment requires that `'a` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "53d3b2d5323c2488315ef11a505409741f24c7c9", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,10 +1,10 @@\n error[E0621]: explicit lifetime required in the type of `v`\n-  --> $DIR/region-object-lifetime-in-coercion.rs:18:33\n+  --> $DIR/region-object-lifetime-in-coercion.rs:18:9\n    |\n LL | fn a(v: &[u8]) -> Box<Foo + 'static> {\n    |         ----- help: add explicit lifetime `'static` to the type of `v`: `&'static [u8]`\n LL |     let x: Box<Foo + 'static> = Box::new(v);\n-   |                                 ^^^^^^^^^^^ lifetime `'static` required\n+   |         ^ lifetime `'static` required\n \n error[E0621]: explicit lifetime required in the type of `v`\n   --> $DIR/region-object-lifetime-in-coercion.rs:24:5"}, {"sha": "0e38abef668cae88084a9039b99cf30deef879ad", "filename": "src/test/ui/regions/regions-addr-of-self.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-self.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -4,7 +4,7 @@ error: unsatisfied lifetime constraints\n LL |     pub fn chase_cat(&mut self) {\n    |                      - let's call the lifetime of this reference `'1`\n LL |         let p: &'static mut usize = &mut self.cats_chased; //~ ERROR cannot infer\n-   |             ^ requires that `'1` must outlive `'static`\n+   |             ^ type annotation requires that `'1` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "6e4bf26047e4679348f1136cd8b7cbdde748bb95", "filename": "src/test/ui/regions/regions-addr-of-upvar-self.nll.stderr", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-addr-of-upvar-self.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -4,7 +4,7 @@ error: unsatisfied lifetime constraints\n LL |         let _f = || {\n    |                  -- lifetime `'1` represents this closure's body\n LL |             let p: &'static mut usize = &mut self.food; //~ ERROR cannot infer\n-   |                 ^ requires that `'1` must outlive `'static`\n+   |                 ^ type annotation requires that `'1` must outlive `'static`\n    |\n    = note: closure implements `FnMut`, so references to captured variables can't escape the closure\n \n@@ -16,17 +16,21 @@ LL |     pub fn chase_cat(&mut self) {\n LL |         let _f = || {\n    |                  -- lifetime `'1` represents this closure's body\n LL |             let p: &'static mut usize = &mut self.food; //~ ERROR cannot infer\n-   |                 ^ requires that `'1` must outlive `'2`\n+   |                 ^ type annotation requires that `'1` must outlive `'2`\n    |\n    = note: closure implements `FnMut`, so references to captured variables can't escape the closure\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/regions-addr-of-upvar-self.rs:19:13\n+  --> $DIR/regions-addr-of-upvar-self.rs:19:18\n    |\n-LL |     pub fn chase_cat(&mut self) {\n-   |                      - let's call the lifetime of this reference `'1`\n-LL |         let _f = || {\n-   |             ^^ requires that `'1` must outlive `'static`\n+LL |       pub fn chase_cat(&mut self) {\n+   |                        - let's call the lifetime of this reference `'1`\n+LL |           let _f = || {\n+   |  __________________^\n+LL | |             let p: &'static mut usize = &mut self.food; //~ ERROR cannot infer\n+LL | |             *p = 3;\n+LL | |         };\n+   | |_________^ closure body requires that `'1` must outlive `'static`\n \n error[E0597]: `self` does not live long enough\n   --> $DIR/regions-addr-of-upvar-self.rs:20:46"}, {"sha": "c073e3728e70571c7febf98ccfdf2e5160a6a311", "filename": "src/test/ui/regions/regions-close-object-into-object-2.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,10 +1,10 @@\n error: unsatisfied lifetime constraints\n-  --> $DIR/regions-close-object-into-object-2.rs:20:11\n+  --> $DIR/regions-close-object-into-object-2.rs:20:5\n    |\n LL | fn g<'a, T: 'static>(v: Box<A<T>+'a>) -> Box<X+'static> {\n    |      -- lifetime `'a` defined here\n LL |     box B(&*v) as Box<X> //~ ERROR cannot infer\n-   |           ^^^ cast requires that `'a` must outlive `'static`\n+   |     ^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n \n error[E0597]: `*v` does not live long enough\n   --> $DIR/regions-close-object-into-object-2.rs:20:11"}, {"sha": "4b47b951d77173fcaba3511fd4e900fb0a38fb40", "filename": "src/test/ui/regions/regions-close-object-into-object-4.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -6,6 +6,14 @@ LL |     box B(&*v) as Box<X> //~ ERROR cannot infer\n    |\n    = help: consider adding an explicit lifetime bound `U: 'static`...\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/regions-close-object-into-object-4.rs:20:5\n+   |\n+LL | fn i<'a, T, U>(v: Box<A<U>+'a>) -> Box<X+'static> {\n+   |      -- lifetime `'a` defined here\n+LL |     box B(&*v) as Box<X> //~ ERROR cannot infer\n+   |     ^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n+\n error[E0310]: the parameter type `U` may not live long enough\n   --> $DIR/regions-close-object-into-object-4.rs:20:9\n    |\n@@ -14,14 +22,6 @@ LL |     box B(&*v) as Box<X> //~ ERROR cannot infer\n    |\n    = help: consider adding an explicit lifetime bound `U: 'static`...\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/regions-close-object-into-object-4.rs:20:11\n-   |\n-LL | fn i<'a, T, U>(v: Box<A<U>+'a>) -> Box<X+'static> {\n-   |      -- lifetime `'a` defined here\n-LL |     box B(&*v) as Box<X> //~ ERROR cannot infer\n-   |           ^^^ cast requires that `'a` must outlive `'static`\n-\n error[E0597]: `*v` does not live long enough\n   --> $DIR/regions-close-object-into-object-4.rs:20:11\n    |"}, {"sha": "d0606295713193816dd2a684968e5bafb4fb554a", "filename": "src/test/ui/regions/regions-free-region-ordering-callee.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-callee.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-callee.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-ordering-callee.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -18,7 +18,7 @@ LL | fn ordering3<'a, 'b>(x: &'a usize, y: &'b usize) -> &'a &'b usize {\n    |              lifetime `'a` defined here\n LL |     // Do not infer an ordering from the return value.\n LL |     let z: &'b usize = &*x;\n-   |                        ^^^ requires that `'a` must outlive `'b`\n+   |                        ^^^ assignment requires that `'a` must outlive `'b`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7558c5caa0e24b7a37269e151efbedec6620896f", "filename": "src/test/ui/regions/regions-infer-paramd-indirect.nll.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-infer-paramd-indirect.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-infer-paramd-indirect.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-infer-paramd-indirect.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,12 +1,13 @@\n-error: borrowed data escapes outside of function\n+error: unsatisfied lifetime constraints\n   --> $DIR/regions-infer-paramd-indirect.rs:33:9\n    |\n+LL | impl<'a> set_f<'a> for c<'a> {\n+   |      -- lifetime `'a` defined here\n+...\n LL |     fn set_f_bad(&mut self, b: Box<b>) {\n-   |                  ---------  - `b` is a reference that is only valid in the function body\n-   |                  |\n-   |                  `self` is declared here, outside of the function body\n+   |                             - has type `std::boxed::Box<std::boxed::Box<&'1 isize>>`\n LL |         self.f = b;\n-   |         ^^^^^^ `b` escapes the function body here\n+   |         ^^^^^^ assignment requires that `'1` must outlive `'a`\n \n error: aborting due to previous error\n "}, {"sha": "4bb602d572fa3e5a650bc335913f0901cfa50e29", "filename": "src/test/ui/regions/regions-nested-fns.nll.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -1,22 +1,14 @@\n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/regions-nested-fns.rs:20:9\n    |\n LL |     let mut ay = &y; //~ ERROR E0495\n-   |         ------ lifetime `'2` appears in the type of `ay`\n+   |         ------ `ay` is declared here, outside of the closure body\n LL | \n LL |     ignore::<Box<for<'z> FnMut(&'z isize)>>(Box::new(|z| {\n-   |                                                       - has type `&'1 isize`\n+   |                                                       - `z` is a reference that is only valid in the closure body\n ...\n LL |         ay = z;\n-   |         ^^^^^^ requires that `'1` must outlive `'2`\n-\n-error: unsatisfied lifetime constraints\n-  --> $DIR/regions-nested-fns.rs:14:9\n-   |\n-LL | fn nested<'x>(x: &'x isize) {\n-   |           -- lifetime `'x` defined here\n-LL |     let y = 3;\n-   |         ^ requires that `'x` must outlive `'static`\n+   |         ^^^^^^ `z` escapes the closure body here\n \n error[E0597]: `y` does not live long enough\n   --> $DIR/regions-nested-fns.rs:15:18\n@@ -43,6 +35,20 @@ LL | }\n    |\n    = note: borrowed value must be valid for the static lifetime...\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/regions-nested-fns.rs:23:68\n+   |\n+LL |   fn nested<'x>(x: &'x isize) {\n+   |             -- lifetime `'x` defined here\n+...\n+LL |       ignore::< Box<for<'z> FnMut(&'z isize) -> &'z isize>>(Box::new(|z| {\n+   |  ____________________________________________________________________^\n+LL | |         if false { return x; } //~ ERROR E0312\n+LL | |         if false { return ay; }\n+LL | |         return z;\n+LL | |     }));\n+   | |_____^ closure body requires that `'x` must outlive `'static`\n+\n error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0597`."}, {"sha": "0a9bcee1ce29d34f53a8a09e2fd9e189edec2782", "filename": "src/test/ui/regions/regions-trait-object-subtyping.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -7,7 +7,7 @@ LL | fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n    |         lifetime `'a` defined here\n LL |     // Without knowing 'a:'b, we can't coerce\n LL |     x //~ ERROR lifetime bound not satisfied\n-   |     ^ returning this value requires that `'a` must outlive `'b`\n+   |     ^ cast requires that `'a` must outlive `'b`\n \n error: unsatisfied lifetime constraints\n   --> $DIR/regions-trait-object-subtyping.rs:32:5"}, {"sha": "7adb195b7d0225d68304b023191927b6d3b760e6", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -5,7 +5,7 @@ LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n    |                - let's call the lifetime of this reference `'1`\n LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ cast requires that `'1` must outlive `'static`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'1` must outlive `'static`\n \n error: aborting due to previous error\n "}, {"sha": "a30720dc6ba8a8bef7ba1ad2989fa31e8b3135c3", "filename": "src/test/ui/variance/variance-contravariant-arg-object.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-arg-object.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-arg-object.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-contravariant-arg-object.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -7,7 +7,7 @@ LL | fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n    |                     lifetime `'min` defined here\n ...\n LL |     v //~ ERROR mismatched types\n-   |     ^ cast requires that `'min` must outlive `'max`\n+   |     ^ returning this value requires that `'min` must outlive `'max`\n \n error: unsatisfied lifetime constraints\n   --> $DIR/variance-contravariant-arg-object.rs:32:5\n@@ -18,7 +18,7 @@ LL | fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n    |                     lifetime `'min` defined here\n ...\n LL |     v //~ ERROR mismatched types\n-   |     ^ cast requires that `'min` must outlive `'max`\n+   |     ^ returning this value requires that `'min` must outlive `'max`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "26699a537e81032fc7c5751882b727356f1afb5b", "filename": "src/test/ui/variance/variance-covariant-arg-object.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-arg-object.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-arg-object.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-covariant-arg-object.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -7,7 +7,7 @@ LL | fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n    |                     lifetime `'min` defined here\n ...\n LL |     v //~ ERROR mismatched types\n-   |     ^ cast requires that `'min` must outlive `'max`\n+   |     ^ returning this value requires that `'min` must outlive `'max`\n \n error: unsatisfied lifetime constraints\n   --> $DIR/variance-covariant-arg-object.rs:32:5\n@@ -18,7 +18,7 @@ LL | fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n    |                     lifetime `'min` defined here\n ...\n LL |     v //~ ERROR mismatched types\n-   |     ^ cast requires that `'min` must outlive `'max`\n+   |     ^ returning this value requires that `'min` must outlive `'max`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "20ab6485986185fae8484f7ae9368f384b1a93f2", "filename": "src/test/ui/variance/variance-invariant-arg-object.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-arg-object.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/576b640a02d7363746aacab9d2f1b91c6b685688/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-arg-object.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fvariance%2Fvariance-invariant-arg-object.nll.stderr?ref=576b640a02d7363746aacab9d2f1b91c6b685688", "patch": "@@ -7,7 +7,7 @@ LL | fn get_min_from_max<'min, 'max>(v: Box<Get<&'max i32>>)\n    |                     lifetime `'min` defined here\n ...\n LL |     v //~ ERROR mismatched types\n-   |     ^ cast requires that `'min` must outlive `'max`\n+   |     ^ returning this value requires that `'min` must outlive `'max`\n \n error: unsatisfied lifetime constraints\n   --> $DIR/variance-invariant-arg-object.rs:28:5\n@@ -18,7 +18,7 @@ LL | fn get_max_from_min<'min, 'max, G>(v: Box<Get<&'min i32>>)\n    |                     lifetime `'min` defined here\n ...\n LL |     v //~ ERROR mismatched types\n-   |     ^ cast requires that `'min` must outlive `'max`\n+   |     ^ returning this value requires that `'min` must outlive `'max`\n \n error: aborting due to 2 previous errors\n "}]}