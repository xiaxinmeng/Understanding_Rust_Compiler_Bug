{"sha": "812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxMmVhOWUxNjlkNmVkY2MxMzhlMzM0ZTdlMmIyY2I1ZjdiYTY2YjM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-11-07T07:49:01Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-11-08T09:57:34Z"}, "message": "syntax::ext: Make type errors in deriving point to the field itself.\n\nThis rearranges the deriving code so that #[deriving] a trait on a field\nthat doesn't implement that trait will point to the field in question,\ne.g.\n\n    struct NotEq; // doesn't implement Eq\n\n    #[deriving(Eq)]\n    struct Foo {\n        ok: int,\n        also_ok: ~str,\n        bad: NotEq // error points here.\n    }\n\nUnfortunately, this means the error is disconnected from the `deriving`\nitself but there's no current way to pass that information through to\nrustc except via the spans, at the moment.\n\nFixes #7724.", "tree": {"sha": "bc573c50474ccf53fc5dfbb21c8217beee36d604", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc573c50474ccf53fc5dfbb21c8217beee36d604"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "html_url": "https://github.com/rust-lang/rust/commit/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57d1ed819b9e32a8e915ced9b5e130c299a46bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/57d1ed819b9e32a8e915ced9b5e130c299a46bca", "html_url": "https://github.com/rust-lang/rust/commit/57d1ed819b9e32a8e915ced9b5e130c299a46bca"}], "stats": {"total": 722, "additions": 410, "deletions": 312}, "files": [{"sha": "6ff39351448ba482e117be88e1a0e92bbda7f353", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -94,21 +94,21 @@ fn cs_clone(\n     }\n \n     match *all_fields {\n-        [(None, _, _), .. _] => {\n+        [FieldInfo { name: None, _ }, .. _] => {\n             // enum-like\n-            let subcalls = all_fields.map(|&(_, self_f, _)| subcall(self_f));\n+            let subcalls = all_fields.map(|field| subcall(field.self_));\n             cx.expr_call_ident(span, ctor_ident, subcalls)\n         },\n         _ => {\n             // struct-like\n-            let fields = do all_fields.map |&(o_id, self_f, _)| {\n-                let ident = match o_id {\n+            let fields = do all_fields.map |field| {\n+                let ident = match field.name {\n                     Some(i) => i,\n                     None => cx.span_bug(span,\n                                         format!(\"unnamed field in normal struct in `deriving({})`\",\n                                              name))\n                 };\n-                cx.field_imm(span, ident, subcall(self_f))\n+                cx.field_imm(span, ident, subcall(field.self_))\n             };\n \n             if fields.is_empty() {"}, {"sha": "4ad835f032f84292757ead3c05b21e53c5d9bc0b", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 35, "deletions": 46, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -13,9 +13,7 @@ The compiler code necessary for #[deriving(Decodable)]. See\n encodable.rs for more.\n */\n \n-use std::vec;\n-\n-use ast::{MetaItem, item, Expr, MutMutable};\n+use ast::{MetaItem, item, Expr, MutMutable, Ident};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -66,37 +64,18 @@ fn decodable_substructure(cx: @ExtCtxt, span: Span,\n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             let nfields = match *summary {\n-                Left(n) => n, Right(ref fields) => fields.len()\n+                Unnamed(ref fields) => fields.len(),\n+                Named(ref fields) => fields.len()\n             };\n             let read_struct_field = cx.ident_of(\"read_struct_field\");\n \n-            let getarg = |name: @str, field: uint| {\n+            let result = do decode_static_fields(cx, span, substr.type_ident,\n+                                                 summary) |span, name, field| {\n                 cx.expr_method_call(span, blkdecoder, read_struct_field,\n                                     ~[cx.expr_str(span, name),\n                                       cx.expr_uint(span, field),\n                                       lambdadecode])\n             };\n-\n-            let result = match *summary {\n-                Left(n) => {\n-                    if n == 0 {\n-                        cx.expr_ident(span, substr.type_ident)\n-                    } else {\n-                        let mut fields = vec::with_capacity(n);\n-                        for i in range(0, n) {\n-                            fields.push(getarg(format!(\"_field{}\", i).to_managed(), i));\n-                        }\n-                        cx.expr_call_ident(span, substr.type_ident, fields)\n-                    }\n-                }\n-                Right(ref fields) => {\n-                    let fields = do fields.iter().enumerate().map |(i, f)| {\n-                        cx.field_imm(span, *f, getarg(cx.str_of(*f), i))\n-                    }.collect();\n-                    cx.expr_struct_ident(span, substr.type_ident, fields)\n-                }\n-            };\n-\n             cx.expr_method_call(span, decoder, cx.ident_of(\"read_struct\"),\n                                 ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n                                   cx.expr_uint(span, nfields),\n@@ -113,31 +92,13 @@ fn decodable_substructure(cx: @ExtCtxt, span: Span,\n                 let (name, parts) = match *f { (i, ref p) => (i, p) };\n                 variants.push(cx.expr_str(span, cx.str_of(name)));\n \n-                let getarg = |field: uint| {\n+                let decoded = do decode_static_fields(cx, span, name,\n+                                                      parts) |span, _, field| {\n                     cx.expr_method_call(span, blkdecoder, rvariant_arg,\n                                         ~[cx.expr_uint(span, field),\n                                           lambdadecode])\n                 };\n \n-                let decoded = match *parts {\n-                    Left(n) => {\n-                        if n == 0 {\n-                            cx.expr_ident(span, name)\n-                        } else {\n-                            let mut fields = vec::with_capacity(n);\n-                            for i in range(0u, n) {\n-                                fields.push(getarg(i));\n-                            }\n-                            cx.expr_call_ident(span, name, fields)\n-                        }\n-                    }\n-                    Right(ref fields) => {\n-                        let fields = do fields.iter().enumerate().map |(i, f)| {\n-                            cx.field_imm(span, *f, getarg(i))\n-                        }.collect();\n-                        cx.expr_struct_ident(span, name, fields)\n-                    }\n-                };\n                 arms.push(cx.arm(span,\n                                  ~[cx.pat_lit(span, cx.expr_uint(span, i))],\n                                  decoded));\n@@ -158,3 +119,31 @@ fn decodable_substructure(cx: @ExtCtxt, span: Span,\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in deriving(Decodable)\")\n     };\n }\n+\n+/// Create a decoder for a single enum variant/struct:\n+/// - `outer_pat_ident` is the name of this enum variant/struct\n+/// - `getarg` should retrieve the `uint`-th field with name `@str`.\n+fn decode_static_fields(cx: @ExtCtxt, outer_span: Span, outer_pat_ident: Ident,\n+                        fields: &StaticFields,\n+                        getarg: &fn(Span, @str, uint) -> @Expr) -> @Expr {\n+    match *fields {\n+        Unnamed(ref fields) => {\n+            if fields.is_empty() {\n+                cx.expr_ident(outer_span, outer_pat_ident)\n+            } else {\n+                let fields = do fields.iter().enumerate().map |(i, &span)| {\n+                    getarg(span, format!(\"_field{}\", i).to_managed(), i)\n+                }.collect();\n+\n+                cx.expr_call_ident(outer_span, outer_pat_ident, fields)\n+            }\n+        }\n+        Named(ref fields) => {\n+            // use the field's span to get nicer error messages.\n+            let fields = do fields.iter().enumerate().map |(i, &(name, span))| {\n+                cx.field_imm(span, name, getarg(span, cx.str_of(name), i))\n+            }.collect();\n+            cx.expr_struct_ident(outer_span, outer_pat_ident, fields)\n+        }\n+    }\n+}"}, {"sha": "6bc2b06806b852d2961a4f2804f51295450e4c1b", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -14,8 +14,6 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-use std::vec;\n-\n pub fn expand_deriving_default(cx: @ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n@@ -47,22 +45,22 @@ fn default_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Exp\n         cx.ident_of(\"Default\"),\n         cx.ident_of(\"default\")\n     ];\n-    let default_call = cx.expr_call_global(span, default_ident.clone(), ~[]);\n+    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), ~[]);\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             match *summary {\n-                Left(count) => {\n-                    if count == 0 {\n+                Unnamed(ref fields) => {\n+                    if fields.is_empty() {\n                         cx.expr_ident(span, substr.type_ident)\n                     } else {\n-                        let exprs = vec::from_elem(count, default_call);\n+                        let exprs = fields.map(|sp| default_call(*sp));\n                         cx.expr_call_ident(span, substr.type_ident, exprs)\n                     }\n                 }\n-                Right(ref fields) => {\n-                    let default_fields = do fields.map |ident| {\n-                        cx.field_imm(span, *ident, default_call)\n+                Named(ref fields) => {\n+                    let default_fields = do fields.map |&(ident, span)| {\n+                        cx.field_imm(span, ident, default_call(span))\n                     };\n                     cx.expr_struct_ident(span, substr.type_ident, default_fields)\n                 }"}, {"sha": "a037a4daabfeb6a39a90cb1f8196bcd69ae863a2", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -123,11 +123,11 @@ fn encodable_substructure(cx: @ExtCtxt, span: Span,\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = ~[];\n             for (i, f) in fields.iter().enumerate() {\n-                let (name, val) = match *f {\n-                    (Some(id), e, _) => (cx.str_of(id), e),\n-                    (None, e, _) => (format!(\"_field{}\", i).to_managed(), e)\n+                let name = match f.name {\n+                    Some(id) => cx.str_of(id),\n+                    None => format!(\"_field{}\", i).to_managed()\n                 };\n-                let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n+                let enc = cx.expr_method_call(span, f.self_, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_struct_field,\n@@ -154,8 +154,7 @@ fn encodable_substructure(cx: @ExtCtxt, span: Span,\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = ~[];\n             for (i, f) in fields.iter().enumerate() {\n-                let val = match *f { (_, e, _) => e };\n-                let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n+                let enc = cx.expr_method_call(span, f.self_, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_variant_arg,"}, {"sha": "cfb6048df18f1e5006501d0e9db9704b8d448a3a", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 252, "deletions": 219, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -59,7 +59,7 @@ associated with. It is only not `None` when the associated field has\n an identifier in the source code. For example, the `x`s in the\n following snippet\n \n- ```\n+~~~\n struct A { x : int }\n \n struct B(int);\n@@ -72,17 +72,17 @@ enum C {\n The `int`s in `B` and `C0` don't have an identifier, so the\n `Option<ident>`s would be `None` for them.\n \n-In the static cases, the structure is summarised, either into the\n-number of fields or a list of field idents (for tuple structs and\n-record structs, respectively), or a list of these, for enums (one for\n-each variant). For empty struct and empty enum variants, it is\n-represented as a count of 0.\n+In the static cases, the structure is summarised, either into the just\n+spans of the fields or a list of spans and the field idents (for tuple\n+structs and record structs, respectively), or a list of these, for\n+enums (one for each variant). For empty struct and empty enum\n+variants, it is represented as a count of 0.\n \n # Examples\n \n The following simplified `Eq` is used for in-code examples:\n \n- ```\n+~~~\n trait Eq {\n     fn eq(&self, other: &Self);\n }\n@@ -91,7 +91,7 @@ impl Eq for int {\n         *self == *other\n     }\n }\n- ```\n+~~~\n \n Some examples of the values of `SubstructureFields` follow, using the\n above `Eq`, `A`, `B` and `C`.\n@@ -100,50 +100,62 @@ above `Eq`, `A`, `B` and `C`.\n \n When generating the `expr` for the `A` impl, the `SubstructureFields` is\n \n- ```\n-Struct(~[(Some(<ident of x>),\n-         <expr for &self.x>,\n-         ~[<expr for &other.x])])\n- ```\n+~~~\n+Struct(~[FieldInfo {\n+           span: <span of x>\n+           name: Some(<ident of x>),\n+           self_: <expr for &self.x>,\n+           other: ~[<expr for &other.x]\n+         }])\n+~~~\n \n For the `B` impl, called with `B(a)` and `B(b)`,\n \n- ```\n-Struct(~[(None,\n+~~~\n+Struct(~[FieldInfo {\n+          span: <span of `int`>,\n+          name: None,\n           <expr for &a>\n-          ~[<expr for &b>])])\n- ```\n+          ~[<expr for &b>]\n+         }])\n+~~~\n \n ## Enums\n \n When generating the `expr` for a call with `self == C0(a)` and `other\n == C0(b)`, the SubstructureFields is\n \n- ```\n+~~~\n EnumMatching(0, <ast::variant for C0>,\n-             ~[None,\n-               <expr for &a>,\n-               ~[<expr for &b>]])\n- ```\n+             ~[FieldInfo {\n+                span: <span of int>\n+                name: None,\n+                self_: <expr for &a>,\n+                other: ~[<expr for &b>]\n+              }])\n+~~~\n \n For `C1 {x}` and `C1 {x}`,\n \n- ```\n+~~~\n EnumMatching(1, <ast::variant for C1>,\n-             ~[Some(<ident of x>),\n-               <expr for &self.x>,\n-               ~[<expr for &other.x>]])\n- ```\n+             ~[FieldInfo {\n+                span: <span of x>\n+                name: Some(<ident of x>),\n+                self_: <expr for &self.x>,\n+                other: ~[<expr for &other.x>]\n+               }])\n+~~~\n \n For `C0(a)` and `C1 {x}` ,\n \n- ```\n+~~~\n EnumNonMatching(~[(0, <ast::variant for B0>,\n-                   ~[(None, <expr for &a>)]),\n+                   ~[(<span of int>, None, <expr for &a>)]),\n                   (1, <ast::variant for B1>,\n-                   ~[(Some(<ident of x>),\n+                   ~[(<span of x>, Some(<ident of x>),\n                       <expr for &other.x>)])])\n- ```\n+~~~\n \n (and vice versa, but with the order of the outermost list flipped.)\n \n@@ -152,13 +164,13 @@ EnumNonMatching(~[(0, <ast::variant for B0>,\n A static method on the above would result in,\n \n ~~~~\n-StaticStruct(<ast::struct_def of A>, Right(~[<ident of x>]))\n+StaticStruct(<ast::struct_def of A>, Named(~[(<ident of x>, <span of x>)]))\n \n-StaticStruct(<ast::struct_def of B>, Left(1))\n+StaticStruct(<ast::struct_def of B>, Unnamed(~[<span of x>]))\n \n-StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Left(1)),\n-                                   (<ident of C1>, Right(~[<ident of x>]))])\n- ```\n+StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Unnamed(~[<span of int>])),\n+                                   (<ident of C1>, Named(~[(<ident of x>, <span of x>)]))])\n+~~~\n \n */\n \n@@ -226,34 +238,50 @@ pub struct Substructure<'self> {\n     fields: &'self SubstructureFields<'self>\n }\n \n+/// Summary of the relevant parts of a struct/enum field.\n+pub struct FieldInfo {\n+    span: Span,\n+    /// None for tuple structs/normal enum variants, Some for normal\n+    /// structs/struct enum variants.\n+    name: Option<Ident>,\n+    /// The expression corresponding to this field of `self`\n+    /// (specifically, a reference to it).\n+    self_: @Expr,\n+    /// The expressions corresponding to references to this field in\n+    /// the other Self arguments.\n+    other: ~[@Expr]\n+}\n+\n+/// Fields for a static method\n+pub enum StaticFields {\n+    /// Tuple structs/enum variants like this\n+    Unnamed(~[Span]),\n+    /// Normal structs/struct variants.\n+    Named(~[(Ident, Span)])\n+}\n+\n /// A summary of the possible sets of fields. See above for details\n /// and examples\n pub enum SubstructureFields<'self> {\n-    /**\n-    Vec of `(field ident, self_or_other)` where the field\n-    ident is the ident of the current field (`None` for all fields in tuple\n-    structs).\n-    */\n-    Struct(~[(Option<Ident>, @Expr, ~[@Expr])]),\n-\n+    Struct(~[FieldInfo]),\n     /**\n     Matching variants of the enum: variant index, ast::variant,\n-    fields: `(field ident, self, [others])`, where the field ident is\n-    only non-`None` in the case of a struct variant.\n+    fields: the field name is only non-`None` in the case of a struct\n+    variant.\n     */\n-    EnumMatching(uint, &'self ast::variant, ~[(Option<Ident>, @Expr, ~[@Expr])]),\n+    EnumMatching(uint, &'self ast::variant, ~[FieldInfo]),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::variant,\n-    [field ident, fields])] (i.e. all fields for self are in the\n+    [field span, field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'self [(uint, ast::variant, ~[(Option<Ident>, @Expr)])]),\n+    EnumNonMatching(&'self [(uint, ast::variant, ~[(Span, Option<Ident>, @Expr)])]),\n \n-    /// A static method where Self is a struct\n-    StaticStruct(&'self ast::struct_def, Either<uint, ~[Ident]>),\n-    /// A static method where Self is an enum\n-    StaticEnum(&'self ast::enum_def, ~[(Ident, Either<uint, ~[Ident]>)])\n+    /// A static method where Self is a struct.\n+    StaticStruct(&'self ast::struct_def, StaticFields),\n+    /// A static method where Self is an enum.\n+    StaticEnum(&'self ast::enum_def, ~[(Ident, StaticFields)])\n }\n \n \n@@ -273,27 +301,27 @@ representing each variant: (variant index, ast::variant instance,\n pub type EnumNonMatchFunc<'self> =\n     &'self fn(@ExtCtxt, Span,\n               &[(uint, ast::variant,\n-                 ~[(Option<Ident>, @Expr)])],\n+                 ~[(Span, Option<Ident>, @Expr)])],\n               &[@Expr]) -> @Expr;\n \n \n impl<'self> TraitDef<'self> {\n     pub fn expand(&self, cx: @ExtCtxt,\n-                  span: Span,\n+                  trait_span: Span,\n                   _mitem: @ast::MetaItem,\n                   in_items: ~[@ast::item]) -> ~[@ast::item] {\n         let mut result = ~[];\n         for item in in_items.iter() {\n             result.push(*item);\n             match item.node {\n                 ast::item_struct(struct_def, ref generics) => {\n-                    result.push(self.expand_struct_def(cx, span,\n+                    result.push(self.expand_struct_def(cx, trait_span,\n                                                        struct_def,\n                                                        item.ident,\n                                                        generics));\n                 }\n                 ast::item_enum(ref enum_def, ref generics) => {\n-                    result.push(self.expand_enum_def(cx, span,\n+                    result.push(self.expand_enum_def(cx, trait_span,\n                                                      enum_def,\n                                                      item.ident,\n                                                      generics));\n@@ -314,12 +342,12 @@ impl<'self> TraitDef<'self> {\n      * where B1, B2, ... are the bounds given by `bounds_paths`.'\n      *\n      */\n-    fn create_derived_impl(&self, cx: @ExtCtxt, span: Span,\n+    fn create_derived_impl(&self, cx: @ExtCtxt, trait_span: Span,\n                            type_ident: Ident, generics: &Generics,\n                            methods: ~[@ast::method]) -> @ast::item {\n-        let trait_path = self.path.to_path(cx, span, type_ident, generics);\n+        let trait_path = self.path.to_path(cx, trait_span, type_ident, generics);\n \n-        let mut trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n+        let mut trait_generics = self.generics.to_generics(cx, trait_span, type_ident, generics);\n         // Copy the lifetimes\n         for l in generics.lifetimes.iter() {\n             trait_generics.lifetimes.push(*l)\n@@ -331,7 +359,7 @@ impl<'self> TraitDef<'self> {\n             let mut bounds = opt_vec::from(\n                 // extra restrictions on the generics parameters to the type being derived upon\n                 do self.additional_bounds.map |p| {\n-                    cx.typarambound(p.to_path(cx, span, type_ident, generics))\n+                    cx.typarambound(p.to_path(cx, trait_span, type_ident, generics))\n                 });\n             // require the current trait\n             bounds.push(cx.typarambound(trait_path.clone()));\n@@ -344,7 +372,7 @@ impl<'self> TraitDef<'self> {\n \n         // Create the type parameters on the `self` path.\n         let self_ty_params = do generics.ty_params.map |ty_param| {\n-            cx.ty_ident(span, ty_param.ident)\n+            cx.ty_ident(trait_span, ty_param.ident)\n         };\n \n         let self_lifetime = if generics.lifetimes.is_empty() {\n@@ -354,16 +382,16 @@ impl<'self> TraitDef<'self> {\n         };\n \n         // Create the type of `self`.\n-        let self_type = cx.ty_path(cx.path_all(span, false, ~[ type_ident ], self_lifetime,\n+        let self_type = cx.ty_path(cx.path_all(trait_span, false, ~[ type_ident ], self_lifetime,\n                                                opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute(\n-            span,\n-            cx.meta_name_value(span,\n+            trait_span,\n+            cx.meta_name_value(trait_span,\n                                @\"doc\",\n                                ast::lit_str(@\"Automatically derived.\", ast::CookedStr)));\n         cx.item(\n-            span,\n+            trait_span,\n             ::parse::token::special_idents::clownshoes_extensions,\n             ~[doc_attr],\n             ast::item_impl(trait_generics,\n@@ -373,72 +401,72 @@ impl<'self> TraitDef<'self> {\n     }\n \n     fn expand_struct_def(&self, cx: @ExtCtxt,\n-                         span: Span,\n+                         trait_span: Span,\n                          struct_def: &struct_def,\n                          type_ident: Ident,\n                          generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(cx, span, type_ident, generics);\n+                method_def.split_self_nonself_args(cx, trait_span, type_ident, generics);\n \n             let body = if method_def.is_static() {\n                 method_def.expand_static_struct_method_body(\n-                    cx, span,\n+                    cx, trait_span,\n                     struct_def,\n                     type_ident,\n                     self_args, nonself_args)\n             } else {\n-                method_def.expand_struct_method_body(cx, span,\n+                method_def.expand_struct_method_body(cx, trait_span,\n                                                      struct_def,\n                                                      type_ident,\n                                                      self_args, nonself_args)\n             };\n \n-            method_def.create_method(cx, span,\n+            method_def.create_method(cx, trait_span,\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n         };\n \n-        self.create_derived_impl(cx, span, type_ident, generics, methods)\n+        self.create_derived_impl(cx, trait_span, type_ident, generics, methods)\n     }\n \n     fn expand_enum_def(&self,\n-                       cx: @ExtCtxt, span: Span,\n+                       cx: @ExtCtxt, trait_span: Span,\n                        enum_def: &enum_def,\n                        type_ident: Ident,\n                        generics: &Generics) -> @ast::item {\n         let methods = do self.methods.map |method_def| {\n             let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(cx, span, type_ident, generics);\n+                method_def.split_self_nonself_args(cx, trait_span, type_ident, generics);\n \n             let body = if method_def.is_static() {\n                 method_def.expand_static_enum_method_body(\n-                    cx, span,\n+                    cx, trait_span,\n                     enum_def,\n                     type_ident,\n                     self_args, nonself_args)\n             } else {\n-                method_def.expand_enum_method_body(cx, span,\n+                method_def.expand_enum_method_body(cx, trait_span,\n                                                    enum_def,\n                                                    type_ident,\n                                                    self_args, nonself_args)\n             };\n \n-            method_def.create_method(cx, span,\n+            method_def.create_method(cx, trait_span,\n                                      type_ident, generics,\n                                      explicit_self, tys,\n                                      body)\n         };\n \n-        self.create_derived_impl(cx, span, type_ident, generics, methods)\n+        self.create_derived_impl(cx, trait_span, type_ident, generics, methods)\n     }\n }\n \n impl<'self> MethodDef<'self> {\n     fn call_substructure_method(&self,\n                                 cx: @ExtCtxt,\n-                                span: Span,\n+                                trait_span: Span,\n                                 type_ident: Ident,\n                                 self_args: &[@Expr],\n                                 nonself_args: &[@Expr],\n@@ -451,21 +479,21 @@ impl<'self> MethodDef<'self> {\n             nonself_args: nonself_args,\n             fields: fields\n         };\n-        (self.combine_substructure)(cx, span,\n+        (self.combine_substructure)(cx, trait_span,\n                                     &substructure)\n     }\n \n-    fn get_ret_ty(&self, cx: @ExtCtxt, span: Span,\n-                     generics: &Generics, type_ident: Ident) -> ast::Ty {\n-        self.ret_ty.to_ty(cx, span, type_ident, generics)\n+    fn get_ret_ty(&self, cx: @ExtCtxt, trait_span: Span,\n+                  generics: &Generics, type_ident: Ident) -> ast::Ty {\n+        self.ret_ty.to_ty(cx, trait_span, type_ident, generics)\n     }\n \n     fn is_static(&self) -> bool {\n         self.explicit_self.is_none()\n     }\n \n-    fn split_self_nonself_args(&self, cx: @ExtCtxt, span: Span,\n-                             type_ident: Ident, generics: &Generics)\n+    fn split_self_nonself_args(&self, cx: @ExtCtxt, trait_span: Span,\n+                               type_ident: Ident, generics: &Generics)\n         -> (ast::explicit_self, ~[@Expr], ~[@Expr], ~[(Ident, ast::Ty)]) {\n \n         let mut self_args = ~[];\n@@ -475,22 +503,22 @@ impl<'self> MethodDef<'self> {\n \n         let ast_explicit_self = match self.explicit_self {\n             Some(ref self_ptr) => {\n-                let (self_expr, explicit_self) = ty::get_explicit_self(cx, span, self_ptr);\n+                let (self_expr, explicit_self) = ty::get_explicit_self(cx, trait_span, self_ptr);\n \n                 self_args.push(self_expr);\n                 nonstatic = true;\n \n                 explicit_self\n             }\n-            None => respan(span, ast::sty_static),\n+            None => respan(trait_span, ast::sty_static),\n         };\n \n         for (i, ty) in self.args.iter().enumerate() {\n-            let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n+            let ast_ty = ty.to_ty(cx, trait_span, type_ident, generics);\n             let ident = cx.ident_of(format!(\"__arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n-            let arg_expr = cx.expr_ident(span, ident);\n+            let arg_expr = cx.expr_ident(trait_span, ident);\n \n             match *ty {\n                 // for static methods, just treat any Self\n@@ -499,7 +527,7 @@ impl<'self> MethodDef<'self> {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(~Self, _) if nonstatic => {\n-                    self_args.push(cx.expr_deref(span, arg_expr))\n+                    self_args.push(cx.expr_deref(trait_span, arg_expr))\n                 }\n                 _ => {\n                     nonself_args.push(arg_expr);\n@@ -510,20 +538,20 @@ impl<'self> MethodDef<'self> {\n         (ast_explicit_self, self_args, nonself_args, arg_tys)\n     }\n \n-    fn create_method(&self, cx: @ExtCtxt, span: Span,\n+    fn create_method(&self, cx: @ExtCtxt, trait_span: Span,\n                      type_ident: Ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n                      arg_types: ~[(Ident, ast::Ty)],\n                      body: @Expr) -> @ast::method {\n         // create the generics that aren't for Self\n-        let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);\n+        let fn_generics = self.generics.to_generics(cx, trait_span, type_ident, generics);\n \n-        let args = do arg_types.map |pair| {\n-            cx.arg(span, pair.first(), pair.second())\n-        };\n+        let args = do arg_types.move_iter().map |(name, ty)| {\n+            cx.arg(trait_span, name, ty)\n+        }.collect();\n \n-        let ret_type = self.get_ret_ty(cx, span, generics, type_ident);\n+        let ret_type = self.get_ret_ty(cx, trait_span, generics, type_ident);\n \n         let method_ident = cx.ident_of(self.name);\n         let fn_decl = cx.fn_decl(args, ret_type);\n@@ -540,14 +568,14 @@ impl<'self> MethodDef<'self> {\n             decl: fn_decl,\n             body: body_block,\n             id: ast::DUMMY_NODE_ID,\n-            span: span,\n+            span: trait_span,\n             self_id: ast::DUMMY_NODE_ID,\n             vis: ast::inherited,\n         }\n     }\n \n     /**\n-    ```\n+   ~~~\n     #[deriving(Eq)]\n     struct A { x: int, y: int }\n \n@@ -565,11 +593,11 @@ impl<'self> MethodDef<'self> {\n             }\n         }\n     }\n-    ```\n+   ~~~\n     */\n     fn expand_struct_method_body(&self,\n                                  cx: @ExtCtxt,\n-                                 span: Span,\n+                                 trait_span: Span,\n                                  struct_def: &struct_def,\n                                  type_ident: Ident,\n                                  self_args: &[@Expr],\n@@ -580,7 +608,7 @@ impl<'self> MethodDef<'self> {\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = ~[];\n         for i in range(0u, self_args.len()) {\n-            let (pat, ident_expr) = create_struct_pattern(cx, span,\n+            let (pat, ident_expr) = create_struct_pattern(cx, trait_span,\n                                                           type_ident, struct_def,\n                                                           format!(\"__self_{}\", i),\n                                                           ast::MutImmutable);\n@@ -591,22 +619,27 @@ impl<'self> MethodDef<'self> {\n         // transpose raw_fields\n         let fields = match raw_fields {\n             [ref self_arg, .. rest] => {\n-                do self_arg.iter().enumerate().map |(i, &(opt_id, field))| {\n+                do self_arg.iter().enumerate().map |(i, &(span, opt_id, field))| {\n                     let other_fields = do rest.map |l| {\n                         match &l[i] {\n-                            &(_, ex) => ex\n+                            &(_, _, ex) => ex\n                         }\n                     };\n-                    (opt_id, field, other_fields)\n+                    FieldInfo {\n+                        span: span,\n+                        name: opt_id,\n+                        self_: field,\n+                        other: other_fields\n+                    }\n                 }.collect()\n             }\n-            [] => { cx.span_bug(span, \"No self arguments to non-static \\\n+            [] => { cx.span_bug(trait_span, \"No self arguments to non-static \\\n                                        method in generic `deriving`\") }\n         };\n \n         // body of the inner most destructuring match\n         let mut body = self.call_substructure_method(\n-            cx, span,\n+            cx, trait_span,\n             type_ident,\n             self_args,\n             nonself_args,\n@@ -616,30 +649,30 @@ impl<'self> MethodDef<'self> {\n         // structs. This is actually right-to-left, but it shoudn't\n         // matter.\n         for (&arg_expr, &pat) in self_args.iter().zip(patterns.iter()) {\n-            body = cx.expr_match(span, arg_expr,\n-                                 ~[ cx.arm(span, ~[pat], body) ])\n+            body = cx.expr_match(trait_span, arg_expr,\n+                                 ~[ cx.arm(trait_span, ~[pat], body) ])\n         }\n         body\n     }\n \n     fn expand_static_struct_method_body(&self,\n                                         cx: @ExtCtxt,\n-                                        span: Span,\n+                                        trait_span: Span,\n                                         struct_def: &struct_def,\n                                         type_ident: Ident,\n                                         self_args: &[@Expr],\n                                         nonself_args: &[@Expr])\n         -> @Expr {\n-        let summary = summarise_struct(cx, span, struct_def);\n+        let summary = summarise_struct(cx, trait_span, struct_def);\n \n-        self.call_substructure_method(cx, span,\n+        self.call_substructure_method(cx, trait_span,\n                                       type_ident,\n                                       self_args, nonself_args,\n                                       &StaticStruct(struct_def, summary))\n     }\n \n     /**\n-    ```\n+   ~~~\n     #[deriving(Eq)]\n     enum A {\n         A1\n@@ -662,18 +695,18 @@ impl<'self> MethodDef<'self> {\n             }\n         }\n     }\n-    ```\n+   ~~~\n     */\n     fn expand_enum_method_body(&self,\n                                cx: @ExtCtxt,\n-                               span: Span,\n+                               trait_span: Span,\n                                enum_def: &enum_def,\n                                type_ident: Ident,\n                                self_args: &[@Expr],\n                                nonself_args: &[@Expr])\n         -> @Expr {\n         let mut matches = ~[];\n-        self.build_enum_match(cx, span, enum_def, type_ident,\n+        self.build_enum_match(cx, trait_span, enum_def, type_ident,\n                               self_args, nonself_args,\n                               None, &mut matches, 0)\n     }\n@@ -682,13 +715,13 @@ impl<'self> MethodDef<'self> {\n     /**\n     Creates the nested matches for an enum definition recursively, i.e.\n \n-    ```\n+   ~~~\n     match self {\n        Variant1 => match other { Variant1 => matching, Variant2 => nonmatching, ... },\n        Variant2 => match other { Variant1 => nonmatching, Variant2 => matching, ... },\n        ...\n     }\n-    ```\n+   ~~~\n \n     It acts in the most naive way, so every branch (and subbranch,\n     subsubbranch, etc) exists, not just the ones where all the variants in\n@@ -701,20 +734,20 @@ impl<'self> MethodDef<'self> {\n     the first call).\n     */\n     fn build_enum_match(&self,\n-                        cx: @ExtCtxt, span: Span,\n+                        cx: @ExtCtxt, trait_span: Span,\n                         enum_def: &enum_def,\n                         type_ident: Ident,\n                         self_args: &[@Expr],\n                         nonself_args: &[@Expr],\n                         matching: Option<uint>,\n                         matches_so_far: &mut ~[(uint, ast::variant,\n-                                              ~[(Option<Ident>, @Expr)])],\n+                                              ~[(Span, Option<Ident>, @Expr)])],\n                         match_count: uint) -> @Expr {\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n             if matches_so_far.len() == 0 {\n-                cx.span_bug(span, \"no self match on an enum in generic \\\n+                cx.span_bug(trait_span, \"no self match on an enum in generic \\\n                                    `deriving`\");\n             }\n             // we currently have a vec of vecs, where each\n@@ -742,25 +775,30 @@ impl<'self> MethodDef<'self> {\n                     for triple in matches_so_far.tail().iter() {\n                         match triple {\n                             &(_, _, ref other_fields) => {\n-                                for (i, pair) in other_fields.iter().enumerate() {\n-                                    enum_matching_fields[i].push(pair.second());\n+                                for (i, &(_, _, e)) in other_fields.iter().enumerate() {\n+                                    enum_matching_fields[i].push(e);\n                                 }\n                             }\n                         }\n                     }\n                     let field_tuples =\n                         do self_vec.iter()\n                            .zip(enum_matching_fields.iter())\n-                           .map |(&(id, self_f), other)| {\n-                        (id, self_f, (*other).clone())\n+                           .map |(&(span, id, self_f), other)| {\n+                        FieldInfo {\n+                            span: span,\n+                            name: id,\n+                            self_: self_f,\n+                            other: (*other).clone()\n+                        }\n                     }.collect();\n                     substructure = EnumMatching(variant_index, variant, field_tuples);\n                 }\n                 None => {\n                     substructure = EnumNonMatching(*matches_so_far);\n                 }\n             }\n-            self.call_substructure_method(cx, span, type_ident,\n+            self.call_substructure_method(cx, trait_span, type_ident,\n                                           self_args, nonself_args,\n                                           &substructure)\n \n@@ -779,47 +817,48 @@ impl<'self> MethodDef<'self> {\n                 // make a matching-variant match, and a _ match.\n                 let index = match matching {\n                     Some(i) => i,\n-                    None => cx.span_bug(span, \"Non-matching variants when required to \\\n-                                               be matching in generic `deriving`\")\n+                    None => cx.span_bug(trait_span,\n+                                        \"Non-matching variants when required to \\\n+                                        be matching in generic `deriving`\")\n                 };\n \n                 // matching-variant match\n                 let variant = &enum_def.variants[index];\n-                let (pattern, idents) = create_enum_variant_pattern(cx, span,\n+                let (pattern, idents) = create_enum_variant_pattern(cx,\n                                                                     variant,\n                                                                     current_match_str,\n                                                                     ast::MutImmutable);\n \n                 matches_so_far.push((index,\n                                      /*bad*/ (*variant).clone(),\n                                      idents));\n-                let arm_expr = self.build_enum_match(cx, span,\n+                let arm_expr = self.build_enum_match(cx, trait_span,\n                                                      enum_def,\n                                                      type_ident,\n                                                      self_args, nonself_args,\n                                                      matching,\n                                                      matches_so_far,\n                                                      match_count + 1);\n                 matches_so_far.pop();\n-                arms.push(cx.arm(span, ~[ pattern ], arm_expr));\n+                arms.push(cx.arm(trait_span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n                     let e = &EnumNonMatching(&[]);\n-                    let wild_expr = self.call_substructure_method(cx, span, type_ident,\n+                    let wild_expr = self.call_substructure_method(cx, trait_span, type_ident,\n                                                                   self_args, nonself_args,\n                                                                   e);\n-                    let wild_arm = cx.arm(span,\n-                                          ~[ cx.pat_wild(span) ],\n+                    let wild_arm = cx.arm(trait_span,\n+                                          ~[ cx.pat_wild(trait_span) ],\n                                           wild_expr);\n                     arms.push(wild_arm);\n                 }\n             } else {\n                 // create an arm matching on each variant\n                 for (index, variant) in enum_def.variants.iter().enumerate() {\n-                    let (pattern, idents) = create_enum_variant_pattern(cx, span,\n-                                                                       variant,\n-                                                                       current_match_str,\n-                                                                       ast::MutImmutable);\n+                    let (pattern, idents) = create_enum_variant_pattern(cx,\n+                                                                        variant,\n+                                                                        current_match_str,\n+                                                                        ast::MutImmutable);\n \n                     matches_so_far.push((index,\n                                          /*bad*/ (*variant).clone(),\n@@ -830,7 +869,7 @@ impl<'self> MethodDef<'self> {\n                             Some(i) if index == i => Some(i),\n                             _ => None\n                         };\n-                    let arm_expr = self.build_enum_match(cx, span,\n+                    let arm_expr = self.build_enum_match(cx, trait_span,\n                                                          enum_def,\n                                                          type_ident,\n                                                          self_args, nonself_args,\n@@ -839,70 +878,69 @@ impl<'self> MethodDef<'self> {\n                                                          match_count + 1);\n                     matches_so_far.pop();\n \n-                    let arm = cx.arm(span, ~[ pattern ], arm_expr);\n+                    let arm = cx.arm(trait_span, ~[ pattern ], arm_expr);\n                     arms.push(arm);\n                 }\n             }\n \n             // match foo { arm, arm, arm, ... }\n-            cx.expr_match(span, self_args[match_count], arms)\n+            cx.expr_match(trait_span, self_args[match_count], arms)\n         }\n     }\n \n     fn expand_static_enum_method_body(&self,\n-                               cx: @ExtCtxt,\n-                               span: Span,\n-                               enum_def: &enum_def,\n-                               type_ident: Ident,\n-                               self_args: &[@Expr],\n-                               nonself_args: &[@Expr])\n+                                      cx: @ExtCtxt,\n+                                      trait_span: Span,\n+                                      enum_def: &enum_def,\n+                                      type_ident: Ident,\n+                                      self_args: &[@Expr],\n+                                      nonself_args: &[@Expr])\n         -> @Expr {\n         let summary = do enum_def.variants.map |v| {\n             let ident = v.node.name;\n             let summary = match v.node.kind {\n-                ast::tuple_variant_kind(ref args) => Left(args.len()),\n+                ast::tuple_variant_kind(ref args) => Unnamed(args.map(|va| va.ty.span)),\n                 ast::struct_variant_kind(struct_def) => {\n-                    summarise_struct(cx, span, struct_def)\n+                    summarise_struct(cx, trait_span, struct_def)\n                 }\n             };\n             (ident, summary)\n         };\n         self.call_substructure_method(cx,\n-                                      span, type_ident,\n+                                      trait_span, type_ident,\n                                       self_args, nonself_args,\n                                       &StaticEnum(enum_def, summary))\n     }\n }\n \n-fn summarise_struct(cx: @ExtCtxt, span: Span,\n-                    struct_def: &struct_def) -> Either<uint, ~[Ident]> {\n+fn summarise_struct(cx: @ExtCtxt, trait_span: Span,\n+                    struct_def: &struct_def) -> StaticFields {\n     let mut named_idents = ~[];\n-    let mut unnamed_count = 0;\n+    let mut just_spans = ~[];\n     for field in struct_def.fields.iter() {\n         match field.node.kind {\n-            ast::named_field(ident, _) => named_idents.push(ident),\n-            ast::unnamed_field => unnamed_count += 1,\n+            ast::named_field(ident, _) => named_idents.push((ident, field.span)),\n+            ast::unnamed_field => just_spans.push(field.span),\n         }\n     }\n \n-    match (unnamed_count > 0, named_idents.is_empty()) {\n-        (true, false) => cx.span_bug(span,\n-                                     \"A struct with named and unnamed \\\n+    match (just_spans.is_empty(), named_idents.is_empty()) {\n+        (false, false) => cx.span_bug(trait_span,\n+                                      \"A struct with named and unnamed \\\n                                       fields in generic `deriving`\"),\n         // named fields\n-        (_, false) => Right(named_idents),\n+        (_, false) => Named(named_idents),\n         // tuple structs (includes empty structs)\n-        (_, _)     => Left(unnamed_count)\n+        (_, _)     => Unnamed(just_spans)\n     }\n }\n \n pub fn create_subpatterns(cx: @ExtCtxt,\n-                          span: Span,\n                           field_paths: ~[ast::Path],\n                           mutbl: ast::Mutability)\n                    -> ~[@ast::Pat] {\n     do field_paths.map |path| {\n-        cx.pat(span,\n+        cx.pat(path.span,\n                ast::PatIdent(ast::BindByRef(mutbl), (*path).clone(), None))\n     }\n }\n@@ -913,20 +951,20 @@ enum StructType {\n }\n \n fn create_struct_pattern(cx: @ExtCtxt,\n-                             span: Span,\n-                             struct_ident: Ident,\n-                             struct_def: &struct_def,\n-                             prefix: &str,\n-                             mutbl: ast::Mutability)\n-    -> (@ast::Pat, ~[(Option<Ident>, @Expr)]) {\n+                         trait_span: Span,\n+                         struct_ident: Ident,\n+                         struct_def: &struct_def,\n+                         prefix: &str,\n+                         mutbl: ast::Mutability)\n+    -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n     if struct_def.fields.is_empty() {\n         return (\n             cx.pat_ident_binding_mode(\n-                span, struct_ident, ast::BindByValue(ast::MutImmutable)),\n+                trait_span, struct_ident, ast::BindByValue(ast::MutImmutable)),\n             ~[]);\n     }\n \n-    let matching_path = cx.path(span, ~[ struct_ident ]);\n+    let matching_path = cx.path(trait_span, ~[ struct_ident ]);\n \n     let mut paths = ~[];\n     let mut ident_expr = ~[];\n@@ -945,68 +983,67 @@ fn create_struct_pattern(cx: @ExtCtxt,\n                 None\n             }\n             _ => {\n-                cx.span_bug(span, \"A struct with named and unnamed fields in `deriving`\");\n+                cx.span_bug(struct_field.span,\n+                            \"A struct with named and unnamed fields in `deriving`\");\n             }\n         };\n-        let path = cx.path_ident(span,\n+        let path = cx.path_ident(struct_field.span,\n                                  cx.ident_of(format!(\"{}_{}\", prefix, i)));\n         paths.push(path.clone());\n-        ident_expr.push((opt_id, cx.expr_path(path)));\n+        ident_expr.push((struct_field.span, opt_id, cx.expr_path(path)));\n     }\n \n-    let subpats = create_subpatterns(cx, span, paths, mutbl);\n+    let subpats = create_subpatterns(cx, paths, mutbl);\n \n     // struct_type is definitely not Unknown, since struct_def.fields\n     // must be nonempty to reach here\n     let pattern = if struct_type == Record {\n-        let field_pats = do vec::build(None) |push| {\n-            for (&pat, &(id, _)) in subpats.iter().zip(ident_expr.iter()) {\n-                // id is guaranteed to be Some\n-                push(ast::FieldPat { ident: id.unwrap(), pat: pat })\n-            }\n-        };\n-        cx.pat_struct(span, matching_path, field_pats)\n+        let field_pats = do subpats.iter().zip(ident_expr.iter()).map |(&pat, &(_, id, _))| {\n+            // id is guaranteed to be Some\n+            ast::FieldPat { ident: id.unwrap(), pat: pat }\n+        }.collect();\n+        cx.pat_struct(trait_span, matching_path, field_pats)\n     } else {\n-        cx.pat_enum(span, matching_path, subpats)\n+        cx.pat_enum(trait_span, matching_path, subpats)\n     };\n \n     (pattern, ident_expr)\n }\n \n fn create_enum_variant_pattern(cx: @ExtCtxt,\n-                                   span: Span,\n-                                   variant: &ast::variant,\n-                                   prefix: &str,\n-                                   mutbl: ast::Mutability)\n-    -> (@ast::Pat, ~[(Option<Ident>, @Expr)]) {\n+                               variant: &ast::variant,\n+                               prefix: &str,\n+                               mutbl: ast::Mutability)\n+    -> (@ast::Pat, ~[(Span, Option<Ident>, @Expr)]) {\n \n     let variant_ident = variant.node.name;\n     match variant.node.kind {\n         ast::tuple_variant_kind(ref variant_args) => {\n             if variant_args.is_empty() {\n-                return (cx.pat_ident_binding_mode(\n-                    span, variant_ident, ast::BindByValue(ast::MutImmutable)), ~[]);\n+                return (cx.pat_ident_binding_mode(variant.span, variant_ident,\n+                                                  ast::BindByValue(ast::MutImmutable)),\n+                        ~[]);\n             }\n \n-            let matching_path = cx.path_ident(span, variant_ident);\n+            let matching_path = cx.path_ident(variant.span, variant_ident);\n \n             let mut paths = ~[];\n             let mut ident_expr = ~[];\n-            for i in range(0u, variant_args.len()) {\n-                let path = cx.path_ident(span,\n+            for (i, va) in variant_args.iter().enumerate() {\n+                let path = cx.path_ident(va.ty.span,\n                                          cx.ident_of(format!(\"{}_{}\", prefix, i)));\n \n                 paths.push(path.clone());\n-                ident_expr.push((None, cx.expr_path(path)));\n+                ident_expr.push((va.ty.span, None, cx.expr_path(path)));\n             }\n \n-            let subpats = create_subpatterns(cx, span, paths, mutbl);\n+            let subpats = create_subpatterns(cx, paths, mutbl);\n \n-            (cx.pat_enum(span, matching_path, subpats),\n+            (cx.pat_enum(variant.span, matching_path, subpats),\n              ident_expr)\n         }\n         ast::struct_variant_kind(struct_def) => {\n-            create_struct_pattern(cx, span,\n+            create_struct_pattern(cx, variant.span,\n                                   variant_ident, struct_def,\n                                   prefix,\n                                   mutbl)\n@@ -1029,27 +1066,25 @@ pub fn cs_fold(use_foldl: bool,\n                       other_fs: &[@Expr]) -> @Expr,\n                base: @Expr,\n                enum_nonmatch_f: EnumNonMatchFunc,\n-               cx: @ExtCtxt, span: Span,\n+               cx: @ExtCtxt, trait_span: Span,\n                substructure: &Substructure) -> @Expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n-                do all_fields.iter().fold(base) |old, triple| {\n-                    let (_, self_f, other_fs) = (*triple).clone();\n-                    f(cx, span, old, self_f, other_fs)\n+                do all_fields.iter().fold(base) |old, field| {\n+                    f(cx, field.span, old, field.self_, field.other)\n                 }\n             } else {\n-                do all_fields.rev_iter().fold(base) |old, triple| {\n-                    let (_, self_f, other_fs) = (*triple).clone();\n-                    f(cx, span, old, self_f, other_fs)\n+                do all_fields.rev_iter().fold(base) |old, field| {\n+                    f(cx, field.span, old, field.self_, field.other)\n                 }\n             }\n         },\n-        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, span,\n+        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, trait_span,\n                                                           *all_enums,\n                                                           substructure.nonself_args),\n         StaticEnum(*) | StaticStruct(*) => {\n-            cx.span_bug(span, \"Static function in `deriving`\")\n+            cx.span_bug(trait_span, \"Static function in `deriving`\")\n         }\n     }\n }\n@@ -1059,34 +1094,33 @@ pub fn cs_fold(use_foldl: bool,\n Call the method that is being derived on all the fields, and then\n process the collected results. i.e.\n \n- ```\n+~~~\n f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n               self_2.method(__arg_1_2, __arg_2_2)])\n- ```\n+~~~\n */\n #[inline]\n pub fn cs_same_method(f: &fn(@ExtCtxt, Span, ~[@Expr]) -> @Expr,\n                       enum_nonmatch_f: EnumNonMatchFunc,\n-                      cx: @ExtCtxt, span: Span,\n+                      cx: @ExtCtxt, trait_span: Span,\n                       substructure: &Substructure) -> @Expr {\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n-            let called = do all_fields.map |triple| {\n-                let (_, self_field, other_fields) = (*triple).clone();\n-                cx.expr_method_call(span,\n-                                    self_field,\n+            let called = do all_fields.map |field| {\n+                cx.expr_method_call(field.span,\n+                                    field.self_,\n                                     substructure.method_ident,\n-                                    other_fields)\n+                                    field.other.clone())\n             };\n \n-            f(cx, span, called)\n+            f(cx, trait_span, called)\n         },\n-        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, span,\n+        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, trait_span,\n                                                           *all_enums,\n                                                           substructure.nonself_args),\n         StaticEnum(*) | StaticStruct(*) => {\n-            cx.span_bug(span, \"Static function in `deriving`\")\n+            cx.span_bug(trait_span, \"Static function in `deriving`\")\n         }\n     }\n }\n@@ -1101,7 +1135,7 @@ pub fn cs_same_method_fold(use_foldl: bool,\n                            f: &fn(@ExtCtxt, Span, @Expr, @Expr) -> @Expr,\n                            base: @Expr,\n                            enum_nonmatch_f: EnumNonMatchFunc,\n-                           cx: @ExtCtxt, span: Span,\n+                           cx: @ExtCtxt, trait_span: Span,\n                            substructure: &Substructure) -> @Expr {\n     cs_same_method(\n         |cx, span, vals| {\n@@ -1116,8 +1150,7 @@ pub fn cs_same_method_fold(use_foldl: bool,\n             }\n         },\n         enum_nonmatch_f,\n-        cx, span, substructure)\n-\n+        cx, trait_span, substructure)\n }\n \n /**\n@@ -1127,7 +1160,7 @@ on all the fields.\n #[inline]\n pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n                 enum_nonmatch_f: EnumNonMatchFunc,\n-                cx: @ExtCtxt, span: Span,\n+                cx: @ExtCtxt, trait_span: Span,\n                 substructure: &Substructure) -> @Expr {\n     cs_same_method_fold(\n         true, // foldl is good enough\n@@ -1139,7 +1172,7 @@ pub fn cs_binop(binop: ast::BinOp, base: @Expr,\n         },\n         base,\n         enum_nonmatch_f,\n-        cx, span, substructure)\n+        cx, trait_span, substructure)\n }\n \n /// cs_binop with binop == or"}, {"sha": "82f449fc11673dceb0ca5330c6a7e6a52a32d2cd", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -81,8 +81,8 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @\n         _ => cx.span_bug(span, \"Impossible substructure in `deriving(IterBytes)`\")\n     }\n \n-    for &(_, field, _) in fields.iter() {\n-        exprs.push(call_iterbytes(field));\n+    for &FieldInfo { self_, _ } in fields.iter() {\n+        exprs.push(call_iterbytes(self_));\n     }\n \n     if exprs.len() == 0 {"}, {"sha": "1e2a6fa2eb51b541603f157fb17a58fed5774118", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -15,8 +15,6 @@ use ext::base::ExtCtxt;\n use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n \n-use std::vec;\n-\n pub fn expand_deriving_rand(cx: @ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n@@ -59,7 +57,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cx.ident_of(\"Rand\"),\n         cx.ident_of(\"rand\")\n     ];\n-    let rand_call = || {\n+    let rand_call = |span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n                             ~[ rng[0] ])\n@@ -112,7 +110,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n                     (ident, ref summary) => {\n                         cx.arm(span,\n                                ~[ pat ],\n-                               rand_thing(cx, span, ident, summary, || rand_call()))\n+                               rand_thing(cx, span, ident, summary, |sp| rand_call(sp)))\n                     }\n                 }\n             }.collect::<~[ast::Arm]>();\n@@ -130,20 +128,20 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n \n     fn rand_thing(cx: @ExtCtxt, span: Span,\n                   ctor_ident: Ident,\n-                  summary: &Either<uint, ~[Ident]>,\n-                  rand_call: &fn() -> @Expr) -> @Expr {\n+                  summary: &StaticFields,\n+                  rand_call: &fn(Span) -> @Expr) -> @Expr {\n         match *summary {\n-            Left(count) => {\n-                if count == 0 {\n+            Unnamed(ref fields) => {\n+                if fields.is_empty() {\n                     cx.expr_ident(span, ctor_ident)\n                 } else {\n-                    let exprs = vec::from_fn(count, |_| rand_call());\n+                    let exprs = fields.map(|span| rand_call(*span));\n                     cx.expr_call_ident(span, ctor_ident, exprs)\n                 }\n             }\n-            Right(ref fields) => {\n-                let rand_fields = do fields.map |ident| {\n-                    cx.field_imm(span, *ident, rand_call())\n+            Named(ref fields) => {\n+                let rand_fields = do fields.map |&(ident, span)| {\n+                    cx.field_imm(span, ident, rand_call(span))\n                 };\n                 cx.expr_struct_ident(span, ctor_ident, rand_fields)\n             }"}, {"sha": "69e5ce566f4cf2f4ed7ca2b0fa93831c2a411829", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -49,7 +49,7 @@ fn to_str_substructure(cx: @ExtCtxt, span: Span,\n     let to_str = cx.ident_of(\"to_str\");\n \n     let doit = |start: &str, end: @str, name: ast::Ident,\n-                fields: &[(Option<ast::Ident>, @Expr, ~[@Expr])]| {\n+                fields: &[FieldInfo]| {\n         if fields.len() == 0 {\n             cx.expr_str_uniq(span, cx.str_of(name))\n         } else {\n@@ -65,7 +65,7 @@ fn to_str_substructure(cx: @ExtCtxt, span: Span,\n                 stmts.push(cx.stmt_expr(call));\n             };\n \n-            for (i, &(name, e, _)) in fields.iter().enumerate() {\n+            for (i, &FieldInfo {name, span, self_, _}) in fields.iter().enumerate() {\n                 if i > 0 {\n                     push(cx.expr_str(span, @\", \"));\n                 }\n@@ -76,7 +76,7 @@ fn to_str_substructure(cx: @ExtCtxt, span: Span,\n                         push(cx.expr_str(span, name.to_managed()));\n                     }\n                 }\n-                push(cx.expr_method_call(span, e, to_str, ~[]));\n+                push(cx.expr_method_call(span, self_, to_str, ~[]));\n             }\n             push(cx.expr_str(span, end));\n \n@@ -86,7 +86,7 @@ fn to_str_substructure(cx: @ExtCtxt, span: Span,\n \n     return match *substr.fields {\n         Struct(ref fields) => {\n-            if fields.len() == 0 || fields[0].n0_ref().is_none() {\n+            if fields.len() == 0 || fields[0].name.is_none() {\n                 doit(\"(\", @\")\", substr.type_ident, *fields)\n             } else {\n                 doit(\"{\", @\"}\", substr.type_ident, *fields)"}, {"sha": "827491ad8cb0e6d2943526de8f6fd248479b457f", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -14,8 +14,6 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-use std::vec;\n-\n pub fn expand_deriving_zero(cx: @ExtCtxt,\n                             span: Span,\n                             mitem: @MetaItem,\n@@ -62,22 +60,22 @@ fn zero_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n         cx.ident_of(\"Zero\"),\n         cx.ident_of(\"zero\")\n     ];\n-    let zero_call = cx.expr_call_global(span, zero_ident.clone(), ~[]);\n+    let zero_call = |span| cx.expr_call_global(span, zero_ident.clone(), ~[]);\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {\n             match *summary {\n-                Left(count) => {\n-                    if count == 0 {\n+                Unnamed(ref fields) => {\n+                    if fields.is_empty() {\n                         cx.expr_ident(span, substr.type_ident)\n                     } else {\n-                        let exprs = vec::from_elem(count, zero_call);\n+                        let exprs = fields.map(|sp| zero_call(*sp));\n                         cx.expr_call_ident(span, substr.type_ident, exprs)\n                     }\n                 }\n-                Right(ref fields) => {\n-                    let zero_fields = do fields.map |ident| {\n-                        cx.field_imm(span, *ident, zero_call)\n+                Named(ref fields) => {\n+                    let zero_fields = do fields.map |&(ident, span)| {\n+                        cx.field_imm(span, ident, zero_call(span))\n                     };\n                     cx.expr_struct_ident(span, substr.type_ident, zero_fields)\n                 }"}, {"sha": "44b56e09840acb7a447937a73c09830f6f8e6d9e", "filename": "src/test/compile-fail/deriving-field-span-enum-struct-variant.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-enum-struct-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-enum-struct-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-enum-struct-variant.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(struct_variant)];\n+\n+struct NotEq;\n+\n+#[deriving(Eq)]\n+enum Foo {\n+    Bar {\n+        x: NotEq //~ ERROR mismatched types\n+        //~^ ERROR failed to find an implementation of trait std::cmp::Eq for NotEq\n+    }\n+}\n+\n+pub fn main() {}"}, {"sha": "8189744de1e72ae30ab43253baea6030af402d40", "filename": "src/test/compile-fail/deriving-field-span-enum.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-enum.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[feature(struct_variant)];\n+\n+struct NotEq;\n+\n+#[deriving(Eq)]\n+enum Foo {\n+    Bar(NotEq), //~ ERROR mismatched types\n+        //~^ ERROR failed to find an implementation of trait std::cmp::Eq for NotEq\n+    Baz { x: NotEq }\n+}\n+\n+pub fn main() {}"}, {"sha": "1add2cd689431c41039ae9b537626f545d142aa3", "filename": "src/test/compile-fail/deriving-field-span-struct.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-struct.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct NotEq;\n+\n+#[deriving(Eq)]\n+struct Foo {\n+    x: NotEq //~ ERROR mismatched types\n+        //~^ ERROR failed to find an implementation of trait std::cmp::Eq for NotEq\n+}\n+\n+pub fn main() {}"}, {"sha": "1f56e774f62777849ea5eb52aac8bca9156f3edf", "filename": "src/test/compile-fail/deriving-field-span-tuple-struct.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-field-span-tuple-struct.rs?ref=812ea9e169d6edcc138e334e7e2b2cb5f7ba66b3", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct NotEq;\n+\n+#[deriving(Eq)]\n+struct Foo (\n+    NotEq //~ ERROR mismatched types\n+        //~^ ERROR failed to find an implementation of trait std::cmp::Eq for NotEq\n+        );\n+\n+pub fn main() {}"}]}