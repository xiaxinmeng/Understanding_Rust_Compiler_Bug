{"sha": "888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4OGJiNmM0NTJmODlhMWI1ODdmYjRjZjg4YTZjZWRkOWMwNjUyYmI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-03T16:13:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-03T16:13:06Z"}, "message": "Merge #9468\n\n9468: feat: Make `inline_function` work on methods r=Veykril a=Veykril\n\nNow called `inline_call`.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "0a9815248506d5abc08abaf334f4a19f9a635ea4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a9815248506d5abc08abaf334f4a19f9a635ea4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg4IySCRBK7hj4Ov3rIwAApdgIAFL6oT4k6BolgvMr0XBVB5+t\nlov/XPBaad4upmr2T2+NcCms3ZfJ4OTOzppjnolD2oEmWF+cyFpybwsPx3tXW9UN\n7SXe4SZkDhBDmoTpV2xU/mtGfjr3WiWgSazzN0jVo7kA4YUY4+POSia4DuH+hI6D\nNlSqIKOHHZGvc4yL5MyDk3sDZvhjbn05dUjWcDir3UVWTopWjDMdMhrPBTTI+Atu\nE3WWLADG7TOufXfA4c0z+Vma12AGrN12WfqND0wvKE4NpK1Tc3ASu8+GzMzKP9Qf\nxETUW/D/ZpY+YSJoT7QgNHX6bcMsjNYzE/NsIUSYO1b6m4Pz//VZqC5S8Q+5qoc=\n=xH+f\n-----END PGP SIGNATURE-----\n", "payload": "tree 0a9815248506d5abc08abaf334f4a19f9a635ea4\nparent 8d0fa9cd026300e5435e982109e80c98832655de\nparent 14e18bfa38dc445a07109cd8fbd98d6ff804f076\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1625328786 +0000\ncommitter GitHub <noreply@github.com> 1625328786 +0000\n\nMerge #9468\n\n9468: feat: Make `inline_function` work on methods r=Veykril a=Veykril\n\nNow called `inline_call`.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "html_url": "https://github.com/rust-lang/rust/commit/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d0fa9cd026300e5435e982109e80c98832655de", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d0fa9cd026300e5435e982109e80c98832655de", "html_url": "https://github.com/rust-lang/rust/commit/8d0fa9cd026300e5435e982109e80c98832655de"}, {"sha": "14e18bfa38dc445a07109cd8fbd98d6ff804f076", "url": "https://api.github.com/repos/rust-lang/rust/commits/14e18bfa38dc445a07109cd8fbd98d6ff804f076", "html_url": "https://github.com/rust-lang/rust/commit/14e18bfa38dc445a07109cd8fbd98d6ff804f076"}], "stats": {"total": 647, "additions": 416, "deletions": 231}, "files": [{"sha": "4886b599be0404eba8fbe4f997bc1cdb72f89d1f", "filename": "crates/ide_assists/src/handlers/early_return.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -127,7 +127,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n                         let happy_arm = {\n                             let pat = make::tuple_struct_pat(\n                                 path,\n-                                once(make::ident_pat(make::name(\"it\")).into()),\n+                                once(make::ext::simple_ident_pat(make::name(\"it\")).into()),\n                             );\n                             let expr = {\n                                 let path = make::ext::ident_path(\"it\");"}, {"sha": "14dea0989f8c67246426aba46af98b5215b990f6", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -341,9 +341,9 @@ impl Param {\n         let var = self.var.name(ctx.db()).unwrap().to_string();\n         let var_name = make::name(&var);\n         let pat = match self.kind() {\n-            ParamKind::MutValue => make::ident_mut_pat(var_name),\n+            ParamKind::MutValue => make::ident_pat(false, true, var_name),\n             ParamKind::Value | ParamKind::SharedRef | ParamKind::MutRef => {\n-                make::ident_pat(var_name)\n+                make::ext::simple_ident_pat(var_name)\n             }\n         };\n \n@@ -1072,7 +1072,7 @@ impl FlowHandler {\n             }\n             FlowHandler::IfOption { action } => {\n                 let path = make::ext::ident_path(\"Some\");\n-                let value_pat = make::ident_pat(make::name(\"value\"));\n+                let value_pat = make::ext::simple_ident_pat(make::name(\"value\"));\n                 let pattern = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                 let cond = make::condition(call_expr, Some(pattern.into()));\n                 let value = make::expr_path(make::ext::ident_path(\"value\"));\n@@ -1086,7 +1086,7 @@ impl FlowHandler {\n \n                 let some_arm = {\n                     let path = make::ext::ident_path(\"Some\");\n-                    let value_pat = make::ident_pat(make::name(some_name));\n+                    let value_pat = make::ext::simple_ident_pat(make::name(some_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                     let value = make::expr_path(make::ext::ident_path(some_name));\n                     make::match_arm(iter::once(pat.into()), None, value)\n@@ -1105,14 +1105,14 @@ impl FlowHandler {\n \n                 let ok_arm = {\n                     let path = make::ext::ident_path(\"Ok\");\n-                    let value_pat = make::ident_pat(make::name(ok_name));\n+                    let value_pat = make::ext::simple_ident_pat(make::name(ok_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                     let value = make::expr_path(make::ext::ident_path(ok_name));\n                     make::match_arm(iter::once(pat.into()), None, value)\n                 };\n                 let err_arm = {\n                     let path = make::ext::ident_path(\"Err\");\n-                    let value_pat = make::ident_pat(make::name(err_name));\n+                    let value_pat = make::ext::simple_ident_pat(make::name(err_name));\n                     let pat = make::tuple_struct_pat(path, iter::once(value_pat.into()));\n                     let value = make::expr_path(make::ext::ident_path(err_name));\n                     make::match_arm("}, {"sha": "c4bd5eaa7b70798c219e4525efebab6d42085f94", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -262,8 +262,9 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: ExtendedVariant) -> Op\n                     make::tuple_struct_pat(path, pats).into()\n                 }\n                 ast::StructKind::Record(field_list) => {\n-                    let pats =\n-                        field_list.fields().map(|f| make::ident_pat(f.name().unwrap()).into());\n+                    let pats = field_list\n+                        .fields()\n+                        .map(|f| make::ext::simple_ident_pat(f.name().unwrap()).into());\n                     make::record_pat(path, pats).into()\n                 }\n                 ast::StructKind::Unit => make::path_pat(path),"}, {"sha": "60cf49988e17c62b73da3a620bd2b9f009194b1d", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -256,10 +256,9 @@ fn fn_args(\n         });\n     }\n     deduplicate_arg_names(&mut arg_names);\n-    let params = arg_names\n-        .into_iter()\n-        .zip(arg_types)\n-        .map(|(name, ty)| make::param(make::ident_pat(make::name(&name)).into(), make::ty(&ty)));\n+    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| {\n+        make::param(make::ext::simple_ident_pat(make::name(&name)).into(), make::ty(&ty))\n+    });\n     Some((None, make::param_list(None, params)))\n }\n "}, {"sha": "93f8edb1a8299f40c4e146df8a40a4c91decc66f", "filename": "crates/ide_assists/src/handlers/inline_call.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_call.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -0,0 +1,381 @@\n+use ast::make;\n+use hir::{HasSource, PathResolution};\n+use syntax::{\n+    ast::{self, edit::AstNodeEdit, ArgListOwner},\n+    ted, AstNode,\n+};\n+\n+use crate::{\n+    assist_context::{AssistContext, Assists},\n+    AssistId, AssistKind,\n+};\n+\n+// Assist: inline_call\n+//\n+// Inlines a function or method body.\n+//\n+// ```\n+// fn add(a: u32, b: u32) -> u32 { a + b }\n+// fn main() {\n+//     let x = add$0(1, 2);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn add(a: u32, b: u32) -> u32 { a + b }\n+// fn main() {\n+//     let x = {\n+//         let a = 1;\n+//         let b = 2;\n+//         a + b\n+//     };\n+// }\n+// ```\n+pub(crate) fn inline_call(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let (label, function, arguments, expr) =\n+        if let Some(path_expr) = ctx.find_node_at_offset::<ast::PathExpr>() {\n+            let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n+            let path = path_expr.path()?;\n+\n+            let function = match ctx.sema.resolve_path(&path)? {\n+                PathResolution::Def(hir::ModuleDef::Function(f))\n+                | PathResolution::AssocItem(hir::AssocItem::Function(f)) => f,\n+                _ => return None,\n+            };\n+            (\n+                format!(\"Inline `{}`\", path),\n+                function,\n+                call.arg_list()?.args().collect(),\n+                ast::Expr::CallExpr(call),\n+            )\n+        } else {\n+            let name_ref: ast::NameRef = ctx.find_node_at_offset()?;\n+            let call = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+            let receiver = call.receiver()?;\n+            let function = ctx.sema.resolve_method_call(&call)?;\n+            let mut arguments = vec![receiver];\n+            arguments.extend(call.arg_list()?.args());\n+            (format!(\"Inline `{}`\", name_ref), function, arguments, ast::Expr::MethodCallExpr(call))\n+        };\n+\n+    inline_(acc, ctx, label, function, arguments, expr)\n+}\n+\n+pub(crate) fn inline_(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+    label: String,\n+    function: hir::Function,\n+    arg_list: Vec<ast::Expr>,\n+    expr: ast::Expr,\n+) -> Option<()> {\n+    let hir::InFile { value: function_source, .. } = function.source(ctx.db())?;\n+    let param_list = function_source.param_list()?;\n+\n+    let mut params = Vec::new();\n+    if let Some(self_param) = param_list.self_param() {\n+        // FIXME this should depend on the receiver as well as the self_param\n+        params.push(\n+            make::ident_pat(\n+                self_param.amp_token().is_some(),\n+                self_param.mut_token().is_some(),\n+                make::name(\"this\"),\n+            )\n+            .into(),\n+        );\n+    }\n+    for param in param_list.params() {\n+        params.push(param.pat()?);\n+    }\n+\n+    if arg_list.len() != params.len() {\n+        // Can't inline the function because they've passed the wrong number of\n+        // arguments to this function\n+        cov_mark::hit!(inline_call_incorrect_number_of_arguments);\n+        return None;\n+    }\n+\n+    let new_bindings = params.into_iter().zip(arg_list);\n+\n+    let body = function_source.body()?;\n+\n+    acc.add(\n+        AssistId(\"inline_call\", AssistKind::RefactorInline),\n+        label,\n+        expr.syntax().text_range(),\n+        |builder| {\n+            // FIXME: emit type ascriptions when a coercion happens?\n+            // FIXME: dont create locals when its not required\n+            let statements = new_bindings\n+                .map(|(pattern, value)| make::let_stmt(pattern, Some(value)).into())\n+                .chain(body.statements());\n+\n+            let original_indentation = expr.indent_level();\n+            let mut replacement = make::block_expr(statements, body.tail_expr())\n+                .reset_indent()\n+                .indent(original_indentation);\n+\n+            if param_list.self_param().is_some() {\n+                replacement = replacement.clone_for_update();\n+                let this = make::name_ref(\"this\").syntax().clone_for_update();\n+                // FIXME dont look into descendant methods\n+                replacement\n+                    .syntax()\n+                    .descendants()\n+                    .filter_map(ast::NameRef::cast)\n+                    .filter(|n| n.self_token().is_some())\n+                    .collect::<Vec<_>>()\n+                    .into_iter()\n+                    .rev()\n+                    .for_each(|self_ref| ted::replace(self_ref.syntax(), &this));\n+            }\n+            builder.replace_ast(expr, ast::Expr::BlockExpr(replacement));\n+        },\n+    )\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn no_args_or_return_value_gets_inlined_without_block() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+fn foo() { println!(\"Hello, World!\"); }\n+fn main() {\n+    fo$0o();\n+}\n+\"#,\n+            r#\"\n+fn foo() { println!(\"Hello, World!\"); }\n+fn main() {\n+    {\n+        println!(\"Hello, World!\");\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn args_with_side_effects() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+fn foo(name: String) { println!(\"Hello, {}!\", name); }\n+fn main() {\n+    foo$0(String::from(\"Michael\"));\n+}\n+\"#,\n+            r#\"\n+fn foo(name: String) { println!(\"Hello, {}!\", name); }\n+fn main() {\n+    {\n+        let name = String::from(\"Michael\");\n+        println!(\"Hello, {}!\", name);\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_when_incorrect_number_of_parameters_are_provided() {\n+        cov_mark::check!(inline_call_incorrect_number_of_arguments);\n+        check_assist_not_applicable(\n+            inline_call,\n+            r#\"\n+fn add(a: u32, b: u32) -> u32 { a + b }\n+fn main() { let x = add$0(42); }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_with_multiple_statements() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+fn foo(a: u32, b: u32) -> u32 {\n+    let x = a + b;\n+    let y = x - b;\n+    x * y\n+}\n+\n+fn main() {\n+    let x = foo$0(1, 2);\n+}\n+\"#,\n+            r#\"\n+fn foo(a: u32, b: u32) -> u32 {\n+    let x = a + b;\n+    let y = x - b;\n+    x * y\n+}\n+\n+fn main() {\n+    let x = {\n+        let a = 1;\n+        let b = 2;\n+        let x = a + b;\n+        let y = x - b;\n+        x * y\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn function_with_self_param() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo::add$0(Foo(3), 2);\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = {\n+        let this = Foo(3);\n+        let a = 2;\n+        Foo(this.0 + a)\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_by_val() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo(3).add$0(2);\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = {\n+        let this = Foo(3);\n+        let a = 2;\n+        Foo(this.0 + a)\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_by_ref() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(&self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = Foo(3).add$0(2);\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn add(&self, a: u32) -> Self {\n+        Foo(self.0 + a)\n+    }\n+}\n+\n+fn main() {\n+    let x = {\n+        let ref this = Foo(3);\n+        let a = 2;\n+        Foo(this.0 + a)\n+    };\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn method_by_ref_mut() {\n+        check_assist(\n+            inline_call,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn clear(&mut self) {\n+        self.0 = 0;\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo(3);\n+    foo.clear$0();\n+}\n+\"#,\n+            r#\"\n+struct Foo(u32);\n+\n+impl Foo {\n+    fn clear(&mut self) {\n+        self.0 = 0;\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo(3);\n+    {\n+        let ref mut this = foo;\n+        this.0 = 0;\n+    };\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "8e56029cb3f8457e6d1fecc85784815bc752334b", "filename": "crates/ide_assists/src/handlers/inline_function.rs", "status": "removed", "additions": 0, "deletions": 201, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/8d0fa9cd026300e5435e982109e80c98832655de/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d0fa9cd026300e5435e982109e80c98832655de/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Finline_function.rs?ref=8d0fa9cd026300e5435e982109e80c98832655de", "patch": "@@ -1,201 +0,0 @@\n-use ast::make;\n-use hir::{HasSource, PathResolution};\n-use syntax::{\n-    ast::{self, edit::AstNodeEdit, ArgListOwner},\n-    AstNode,\n-};\n-\n-use crate::{\n-    assist_context::{AssistContext, Assists},\n-    AssistId, AssistKind,\n-};\n-\n-// Assist: inline_function\n-//\n-// Inlines a function body.\n-//\n-// ```\n-// fn add(a: u32, b: u32) -> u32 { a + b }\n-// fn main() {\n-//     let x = add$0(1, 2);\n-// }\n-// ```\n-// ->\n-// ```\n-// fn add(a: u32, b: u32) -> u32 { a + b }\n-// fn main() {\n-//     let x = {\n-//         let a = 1;\n-//         let b = 2;\n-//         a + b\n-//     };\n-// }\n-// ```\n-pub(crate) fn inline_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n-    let path_expr: ast::PathExpr = ctx.find_node_at_offset()?;\n-    let call = path_expr.syntax().parent().and_then(ast::CallExpr::cast)?;\n-    let path = path_expr.path()?;\n-\n-    let function = match ctx.sema.resolve_path(&path)? {\n-        PathResolution::Def(hir::ModuleDef::Function(f)) => f,\n-        _ => return None,\n-    };\n-\n-    let function_source = function.source(ctx.db())?;\n-    let arguments: Vec<_> = call.arg_list()?.args().collect();\n-    let parameters = function_parameter_patterns(&function_source.value)?;\n-\n-    if arguments.len() != parameters.len() {\n-        // Can't inline the function because they've passed the wrong number of\n-        // arguments to this function\n-        cov_mark::hit!(inline_function_incorrect_number_of_arguments);\n-        return None;\n-    }\n-\n-    let new_bindings = parameters.into_iter().zip(arguments);\n-\n-    let body = function_source.value.body()?;\n-\n-    acc.add(\n-        AssistId(\"inline_function\", AssistKind::RefactorInline),\n-        format!(\"Inline `{}`\", path),\n-        call.syntax().text_range(),\n-        |builder| {\n-            let mut statements: Vec<ast::Stmt> = Vec::new();\n-\n-            for (pattern, value) in new_bindings {\n-                statements.push(make::let_stmt(pattern, Some(value)).into());\n-            }\n-\n-            statements.extend(body.statements());\n-\n-            let original_indentation = call.indent_level();\n-            let replacement = make::block_expr(statements, body.tail_expr())\n-                .reset_indent()\n-                .indent(original_indentation);\n-\n-            builder.replace_ast(ast::Expr::CallExpr(call), ast::Expr::BlockExpr(replacement));\n-        },\n-    )\n-}\n-\n-fn function_parameter_patterns(value: &ast::Fn) -> Option<Vec<ast::Pat>> {\n-    let mut patterns = Vec::new();\n-\n-    for param in value.param_list()?.params() {\n-        let pattern = param.pat()?;\n-        patterns.push(pattern);\n-    }\n-\n-    Some(patterns)\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::tests::{check_assist, check_assist_not_applicable};\n-\n-    use super::*;\n-\n-    #[test]\n-    fn no_args_or_return_value_gets_inlined_without_block() {\n-        check_assist(\n-            inline_function,\n-            r#\"\n-fn foo() { println!(\"Hello, World!\"); }\n-fn main() {\n-    fo$0o();\n-}\n-\"#,\n-            r#\"\n-fn foo() { println!(\"Hello, World!\"); }\n-fn main() {\n-    {\n-        println!(\"Hello, World!\");\n-    };\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn args_with_side_effects() {\n-        check_assist(\n-            inline_function,\n-            r#\"\n-fn foo(name: String) { println!(\"Hello, {}!\", name); }\n-fn main() {\n-    foo$0(String::from(\"Michael\"));\n-}\n-\"#,\n-            r#\"\n-fn foo(name: String) { println!(\"Hello, {}!\", name); }\n-fn main() {\n-    {\n-        let name = String::from(\"Michael\");\n-        println!(\"Hello, {}!\", name);\n-    };\n-}\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn method_inlining_isnt_supported() {\n-        check_assist_not_applicable(\n-            inline_function,\n-            r\"\n-struct Foo;\n-impl Foo { fn bar(&self) {} }\n-\n-fn main() { Foo.bar$0(); }\n-\",\n-        );\n-    }\n-\n-    #[test]\n-    fn not_applicable_when_incorrect_number_of_parameters_are_provided() {\n-        cov_mark::check!(inline_function_incorrect_number_of_arguments);\n-        check_assist_not_applicable(\n-            inline_function,\n-            r#\"\n-fn add(a: u32, b: u32) -> u32 { a + b }\n-fn main() { let x = add$0(42); }\n-\"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn function_with_multiple_statements() {\n-        check_assist(\n-            inline_function,\n-            r#\"\n-fn foo(a: u32, b: u32) -> u32 {\n-    let x = a + b;\n-    let y = x - b;\n-    x * y\n-}\n-\n-fn main() {\n-    let x = foo$0(1, 2);\n-}\n-\"#,\n-            r#\"\n-fn foo(a: u32, b: u32) -> u32 {\n-    let x = a + b;\n-    let y = x - b;\n-    x * y\n-}\n-\n-fn main() {\n-    let x = {\n-        let a = 1;\n-        let b = 2;\n-        let x = a + b;\n-        let y = x - b;\n-        x * y\n-    };\n-}\n-\"#,\n-        );\n-    }\n-}"}, {"sha": "ccc8449775adfa5e8138e31a1dfd1713c6343b6b", "filename": "crates/ide_assists/src/handlers/replace_unwrap_with_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext)\n         target,\n         |builder| {\n             let ok_path = make::ext::ident_path(happy_variant);\n-            let it = make::ident_pat(make::name(\"it\")).into();\n+            let it = make::ext::simple_ident_pat(make::name(\"it\")).into();\n             let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n             let bind_path = make::ext::ident_path(\"it\");"}, {"sha": "bc30020f1f9566389f16f7b9dccc73fedc423893", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -85,7 +85,7 @@ mod handlers {\n     mod generate_new;\n     mod generate_setter;\n     mod infer_function_return_type;\n-    mod inline_function;\n+    mod inline_call;\n     mod inline_local_variable;\n     mod introduce_named_lifetime;\n     mod invert_if;\n@@ -155,7 +155,7 @@ mod handlers {\n             generate_new::generate_new,\n             generate_setter::generate_setter,\n             infer_function_return_type::infer_function_return_type,\n-            inline_function::inline_function,\n+            inline_call::inline_call,\n             inline_local_variable::inline_local_variable,\n             introduce_named_lifetime::introduce_named_lifetime,\n             invert_if::invert_if,"}, {"sha": "cae2ad57eb5d62eed29187581f5e419ad732993b", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -919,9 +919,9 @@ fn foo() -> i32 { 42i32 }\n }\n \n #[test]\n-fn doctest_inline_function() {\n+fn doctest_inline_call() {\n     check_doc_test(\n-        \"inline_function\",\n+        \"inline_call\",\n         r#####\"\n fn add(a: u32, b: u32) -> u32 { a + b }\n fn main() {"}, {"sha": "91f1d1cb7dbbc19631d2692ee12a93cddbb28b23", "filename": "crates/ide_db/src/ty_filter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fide_db%2Fsrc%2Fty_filter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fty_filter.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -47,7 +47,7 @@ impl TryEnum {\n                 iter::once(make::wildcard_pat().into()),\n             )\n             .into(),\n-            TryEnum::Option => make::ident_pat(make::name(\"None\")).into(),\n+            TryEnum::Option => make::ext::simple_ident_pat(make::name(\"None\")).into(),\n         }\n     }\n "}, {"sha": "e00ec7f1963c3fde158bf095a82d4c9319eebd14", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888bb6c452f89a1b587fb4cf88a6cedd9c0652bb/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=888bb6c452f89a1b587fb4cf88a6cedd9c0652bb", "patch": "@@ -21,6 +21,13 @@ use crate::{ast, AstNode, SourceFile, SyntaxKind, SyntaxToken};\n pub mod ext {\n     use super::*;\n \n+    pub fn simple_ident_pat(name: ast::Name) -> ast::IdentPat {\n+        return from_text(&name.text());\n+\n+        fn from_text(text: &str) -> ast::IdentPat {\n+            ast_from_text(&format!(\"fn f({}: ())\", text))\n+        }\n+    }\n     pub fn ident_path(ident: &str) -> ast::Path {\n         path_unqualified(path_segment(name_ref(ident)))\n     }\n@@ -330,19 +337,17 @@ pub fn arg_list(args: impl IntoIterator<Item = ast::Expr>) -> ast::ArgList {\n     ast_from_text(&format!(\"fn main() {{ ()({}) }}\", args.into_iter().format(\", \")))\n }\n \n-pub fn ident_pat(name: ast::Name) -> ast::IdentPat {\n-    return from_text(&name.text());\n-\n-    fn from_text(text: &str) -> ast::IdentPat {\n-        ast_from_text(&format!(\"fn f({}: ())\", text))\n+pub fn ident_pat(ref_: bool, mut_: bool, name: ast::Name) -> ast::IdentPat {\n+    let mut s = String::from(\"fn f(\");\n+    if ref_ {\n+        s.push_str(\"ref \");\n     }\n-}\n-pub fn ident_mut_pat(name: ast::Name) -> ast::IdentPat {\n-    return from_text(&name.text());\n-\n-    fn from_text(text: &str) -> ast::IdentPat {\n-        ast_from_text(&format!(\"fn f(mut {}: ())\", text))\n+    if mut_ {\n+        s.push_str(\"mut \");\n     }\n+    format_to!(s, \"{}\", name);\n+    s.push_str(\": ())\");\n+    ast_from_text(&s)\n }\n \n pub fn wildcard_pat() -> ast::WildcardPat {"}]}