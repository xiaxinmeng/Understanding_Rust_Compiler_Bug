{"sha": "a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMGEwYWRjNzkxMzE1MmJmZjYyNmQ2ZGJlYmZhMmNmZGJiOTNkMGE=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-02T04:44:30Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2017-02-10T17:42:41Z"}, "message": "Only SwitchInt over integers, not all consts\n\nAlso use a Cow to avoid full Vec for all SwitchInts", "tree": {"sha": "4848312f6e9657f06bf6d15bddef8cdd63cbf6ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4848312f6e9657f06bf6d15bddef8cdd63cbf6ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "html_url": "https://github.com/rust-lang/rust/commit/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aac82d9b13f8ba1baebc5a2a1a673831e6f6fbe7", "url": "https://api.github.com/repos/rust-lang/rust/commits/aac82d9b13f8ba1baebc5a2a1a673831e6f6fbe7", "html_url": "https://github.com/rust-lang/rust/commit/aac82d9b13f8ba1baebc5a2a1a673831e6f6fbe7"}], "stats": {"total": 255, "additions": 154, "deletions": 101}, "files": [{"sha": "f885a6d95693f34ad288ce85c7115ea5c759920d", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -11,13 +11,16 @@\n use syntax::symbol::InternedString;\n use syntax::ast;\n use std::rc::Rc;\n+use std::borrow::Cow;\n use hir::def_id::DefId;\n use rustc_const_math::*;\n use self::ConstVal::*;\n pub use rustc_const_math::ConstInt;\n \n use std::collections::BTreeMap;\n \n+pub static BOOL_SWITCH_TRUE: Cow<'static, [ConstInt]> = Cow::Borrowed(&[ConstInt::Infer(1)]);\n+\n #[derive(Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq)]\n pub enum ConstVal {\n     Float(ConstFloat),\n@@ -49,4 +52,14 @@ impl ConstVal {\n             Char(..) => \"char\",\n         }\n     }\n+\n+    pub fn to_const_int(&self) -> Option<ConstInt> {\n+        match *self {\n+            ConstVal::Integral(i) => Some(i),\n+            ConstVal::Bool(true) => Some(ConstInt::Infer(1)),\n+            ConstVal::Bool(false) => Some(ConstInt::Infer(0)),\n+            ConstVal::Char(ch) => Some(ConstInt::U32(ch as u32)),\n+            _ => None\n+        }\n+    }\n }"}, {"sha": "28990fd323f3d7e9e2c2b2add79f4f36930460a4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -446,6 +446,9 @@ pub struct Terminator<'tcx> {\n     pub kind: TerminatorKind<'tcx>\n }\n \n+/// For use in SwitchInt, for switching on bools.\n+pub static BOOL_SWITCH_TRUE: Cow<'static, [ConstInt]> = Cow::Borrowed(&[ConstInt::Infer(1)]);\n+\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum TerminatorKind<'tcx> {\n     /// block should have one successor in the graph; we jump there\n@@ -464,8 +467,7 @@ pub enum TerminatorKind<'tcx> {\n \n         /// Possible values. The locations to branch to in each case\n         /// are found in the corresponding indices from the `targets` vector.\n-        // FIXME: ConstVal doesn\u2019t quite make any sense here? Its a Switch*Int*.\n-        values: Vec<ConstVal>,\n+        values: Cow<'tcx, [ConstInt]>,\n \n         /// Possible branch sites. The length of this vector should be\n         /// equal to the length of the `values` vector plus 1 -- the\n@@ -696,7 +698,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                 values.iter()\n                       .map(|const_val| {\n                           let mut buf = String::new();\n-                          fmt_const_val(&mut buf, const_val).unwrap();\n+                          fmt_const_val(&mut buf, &ConstVal::Integral(*const_val)).unwrap();\n                           buf.into()\n                       })\n                       .chain(iter::once(String::from(\"otherwise\").into()))"}, {"sha": "be3c43db7baddefbac8ab0457e2195ac547b23f0", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -223,6 +223,12 @@ macro_rules! make_mir_visitor {\n                 self.super_const_val(const_val);\n             }\n \n+            fn visit_const_int(&mut self,\n+                               const_int: &ConstInt,\n+                               _: Location) {\n+                self.super_const_int(const_int);\n+            }\n+\n             fn visit_const_usize(&mut self,\n                                  const_usize: & $($mutability)* ConstUsize,\n                                  _: Location) {\n@@ -364,12 +370,12 @@ macro_rules! make_mir_visitor {\n \n                     TerminatorKind::SwitchInt { ref $($mutability)* discr,\n                                                 ref $($mutability)* switch_ty,\n-                                                ref $($mutability)* values,\n+                                                ref values,\n                                                 ref targets } => {\n                         self.visit_operand(discr, source_location);\n                         self.visit_ty(switch_ty);\n-                        for value in values {\n-                            self.visit_const_val(value, source_location);\n+                        for value in &values[..] {\n+                            self.visit_const_int(value, source_location);\n                         }\n                         for &target in targets {\n                             self.visit_branch(block, target);\n@@ -698,10 +704,13 @@ macro_rules! make_mir_visitor {\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n-            fn super_const_val(&mut self, _substs: & $($mutability)* ConstVal) {\n+            fn super_const_val(&mut self, _const_val: & $($mutability)* ConstVal) {\n+            }\n+\n+            fn super_const_int(&mut self, _const_int: &ConstInt) {\n             }\n \n-            fn super_const_usize(&mut self, _substs: & $($mutability)* ConstUsize) {\n+            fn super_const_usize(&mut self, _const_usize: & $($mutability)* ConstUsize) {\n             }\n \n             // Convenience methods"}, {"sha": "53e84f1fb7117c5fa01539e08ff0d59f389c1fc2", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -679,7 +679,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                     let discr = ConstInt::new_inttype(variant.disr_val, adt.discr_ty,\n                                                       self.tcx.sess.target.uint_type,\n                                                       self.tcx.sess.target.int_type).unwrap();\n-                    values.push(ConstVal::Integral(discr));\n+                    values.push(discr);\n                     blocks.push(self.open_drop_for_variant(c, &mut drop_block, adt, substs, idx));\n                 }\n                 // If there are multiple variants, then if something\n@@ -704,7 +704,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                         kind: TerminatorKind::SwitchInt {\n                             discr: Operand::Consume(discr),\n                             switch_ty: discr_ty,\n-                            values: values,\n+                            values: From::from(values),\n                             targets: blocks,\n                             // adt_def: adt,\n                             // targets: variant_drops\n@@ -836,7 +836,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 self.new_block(c, is_cleanup, TerminatorKind::SwitchInt {\n                     discr: Operand::Consume(flag),\n                     switch_ty: boolty,\n-                    values: vec![ConstVal::Bool(true)],\n+                    values: BOOL_SWITCH_TRUE.clone(),\n                     targets: vec![on_set, on_unset],\n                 })\n             }"}, {"sha": "537daa4a15ba40288e95a8d96e1c7066f33559b8", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -15,7 +15,6 @@ use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n use rustc::ty;\n use rustc::mir::*;\n-use rustc::middle::const_val::ConstVal;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n@@ -73,7 +72,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n                     discr: operand,\n                     switch_ty: this.hir.bool_ty(),\n-                    values: vec![ConstVal::Bool(true)],\n+                    values: BOOL_SWITCH_TRUE.clone(),\n                     targets: vec![then_block, else_block],\n                 });\n \n@@ -120,15 +119,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 this.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n                     discr: lhs,\n                     switch_ty: this.hir.bool_ty(),\n-                    values: vec![ConstVal::Bool(true)],\n+                    values: BOOL_SWITCH_TRUE.clone(),\n                     targets: blocks,\n                 });\n \n                 let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n                 this.cfg.terminate(else_block, source_info, TerminatorKind::SwitchInt {\n                     discr: rhs,\n                     switch_ty: this.hir.bool_ty(),\n-                    values: vec![ConstVal::Bool(true)],\n+                    values: BOOL_SWITCH_TRUE.clone(),\n                     targets: vec![true_block, false_block],\n                 });\n \n@@ -192,7 +191,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                TerminatorKind::SwitchInt {\n                                                    discr: cond,\n                                                    switch_ty: this.hir.bool_ty(),\n-                                                   values: vec![ConstVal::Bool(true)],\n+                                                   values: BOOL_SWITCH_TRUE.clone(),\n                                                    targets: vec![body_block, exit_block],\n                                                });\n "}, {"sha": "885965da1f92455bde252b20c16ebde607a08e25", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -675,7 +675,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             self.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n                 discr: cond,\n                 switch_ty: self.hir.bool_ty(),\n-                values: vec![ConstVal::Bool(true)],\n+                values: BOOL_SWITCH_TRUE.clone(),\n                 targets: vec![arm_block, otherwise],\n             });\n             Some(otherwise)"}, {"sha": "f2d48f65fef2fe40c056f59b5f68f5dff176f964", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 39, "deletions": 56, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         let discr = ConstInt::new_inttype(variant.disr_val, adt_def.discr_ty,\n                                                           tcx.sess.target.uint_type,\n                                                           tcx.sess.target.int_type).unwrap();\n-                        values.push(ConstVal::Integral(discr));\n+                        values.push(discr);\n                         *(targets.place_back() <- self.cfg.start_new_block())\n                     } else {\n                         if otherwise_block.is_none() {\n@@ -226,59 +226,45 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n                     discr: Operand::Consume(discr),\n                     switch_ty: discr_ty,\n-                    values: values,\n+                    values: From::from(values),\n                     targets: targets\n                 });\n                 target_blocks\n             }\n \n             TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n-                let (targets, term) = match switch_ty.sty {\n-                    // If we're matching on boolean we can\n-                    // use the If TerminatorKind instead\n-                    ty::TyBool => {\n-                        assert!(options.len() > 0 && options.len() <= 2);\n-\n-                        let (true_bb, else_bb) =\n-                            (self.cfg.start_new_block(),\n-                             self.cfg.start_new_block());\n-\n-                        let targets = match &options[0] {\n-                            &ConstVal::Bool(true) => vec![true_bb, else_bb],\n-                            &ConstVal::Bool(false) => vec![else_bb, true_bb],\n-                            v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n-                        };\n-\n-                        (targets, TerminatorKind::SwitchInt {\n-                             discr: Operand::Consume(lvalue.clone()),\n-                             switch_ty: self.hir.bool_ty(),\n-                             values: vec![ConstVal::Bool(true)],\n-                             targets: vec![true_bb, else_bb]\n-                         })\n-\n-                    }\n-                    _ => {\n-                        // The switch may be inexhaustive so we\n-                        // add a catch all block\n-                        let otherwise = self.cfg.start_new_block();\n-                        let targets: Vec<_> =\n-                            options.iter()\n-                                   .map(|_| self.cfg.start_new_block())\n-                                   .chain(Some(otherwise))\n-                                   .collect();\n-\n-                        (targets.clone(),\n-                         TerminatorKind::SwitchInt {\n-                             discr: Operand::Consume(lvalue.clone()),\n-                             switch_ty: switch_ty,\n-                             values: options.clone(),\n-                             targets: targets\n-                         })\n-                    }\n+                let (values, targets, ret) = if switch_ty.sty == ty::TyBool {\n+                    assert!(options.len() > 0 && options.len() <= 2);\n+                    let (true_bb, false_bb) = (self.cfg.start_new_block(),\n+                                               self.cfg.start_new_block());\n+                    let ret = match &options[0] {\n+                        &ConstVal::Bool(true) => vec![true_bb, false_bb],\n+                        &ConstVal::Bool(false) => vec![false_bb, true_bb],\n+                        v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n+                    };\n+                    (BOOL_SWITCH_TRUE.clone(), vec![true_bb, false_bb], ret)\n+                } else {\n+                    // The switch may be inexhaustive so we\n+                    // add a catch all block\n+                    let otherwise = self.cfg.start_new_block();\n+                    let targets: Vec<_> =\n+                        options.iter()\n+                               .map(|_| self.cfg.start_new_block())\n+                               .chain(Some(otherwise))\n+                               .collect();\n+                    let values: Vec<_> = options.iter().map(|v|\n+                        v.to_const_int().expect(\"switching on integral\")\n+                    ).collect();\n+                    (From::from(values), targets.clone(), targets)\n                 };\n \n-                self.cfg.terminate(block, source_info, term);\n-                targets\n+                self.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n+                    discr: Operand::Consume(lvalue.clone()),\n+                    switch_ty: switch_ty,\n+                    values: values,\n+                    targets: targets.clone(),\n+                });\n+                ret\n             }\n \n             TestKind::Eq { ref value, mut ty } => {\n@@ -346,10 +332,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     self.cfg.terminate(eq_block, source_info, TerminatorKind::SwitchInt {\n                         discr: Operand::Consume(eq_result),\n                         switch_ty: self.hir.bool_ty(),\n-                        values: vec![ConstVal::Bool(true)],\n+                        values: BOOL_SWITCH_TRUE.clone(),\n                         targets: vec![block, fail],\n                     });\n-\n                     vec![block, fail]\n                 } else {\n                     let block = self.compare(block, fail, test.span, BinOp::Eq, expect, val);\n@@ -391,16 +376,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                       Operand::Consume(expected)));\n \n                 // branch based on result\n-                let target_blocks: Vec<_> = vec![self.cfg.start_new_block(),\n-                                                 self.cfg.start_new_block()];\n+                let (false_bb, true_bb) = (self.cfg.start_new_block(),\n+                                           self.cfg.start_new_block());\n                 self.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n                     discr: Operand::Consume(result),\n                     switch_ty: self.hir.bool_ty(),\n-                    values: vec![ConstVal::Bool(true)],\n-                    targets: target_blocks.clone(),\n+                    values: BOOL_SWITCH_TRUE.clone(),\n+                    targets: vec![true_bb, false_bb],\n                 });\n-\n-                target_blocks\n+                vec![true_bb, false_bb]\n             }\n         }\n     }\n@@ -425,10 +409,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n             discr: Operand::Consume(result),\n             switch_ty: self.hir.bool_ty(),\n-            values: vec![ConstVal::Bool(true)],\n+            values: BOOL_SWITCH_TRUE.clone(),\n             targets: vec![target_block, fail_block]\n         });\n-\n         target_block\n     }\n "}, {"sha": "651d0066b12dd3d9f944eb21a4d00e631524bcd0", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -11,6 +11,7 @@\n use llvm::{self, ValueRef, BasicBlockRef};\n use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n+use rustc::middle::const_val::ConstInt;\n use rustc::ty::{self, layout, TypeFoldable};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n@@ -134,14 +135,24 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-                // TODO: cond_br if only 1 value\n-                let (otherwise, targets) = targets.split_last().unwrap();\n-                let discr = self.trans_operand(&bcx, discr).immediate();\n-                let switch = bcx.switch(discr, llblock(self, *otherwise), values.len());\n-                for (value, target) in values.iter().zip(targets) {\n-                    let val = Const::from_constval(bcx.ccx, value.clone(), switch_ty);\n-                    let llbb = llblock(self, *target);\n-                    bcx.add_case(switch, val.llval, llbb)\n+                let discr = self.trans_operand(&bcx, discr);\n+                if switch_ty == bcx.tcx().types.bool {\n+                    let lltrue = llblock(self, targets[0]);\n+                    let llfalse = llblock(self, targets[1]);\n+                    if let [ConstInt::Infer(0)] = values[..] {\n+                        bcx.cond_br(discr.immediate(), llfalse, lltrue);\n+                    } else {\n+                        bcx.cond_br(discr.immediate(), lltrue, llfalse);\n+                    }\n+                } else {\n+                    let (otherwise, targets) = targets.split_last().unwrap();\n+                    let switch = bcx.switch(discr.immediate(),\n+                                            llblock(self, *otherwise), values.len());\n+                    for (value, target) in values.iter().zip(targets) {\n+                        let val = Const::from_constint(bcx.ccx, value);\n+                        let llbb = llblock(self, *target);\n+                        bcx.add_case(switch, val.llval, llbb)\n+                    }\n                 }\n             }\n "}, {"sha": "19139301bb0c48449beadcf6faccfa669e895bed", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -61,6 +61,33 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n+    pub fn from_constint<'a>(ccx: &CrateContext<'a, 'tcx>, ci: &ConstInt)\n+    -> Const<'tcx> {\n+        let tcx = ccx.tcx();\n+        let (llval, ty) = match *ci {\n+            I8(v) => (C_integral(Type::i8(ccx), v as u64, true), tcx.types.i8),\n+            I16(v) => (C_integral(Type::i16(ccx), v as u64, true), tcx.types.i16),\n+            I32(v) => (C_integral(Type::i32(ccx), v as u64, true), tcx.types.i32),\n+            I64(v) => (C_integral(Type::i64(ccx), v as u64, true), tcx.types.i64),\n+            I128(v) => (C_big_integral(Type::i128(ccx), v as u128), tcx.types.i128),\n+            Isize(v) => {\n+                let i = v.as_i64(ccx.tcx().sess.target.int_type);\n+                (C_integral(Type::int(ccx), i as u64, true), tcx.types.isize)\n+            },\n+            U8(v) => (C_integral(Type::i8(ccx), v as u64, false), tcx.types.u8),\n+            U16(v) => (C_integral(Type::i16(ccx), v as u64, false), tcx.types.u16),\n+            U32(v) => (C_integral(Type::i32(ccx), v as u64, false), tcx.types.u32),\n+            U64(v) => (C_integral(Type::i64(ccx), v, false), tcx.types.u64),\n+            U128(v) => (C_big_integral(Type::i128(ccx), v), tcx.types.u128),\n+            Usize(v) => {\n+                let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n+                (C_integral(Type::int(ccx), u, false), tcx.types.usize)\n+            },\n+            Infer(_) | InferSigned(_) => bug!(\"MIR must not use `{:?}`\", ci),\n+        };\n+        Const { llval: llval, ty: ty }\n+    }\n+\n     /// Translate ConstVal into a LLVM constant value.\n     pub fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n                              cv: ConstVal,\n@@ -72,26 +99,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Float(F64(v)) => C_floating_f64(v, llty),\n             ConstVal::Float(FInfer {..}) => bug!(\"MIR must not use `{:?}`\", cv),\n             ConstVal::Bool(v) => C_bool(ccx, v),\n-            ConstVal::Integral(I8(v)) => C_integral(Type::i8(ccx), v as u64, true),\n-            ConstVal::Integral(I16(v)) => C_integral(Type::i16(ccx), v as u64, true),\n-            ConstVal::Integral(I32(v)) => C_integral(Type::i32(ccx), v as u64, true),\n-            ConstVal::Integral(I64(v)) => C_integral(Type::i64(ccx), v as u64, true),\n-            ConstVal::Integral(I128(v)) => C_big_integral(Type::i128(ccx), v as u128),\n-            ConstVal::Integral(Isize(v)) => {\n-                let i = v.as_i64(ccx.tcx().sess.target.int_type);\n-                C_integral(Type::int(ccx), i as u64, true)\n-            },\n-            ConstVal::Integral(U8(v)) => C_integral(Type::i8(ccx), v as u64, false),\n-            ConstVal::Integral(U16(v)) => C_integral(Type::i16(ccx), v as u64, false),\n-            ConstVal::Integral(U32(v)) => C_integral(Type::i32(ccx), v as u64, false),\n-            ConstVal::Integral(U64(v)) => C_integral(Type::i64(ccx), v, false),\n-            ConstVal::Integral(U128(v)) => C_big_integral(Type::i128(ccx), v),\n-            ConstVal::Integral(Usize(v)) => {\n-                let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n-                C_integral(Type::int(ccx), u, false)\n-            },\n-            ConstVal::Integral(Infer(_)) |\n-            ConstVal::Integral(InferSigned(_)) => bug!(\"MIR must not use `{:?}`\", cv),\n+            ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n             ConstVal::Struct(_) | ConstVal::Tuple(_) |"}, {"sha": "c6847249803e35282b13f1147da033fa069054da", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a00a0adc7913152bff626d6dbebfa2cfdbb93d0a/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=a00a0adc7913152bff626d6dbebfa2cfdbb93d0a", "patch": "@@ -567,6 +567,34 @@ impl<T:Decodable> Decodable for Vec<T> {\n     }\n }\n \n+impl<'a, T:Encodable> Encodable for Cow<'a, [T]>\n+where [T]: ToOwned<Owned = Vec<T>>\n+{\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s))?\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<T:Decodable+ToOwned> Decodable for Cow<'static, [T]>\n+where [T]: ToOwned<Owned = Vec<T>>\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n+        d.read_seq(|d, len| {\n+            let mut v = Vec::with_capacity(len);\n+            for i in 0..len {\n+                v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            }\n+            Ok(Cow::Owned(v))\n+        })\n+    }\n+}\n+\n+\n impl<T:Encodable> Encodable for Option<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_option(|s| {"}]}