{"sha": "33a0799fa9777a4e2735faa8c4d6595db5cb6179", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYTA3OTlmYTk3NzdhNGUyNzM1ZmFhOGM0ZDY1OTVkYjVjYjYxNzk=", "commit": {"author": {"name": "Pyriphlegethon", "email": "pyriphlegethon.github@gmail.com", "date": "2015-09-30T11:08:29Z"}, "committer": {"name": "Pyriphlegethon", "email": "pyriphlegethon.github@gmail.com", "date": "2015-09-30T11:08:29Z"}, "message": "Remove unnecessary clones and add helper function", "tree": {"sha": "dad402df7c1f780c769af2e8551348fe35766ab3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dad402df7c1f780c769af2e8551348fe35766ab3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33a0799fa9777a4e2735faa8c4d6595db5cb6179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33a0799fa9777a4e2735faa8c4d6595db5cb6179", "html_url": "https://github.com/rust-lang/rust/commit/33a0799fa9777a4e2735faa8c4d6595db5cb6179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33a0799fa9777a4e2735faa8c4d6595db5cb6179/comments", "author": {"login": "Pyriphlegethon", "id": 13908830, "node_id": "MDQ6VXNlcjEzOTA4ODMw", "avatar_url": "https://avatars.githubusercontent.com/u/13908830?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pyriphlegethon", "html_url": "https://github.com/Pyriphlegethon", "followers_url": "https://api.github.com/users/Pyriphlegethon/followers", "following_url": "https://api.github.com/users/Pyriphlegethon/following{/other_user}", "gists_url": "https://api.github.com/users/Pyriphlegethon/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pyriphlegethon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pyriphlegethon/subscriptions", "organizations_url": "https://api.github.com/users/Pyriphlegethon/orgs", "repos_url": "https://api.github.com/users/Pyriphlegethon/repos", "events_url": "https://api.github.com/users/Pyriphlegethon/events{/privacy}", "received_events_url": "https://api.github.com/users/Pyriphlegethon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Pyriphlegethon", "id": 13908830, "node_id": "MDQ6VXNlcjEzOTA4ODMw", "avatar_url": "https://avatars.githubusercontent.com/u/13908830?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pyriphlegethon", "html_url": "https://github.com/Pyriphlegethon", "followers_url": "https://api.github.com/users/Pyriphlegethon/followers", "following_url": "https://api.github.com/users/Pyriphlegethon/following{/other_user}", "gists_url": "https://api.github.com/users/Pyriphlegethon/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pyriphlegethon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pyriphlegethon/subscriptions", "organizations_url": "https://api.github.com/users/Pyriphlegethon/orgs", "repos_url": "https://api.github.com/users/Pyriphlegethon/repos", "events_url": "https://api.github.com/users/Pyriphlegethon/events{/privacy}", "received_events_url": "https://api.github.com/users/Pyriphlegethon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e42f00e470b1f61b02f325f1ba0c7795c0725bfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e42f00e470b1f61b02f325f1ba0c7795c0725bfc", "html_url": "https://github.com/rust-lang/rust/commit/e42f00e470b1f61b02f325f1ba0c7795c0725bfc"}], "stats": {"total": 79, "additions": 35, "deletions": 44}, "files": [{"sha": "1cc04e096baa2c78972ae109f1d45443c07c9e9a", "filename": "src/mut_reference.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/33a0799fa9777a4e2735faa8c4d6595db5cb6179/src%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a0799fa9777a4e2735faa8c4d6595db5cb6179/src%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmut_reference.rs?ref=33a0799fa9777a4e2735faa8c4d6595db5cb6179", "patch": "@@ -1,7 +1,8 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use utils::span_lint;\n-use rustc::middle::ty::{TypeAndMut, TypeVariants, MethodCall};\n+use rustc::middle::ty::{TypeAndMut, TypeVariants, MethodCall, TyS};\n+use syntax::ptr::P;\n \n declare_lint! {\n     pub UNNECESSARY_MUT_PASSED,\n@@ -22,62 +23,52 @@ impl LintPass for UnnecessaryMutPassed {\n \n impl LateLintPass for UnnecessaryMutPassed {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+        let borrowed_table = cx.tcx.tables.borrow();\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {\n-                let borrowed_table = cx.tcx.tables.borrow();\n-                let funtion_type = match borrowed_table.node_types.get(&fn_expr.id) {\n-                    Some(funtion_type) => funtion_type,\n+                match borrowed_table.node_types.get(&fn_expr.id) {\n+                    Some(function_type) => {\n+                        if let ExprPath(_, ref path) = fn_expr.node {\n+                            check_arguments(cx, &arguments, function_type, \n+                                            &format!(\"{}\", path));\n+                        }\n+                    },\n                     None => unreachable!(), // A function with unknown type is called.\n                                             // If this happened the compiler would have aborted the\n                                             // compilation long ago.\n                 };\n-                if let TypeVariants::TyBareFn(_, ref b) = funtion_type.sty {\n-                    let parameters = b.sig.skip_binder().inputs.clone();\n-                    for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n-                        match parameter.sty {\n-                            TypeVariants::TyRef(_, TypeAndMut {ty: _, mutbl: MutImmutable}) | \n-                            TypeVariants::TyRawPtr(TypeAndMut {ty: _, mutbl: MutImmutable}) => {\n-                                if let Expr_::ExprAddrOf(MutMutable, _) = argument.node {\n-                                    if let ExprPath(_, path) = fn_expr.node.clone() {\n-                                        span_lint(cx, UNNECESSARY_MUT_PASSED, \n-                                                  argument.span, &format!(\"This argument of the \\\n-                                                  function \\\"{}\\\" doesn't need to be mutable\", path));\n-                                    }\n-                                }\n-                            },\n-                            _ => {}\n-                        }\n-                    }\n-                }\n+\n+\n             },\n             ExprMethodCall(ref name, _, ref arguments) => {\n                 let method_call = MethodCall::expr(e.id);\n-                let borrowed_table = cx.tcx.tables.borrow();\n-                let method_type = match borrowed_table.method_map.get(&method_call) {\n-                    Some(method_type) => method_type,\n+                match borrowed_table.method_map.get(&method_call) {\n+                    Some(method_type) => check_arguments(cx, &arguments, method_type.ty, \n+                                                         &format!(\"{}\", name.node.as_str())),\n                     None => unreachable!(), // Just like above, this should never happen.\n                 };\n-                if let TypeVariants::TyBareFn(_, ref b) = method_type.ty.sty {\n-                    let parameters = b.sig.skip_binder().inputs.iter().clone();\n-                    for (argument, parameter) in arguments.iter().zip(parameters).skip(1) {\n-                        // Skip the first argument and the first parameter because it is the\n-                        // struct the function is called on.\n-                        match parameter.sty {\n-                            TypeVariants::TyRef(_, TypeAndMut {ty: _, mutbl: MutImmutable}) |\n-                            TypeVariants::TyRawPtr(TypeAndMut {ty: _, mutbl: MutImmutable}) => {\n-                                if let Expr_::ExprAddrOf(MutMutable, _) = argument.node {\n-                                    span_lint(cx, UNNECESSARY_MUT_PASSED, \n-                                              argument.span, &format!(\"This argument of the \\\n-                                              method \\\"{}\\\" doesn't need to be mutable\", \n-                                              name.node.as_str()));\n-                                }\n-                            },\n-                            _ => {}\n-                        }\n-                    }\n-                }\n             },\n             _ => {}\n         }\n     }\n }\n+\n+fn check_arguments(cx: &LateContext, arguments: &[P<Expr>], type_definition: &TyS, name: &str) {\n+    if let TypeVariants::TyBareFn(_, ref fn_type) = type_definition.sty {\n+        let parameters = &fn_type.sig.skip_binder().inputs;\n+        for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n+            match parameter.sty {\n+                TypeVariants::TyRef(_, TypeAndMut {ty: _, mutbl: MutImmutable}) |\n+                TypeVariants::TyRawPtr(TypeAndMut {ty: _, mutbl: MutImmutable}) => {\n+                    if let Expr_::ExprAddrOf(MutMutable, _) = argument.node {\n+                        span_lint(cx, UNNECESSARY_MUT_PASSED, \n+                                  argument.span, &format!(\"The function/method \\\"{}\\\" \\\n+                                  doesn't need a mutable reference\", \n+                                  name));\n+                    }\n+                },\n+                _ => {}\n+            }\n+        }\n+    }\n+}"}]}