{"sha": "6c72c5fa883cc8d33cee90b14fda506eb91d846e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNzJjNWZhODgzY2M4ZDMzY2VlOTBiMTRmZGE1MDZlYjkxZDg0NmU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-02T11:28:13Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-16T08:00:35Z"}, "message": "`borrowck::mir::gather_moves`: create MovePaths for lvalues even if unreferenced.\n\nincludes misc bug fixes and removal of useless code.", "tree": {"sha": "2a3923b295a0d55f1cc72a86db8cb9c001624cd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a3923b295a0d55f1cc72a86db8cb9c001624cd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c72c5fa883cc8d33cee90b14fda506eb91d846e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c72c5fa883cc8d33cee90b14fda506eb91d846e", "html_url": "https://github.com/rust-lang/rust/commit/6c72c5fa883cc8d33cee90b14fda506eb91d846e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c72c5fa883cc8d33cee90b14fda506eb91d846e/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d03b341e6b9f2c1e665031f510e6129349ecae21", "url": "https://api.github.com/repos/rust-lang/rust/commits/d03b341e6b9f2c1e665031f510e6129349ecae21", "html_url": "https://github.com/rust-lang/rust/commit/d03b341e6b9f2c1e665031f510e6129349ecae21"}], "stats": {"total": 106, "additions": 74, "deletions": 32}, "files": [{"sha": "64a7dddc8aba2e6d9c524e12a1b190cfb8c6c60a", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 74, "deletions": 32, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/6c72c5fa883cc8d33cee90b14fda506eb91d846e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c72c5fa883cc8d33cee90b14fda506eb91d846e/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=6c72c5fa883cc8d33cee90b14fda506eb91d846e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{FnOutput, TyCtxt};\n use rustc::mir::repr::*;\n use rustc::util::nodemap::FnvHashMap;\n \n@@ -419,6 +419,11 @@ impl<'a, 'tcx> MovePathDataBuilder<'a, 'tcx> {\n         self.rev_lookup.lookup_proj(proj, base_index)\n     }\n \n+    fn create_move_path(&mut self, lval: &Lvalue<'tcx>) {\n+        // Create MovePath for `lval`, discarding returned index.\n+        self.move_path_for(lval);\n+    }\n+\n     fn move_path_for(&mut self, lval: &Lvalue<'tcx>) -> MovePathIndex {\n         let lookup: Lookup<MovePathIndex> = self.lookup(lval);\n \n@@ -491,7 +496,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n #[derive(Debug)]\n enum StmtKind {\n     Use, Repeat, Cast, BinaryOp, UnaryOp, Box,\n-    Aggregate, Drop, CallFn, CallArg, Return,\n+    Aggregate, Drop, CallFn, CallArg, Return, If,\n }\n \n fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveData<'tcx> {\n@@ -511,6 +516,27 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n         rev_lookup: MovePathLookup::new(),\n     };\n \n+    // Before we analyze the program text, we create the MovePath's\n+    // for all of the vars, args, and temps. (This enforces a basic\n+    // property that even if the MIR body doesn't contain any\n+    // references to a var/arg/temp, it will still be a valid\n+    // operation to lookup the MovePath associated with it.)\n+    assert!(mir.var_decls.len() <= ::std::u32::MAX as usize);\n+    assert!(mir.arg_decls.len() <= ::std::u32::MAX as usize);\n+    assert!(mir.temp_decls.len() <= ::std::u32::MAX as usize);\n+    for var_idx in 0..mir.var_decls.len() {\n+        let path_idx = builder.move_path_for(&Lvalue::Var(var_idx as u32));\n+        path_map.fill_to(path_idx.idx());\n+    }\n+    for arg_idx in 0..mir.arg_decls.len() {\n+        let path_idx = builder.move_path_for(&Lvalue::Arg(arg_idx as u32));\n+        path_map.fill_to(path_idx.idx());\n+    }\n+    for temp_idx in 0..mir.temp_decls.len() {\n+        let path_idx = builder.move_path_for(&Lvalue::Temp(temp_idx as u32));\n+        path_map.fill_to(path_idx.idx());\n+    }\n+\n     for bb in bbs {\n         let loc_map_bb = &mut loc_map[bb.index()];\n         let bb_data = mir.basic_block_data(bb);\n@@ -532,8 +558,12 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             let source = Location { block: bb, index: i };\n             match stmt.kind {\n                 StatementKind::Assign(ref lval, ref rval) => {\n-                    // ensure MovePath created for `lval`.\n-                    bb_ctxt.builder.move_path_for(lval);\n+                    bb_ctxt.builder.create_move_path(lval);\n+\n+                    // Ensure that the path_map contains entries even\n+                    // if the lvalue is assigned and never read.\n+                    let assigned_path = bb_ctxt.builder.move_path_for(lval);\n+                    bb_ctxt.path_map.fill_to(assigned_path.idx());\n \n                     match *rval {\n                         Rvalue::Use(ref operand) => {\n@@ -569,7 +599,26 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                         Rvalue::InlineAsm { .. } => {}\n \n                         Rvalue::Slice {..} => {\n-                            bug!(\"cannot move out of slice\");\n+                            // A slice pattern `x..` binds `x` to a\n+                            // reference; thus no move occurs.\n+                            //\n+                            // FIXME: I recall arielb1 questioning\n+                            // whether this is even a legal thing to\n+                            // have as an R-value. The particular\n+                            // example where I am seeing this arise is\n+                            // `TargetDataLayout::parse(&Session)` in\n+                            // `rustc::ty::layout`.\n+                            debug!(\"encountered Rvalue::Slice as RHS of Assign, source: {:?} \\n{}\",\n+                                   source, {\n+                                       let mut out = Vec::new();\n+                                       {\n+                                           use std::io::Write;\n+                                           use rustc_mir::pretty::write_mir_named;\n+                                           let mut w: &mut Write = &mut out;\n+                                           write_mir_named(tcx, \"boo_attempt_move_out_of_slice\", mir, &mut w, None).unwrap();\n+                                       }\n+                                       String::from_utf8(out).unwrap()\n+                                   });\n                         }\n                     }\n                 }\n@@ -582,14 +631,19 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             TerminatorKind::Return => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n-                let lval = &Lvalue::ReturnPointer.deref();\n-                bb_ctxt.on_move_out_lval(SK::Return, lval, source);\n+                if let FnOutput::FnConverging(_) = bb_ctxt.builder.mir.return_ty {\n+                    debug!(\"gather_moves Return on_move_out_lval return {:?}\", source);\n+                    bb_ctxt.on_move_out_lval(SK::Return, &Lvalue::ReturnPointer, source);\n+                } else {\n+                    debug!(\"gather_moves Return on_move_out_lval assuming unreachable return {:?}\", source);\n+                }\n             }\n \n             TerminatorKind::If { ref cond, targets: _ } => {\n-                // The `cond` is always of (copyable) type `bool`,\n-                // so there will never be anything to move.\n-                let _ = cond;\n+                let source = Location { block: bb,\n+                                        index: bb_data.statements.len() };\n+                debug!(\"gather_moves If on_operand {:?} {:?}\", cond, source);\n+                bb_ctxt.on_operand(SK::If, cond, source);\n             }\n \n             TerminatorKind::SwitchInt { switch_ty: _, values: _, targets: _, ref discr } |\n@@ -604,6 +658,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n             TerminatorKind::Drop { value: ref lval, target: _, unwind: _ } => {\n                 let source = Location { block: bb,\n                                         index: bb_data.statements.len() };\n+                debug!(\"gather_moves Drop on_move_out_lval {:?} {:?}\", lval, source);\n                 bb_ctxt.on_move_out_lval(SK::Drop, lval, source);\n             }\n \n@@ -612,12 +667,18 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n                                         index: bb_data.statements.len() };\n                 bb_ctxt.on_operand(SK::CallFn, func, source);\n                 for arg in args {\n+                    debug!(\"gather_moves Call on_operand {:?} {:?}\", arg, source);\n                     bb_ctxt.on_operand(SK::CallArg, arg, source);\n                 }\n                 if let Some((ref destination, _bb)) = *destination {\n-                    // Create MovePath for `destination`, then\n-                    // discard returned index.\n-                    bb_ctxt.builder.move_path_for(destination);\n+                    debug!(\"gather_moves Call create_move_path {:?} {:?}\", destination, source);\n+\n+                    // Ensure that the path_map contains entries even\n+                    // if the lvalue is assigned and never read.\n+                    let assigned_path = bb_ctxt.builder.move_path_for(destination);\n+                    bb_ctxt.path_map.fill_to(assigned_path.idx());\n+\n+                    bb_ctxt.builder.create_move_path(destination);\n                 }\n             }\n         }\n@@ -635,7 +696,6 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n     //\n     // well you know, lets actually try just asserting that the path map *is* complete.\n     assert_eq!(path_map.len(), builder.pre_move_paths.len());\n-    path_map.fill_to(builder.pre_move_paths.len() - 1);\n \n     let pre_move_paths = builder.pre_move_paths;\n     let move_paths: Vec<_> = pre_move_paths.into_iter()\n@@ -680,24 +740,6 @@ impl<'b, 'a: 'b, 'tcx: 'a> BlockContext<'b, 'a, 'tcx> {\n                         lval: &Lvalue<'tcx>,\n                         source: Location) {\n         let tcx = self.tcx;\n-        let lval_ty = self.builder.mir.lvalue_ty(tcx, lval);\n-\n-        // FIXME: does lvalue_ty ever return TyError, or is it\n-        // guaranteed to always return non-Infer/non-Error values?\n-\n-        // This code is just trying to avoid creating a MoveOut\n-        // entry for values that do not need move semantics.\n-        //\n-        // type_contents is imprecise (may claim needs drop for\n-        // types that in fact have no destructor). But that is\n-        // still usable for our purposes here.\n-        let consumed = lval_ty.to_ty(tcx).type_contents(tcx).needs_drop(tcx);\n-\n-        if !consumed {\n-            debug!(\"ctxt: {:?} no consume of lval: {:?} of type {:?}\",\n-                   stmt_kind, lval, lval_ty);\n-            return;\n-        }\n         let i = source.index;\n         let index = MoveOutIndex::new(self.moves.len());\n "}]}