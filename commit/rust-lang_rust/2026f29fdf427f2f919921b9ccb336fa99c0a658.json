{"sha": "2026f29fdf427f2f919921b9ccb336fa99c0a658", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMjZmMjlmZGY0MjdmMmY5MTk5MjFiOWNjYjMzNmZhOTljMGE2NTg=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-05-12T05:27:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-12T05:27:03Z"}, "message": "Merge pull request #1749 from Manishearth/cmp_owned\n\nImprove cmp_owned and stop suggestiong `self == other` inside a `PartialEq` impl", "tree": {"sha": "fbe329cbfebd09a1d700e75f464da021afffef05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbe329cbfebd09a1d700e75f464da021afffef05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2026f29fdf427f2f919921b9ccb336fa99c0a658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2026f29fdf427f2f919921b9ccb336fa99c0a658", "html_url": "https://github.com/rust-lang/rust/commit/2026f29fdf427f2f919921b9ccb336fa99c0a658", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2026f29fdf427f2f919921b9ccb336fa99c0a658/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8300f0c080608b2f36bdec15ac7361691360401d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8300f0c080608b2f36bdec15ac7361691360401d", "html_url": "https://github.com/rust-lang/rust/commit/8300f0c080608b2f36bdec15ac7361691360401d"}, {"sha": "672045689e18bc15ae76bacc70540c0b4fe769b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/672045689e18bc15ae76bacc70540c0b4fe769b9", "html_url": "https://github.com/rust-lang/rust/commit/672045689e18bc15ae76bacc70540c0b4fe769b9"}], "stats": {"total": 151, "additions": 100, "deletions": 51}, "files": [{"sha": "dbadce6193cd1cf596f5611f0c8c88d949de16c6", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/2026f29fdf427f2f919921b9ccb336fa99c0a658/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2026f29fdf427f2f919921b9ccb336fa99c0a658/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=2026f29fdf427f2f919921b9ccb336fa99c0a658", "patch": "@@ -6,11 +6,12 @@ use rustc::middle::const_val::ConstVal;\n use rustc::ty;\n use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstFloat;\n-use syntax::codemap::{Span, Spanned, ExpnFormat};\n+use syntax::codemap::{Span, ExpnFormat};\n use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path, snippet,\n-            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment, iter_input_pats, in_constant};\n+            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment, iter_input_pats, in_constant,\n+            match_trait_method, paths};\n use utils::sugg::Sugg;\n-use syntax::ast::LitKind;\n+use syntax::ast::{LitKind, CRATE_NODE_ID};\n \n /// **What it does:** Checks for function arguments and let bindings denoted as `ref`.\n ///\n@@ -297,8 +298,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n                         check_nan(cx, path, expr);\n                     }\n-                    check_to_owned(cx, left, right, true, cmp.span);\n-                    check_to_owned(cx, right, left, false, cmp.span)\n+                    check_to_owned(cx, left, right);\n+                    check_to_owned(cx, right, left);\n                 }\n                 if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n                     if is_allowed(cx, left) || is_allowed(cx, right) {\n@@ -422,20 +423,19 @@ fn is_float(cx: &LateContext, expr: &Expr) -> bool {\n     matches!(walk_ptrs_ty(cx.tables.expr_ty(expr)).sty, ty::TyFloat(_))\n }\n \n-fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: Span) {\n+fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr) {\n     let (arg_ty, snip) = match expr.node {\n-        ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) if args.len() == 1 => {\n-            let name = name.as_str();\n-            if name == \"to_string\" || name == \"to_owned\" && is_str_arg(cx, args) {\n-                (cx.tables.expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n+        ExprMethodCall(.., ref args) if args.len() == 1 => {\n+            if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n+                (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprCall(ref path, ref v) if v.len() == 1 => {\n             if let ExprPath(ref path) = path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) || match_path(path, &[\"String\", \"from\"]) {\n-                    (cx.tables.expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.tables.expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -446,40 +446,43 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n         _ => return,\n     };\n \n-    let other_ty = cx.tables.expr_ty(other);\n+    let other_ty = cx.tables.expr_ty_adjusted(other);\n     let partial_eq_trait_id = match cx.tcx.lang_items.eq_trait() {\n         Some(id) => id,\n         None => return,\n     };\n \n-    if !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty], None) {\n+    // *arg impls PartialEq<other>\n+    if !arg_ty\n+        .builtin_deref(true, ty::LvaluePreference::NoPreference)\n+        .map_or(false, |tam| implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty], None))\n+        // arg impls PartialEq<*other>\n+        && !other_ty\n+        .builtin_deref(true, ty::LvaluePreference::NoPreference)\n+        .map_or(false, |tam| implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty], None))\n+        // arg impls PartialEq<other>\n+        && !implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty], None) {\n         return;\n     }\n \n-    if left {\n-        span_lint(cx,\n-                  CMP_OWNED,\n-                  expr.span,\n-                  &format!(\"this creates an owned instance just for comparison. Consider using `{} {} {}` to \\\n-                            compare without allocation\",\n-                           snip,\n-                           snippet(cx, op, \"==\"),\n-                           snippet(cx, other.span, \"..\")));\n-    } else {\n-        span_lint(cx,\n-                  CMP_OWNED,\n-                  expr.span,\n-                  &format!(\"this creates an owned instance just for comparison. Consider using `{} {} {}` to \\\n-                            compare without allocation\",\n-                           snippet(cx, other.span, \"..\"),\n-                           snippet(cx, op, \"==\"),\n-                           snip));\n-    }\n-\n-}\n-\n-fn is_str_arg(cx: &LateContext, args: &[Expr]) -> bool {\n-    args.len() == 1 && matches!(walk_ptrs_ty(cx.tables.expr_ty(&args[0])).sty, ty::TyStr)\n+    span_lint_and_then(cx, CMP_OWNED, expr.span, \"this creates an owned instance just for comparison\", |db| {\n+        // this is as good as our recursion check can get, we can't prove that the current function is called by\n+        // PartialEq::eq, but we can at least ensure that this code is not part of it\n+        let parent_fn = cx.tcx.hir.get_parent(expr.id);\n+        let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n+        if parent_impl != CRATE_NODE_ID {\n+            if let map::NodeItem(item) = cx.tcx.hir.get(parent_impl) {\n+                if let ItemImpl(.., Some(ref trait_ref), _, _) = item.node {\n+                    if trait_ref.path.def.def_id() == partial_eq_trait_id {\n+                        // we are implementing PartialEq, don't suggest not doing `to_owned`, otherwise we go into recursion\n+                        db.span_label(expr.span, \"try calling implementing the comparison without allocating\");\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+        db.span_suggestion(expr.span, \"try\", snip.to_string());\n+    });\n }\n \n /// Heuristic to see if an expression is used. Should be compatible with `unused_variables`'s idea"}, {"sha": "f7e0d0c6aae89377bc68dc06bf9f71383ab91265", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2026f29fdf427f2f919921b9ccb336fa99c0a658/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2026f29fdf427f2f919921b9ccb336fa99c0a658/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=2026f29fdf427f2f919921b9ccb336fa99c0a658", "patch": "@@ -71,6 +71,8 @@ pub const RESULT_OK: [&'static str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n pub const SERDE_DE_VISITOR: [&'static str; 3] = [\"serde\", \"de\", \"Visitor\"];\n pub const SLICE_INTO_VEC: [&'static str; 4] = [\"collections\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const TO_OWNED: [&'static str; 3] = [\"collections\", \"borrow\", \"ToOwned\"];\n+pub const TO_STRING: [&'static str; 3] = [\"collections\", \"string\", \"ToString\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n pub const VEC_DEQUE: [&'static str; 3] = [\"collections\", \"vec_deque\", \"VecDeque\"];"}, {"sha": "e586b164cc659b5913c3800624eb3ec8328a22f6", "filename": "tests/ui/cmp_owned.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2026f29fdf427f2f919921b9ccb336fa99c0a658/tests%2Fui%2Fcmp_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2026f29fdf427f2f919921b9ccb336fa99c0a658/tests%2Fui%2Fcmp_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned.rs?ref=2026f29fdf427f2f919921b9ccb336fa99c0a658", "patch": "@@ -16,10 +16,40 @@ fn main() {\n \n     x != \"foo\".to_owned();\n \n-    // removed String::from_str(..), as it has finally been removed in 1.4.0\n-    // as of 2015-08-14\n-\n     x != String::from(\"foo\");\n \n     42.to_string() == \"42\";\n+\n+    Foo.to_owned() == Foo;\n+}\n+\n+struct Foo;\n+\n+impl PartialEq for Foo {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.to_owned() == *other\n+    }\n+}\n+\n+impl ToOwned for Foo {\n+    type Owned = Bar;\n+    fn to_owned(&self) -> Bar {\n+        Bar\n+    }\n+}\n+\n+#[derive(PartialEq)]\n+struct Bar;\n+\n+impl PartialEq<Foo> for Bar {\n+    fn eq(&self, _: &Foo) -> bool {\n+        true\n+    }\n+}\n+\n+impl std::borrow::Borrow<Foo> for Bar {\n+    fn borrow(&self) -> &Foo {\n+        static FOO: Foo = Foo;\n+        &FOO\n+    }\n }"}, {"sha": "14cad03a0f25a26a83e3ae20c65f10895450ea59", "filename": "tests/ui/cmp_owned.stderr", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2026f29fdf427f2f919921b9ccb336fa99c0a658/tests%2Fui%2Fcmp_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2026f29fdf427f2f919921b9ccb336fa99c0a658/tests%2Fui%2Fcmp_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcmp_owned.stderr?ref=2026f29fdf427f2f919921b9ccb336fa99c0a658", "patch": "@@ -1,32 +1,46 @@\n-error: this creates an owned instance just for comparison. Consider using `x != \"foo\"` to compare without allocation\n+error: this creates an owned instance just for comparison\n  --> $DIR/cmp_owned.rs:8:14\n   |\n 8 |         x != \"foo\".to_string();\n-  |              ^^^^^^^^^^^^^^^^^\n+  |              ^^^^^^^^^^^^^^^^^ help: try `\"foo\"`\n   |\n note: lint level defined here\n  --> $DIR/cmp_owned.rs:4:8\n   |\n 4 | #[deny(cmp_owned)]\n   |        ^^^^^^^^^\n \n-error: this creates an owned instance just for comparison. Consider using `\"foo\" != x` to compare without allocation\n+error: this creates an owned instance just for comparison\n   --> $DIR/cmp_owned.rs:10:9\n    |\n 10 |         \"foo\".to_string() != x;\n-   |         ^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^ help: try `\"foo\"`\n \n-error: this creates an owned instance just for comparison. Consider using `x != \"foo\"` to compare without allocation\n+error: this creates an owned instance just for comparison\n   --> $DIR/cmp_owned.rs:17:10\n    |\n 17 |     x != \"foo\".to_owned();\n-   |          ^^^^^^^^^^^^^^^^\n+   |          ^^^^^^^^^^^^^^^^ help: try `\"foo\"`\n \n-error: this creates an owned instance just for comparison. Consider using `x != \"foo\"` to compare without allocation\n-  --> $DIR/cmp_owned.rs:22:10\n+error: this creates an owned instance just for comparison\n+  --> $DIR/cmp_owned.rs:19:10\n    |\n-22 |     x != String::from(\"foo\");\n-   |          ^^^^^^^^^^^^^^^^^^^\n+19 |     x != String::from(\"foo\");\n+   |          ^^^^^^^^^^^^^^^^^^^ help: try `\"foo\"`\n \n-error: aborting due to 4 previous errors\n+error: this creates an owned instance just for comparison\n+  --> $DIR/cmp_owned.rs:23:5\n+   |\n+23 |     Foo.to_owned() == Foo;\n+   |     ^^^^^^^^^^^^^^ help: try `Foo`\n+\n+warning: this creates an owned instance just for comparison\n+  --> $DIR/cmp_owned.rs:30:9\n+   |\n+30 |         self.to_owned() == *other\n+   |         ^^^^^^^^^^^^^^^ try calling implementing the comparison without allocating\n+   |\n+   = note: #[warn(cmp_owned)] on by default\n+\n+error: aborting due to 5 previous errors\n "}]}