{"sha": "f51f25ab7de7c737ab67d79e23691b8f8f642a8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1MWYyNWFiN2RlN2M3MzdhYjY3ZDc5ZTIzNjkxYjhmOGY2NDJhOGM=", "commit": {"author": {"name": "K", "email": "kwj2104@columbia.edu", "date": "2021-04-07T16:35:39Z"}, "committer": {"name": "K", "email": "kwj2104@columbia.edu", "date": "2021-04-07T16:35:39Z"}, "message": "Added additional comments and minor edits", "tree": {"sha": "2095894e72efc4a8f30b92af4c65d4f8b6beb749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2095894e72efc4a8f30b92af4c65d4f8b6beb749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f51f25ab7de7c737ab67d79e23691b8f8f642a8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f51f25ab7de7c737ab67d79e23691b8f8f642a8c", "html_url": "https://github.com/rust-lang/rust/commit/f51f25ab7de7c737ab67d79e23691b8f8f642a8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f51f25ab7de7c737ab67d79e23691b8f8f642a8c/comments", "author": {"login": "kwj2104", "id": 742632, "node_id": "MDQ6VXNlcjc0MjYzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/742632?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kwj2104", "html_url": "https://github.com/kwj2104", "followers_url": "https://api.github.com/users/kwj2104/followers", "following_url": "https://api.github.com/users/kwj2104/following{/other_user}", "gists_url": "https://api.github.com/users/kwj2104/gists{/gist_id}", "starred_url": "https://api.github.com/users/kwj2104/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kwj2104/subscriptions", "organizations_url": "https://api.github.com/users/kwj2104/orgs", "repos_url": "https://api.github.com/users/kwj2104/repos", "events_url": "https://api.github.com/users/kwj2104/events{/privacy}", "received_events_url": "https://api.github.com/users/kwj2104/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kwj2104", "id": 742632, "node_id": "MDQ6VXNlcjc0MjYzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/742632?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kwj2104", "html_url": "https://github.com/kwj2104", "followers_url": "https://api.github.com/users/kwj2104/followers", "following_url": "https://api.github.com/users/kwj2104/following{/other_user}", "gists_url": "https://api.github.com/users/kwj2104/gists{/gist_id}", "starred_url": "https://api.github.com/users/kwj2104/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kwj2104/subscriptions", "organizations_url": "https://api.github.com/users/kwj2104/orgs", "repos_url": "https://api.github.com/users/kwj2104/repos", "events_url": "https://api.github.com/users/kwj2104/events{/privacy}", "received_events_url": "https://api.github.com/users/kwj2104/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e433f5585296ba8892893e4c78f51d2d42ac7ea4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e433f5585296ba8892893e4c78f51d2d42ac7ea4", "html_url": "https://github.com/rust-lang/rust/commit/e433f5585296ba8892893e4c78f51d2d42ac7ea4"}], "stats": {"total": 110, "additions": 64, "deletions": 46}, "files": [{"sha": "9321f11f6593380f749d79476205eca86929f173", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f51f25ab7de7c737ab67d79e23691b8f8f642a8c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51f25ab7de7c737ab67d79e23691b8f8f642a8c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=f51f25ab7de7c737ab67d79e23691b8f8f642a8c", "patch": "@@ -1596,7 +1596,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n                         .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n-                    self.r.record_local_span(pat.id, pat.span);\n+                    self.r.record_pat_span(pat.id, pat.span);\n                 }\n                 PatKind::TupleStruct(ref path, ref sub_patterns) => {\n                     self.smart_resolve_path("}, {"sha": "665c32ddf069c0da38a4840564800a767a176325", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 61, "deletions": 43, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/f51f25ab7de7c737ab67d79e23691b8f8f642a8c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f51f25ab7de7c737ab67d79e23691b8f8f642a8c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=f51f25ab7de7c737ab67d79e23691b8f8f642a8c", "patch": "@@ -884,9 +884,9 @@ pub struct Resolver<'a> {\n     /// \"self-confirming\" import resolutions during import validation.\n     unusable_binding: Option<&'a NameBinding<'a>>,\n \n-    // Spans for local variables found during resolution\n-    // Used for suggestions during error reporting\n-    local_span_map: NodeMap<Span>,\n+    // Spans for local variables found during pattern resolution.\n+    // Used for suggestions during error reporting.\n+    pat_span_map: NodeMap<Span>,\n \n     /// Resolutions for nodes that have a single resolution.\n     partial_res_map: NodeMap<PartialRes>,\n@@ -1266,7 +1266,7 @@ impl<'a> Resolver<'a> {\n             last_import_segment: false,\n             unusable_binding: None,\n \n-            local_span_map: Default::default(),\n+            pat_span_map: Default::default(),\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n@@ -1884,6 +1884,7 @@ impl<'a> Resolver<'a> {\n                     ribs,\n                 )));\n             }\n+\n             module = match ribs[i].kind {\n                 ModuleRibKind(module) => module,\n                 MacroDefinition(def) if def == self.macro_def(ident.span.ctxt()) => {\n@@ -1894,6 +1895,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 _ => continue,\n             };\n+\n             match module.kind {\n                 ModuleKind::Block(..) => {} // We can see through blocks\n                 _ => break,\n@@ -1912,19 +1914,16 @@ impl<'a> Resolver<'a> {\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n         }\n-        let returned_item = self\n-            .early_resolve_ident_in_lexical_scope(\n-                orig_ident,\n-                ScopeSet::Late(ns, module, record_used_id),\n-                parent_scope,\n-                record_used,\n-                record_used,\n-                path_span,\n-            )\n-            .ok()\n-            .map(LexicalScopeBinding::Item);\n-\n-        returned_item\n+        self.early_resolve_ident_in_lexical_scope(\n+            orig_ident,\n+            ScopeSet::Late(ns, module, record_used_id),\n+            parent_scope,\n+            record_used,\n+            record_used,\n+            path_span,\n+        )\n+        .ok()\n+        .map(LexicalScopeBinding::Item)\n     }\n \n     fn hygienic_lexical_parent(\n@@ -2391,38 +2390,57 @@ impl<'a> Resolver<'a> {\n                             .next()\n                             .map_or(false, |c| c.is_ascii_uppercase())\n                         {\n-                            // Add check case for similarly named item in alternative namespace\n-                            let mut suggestion = None;\n-\n-                            if ribs.is_some() {\n-                                if let Some(res) = self.resolve_ident_in_lexical_scope(\n+                            // Check whether the name refers to an item in the value namespace.\n+                            let suggestion = if ribs.is_some() {\n+                                let match_span = match self.resolve_ident_in_lexical_scope(\n                                     ident,\n                                     ValueNS,\n                                     parent_scope,\n                                     None,\n                                     path_span,\n                                     &ribs.unwrap()[ValueNS],\n                                 ) {\n-                                    let mut match_span: Option<Span> = None;\n-                                    match res {\n-                                        LexicalScopeBinding::Res(Res::Local(id)) => {\n-                                            match_span =\n-                                                Some(*self.local_span_map.get(&id).unwrap());\n-                                        }\n-                                        LexicalScopeBinding::Item(name_binding) => {\n-                                            match_span = Some(name_binding.span);\n-                                        }\n-                                        _ => (),\n-                                    };\n-                                    if let Some(span) = match_span {\n-                                        suggestion = Some((\n-                                            vec![(span, String::from(\"\"))],\n-                                            format!(\"{} is defined here, but is not a type\", ident),\n-                                            Applicability::MaybeIncorrect,\n-                                        ));\n+                                    // Name matches a local variable. For example:\n+                                    // ```\n+                                    // fn f() {\n+                                    //     let Foo: &str = \"\";\n+                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                    //                               // variable `Foo`.\n+                                    // }\n+                                    // ```\n+                                    Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n+                                        Some(*self.pat_span_map.get(&id).unwrap())\n                                     }\n+\n+                                    // Name matches item from a local name binding\n+                                    // created by `use` declaration. For example:\n+                                    // ```\n+                                    // pub Foo: &str = \"\";\n+                                    //\n+                                    // mod submod {\n+                                    //     use super::Foo;\n+                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                    //                               // binding `Foo`.\n+                                    // }\n+                                    // ```\n+                                    Some(LexicalScopeBinding::Item(name_binding)) => {\n+                                        Some(name_binding.span)\n+                                    }\n+                                    _ => None,\n+                                };\n+\n+                                if let Some(span) = match_span {\n+                                    Some((\n+                                        vec![(span, String::from(\"\"))],\n+                                        format!(\"`{}` is defined here, but is not a type\", ident),\n+                                        Applicability::MaybeIncorrect,\n+                                    ))\n+                                } else {\n+                                    None\n                                 }\n-                            }\n+                            } else {\n+                                None\n+                            };\n \n                             (format!(\"use of undeclared type `{}`\", ident), suggestion)\n                         } else {\n@@ -2835,9 +2853,9 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn record_local_span(&mut self, node: NodeId, span: Span) {\n-        debug!(\"(recording local) recording {:?} for {:?}\", node, span);\n-        self.local_span_map.insert(node, span);\n+    fn record_pat_span(&mut self, node: NodeId, span: Span) {\n+        debug!(\"(recording pat) recording {:?} for {:?}\", node, span);\n+        self.pat_span_map.insert(node, span);\n     }\n \n     fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {"}, {"sha": "15555631b90474887cdb356f8a4158e1d03ad044", "filename": "src/test/ui/resolve/issue-81508.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f51f25ab7de7c737ab67d79e23691b8f8f642a8c/src%2Ftest%2Fui%2Fresolve%2Fissue-81508.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f51f25ab7de7c737ab67d79e23691b8f8f642a8c/src%2Ftest%2Fui%2Fresolve%2Fissue-81508.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-81508.stderr?ref=f51f25ab7de7c737ab67d79e23691b8f8f642a8c", "patch": "@@ -2,7 +2,7 @@ error[E0433]: failed to resolve: use of undeclared type `Baz`\n   --> $DIR/issue-81508.rs:11:20\n    |\n LL |     let Baz: &str = \"\";\n-   |         --- help: Baz is defined here, but is not a type\n+   |         --- help: `Baz` is defined here, but is not a type\n LL | \n LL |     println!(\"{}\", Baz::Bar);\n    |                    ^^^ use of undeclared type `Baz`\n@@ -11,7 +11,7 @@ error[E0433]: failed to resolve: use of undeclared type `Foo`\n   --> $DIR/issue-81508.rs:20:24\n    |\n LL |     use super::Foo;\n-   |         ---------- help: Foo is defined here, but is not a type\n+   |         ---------- help: `Foo` is defined here, but is not a type\n LL |     fn function() {\n LL |         println!(\"{}\", Foo::Bar);\n    |                        ^^^ use of undeclared type `Foo`"}]}