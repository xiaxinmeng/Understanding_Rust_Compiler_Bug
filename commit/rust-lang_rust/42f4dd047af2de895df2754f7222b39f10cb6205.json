{"sha": "42f4dd047af2de895df2754f7222b39f10cb6205", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyZjRkZDA0N2FmMmRlODk1ZGYyNzU0ZjcyMjJiMzlmMTBjYjYyMDU=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2016-01-13T17:08:08Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2016-01-13T17:08:08Z"}, "message": "Implement RFC 1252 expanding the OpenOptions structure\nTracking issue: #30014\n\nThis implements the RFC and makes a few other changes.\nI have added a few extra tests, and made the Windows and\nUnix code as similar as possible.\n\nPart of the RFC mentions the unstable OpenOptionsExt trait\non Windows (see #27720). I have added a few extra methods\nto future-proof it for CreateFile2.", "tree": {"sha": "0b3b2aee6a1ff9ab0031410a510c02c5027a9f6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b3b2aee6a1ff9ab0031410a510c02c5027a9f6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/42f4dd047af2de895df2754f7222b39f10cb6205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/42f4dd047af2de895df2754f7222b39f10cb6205", "html_url": "https://github.com/rust-lang/rust/commit/42f4dd047af2de895df2754f7222b39f10cb6205", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/42f4dd047af2de895df2754f7222b39f10cb6205/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1bcfdd8e48ce9ca322e800a3641c65a9b1c1a5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1bcfdd8e48ce9ca322e800a3641c65a9b1c1a5d", "html_url": "https://github.com/rust-lang/rust/commit/f1bcfdd8e48ce9ca322e800a3641c65a9b1c1a5d"}], "stats": {"total": 614, "additions": 437, "deletions": 177}, "files": [{"sha": "7b2555ff1f5ef3a7a68b70327674b4d790d0cdf2", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 179, "deletions": 47, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=42f4dd047af2de895df2754f7222b39f10cb6205", "patch": "@@ -375,7 +375,7 @@ impl<'a> Seek for &'a File {\n }\n \n impl OpenOptions {\n-    /// Creates a blank net set of options ready for configuration.\n+    /// Creates a blank new set of options ready for configuration.\n     ///\n     /// All options are initially set to `false`.\n     ///\n@@ -384,7 +384,8 @@ impl OpenOptions {\n     /// ```no_run\n     /// use std::fs::OpenOptions;\n     ///\n-    /// let file = OpenOptions::new().open(\"foo.txt\");\n+    /// let mut options = OpenOptions::new();\n+    /// let file = options.read(true).open(\"foo.txt\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> OpenOptions {\n@@ -413,6 +414,9 @@ impl OpenOptions {\n     /// This option, when true, will indicate that the file should be\n     /// `write`-able if opened.\n     ///\n+    /// If a file already exist, the contents of that file get overwritten, but it is\n+    /// not truncated.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -429,13 +433,29 @@ impl OpenOptions {\n     ///\n     /// This option, when true, means that writes will append to a file instead\n     /// of overwriting previous contents.\n+    /// Note that setting `.write(true).append(true)` has the same effect as\n+    /// setting only `.append(true)`.\n+    ///\n+    /// For most filesystems the operating system guarantees all writes are atomic:\n+    /// no writes get mangled because another process writes at the same time.\n+    ///\n+    /// One maybe obvious note when using append-mode: make sure that all data that\n+    /// belongs together, is written the the file in one operation. This can be done\n+    /// by concatenating strings before passing them to `write()`, or using a buffered\n+    /// writer (with a more than adequately sized buffer) and calling `flush()` when the\n+    /// message is complete.\n+    ///\n+    /// If a file is opened with both read and append access, beware that after opening\n+    /// and after every write the position for reading may be set at the end of the file.\n+    /// So before writing save the current position (using `seek(SeekFrom::Current(0))`,\n+    /// and restore it before the next read.\n     ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::fs::OpenOptions;\n     ///\n-    /// let file = OpenOptions::new().write(true).append(true).open(\"foo.txt\");\n+    /// let file = OpenOptions::new().append(true).open(\"foo.txt\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, append: bool) -> &mut OpenOptions {\n@@ -447,6 +467,8 @@ impl OpenOptions {\n     /// If a file is successfully opened with this option set it will truncate\n     /// the file to 0 length if it already exists.\n     ///\n+    /// The file must be opened with write access for truncate to work.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -464,29 +486,92 @@ impl OpenOptions {\n     /// This option indicates whether a new file will be created if the file\n     /// does not yet already exist.\n     ///\n+    /// The file must be opened with write or append access in order to create\n+    /// a new file.\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n     /// use std::fs::OpenOptions;\n     ///\n-    /// let file = OpenOptions::new().create(true).open(\"foo.txt\");\n+    /// let file = OpenOptions::new().write(true).create(true).open(\"foo.txt\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn create(&mut self, create: bool) -> &mut OpenOptions {\n         self.0.create(create); self\n     }\n \n+    /// Sets the option to always create a new file.\n+    ///\n+    /// This option indicates whether a new file will be created.\n+    /// No file is allowed to exist at the target location, also no (dangling)\n+    /// symlink.\n+    ///\n+    /// if `.create_new(true)` is set, `.create()` and `.truncate()` are ignored.\n+    ///\n+    /// The file must be opened with write or append access in order to create\n+    /// a new file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let file = OpenOptions::new().write(true).create_new(true).open(\"foo.txt\");\n+    /// ```\n+    #[stable(feature = \"expand_open_options\", since = \"1.7.0\")]\n+    pub fn create_new(&mut self, create_new: bool) -> &mut OpenOptions {\n+        self.0.create_new(create_new); self\n+    }\n+\n+    /// Pass custom open flags to the operating system.\n+    ///\n+    /// Windows and the various flavours of Unix support flags that are not\n+    /// cross-platform, but that can be useful in some circumstances. On Unix they will\n+    /// be passed as the variable _flags_ to `open`, on Windows as the\n+    /// _dwFlagsAndAttributes_ parameter.\n+    ///\n+    /// The cross-platform options of Rust can do magic: they can set any flag necessary\n+    /// to ensure it works as expected. For example, `.append(true)` on Unix not only\n+    /// sets the flag `O_APPEND`, but also automatically `O_WRONLY` or `O_RDWR`. This\n+    /// special treatment is not available for the custom flags.\n+    ///\n+    /// Custom flags can only set flags, not remove flags set by Rusts options.\n+    ///\n+    /// For the custom flags on Unix, the bits that define the access mode are masked\n+    /// out with `O_ACCMODE`, to ensure they do not interfere with the access mode set\n+    /// by Rusts options.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// extern crate libc;\n+    /// extern crate winapi;\n+    /// use std::fs::OpenOptions;\n+    ///\n+    /// let options = OpenOptions::new().write(true);\n+    /// if cfg!(unix) { options.custom_flags(libc::O_NOFOLLOW); }\n+    /// if cfg!(windows) { options.custom_flags(winapi::FILE_FLAG_BACKUP_SEMANTICS); }\n+    /// let file = options.open(\"foo.txt\");\n+    /// ```\n+    #[stable(feature = \"expand_open_options\", since = \"1.7.0\")]\n+    pub fn custom_flags(&mut self, flags: u32) -> &mut OpenOptions {\n+        self.0.custom_flags(flags); self\n+    }\n+\n     /// Opens a file at `path` with the options specified by `self`.\n     ///\n     /// # Errors\n     ///\n     /// This function will return an error under a number of different\n     /// circumstances, to include but not limited to:\n     ///\n-    /// * Opening a file that does not exist with read access.\n+    /// * Opening a file that does not exist without setting `create` or `create_new`.\n     /// * Attempting to open a file with access that the user lacks\n     ///   permissions for\n     /// * Filesystem-level errors (full disk, etc)\n+    /// * Invalid combinations of open options (truncate without write access,\n+    ///   no access mode set, etc)\n     ///\n     /// # Examples\n     ///\n@@ -2098,61 +2183,108 @@ mod tests {\n \n         let mut r = OO::new(); r.read(true);\n         let mut w = OO::new(); w.write(true);\n-        let mut rw = OO::new(); rw.write(true).read(true);\n-\n-        match r.open(&tmpdir.join(\"a\")) {\n-            Ok(..) => panic!(), Err(..) => {}\n-        }\n-\n-        // Perform each one twice to make sure that it succeeds the second time\n-        // (where the file exists)\n-        check!(c(&w).create(true).open(&tmpdir.join(\"b\")));\n-        assert!(tmpdir.join(\"b\").exists());\n-        check!(c(&w).create(true).open(&tmpdir.join(\"b\")));\n-        check!(w.open(&tmpdir.join(\"b\")));\n-\n-        check!(c(&rw).create(true).open(&tmpdir.join(\"c\")));\n-        assert!(tmpdir.join(\"c\").exists());\n+        let mut rw = OO::new(); rw.read(true).write(true);\n+        let mut a = OO::new(); a.append(true);\n+        let mut ra = OO::new(); ra.read(true).append(true);\n+\n+        let invalid_options = if cfg!(windows) { \"The parameter is incorrect\" }\n+                              else { \"Invalid argument\" };\n+\n+        // Test various combinations of creation modes and access modes.\n+        //\n+        // Allowed:\n+        // creation mode           | read  | write | read-write | append | read-append |\n+        // :-----------------------|:-----:|:-----:|:----------:|:------:|:-----------:|\n+        // not set (open existing) |   X   |   X   |     X      |   X    |      X      |\n+        // create                  |       |   X   |     X      |   X    |      X      |\n+        // truncate                |       |   X   |     X      |        |             |\n+        // create and truncate     |       |   X   |     X      |        |             |\n+        // create_new              |       |   X   |     X      |   X    |      X      |\n+        //\n+        // tested in reverse order, so 'create_new' creates the file, and 'open existing' opens it.\n+\n+        // write-only\n+        check!(c(&w).create_new(true).open(&tmpdir.join(\"a\")));\n+        check!(c(&w).create(true).truncate(true).open(&tmpdir.join(\"a\")));\n+        check!(c(&w).truncate(true).open(&tmpdir.join(\"a\")));\n+        check!(c(&w).create(true).open(&tmpdir.join(\"a\")));\n+        check!(c(&w).open(&tmpdir.join(\"a\")));\n+\n+        // read-only\n+        error!(c(&r).create_new(true).open(&tmpdir.join(\"b\")), invalid_options);\n+        error!(c(&r).create(true).truncate(true).open(&tmpdir.join(\"b\")), invalid_options);\n+        error!(c(&r).truncate(true).open(&tmpdir.join(\"b\")), invalid_options);\n+        error!(c(&r).create(true).open(&tmpdir.join(\"b\")), invalid_options);\n+        check!(c(&r).open(&tmpdir.join(\"a\"))); // try opening the file created with write_only\n+\n+        // read-write\n+        check!(c(&rw).create_new(true).open(&tmpdir.join(\"c\")));\n+        check!(c(&rw).create(true).truncate(true).open(&tmpdir.join(\"c\")));\n+        check!(c(&rw).truncate(true).open(&tmpdir.join(\"c\")));\n         check!(c(&rw).create(true).open(&tmpdir.join(\"c\")));\n-        check!(rw.open(&tmpdir.join(\"c\")));\n-\n-        check!(c(&w).append(true).create(true).open(&tmpdir.join(\"d\")));\n-        assert!(tmpdir.join(\"d\").exists());\n-        check!(c(&w).append(true).create(true).open(&tmpdir.join(\"d\")));\n-        check!(c(&w).append(true).open(&tmpdir.join(\"d\")));\n-\n-        check!(c(&rw).append(true).create(true).open(&tmpdir.join(\"e\")));\n-        assert!(tmpdir.join(\"e\").exists());\n-        check!(c(&rw).append(true).create(true).open(&tmpdir.join(\"e\")));\n-        check!(c(&rw).append(true).open(&tmpdir.join(\"e\")));\n-\n-        check!(c(&w).truncate(true).create(true).open(&tmpdir.join(\"f\")));\n-        assert!(tmpdir.join(\"f\").exists());\n-        check!(c(&w).truncate(true).create(true).open(&tmpdir.join(\"f\")));\n-        check!(c(&w).truncate(true).open(&tmpdir.join(\"f\")));\n-\n-        check!(c(&rw).truncate(true).create(true).open(&tmpdir.join(\"g\")));\n-        assert!(tmpdir.join(\"g\").exists());\n-        check!(c(&rw).truncate(true).create(true).open(&tmpdir.join(\"g\")));\n-        check!(c(&rw).truncate(true).open(&tmpdir.join(\"g\")));\n-\n-        check!(check!(File::create(&tmpdir.join(\"h\"))).write(\"foo\".as_bytes()));\n+        check!(c(&rw).open(&tmpdir.join(\"c\")));\n+\n+        // append\n+        check!(c(&a).create_new(true).open(&tmpdir.join(\"d\")));\n+        error!(c(&a).create(true).truncate(true).open(&tmpdir.join(\"d\")), invalid_options);\n+        error!(c(&a).truncate(true).open(&tmpdir.join(\"d\")), invalid_options);\n+        check!(c(&a).create(true).open(&tmpdir.join(\"d\")));\n+        check!(c(&a).open(&tmpdir.join(\"d\")));\n+\n+        // read-append\n+        check!(c(&ra).create_new(true).open(&tmpdir.join(\"e\")));\n+        error!(c(&ra).create(true).truncate(true).open(&tmpdir.join(\"e\")), invalid_options);\n+        error!(c(&ra).truncate(true).open(&tmpdir.join(\"e\")), invalid_options);\n+        check!(c(&ra).create(true).open(&tmpdir.join(\"e\")));\n+        check!(c(&ra).open(&tmpdir.join(\"e\")));\n+\n+        // Test opening a file without setting an access mode\n+        let mut blank = OO::new();\n+         error!(blank.create(true).open(&tmpdir.join(\"f\")), invalid_options);\n+\n+        // Test write works\n+        check!(check!(File::create(&tmpdir.join(\"h\"))).write(\"foobar\".as_bytes()));\n+\n+        // Test write fails for read-only\n         check!(r.open(&tmpdir.join(\"h\")));\n         {\n             let mut f = check!(r.open(&tmpdir.join(\"h\")));\n             assert!(f.write(\"wut\".as_bytes()).is_err());\n         }\n+\n+        // Test write overwrites\n+        {\n+            let mut f = check!(c(&w).open(&tmpdir.join(\"h\")));\n+            check!(f.write(\"baz\".as_bytes()));\n+        }\n+        {\n+            let mut f = check!(c(&r).open(&tmpdir.join(\"h\")));\n+            let mut b = vec![0; 6];\n+            check!(f.read(&mut b));\n+            assert_eq!(b, \"bazbar\".as_bytes());\n+        }\n+\n+        // Test truncate works\n+        {\n+            let mut f = check!(c(&w).truncate(true).open(&tmpdir.join(\"h\")));\n+            check!(f.write(\"foo\".as_bytes()));\n+        }\n+        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n+\n+        // Test append works\n         assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n         {\n-            let mut f = check!(c(&w).append(true).open(&tmpdir.join(\"h\")));\n+            let mut f = check!(c(&a).open(&tmpdir.join(\"h\")));\n             check!(f.write(\"bar\".as_bytes()));\n         }\n         assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 6);\n+\n+        // Test .append(true) equals .write(true).append(true)\n         {\n-            let mut f = check!(c(&w).truncate(true).open(&tmpdir.join(\"h\")));\n-            check!(f.write(\"bar\".as_bytes()));\n+            let mut f = check!(c(&w).append(true).open(&tmpdir.join(\"h\")));\n+            check!(f.write(\"baz\".as_bytes()));\n         }\n-        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 3);\n+        assert_eq!(check!(fs::metadata(&tmpdir.join(\"h\"))).len(), 9);\n     }\n \n     #[test]"}, {"sha": "801b222b9a8c69e3cd4e8148b73ff35cba3cfde6", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=42f4dd047af2de895df2754f7222b39f10cb6205", "patch": "@@ -99,6 +99,9 @@ pub trait OpenOptionsExt {\n     ///\n     /// If a new file is created as part of a `File::open_opts` call then this\n     /// specified `mode` will be used as the permission bits for the new file.\n+    /// If no `mode` is set, the default of `0o666` will be used.\n+    /// The operating system masks out bits with the systems `umask`, to produce\n+    /// the final permissions.\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&mut self, mode: raw::mode_t) -> &mut Self;\n }"}, {"sha": "c6a02f2b8b9301340fb8037f4864510f135be0e8", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=42f4dd047af2de895df2754f7222b39f10cb6205", "patch": "@@ -50,9 +50,15 @@ pub struct DirEntry {\n \n #[derive(Clone)]\n pub struct OpenOptions {\n-    flags: c_int,\n+    // generic\n     read: bool,\n     write: bool,\n+    append: bool,\n+    truncate: bool,\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    custom_flags: u32,\n     mode: mode_t,\n }\n \n@@ -233,43 +239,58 @@ impl DirEntry {\n impl OpenOptions {\n     pub fn new() -> OpenOptions {\n         OpenOptions {\n-            flags: libc::O_CLOEXEC,\n+            // generic\n             read: false,\n             write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            custom_flags: 0,\n             mode: 0o666,\n         }\n     }\n \n-    pub fn read(&mut self, read: bool) {\n-        self.read = read;\n-    }\n-\n-    pub fn write(&mut self, write: bool) {\n-        self.write = write;\n-    }\n-\n-    pub fn append(&mut self, append: bool) {\n-        self.flag(libc::O_APPEND, append);\n-    }\n-\n-    pub fn truncate(&mut self, truncate: bool) {\n-        self.flag(libc::O_TRUNC, truncate);\n-    }\n-\n-    pub fn create(&mut self, create: bool) {\n-        self.flag(libc::O_CREAT, create);\n-    }\n-\n-    pub fn mode(&mut self, mode: raw::mode_t) {\n-        self.mode = mode as mode_t;\n+    pub fn read(&mut self, read: bool) { self.read = read; }\n+    pub fn write(&mut self, write: bool) { self.write = write; }\n+    pub fn append(&mut self, append: bool) { self.append = append; }\n+    pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+\n+    pub fn custom_flags(&mut self, flags: u32) { self.custom_flags = flags; }\n+    pub fn mode(&mut self, mode: raw::mode_t) { self.mode = mode as mode_t; }\n+\n+    fn get_access_mode(&self) -> io::Result<c_int> {\n+        match (self.read, self.write, self.append) {\n+            (true,  false, false) => Ok(libc::O_RDONLY),\n+            (false, true,  false) => Ok(libc::O_WRONLY),\n+            (true,  true,  false) => Ok(libc::O_RDWR),\n+            (false, _,     true)  => Ok(libc::O_WRONLY | libc::O_APPEND),\n+            (true,  _,     true)  => Ok(libc::O_RDWR | libc::O_APPEND),\n+            (false, false, false) => Err(Error::from_raw_os_error(libc::EINVAL)),\n+        }\n     }\n \n-    fn flag(&mut self, bit: c_int, on: bool) {\n-        if on {\n-            self.flags |= bit;\n-        } else {\n-            self.flags &= !bit;\n+    fn get_creation_mode(&self) -> io::Result<c_int> {\n+        match (self.write, self.append) {\n+            (true,  false) => {}\n+            (false, false) => if self.truncate || self.create || self.create_new {\n+                                  return Err(Error::from_raw_os_error(libc::EINVAL));\n+                              },\n+            (_,     true)  => if self.truncate && !self.create_new {\n+                                  return Err(Error::from_raw_os_error(libc::EINVAL));\n+                              },\n         }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => 0,\n+                (true,  false, false) => libc::O_CREAT,\n+                (false, true,  false) => libc::O_TRUNC,\n+                (true,  true,  false) => libc::O_CREAT | libc::O_TRUNC,\n+                (_,      _,    true)  => libc::O_CREAT | libc::O_EXCL,\n+           })\n     }\n }\n \n@@ -280,12 +301,10 @@ impl File {\n     }\n \n     pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n-        let flags = opts.flags | match (opts.read, opts.write) {\n-            (true, true) => libc::O_RDWR,\n-            (false, true) => libc::O_WRONLY,\n-            (true, false) |\n-            (false, false) => libc::O_RDONLY,\n-        };\n+        let flags = libc::O_CLOEXEC |\n+                    try!(opts.get_access_mode()) |\n+                    try!(opts.get_creation_mode()) |\n+                    (opts.custom_flags as c_int & !libc::O_ACCMODE);\n         let fd = try!(cvt_r(|| unsafe {\n             libc::open(path.as_ptr(), flags, opts.mode as c_int)\n         }));"}, {"sha": "6e8090a223516434662df5b4f5497422cce35a2b", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=42f4dd047af2de895df2754f7222b39f10cb6205", "patch": "@@ -93,16 +93,30 @@ pub const CREATE_NEW: DWORD = 1;\n pub const OPEN_ALWAYS: DWORD = 4;\n pub const OPEN_EXISTING: DWORD = 3;\n pub const TRUNCATE_EXISTING: DWORD = 5;\n-pub const FILE_APPEND_DATA: DWORD = 0x00000004;\n+\n pub const FILE_READ_DATA: DWORD = 0x00000001;\n pub const FILE_WRITE_DATA: DWORD = 0x00000002;\n-pub const STANDARD_RIGHTS_READ: DWORD = 0x20000;\n-pub const STANDARD_RIGHTS_WRITE: DWORD = 0x20000;\n-pub const FILE_WRITE_EA: DWORD = 0x00000010;\n+pub const FILE_APPEND_DATA: DWORD = 0x00000004;\n pub const FILE_READ_EA: DWORD = 0x00000008;\n-pub const SYNCHRONIZE: DWORD = 0x00100000;\n-pub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n+pub const FILE_WRITE_EA: DWORD = 0x00000010;\n+pub const FILE_EXECUTE: DWORD = 0x00000020;\n pub const FILE_READ_ATTRIBUTES: DWORD = 0x00000080;\n+pub const FILE_WRITE_ATTRIBUTES: DWORD = 0x00000100;\n+\n+pub const DELETE: DWORD = 0x00008000;\n+pub const READ_CONTROL: DWORD = 0x00020000;\n+pub const WRITE_DAC: DWORD = 0x00040000;\n+pub const WRITE_OWNER: DWORD = 0x00080000;\n+pub const SYNCHRONIZE: DWORD = 0x00100000;\n+\n+pub const GENERIC_READ: DWORD = 0x80000000;\n+pub const GENERIC_WRITE: DWORD = 0x40000000;\n+pub const GENERIC_EXECUTE: DWORD = 0x20000000;\n+pub const GENERIC_ALL: DWORD = 0x10000000;\n+\n+pub const STANDARD_RIGHTS_READ: DWORD = READ_CONTROL;\n+pub const STANDARD_RIGHTS_WRITE: DWORD = READ_CONTROL;\n+pub const STANDARD_RIGHTS_EXECUTE: DWORD = READ_CONTROL;\n pub const FILE_GENERIC_READ: DWORD = STANDARD_RIGHTS_READ | FILE_READ_DATA |\n                                      FILE_READ_ATTRIBUTES |\n                                      FILE_READ_EA |\n@@ -113,6 +127,14 @@ pub const FILE_GENERIC_WRITE: DWORD = STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA |\n                                       FILE_APPEND_DATA |\n                                       SYNCHRONIZE;\n \n+pub const SECURITY_ANONYMOUS: DWORD = 0 << 16;\n+pub const SECURITY_IDENTIFICATION: DWORD = 1 << 16;\n+pub const SECURITY_IMPERSONATION: DWORD = 2 << 16;\n+pub const SECURITY_DELEGATION: DWORD = 3 << 16;\n+pub const SECURITY_CONTEXT_TRACKING: DWORD = 0x00040000;\n+pub const SECURITY_EFFECTIVE_ONLY: DWORD = 0x00080000;\n+pub const SECURITY_SQOS_PRESENT: DWORD = 0x00100000;\n+\n #[repr(C)]\n #[derive(Copy)]\n pub struct WIN32_FIND_DATAW {"}, {"sha": "fa7e0e564ac25321aff0cd4ced707ec18f2bb329", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 83, "deletions": 23, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=42f4dd047af2de895df2754f7222b39f10cb6205", "patch": "@@ -25,45 +25,105 @@ use sys_common::{AsInnerMut, AsInner};\n pub trait OpenOptionsExt {\n     /// Overrides the `dwDesiredAccess` argument to the call to `CreateFile`\n     /// with the specified value.\n-    fn desired_access(&mut self, access: u32) -> &mut Self;\n-\n-    /// Overrides the `dwCreationDisposition` argument to the call to\n-    /// `CreateFile` with the specified value.\n     ///\n-    /// This will override any values of the standard `create` flags, for\n-    /// example.\n-    fn creation_disposition(&mut self, val: u32) -> &mut Self;\n-\n-    /// Overrides the `dwFlagsAndAttributes` argument to the call to\n-    /// `CreateFile` with the specified value.\n+    /// This will override the `read`, `write`, and `append` flags on the\n+    /// `OpenOptions` structure. This method provides fine-grained control\n+    /// over the permissions to read, write and append data, attributes\n+    /// (like hidden and system) and extended attributes.\n+    ///\n+    /// # Examples\n     ///\n-    /// This will override any values of the standard flags on the\n-    /// `OpenOptions` structure.\n-    fn flags_and_attributes(&mut self, val: u32) -> &mut Self;\n+    /// ```no_run\n+    /// #![feature(open_options_ext)]\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::windows::fs::OpenOptionsExt;\n+    ///\n+    /// // Open without read and write permission, for example if you only need to call `stat()`\n+    /// // on the file\n+    /// let file = OpenOptions::new().access_mode(0).open(\"foo.txt\");\n+    /// ```\n+    fn access_mode(&mut self, access: u32) -> &mut Self;\n \n     /// Overrides the `dwShareMode` argument to the call to `CreateFile` with\n     /// the specified value.\n     ///\n-    /// This will override any values of the standard flags on the\n-    /// `OpenOptions` structure.\n+    /// By default `share_mode` is set to `FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE`.\n+    /// Specifying less permissions denies others to read from, write to and/or\n+    /// delete the file while it is open.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(open_options_ext)]\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::windows::fs::OpenOptionsExt;\n+    ///\n+    /// let file = OpenOptions::new().write(true)\n+    ///                              .share_mode(0) // Do not allow others to read or modify\n+    ///                              .open(\"foo.txt\");\n+    /// ```\n     fn share_mode(&mut self, val: u32) -> &mut Self;\n+\n+    /// Sets the `dwFileAttributes` argument to the call to `CreateFile2` to\n+    /// the specified value (or combines it with `custom_flags` and\n+    /// `security_qos_flags` to set the `dwFlagsAndAttributes` for `CreateFile`).\n+    ///\n+    /// If a _new_ file is created because it does not yet exist and `.create(true)` or\n+    /// `.create_new(true)` are specified, the new file is given the attributes declared\n+    /// with `.attributes()`.\n+    ///\n+    /// If an _existing_ file is opened with `.create(true).truncate(true)`, its\n+    /// existing attributes are preserved and combined with the ones declared with\n+    /// `.attributes()`.\n+    ///\n+    /// In all other cases the attributes get ignored.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust,ignore\n+    /// #![feature(open_options_ext)]\n+    /// extern crate winapi;\n+    /// use std::fs::OpenOptions;\n+    /// use std::os::windows::fs::OpenOptionsExt;\n+    ///\n+    /// let file = OpenOptions::new().write(true).create(true)\n+    ///                              .attributes(winapi::FILE_ATTRIBUTE_HIDDEN)\n+    ///                              .open(\"foo.txt\");\n+    /// ```\n+    fn attributes(&mut self, val: u32) -> &mut Self;\n+\n+    /// Sets the `dwSecurityQosFlags` argument to the call to `CreateFile2` to\n+    /// the specified value (or combines it with `custom_flags` and `attributes`\n+    /// to set the `dwFlagsAndAttributes` for `CreateFile`).\n+    fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions;\n+\n+    /// Sets the `lpSecurityAttributes` argument to the call to `CreateFile` to\n+    /// the specified value.\n+    fn security_attributes(&mut self, attrs: sys::c::LPSECURITY_ATTRIBUTES) -> &mut OpenOptions;\n }\n \n #[unstable(feature = \"open_options_ext\",\n            reason = \"may require more thought/methods\",\n            issue = \"27720\")]\n impl OpenOptionsExt for OpenOptions {\n-    fn desired_access(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().desired_access(access); self\n+    fn access_mode(&mut self, access: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().access_mode(access); self\n     }\n-    fn creation_disposition(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().creation_disposition(access); self\n+\n+    fn share_mode(&mut self, share: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().share_mode(share); self\n     }\n-    fn flags_and_attributes(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().flags_and_attributes(access); self\n+\n+    fn attributes(&mut self, attributes: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().attributes(attributes); self\n     }\n-    fn share_mode(&mut self, access: u32) -> &mut OpenOptions {\n-        self.as_inner_mut().share_mode(access); self\n+\n+    fn security_qos_flags(&mut self, flags: u32) -> &mut OpenOptions {\n+        self.as_inner_mut().security_qos_flags(flags); self\n+    }\n+\n+    fn security_attributes(&mut self, attrs: sys::c::LPSECURITY_ATTRIBUTES) -> &mut OpenOptions {\n+        self.as_inner_mut().security_attributes(attrs); self\n     }\n }\n "}, {"sha": "b3b80be208b66663451cb68d05b17868773c3286", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 90, "deletions": 66, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42f4dd047af2de895df2754f7222b39f10cb6205/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=42f4dd047af2de895df2754f7222b39f10cb6205", "patch": "@@ -54,18 +54,22 @@ pub struct DirEntry {\n     data: c::WIN32_FIND_DATAW,\n }\n \n-#[derive(Clone, Default)]\n+#[derive(Clone)]\n pub struct OpenOptions {\n-    create: bool,\n-    append: bool,\n+    // generic\n     read: bool,\n     write: bool,\n+    append: bool,\n     truncate: bool,\n-    desired_access: Option<c::DWORD>,\n-    share_mode: Option<c::DWORD>,\n-    creation_disposition: Option<c::DWORD>,\n-    flags_and_attributes: Option<c::DWORD>,\n-    security_attributes: usize, // *mut T doesn't have a Default impl\n+    create: bool,\n+    create_new: bool,\n+    // system-specific\n+    custom_flags: u32,\n+    access_mode: Option<c::DWORD>,\n+    attributes: c::DWORD,\n+    share_mode: c::DWORD,\n+    security_qos_flags: c::DWORD,\n+    security_attributes: c::LPSECURITY_ATTRIBUTES,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -151,68 +155,84 @@ impl DirEntry {\n }\n \n impl OpenOptions {\n-    pub fn new() -> OpenOptions { Default::default() }\n+    pub fn new() -> OpenOptions {\n+        OpenOptions {\n+            // generic\n+            read: false,\n+            write: false,\n+            append: false,\n+            truncate: false,\n+            create: false,\n+            create_new: false,\n+            // system-specific\n+            custom_flags: 0,\n+            access_mode: None,\n+            share_mode: c::FILE_SHARE_READ | c::FILE_SHARE_WRITE | c::FILE_SHARE_DELETE,\n+            attributes: 0,\n+            security_qos_flags: 0,\n+            security_attributes: ptr::null_mut(),\n+        }\n+    }\n+\n     pub fn read(&mut self, read: bool) { self.read = read; }\n     pub fn write(&mut self, write: bool) { self.write = write; }\n     pub fn append(&mut self, append: bool) { self.append = append; }\n-    pub fn create(&mut self, create: bool) { self.create = create; }\n     pub fn truncate(&mut self, truncate: bool) { self.truncate = truncate; }\n-    pub fn creation_disposition(&mut self, val: u32) {\n-        self.creation_disposition = Some(val);\n-    }\n-    pub fn flags_and_attributes(&mut self, val: u32) {\n-        self.flags_and_attributes = Some(val);\n-    }\n-    pub fn desired_access(&mut self, val: u32) {\n-        self.desired_access = Some(val);\n-    }\n-    pub fn share_mode(&mut self, val: u32) {\n-        self.share_mode = Some(val);\n-    }\n+    pub fn create(&mut self, create: bool) { self.create = create; }\n+    pub fn create_new(&mut self, create_new: bool) { self.create_new = create_new; }\n+\n+    pub fn custom_flags(&mut self, flags: u32) { self.custom_flags = flags; }\n+    pub fn access_mode(&mut self, access_mode: u32) { self.access_mode = Some(access_mode); }\n+    pub fn share_mode(&mut self, share_mode: u32) { self.share_mode = share_mode; }\n+    pub fn attributes(&mut self, attrs: u32) { self.attributes = attrs; }\n+    pub fn security_qos_flags(&mut self, flags: u32) { self.security_qos_flags = flags; }\n     pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) {\n-        self.security_attributes = attrs as usize;\n+        self.security_attributes = attrs;\n     }\n \n-    fn get_desired_access(&self) -> c::DWORD {\n-        self.desired_access.unwrap_or({\n-            let mut base = if self.read {c::FILE_GENERIC_READ} else {0} |\n-                           if self.write {c::FILE_GENERIC_WRITE} else {0};\n-            if self.append {\n-                base &= !c::FILE_WRITE_DATA;\n-                base |= c::FILE_APPEND_DATA;\n-            }\n-            base\n-        })\n+    fn get_access_mode(&self) -> io::Result<c::DWORD> {\n+        const ERROR_INVALID_PARAMETER: i32 = 87;\n+\n+        match (self.read, self.write, self.append, self.access_mode) {\n+            (_, _, _, Some(mode)) => Ok(mode),\n+            (true,  false, false, None) => Ok(c::GENERIC_READ),\n+            (false, true,  false, None) => Ok(c::GENERIC_WRITE),\n+            (true,  true,  false, None) => Ok(c::GENERIC_READ | c::GENERIC_WRITE),\n+            (false, _,     true,  None) => Ok(c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA),\n+            (true,  _,     true,  None) => Ok(c::GENERIC_READ |\n+                                              (c::FILE_GENERIC_WRITE & !c::FILE_WRITE_DATA)),\n+            (false, false, false, None) => Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER)),\n+        }\n     }\n \n-    fn get_share_mode(&self) -> c::DWORD {\n-        // libuv has a good comment about this, but the basic idea is that\n-        // we try to emulate unix semantics by enabling all sharing by\n-        // allowing things such as deleting a file while it's still open.\n-        self.share_mode.unwrap_or(c::FILE_SHARE_READ |\n-                                  c::FILE_SHARE_WRITE |\n-                                  c::FILE_SHARE_DELETE)\n-    }\n-\n-    fn get_creation_disposition(&self) -> c::DWORD {\n-        self.creation_disposition.unwrap_or({\n-            match (self.create, self.truncate) {\n-                (true, true) => c::CREATE_ALWAYS,\n-                (true, false) => c::OPEN_ALWAYS,\n-                (false, false) => c::OPEN_EXISTING,\n-                (false, true) => {\n-                    if self.write && !self.append {\n-                        c::CREATE_ALWAYS\n-                    } else {\n-                        c::TRUNCATE_EXISTING\n-                    }\n-                }\n-            }\n-        })\n+    fn get_creation_mode(&self) -> io::Result<c::DWORD> {\n+        const ERROR_INVALID_PARAMETER: i32 = 87;\n+\n+        match (self.write, self.append) {\n+            (true,  false) => {}\n+            (false, false) => if self.truncate || self.create || self.create_new {\n+                                  return Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n+                              },\n+            (_,     true)  => if self.truncate && !self.create_new {\n+                                  return Err(Error::from_raw_os_error(ERROR_INVALID_PARAMETER));\n+                              },\n+        }\n+\n+        Ok(match (self.create, self.truncate, self.create_new) {\n+                (false, false, false) => c::OPEN_EXISTING,\n+                (true,  false, false) => c::OPEN_ALWAYS,\n+                (false, true,  false) => c::TRUNCATE_EXISTING,\n+                (true,  true,  false) => c::CREATE_ALWAYS,\n+                (_,      _,    true)  => c::CREATE_NEW,\n+           })\n     }\n \n     fn get_flags_and_attributes(&self) -> c::DWORD {\n-        self.flags_and_attributes.unwrap_or(c::FILE_ATTRIBUTE_NORMAL)\n+        self.custom_flags |\n+        self.attributes |\n+        self.security_qos_flags |\n+        if self.security_qos_flags != 0 { c::SECURITY_SQOS_PRESENT } else { 0 } |\n+        if self.create_new { c::FILE_FLAG_OPEN_REPARSE_POINT } else { 0 }\n     }\n }\n \n@@ -221,19 +241,19 @@ impl File {\n         let mut opts = OpenOptions::new();\n         opts.read(!write);\n         opts.write(write);\n-        opts.flags_and_attributes(c::FILE_FLAG_OPEN_REPARSE_POINT |\n-                                  c::FILE_FLAG_BACKUP_SEMANTICS);\n+        opts.custom_flags(c::FILE_FLAG_OPEN_REPARSE_POINT |\n+                          c::FILE_FLAG_BACKUP_SEMANTICS);\n         File::open(path, &opts)\n     }\n \n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n         let path = try!(to_u16s(path));\n         let handle = unsafe {\n             c::CreateFileW(path.as_ptr(),\n-                           opts.get_desired_access(),\n-                           opts.get_share_mode(),\n+                           try!(opts.get_access_mode()),\n+                           opts.share_mode,\n                            opts.security_attributes as *mut _,\n-                           opts.get_creation_disposition(),\n+                           try!(opts.get_creation_mode()),\n                            opts.get_flags_and_attributes(),\n                            ptr::null_mut())\n         };\n@@ -533,7 +553,10 @@ pub fn stat(p: &Path) -> io::Result<FileAttr> {\n     // metadata information is.\n     if attr.is_reparse_point() {\n         let mut opts = OpenOptions::new();\n-        opts.flags_and_attributes(c::FILE_FLAG_BACKUP_SEMANTICS);\n+        // No read or write permissions are necessary\n+        opts.access_mode(0);\n+        // This flag is so we can open directories too\n+        opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n         let file = try!(File::open(p, &opts));\n         file.file_attr()\n     } else {\n@@ -577,9 +600,10 @@ fn get_path(f: &File) -> io::Result<PathBuf> {\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     let mut opts = OpenOptions::new();\n-    opts.read(true);\n+    // No read or write permissions are necessary\n+    opts.access_mode(0);\n     // This flag is so we can open directories too\n-    opts.flags_and_attributes(c::FILE_FLAG_BACKUP_SEMANTICS);\n+    opts.custom_flags(c::FILE_FLAG_BACKUP_SEMANTICS);\n     let f = try!(File::open(p, &opts));\n     get_path(&f)\n }"}]}