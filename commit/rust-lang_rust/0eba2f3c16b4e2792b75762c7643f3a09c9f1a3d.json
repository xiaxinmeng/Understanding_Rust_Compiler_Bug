{"sha": "0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "node_id": "C_kwDOAAsO6NoAKDBlYmEyZjNjMTZiNGUyNzkyYjc1NzYyYzc2NDNmM2EwOWM5ZjFhM2Q", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-19T21:13:01Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-02-10T18:18:08Z"}, "message": "Suggest fn call on pattern type mismatch", "tree": {"sha": "9e0cdabc94034431c8ff72b0d994bed72e50adef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e0cdabc94034431c8ff72b0d994bed72e50adef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "html_url": "https://github.com/rust-lang/rust/commit/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ac43a9b9a8250d858705b0796dfed6186e18db", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ac43a9b9a8250d858705b0796dfed6186e18db", "html_url": "https://github.com/rust-lang/rust/commit/d1ac43a9b9a8250d858705b0796dfed6186e18db"}], "stats": {"total": 78, "additions": 68, "deletions": 10}, "files": [{"sha": "e19ef2ff3bf481a874445e4e18808061dce0d0b8", "filename": "compiler/rustc_hir_typeck/src/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2F_match.rs?ref=0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "patch": "@@ -41,7 +41,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // #55810: Type check patterns first so we get types for all bindings.\n         let scrut_span = scrut.span.find_ancestor_inside(expr.span).unwrap_or(scrut.span);\n         for arm in arms {\n-            self.check_pat_top(&arm.pat, scrutinee_ty, Some(scrut_span), true);\n+            self.check_pat_top(&arm.pat, scrutinee_ty, Some(scrut_span), Some(scrut));\n         }\n \n         // Now typecheck the blocks."}, {"sha": "cc515e6c853134c6055f251f9ebedfc5d5ec9300", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "patch": "@@ -90,7 +90,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n         // Check the pattern.\n         let ty_span = try { inputs_hir?.get(idx)?.span };\n-        fcx.check_pat_top(&param.pat, param_ty, ty_span, false);\n+        fcx.check_pat_top(&param.pat, param_ty, ty_span, None);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings"}, {"sha": "9c7a84ce198e8fa9411fde54a60220071f9055c4", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "patch": "@@ -1330,11 +1330,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Does the expected pattern type originate from an expression and what is the span?\n         let (origin_expr, ty_span) = match (decl.ty, decl.init) {\n-            (Some(ty), _) => (false, Some(ty.span)), // Bias towards the explicit user type.\n+            (Some(ty), _) => (None, Some(ty.span)), // Bias towards the explicit user type.\n             (_, Some(init)) => {\n-                (true, Some(init.span.find_ancestor_inside(decl.span).unwrap_or(init.span)))\n+                (Some(init), Some(init.span.find_ancestor_inside(decl.span).unwrap_or(init.span)))\n             } // No explicit type; so use the scrutinee.\n-            _ => (false, None), // We have `let $pat;`, so the expected type is unconstrained.\n+            _ => (None, None), // We have `let $pat;`, so the expected type is unconstrained.\n         };\n \n         // Type check the pattern. Override if necessary to avoid knock-on errors."}, {"sha": "52236ae56eeaac92b5bd15c6f33eca6555940e98", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "patch": "@@ -46,7 +46,7 @@ struct TopInfo<'tcx> {\n     /// Was the origin of the `span` from a scrutinee expression?\n     ///\n     /// Otherwise there is no scrutinee and it could be e.g. from the type of a formal parameter.\n-    origin_expr: bool,\n+    origin_expr: Option<&'tcx hir::Expr<'tcx>>,\n     /// The span giving rise to the `expected` type, if one could be provided.\n     ///\n     /// If `origin_expr` is `true`, then this is the span of the scrutinee as in:\n@@ -74,7 +74,8 @@ struct TopInfo<'tcx> {\n \n impl<'tcx> FnCtxt<'_, 'tcx> {\n     fn pattern_cause(&self, ti: TopInfo<'tcx>, cause_span: Span) -> ObligationCause<'tcx> {\n-        let code = Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr };\n+        let code =\n+            Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr.is_some() };\n         self.cause(cause_span, code)\n     }\n \n@@ -85,7 +86,14 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         actual: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)\n+        let mut diag =\n+            self.demand_eqtype_with_origin(&self.pattern_cause(ti, cause_span), expected, actual)?;\n+        if let Some(expr) = ti.origin_expr {\n+            self.suggest_fn_call(&mut diag, expr, expected, |output| {\n+                self.can_eq(self.param_env, output, actual).is_ok()\n+            });\n+        }\n+        Some(diag)\n     }\n \n     fn demand_eqtype_pat(\n@@ -127,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         span: Option<Span>,\n-        origin_expr: bool,\n+        origin_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) {\n         let info = TopInfo { expected, origin_expr, span };\n         self.check_pat(pat, expected, INITIAL_BM, info);\n@@ -2146,7 +2154,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             err.help(\"the semantics of slice patterns changed recently; see issue #62254\");\n         } else if self.autoderef(span, expected_ty)\n             .any(|(ty, _)| matches!(ty.kind(), ty::Slice(..) | ty::Array(..)))\n-            && let (Some(span), true) = (ti.span, ti.origin_expr)\n+            && let Some(span) = ti.span\n+            && let Some(_) = ti.origin_expr\n             && let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span)\n         {\n             let ty = self.resolve_vars_if_possible(ti.expected);"}, {"sha": "657dd9c22c21b1a4d3c7ba3f183ea8fa1fedb321", "filename": "tests/ui/suggestions/suggest-call-on-pat-mismatch.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.rs?ref=0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "patch": "@@ -0,0 +1,16 @@\n+enum E {\n+    One(i32, i32),\n+}\n+\n+fn main() {\n+    let var = E::One;\n+    if let E::One(var1, var2) = var {\n+        //~^ ERROR mismatched types\n+        //~| HELP use parentheses to construct this tuple variant\n+        println!(\"{var1} {var2}\");\n+    }\n+\n+    let Some(x) = Some;\n+    //~^ ERROR mismatched types\n+    //~| HELP use parentheses to construct this tuple variant\n+}"}, {"sha": "7338312bab651eb8ca999ff76830aa00e7c5889d", "filename": "tests/ui/suggestions/suggest-call-on-pat-mismatch.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fsuggest-call-on-pat-mismatch.stderr?ref=0eba2f3c16b4e2792b75762c7643f3a09c9f1a3d", "patch": "@@ -0,0 +1,33 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-call-on-pat-mismatch.rs:7:12\n+   |\n+LL |     if let E::One(var1, var2) = var {\n+   |            ^^^^^^^^^^^^^^^^^^   --- this expression has type `fn(i32, i32) -> E {E::One}`\n+   |            |\n+   |            expected enum constructor, found `E`\n+   |\n+   = note: expected enum constructor `fn(i32, i32) -> E {E::One}`\n+                          found enum `E`\n+help: use parentheses to construct this tuple variant\n+   |\n+LL |     if let E::One(var1, var2) = var(/* i32 */, /* i32 */) {\n+   |                                    ++++++++++++++++++++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-call-on-pat-mismatch.rs:13:9\n+   |\n+LL |     let Some(x) = Some;\n+   |         ^^^^^^^   ---- this expression has type `fn(_) -> Option<_> {Option::<_>::Some}`\n+   |         |\n+   |         expected enum constructor, found `Option<_>`\n+   |\n+   = note: expected enum constructor `fn(_) -> Option<_> {Option::<_>::Some}`\n+                          found enum `Option<_>`\n+help: use parentheses to construct this tuple variant\n+   |\n+LL |     let Some(x) = Some(/* value */);\n+   |                       +++++++++++++\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}