{"sha": "a56d345490ed68ab57cf1854dd8978fefc9862d0", "node_id": "C_kwDOAAsO6NoAKGE1NmQzNDU0OTBlZDY4YWI1N2NmMTg1NGRkODk3OGZlZmM5ODYyZDA", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-09T02:44:05Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-09T02:45:26Z"}, "message": "Rename `AttrAnnotatedToken{Stream,Tree}`.\n\nThese two type names are long and have long matching prefixes. I find\nthem hard to read, especially in combinations like\n`AttrAnnotatedTokenStream::new(vec![AttrAnnotatedTokenTree::Token(..)])`.\n\nThis commit renames them as `AttrToken{Stream,Tree}`.", "tree": {"sha": "d1a3c1a52c6caae0243b386f84ae3fb3f9e69722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1a3c1a52c6caae0243b386f84ae3fb3f9e69722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a56d345490ed68ab57cf1854dd8978fefc9862d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a56d345490ed68ab57cf1854dd8978fefc9862d0", "html_url": "https://github.com/rust-lang/rust/commit/a56d345490ed68ab57cf1854dd8978fefc9862d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a56d345490ed68ab57cf1854dd8978fefc9862d0/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "890e759ffcf61a2c66f722bb448432b9a78fdaaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/890e759ffcf61a2c66f722bb448432b9a78fdaaf", "html_url": "https://github.com/rust-lang/rust/commit/890e759ffcf61a2c66f722bb448432b9a78fdaaf"}], "stats": {"total": 164, "additions": 80, "deletions": 84}, "files": [{"sha": "e0bb47539329ed492fbe9d0cc2f29355a3524080", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=a56d345490ed68ab57cf1854dd8978fefc9862d0", "patch": "@@ -7,7 +7,7 @@ use crate::ast::{MacArgs, MacArgsEq, MacDelimiter, MetaItem, MetaItemKind, Neste\n use crate::ast::{Path, PathSegment};\n use crate::ptr::P;\n use crate::token::{self, CommentKind, Delimiter, Token};\n-use crate::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n+use crate::tokenstream::{AttrTokenStream, AttrTokenTree};\n use crate::tokenstream::{DelimSpan, Spacing, TokenTree};\n use crate::tokenstream::{LazyTokenStream, TokenStream};\n use crate::util::comments;\n@@ -296,15 +296,15 @@ impl Attribute {\n         }\n     }\n \n-    pub fn tokens(&self) -> AttrAnnotatedTokenStream {\n+    pub fn tokens(&self) -> AttrTokenStream {\n         match self.kind {\n             AttrKind::Normal(ref normal) => normal\n                 .tokens\n                 .as_ref()\n                 .unwrap_or_else(|| panic!(\"attribute is missing tokens: {:?}\", self))\n                 .create_token_stream(),\n             AttrKind::DocComment(comment_kind, data) => {\n-                AttrAnnotatedTokenStream::new(vec![AttrAnnotatedTokenTree::Token(\n+                AttrTokenStream::new(vec![AttrTokenTree::Token(\n                     Token::new(token::DocComment(comment_kind, self.style, data), self.span),\n                     Spacing::Alone,\n                 )])"}, {"sha": "27fb2d12760dc342085ebba82606afdb5e1ac82d", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=a56d345490ed68ab57cf1854dd8978fefc9862d0", "patch": "@@ -642,17 +642,17 @@ pub fn noop_flat_map_param<T: MutVisitor>(mut param: Param, vis: &mut T) -> Smal\n }\n \n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n-pub fn visit_attr_annotated_tt<T: MutVisitor>(tt: &mut AttrAnnotatedTokenTree, vis: &mut T) {\n+pub fn visit_attr_tt<T: MutVisitor>(tt: &mut AttrTokenTree, vis: &mut T) {\n     match tt {\n-        AttrAnnotatedTokenTree::Token(token, _) => {\n+        AttrTokenTree::Token(token, _) => {\n             visit_token(token, vis);\n         }\n-        AttrAnnotatedTokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n+        AttrTokenTree::Delimited(DelimSpan { open, close }, _delim, tts) => {\n             vis.visit_span(open);\n             vis.visit_span(close);\n-            visit_attr_annotated_tts(tts, vis);\n+            visit_attr_tts(tts, vis);\n         }\n-        AttrAnnotatedTokenTree::Attributes(data) => {\n+        AttrTokenTree::Attributes(data) => {\n             for attr in &mut *data.attrs {\n                 match &mut attr.kind {\n                     AttrKind::Normal(normal) => {\n@@ -690,21 +690,18 @@ pub fn visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T)\n     }\n }\n \n-pub fn visit_attr_annotated_tts<T: MutVisitor>(\n-    AttrAnnotatedTokenStream(tts): &mut AttrAnnotatedTokenStream,\n-    vis: &mut T,\n-) {\n+pub fn visit_attr_tts<T: MutVisitor>(AttrTokenStream(tts): &mut AttrTokenStream, vis: &mut T) {\n     if T::VISIT_TOKENS && !tts.is_empty() {\n         let tts = Lrc::make_mut(tts);\n-        visit_vec(tts, |tree| visit_attr_annotated_tt(tree, vis));\n+        visit_vec(tts, |tree| visit_attr_tt(tree, vis));\n     }\n }\n \n pub fn visit_lazy_tts_opt_mut<T: MutVisitor>(lazy_tts: Option<&mut LazyTokenStream>, vis: &mut T) {\n     if T::VISIT_TOKENS {\n         if let Some(lazy_tts) = lazy_tts {\n             let mut tts = lazy_tts.create_token_stream();\n-            visit_attr_annotated_tts(&mut tts, vis);\n+            visit_attr_tts(&mut tts, vis);\n             *lazy_tts = LazyTokenStream::new(tts);\n         }\n     }"}, {"sha": "4088e50fbe2c8ee53b509695369aa93bfa491546", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=a56d345490ed68ab57cf1854dd8978fefc9862d0", "patch": "@@ -122,11 +122,11 @@ where\n }\n \n pub trait CreateTokenStream: sync::Send + sync::Sync {\n-    fn create_token_stream(&self) -> AttrAnnotatedTokenStream;\n+    fn create_token_stream(&self) -> AttrTokenStream;\n }\n \n-impl CreateTokenStream for AttrAnnotatedTokenStream {\n-    fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n+impl CreateTokenStream for AttrTokenStream {\n+    fn create_token_stream(&self) -> AttrTokenStream {\n         self.clone()\n     }\n }\n@@ -142,7 +142,7 @@ impl LazyTokenStream {\n         LazyTokenStream(Lrc::new(Box::new(inner)))\n     }\n \n-    pub fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n+    pub fn create_token_stream(&self) -> AttrTokenStream {\n         self.0.create_token_stream()\n     }\n }\n@@ -172,31 +172,31 @@ impl<CTX> HashStable<CTX> for LazyTokenStream {\n     }\n }\n \n-/// A `AttrAnnotatedTokenStream` is similar to a `TokenStream`, but with extra\n+/// An `AttrTokenStream` is similar to a `TokenStream`, but with extra\n /// information about the tokens for attribute targets. This is used\n /// during expansion to perform early cfg-expansion, and to process attributes\n /// during proc-macro invocations.\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n-pub struct AttrAnnotatedTokenStream(pub Lrc<Vec<AttrAnnotatedTokenTree>>);\n+pub struct AttrTokenStream(pub Lrc<Vec<AttrTokenTree>>);\n \n-/// Like `TokenTree`, but for `AttrAnnotatedTokenStream`\n+/// Like `TokenTree`, but for `AttrTokenStream`.\n #[derive(Clone, Debug, Encodable, Decodable)]\n-pub enum AttrAnnotatedTokenTree {\n+pub enum AttrTokenTree {\n     Token(Token, Spacing),\n-    Delimited(DelimSpan, Delimiter, AttrAnnotatedTokenStream),\n+    Delimited(DelimSpan, Delimiter, AttrTokenStream),\n     /// Stores the attributes for an attribute target,\n     /// along with the tokens for that attribute target.\n     /// See `AttributesData` for more information\n     Attributes(AttributesData),\n }\n \n-impl AttrAnnotatedTokenStream {\n-    pub fn new(tokens: Vec<AttrAnnotatedTokenTree>) -> AttrAnnotatedTokenStream {\n-        AttrAnnotatedTokenStream(Lrc::new(tokens))\n+impl AttrTokenStream {\n+    pub fn new(tokens: Vec<AttrTokenTree>) -> AttrTokenStream {\n+        AttrTokenStream(Lrc::new(tokens))\n     }\n \n-    /// Converts this `AttrAnnotatedTokenStream` to a plain `TokenStream\n-    /// During conversion, `AttrAnnotatedTokenTree::Attributes` get 'flattened'\n+    /// Converts this `AttrTokenStream` to a plain `TokenStream`.\n+    /// During conversion, `AttrTokenTree::Attributes` get 'flattened'\n     /// back to a `TokenStream` of the form `outer_attr attr_target`.\n     /// If there are inner attributes, they are inserted into the proper\n     /// place in the attribute target tokens.\n@@ -205,14 +205,14 @@ impl AttrAnnotatedTokenStream {\n             .0\n             .iter()\n             .flat_map(|tree| match &tree {\n-                AttrAnnotatedTokenTree::Token(inner, spacing) => {\n+                AttrTokenTree::Token(inner, spacing) => {\n                     smallvec![TokenTree::Token(inner.clone(), *spacing)].into_iter()\n                 }\n-                AttrAnnotatedTokenTree::Delimited(span, delim, stream) => {\n+                AttrTokenTree::Delimited(span, delim, stream) => {\n                     smallvec![TokenTree::Delimited(*span, *delim, stream.to_tokenstream()),]\n                         .into_iter()\n                 }\n-                AttrAnnotatedTokenTree::Attributes(data) => {\n+                AttrTokenTree::Attributes(data) => {\n                     let mut outer_attrs = Vec::new();\n                     let mut inner_attrs = Vec::new();\n                     for attr in &data.attrs {\n@@ -417,14 +417,14 @@ impl TokenStream {\n     fn opt_from_ast(node: &(impl HasAttrs + HasTokens)) -> Option<TokenStream> {\n         let tokens = node.tokens()?;\n         let attrs = node.attrs();\n-        let attr_annotated = if attrs.is_empty() {\n+        let attr_stream = if attrs.is_empty() {\n             tokens.create_token_stream()\n         } else {\n             let attr_data =\n                 AttributesData { attrs: attrs.iter().cloned().collect(), tokens: tokens.clone() };\n-            AttrAnnotatedTokenStream::new(vec![AttrAnnotatedTokenTree::Attributes(attr_data)])\n+            AttrTokenStream::new(vec![AttrTokenTree::Attributes(attr_data)])\n         };\n-        Some(attr_annotated.to_tokenstream())\n+        Some(attr_stream.to_tokenstream())\n     }\n \n     // Create a token stream containing a single token with alone spacing."}, {"sha": "e673dff0dea8e438f33251c1b52cb6fc8f52debe", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=a56d345490ed68ab57cf1854dd8978fefc9862d0", "patch": "@@ -188,14 +188,14 @@ impl CfgEval<'_, '_> {\n         let orig_tokens = annotatable.to_tokens().flattened();\n \n         // Re-parse the tokens, setting the `capture_cfg` flag to save extra information\n-        // to the captured `AttrAnnotatedTokenStream` (specifically, we capture\n-        // `AttrAnnotatedTokenTree::AttributesData` for all occurrences of `#[cfg]` and `#[cfg_attr]`)\n+        // to the captured `AttrTokenStream` (specifically, we capture\n+        // `AttrTokenTree::AttributesData` for all occurrences of `#[cfg]` and `#[cfg_attr]`)\n         let mut parser =\n             rustc_parse::stream_to_parser(&self.cfg.sess.parse_sess, orig_tokens, None);\n         parser.capture_cfg = true;\n         annotatable = parse_annotatable_with(&mut parser);\n \n-        // Now that we have our re-parsed `AttrAnnotatedTokenStream`, recursively configuring\n+        // Now that we have our re-parsed `AttrTokenStream`, recursively configuring\n         // our attribute target will correctly the tokens as well.\n         flat_map_annotatable(self, annotatable)\n     }"}, {"sha": "5d78a4a59ecd2ff721653d6d99157e876a6917f7", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=a56d345490ed68ab57cf1854dd8978fefc9862d0", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{Delimiter, Token, TokenKind};\n-use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n+use rustc_ast::tokenstream::{AttrTokenStream, AttrTokenTree};\n use rustc_ast::tokenstream::{DelimSpan, Spacing};\n use rustc_ast::tokenstream::{LazyTokenStream, TokenTree};\n use rustc_ast::NodeId;\n@@ -259,8 +259,8 @@ impl<'a> StripUnconfigured<'a> {\n     fn try_configure_tokens<T: HasTokens>(&self, node: &mut T) {\n         if self.config_tokens {\n             if let Some(Some(tokens)) = node.tokens_mut() {\n-                let attr_annotated_tokens = tokens.create_token_stream();\n-                *tokens = LazyTokenStream::new(self.configure_tokens(&attr_annotated_tokens));\n+                let attr_stream = tokens.create_token_stream();\n+                *tokens = LazyTokenStream::new(self.configure_tokens(&attr_stream));\n             }\n         }\n     }\n@@ -270,16 +270,16 @@ impl<'a> StripUnconfigured<'a> {\n         if self.in_cfg(&attrs) { Some(attrs) } else { None }\n     }\n \n-    /// Performs cfg-expansion on `stream`, producing a new `AttrAnnotatedTokenStream`.\n+    /// Performs cfg-expansion on `stream`, producing a new `AttrTokenStream`.\n     /// This is only used during the invocation of `derive` proc-macros,\n     /// which require that we cfg-expand their entire input.\n     /// Normal cfg-expansion operates on parsed AST nodes via the `configure` method\n-    fn configure_tokens(&self, stream: &AttrAnnotatedTokenStream) -> AttrAnnotatedTokenStream {\n-        fn can_skip(stream: &AttrAnnotatedTokenStream) -> bool {\n+    fn configure_tokens(&self, stream: &AttrTokenStream) -> AttrTokenStream {\n+        fn can_skip(stream: &AttrTokenStream) -> bool {\n             stream.0.iter().all(|tree| match tree {\n-                AttrAnnotatedTokenTree::Attributes(_) => false,\n-                AttrAnnotatedTokenTree::Token(..) => true,\n-                AttrAnnotatedTokenTree::Delimited(_, _, inner) => can_skip(inner),\n+                AttrTokenTree::Attributes(_) => false,\n+                AttrTokenTree::Token(..) => true,\n+                AttrTokenTree::Delimited(_, _, inner) => can_skip(inner),\n             })\n         }\n \n@@ -291,35 +291,35 @@ impl<'a> StripUnconfigured<'a> {\n             .0\n             .iter()\n             .flat_map(|tree| match tree.clone() {\n-                AttrAnnotatedTokenTree::Attributes(mut data) => {\n+                AttrTokenTree::Attributes(mut data) => {\n                     data.attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n \n                     if self.in_cfg(&data.attrs) {\n                         data.tokens = LazyTokenStream::new(\n                             self.configure_tokens(&data.tokens.create_token_stream()),\n                         );\n-                        Some(AttrAnnotatedTokenTree::Attributes(data)).into_iter()\n+                        Some(AttrTokenTree::Attributes(data)).into_iter()\n                     } else {\n                         None.into_iter()\n                     }\n                 }\n-                AttrAnnotatedTokenTree::Delimited(sp, delim, mut inner) => {\n+                AttrTokenTree::Delimited(sp, delim, mut inner) => {\n                     inner = self.configure_tokens(&inner);\n-                    Some(AttrAnnotatedTokenTree::Delimited(sp, delim, inner))\n+                    Some(AttrTokenTree::Delimited(sp, delim, inner))\n                         .into_iter()\n                 }\n-                AttrAnnotatedTokenTree::Token(ref token, _) if let TokenKind::Interpolated(ref nt) = token.kind => {\n+                AttrTokenTree::Token(ref token, _) if let TokenKind::Interpolated(ref nt) = token.kind => {\n                     panic!(\n                         \"Nonterminal should have been flattened at {:?}: {:?}\",\n                         token.span, nt\n                     );\n                 }\n-                AttrAnnotatedTokenTree::Token(token, spacing) => {\n-                    Some(AttrAnnotatedTokenTree::Token(token, spacing)).into_iter()\n+                AttrTokenTree::Token(token, spacing) => {\n+                    Some(AttrTokenTree::Token(token, spacing)).into_iter()\n                 }\n             })\n             .collect();\n-        AttrAnnotatedTokenStream::new(trees)\n+        AttrTokenStream::new(trees)\n     }\n \n     /// Parse and expand all `cfg_attr` attributes into a list of attributes\n@@ -404,17 +404,17 @@ impl<'a> StripUnconfigured<'a> {\n         };\n         let pound_span = pound_token.span;\n \n-        let mut trees = vec![AttrAnnotatedTokenTree::Token(pound_token, Spacing::Alone)];\n+        let mut trees = vec![AttrTokenTree::Token(pound_token, Spacing::Alone)];\n         if attr.style == AttrStyle::Inner {\n             // For inner attributes, we do the same thing for the `!` in `#![some_attr]`\n             let TokenTree::Token(bang_token @ Token { kind: TokenKind::Not, .. }, _) = orig_trees.next().unwrap() else {\n                 panic!(\"Bad tokens for attribute {:?}\", attr);\n             };\n-            trees.push(AttrAnnotatedTokenTree::Token(bang_token, Spacing::Alone));\n+            trees.push(AttrTokenTree::Token(bang_token, Spacing::Alone));\n         }\n         // We don't really have a good span to use for the synthesized `[]`\n         // in `#[attr]`, so just use the span of the `#` token.\n-        let bracket_group = AttrAnnotatedTokenTree::Delimited(\n+        let bracket_group = AttrTokenTree::Delimited(\n             DelimSpan::from_single(pound_span),\n             Delimiter::Bracket,\n             item.tokens\n@@ -423,7 +423,7 @@ impl<'a> StripUnconfigured<'a> {\n                 .create_token_stream(),\n         );\n         trees.push(bracket_group);\n-        let tokens = Some(LazyTokenStream::new(AttrAnnotatedTokenStream::new(trees)));\n+        let tokens = Some(LazyTokenStream::new(AttrTokenStream::new(trees)));\n         let attr = attr::mk_attr_from_item(item, tokens, attr.style, item_span);\n         if attr.has_name(sym::crate_type) {\n             self.sess.parse_sess.buffer_lint("}, {"sha": "0cd742f6350243cfc5f1c505d960532fafdb2f28", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=a56d345490ed68ab57cf1854dd8978fefc9862d0", "patch": "@@ -303,7 +303,7 @@ impl<'a> Parser<'a> {\n                 // If we are currently capturing tokens, mark the location of this inner attribute.\n                 // If capturing ends up creating a `LazyTokenStream`, we will include\n                 // this replace range with it, removing the inner attribute from the final\n-                // `AttrAnnotatedTokenStream`. Inner attributes are stored in the parsed AST note.\n+                // `AttrTokenStream`. Inner attributes are stored in the parsed AST note.\n                 // During macro expansion, they are selectively inserted back into the\n                 // token stream (the first inner attribute is removed each time we invoke the\n                 // corresponding macro)."}, {"sha": "a902e57ca2aec77aaf3f00002b22a0479867e64e", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=a56d345490ed68ab57cf1854dd8978fefc9862d0", "patch": "@@ -1,7 +1,7 @@\n use super::{Capturing, FlatToken, ForceCollect, Parser, ReplaceRange, TokenCursor, TrailingToken};\n use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n-use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttributesData, CreateTokenStream};\n-use rustc_ast::tokenstream::{AttrAnnotatedTokenTree, DelimSpan, LazyTokenStream, Spacing};\n+use rustc_ast::tokenstream::{AttrTokenStream, AttributesData, CreateTokenStream};\n+use rustc_ast::tokenstream::{AttrTokenTree, DelimSpan, LazyTokenStream, Spacing};\n use rustc_ast::{self as ast};\n use rustc_ast::{AttrVec, Attribute, HasAttrs, HasTokens};\n use rustc_errors::PResult;\n@@ -100,7 +100,7 @@ struct LazyTokenStreamImpl {\n rustc_data_structures::static_assert_size!(LazyTokenStreamImpl, 144);\n \n impl CreateTokenStream for LazyTokenStreamImpl {\n-    fn create_token_stream(&self) -> AttrAnnotatedTokenStream {\n+    fn create_token_stream(&self) -> AttrTokenStream {\n         // The token produced by the final call to `{,inlined_}next` was not\n         // actually consumed by the callback. The combination of chaining the\n         // initial token and using `take` produces the desired result - we\n@@ -298,7 +298,7 @@ impl<'a> Parser<'a> {\n         // If we 'broke' the last token (e.g. breaking a '>>' token to two '>' tokens),\n         // then extend the range of captured tokens to include it, since the parser\n         // was not actually bumped past it. When the `LazyTokenStream` gets converted\n-        // into an `AttrAnnotatedTokenStream`, we will create the proper token.\n+        // into an `AttrTokenStream`, we will create the proper token.\n         if self.token_cursor.break_last_token {\n             assert_eq!(\n                 trailing,\n@@ -317,7 +317,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Grab any replace ranges that occur *inside* the current AST node.\n             // We will perform the actual replacement when we convert the `LazyTokenStream`\n-            // to an `AttrAnnotatedTokenStream`\n+            // to an `AttrTokenStream`.\n             let start_calls: u32 = cursor_snapshot_next_calls.try_into().unwrap();\n             self.capture_state.replace_ranges[replace_ranges_start..replace_ranges_end]\n                 .iter()\n@@ -392,12 +392,12 @@ impl<'a> Parser<'a> {\n fn make_token_stream(\n     mut iter: impl Iterator<Item = (FlatToken, Spacing)>,\n     break_last_token: bool,\n-) -> AttrAnnotatedTokenStream {\n+) -> AttrTokenStream {\n     #[derive(Debug)]\n     struct FrameData {\n         // This is `None` for the first frame, `Some` for all others.\n         open_delim_sp: Option<(Delimiter, Span)>,\n-        inner: Vec<AttrAnnotatedTokenTree>,\n+        inner: Vec<AttrTokenTree>,\n     }\n     let mut stack = vec![FrameData { open_delim_sp: None, inner: vec![] }];\n     let mut token_and_spacing = iter.next();\n@@ -418,8 +418,8 @@ fn make_token_stream(\n                     open_delim, span\n                 );\n                 let dspan = DelimSpan::from_pair(open_sp, span);\n-                let stream = AttrAnnotatedTokenStream::new(frame_data.inner);\n-                let delimited = AttrAnnotatedTokenTree::Delimited(dspan, delim, stream);\n+                let stream = AttrTokenStream::new(frame_data.inner);\n+                let delimited = AttrTokenTree::Delimited(dspan, delim, stream);\n                 stack\n                     .last_mut()\n                     .unwrap_or_else(|| {\n@@ -432,34 +432,33 @@ fn make_token_stream(\n                 .last_mut()\n                 .expect(\"Bottom token frame is missing!\")\n                 .inner\n-                .push(AttrAnnotatedTokenTree::Token(token, spacing)),\n+                .push(AttrTokenTree::Token(token, spacing)),\n             FlatToken::AttrTarget(data) => stack\n                 .last_mut()\n                 .expect(\"Bottom token frame is missing!\")\n                 .inner\n-                .push(AttrAnnotatedTokenTree::Attributes(data)),\n+                .push(AttrTokenTree::Attributes(data)),\n             FlatToken::Empty => {}\n         }\n         token_and_spacing = iter.next();\n     }\n     let mut final_buf = stack.pop().expect(\"Missing final buf!\");\n     if break_last_token {\n         let last_token = final_buf.inner.pop().unwrap();\n-        if let AttrAnnotatedTokenTree::Token(last_token, spacing) = last_token {\n+        if let AttrTokenTree::Token(last_token, spacing) = last_token {\n             let unglued_first = last_token.kind.break_two_token_op().unwrap().0;\n \n             // An 'unglued' token is always two ASCII characters\n             let mut first_span = last_token.span.shrink_to_lo();\n             first_span = first_span.with_hi(first_span.lo() + rustc_span::BytePos(1));\n \n-            final_buf.inner.push(AttrAnnotatedTokenTree::Token(\n-                Token::new(unglued_first, first_span),\n-                spacing,\n-            ));\n+            final_buf\n+                .inner\n+                .push(AttrTokenTree::Token(Token::new(unglued_first, first_span), spacing));\n         } else {\n             panic!(\"Unexpected last token {:?}\", last_token)\n         }\n     }\n     assert!(stack.is_empty(), \"Stack should be empty: final_buf={:?} stack={:?}\", final_buf, stack);\n-    AttrAnnotatedTokenStream::new(final_buf.inner)\n+    AttrTokenStream::new(final_buf.inner)\n }"}, {"sha": "af8f55832a22916e970f5e9ce16bea9b86fb4f1d", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a56d345490ed68ab57cf1854dd8978fefc9862d0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=a56d345490ed68ab57cf1854dd8978fefc9862d0", "patch": "@@ -170,7 +170,7 @@ pub struct ClosureSpans {\n /// attribute, we parse a nested AST node that has `#[cfg]` or `#[cfg_attr]`\n /// In this case, we use a `ReplaceRange` to replace the entire inner AST node\n /// with `FlatToken::AttrTarget`, allowing us to perform eager cfg-expansion\n-/// on an `AttrAnnotatedTokenStream`\n+/// on an `AttrTokenStream`.\n ///\n /// 2. When we parse an inner attribute while collecting tokens. We\n /// remove inner attributes from the token stream entirely, and\n@@ -183,7 +183,7 @@ pub type ReplaceRange = (Range<u32>, Vec<(FlatToken, Spacing)>);\n \n /// Controls how we capture tokens. Capturing can be expensive,\n /// so we try to avoid performing capturing in cases where\n-/// we will never need an `AttrAnnotatedTokenStream`\n+/// we will never need an `AttrTokenStream`.\n #[derive(Copy, Clone)]\n pub enum Capturing {\n     /// We aren't performing any capturing - this is the default mode.\n@@ -1464,23 +1464,23 @@ pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &Pa\n     }\n }\n \n-/// A helper struct used when building an `AttrAnnotatedTokenStream` from\n+/// A helper struct used when building an `AttrTokenStream` from\n /// a `LazyTokenStream`. Both delimiter and non-delimited tokens\n /// are stored as `FlatToken::Token`. A vector of `FlatToken`s\n-/// is then 'parsed' to build up an `AttrAnnotatedTokenStream` with nested\n-/// `AttrAnnotatedTokenTree::Delimited` tokens\n+/// is then 'parsed' to build up an `AttrTokenStream` with nested\n+/// `AttrTokenTree::Delimited` tokens.\n #[derive(Debug, Clone)]\n pub enum FlatToken {\n     /// A token - this holds both delimiter (e.g. '{' and '}')\n     /// and non-delimiter tokens\n     Token(Token),\n     /// Holds the `AttributesData` for an AST node. The\n     /// `AttributesData` is inserted directly into the\n-    /// constructed `AttrAnnotatedTokenStream` as\n-    /// an `AttrAnnotatedTokenTree::Attributes`\n+    /// constructed `AttrTokenStream` as\n+    /// an `AttrTokenTree::Attributes`.\n     AttrTarget(AttributesData),\n     /// A special 'empty' token that is ignored during the conversion\n-    /// to an `AttrAnnotatedTokenStream`. This is used to simplify the\n+    /// to an `AttrTokenStream`. This is used to simplify the\n     /// handling of replace ranges.\n     Empty,\n }"}]}