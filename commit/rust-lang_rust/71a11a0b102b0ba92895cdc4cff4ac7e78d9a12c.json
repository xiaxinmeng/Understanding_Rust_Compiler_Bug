{"sha": "71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxYTExYTBiMTAyYjBiYTkyODk1Y2RjNGNmZjRhYzdlNzhkOWExMmM=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2016-12-29T01:20:26Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2016-12-31T12:13:30Z"}, "message": "Fix transmute::<T, U> where T requires a bigger alignment than U\n\nFor transmute::<T, U> we simply pointercast the destination from a U\npointer to a T pointer, without providing any alignment information,\nthus LLVM assumes that the destination is aligned to hold a value of\ntype T, which is not necessarily true. This can lead to LLVM emitting\nmachine instructions that assume said alignment, and thus cause aborts.\n\nTo fix this, we need to provide the actual alignment to store_operand()\nand in turn to store() so they can set the proper alignment information\non the stores and LLVM can emit the proper machine instructions.\n\nFixes #32947", "tree": {"sha": "f970a3405d5ebea04f7a343e5b93a43abbf1dbe0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f970a3405d5ebea04f7a343e5b93a43abbf1dbe0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "html_url": "https://github.com/rust-lang/rust/commit/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82801b552ee8a683c40eb9fce5b892e649794648", "url": "https://api.github.com/repos/rust-lang/rust/commits/82801b552ee8a683c40eb9fce5b892e649794648", "html_url": "https://github.com/rust-lang/rust/commit/82801b552ee8a683c40eb9fce5b892e649794648"}], "stats": {"total": 162, "additions": 97, "deletions": 65}, "files": [{"sha": "e265cf747701092140e0cf50686b29d8987b3c67", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -248,11 +248,8 @@ impl ArgType {\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n                 let cast_dst = bcx.pointercast(dst, ty.ptr_to());\n-                let store = bcx.store(val, cast_dst);\n                 let llalign = llalign_of_min(ccx, self.ty);\n-                unsafe {\n-                    llvm::LLVMSetAlignment(store, llalign);\n-                }\n+                bcx.store(val, cast_dst, Some(llalign));\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -273,7 +270,7 @@ impl ArgType {\n                 base::Lifetime::Start.call(bcx, llscratch);\n \n                 // ...where we first store the value...\n-                bcx.store(val, llscratch);\n+                bcx.store(val, llscratch, None);\n \n                 // ...and then memcpy it to the intended destination.\n                 base::call_memcpy(bcx,\n@@ -289,7 +286,7 @@ impl ArgType {\n             if self.original_ty == Type::i1(ccx) {\n                 val = bcx.zext(val, Type::i8(ccx));\n             }\n-            bcx.store(val, dst);\n+            bcx.store(val, dst, None);\n         }\n     }\n "}, {"sha": "e08f29d24729cc5b21a71ea7062a956cfd6f0339", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -443,11 +443,11 @@ pub fn trans_set_discr<'a, 'tcx>(\n         layout::CEnum{ discr, min, max, .. } => {\n             assert_discr_in_range(Disr(min), Disr(max), to);\n             bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n-                  val);\n+                  val, None);\n         }\n         layout::General{ discr, .. } => {\n             bcx.store(C_integral(Type::from_integer(bcx.ccx, discr), to.0, true),\n-                  bcx.struct_gep(val, 0));\n+                  bcx.struct_gep(val, 0), None);\n         }\n         layout::Univariant { .. }\n         | layout::UntaggedUnion { .. }\n@@ -458,7 +458,7 @@ pub fn trans_set_discr<'a, 'tcx>(\n             let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             if to.0 != nndiscr {\n                 let llptrty = type_of::sizing_type_of(bcx.ccx, nnty);\n-                bcx.store(C_null(llptrty), val);\n+                bcx.store(C_null(llptrty), val, None);\n             }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref discrfield, ref nonnull, .. } => {\n@@ -476,7 +476,7 @@ pub fn trans_set_discr<'a, 'tcx>(\n                     let path = discrfield.iter().map(|&i| i as usize).collect::<Vec<_>>();\n                     let llptrptr = bcx.gepi(val, &path[..]);\n                     let llptrty = val_ty(llptrptr).element_type();\n-                    bcx.store(C_null(llptrty), llptrptr);\n+                    bcx.store(C_null(llptrty), llptrptr, None);\n                 }\n             }\n         }"}, {"sha": "05699fb9de9a532947c66a9986a28015c12e2280", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -105,7 +105,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n     let outputs = ia.outputs.iter().zip(&outputs).filter(|&(ref o, _)| !o.is_indirect);\n     for (i, (_, &(val, _))) in outputs.enumerate() {\n         let v = if num_outputs == 1 { r } else { bcx.extract_value(r, i) };\n-        bcx.store(v, val);\n+        bcx.store(v, val, None);\n     }\n \n     // Store expn_id in a metadata node so we can map LLVM errors"}, {"sha": "11cd9ab45f9075e25f85fc27457168e11bcb5e6d", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -290,7 +290,7 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 let src_f = adt::trans_field_ptr(bcx, src_ty, src, Disr(0), i);\n                 let dst_f = adt::trans_field_ptr(bcx, dst_ty, dst, Disr(0), i);\n                 if src_fty == dst_fty {\n-                    memcpy_ty(bcx, dst_f, src_f, src_fty);\n+                    memcpy_ty(bcx, dst_f, src_f, src_fty, None);\n                 } else {\n                     coerce_unsized_into(bcx, src_f, src_fty, dst_f, dst_fty);\n                 }\n@@ -429,7 +429,7 @@ pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: Valu\n         let llextra = cx.extract_value(v, abi::FAT_PTR_EXTRA);\n         store_fat_ptr(cx, lladdr, llextra, dst, t);\n     } else {\n-        cx.store(from_immediate(cx, v), dst);\n+        cx.store(from_immediate(cx, v), dst, None);\n     }\n }\n \n@@ -439,8 +439,8 @@ pub fn store_fat_ptr<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n                                dst: ValueRef,\n                                _ty: Ty<'tcx>) {\n     // FIXME: emit metadata\n-    cx.store(data, get_dataptr(cx, dst));\n-    cx.store(extra, get_meta(cx, dst));\n+    cx.store(data, get_dataptr(cx, dst), None);\n+    cx.store(extra, get_meta(cx, dst), None);\n }\n \n pub fn load_fat_ptr<'a, 'tcx>(\n@@ -523,26 +523,21 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>, dst: ValueRef, src: ValueRef, t: Ty<'tcx>\n-) {\n+pub fn memcpy_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+                           dst: ValueRef,\n+                           src: ValueRef,\n+                           t: Ty<'tcx>,\n+                           align: Option<u32>) {\n     let ccx = bcx.ccx;\n \n     if type_is_zero_size(ccx, t) {\n         return;\n     }\n \n-    if t.is_structural() {\n-        let llty = type_of::type_of(ccx, t);\n-        let llsz = llsize_of(ccx, llty);\n-        let llalign = type_of::align_of(ccx, t);\n-        call_memcpy(bcx, dst, src, llsz, llalign as u32);\n-    } else if common::type_is_fat_ptr(bcx.ccx, t) {\n-        let (data, extra) = load_fat_ptr(bcx, src, t);\n-        store_fat_ptr(bcx, data, extra, dst, t);\n-    } else {\n-        store_ty(bcx, load_ty(bcx, src, t), dst, t);\n-    }\n+    let llty = type_of::type_of(ccx, t);\n+    let llsz = llsize_of(ccx, llty);\n+    let llalign = align.unwrap_or_else(|| type_of::align_of(ccx, t));\n+    call_memcpy(bcx, dst, src, llsz, llalign as u32);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,"}, {"sha": "865787f48fc52ba93fbe1535a1972b0df3cf45ad", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -512,13 +512,17 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         value\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef, align: Option<u32>) -> ValueRef {\n         debug!(\"Store {:?} -> {:?}\", Value(val), Value(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         let ptr = self.check_store(val, ptr);\n         unsafe {\n-            llvm::LLVMBuildStore(self.llbuilder, val, ptr)\n+            let store = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n+            if let Some(align) = align {\n+                llvm::LLVMSetAlignment(store, align as c_uint);\n+            }\n+            store\n         }\n     }\n "}, {"sha": "fe28276438df9cef73b0e156b4aa614fb03d8795", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -288,8 +288,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                             let val = bcx.call(llfn, &[llargs[0], llargs[1]], None);\n                             let result = bcx.extract_value(val, 0);\n                             let overflow = bcx.zext(bcx.extract_value(val, 1), Type::bool(ccx));\n-                            bcx.store(result, bcx.struct_gep(llresult, 0));\n-                            bcx.store(overflow, bcx.struct_gep(llresult, 1));\n+                            bcx.store(result, bcx.struct_gep(llresult, 0), None);\n+                            bcx.store(overflow, bcx.struct_gep(llresult, 1), None);\n \n                             C_nil(bcx.ccx)\n                         },\n@@ -407,8 +407,8 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                             failorder, weak);\n                         let result = bcx.extract_value(val, 0);\n                         let success = bcx.zext(bcx.extract_value(val, 1), Type::bool(bcx.ccx));\n-                        bcx.store(result, bcx.struct_gep(llresult, 0));\n-                        bcx.store(success, bcx.struct_gep(llresult, 1));\n+                        bcx.store(result, bcx.struct_gep(llresult, 0), None);\n+                        bcx.store(success, bcx.struct_gep(llresult, 1), None);\n                     } else {\n                         invalid_monomorphization(sty);\n                     }\n@@ -613,7 +613,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n                     for i in 0..elems.len() {\n                         let val = bcx.extract_value(val, i);\n-                        bcx.store(val, bcx.struct_gep(llresult, i));\n+                        bcx.store(val, bcx.struct_gep(llresult, i), None);\n                     }\n                     C_nil(ccx)\n                 }\n@@ -625,10 +625,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n     if val_ty(llval) != Type::void(ccx) && machine::llsize_of_alloc(ccx, val_ty(llval)) != 0 {\n         if let Some(ty) = fn_ty.ret.cast {\n             let ptr = bcx.pointercast(llresult, ty.ptr_to());\n-            let store = bcx.store(llval, ptr);\n-            unsafe {\n-                llvm::LLVMSetAlignment(store, type_of::align_of(ccx, ret_ty));\n-            }\n+            bcx.store(llval, ptr, Some(type_of::align_of(ccx, ret_ty)));\n         } else {\n             store_ty(bcx, llval, llresult, ret_ty);\n         }\n@@ -695,7 +692,7 @@ fn try_intrinsic<'a, 'tcx>(\n ) {\n     if bcx.sess().no_landing_pads() {\n         bcx.call(func, &[data], None);\n-        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest);\n+        bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, None);\n     } else if wants_msvc_seh(bcx.sess()) {\n         trans_msvc_try(bcx, func, data, local_ptr, dest);\n     } else {\n@@ -789,8 +786,8 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         let val1 = C_i32(ccx, 1);\n         let arg2 = catchpad.load(catchpad.inbounds_gep(addr, &[val1]));\n         let local_ptr = catchpad.bitcast(local_ptr, i64p);\n-        catchpad.store(arg1, local_ptr);\n-        catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]));\n+        catchpad.store(arg1, local_ptr, None);\n+        catchpad.store(arg2, catchpad.inbounds_gep(local_ptr, &[val1]), None);\n         catchpad.catch_ret(tok, caught.llbb());\n \n         caught.ret(C_i32(ccx, 1));\n@@ -799,7 +796,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    bcx.store(ret, dest);\n+    bcx.store(ret, dest, None);\n }\n \n // Definition of the standard \"try\" function for Rust using the GNU-like model\n@@ -858,14 +855,14 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1, catch.fcx().llfn);\n         catch.add_clause(vals, C_null(Type::i8p(ccx)));\n         let ptr = catch.extract_value(vals, 0);\n-        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()));\n+        catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), None);\n         catch.ret(C_i32(ccx, 1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n     let ret = bcx.call(llfn, &[func, data, local_ptr], None);\n-    bcx.store(ret, dest);\n+    bcx.store(ret, dest, None);\n }\n \n // Helper function to give a Block to a closure to translate a shim function."}, {"sha": "f1bf2a24514f616ddc481fee0d60e1646a0d02f9", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -23,14 +23,16 @@ use consts;\n use Disr;\n use machine::{llalign_of_min, llbitsize_of_real};\n use meth;\n-use type_of;\n+use type_of::{self, align_of};\n use glue;\n use type_::Type;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::symbol::Symbol;\n \n+use std::cmp;\n+\n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n use super::constant::Const;\n@@ -207,7 +209,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n                             let llscratch = bcx.fcx().alloca(ret.original_ty, \"ret\");\n-                            self.store_operand(&bcx, llscratch, op);\n+                            self.store_operand(&bcx, llscratch, op, None);\n                             llscratch\n                         }\n                         Ref(llval) => llval\n@@ -426,7 +428,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // The first argument is a thin destination pointer.\n                     let llptr = self.trans_operand(&bcx, &args[0]).immediate();\n                     let val = self.trans_operand(&bcx, &args[1]);\n-                    self.store_operand(&bcx, llptr, val);\n+                    self.store_operand(&bcx, llptr, val, None);\n                     funclet_br(self, bcx, target);\n                     return;\n                 }\n@@ -659,7 +661,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n                     let llscratch = bcx.fcx().alloca(arg.original_ty, \"arg\");\n-                    self.store_operand(bcx, llscratch, op);\n+                    self.store_operand(bcx, llscratch, op, None);\n                     (llscratch, true)\n                 } else {\n                     (op.pack_if_pair(bcx).immediate(), false)\n@@ -801,7 +803,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.fcx.llfn);\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n-        bcx.store(llretval, slot);\n+        bcx.store(llretval, slot, None);\n         bcx.br(target.llbb());\n         bcx.llbb()\n     }\n@@ -886,7 +888,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let llty = type_of::type_of(bcx.ccx, val.ty);\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n-        self.store_operand(bcx, cast_ptr, val);\n+        let in_type = val.ty;\n+        let out_type = dst.ty.to_ty(bcx.tcx());;\n+        let llalign = cmp::min(align_of(bcx.ccx, in_type), align_of(bcx.ccx, out_type));\n+        self.store_operand(bcx, cast_ptr, val, Some(llalign));\n     }\n \n "}, {"sha": "4ce9b1bbca04b3684e2c673ef2a8ea52b504e872", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -514,7 +514,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             // environment into its components so it ends up out of bounds.\n             let env_ptr = if !env_ref {\n                 let alloc = bcx.fcx().alloca(common::val_ty(llval), \"__debuginfo_env_ptr\");\n-                bcx.store(llval, alloc);\n+                bcx.store(llval, alloc, None);\n                 alloc\n             } else {\n                 llval"}, {"sha": "a198b2b6b6dc29563f617ab958999a87c54aa392", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -244,21 +244,24 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn store_operand(&mut self,\n                          bcx: &BlockAndBuilder<'a, 'tcx>,\n                          lldest: ValueRef,\n-                         operand: OperandRef<'tcx>) {\n-        debug!(\"store_operand: operand={:?}\", operand);\n+                         operand: OperandRef<'tcx>,\n+                         align: Option<u32>) {\n+        debug!(\"store_operand: operand={:?}, align={:?}\", operand, align);\n         // Avoid generating stores of zero-sized values, because the only way to have a zero-sized\n         // value is through `undef`, and store itself is useless.\n         if common::type_is_zero_size(bcx.ccx, operand.ty) {\n             return;\n         }\n         match operand.val {\n-            OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty),\n-            OperandValue::Immediate(s) => base::store_ty(bcx, s, lldest, operand.ty),\n+            OperandValue::Ref(r) => base::memcpy_ty(bcx, lldest, r, operand.ty, align),\n+            OperandValue::Immediate(s) => {\n+                bcx.store(base::from_immediate(bcx, s), lldest, align);\n+            }\n             OperandValue::Pair(a, b) => {\n                 let a = base::from_immediate(bcx, a);\n                 let b = base::from_immediate(bcx, b);\n-                bcx.store(a, bcx.struct_gep(lldest, 0));\n-                bcx.store(b, bcx.struct_gep(lldest, 1));\n+                bcx.store(a, bcx.struct_gep(lldest, 0), align);\n+                bcx.store(b, bcx.struct_gep(lldest, 1), align);\n             }\n         }\n     }"}, {"sha": "ed64884d11aa253330b8b20c49a454c080f1941a", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -48,7 +48,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                let tr_operand = self.trans_operand(&bcx, operand);\n                // FIXME: consider not copying constants through stack. (fixable by translating\n                // constants into OperandValue::Ref, why don\u2019t we do that yet if we don\u2019t?)\n-               self.store_operand(&bcx, dest.llval, tr_operand);\n+               self.store_operand(&bcx, dest.llval, tr_operand, None);\n                bcx\n            }\n \n@@ -59,7 +59,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // into-coerce of a thin pointer to a fat pointer - just\n                     // use the operand path.\n                     let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                    self.store_operand(&bcx, dest.llval, temp);\n+                    self.store_operand(&bcx, dest.llval, temp, None);\n                     return bcx;\n                 }\n \n@@ -95,7 +95,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n-                    self.store_operand(bcx, llslot, tr_elem);\n+                    self.store_operand(bcx, llslot, tr_elem, None);\n                 })\n             }\n \n@@ -113,7 +113,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 let field_index = active_field_index.unwrap_or(i);\n                                 let lldest_i = adt::trans_field_ptr(&bcx, dest_ty, val, disr,\n                                     field_index);\n-                                self.store_operand(&bcx, lldest_i, op);\n+                                self.store_operand(&bcx, lldest_i, op, None);\n                             }\n                         }\n                     },\n@@ -138,7 +138,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     i\n                                 };\n                                 let dest = bcx.gepi(dest.llval, &[0, i]);\n-                                self.store_operand(&bcx, dest, op);\n+                                self.store_operand(&bcx, dest, op, None);\n                             }\n                         }\n                     }\n@@ -163,7 +163,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             _ => {\n                 assert!(rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n-                self.store_operand(&bcx, dest.llval, temp);\n+                self.store_operand(&bcx, dest.llval, temp, None);\n                 bcx\n             }\n         }"}, {"sha": "d0fef36efb9cd93c8e294b9e525081fa981765dc", "filename": "src/test/run-pass/issue-32947.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Ftest%2Frun-pass%2Fissue-32947.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c/src%2Ftest%2Frun-pass%2Fissue-32947.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-32947.rs?ref=71a11a0b102b0ba92895cdc4cff4ac7e78d9a12c", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_simd, test)]\n+\n+extern crate test;\n+\n+#[repr(simd)]\n+pub struct Mu64(pub u64, pub u64, pub u64, pub u64);\n+\n+fn main() {\n+    // This ensures an unaligned pointer even in optimized builds, though LLVM\n+    // gets enough type information to actually not mess things up in that case,\n+    // but at the time of writing this, it's enough to trigger the bug in\n+    // non-optimized builds\n+    unsafe {\n+        let memory = &mut [0u64; 8] as *mut _ as *mut u8;\n+        let misaligned_ptr: &mut [u8; 32] = {\n+            std::mem::transmute(memory.offset(1))\n+        };\n+        *misaligned_ptr = std::mem::transmute(Mu64(1, 1, 1, 1));\n+        test::black_box(memory);\n+    }\n+}"}]}