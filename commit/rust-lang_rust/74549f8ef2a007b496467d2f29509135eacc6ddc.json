{"sha": "74549f8ef2a007b496467d2f29509135eacc6ddc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NTQ5ZjhlZjJhMDA3YjQ5NjQ2N2QyZjI5NTA5MTM1ZWFjYzZkZGM=", "commit": {"author": {"name": "Jonathan Turner", "email": "jonathandturner@users.noreply.github.com", "date": "2016-08-17T13:25:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-17T13:25:24Z"}, "message": "Rollup merge of #35614 - srinivasreddy:syntax_ext_rustfmt, r=nikomatsakis\n\nrun rustfmt on libsyntax_ext folder", "tree": {"sha": "688460c05b026e0f3b7a1a84c54630f630ae22ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/688460c05b026e0f3b7a1a84c54630f630ae22ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74549f8ef2a007b496467d2f29509135eacc6ddc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74549f8ef2a007b496467d2f29509135eacc6ddc", "html_url": "https://github.com/rust-lang/rust/commit/74549f8ef2a007b496467d2f29509135eacc6ddc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74549f8ef2a007b496467d2f29509135eacc6ddc/comments", "author": {"login": "jonathandturner", "id": 111457284, "node_id": "O_kgDOBqS0BA", "avatar_url": "https://avatars.githubusercontent.com/u/111457284?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonathandturner", "html_url": "https://github.com/jonathandturner", "followers_url": "https://api.github.com/users/jonathandturner/followers", "following_url": "https://api.github.com/users/jonathandturner/following{/other_user}", "gists_url": "https://api.github.com/users/jonathandturner/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonathandturner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonathandturner/subscriptions", "organizations_url": "https://api.github.com/users/jonathandturner/orgs", "repos_url": "https://api.github.com/users/jonathandturner/repos", "events_url": "https://api.github.com/users/jonathandturner/events{/privacy}", "received_events_url": "https://api.github.com/users/jonathandturner/received_events", "type": "Organization", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "559bfd68e36eb1328970a803f87049bdde285d7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/559bfd68e36eb1328970a803f87049bdde285d7f", "html_url": "https://github.com/rust-lang/rust/commit/559bfd68e36eb1328970a803f87049bdde285d7f"}, {"sha": "d6526395244f533fd8cfd3bc1a86e2b5da963860", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6526395244f533fd8cfd3bc1a86e2b5da963860", "html_url": "https://github.com/rust-lang/rust/commit/d6526395244f533fd8cfd3bc1a86e2b5da963860"}], "stats": {"total": 520, "additions": 273, "deletions": 247}, "files": [{"sha": "6f368e1bc6f06ea28cc22fe9e217812acc022d48", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 38, "deletions": 40, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n- * Inline assembly support.\n- */\n+// Inline assembly support.\n+//\n use self::State::*;\n \n use syntax::ast;\n@@ -31,43 +30,48 @@ enum State {\n     Inputs,\n     Clobbers,\n     Options,\n-    StateNone\n+    StateNone,\n }\n \n impl State {\n     fn next(&self) -> State {\n         match *self {\n-            Asm       => Outputs,\n-            Outputs   => Inputs,\n-            Inputs    => Clobbers,\n-            Clobbers  => Options,\n-            Options   => StateNone,\n-            StateNone => StateNone\n+            Asm => Outputs,\n+            Outputs => Inputs,\n+            Inputs => Clobbers,\n+            Clobbers => Options,\n+            Options => StateNone,\n+            StateNone => StateNone,\n         }\n     }\n }\n \n const OPTIONS: &'static [&'static str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n-pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                       -> Box<base::MacResult+'cx> {\n+pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n+                       sp: Span,\n+                       tts: &[tokenstream::TokenTree])\n+                       -> Box<base::MacResult + 'cx> {\n     if !cx.ecfg.enable_asm() {\n-        feature_gate::emit_feature_err(\n-            &cx.parse_sess.span_diagnostic, \"asm\", sp,\n-            feature_gate::GateIssue::Language,\n-            feature_gate::EXPLAIN_ASM);\n+        feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n+                                       \"asm\",\n+                                       sp,\n+                                       feature_gate::GateIssue::Language,\n+                                       feature_gate::EXPLAIN_ASM);\n         return DummyResult::expr(sp);\n     }\n \n     // Split the tts before the first colon, to avoid `asm!(\"x\": y)`  being\n     // parsed as `asm!(z)` with `z = \"x\": y` which is type ascription.\n-    let first_colon = tts.iter().position(|tt| {\n-        match *tt {\n-            tokenstream::TokenTree::Token(_, token::Colon) |\n-            tokenstream::TokenTree::Token(_, token::ModSep) => true,\n-            _ => false\n-        }\n-    }).unwrap_or(tts.len());\n+    let first_colon = tts.iter()\n+        .position(|tt| {\n+            match *tt {\n+                tokenstream::TokenTree::Token(_, token::Colon) |\n+                tokenstream::TokenTree::Token(_, token::ModSep) => true,\n+                _ => false,\n+            }\n+        })\n+        .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(&tts[first_colon..]);\n     let mut asm = token::InternedString::new(\"\");\n     let mut asm_str_style = None;\n@@ -91,8 +95,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                 }\n                 // Nested parser, stop before the first colon (see above).\n                 let mut p2 = cx.new_parser_from_tts(&tts[..first_colon]);\n-                let (s, style) = match expr_to_string(cx, panictry!(p2.parse_expr()),\n-                                                   \"inline assembly must be a string literal\") {\n+                let (s, style) = match expr_to_string(cx,\n+                                                      panictry!(p2.parse_expr()),\n+                                                      \"inline assembly must be a string literal\") {\n                     Some((s, st)) => (s, st),\n                     // let compilation continue\n                     None => return DummyResult::expr(sp),\n@@ -109,9 +114,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                 asm_str_style = Some(style);\n             }\n             Outputs => {\n-                while p.token != token::Eof &&\n-                      p.token != token::Colon &&\n-                      p.token != token::ModSep {\n+                while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n \n                     if !outputs.is_empty() {\n                         p.eat(&token::Comma);\n@@ -136,8 +139,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                     let output = match ch.next() {\n                         Some('=') => None,\n                         Some('+') => {\n-                            Some(token::intern_and_get_ident(&format!(\n-                                        \"={}\", ch.as_str())))\n+                            Some(token::intern_and_get_ident(&format!(\"={}\", ch.as_str())))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");\n@@ -156,9 +158,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                 }\n             }\n             Inputs => {\n-                while p.token != token::Eof &&\n-                      p.token != token::Colon &&\n-                      p.token != token::ModSep {\n+                while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n \n                     if !inputs.is_empty() {\n                         p.eat(&token::Comma);\n@@ -180,9 +180,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                 }\n             }\n             Clobbers => {\n-                while p.token != token::Eof &&\n-                      p.token != token::Colon &&\n-                      p.token != token::ModSep {\n+                while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n \n                     if !clobs.is_empty() {\n                         p.eat(&token::Comma);\n@@ -218,25 +216,25 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n                     p.eat(&token::Comma);\n                 }\n             }\n-            StateNone => ()\n+            StateNone => (),\n         }\n \n         loop {\n             // MOD_SEP is a double colon '::' without space in between.\n             // When encountered, the state must be advanced twice.\n             match (&p.token, state.next(), state.next().next()) {\n-                (&token::Colon, StateNone, _)   |\n+                (&token::Colon, StateNone, _) |\n                 (&token::ModSep, _, StateNone) => {\n                     p.bump();\n                     break 'statement;\n                 }\n-                (&token::Colon, st, _)   |\n+                (&token::Colon, st, _) |\n                 (&token::ModSep, _, st) => {\n                     p.bump();\n                     state = st;\n                 }\n                 (&token::Eof, _, _) => break 'statement,\n-                _ => break\n+                _ => break,\n             }\n         }\n     }"}, {"sha": "169ef9ab7d6359f40c53ec3d54526e573df2fad2", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -23,7 +23,7 @@ use syntax_pos::Span;\n pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[tokenstream::TokenTree])\n-                       -> Box<base::MacResult+'static> {\n+                       -> Box<base::MacResult + 'static> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let cfg = panictry!(p.parse_meta_item());\n "}, {"sha": "02b44f2d012ea101f224d69969ba2a401a45e1b7", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -20,10 +20,10 @@ use std::string::String;\n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: syntax_pos::Span,\n                          tts: &[tokenstream::TokenTree])\n-                         -> Box<base::MacResult+'static> {\n+                         -> Box<base::MacResult + 'static> {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,\n-        None => return base::DummyResult::expr(sp)\n+        None => return base::DummyResult::expr(sp),\n     };\n     let mut accumulator = String::new();\n     for e in es {\n@@ -57,7 +57,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    base::MacEager::expr(cx.expr_str(\n-            sp,\n-            token::intern_and_get_ident(&accumulator[..])))\n+    base::MacEager::expr(cx.expr_str(sp, token::intern_and_get_ident(&accumulator[..])))\n }"}, {"sha": "15aaf3c78237f2410f3760df07afca52f9e9c396", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -18,8 +18,10 @@ use syntax::ptr::P;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n \n-pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n+                              sp: Span,\n+                              tts: &[TokenTree])\n+                              -> Box<base::MacResult + 'cx> {\n     if !cx.ecfg.enable_concat_idents() {\n         feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n                                        \"concat_idents\",\n@@ -33,35 +35,40 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {\n             match *e {\n-                TokenTree::Token(_, token::Comma) => {},\n+                TokenTree::Token(_, token::Comma) => {}\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! expecting comma.\");\n                     return DummyResult::expr(sp);\n-                },\n+                }\n             }\n         } else {\n             match *e {\n-                TokenTree::Token(_, token::Ident(ident)) => {\n-                    res_str.push_str(&ident.name.as_str())\n-                },\n+                TokenTree::Token(_, token::Ident(ident)) => res_str.push_str(&ident.name.as_str()),\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");\n                     return DummyResult::expr(sp);\n-                },\n+                }\n             }\n         }\n     }\n     let res = str_to_ident(&res_str);\n \n-    struct Result { ident: ast::Ident, span: Span };\n+    struct Result {\n+        ident: ast::Ident,\n+        span: Span,\n+    };\n \n     impl Result {\n         fn path(&self) -> ast::Path {\n             let segment = ast::PathSegment {\n                 identifier: self.ident,\n-                parameters: ast::PathParameters::none()\n+                parameters: ast::PathParameters::none(),\n             };\n-            ast::Path { span: self.span, global: false, segments: vec![segment] }\n+            ast::Path {\n+                span: self.span,\n+                global: false,\n+                segments: vec![segment],\n+            }\n         }\n     }\n \n@@ -84,5 +91,8 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[TokenTree])\n         }\n     }\n \n-    Box::new(Result { ident: res, span: sp })\n+    Box::new(Result {\n+        ident: res,\n+        span: sp,\n+    })\n }"}, {"sha": "356c54fcf31202299bac568cee529e21d418f536", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 70, "deletions": 63, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -36,20 +36,20 @@ pub enum PtrTy<'a> {\n /// for type parameters and a lifetime.\n #[derive(Clone, Eq, PartialEq)]\n pub struct Path<'a> {\n-    pub path: Vec<&'a str> ,\n+    pub path: Vec<&'a str>,\n     pub lifetime: Option<&'a str>,\n     pub params: Vec<Box<Ty<'a>>>,\n     pub global: bool,\n }\n \n impl<'a> Path<'a> {\n-    pub fn new<'r>(path: Vec<&'r str> ) -> Path<'r> {\n+    pub fn new<'r>(path: Vec<&'r str>) -> Path<'r> {\n         Path::new_(path, None, Vec::new(), true)\n     }\n     pub fn new_local<'r>(path: &'r str) -> Path<'r> {\n-        Path::new_(vec!( path ), None, Vec::new(), false)\n+        Path::new_(vec![path], None, Vec::new(), false)\n     }\n-    pub fn new_<'r>(path: Vec<&'r str> ,\n+    pub fn new_<'r>(path: Vec<&'r str>,\n                     lifetime: Option<&'r str>,\n                     params: Vec<Box<Ty<'r>>>,\n                     global: bool)\n@@ -58,7 +58,7 @@ impl<'a> Path<'a> {\n             path: path,\n             lifetime: lifetime,\n             params: params,\n-            global: global\n+            global: global,\n         }\n     }\n \n@@ -94,7 +94,7 @@ pub enum Ty<'a> {\n     /// parameter, and things like `i32`\n     Literal(Path<'a>),\n     /// includes unit\n-    Tuple(Vec<Ty<'a>> )\n+    Tuple(Vec<Ty<'a>>),\n }\n \n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n@@ -119,14 +119,14 @@ pub fn nil_ty<'r>() -> Ty<'r> {\n fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n     match *lt {\n         Some(ref s) => Some(cx.lifetime(span, cx.ident_of(*s).name)),\n-        None => None\n+        None => None,\n     }\n }\n \n fn mk_lifetimes(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Vec<ast::Lifetime> {\n     match *lt {\n-        Some(ref s) => vec!(cx.lifetime(span, cx.ident_of(*s).name)),\n-        None => vec!()\n+        Some(ref s) => vec![cx.lifetime(span, cx.ident_of(*s).name)],\n+        None => vec![],\n     }\n }\n \n@@ -145,13 +145,11 @@ impl<'a> Ty<'a> {\n                         let lt = mk_lifetime(cx, span, lt);\n                         cx.ty_rptr(span, raw_ty, lt, mutbl)\n                     }\n-                    Raw(mutbl) => cx.ty_ptr(span, raw_ty, mutbl)\n+                    Raw(mutbl) => cx.ty_ptr(span, raw_ty, mutbl),\n                 }\n             }\n-            Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n-            Self_  => {\n-                cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n-            }\n+            Literal(ref p) => p.to_ty(cx, span, self_ty, self_generics),\n+            Self_ => cx.ty_path(self.to_path(cx, span, self_ty, self_generics)),\n             Tuple(ref fields) => {\n                 let ty = ast::TyKind::Tup(fields.iter()\n                     .map(|f| f.to_ty(cx, span, self_ty, self_generics))\n@@ -169,20 +167,25 @@ impl<'a> Ty<'a> {\n                    -> ast::Path {\n         match *self {\n             Self_ => {\n-                let self_params = self_generics.ty_params.iter().map(|ty_param| {\n-                    cx.ty_ident(span, ty_param.ident)\n-                }).collect();\n-                let lifetimes = self_generics.lifetimes.iter()\n-                                                       .map(|d| d.lifetime)\n-                                                       .collect();\n+                let self_params = self_generics.ty_params\n+                    .iter()\n+                    .map(|ty_param| cx.ty_ident(span, ty_param.ident))\n+                    .collect();\n+                let lifetimes = self_generics.lifetimes\n+                    .iter()\n+                    .map(|d| d.lifetime)\n+                    .collect();\n \n-                cx.path_all(span, false, vec![self_ty], lifetimes, self_params, Vec::new())\n-            }\n-            Literal(ref p) => {\n-                p.to_path(cx, span, self_ty, self_generics)\n+                cx.path_all(span,\n+                            false,\n+                            vec![self_ty],\n+                            lifetimes,\n+                            self_params,\n+                            Vec::new())\n             }\n-            Ptr(..) => { cx.span_bug(span, \"pointer in a path in generic `derive`\") }\n-            Tuple(..) => { cx.span_bug(span, \"tuple in a path in generic `derive`\") }\n+            Literal(ref p) => p.to_path(cx, span, self_ty, self_generics),\n+            Ptr(..) => cx.span_bug(span, \"pointer in a path in generic `derive`\"),\n+            Tuple(..) => cx.span_bug(span, \"tuple in a path in generic `derive`\"),\n         }\n     }\n }\n@@ -195,16 +198,16 @@ fn mk_ty_param(cx: &ExtCtxt,\n                self_ident: Ident,\n                self_generics: &Generics)\n                -> ast::TyParam {\n-    let bounds =\n-        bounds.iter().map(|b| {\n+    let bounds = bounds.iter()\n+        .map(|b| {\n             let path = b.to_path(cx, span, self_ident, self_generics);\n             cx.typarambound(path)\n-        }).collect();\n+        })\n+        .collect();\n     cx.typaram(span, cx.ident_of(name), bounds, None)\n }\n \n-fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>)\n-               -> Generics {\n+fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>) -> Generics {\n     Generics {\n         lifetimes: lifetimes,\n         ty_params: P::from_vec(ty_params),\n@@ -225,7 +228,8 @@ pub struct LifetimeBounds<'a> {\n impl<'a> LifetimeBounds<'a> {\n     pub fn empty() -> LifetimeBounds<'a> {\n         LifetimeBounds {\n-            lifetimes: Vec::new(), bounds: Vec::new()\n+            lifetimes: Vec::new(),\n+            bounds: Vec::new(),\n         }\n     }\n     pub fn to_generics(&self,\n@@ -234,46 +238,49 @@ impl<'a> LifetimeBounds<'a> {\n                        self_ty: Ident,\n                        self_generics: &Generics)\n                        -> Generics {\n-        let lifetimes = self.lifetimes.iter().map(|&(ref lt, ref bounds)| {\n-            let bounds =\n-                bounds.iter().map(\n-                    |b| cx.lifetime(span, cx.ident_of(*b).name)).collect();\n-            cx.lifetime_def(span, cx.ident_of(*lt).name, bounds)\n-        }).collect();\n-        let ty_params = self.bounds.iter().map(|t| {\n-            match *t {\n-                (ref name, ref bounds) => {\n-                    mk_ty_param(cx,\n-                                span,\n-                                *name,\n-                                bounds,\n-                                self_ty,\n-                                self_generics)\n+        let lifetimes = self.lifetimes\n+            .iter()\n+            .map(|&(ref lt, ref bounds)| {\n+                let bounds = bounds.iter()\n+                    .map(|b| cx.lifetime(span, cx.ident_of(*b).name))\n+                    .collect();\n+                cx.lifetime_def(span, cx.ident_of(*lt).name, bounds)\n+            })\n+            .collect();\n+        let ty_params = self.bounds\n+            .iter()\n+            .map(|t| {\n+                match *t {\n+                    (ref name, ref bounds) => {\n+                        mk_ty_param(cx, span, *name, bounds, self_ty, self_generics)\n+                    }\n                 }\n-            }\n-        }).collect();\n+            })\n+            .collect();\n         mk_generics(lifetimes, ty_params)\n     }\n }\n \n-pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n-    -> (P<Expr>, ast::ExplicitSelf) {\n+pub fn get_explicit_self(cx: &ExtCtxt,\n+                         span: Span,\n+                         self_ptr: &Option<PtrTy>)\n+                         -> (P<Expr>, ast::ExplicitSelf) {\n     // this constructs a fresh `self` path\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n-        None => {\n-            (self_path, respan(span, SelfKind::Value(ast::Mutability::Immutable)))\n-        }\n+        None => (self_path, respan(span, SelfKind::Value(ast::Mutability::Immutable))),\n         Some(ref ptr) => {\n-            let self_ty = respan(\n-                span,\n-                match *ptr {\n-                    Borrowed(ref lt, mutbl) => {\n-                        let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        SelfKind::Region(lt, mutbl)\n-                    }\n-                    Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\")\n-                });\n+            let self_ty =\n+                respan(span,\n+                       match *ptr {\n+                           Borrowed(ref lt, mutbl) => {\n+                               let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n+                               SelfKind::Region(lt, mutbl)\n+                           }\n+                           Raw(_) => {\n+                               cx.span_bug(span, \"attempted to use *self in deriving definition\")\n+                           }\n+                       });\n             let self_expr = cx.expr_deref(span, self_path);\n             (self_expr, self_ty)\n         }"}, {"sha": "aee86b246b9852dd61f10337428ea07164a5012e", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -10,7 +10,7 @@\n \n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use syntax::ast::{MetaItem, self};\n+use syntax::ast::{self, MetaItem};\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n@@ -99,11 +99,11 @@ fn expand_derive(cx: &mut ExtCtxt,\n \n             for titem in traits.iter().rev() {\n                 let tname = if titem.is_word() {\n-                                titem.name() }\n-                            else {\n-                                cx.span_err(titem.span, \"malformed `derive` entry\");\n-                                continue;\n-                            };\n+                    titem.name()\n+                } else {\n+                    cx.span_err(titem.span, \"malformed `derive` entry\");\n+                    continue;\n+                };\n \n                 if !(is_builtin_trait(&tname) || cx.ecfg.enable_custom_derive()) {\n                     feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,"}, {"sha": "5c081b98962e310345110f2b5efe7561a97d2c70", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*\n- * The compiler code necessary to support the env! extension.  Eventually this\n- * should all get sucked into either the compiler syntax extension plugin\n- * interface.\n- */\n+// The compiler code necessary to support the env! extension.  Eventually this\n+// should all get sucked into either the compiler syntax extension plugin\n+// interface.\n+//\n \n use syntax::ast;\n use syntax::ext::base::*;\n@@ -24,66 +23,61 @@ use syntax::tokenstream;\n \n use std::env;\n \n-pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n+                              sp: Span,\n+                              tts: &[tokenstream::TokenTree])\n+                              -> Box<base::MacResult + 'cx> {\n     let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n         None => return DummyResult::expr(sp),\n-        Some(v) => v\n+        Some(v) => v,\n     };\n \n     let e = match env::var(&var[..]) {\n-      Err(..) => {\n-          cx.expr_path(cx.path_all(sp,\n-                                   true,\n-                                   cx.std_path(&[\"option\", \"Option\", \"None\"]),\n-                                   Vec::new(),\n-                                   vec!(cx.ty_rptr(sp,\n-                                                   cx.ty_ident(sp,\n-                                                        cx.ident_of(\"str\")),\n-                                                   Some(cx.lifetime(sp,\n-                                                        cx.ident_of(\n-                                                            \"'static\").name)),\n-                                                   ast::Mutability::Immutable)),\n-                                   Vec::new()))\n-      }\n-      Ok(s) => {\n-          cx.expr_call_global(sp,\n-                              cx.std_path(&[\"option\", \"Option\", \"Some\"]),\n-                              vec!(cx.expr_str(sp,\n-                                               token::intern_and_get_ident(\n-                                          &s[..]))))\n-      }\n+        Err(..) => {\n+            cx.expr_path(cx.path_all(sp,\n+                                     true,\n+                                     cx.std_path(&[\"option\", \"Option\", \"None\"]),\n+                                     Vec::new(),\n+                                     vec![cx.ty_rptr(sp,\n+                                                     cx.ty_ident(sp, cx.ident_of(\"str\")),\n+                                                     Some(cx.lifetime(sp,\n+                                                                      cx.ident_of(\"'static\")\n+                                                                          .name)),\n+                                                     ast::Mutability::Immutable)],\n+                                     Vec::new()))\n+        }\n+        Ok(s) => {\n+            cx.expr_call_global(sp,\n+                                cx.std_path(&[\"option\", \"Option\", \"Some\"]),\n+                                vec![cx.expr_str(sp, token::intern_and_get_ident(&s[..]))])\n+        }\n     };\n     MacEager::expr(e)\n }\n \n-pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                       -> Box<base::MacResult+'cx> {\n+pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n+                       sp: Span,\n+                       tts: &[tokenstream::TokenTree])\n+                       -> Box<base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::expr(sp);\n         }\n         None => return DummyResult::expr(sp),\n-        Some(exprs) => exprs.into_iter()\n+        Some(exprs) => exprs.into_iter(),\n     };\n \n-    let var = match expr_to_string(cx,\n-                                exprs.next().unwrap(),\n-                                \"expected string literal\") {\n+    let var = match expr_to_string(cx, exprs.next().unwrap(), \"expected string literal\") {\n         None => return DummyResult::expr(sp),\n-        Some((v, _style)) => v\n+        Some((v, _style)) => v,\n     };\n     let msg = match exprs.next() {\n-        None => {\n-            token::intern_and_get_ident(&format!(\"environment variable `{}` \\\n-                                                 not defined\",\n-                                                var))\n-        }\n+        None => token::intern_and_get_ident(&format!(\"environment variable `{}` not defined\", var)),\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n                 None => return DummyResult::expr(sp),\n-                Some((s, _style)) => s\n+                Some((s, _style)) => s,\n             }\n         }\n     };\n@@ -98,7 +92,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n             cx.span_err(sp, &msg);\n             cx.expr_usize(sp, 0)\n         }\n-        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s))\n+        Ok(s) => cx.expr_str(sp, token::intern_and_get_ident(&s)),\n     };\n     MacEager::expr(e)\n }"}, {"sha": "06b16095d1963bff451224a30393abc37753aa55", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 89, "deletions": 68, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -37,7 +37,7 @@ enum Position {\n     Named(String),\n }\n \n-struct Context<'a, 'b:'a> {\n+struct Context<'a, 'b: 'a> {\n     ecx: &'a mut ExtCtxt<'b>,\n     /// The macro's call site. References to unstable formatting internals must\n     /// use this span to pass the stability checker.\n@@ -120,7 +120,9 @@ struct Context<'a, 'b:'a> {\n /// ```ignore\n /// Some((fmtstr, parsed arguments, index map for named arguments))\n /// ```\n-fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n+fn parse_args(ecx: &mut ExtCtxt,\n+              sp: Span,\n+              tts: &[tokenstream::TokenTree])\n               -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, HashMap<String, usize>)> {\n     let mut args = Vec::<P<ast::Expr>>::new();\n     let mut names = HashMap::<String, usize>::new();\n@@ -138,7 +140,9 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n             ecx.span_err(sp, \"expected token: `,`\");\n             return None;\n         }\n-        if p.token == token::Eof { break } // accept trailing commas\n+        if p.token == token::Eof {\n+            break;\n+        } // accept trailing commas\n         if named || (p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq)) {\n             named = true;\n             let ident = match p.token {\n@@ -155,7 +159,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                 _ => {\n                     ecx.span_err(p.span,\n                                  &format!(\"expected ident for named argument, found `{}`\",\n-                                         p.this_token_to_string()));\n+                                          p.this_token_to_string()));\n                     return None;\n                 }\n             };\n@@ -164,9 +168,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n             panictry!(p.expect(&token::Eq));\n             let e = panictry!(p.parse_expr());\n             if let Some(prev) = names.get(name) {\n-                ecx.struct_span_err(e.span,\n-                                    &format!(\"duplicate argument named `{}`\",\n-                                             name))\n+                ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", name))\n                     .span_note(args[*prev].span, \"previously here\")\n                     .emit();\n                 continue;\n@@ -235,7 +237,8 @@ impl<'a, 'b> Context<'a, 'b> {\n \n     fn verify_count(&mut self, c: parse::Count) {\n         match c {\n-            parse::CountImplied | parse::CountIs(..) => {}\n+            parse::CountImplied |\n+            parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n                 self.verify_arg_type(Exact(i), Count);\n             }\n@@ -260,7 +263,8 @@ impl<'a, 'b> Context<'a, 'b> {\n             Exact(arg) => {\n                 if self.args.len() <= arg {\n                     let msg = format!(\"invalid reference to argument `{}` ({})\",\n-                                      arg, self.describe_num_args());\n+                                      arg,\n+                                      self.describe_num_args());\n \n                     self.ecx.span_err(self.fmtsp, &msg[..]);\n                     return;\n@@ -394,9 +398,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                                 let arg = self.ecx.expr_usize(sp, i);\n                                 self.ecx.expr_call_global(sp, path, vec![arg])\n                             }\n-                            None => {\n-                                self.ecx.expr_path(self.ecx.path_global(sp, path))\n-                            }\n+                            None => self.ecx.expr_path(self.ecx.path_global(sp, path)),\n                         }\n                     };\n                     match arg.position {\n@@ -436,11 +438,14 @@ impl<'a, 'b> Context<'a, 'b> {\n                         flags: 0,\n                         precision: parse::CountImplied,\n                         width: parse::CountImplied,\n-                        ty: arg.format.ty\n-                    }\n+                        ty: arg.format.ty,\n+                    },\n                 };\n \n-                let fill = match arg.format.fill { Some(c) => c, None => ' ' };\n+                let fill = match arg.format.fill {\n+                    Some(c) => c,\n+                    None => ' ',\n+                };\n \n                 if *arg != simple_arg || fill != ' ' {\n                     self.all_pieces_simple = false;\n@@ -464,17 +469,33 @@ impl<'a, 'b> Context<'a, 'b> {\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n-                let fmt = self.ecx.expr_struct(sp, path, vec!(\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width)));\n+                let fmt =\n+                    self.ecx.expr_struct(sp,\n+                                         path,\n+                                         vec![self.ecx\n+                                                  .field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n+                                              self.ecx.field_imm(sp,\n+                                                                 self.ecx.ident_of(\"align\"),\n+                                                                 align),\n+                                              self.ecx.field_imm(sp,\n+                                                                 self.ecx.ident_of(\"flags\"),\n+                                                                 flags),\n+                                              self.ecx.field_imm(sp,\n+                                                                 self.ecx.ident_of(\"precision\"),\n+                                                                 prec),\n+                                              self.ecx.field_imm(sp,\n+                                                                 self.ecx.ident_of(\"width\"),\n+                                                                 width)]);\n \n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"Argument\"));\n-                Some(self.ecx.expr_struct(sp, path, vec!(\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt))))\n+                Some(self.ecx.expr_struct(sp,\n+                                          path,\n+                                          vec![self.ecx.field_imm(sp,\n+                                                                  self.ecx.ident_of(\"position\"),\n+                                                                  pos),\n+                                               self.ecx.field_imm(sp,\n+                                                                  self.ecx.ident_of(\"format\"),\n+                                                                  fmt)]))\n             }\n         }\n     }\n@@ -486,9 +507,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                     -> P<ast::Expr> {\n         let sp = piece_ty.span;\n         let ty = ecx.ty_rptr(sp,\n-            ecx.ty(sp, ast::TyKind::Vec(piece_ty)),\n-            Some(ecx.lifetime(sp, keywords::StaticLifetime.name())),\n-            ast::Mutability::Immutable);\n+                             ecx.ty(sp, ast::TyKind::Vec(piece_ty)),\n+                             Some(ecx.lifetime(sp, keywords::StaticLifetime.name())),\n+                             ast::Mutability::Immutable);\n         let slice = ecx.expr_vec_slice(sp, pieces);\n         // static instead of const to speed up codegen by not requiring this to be inlined\n         let st = ast::ItemKind::Static(ty, ast::Mutability::Immutable, slice);\n@@ -516,15 +537,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         // First, build up the static array which will become our precompiled\n         // format \"string\"\n         let static_lifetime = self.ecx.lifetime(self.fmtsp, keywords::StaticLifetime.name());\n-        let piece_ty = self.ecx.ty_rptr(\n-                self.fmtsp,\n-                self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n-                Some(static_lifetime),\n-                ast::Mutability::Immutable);\n-        let pieces = Context::static_array(self.ecx,\n-                                           \"__STATIC_FMTSTR\",\n-                                           piece_ty,\n-                                           self.str_pieces);\n+        let piece_ty = self.ecx.ty_rptr(self.fmtsp,\n+                                        self.ecx.ty_ident(self.fmtsp, self.ecx.ident_of(\"str\")),\n+                                        Some(static_lifetime),\n+                                        ast::Mutability::Immutable);\n+        let pieces = Context::static_array(self.ecx, \"__STATIC_FMTSTR\", piece_ty, self.str_pieces);\n \n         // Before consuming the expressions, we have to remember spans for\n         // count arguments as they are now generated separate from other\n@@ -542,7 +559,10 @@ impl<'a, 'b> Context<'a, 'b> {\n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(DUMMY_SP, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n-                locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n+                locals.push(Context::format_arg(self.ecx,\n+                                                self.macsp,\n+                                                e.span,\n+                                                arg_ty,\n                                                 self.ecx.expr_ident(e.span, name)));\n             }\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n@@ -556,7 +576,10 @@ impl<'a, 'b> Context<'a, 'b> {\n                 Exact(i) => spans_pos[i],\n                 _ => panic!(\"should never happen\"),\n             };\n-            counts.push(Context::format_arg(self.ecx, self.macsp, span, &Count,\n+            counts.push(Context::format_arg(self.ecx,\n+                                            self.macsp,\n+                                            span,\n+                                            &Count,\n                                             self.ecx.expr_ident(span, name)));\n         }\n \n@@ -593,9 +616,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         // But the nested match expression is proved to perform not as well\n         // as series of let's; the first approach does.\n         let pat = self.ecx.pat_tuple(self.fmtsp, pats);\n-        let arm = self.ecx.arm(self.fmtsp, vec!(pat), args_array);\n+        let arm = self.ecx.arm(self.fmtsp, vec![pat], args_array);\n         let head = self.ecx.expr(self.fmtsp, ast::ExprKind::Tup(heads));\n-        let result = self.ecx.expr_match(self.fmtsp, head, vec!(arm));\n+        let result = self.ecx.expr_match(self.fmtsp, head, vec![arm]);\n \n         let args_slice = self.ecx.expr_addr_of(self.fmtsp, result);\n \n@@ -605,13 +628,9 @@ impl<'a, 'b> Context<'a, 'b> {\n         } else {\n             // Build up the static array which will store our precompiled\n             // nonstandard placeholders, if there are any.\n-            let piece_ty = self.ecx.ty_path(self.ecx.path_global(\n-                    self.macsp,\n-                    Context::rtpath(self.ecx, \"Argument\")));\n-            let fmt = Context::static_array(self.ecx,\n-                                            \"__STATIC_FMTARGS\",\n-                                            piece_ty,\n-                                            self.pieces);\n+            let piece_ty = self.ecx\n+                .ty_path(self.ecx.path_global(self.macsp, Context::rtpath(self.ecx, \"Argument\")));\n+            let fmt = Context::static_array(self.ecx, \"__STATIC_FMTARGS\", piece_ty, self.pieces);\n \n             (\"new_v1_formatted\", vec![pieces, args_slice, fmt])\n         };\n@@ -620,13 +639,16 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_call_global(self.macsp, path, fn_args)\n     }\n \n-    fn format_arg(ecx: &ExtCtxt, macsp: Span, sp: Span,\n-                  ty: &ArgumentType, arg: P<ast::Expr>)\n+    fn format_arg(ecx: &ExtCtxt,\n+                  macsp: Span,\n+                  sp: Span,\n+                  ty: &ArgumentType,\n+                  arg: P<ast::Expr>)\n                   -> P<ast::Expr> {\n         let trait_ = match *ty {\n             Placeholder(ref tyname) => {\n                 match &tyname[..] {\n-                    \"\"  => \"Display\",\n+                    \"\" => \"Display\",\n                     \"?\" => \"Debug\",\n                     \"e\" => \"LowerExp\",\n                     \"E\" => \"UpperExp\",\n@@ -636,16 +658,14 @@ impl<'a, 'b> Context<'a, 'b> {\n                     \"x\" => \"LowerHex\",\n                     \"X\" => \"UpperHex\",\n                     _ => {\n-                        ecx.span_err(sp,\n-                                     &format!(\"unknown format trait `{}`\",\n-                                             *tyname));\n+                        ecx.span_err(sp, &format!(\"unknown format trait `{}`\", *tyname));\n                         \"Dummy\"\n                     }\n                 }\n             }\n             Count => {\n                 let path = ecx.std_path(&[\"fmt\", \"ArgumentV1\", \"from_usize\"]);\n-                return ecx.expr_call_global(macsp, path, vec![arg])\n+                return ecx.expr_call_global(macsp, path, vec![arg]);\n             }\n         };\n \n@@ -656,22 +676,23 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n }\n \n-pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n+pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt,\n+                               sp: Span,\n                                tts: &[tokenstream::TokenTree])\n-                               -> Box<base::MacResult+'cx> {\n+                               -> Box<base::MacResult + 'cx> {\n \n     match parse_args(ecx, sp, tts) {\n         Some((efmt, args, names)) => {\n-            MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt,\n-                                                      args, names))\n+            MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names))\n         }\n-        None => DummyResult::expr(sp)\n+        None => DummyResult::expr(sp),\n     }\n }\n \n /// Take the various parts of `format_args!(efmt, args..., name=names...)`\n /// and construct the appropriate formatting expression.\n-pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n+pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n+                                    sp: Span,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n                                     names: HashMap<String, usize>)\n@@ -704,11 +725,9 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         macsp: macsp,\n         fmtsp: efmt.span,\n     };\n-    let fmt = match expr_to_string(cx.ecx,\n-                                   efmt,\n-                                   \"format argument must be a string literal.\") {\n+    let fmt = match expr_to_string(cx.ecx, efmt, \"format argument must be a string literal.\") {\n         Some((fmt, _)) => fmt,\n-        None => return DummyResult::raw_expr(sp)\n+        None => return DummyResult::raw_expr(sp),\n     };\n \n     let mut parser = parse::Parser::new(&fmt);\n@@ -717,12 +736,14 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     loop {\n         match parser.next() {\n             Some(mut piece) => {\n-                if !parser.errors.is_empty() { break }\n+                if !parser.errors.is_empty() {\n+                    break;\n+                }\n                 cx.verify_piece(&piece);\n                 cx.resolve_name_inplace(&mut piece);\n                 pieces.push(piece);\n             }\n-            None => break\n+            None => break,\n         }\n     }\n \n@@ -738,8 +759,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n \n     if !parser.errors.is_empty() {\n-        cx.ecx.span_err(cx.fmtsp, &format!(\"invalid format string: {}\",\n-                                          parser.errors.remove(0)));\n+        cx.ecx.span_err(cx.fmtsp,\n+                        &format!(\"invalid format string: {}\", parser.errors.remove(0)));\n         return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {"}, {"sha": "3aa62339b477efac75e4313fa5fa2b9ce54eb0f7", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -23,7 +23,8 @@\n #![feature(staged_api)]\n \n extern crate fmt_macros;\n-#[macro_use] extern crate log;\n+#[macro_use]\n+extern crate log;\n #[macro_use]\n extern crate syntax;\n extern crate syntax_pos;\n@@ -52,16 +53,13 @@ pub fn register_builtins(env: &mut SyntaxEnv) {\n         NormalTT(Box::new(f), None, false)\n     }\n \n-    env.insert(intern(\"asm\"),\n-               builtin_normal_expander(asm::expand_asm));\n-    env.insert(intern(\"cfg\"),\n-               builtin_normal_expander(cfg::expand_cfg));\n+    env.insert(intern(\"asm\"), builtin_normal_expander(asm::expand_asm));\n+    env.insert(intern(\"cfg\"), builtin_normal_expander(cfg::expand_cfg));\n     env.insert(intern(\"concat\"),\n                builtin_normal_expander(concat::expand_syntax_ext));\n     env.insert(intern(\"concat_idents\"),\n                builtin_normal_expander(concat_idents::expand_syntax_ext));\n-    env.insert(intern(\"env\"),\n-               builtin_normal_expander(env::expand_env));\n+    env.insert(intern(\"env\"), builtin_normal_expander(env::expand_env));\n     env.insert(intern(\"option_env\"),\n                builtin_normal_expander(env::expand_option_env));\n     env.insert(intern(\"format_args\"),"}, {"sha": "7242b9865a92c73e4b634e0090689d6feb856cb1", "filename": "src/libsyntax_ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flog_syntax.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -17,7 +17,7 @@ use syntax_pos;\n pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt,\n                               sp: syntax_pos::Span,\n                               tts: &[tokenstream::TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+                              -> Box<base::MacResult + 'cx> {\n     if !cx.ecfg.enable_log_syntax() {\n         feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n                                        \"log_syntax\","}, {"sha": "794169ae3429cd9d19c01928fe413dee00af944b", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74549f8ef2a007b496467d2f29509135eacc6ddc/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=74549f8ef2a007b496467d2f29509135eacc6ddc", "patch": "@@ -18,7 +18,7 @@ use syntax::tokenstream::TokenTree;\n pub fn expand_trace_macros(cx: &mut ExtCtxt,\n                            sp: Span,\n                            tt: &[TokenTree])\n-                           -> Box<base::MacResult+'static> {\n+                           -> Box<base::MacResult + 'static> {\n     if !cx.ecfg.enable_trace_macros() {\n         feature_gate::emit_feature_err(&cx.parse_sess.span_diagnostic,\n                                        \"trace_macros\","}]}