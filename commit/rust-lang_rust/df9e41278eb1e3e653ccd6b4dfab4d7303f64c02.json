{"sha": "df9e41278eb1e3e653ccd6b4dfab4d7303f64c02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmOWU0MTI3OGViMWUzZTY1M2NjZDZiNGRmYWI0ZDczMDNmNjRjMDI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-18T00:47:10Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-18T00:54:32Z"}, "message": "core: Wire up `stream` to newsched", "tree": {"sha": "440984f7869286692b266c5a9d95dced081f9882", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/440984f7869286692b266c5a9d95dced081f9882"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02", "html_url": "https://github.com/rust-lang/rust/commit/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26becc308e4b9a0f5be1c7c2895c7761b778e01f", "url": "https://api.github.com/repos/rust-lang/rust/commits/26becc308e4b9a0f5be1c7c2895c7761b778e01f", "html_url": "https://github.com/rust-lang/rust/commit/26becc308e4b9a0f5be1c7c2895c7761b778e01f"}], "stats": {"total": 599, "additions": 357, "deletions": 242}, "files": [{"sha": "59eb915c239fee0ee376ccce41434a602b999d22", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 219, "deletions": 130, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=df9e41278eb1e3e653ccd6b4dfab4d7303f64c02", "patch": "@@ -25,7 +25,7 @@ use unstable::sync::{Exclusive, exclusive};\n use rtcomm = rt::comm;\n use rt;\n \n-use pipes::{recv, try_recv, wait_many, peek, PacketHeader};\n+use pipes::{wait_many, PacketHeader};\n \n // FIXME #5160: Making this public exposes some plumbing from\n // pipes. Needs some refactoring\n@@ -61,76 +61,14 @@ pub trait Peekable<T> {\n     fn peek(&self) -> bool;\n }\n \n-\n-// Streams - Make pipes a little easier in general.\n-\n-/*proto! streamp (\n-    Open:send<T: Owned> {\n-        data(T) -> Open<T>\n-    }\n-)*/\n-\n-#[allow(non_camel_case_types)]\n-pub mod streamp {\n-    priv use core::kinds::Owned;\n-\n-    pub fn init<T: Owned>() -> (client::Open<T>, server::Open<T>) {\n-        pub use core::pipes::HasBuffer;\n-        ::core::pipes::entangle()\n-    }\n-\n-    #[allow(non_camel_case_types)]\n-    pub enum Open<T> { pub data(T, server::Open<T>), }\n-\n-    #[allow(non_camel_case_types)]\n-    pub mod client {\n-        priv use core::kinds::Owned;\n-\n-        #[allow(non_camel_case_types)]\n-        pub fn try_data<T: Owned>(pipe: Open<T>, x_0: T) ->\n-            ::core::option::Option<Open<T>> {\n-            {\n-                use super::data;\n-                let (c, s) = ::core::pipes::entangle();\n-                let message = data(x_0, s);\n-                if ::core::pipes::send(pipe, message) {\n-                    ::core::pipes::rt::make_some(c)\n-                } else { ::core::pipes::rt::make_none() }\n-            }\n-        }\n-\n-        #[allow(non_camel_case_types)]\n-        pub fn data<T: Owned>(pipe: Open<T>, x_0: T) -> Open<T> {\n-            {\n-                use super::data;\n-                let (c, s) = ::core::pipes::entangle();\n-                let message = data(x_0, s);\n-                ::core::pipes::send(pipe, message);\n-                c\n-            }\n-        }\n-\n-        #[allow(non_camel_case_types)]\n-        pub type Open<T> = ::core::pipes::SendPacket<super::Open<T>>;\n-    }\n-\n-    #[allow(non_camel_case_types)]\n-    pub mod server {\n-        #[allow(non_camel_case_types)]\n-        pub type Open<T> = ::core::pipes::RecvPacket<super::Open<T>>;\n-    }\n-}\n-\n /// An endpoint that can send many messages.\n-#[unsafe_mut_field(endp)]\n pub struct Chan<T> {\n-    endp: Option<streamp::client::Open<T>>\n+    inner: Either<pipesy::Chan<T>, rtcomm::Chan<T>>\n }\n \n /// An endpoint that can receive many messages.\n-#[unsafe_mut_field(endp)]\n pub struct Port<T> {\n-    endp: Option<streamp::server::Open<T>>,\n+    inner: Either<pipesy::Port<T>, rtcomm::Port<T>>\n }\n \n /** Creates a `(Port, Chan)` pair.\n@@ -139,100 +77,75 @@ These allow sending or receiving an unlimited number of messages.\n \n */\n pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n-    let (c, s) = streamp::init();\n-\n-    (Port {\n-        endp: Some(s)\n-    }, Chan {\n-        endp: Some(c)\n-    })\n+    let (port, chan) = match rt::context() {\n+        rt::OldTaskContext => match pipesy::stream() {\n+            (p, c) => (Left(p), Left(c))\n+        },\n+        _ => match rtcomm::stream() {\n+            (p, c) => (Right(p), Right(c))\n+        }\n+    };\n+    let port = Port { inner: port };\n+    let chan = Chan { inner: chan };\n+    return (port, chan);\n }\n \n impl<T: Owned> GenericChan<T> for Chan<T> {\n-    #[inline(always)]\n     fn send(&self, x: T) {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let endp = replace(self_endp, None);\n-            *self_endp = Some(streamp::client::data(endp.unwrap(), x))\n+        match self.inner {\n+            Left(ref chan) => chan.send(x),\n+            Right(ref chan) => chan.send(x)\n         }\n     }\n }\n \n impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n-    #[inline(always)]\n     fn try_send(&self, x: T) -> bool {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let endp = replace(self_endp, None);\n-            match streamp::client::try_data(endp.unwrap(), x) {\n-                Some(next) => {\n-                    *self_endp = Some(next);\n-                    true\n-                }\n-                None => false\n-            }\n+        match self.inner {\n+            Left(ref chan) => chan.try_send(x),\n+            Right(ref chan) => chan.try_send(x)\n         }\n     }\n }\n \n impl<T: Owned> GenericPort<T> for Port<T> {\n-    #[inline(always)]\n     fn recv(&self) -> T {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let endp = replace(self_endp, None);\n-            let streamp::data(x, endp) = recv(endp.unwrap());\n-            *self_endp = Some(endp);\n-            x\n+        match self.inner {\n+            Left(ref port) => port.recv(),\n+            Right(ref port) => port.recv()\n         }\n     }\n \n-    #[inline(always)]\n     fn try_recv(&self) -> Option<T> {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let endp = replace(self_endp, None);\n-            match try_recv(endp.unwrap()) {\n-                Some(streamp::data(x, endp)) => {\n-                    *self_endp = Some(endp);\n-                    Some(x)\n-                }\n-                None => None\n-            }\n+        match self.inner {\n+            Left(ref port) => port.try_recv(),\n+            Right(ref port) => port.try_recv()\n         }\n     }\n }\n \n impl<T: Owned> Peekable<T> for Port<T> {\n-    #[inline(always)]\n     fn peek(&self) -> bool {\n-        unsafe {\n-            let self_endp = transmute_mut(&self.endp);\n-            let mut endp = replace(self_endp, None);\n-            let peek = match endp {\n-                Some(ref mut endp) => peek(endp),\n-                None => fail!(\"peeking empty stream\")\n-            };\n-            *self_endp = endp;\n-            peek\n+        match self.inner {\n+            Left(ref port) => port.peek(),\n+            Right(ref port) => port.peek()\n         }\n     }\n }\n \n impl<T: Owned> Selectable for Port<T> {\n     fn header(&mut self) -> *mut PacketHeader {\n-            match self.endp {\n-                Some(ref mut endp) => endp.header(),\n-                None => fail!(\"peeking empty stream\")\n-            }\n+        match self.inner {\n+            Left(ref mut port) => port.header(),\n+            Right(_) => fail!(\"can't select on newsched ports\")\n+        }\n     }\n }\n \n /// Treat many ports as one.\n #[unsafe_mut_field(ports)]\n pub struct PortSet<T> {\n-    ports: ~[Port<T>],\n+    ports: ~[pipesy::Port<T>],\n }\n \n pub impl<T: Owned> PortSet<T> {\n@@ -243,6 +156,11 @@ pub impl<T: Owned> PortSet<T> {\n     }\n \n     fn add(&self, port: Port<T>) {\n+        let Port { inner } = port;\n+        let port = match inner {\n+            Left(p) => p,\n+            Right(_) => fail!(\"PortSet not implemented\")\n+        };\n         unsafe {\n             let self_ports = transmute_mut(&self.ports);\n             self_ports.push(port)\n@@ -290,7 +208,7 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n         for uint::range(0, vec::uniq_len(&const self.ports)) |i| {\n-            let port: &Port<T> = &self.ports[i];\n+            let port: &pipesy::Port<T> = &self.ports[i];\n             if port.peek() {\n                 return true;\n             }\n@@ -301,12 +219,17 @@ impl<T: Owned> Peekable<T> for PortSet<T> {\n \n /// A channel that can be shared between many senders.\n pub struct SharedChan<T> {\n-    ch: Exclusive<Chan<T>>\n+    ch: Exclusive<pipesy::Chan<T>>\n }\n \n impl<T: Owned> SharedChan<T> {\n     /// Converts a `chan` into a `shared_chan`.\n     pub fn new(c: Chan<T>) -> SharedChan<T> {\n+        let Chan { inner } = c;\n+        let c = match inner {\n+            Left(c) => c,\n+            Right(_) => fail!(\"SharedChan not implemented\")\n+        };\n         SharedChan { ch: exclusive(c) }\n     }\n }\n@@ -354,12 +277,8 @@ pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n             (p, c) => (Right(p), Right(c))\n         }\n     };\n-    let port = PortOne {\n-        inner: port\n-    };\n-    let chan = ChanOne {\n-        inner: chan\n-    };\n+    let port = PortOne { inner: port };\n+    let chan = ChanOne { inner: chan };\n     return (port, chan);\n }\n \n@@ -435,7 +354,10 @@ mod pipesy {\n \n     use kinds::Owned;\n     use option::{Option, Some, None};\n-    use pipes::{recv, try_recv};\n+    use pipes::{recv, try_recv, peek, PacketHeader};\n+    use super::{GenericChan, GenericSmartChan, GenericPort, Peekable, Selectable};\n+    use cast::transmute_mut;\n+    use util::replace;\n \n     /*proto! oneshot (\n         Oneshot:send<T:Owned> {\n@@ -610,6 +532,173 @@ mod pipesy {\n         }\n     }\n \n+    // Streams - Make pipes a little easier in general.\n+\n+    /*proto! streamp (\n+        Open:send<T: Owned> {\n+            data(T) -> Open<T>\n+        }\n+    )*/\n+\n+    #[allow(non_camel_case_types)]\n+    pub mod streamp {\n+        priv use core::kinds::Owned;\n+\n+        pub fn init<T: Owned>() -> (client::Open<T>, server::Open<T>) {\n+            pub use core::pipes::HasBuffer;\n+            ::core::pipes::entangle()\n+        }\n+\n+        #[allow(non_camel_case_types)]\n+        pub enum Open<T> { pub data(T, server::Open<T>), }\n+\n+        #[allow(non_camel_case_types)]\n+        pub mod client {\n+            priv use core::kinds::Owned;\n+\n+            #[allow(non_camel_case_types)]\n+            pub fn try_data<T: Owned>(pipe: Open<T>, x_0: T) ->\n+                ::core::option::Option<Open<T>> {\n+                {\n+                    use super::data;\n+                    let (c, s) = ::core::pipes::entangle();\n+                    let message = data(x_0, s);\n+                    if ::core::pipes::send(pipe, message) {\n+                        ::core::pipes::rt::make_some(c)\n+                    } else { ::core::pipes::rt::make_none() }\n+                }\n+            }\n+\n+            #[allow(non_camel_case_types)]\n+            pub fn data<T: Owned>(pipe: Open<T>, x_0: T) -> Open<T> {\n+                {\n+                    use super::data;\n+                    let (c, s) = ::core::pipes::entangle();\n+                    let message = data(x_0, s);\n+                    ::core::pipes::send(pipe, message);\n+                    c\n+                }\n+            }\n+\n+            #[allow(non_camel_case_types)]\n+            pub type Open<T> = ::core::pipes::SendPacket<super::Open<T>>;\n+        }\n+\n+        #[allow(non_camel_case_types)]\n+        pub mod server {\n+            #[allow(non_camel_case_types)]\n+            pub type Open<T> = ::core::pipes::RecvPacket<super::Open<T>>;\n+        }\n+    }\n+\n+    /// An endpoint that can send many messages.\n+    #[unsafe_mut_field(endp)]\n+    pub struct Chan<T> {\n+        endp: Option<streamp::client::Open<T>>\n+    }\n+\n+    /// An endpoint that can receive many messages.\n+    #[unsafe_mut_field(endp)]\n+    pub struct Port<T> {\n+        endp: Option<streamp::server::Open<T>>,\n+    }\n+\n+    /** Creates a `(Port, Chan)` pair.\n+\n+    These allow sending or receiving an unlimited number of messages.\n+\n+    */\n+    pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n+        let (c, s) = streamp::init();\n+\n+        (Port {\n+            endp: Some(s)\n+        }, Chan {\n+            endp: Some(c)\n+        })\n+    }\n+\n+    impl<T: Owned> GenericChan<T> for Chan<T> {\n+        #[inline(always)]\n+        fn send(&self, x: T) {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let endp = replace(self_endp, None);\n+                *self_endp = Some(streamp::client::data(endp.unwrap(), x))\n+            }\n+        }\n+    }\n+\n+    impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+        #[inline(always)]\n+        fn try_send(&self, x: T) -> bool {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let endp = replace(self_endp, None);\n+                match streamp::client::try_data(endp.unwrap(), x) {\n+                    Some(next) => {\n+                        *self_endp = Some(next);\n+                        true\n+                    }\n+                    None => false\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<T: Owned> GenericPort<T> for Port<T> {\n+        #[inline(always)]\n+        fn recv(&self) -> T {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let endp = replace(self_endp, None);\n+                let streamp::data(x, endp) = recv(endp.unwrap());\n+                *self_endp = Some(endp);\n+                x\n+            }\n+        }\n+\n+        #[inline(always)]\n+        fn try_recv(&self) -> Option<T> {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let endp = replace(self_endp, None);\n+                match try_recv(endp.unwrap()) {\n+                    Some(streamp::data(x, endp)) => {\n+                        *self_endp = Some(endp);\n+                        Some(x)\n+                    }\n+                    None => None\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<T: Owned> Peekable<T> for Port<T> {\n+        #[inline(always)]\n+        fn peek(&self) -> bool {\n+            unsafe {\n+                let self_endp = transmute_mut(&self.endp);\n+                let mut endp = replace(self_endp, None);\n+                let peek = match endp {\n+                    Some(ref mut endp) => peek(endp),\n+                    None => fail!(\"peeking empty stream\")\n+                };\n+                *self_endp = endp;\n+                peek\n+            }\n+        }\n+    }\n+\n+    impl<T: Owned> Selectable for Port<T> {\n+        fn header(&mut self) -> *mut PacketHeader {\n+            match self.endp {\n+                Some(ref mut endp) => endp.header(),\n+                None => fail!(\"peeking empty stream\")\n+            }\n+    }\n+}\n+\n }\n \n /// Returns the index of an endpoint that is ready to receive."}, {"sha": "4b5732b2d3aecf7ad6fc017f1e4b25696c218d7f", "filename": "src/libcore/rt/comm.rs", "status": "modified", "additions": 137, "deletions": 111, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02/src%2Flibcore%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02/src%2Flibcore%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcomm.rs?ref=df9e41278eb1e3e653ccd6b4dfab4d7303f64c02", "patch": "@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Ports and channels.\n+//!\n+//! XXX: Carefully consider whether the sequentially consistent\n+//! atomics here can be converted to acq/rel. I'm not sure they can,\n+//! because there is data being transerred in both directions (the payload\n+//! goes from sender to receiver and the task pointer goes the other way).\n+\n use option::*;\n use cast;\n use util;\n@@ -29,33 +36,37 @@ use cell::Cell;\n ///\n /// * 2 - both endpoints are alive\n /// * 1 - either the sender or the receiver is dead, determined by context\n-/// * <ptr> - A pointer to a Task that can be transmuted to ~Task\n+/// * <ptr> - A pointer to a blocked Task that can be transmuted to ~Task\n type State = int;\n \n static STATE_BOTH: State = 2;\n static STATE_ONE: State = 1;\n \n+/// The heap-allocated structure shared between two endpoints.\n struct Packet<T> {\n     state: State,\n     payload: Option<T>,\n }\n \n-pub struct PortOne<T> {\n+/// A one-shot channel.\n+pub struct ChanOne<T> {\n     // XXX: Hack extra allocation to make by-val self work\n-    inner: ~PortOneHack<T>\n+    inner: ~ChanOneHack<T>\n }\n \n-pub struct ChanOne<T> {\n+\n+/// A one-shot port.\n+pub struct PortOne<T> {\n     // XXX: Hack extra allocation to make by-val self work\n-    inner: ~ChanOneHack<T>\n+    inner: ~PortOneHack<T>\n }\n \n-pub struct PortOneHack<T> {\n+pub struct ChanOneHack<T> {\n     void_packet: *mut Void,\n     suppress_finalize: bool\n }\n \n-pub struct ChanOneHack<T> {\n+pub struct PortOneHack<T> {\n     void_packet: *mut Void,\n     suppress_finalize: bool\n }\n@@ -84,6 +95,54 @@ pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n     }\n }\n \n+impl<T> ChanOne<T> {\n+\n+    pub fn send(self, val: T) {\n+        self.try_send(val);\n+    }\n+\n+    pub fn try_send(self, val: T) -> bool {\n+        let mut this = self;\n+        let mut recvr_active = true;\n+        let packet = this.inner.packet();\n+\n+        unsafe {\n+\n+            // Install the payload\n+            assert!((*packet).payload.is_none());\n+            (*packet).payload = Some(val);\n+\n+            // Atomically swap out the old state to figure out what\n+            // the port's up to, issuing a release barrier to prevent\n+            // reordering of the payload write. This also issues an\n+            // acquire barrier that keeps the subsequent access of the\n+            // ~Task pointer from being reordered.\n+            let oldstate = atomic_xchg(&mut (*packet).state, STATE_ONE);\n+            match oldstate {\n+                STATE_BOTH => {\n+                    // Port is not waiting yet. Nothing to do\n+                }\n+                STATE_ONE => {\n+                    // Port has closed. Need to clean up.\n+                    let _packet: ~Packet<T> = cast::transmute(this.inner.void_packet);\n+                    recvr_active = false;\n+                }\n+                task_as_state => {\n+                    // Port is blocked. Wake it up.\n+                    let recvr: ~Coroutine = cast::transmute(task_as_state);\n+                    let sched = local_sched::take();\n+                    sched.schedule_task(recvr);\n+                }\n+            }\n+        }\n+\n+        // Suppress the synchronizing actions in the finalizer. We're done with the packet.\n+        this.inner.suppress_finalize = true;\n+        return recvr_active;\n+    }\n+}\n+\n+\n impl<T> PortOne<T> {\n     pub fn recv(self) -> T {\n         match self.try_recv() {\n@@ -96,30 +155,31 @@ impl<T> PortOne<T> {\n \n     pub fn try_recv(self) -> Option<T> {\n         let mut this = self;\n-\n-        {\n-            let self_ptr: *mut PortOne<T> = &mut this;\n-\n-            // XXX: Optimize this to not require the two context switches when data is available\n-\n-            // Switch to the scheduler\n-            let sched = local_sched::take();\n-            do sched.deschedule_running_task_and_then |task| {\n-                unsafe {\n-                    let task_as_state: State = cast::transmute(task);\n-                    let oldstate = atomic_xchg(&mut (*(*self_ptr).inner.packet()).state, task_as_state);\n-                    match oldstate {\n-                        STATE_BOTH => {\n-                            // Data has not been sent. Now we're blocked.\n-                        }\n-                        STATE_ONE => {\n-                            // Channel is closed. Switch back and check the data.\n-                            let task: ~Coroutine = cast::transmute(task_as_state);\n-                            let sched = local_sched::take();\n-                            sched.resume_task_immediately(task);\n-                        }\n-                        _ => util::unreachable()\n+        let packet = this.inner.packet();\n+\n+        // XXX: Optimize this to not require the two context switches when data is available\n+\n+        // Switch to the scheduler to put the ~Task into the Packet state.\n+        let sched = local_sched::take();\n+        do sched.deschedule_running_task_and_then |task| {\n+            unsafe {\n+                // Atomically swap the task pointer into the Packet state, issuing\n+                // an acquire barrier to prevent reordering of the subsequent read\n+                // of the payload. Also issues a release barrier to prevent reordering\n+                // of any previous writes to the task structure.\n+                let task_as_state: State = cast::transmute(task);\n+                let oldstate = atomic_xchg(&mut (*packet).state, task_as_state);\n+                match oldstate {\n+                    STATE_BOTH => {\n+                        // Data has not been sent. Now we're blocked.\n+                    }\n+                    STATE_ONE => {\n+                        // Channel is closed. Switch back and check the data.\n+                        let task: ~Coroutine = cast::transmute(task_as_state);\n+                        let sched = local_sched::take();\n+                        sched.resume_task_immediately(task);\n                     }\n+                    _ => util::unreachable()\n                 }\n             }\n         }\n@@ -130,20 +190,20 @@ impl<T> PortOne<T> {\n         // payload. Some scenarios:\n         //\n         // 1) We encountered STATE_ONE above - the atomic_xchg was the acq barrier. We're fine.\n-        // 2) We encountered STATE_BOTH above and blocked. The sending task work-stole us\n-        //    and ran on its thread. The work stealing had a memory barrier.\n+        // 2) We encountered STATE_BOTH above and blocked. The sending task then ran us\n+        //    and ran on its thread. The sending task issued a read barrier when taking the\n+        //    pointer to the receiving task.\n         // 3) We encountered STATE_BOTH above and blocked, but the receiving task (this task)\n         //    is pinned to some other scheduler, so the sending task had to give us to\n         //    a different scheduler for resuming. That send synchronized memory.\n \n         unsafe {\n-            let payload = util::replace(&mut (*this.inner.packet()).payload, None);\n+            let payload = util::replace(&mut (*packet).payload, None);\n \n             // The sender has closed up shop. Drop the packet.\n             let _packet: ~Packet<T> = cast::transmute(this.inner.void_packet);\n-            // Supress the finalizer. We're done here.\n+            // Suppress the synchronizing actions in the finalizer. We're done with the packet.\n             this.inner.suppress_finalize = true;\n-\n             return payload;\n         }\n     }\n@@ -167,47 +227,8 @@ impl<T> Peekable<T> for PortOne<T> {\n     }\n }\n \n-impl<T> ChanOne<T> {\n-\n-    pub fn send(self, val: T) {\n-        self.try_send(val);\n-    }\n-\n-    pub fn try_send(self, val: T) -> bool {\n-        let mut this = self;\n-        let mut recvr_active = true;\n-\n-        unsafe {\n-            assert!((*this.inner.packet()).payload.is_none());\n-            (*this.inner.packet()).payload = Some(val);\n-\n-            let oldstate = atomic_xchg(&mut (*this.inner.packet()).state, STATE_ONE);\n-            match oldstate {\n-                STATE_BOTH => {\n-                    // Port is not recving yet. Nothing to do\n-                }\n-                STATE_ONE => {\n-                    // Port has closed. Need to clean up.\n-                    let _packet: ~Packet<T> = cast::transmute(this.inner.void_packet);\n-                    recvr_active = false;\n-                }\n-                _ => {\n-                    // Port is blocked. Wake it up.\n-                    let recvr: ~Coroutine = cast::transmute(oldstate);\n-                    let sched = local_sched::take();\n-                    sched.schedule_task(recvr);\n-                }\n-            }\n-        }\n-\n-        // Suppress the finalizer. We're done here.\n-        this.inner.suppress_finalize = true;\n-        return recvr_active;\n-    }\n-}\n-\n #[unsafe_destructor]\n-impl<T> Drop for PortOneHack<T> {\n+impl<T> Drop for ChanOneHack<T> {\n     fn finalize(&self) {\n         if self.suppress_finalize { return }\n \n@@ -216,21 +237,25 @@ impl<T> Drop for PortOneHack<T> {\n             let oldstate = atomic_xchg(&mut (*this.packet()).state, STATE_ONE);\n             match oldstate {\n                 STATE_BOTH => {\n-                    /* cleanup is the chan's responsibility */\n+                    // Port still active. It will destroy the Packet.\n                 },\n                 STATE_ONE => {\n                     let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n-                }\n-                _ => {\n-                    util::unreachable()\n+                },\n+                task_as_state => {\n+                    // The port is blocked waiting for a message we will never send. Wake it.\n+                    assert!((*this.packet()).payload.is_none());\n+                    let recvr: ~Coroutine = cast::transmute(task_as_state);\n+                    let sched = local_sched::take();\n+                    sched.schedule_task(recvr);\n                 }\n             }\n         }\n     }\n }\n \n #[unsafe_destructor]\n-impl<T> Drop for ChanOneHack<T> {\n+impl<T> Drop for PortOneHack<T> {\n     fn finalize(&self) {\n         if self.suppress_finalize { return }\n \n@@ -239,24 +264,20 @@ impl<T> Drop for ChanOneHack<T> {\n             let oldstate = atomic_xchg(&mut (*this.packet()).state, STATE_ONE);\n             match oldstate {\n                 STATE_BOTH => {\n-                    /* cleanup is the port's responsibility */\n+                    // Chan still active. It will destroy the packet.\n                 },\n                 STATE_ONE => {\n                     let _packet: ~Packet<T> = cast::transmute(this.void_packet);\n-                },\n+                }\n                 _ => {\n-                    // The port is blocked recving for a message we will never send. Wake it.\n-                    assert!((*this.packet()).payload.is_none());\n-                    let recvr: ~Coroutine = cast::transmute(oldstate);\n-                    let sched = local_sched::take();\n-                    sched.schedule_task(recvr);\n+                    util::unreachable()\n                 }\n             }\n         }\n     }\n }\n \n-impl<T> PortOneHack<T> {\n+impl<T> ChanOneHack<T> {\n     fn packet(&self) -> *mut Packet<T> {\n         unsafe {\n             let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n@@ -266,7 +287,7 @@ impl<T> PortOneHack<T> {\n     }\n }\n \n-impl<T> ChanOneHack<T> {\n+impl<T> PortOneHack<T> {\n     fn packet(&self) -> *mut Packet<T> {\n         unsafe {\n             let p: *mut ~Packet<T> = cast::transmute(&self.void_packet);\n@@ -276,25 +297,45 @@ impl<T> ChanOneHack<T> {\n     }\n }\n \n-struct StreamPayload<T>(T, PortOne<StreamPayload<T>>);\n-\n-pub struct Port<T> {\n-    // FIXME #5372. Using Cell because we don't take &mut self\n-    next: Cell<PortOne<StreamPayload<T>>>\n+struct StreamPayload<T> {\n+    val: T,\n+    next: PortOne<StreamPayload<T>>\n }\n \n+/// A channel with unbounded size.\n pub struct Chan<T> {\n     // FIXME #5372. Using Cell because we don't take &mut self\n     next: Cell<ChanOne<StreamPayload<T>>>\n }\n \n+/// An port with unbounded size.\n+pub struct Port<T> {\n+    // FIXME #5372. Using Cell because we don't take &mut self\n+    next: Cell<PortOne<StreamPayload<T>>>\n+}\n+\n pub fn stream<T: Owned>() -> (Port<T>, Chan<T>) {\n     let (pone, cone) = oneshot();\n     let port = Port { next: Cell(pone) };\n     let chan = Chan { next: Cell(cone) };\n     return (port, chan);\n }\n \n+impl<T: Owned> GenericChan<T> for Chan<T> {\n+    fn send(&self, val: T) {\n+        self.try_send(val);\n+    }\n+}\n+\n+impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+    fn try_send(&self, val: T) -> bool {\n+        let (next_pone, next_cone) = oneshot();\n+        let cone = self.next.take();\n+        self.next.put_back(next_cone);\n+        cone.try_send(StreamPayload { val: val, next: next_pone })\n+    }\n+}\n+\n impl<T> GenericPort<T> for Port<T> {\n     fn recv(&self) -> T {\n         match self.try_recv() {\n@@ -308,7 +349,7 @@ impl<T> GenericPort<T> for Port<T> {\n     fn try_recv(&self) -> Option<T> {\n         let pone = self.next.take();\n         match pone.try_recv() {\n-            Some(StreamPayload(val, next)) => {\n+            Some(StreamPayload { val, next }) => {\n                 self.next.put_back(next);\n                 Some(val)\n             }\n@@ -323,21 +364,6 @@ impl<T> Peekable<T> for Port<T> {\n     }\n }\n \n-impl<T: Owned> GenericChan<T> for Chan<T> {\n-    fn send(&self, val: T) {\n-        self.try_send(val);\n-    }\n-}\n-\n-impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n-    fn try_send(&self, val: T) -> bool {\n-        let (next_pone, next_cone) = oneshot();\n-        let cone = self.next.take();\n-        self.next.put_back(next_cone);\n-        cone.try_send(StreamPayload(val, next_pone))\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use super::*;\n@@ -563,7 +589,7 @@ mod test {\n     }\n \n     #[test]\n-    fn stream_send_recv() {\n+    fn stream_send_recv_stress() {\n         for stress_factor().times {\n             do run_in_newsched_task {\n                 let (port, chan) = stream::<~int>();"}, {"sha": "8d6873be8cd564e429fa86e81a5c5325ec2f1ef2", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df9e41278eb1e3e653ccd6b4dfab4d7303f64c02/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=df9e41278eb1e3e653ccd6b4dfab4d7303f64c02", "patch": "@@ -261,7 +261,7 @@ mod test {\n         use comm::*;\n \n         do run_in_newsched_task() {\n-            let (port, chan) = oneshot();\n+            let (port, chan) = stream();\n             chan.send(10);\n             assert!(port.recv() == 10);\n         }"}]}