{"sha": "5f28831a40477a0d564368e11fe6c5d6a26cd56f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmMjg4MzFhNDA0NzdhMGQ1NjQzNjhlMTFmZTZjNWQ2YTI2Y2Q1NmY=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2020-09-02T01:24:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-02T01:24:25Z"}, "message": "Rollup merge of #76074 - richkadel:llvm-coverage-map-gen-6b.5.1, r=wesleywiser\n\nAdd new `-Z dump-mir-spanview` option\n\nSimilar to `-Z dump-mir-graphviz`, this adds the option to write\nHTML+CSS files that allow users to analyze the spans associated with MIR\nelements (by individual statement, just terminator, or overall basic\nblock).\n\nThis PR was split out from PR #76004, and exposes an API for spanview\nHTML+CSS files that is also used to analyze code regions chosen for\ncoverage instrumentation (in a follow-on PR).\n\nRust compiler MCP rust-lang/compiler-team#278\n\nRelevant issue: #34701 - Implement support for LLVMs code coverage\ninstrumentation\n\nr? @tmandry\nFYI @wesleywiser", "tree": {"sha": "1f310a19da46bde7daa574b45c79e3efb60c1443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f310a19da46bde7daa574b45c79e3efb60c1443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f28831a40477a0d564368e11fe6c5d6a26cd56f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfTvRJCRBK7hj4Ov3rIwAAdHIIAHJcK3absWrQ75RDVtmKEZ4V\nxnrhustIIgBdbuCto8JfbD6usSG0ZRdeYrX5uFoLOjBQSwbdI3uPSsy5UxNUAWTd\nHxSf55NDu3mG9/vOLZNz8e7GnseFMklvErlIsO1r624Gkz60P5hMJTtD/dg7fJ2l\nIO+nrcD24SCRm4U+/PyaDEv/mDw0bZbNXJnwwQMf+G8Qh33B7demMvgUrnbx4ViX\nt3694OABfgoeLpLf4x85xWaoGvYcEBasQ/fSUdvXf9GenuSFxptRlchebYKDGN6S\n5D1L/jQ0fuN4081JjuynJfh8+fV51BbEptr5qWwMUzDJ3+/fPFQXdzw6XL52t+4=\n=aa8c\n-----END PGP SIGNATURE-----\n", "payload": "tree 1f310a19da46bde7daa574b45c79e3efb60c1443\nparent 383da5e1e670c5028731aa3e477578e5e97c6e52\nparent 6b5869a0ae3488ee19c2c4cb30cd589f68a3d2a8\nauthor Tyler Mandry <tmandry@gmail.com> 1599009865 -0700\ncommitter GitHub <noreply@github.com> 1599009865 -0700\n\nRollup merge of #76074 - richkadel:llvm-coverage-map-gen-6b.5.1, r=wesleywiser\n\nAdd new `-Z dump-mir-spanview` option\n\nSimilar to `-Z dump-mir-graphviz`, this adds the option to write\nHTML+CSS files that allow users to analyze the spans associated with MIR\nelements (by individual statement, just terminator, or overall basic\nblock).\n\nThis PR was split out from PR #76004, and exposes an API for spanview\nHTML+CSS files that is also used to analyze code regions chosen for\ncoverage instrumentation (in a follow-on PR).\n\nRust compiler MCP rust-lang/compiler-team#278\n\nRelevant issue: #34701 - Implement support for LLVMs code coverage\ninstrumentation\n\nr? @tmandry\nFYI @wesleywiser\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f28831a40477a0d564368e11fe6c5d6a26cd56f", "html_url": "https://github.com/rust-lang/rust/commit/5f28831a40477a0d564368e11fe6c5d6a26cd56f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f28831a40477a0d564368e11fe6c5d6a26cd56f/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "383da5e1e670c5028731aa3e477578e5e97c6e52", "url": "https://api.github.com/repos/rust-lang/rust/commits/383da5e1e670c5028731aa3e477578e5e97c6e52", "html_url": "https://github.com/rust-lang/rust/commit/383da5e1e670c5028731aa3e477578e5e97c6e52"}, {"sha": "6b5869a0ae3488ee19c2c4cb30cd589f68a3d2a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b5869a0ae3488ee19c2c4cb30cd589f68a3d2a8", "html_url": "https://github.com/rust-lang/rust/commit/6b5869a0ae3488ee19c2c4cb30cd589f68a3d2a8"}], "stats": {"total": 739, "additions": 739, "deletions": 0}, "files": [{"sha": "ed0fafb1aac16f32ba96c892e6a6c719986b25bb", "filename": "compiler/rustc_mir/src/util/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -9,6 +9,7 @@ mod alignment;\n pub mod collect_writes;\n mod graphviz;\n pub(crate) mod pretty;\n+pub(crate) mod spanview;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;"}, {"sha": "db57766620e8134964add64d72678cb17369dcc5", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -6,6 +6,7 @@ use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n \n use super::graphviz::write_mir_fn_graphviz;\n+use super::spanview::write_mir_fn_spanview;\n use crate::transform::MirSource;\n use either::Either;\n use rustc_data_structures::fx::FxHashMap;\n@@ -147,6 +148,16 @@ fn dump_matched_mir_node<'tcx, F>(\n             write_mir_fn_graphviz(tcx, source.def_id(), body, false, &mut file)?;\n         };\n     }\n+\n+    if let Some(spanview) = tcx.sess.opts.debugging_opts.dump_mir_spanview {\n+        let _: io::Result<()> = try {\n+            let mut file =\n+                create_dump_file(tcx, \"html\", pass_num, pass_name, disambiguator, source)?;\n+            if source.def_id().is_local() {\n+                write_mir_fn_spanview(tcx, source.def_id(), body, spanview, &mut file)?;\n+            }\n+        };\n+    }\n }\n \n /// Returns the path to the filename where we should dump a given MIR."}, {"sha": "b2f2b5fc1e6f49067d88015ab619b85cba4f6c2d", "filename": "compiler/rustc_mir/src/util/spanview.rs", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fspanview.rs?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -0,0 +1,461 @@\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::hir;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::config::MirSpanview;\n+use rustc_span::{BytePos, Pos, Span};\n+\n+use std::io::{self, Write};\n+use std::iter::Peekable;\n+\n+pub const TOOLTIP_INDENT: &str = \"    \";\n+\n+const NEW_LINE_SPAN: &str = \"</span>\\n<span class=\\\"line\\\">\";\n+const HEADER: &str = r#\"<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>coverage_of_if_else - Code Regions</title>\n+    <style>\n+    .line {\n+        counter-increment: line;\n+    }\n+    .line:before {\n+        content: counter(line) \": \";\n+        font-family: Menlo, Monaco, monospace;\n+        font-style: italic;\n+        width: 3.8em;\n+        display: inline-block;\n+        text-align: right;\n+        filter: opacity(50%);\n+        -webkit-user-select: none;\n+    }\n+    .code {\n+        color: #dddddd;\n+        background-color: #222222;\n+        font-family: Menlo, Monaco, monospace;\n+        line-height: 1.4em;\n+        border-bottom: 2px solid #222222;\n+        white-space: pre;\n+        display: inline-block;\n+    }\n+    .odd {\n+        background-color: #55bbff;\n+        color: #223311;\n+    }\n+    .even {\n+        background-color: #ee7756;\n+        color: #551133;\n+    }\n+    .code {\n+        --index: calc(var(--layer) - 1);\n+        padding-top: calc(var(--index) * 0.15em);\n+        filter:\n+            hue-rotate(calc(var(--index) * 25deg))\n+            saturate(calc(100% - (var(--index) * 2%)))\n+            brightness(calc(100% - (var(--index) * 1.5%)));\n+    }\n+    .annotation {\n+        color: #4444ff;\n+        font-family: monospace;\n+        font-style: italic;\n+        display: none;\n+        -webkit-user-select: none;\n+    }\n+    body:active .annotation {\n+        /* requires holding mouse down anywhere on the page */\n+        display: inline-block;\n+    }\n+    span:hover .annotation {\n+        /* requires hover over a span ONLY on its first line */\n+        display: inline-block;\n+    }\n+    </style>\n+</head>\n+<body>\"#;\n+\n+const FOOTER: &str = r#\"\n+</body>\n+</html>\"#;\n+\n+/// Metadata to highlight the span of a MIR BasicBlock, Statement, or Terminator.\n+pub struct SpanViewable {\n+    pub span: Span,\n+    pub title: String,\n+    pub tooltip: String,\n+}\n+\n+/// Write a spanview HTML+CSS file to analyze MIR element spans.\n+pub fn write_mir_fn_spanview<'tcx, W>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    body: &Body<'tcx>,\n+    spanview: MirSpanview,\n+    w: &mut W,\n+) -> io::Result<()>\n+where\n+    W: Write,\n+{\n+    let body_span = hir_body(tcx, def_id).value.span;\n+    let mut span_viewables = Vec::new();\n+    for (bb, data) in body.basic_blocks().iter_enumerated() {\n+        match spanview {\n+            MirSpanview::Statement => {\n+                for (i, statement) in data.statements.iter().enumerate() {\n+                    if let Some(span_viewable) =\n+                        statement_span_viewable(tcx, body_span, bb, i, statement)\n+                    {\n+                        span_viewables.push(span_viewable);\n+                    }\n+                }\n+                if let Some(span_viewable) = terminator_span_viewable(tcx, body_span, bb, data) {\n+                    span_viewables.push(span_viewable);\n+                }\n+            }\n+            MirSpanview::Terminator => {\n+                if let Some(span_viewable) = terminator_span_viewable(tcx, body_span, bb, data) {\n+                    span_viewables.push(span_viewable);\n+                }\n+            }\n+            MirSpanview::Block => {\n+                if let Some(span_viewable) = block_span_viewable(tcx, body_span, bb, data) {\n+                    span_viewables.push(span_viewable);\n+                }\n+            }\n+        }\n+    }\n+    write_spanview_document(tcx, def_id, span_viewables, w)?;\n+    Ok(())\n+}\n+\n+/// Generate a spanview HTML+CSS document for the given local function `def_id`, and a pre-generated\n+/// list `SpanViewable`s.\n+pub fn write_spanview_document<'tcx, W>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    mut span_viewables: Vec<SpanViewable>,\n+    w: &mut W,\n+) -> io::Result<()>\n+where\n+    W: Write,\n+{\n+    let fn_span = fn_span(tcx, def_id);\n+    writeln!(w, \"{}\", HEADER)?;\n+    let mut next_pos = fn_span.lo();\n+    let end_pos = fn_span.hi();\n+    let source_map = tcx.sess.source_map();\n+    let start = source_map.lookup_char_pos(next_pos);\n+    write!(\n+        w,\n+        r#\"<div class=\"code\" style=\"counter-reset: line {}\"><span class=\"line\">{}\"#,\n+        start.line - 1,\n+        \" \".repeat(start.col.to_usize())\n+    )?;\n+    span_viewables.sort_unstable_by(|a, b| {\n+        let a = a.span;\n+        let b = b.span;\n+        if a.lo() == b.lo() {\n+            // Sort hi() in reverse order so shorter spans are attempted after longer spans.\n+            // This should give shorter spans a higher \"layer\", so they are not covered by\n+            // the longer spans.\n+            b.hi().partial_cmp(&a.hi())\n+        } else {\n+            a.lo().partial_cmp(&b.lo())\n+        }\n+        .unwrap()\n+    });\n+    let mut ordered_span_viewables = span_viewables.iter().peekable();\n+    let mut alt = false;\n+    while ordered_span_viewables.peek().is_some() {\n+        next_pos = write_span_viewables(tcx, next_pos, &mut ordered_span_viewables, false, 1, w)?;\n+        alt = !alt;\n+    }\n+    if next_pos < end_pos {\n+        write_coverage_gap(tcx, next_pos, end_pos, w)?;\n+    }\n+    write!(w, r#\"</span></div>\"#)?;\n+    writeln!(w, \"{}\", FOOTER)?;\n+    Ok(())\n+}\n+\n+/// Format a string showing the start line and column, and end line and column within a file.\n+pub fn source_range_no_file<'tcx>(tcx: TyCtxt<'tcx>, span: &Span) -> String {\n+    let source_map = tcx.sess.source_map();\n+    let start = source_map.lookup_char_pos(span.lo());\n+    let end = source_map.lookup_char_pos(span.hi());\n+    format!(\"{}:{}-{}:{}\", start.line, start.col.to_usize() + 1, end.line, end.col.to_usize() + 1)\n+}\n+\n+pub fn statement_kind_name(statement: &Statement<'_>) -> &'static str {\n+    use StatementKind::*;\n+    match statement.kind {\n+        Assign(..) => \"Assign\",\n+        FakeRead(..) => \"FakeRead\",\n+        SetDiscriminant { .. } => \"SetDiscriminant\",\n+        StorageLive(..) => \"StorageLive\",\n+        StorageDead(..) => \"StorageDead\",\n+        LlvmInlineAsm(..) => \"LlvmInlineAsm\",\n+        Retag(..) => \"Retag\",\n+        AscribeUserType(..) => \"AscribeUserType\",\n+        Coverage(..) => \"Coverage\",\n+        Nop => \"Nop\",\n+    }\n+}\n+\n+pub fn terminator_kind_name(term: &Terminator<'_>) -> &'static str {\n+    use TerminatorKind::*;\n+    match term.kind {\n+        Goto { .. } => \"Goto\",\n+        SwitchInt { .. } => \"SwitchInt\",\n+        Resume => \"Resume\",\n+        Abort => \"Abort\",\n+        Return => \"Return\",\n+        Unreachable => \"Unreachable\",\n+        Drop { .. } => \"Drop\",\n+        DropAndReplace { .. } => \"DropAndReplace\",\n+        Call { .. } => \"Call\",\n+        Assert { .. } => \"Assert\",\n+        Yield { .. } => \"Yield\",\n+        GeneratorDrop => \"GeneratorDrop\",\n+        FalseEdge { .. } => \"FalseEdge\",\n+        FalseUnwind { .. } => \"FalseUnwind\",\n+        InlineAsm { .. } => \"InlineAsm\",\n+    }\n+}\n+\n+fn statement_span_viewable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body_span: Span,\n+    bb: BasicBlock,\n+    i: usize,\n+    statement: &Statement<'tcx>,\n+) -> Option<SpanViewable> {\n+    let span = statement.source_info.span;\n+    if !body_span.contains(span) {\n+        return None;\n+    }\n+    let title = format!(\"bb{}[{}]\", bb.index(), i);\n+    let tooltip = tooltip(tcx, &title, span, vec![statement.clone()], &None);\n+    Some(SpanViewable { span, title, tooltip })\n+}\n+\n+fn terminator_span_viewable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body_span: Span,\n+    bb: BasicBlock,\n+    data: &BasicBlockData<'tcx>,\n+) -> Option<SpanViewable> {\n+    let term = data.terminator();\n+    let span = term.source_info.span;\n+    if !body_span.contains(span) {\n+        return None;\n+    }\n+    let title = format!(\"bb{}`{}`\", bb.index(), terminator_kind_name(term));\n+    let tooltip = tooltip(tcx, &title, span, vec![], &data.terminator);\n+    Some(SpanViewable { span, title, tooltip })\n+}\n+\n+fn block_span_viewable<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body_span: Span,\n+    bb: BasicBlock,\n+    data: &BasicBlockData<'tcx>,\n+) -> Option<SpanViewable> {\n+    let span = compute_block_span(data, body_span);\n+    if !body_span.contains(span) {\n+        return None;\n+    }\n+    let title = format!(\"bb{}\", bb.index());\n+    let tooltip = tooltip(tcx, &title, span, data.statements.clone(), &data.terminator);\n+    Some(SpanViewable { span, title, tooltip })\n+}\n+\n+fn compute_block_span<'tcx>(data: &BasicBlockData<'tcx>, body_span: Span) -> Span {\n+    let mut span = data.terminator().source_info.span;\n+    for statement_span in data.statements.iter().map(|statement| statement.source_info.span) {\n+        // Only combine Spans from the function's body_span.\n+        if body_span.contains(statement_span) {\n+            span = span.to(statement_span);\n+        }\n+    }\n+    span\n+}\n+\n+/// Recursively process each ordered span. Spans that overlap will have progressively varying\n+/// styles, such as increased padding for each overlap. Non-overlapping adjacent spans will\n+/// have alternating style choices, to help distinguish between them if, visually adjacent.\n+/// The `layer` is incremented for each overlap, and the `alt` bool alternates between true\n+/// and false, for each adjacent non-overlapping span. Source code between the spans (code\n+/// that is not in any coverage region) has neutral styling.\n+fn write_span_viewables<'tcx, 'b, W>(\n+    tcx: TyCtxt<'tcx>,\n+    next_pos: BytePos,\n+    ordered_span_viewables: &mut Peekable<impl Iterator<Item = &'b SpanViewable>>,\n+    alt: bool,\n+    layer: usize,\n+    w: &mut W,\n+) -> io::Result<BytePos>\n+where\n+    W: Write,\n+{\n+    let span_viewable =\n+        ordered_span_viewables.next().expect(\"ordered_span_viewables should have some\");\n+    if next_pos < span_viewable.span.lo() {\n+        write_coverage_gap(tcx, next_pos, span_viewable.span.lo(), w)?;\n+    }\n+    let mut remaining_span = span_viewable.span;\n+    let mut subalt = false;\n+    loop {\n+        let next_span_viewable = match ordered_span_viewables.peek() {\n+            None => break,\n+            Some(span_viewable) => *span_viewable,\n+        };\n+        if !next_span_viewable.span.overlaps(remaining_span) {\n+            break;\n+        }\n+        write_span(\n+            tcx,\n+            remaining_span.until(next_span_viewable.span),\n+            Some(span_viewable),\n+            alt,\n+            layer,\n+            w,\n+        )?;\n+        let next_pos = write_span_viewables(\n+            tcx,\n+            next_span_viewable.span.lo(),\n+            ordered_span_viewables,\n+            subalt,\n+            layer + 1,\n+            w,\n+        )?;\n+        subalt = !subalt;\n+        if next_pos < remaining_span.hi() {\n+            remaining_span = remaining_span.with_lo(next_pos);\n+        } else {\n+            return Ok(next_pos);\n+        }\n+    }\n+    write_span(tcx, remaining_span, Some(span_viewable), alt, layer, w)\n+}\n+\n+fn write_coverage_gap<'tcx, W>(\n+    tcx: TyCtxt<'tcx>,\n+    lo: BytePos,\n+    hi: BytePos,\n+    w: &mut W,\n+) -> io::Result<BytePos>\n+where\n+    W: Write,\n+{\n+    write_span(tcx, Span::with_root_ctxt(lo, hi), None, false, 0, w)\n+}\n+\n+fn write_span<'tcx, W>(\n+    tcx: TyCtxt<'tcx>,\n+    span: Span,\n+    span_viewable: Option<&SpanViewable>,\n+    alt: bool,\n+    layer: usize,\n+    w: &mut W,\n+) -> io::Result<BytePos>\n+where\n+    W: Write,\n+{\n+    let source_map = tcx.sess.source_map();\n+    let snippet = source_map\n+        .span_to_snippet(span)\n+        .unwrap_or_else(|err| bug!(\"span_to_snippet error for span {:?}: {:?}\", span, err));\n+    let labeled_snippet = if let Some(SpanViewable { title, .. }) = span_viewable {\n+        if span.is_empty() {\n+            format!(r#\"<span class=\"annotation\">@{}</span>\"#, title)\n+        } else {\n+            format!(r#\"<span class=\"annotation\">@{}:</span> {}\"#, title, escape_html(&snippet))\n+        }\n+    } else {\n+        snippet\n+    };\n+    let maybe_alt = if layer > 0 {\n+        if alt { \" odd\" } else { \" even\" }\n+    } else {\n+        \"\"\n+    };\n+    let maybe_tooltip = if let Some(SpanViewable { tooltip, .. }) = span_viewable {\n+        format!(\" title=\\\"{}\\\"\", escape_attr(tooltip))\n+    } else {\n+        \"\".to_owned()\n+    };\n+    if layer == 1 {\n+        write!(w, \"<span>\")?;\n+    }\n+    for (i, line) in labeled_snippet.lines().enumerate() {\n+        if i > 0 {\n+            write!(w, \"{}\", NEW_LINE_SPAN)?;\n+        }\n+        write!(\n+            w,\n+            r#\"<span class=\"code{}\" style=\"--layer: {}\"{}>{}</span>\"#,\n+            maybe_alt, layer, maybe_tooltip, line\n+        )?;\n+    }\n+    if layer == 1 {\n+        write!(w, \"</span>\")?;\n+    }\n+    Ok(span.hi())\n+}\n+\n+fn tooltip<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    title: &str,\n+    span: Span,\n+    statements: Vec<Statement<'tcx>>,\n+    terminator: &Option<Terminator<'tcx>>,\n+) -> String {\n+    let source_map = tcx.sess.source_map();\n+    let mut text = Vec::new();\n+    text.push(format!(\"{}: {}:\", title, &source_map.span_to_string(span)));\n+    for statement in statements {\n+        let source_range = source_range_no_file(tcx, &statement.source_info.span);\n+        text.push(format!(\n+            \"\\n{}{}: {}: {}\",\n+            TOOLTIP_INDENT,\n+            source_range,\n+            statement_kind_name(&statement),\n+            format!(\"{:?}\", statement)\n+        ));\n+    }\n+    if let Some(term) = terminator {\n+        let source_range = source_range_no_file(tcx, &term.source_info.span);\n+        text.push(format!(\n+            \"\\n{}{}: {}: {:?}\",\n+            TOOLTIP_INDENT,\n+            source_range,\n+            terminator_kind_name(term),\n+            term.kind\n+        ));\n+    }\n+    text.join(\"\")\n+}\n+\n+fn fn_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n+    let hir_id =\n+        tcx.hir().local_def_id_to_hir_id(def_id.as_local().expect(\"expected DefId is local\"));\n+    tcx.hir().span(hir_id)\n+}\n+\n+fn hir_body<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx rustc_hir::Body<'tcx> {\n+    let hir_node = tcx.hir().get_if_local(def_id).expect(\"expected DefId is local\");\n+    let fn_body_id = hir::map::associated_body(hir_node).expect(\"HIR node is a function with body\");\n+    tcx.hir().body(fn_body_id)\n+}\n+\n+fn escape_html(s: &str) -> String {\n+    s.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\")\n+}\n+\n+fn escape_attr(s: &str) -> String {\n+    s.replace(\"&\", \"&amp;\")\n+        .replace(\"\\\"\", \"&quot;\")\n+        .replace(\"'\", \"&#39;\")\n+        .replace(\"<\", \"&lt;\")\n+        .replace(\">\", \"&gt;\")\n+}"}, {"sha": "6861314a88f6fc1843c7f731fb1dcb71d3cfba5a", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -163,6 +163,21 @@ pub enum LtoCli {\n     Unspecified,\n }\n \n+/// The different settings that the `-Z dump_mir_spanview` flag can have. `Statement` generates a\n+/// document highlighting each span of every statement (including terminators). `Terminator` and\n+/// `Block` highlight a single span per `BasicBlock`: the span of the block's `Terminator`, or a\n+/// computed span for the block, representing the entire range, covering the block's terminator and\n+/// all of its statements.\n+#[derive(Clone, Copy, PartialEq, Hash, Debug)]\n+pub enum MirSpanview {\n+    /// Default `-Z dump_mir_spanview` or `-Z dump_mir_spanview=statement`\n+    Statement,\n+    /// `-Z dump_mir_spanview=terminator`\n+    Terminator,\n+    /// `-Z dump_mir_spanview=block`\n+    Block,\n+}\n+\n #[derive(Clone, PartialEq, Hash)]\n pub enum LinkerPluginLto {\n     LinkerPlugin(PathBuf),"}, {"sha": "bcf65a1c4d2b0571a3c81c319d954f148cd448b5", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -255,6 +255,7 @@ macro_rules! options {\n         pub const parse_strip: &str = \"either `none`, `debuginfo`, or `symbols`\";\n         pub const parse_linker_flavor: &str = ::rustc_target::spec::LinkerFlavor::one_of();\n         pub const parse_optimization_fuel: &str = \"crate=integer\";\n+        pub const parse_mir_spanview: &str = \"`statement` (default), `terminator`, or `block`\";\n         pub const parse_unpretty: &str = \"`string` or `string=string`\";\n         pub const parse_treat_err_as_bug: &str = \"either no value or a number bigger than 0\";\n         pub const parse_lto: &str =\n@@ -551,6 +552,36 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_mir_spanview(slot: &mut Option<MirSpanview>, v: Option<&str>) -> bool {\n+            if v.is_some() {\n+                let mut bool_arg = None;\n+                if parse_opt_bool(&mut bool_arg, v) {\n+                    *slot = if bool_arg.unwrap() {\n+                        Some(MirSpanview::Statement)\n+                    } else {\n+                        None\n+                    };\n+                    return true\n+                }\n+            }\n+\n+            let v = match v {\n+                None => {\n+                    *slot = Some(MirSpanview::Statement);\n+                    return true;\n+                }\n+                Some(v) => v,\n+            };\n+\n+            *slot = Some(match v.trim_end_matches(\"s\") {\n+                \"statement\" | \"stmt\" => MirSpanview::Statement,\n+                \"terminator\" | \"term\" => MirSpanview::Terminator,\n+                \"block\" | \"basicblock\" => MirSpanview::Block,\n+                _ => return false,\n+            });\n+            true\n+        }\n+\n         fn parse_treat_err_as_bug(slot: &mut Option<usize>, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = s.parse().ok().filter(|&x| x != 0); slot.unwrap_or(0) != 0 }\n@@ -849,6 +880,11 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"exclude the pass number when dumping MIR (used in tests) (default: no)\"),\n     dump_mir_graphviz: bool = (false, parse_bool, [UNTRACKED],\n         \"in addition to `.mir` files, create graphviz `.dot` files (default: no)\"),\n+    dump_mir_spanview: Option<MirSpanview> = (None, parse_mir_spanview, [UNTRACKED],\n+        \"in addition to `.mir` files, create `.html` files to view spans for \\\n+        all `statement`s (including terminators), only `terminator` spans, or \\\n+        computed `block` spans (one span encompassing a block's terminator and \\\n+        all statements).\"),\n     emit_stack_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"emit a section containing stack size metadata (default: no)\"),\n     fewer_names: bool = (false, parse_bool, [TRACKED],"}, {"sha": "fc1d6e0ede66e4af8dea70e4dae307ca568af4e1", "filename": "src/test/mir-opt/spanview-block.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview-block.rs?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -0,0 +1,5 @@\n+// Test spanview block output\n+// compile-flags: -Z dump-mir-spanview=block\n+\n+// EMIT_MIR spanview_block.main.mir_map.0.html\n+fn main() {}"}, {"sha": "a43ad5e71a3930931d6801ba0a3b786827384884", "filename": "src/test/mir-opt/spanview-statement.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview-statement.rs?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -0,0 +1,5 @@\n+// Test spanview output (the default value for `-Z dump-mir-spanview` is \"statement\")\n+// compile-flags: -Z dump-mir-spanview\n+\n+// EMIT_MIR spanview_statement.main.mir_map.0.html\n+fn main() {}"}, {"sha": "92e1411eadbdaf9ee4a111be6ed104352ca8862c", "filename": "src/test/mir-opt/spanview-terminator.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview-terminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview-terminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview-terminator.rs?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -0,0 +1,5 @@\n+// Test spanview terminator output\n+// compile-flags: -Z dump-mir-spanview=terminator\n+\n+// EMIT_MIR spanview_terminator.main.mir_map.0.html\n+fn main() {}"}, {"sha": "7c1b7bc3b84b0bb031a35775a334c8ca11de20a8", "filename": "src/test/mir-opt/spanview_block.main.mir_map.0.html", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview_block.main.mir_map.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview_block.main.mir_map.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview_block.main.mir_map.0.html?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -0,0 +1,67 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>coverage_of_if_else - Code Regions</title>\n+    <style>\n+    .line {\n+        counter-increment: line;\n+    }\n+    .line:before {\n+        content: counter(line) \": \";\n+        font-family: Menlo, Monaco, monospace;\n+        font-style: italic;\n+        width: 3.8em;\n+        display: inline-block;\n+        text-align: right;\n+        filter: opacity(50%);\n+        -webkit-user-select: none;\n+    }\n+    .code {\n+        color: #dddddd;\n+        background-color: #222222;\n+        font-family: Menlo, Monaco, monospace;\n+        line-height: 1.4em;\n+        border-bottom: 2px solid #222222;\n+        white-space: pre;\n+        display: inline-block;\n+    }\n+    .odd {\n+        background-color: #55bbff;\n+        color: #223311;\n+    }\n+    .even {\n+        background-color: #ee7756;\n+        color: #551133;\n+    }\n+    .code {\n+        --index: calc(var(--layer) - 1);\n+        padding-top: calc(var(--index) * 0.15em);\n+        filter:\n+            hue-rotate(calc(var(--index) * 25deg))\n+            saturate(calc(100% - (var(--index) * 2%)))\n+            brightness(calc(100% - (var(--index) * 1.5%)));\n+    }\n+    .annotation {\n+        color: #4444ff;\n+        font-family: monospace;\n+        font-style: italic;\n+        display: none;\n+        -webkit-user-select: none;\n+    }\n+    body:active .annotation {\n+        /* requires holding mouse down anywhere on the page */\n+        display: inline-block;\n+    }\n+    span:hover .annotation {\n+        /* requires hover over a span ONLY on its first line */\n+        display: inline-block;\n+    }\n+    </style>\n+</head>\n+<body>\n+<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span class=\"code\" style=\"--layer: 0\">fn main() </span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb0: $DIR/spanview-block.rs:5:11: 5:13:\n+    5:11-5:13: Assign: _0 = const ()\n+    5:13-5:13: Goto: goto -&gt; bb2\"><span class=\"annotation\">@bb0:</span> {}</span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb2: $DIR/spanview-block.rs:5:13: 5:13:\n+    5:13-5:13: Return: return\"><span class=\"annotation\">@bb2</span></span></span></span></div>\n+</body>\n+</html>"}, {"sha": "f8662a3277a05e472513a6f95bb19df6f584b314", "filename": "src/test/mir-opt/spanview_statement.main.mir_map.0.html", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview_statement.main.mir_map.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview_statement.main.mir_map.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview_statement.main.mir_map.0.html?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -0,0 +1,67 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>coverage_of_if_else - Code Regions</title>\n+    <style>\n+    .line {\n+        counter-increment: line;\n+    }\n+    .line:before {\n+        content: counter(line) \": \";\n+        font-family: Menlo, Monaco, monospace;\n+        font-style: italic;\n+        width: 3.8em;\n+        display: inline-block;\n+        text-align: right;\n+        filter: opacity(50%);\n+        -webkit-user-select: none;\n+    }\n+    .code {\n+        color: #dddddd;\n+        background-color: #222222;\n+        font-family: Menlo, Monaco, monospace;\n+        line-height: 1.4em;\n+        border-bottom: 2px solid #222222;\n+        white-space: pre;\n+        display: inline-block;\n+    }\n+    .odd {\n+        background-color: #55bbff;\n+        color: #223311;\n+    }\n+    .even {\n+        background-color: #ee7756;\n+        color: #551133;\n+    }\n+    .code {\n+        --index: calc(var(--layer) - 1);\n+        padding-top: calc(var(--index) * 0.15em);\n+        filter:\n+            hue-rotate(calc(var(--index) * 25deg))\n+            saturate(calc(100% - (var(--index) * 2%)))\n+            brightness(calc(100% - (var(--index) * 1.5%)));\n+    }\n+    .annotation {\n+        color: #4444ff;\n+        font-family: monospace;\n+        font-style: italic;\n+        display: none;\n+        -webkit-user-select: none;\n+    }\n+    body:active .annotation {\n+        /* requires holding mouse down anywhere on the page */\n+        display: inline-block;\n+    }\n+    span:hover .annotation {\n+        /* requires hover over a span ONLY on its first line */\n+        display: inline-block;\n+    }\n+    </style>\n+</head>\n+<body>\n+<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span class=\"code\" style=\"--layer: 0\">fn main() </span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb0[0]: $DIR/spanview-statement.rs:5:11: 5:13:\n+    5:11-5:13: Assign: _0 = const ()\"><span class=\"annotation\">@bb0[0]:</span> {}</span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb0`Goto`: $DIR/spanview-statement.rs:5:13: 5:13:\n+    5:13-5:13: Goto: goto -&gt; bb2\"><span class=\"annotation\">@bb0`Goto`</span></span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb2`Return`: $DIR/spanview-statement.rs:5:13: 5:13:\n+    5:13-5:13: Return: return\"><span class=\"annotation\">@bb2`Return`</span></span></span></span></div>\n+</body>\n+</html>"}, {"sha": "d0a11a8d2629d06f2db783eaac7b82f857853f96", "filename": "src/test/mir-opt/spanview_terminator.main.mir_map.0.html", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview_terminator.main.mir_map.0.html", "raw_url": "https://github.com/rust-lang/rust/raw/5f28831a40477a0d564368e11fe6c5d6a26cd56f/src%2Ftest%2Fmir-opt%2Fspanview_terminator.main.mir_map.0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fspanview_terminator.main.mir_map.0.html?ref=5f28831a40477a0d564368e11fe6c5d6a26cd56f", "patch": "@@ -0,0 +1,66 @@\n+<!DOCTYPE html>\n+<html>\n+<head>\n+    <title>coverage_of_if_else - Code Regions</title>\n+    <style>\n+    .line {\n+        counter-increment: line;\n+    }\n+    .line:before {\n+        content: counter(line) \": \";\n+        font-family: Menlo, Monaco, monospace;\n+        font-style: italic;\n+        width: 3.8em;\n+        display: inline-block;\n+        text-align: right;\n+        filter: opacity(50%);\n+        -webkit-user-select: none;\n+    }\n+    .code {\n+        color: #dddddd;\n+        background-color: #222222;\n+        font-family: Menlo, Monaco, monospace;\n+        line-height: 1.4em;\n+        border-bottom: 2px solid #222222;\n+        white-space: pre;\n+        display: inline-block;\n+    }\n+    .odd {\n+        background-color: #55bbff;\n+        color: #223311;\n+    }\n+    .even {\n+        background-color: #ee7756;\n+        color: #551133;\n+    }\n+    .code {\n+        --index: calc(var(--layer) - 1);\n+        padding-top: calc(var(--index) * 0.15em);\n+        filter:\n+            hue-rotate(calc(var(--index) * 25deg))\n+            saturate(calc(100% - (var(--index) * 2%)))\n+            brightness(calc(100% - (var(--index) * 1.5%)));\n+    }\n+    .annotation {\n+        color: #4444ff;\n+        font-family: monospace;\n+        font-style: italic;\n+        display: none;\n+        -webkit-user-select: none;\n+    }\n+    body:active .annotation {\n+        /* requires holding mouse down anywhere on the page */\n+        display: inline-block;\n+    }\n+    span:hover .annotation {\n+        /* requires hover over a span ONLY on its first line */\n+        display: inline-block;\n+    }\n+    </style>\n+</head>\n+<body>\n+<div class=\"code\" style=\"counter-reset: line 4\"><span class=\"line\"><span class=\"code\" style=\"--layer: 0\">fn main() {}</span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb0`Goto`: $DIR/spanview-terminator.rs:5:13: 5:13:\n+    5:13-5:13: Goto: goto -&gt; bb2\"><span class=\"annotation\">@bb0`Goto`</span></span></span><span><span class=\"code even\" style=\"--layer: 1\" title=\"bb2`Return`: $DIR/spanview-terminator.rs:5:13: 5:13:\n+    5:13-5:13: Return: return\"><span class=\"annotation\">@bb2`Return`</span></span></span></span></div>\n+</body>\n+</html>"}]}