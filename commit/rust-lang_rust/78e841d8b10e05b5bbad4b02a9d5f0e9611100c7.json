{"sha": "78e841d8b10e05b5bbad4b02a9d5f0e9611100c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4ZTg0MWQ4YjEwZTA1YjViYmFkNGIwMmE5ZDVmMGU5NjExMTAwYzc=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-03T04:05:30Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2015-01-06T02:21:14Z"}, "message": "Update docs", "tree": {"sha": "0142c9ff8c8ba7d361c4669513ea5f9dbe235443", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0142c9ff8c8ba7d361c4669513ea5f9dbe235443"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7", "html_url": "https://github.com/rust-lang/rust/commit/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34b995d9e2f46e10124ac67a6249d9ef022972a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/34b995d9e2f46e10124ac67a6249d9ef022972a9", "html_url": "https://github.com/rust-lang/rust/commit/34b995d9e2f46e10124ac67a6249d9ef022972a9"}], "stats": {"total": 233, "additions": 140, "deletions": 93}, "files": [{"sha": "dc6d281307a7a602e746a599b78f16961f628da9", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 97, "deletions": 58, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=78e841d8b10e05b5bbad4b02a9d5f0e9611100c7", "patch": "@@ -1,14 +1,5 @@\n % The Rust Macros Guide\n \n-<div class=\"unstable-feature\">\n-<b>Warning:</b> There are currently various problems with invoking macros, how\n-they interact with their environment, and how they are used outside of the\n-location in which they are defined. Macro definitions are likely to change\n-slightly in the future. For this reason, they are hidden behind the\n-<code>macro_rules</code> <a href=\"reference.html#compiler-features\">feature\n-attribute</a>.\n-</div>\n-\n # Introduction\n \n Functions are the primary tool that programmers can use to build abstractions.\n@@ -46,19 +37,18 @@ lightweight custom syntax extensions, themselves defined using the\n the pattern in the above code:\n \n ~~~~\n-# #![feature(macro_rules)]\n # enum T { SpecialA(uint), SpecialB(uint) }\n # fn f() -> uint {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n-macro_rules! early_return(\n+macro_rules! early_return {\n     ($inp:expr $sp:path) => ( // invoke it like `(input_5 SpecialE)`\n         match $inp {\n             $sp(x) => { return x; }\n             _ => {}\n         }\n     );\n-);\n+}\n // ...\n early_return!(input_1 T::SpecialA);\n // ...\n@@ -109,10 +99,10 @@ that could be invoked like: `my_macro!(i->(( 2+2 )))`.\n \n ## Invocation location\n \n-A macro invocation may take the place of (and therefore expand to)\n-an expression, an item, or a statement.\n-The Rust parser will parse the macro invocation as a \"placeholder\"\n-for whichever of those three nonterminals is appropriate for the location.\n+A macro invocation may take the place of (and therefore expand to) an\n+expression, item, statement, or pattern.  The Rust parser will parse the macro\n+invocation as a \"placeholder\" for whichever syntactic form is appropriate for\n+the location.\n \n At expansion time, the output of the macro will be parsed as whichever of the\n three nonterminals it stands in for. This means that a single macro might,\n@@ -166,12 +156,11 @@ separator token (a comma-separated list could be written `$(...),*`), and `+`\n instead of `*` to mean \"at least one\".\n \n ~~~~\n-# #![feature(macro_rules)]\n # enum T { SpecialA(uint),SpecialB(uint),SpecialC(uint),SpecialD(uint)}\n # fn f() -> uint {\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n-macro_rules! early_return(\n+macro_rules! early_return {\n     ($inp:expr, [ $($sp:path)|+ ]) => (\n         match $inp {\n             $(\n@@ -180,7 +169,7 @@ macro_rules! early_return(\n             _ => {}\n         }\n     )\n-);\n+}\n // ...\n early_return!(input_1, [T::SpecialA|T::SpecialC|T::SpecialD]);\n // ...\n@@ -228,7 +217,6 @@ solves the problem.\n Now consider code like the following:\n \n ~~~~\n-# #![feature(macro_rules)]\n # enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n # enum T3 { Good2(uint), Bad2}\n@@ -255,8 +243,7 @@ a match, but with a syntax that suits the problem better. The following macro\n can solve the problem:\n \n ~~~~\n-# #![feature(macro_rules)]\n-macro_rules! biased_match (\n+macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n     ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n       binds $bind_res:ident\n@@ -275,7 +262,7 @@ macro_rules! biased_match (\n             _ => { $err }\n         };\n     )\n-);\n+}\n \n # enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n@@ -297,13 +284,12 @@ like this, we might prefer to write a single macro invocation. The input\n pattern we want is clear:\n \n ~~~~\n-# #![feature(macro_rules)]\n # fn main() {}\n-# macro_rules! b(\n+# macro_rules! b {\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $( $bind_res:ident ),*\n     )\n-# => (0));\n+# => (0) }\n ~~~~\n \n However, it's not possible to directly expand to nested match statements. But\n@@ -320,35 +306,32 @@ process the semicolon-terminated lines, one-by-one. So, we want the following\n input patterns:\n \n ~~~~\n-# #![feature(macro_rules)]\n-# macro_rules! b(\n+# macro_rules! b {\n     ( binds $( $bind_res:ident ),* )\n-# => (0));\n+# => (0) }\n # fn main() {}\n ~~~~\n \n ...and:\n \n ~~~~\n-# #![feature(macro_rules)]\n # fn main() {}\n-# macro_rules! b(\n+# macro_rules! b {\n     (    ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n       $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     )\n-# => (0));\n+# => (0) }\n ~~~~\n \n The resulting macro looks like this. Note that the separation into\n `biased_match!` and `biased_match_rec!` occurs only because we have an outer\n piece of syntax (the `let`) which we only want to transcribe once.\n \n ~~~~\n-# #![feature(macro_rules)]\n # fn main() {\n \n-macro_rules! biased_match_rec (\n+macro_rules! biased_match_rec {\n     // Handle the first layer\n     (   ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n      $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n@@ -366,10 +349,10 @@ macro_rules! biased_match_rec (\n     );\n     // Produce the requested values\n     ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n-);\n+}\n \n // Wrap the whole thing in a `let`.\n-macro_rules! biased_match (\n+macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $bind_res:ident\n@@ -388,7 +371,7 @@ macro_rules! biased_match (\n             binds $( $bind_res ),*\n         );\n     )\n-);\n+}\n \n \n # enum T1 { Good1(T2, uint), Bad1}\n@@ -434,17 +417,15 @@ As an example, `loop` and `for-loop` labels (discussed in the lifetimes guide)\n will not clash. The following code will print \"Hello!\" only once:\n \n ~~~\n-#![feature(macro_rules)]\n-\n-macro_rules! loop_x (\n+macro_rules! loop_x {\n     ($e: expr) => (\n         // $e will not interact with this 'x\n         'x: loop {\n             println!(\"Hello!\");\n             $e\n         }\n     );\n-);\n+}\n \n fn main() {\n     'x: loop {\n@@ -467,45 +448,53 @@ lexical-order traversal of a crate's source. So a macro defined at module scope\n is visible to any subsequent code in the same module, which includes the body\n of any subsequent child `mod` items.\n \n-If a module has the `macro_escape` attribute, its macros are also visible in\n-its parent module after the child's `mod` item. If the parent also has\n-`macro_escape` then the macros will be visible in the grandparent after the\n-parent's `mod` item, and so forth.\n+If a module has the `macro_use` attribute, its macros are also visible in its\n+parent module after the child's `mod` item. If the parent also has `macro_use`\n+then the macros will be visible in the grandparent after the parent's `mod`\n+item, and so forth.\n \n-Independent of `macro_escape`, the `macro_export` attribute controls visibility\n-between crates.  Any `macro_rules!` definition with the `macro_export`\n-attribute will be visible to other crates that have loaded this crate with\n-`phase(plugin)`. There is currently no way for the importing crate to control\n-which macros are imported.\n+The `macro_use` attribute can also appear on `extern crate`.  In this context\n+it controls which macros are loaded from the external crate, e.g.\n+\n+```rust,ignore\n+#[macro_use(foo, bar)]\n+extern crate baz;\n+```\n+\n+If the attribute is given simply as `#[macro_use]`, all macros are loaded.  If\n+there is no `#[macro_use]` attribute then no macros are loaded.  Only macros\n+defined with the `#[macro_export]` attribute may be loaded.\n+\n+To load a crate's macros *without* linking it into the output, use `#[no_link]`\n+as well.\n \n An example:\n \n ```rust\n-# #![feature(macro_rules)]\n-macro_rules! m1 (() => (()));\n+macro_rules! m1 { () => (()) }\n \n // visible here: m1\n \n mod foo {\n     // visible here: m1\n \n     #[macro_export]\n-    macro_rules! m2 (() => (()));\n+    macro_rules! m2 { () => (()) }\n \n     // visible here: m1, m2\n }\n \n // visible here: m1\n \n-macro_rules! m3 (() => (()));\n+macro_rules! m3 { () => (()) }\n \n // visible here: m1, m3\n \n-#[macro_escape]\n+#[macro_use]\n mod bar {\n     // visible here: m1, m3\n \n-    macro_rules! m4 (() => (()));\n+    macro_rules! m4 { () => (()) }\n \n     // visible here: m1, m3, m4\n }\n@@ -514,8 +503,58 @@ mod bar {\n # fn main() { }\n ```\n \n-When this library is loaded with `#[phase(plugin)] extern crate`, only `m2`\n-will be imported.\n+When this library is loaded with `#[use_macros] extern crate`, only `m2` will\n+be imported.\n+\n+The Rust Reference has a [listing of macro-related\n+attributes](reference.html#macro--and-plugin-related-attributes).\n+\n+# The variable `$crate`\n+\n+A further difficulty occurs when a macro is used in multiple crates.  Say that\n+`mylib` defines\n+\n+```rust\n+pub fn increment(x: uint) -> uint {\n+    x + 1\n+}\n+\n+#[macro_export]\n+macro_rules! inc_a {\n+    ($x:expr) => ( ::increment($x) )\n+}\n+\n+#[macro_export]\n+macro_rules! inc_b {\n+    ($x:expr) => ( ::mylib::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+`inc_a` only works within `mylib`, while `inc_b` only works outside the\n+library.  Furthermore, `inc_b` will break if the user imports `mylib` under\n+another name.\n+\n+Rust does not (yet) have a hygiene system for crate references, but it does\n+provide a simple workaround for this problem.  Within a macro imported from a\n+crate named `foo`, the special macro variable `$crate` will expand to `::foo`.\n+By contrast, when a macro is defined and then used in the same crate, `$crate`\n+will expand to nothing.  This means we can write\n+\n+```rust\n+#[macro_export]\n+macro_rules! inc {\n+    ($x:expr) => ( $crate::increment($x) )\n+}\n+# fn main() { }\n+```\n+\n+to define a single macro that works both inside and outside our library.  The\n+function name will expand to either `::increment` or `::mylib::increment`.\n+\n+To keep this system simple and correct, `#[macro_use] extern crate ...` may\n+only appear at the root of your crate, not inside `mod`.  This ensures that\n+`$crate` is a single identifier.\n \n # A final note\n "}, {"sha": "025f0cced63a6a6cb6b3dd37f793ecd07ba84a99", "filename": "src/doc/guide-plugin.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7/src%2Fdoc%2Fguide-plugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7/src%2Fdoc%2Fguide-plugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-plugin.md?ref=78e841d8b10e05b5bbad4b02a9d5f0e9611100c7", "patch": "@@ -31,10 +31,14 @@ extend the compiler's behavior with new syntax extensions, lint checks, etc.\n \n A plugin is a dynamic library crate with a designated \"registrar\" function that\n registers extensions with `rustc`. Other crates can use these extensions by\n-loading the plugin crate with `#[phase(plugin)] extern crate`. See the\n+loading the plugin crate with `#[plugin] extern crate`. See the\n [`rustc::plugin`](rustc/plugin/index.html) documentation for more about the\n mechanics of defining and loading a plugin.\n \n+Arguments passed as `#[plugin=...]` or `#[plugin(...)]` are not interpreted by\n+rustc itself.  They are provided to the plugin through the `Registry`'s [`args`\n+method](rustc/plugin/registry/struct.Registry.html#method.args).\n+\n # Syntax extensions\n \n Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n@@ -105,10 +109,9 @@ pub fn plugin_registrar(reg: &mut Registry) {\n Then we can use `rn!()` like any other macro:\n \n ```ignore\n-#![feature(phase)]\n+#![feature(plugin)]\n \n-#[phase(plugin)]\n-extern crate roman_numerals;\n+#[plugin] extern crate roman_numerals;\n \n fn main() {\n     assert_eq!(rn!(MMXV), 2015);\n@@ -217,8 +220,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n Then code like\n \n ```ignore\n-#[phase(plugin)]\n-extern crate lint_plugin_test;\n+#[plugin] extern crate lint_plugin_test;\n \n fn lintme() { }\n ```"}, {"sha": "829c0e675146a6e7835b45e30b0da486c9e0bd79", "filename": "src/doc/reference.md", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/78e841d8b10e05b5bbad4b02a9d5f0e9611100c7/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=78e841d8b10e05b5bbad4b02a9d5f0e9611100c7", "patch": "@@ -668,9 +668,11 @@ transcriber : '(' transcriber * ')' | '[' transcriber * ']'\n             | non_special_token ;\n ```\n \n-User-defined syntax extensions are called \"macros\", and the `macro_rules`\n-syntax extension defines them. Currently, user-defined macros can expand to\n-expressions, statements, items, or patterns.\n+`macro_rules` allows users to define syntax extension in a declarative way.  We\n+call such extensions \"macros by example\" or simply \"macros\" \u2014 to be distinguished\n+from the \"procedural macros\" defined in [compiler plugins][plugin].\n+\n+Currently, macros can expand to expressions, statements, items, or patterns.\n \n (A `sep_token` is any token other than `*` and `+`. A `non_special_token` is\n any token other than a delimiter or `$`.)\n@@ -2002,8 +2004,6 @@ type int8_t = i8;\n \n ### Module-only attributes\n \n-- `macro_escape` - macros defined in this module will be visible in the\n-  module's parent, after this module has been included.\n - `no_implicit_prelude` - disable injecting `use std::prelude::*` in this\n   module.\n - `path` - specifies the file to load the module from. `#[path=\"foo.rs\"] mod\n@@ -2066,23 +2066,43 @@ On `struct`s:\n   remove any padding between fields (note that this is very fragile and may\n   break platforms which require aligned access).\n \n+### Macro- and plugin-related attributes\n+\n+- `macro_use` on a `mod` \u2014 macros defined in this module will be visible in the\n+  module's parent, after this module has been included.\n+\n+- `macro_use` on an `extern crate` \u2014 load macros from this crate.  An optional\n+  list of names `#[macro_use(foo, bar)]` restricts the import to just those\n+  macros named.  The `extern crate` must appear at the crate root, not inside\n+  `mod`, which ensures proper function of the [`$crate` macro\n+  variable](guide-macros.html#the-variable-$crate).\n+\n+- `macro_reexport` on an `extern crate` \u2014 re-export the named macros.\n+\n+- `macro_export` - export a macro for cross-crate usage.\n+\n+- `plugin` on an `extern crate`\u00a0\u2014 load this crate as a [compiler\n+  plugin][plugin].  The `plugin` feature gate is required.  Any arguments to\n+  the attribute, e.g. `#[plugin=...]` or `#[plugin(...)]`, are provided to the\n+  plugin.\n+\n+- `no_link` on an `extern crate` \u2014 even if we load this crate for macros or\n+  compiler plugins, don't link it into the output.\n+\n+See the [macros guide](guide-macros.html#scoping-and-macro-import/export) for\n+more information on macro scope.\n+\n+\n ### Miscellaneous attributes\n \n - `export_name` - on statics and functions, this determines the name of the\n   exported symbol.\n - `link_section` - on statics and functions, this specifies the section of the\n   object file that this item's contents will be placed into.\n-- `macro_export` - export a macro for cross-crate usage.\n - `no_mangle` - on any item, do not apply the standard name mangling. Set the\n   symbol for this item to its identifier.\n - `packed` - on structs or enums, eliminate any padding that would be used to\n   align fields.\n-- `phase` - on `extern crate` statements, allows specifying which \"phase\" of\n-  compilation the crate should be loaded for. Currently, there are two\n-  choices: `link` and `plugin`. `link` is the default. `plugin` will [load the\n-  crate at compile-time][plugin] and use any syntax extensions or lints that the crate\n-  defines. They can both be specified, `#[phase(link, plugin)]` to use a crate\n-  both at runtime and compiletime.\n - `simd` - on certain tuple structs, derive the arithmetic operators, which\n   lower to the target's SIMD instructions, if any; the `simd` feature gate\n   is necessary to use this attribute.\n@@ -2569,15 +2589,6 @@ The currently implemented features of the reference compiler are:\n * `log_syntax` - Allows use of the `log_syntax` macro attribute, which is a\n                  nasty hack that will certainly be removed.\n \n-* `macro_rules` - The definition of new macros. This does not encompass\n-                  macro-invocation, that is always enabled by default, this\n-                  only covers the definition of new macros. There are currently\n-                  various problems with invoking macros, how they interact with\n-                  their environment, and possibly how they are used outside of\n-                  location in which they are defined. Macro definitions are\n-                  likely to change slightly in the future, so they are\n-                  currently hidden behind this feature.\n-\n * `non_ascii_idents` - The compiler supports the use of non-ascii identifiers,\n                        but the implementation is a little rough around the\n                        edges, so this can be seen as an experimental feature\n@@ -2588,15 +2599,10 @@ The currently implemented features of the reference compiler are:\n                closure as `once` is unlikely to be supported going forward. So\n                they are hidden behind this feature until they are to be removed.\n \n-* `phase` - Usage of the `#[phase]` attribute allows loading compiler plugins\n-            for custom lints or syntax extensions. The implementation is\n-            considered unwholesome and in need of overhaul, and it is not clear\n-            what they will look like moving forward.\n+* `plugin` - Usage of [compiler plugins][plugin] for custom lints or syntax extensions.\n+             These depend on compiler internals and are subject to change.\n \n-* `plugin_registrar` - Indicates that a crate has [compiler plugins][plugin] that it\n-                       wants to load. As with `phase`, the implementation is\n-                       in need of an overhaul, and it is not clear that plugins\n-                       defined using this will continue to work.\n+* `plugin_registrar` - Indicates that a crate provides [compiler plugins][plugin].\n \n * `quote` - Allows use of the `quote_*!` family of macros, which are\n             implemented very poorly and will likely change significantly"}]}