{"sha": "7f5721c3f470f9c393db239c01dc051ec84430c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNTcyMWMzZjQ3MGY5YzM5M2RiMjM5YzAxZGMwNTFlYzg0NDMwYzg=", "commit": {"author": {"name": "Ding Xiang Fei", "email": "dingxiangfei2009@protonmail.ch", "date": "2020-08-06T07:37:12Z"}, "committer": {"name": "Ding Xiang Fei", "email": "dingxiangfei2009@protonmail.ch", "date": "2020-10-13T16:50:55Z"}, "message": "also record the types of borrows from the pattern locals in match guards\n\nso that it reflects the fact that borrowing these pattern locals is happening\nbefore any yield points in match guards", "tree": {"sha": "3c2c6c82150125aab53ef46da75cad51381f4246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c2c6c82150125aab53ef46da75cad51381f4246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f5721c3f470f9c393db239c01dc051ec84430c8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE0u8S3YU336XkLsQOPNdIZH7vY1kFAl+F2u8ACgkQPNdIZH7v\nY1kfyg//bDDKMCXqE54PqKXuFI4ImsPzSKNGQ69TLa9Lisqmi//dpBAuEa55O06p\nhmBPYhpUqndqDkKQMMXNovMPX+VA/ZIrbDueAV4aJIHc5y+l8+vQWDKnbf2NzKmY\ndZ8COxjLTpGTX/xGrHx7wHBfU4T6pXd/Vi8Rly0is5V19zw4TaLk1FY1U75y+Wbr\nz0tIcpLH4L9Kgj3+p3myhD4Fzqm2eNpPT3LNHF4HzZt3t5/pBGG8pDtX98Z3AcOk\n1KbKdSVHf+SkKUvUT9pGFDZuHMfyqEPGgH3EUs4Jk2NaaUnXLZg4Ie9P/tFzpy8j\nxMCasP///TJrXGpuWTTdX8Z3l/W2Vr7O3wBnbzIWPz2cqegY8JZtMqfPEkp5jrDB\nlpXrATPG+anAQ8fqVqLF8tskMThWsXtwKyH2Ox5DI8DdO3Aemc9m8K52V/cwdYhZ\n0zTm+1+mZ04T3F3oxzA+3NaQaMCheSXHc9vM3FBxP6mLOLgp3yMn7z73cCO1wdjk\naySNgOmfu7jrrDV9yXk9f5BbaqEq0hod4MTWQkWyFO+V71t8rk+m6BHfHaxWcNDA\ni5trm9QgsjCR+61LSRHXg56OwSXzgtbXDy4a6uPsLeBiq6hDZP3PvfsFd4g9ABUX\nS1O14DkZ47pTl17Lx68OPFgMXy3yTAml5XZrbWwkx8CTd2jlFaY=\n=ho1h\n-----END PGP SIGNATURE-----", "payload": "tree 3c2c6c82150125aab53ef46da75cad51381f4246\nparent f9ccd39ae38051463771495e03889bf3aeff616a\nauthor Ding Xiang Fei <dingxiangfei2009@protonmail.ch> 1596699432 +0800\ncommitter Ding Xiang Fei <dingxiangfei2009@protonmail.ch> 1602607855 +0800\n\nalso record the types of borrows from the pattern locals in match guards\n\nso that it reflects the fact that borrowing these pattern locals is happening\nbefore any yield points in match guards\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5721c3f470f9c393db239c01dc051ec84430c8", "html_url": "https://github.com/rust-lang/rust/commit/7f5721c3f470f9c393db239c01dc051ec84430c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f5721c3f470f9c393db239c01dc051ec84430c8/comments", "author": {"login": "dingxiangfei2009", "id": 6884440, "node_id": "MDQ6VXNlcjY4ODQ0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6884440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingxiangfei2009", "html_url": "https://github.com/dingxiangfei2009", "followers_url": "https://api.github.com/users/dingxiangfei2009/followers", "following_url": "https://api.github.com/users/dingxiangfei2009/following{/other_user}", "gists_url": "https://api.github.com/users/dingxiangfei2009/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingxiangfei2009/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingxiangfei2009/subscriptions", "organizations_url": "https://api.github.com/users/dingxiangfei2009/orgs", "repos_url": "https://api.github.com/users/dingxiangfei2009/repos", "events_url": "https://api.github.com/users/dingxiangfei2009/events{/privacy}", "received_events_url": "https://api.github.com/users/dingxiangfei2009/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dingxiangfei2009", "id": 6884440, "node_id": "MDQ6VXNlcjY4ODQ0NDA=", "avatar_url": "https://avatars.githubusercontent.com/u/6884440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dingxiangfei2009", "html_url": "https://github.com/dingxiangfei2009", "followers_url": "https://api.github.com/users/dingxiangfei2009/followers", "following_url": "https://api.github.com/users/dingxiangfei2009/following{/other_user}", "gists_url": "https://api.github.com/users/dingxiangfei2009/gists{/gist_id}", "starred_url": "https://api.github.com/users/dingxiangfei2009/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dingxiangfei2009/subscriptions", "organizations_url": "https://api.github.com/users/dingxiangfei2009/orgs", "repos_url": "https://api.github.com/users/dingxiangfei2009/repos", "events_url": "https://api.github.com/users/dingxiangfei2009/events{/privacy}", "received_events_url": "https://api.github.com/users/dingxiangfei2009/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9ccd39ae38051463771495e03889bf3aeff616a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ccd39ae38051463771495e03889bf3aeff616a", "html_url": "https://github.com/rust-lang/rust/commit/f9ccd39ae38051463771495e03889bf3aeff616a"}], "stats": {"total": 70, "additions": 61, "deletions": 9}, "files": [{"sha": "25268b554e1cec520937baeae08f6d365027d6f7", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7f5721c3f470f9c393db239c01dc051ec84430c8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5721c3f470f9c393db239c01dc051ec84430c8/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=7f5721c3f470f9c393db239c01dc051ec84430c8", "patch": "@@ -9,10 +9,12 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, ExprKind, Pat, PatKind};\n+use rustc_hir::{Expr, ExprKind, Pat, PatKind, Arm, Guard, HirId};\n+use rustc_hir::hir_id::HirIdSet;\n use rustc_middle::middle::region::{self, YieldData};\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n+use smallvec::SmallVec;\n \n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n@@ -21,6 +23,14 @@ struct InteriorVisitor<'a, 'tcx> {\n     expr_count: usize,\n     kind: hir::GeneratorKind,\n     prev_unresolved_span: Option<Span>,\n+    /// Match arm guards have temporary borrows from the pattern bindings.\n+    /// In case there is a yield point in a guard with a reference to such bindings,\n+    /// such borrows can span across this yield point.\n+    /// As such, we need to track these borrows and record them despite of the fact\n+    /// that they may succeed the said yield point in the post-order.\n+    nested_scope_of_guards: SmallVec<[SmallVec<[HirId; 4]>; 4]>,\n+    current_scope_of_guards: HirIdSet,\n+    arm_has_guard: bool,\n }\n \n impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n@@ -30,6 +40,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n         scope: Option<region::Scope>,\n         expr: Option<&'tcx Expr<'tcx>>,\n         source_span: Span,\n+        guard_borrowing_from_pattern: bool,\n     ) {\n         use rustc_span::DUMMY_SP;\n \n@@ -53,7 +64,7 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                         yield_data.expr_and_pat_count, self.expr_count, source_span\n                     );\n \n-                    if yield_data.expr_and_pat_count >= self.expr_count {\n+                    if guard_borrowing_from_pattern || yield_data.expr_and_pat_count >= self.expr_count {\n                         Some(yield_data)\n                     } else {\n                         None\n@@ -134,6 +145,9 @@ pub fn resolve_interior<'a, 'tcx>(\n         expr_count: 0,\n         kind,\n         prev_unresolved_span: None,\n+        nested_scope_of_guards: <_>::default(),\n+        current_scope_of_guards: <_>::default(),\n+        arm_has_guard: false,\n     };\n     intravisit::walk_body(&mut visitor, body);\n \n@@ -210,19 +224,46 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n \n+    fn visit_arm(&mut self, arm: &'tcx Arm<'tcx>) {\n+        if arm.guard.is_some() {\n+            self.nested_scope_of_guards.push(<_>::default());\n+            self.arm_has_guard = true;\n+        }\n+        self.visit_pat(&arm.pat);\n+        if let Some(ref g) = arm.guard {\n+            match g {\n+                Guard::If(ref e) => {\n+                    self.visit_expr(e);\n+                }\n+            }\n+            let mut scope_var_ids =\n+                self.nested_scope_of_guards.pop().expect(\"should have pushed at least one earlier\");\n+            for var_id in scope_var_ids.drain(..) {\n+                assert!(self.current_scope_of_guards.remove(&var_id), \"variable should be placed in scope earlier\");\n+            }\n+            self.arm_has_guard = false;\n+        }\n+        self.visit_expr(&arm.body);\n+    }\n+\n     fn visit_pat(&mut self, pat: &'tcx Pat<'tcx>) {\n         intravisit::walk_pat(self, pat);\n \n         self.expr_count += 1;\n \n-        if let PatKind::Binding(..) = pat.kind {\n+        if let PatKind::Binding(_, id, ..) = pat.kind {\n             let scope = self.region_scope_tree.var_scope(pat.hir_id.local_id);\n             let ty = self.fcx.typeck_results.borrow().pat_ty(pat);\n-            self.record(ty, Some(scope), None, pat.span);\n+            self.record(ty, Some(scope), None, pat.span, false);\n+            if self.arm_has_guard {\n+                self.nested_scope_of_guards.as_mut_slice().last_mut().unwrap().push(id);\n+                self.current_scope_of_guards.insert(id);\n+            }\n         }\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        let mut guard_borrowing_from_pattern = false;\n         match &expr.kind {\n             ExprKind::Call(callee, args) => match &callee.kind {\n                 ExprKind::Path(qpath) => {\n@@ -248,7 +289,18 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n                     }\n                 }\n                 _ => intravisit::walk_expr(self, expr),\n-            },\n+            }\n+            ExprKind::Path(qpath) => {\n+                intravisit::walk_expr(self, expr);\n+                let res = self.fcx.typeck_results.borrow().qpath_res(qpath, expr.hir_id);\n+                match res {\n+                    Res::Local(id) if self.current_scope_of_guards.contains(&id) => {\n+                        debug!(\"a borrow in guard from pattern local is detected\");\n+                        guard_borrowing_from_pattern = true;\n+                    }\n+                    _ => {}\n+                }\n+            }\n             _ => intravisit::walk_expr(self, expr),\n         }\n \n@@ -259,18 +311,18 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // If there are adjustments, then record the final type --\n         // this is the actual value that is being produced.\n         if let Some(adjusted_ty) = self.fcx.typeck_results.borrow().expr_ty_adjusted_opt(expr) {\n-            self.record(adjusted_ty, scope, Some(expr), expr.span);\n+            self.record(adjusted_ty, scope, Some(expr), expr.span, guard_borrowing_from_pattern);\n         }\n \n         // Also record the unadjusted type (which is the only type if\n         // there are no adjustments). The reason for this is that the\n         // unadjusted value is sometimes a \"temporary\" that would wind\n         // up in a MIR temporary.\n         //\n-        // As an example, consider an expression like `vec![].push()`.\n+        // As an example, consider an expression like `vec![].push(x)`.\n         // Here, the `vec![]` would wind up MIR stored into a\n         // temporary variable `t` which we can borrow to invoke\n-        // `<Vec<_>>::push(&mut t)`.\n+        // `<Vec<_>>::push(&mut t, x)`.\n         //\n         // Note that an expression can have many adjustments, and we\n         // are just ignoring those intermediate types. This is because\n@@ -287,7 +339,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n         // The type table might not have information for this expression\n         // if it is in a malformed scope. (#66387)\n         if let Some(ty) = self.fcx.typeck_results.borrow().expr_ty_opt(expr) {\n-            self.record(ty, scope, Some(expr), expr.span);\n+            self.record(ty, scope, Some(expr), expr.span, guard_borrowing_from_pattern);\n         } else {\n             self.fcx.tcx.sess.delay_span_bug(expr.span, \"no type for node\");\n         }"}]}