{"sha": "728bb878acb374d313482cac41a2aa3a60af2a84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyOGJiODc4YWNiMzc0ZDMxMzQ4MmNhYzQxYTJhYTNhNjBhZjJhODQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-27T10:02:16Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-01T07:56:21Z"}, "message": "Move the `global_item` function to the `EvalContext`", "tree": {"sha": "8f6dc9f3eb07b780cce64e8aa0e1c41da8792244", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f6dc9f3eb07b780cce64e8aa0e1c41da8792244"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/728bb878acb374d313482cac41a2aa3a60af2a84", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmANCUACgkQpp+NIls6\n19nnwBAAhPaTO7dSQ2536Q90TeYV7GsaXMJFVzneXIffxdSwqdEs7BZuDA8P394v\ngAgkoQcBJapUXjDqUc2PzkUoJehfJn6GeKuQPNdGWSkjBV/GIvtN6MVkuzJgmUy4\nVGP5kT8qdNsJ4gR/2Z1w5PzZ1BOpnjUt8QEhxc8xinv1dhunJ+lib+tn69jEqAX9\nnriwCBuX4QE3Qbv+WhOdKEZaWxst/xqUrT7RvwBAHSR3xp7K34Wp1EP+SbOydaHl\n1GOxt1VU0aKm2lrp/p2994nsqBx6ylfQk4NlTL5pvNUzi04fqq4qExrVKu9vesAJ\nWaW2I/LUjoHVAzAsYwgcr3n/JsqzZEJPd8NGv4LFegwS8VttAxq3gM84uaXQBtX5\nkJ07P6qBOq1rNMh3SXR7cSZJRe2/QFMh6BAgUqTpLE/KoSxCpJWbZVCnRnJr8tK8\nB1zHHQo7DVezW1UnnFu/9EV6qnd4eFv2Q3QtyV8nX3/o+qChTFHajdB3Ccsinltt\nkcIdyZMQf9/3u1PM33zfAFLxP/k8uhuIhx7hnj30fbKvm7a4Z5FXPbP3t8d6a1tL\nYx8BCKRlJVFqUWUO1hi+7grM/70NIIhL8QSgJ7yi3OwYYIv6PcGzkxlsbsamNj/P\nE/qhGfsREPQYD1gxpCGtX2F7RVuzm3hb/VKkZHCn9bStSus5xpY=\n=2NL9\n-----END PGP SIGNATURE-----", "payload": "tree 8f6dc9f3eb07b780cce64e8aa0e1c41da8792244\nparent 960dca172d1102bb1ff3fded56427bc6e00c521e\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501149736 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1501574181 +0200\n\nMove the `global_item` function to the `EvalContext`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/728bb878acb374d313482cac41a2aa3a60af2a84", "html_url": "https://github.com/rust-lang/rust/commit/728bb878acb374d313482cac41a2aa3a60af2a84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/728bb878acb374d313482cac41a2aa3a60af2a84/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "960dca172d1102bb1ff3fded56427bc6e00c521e", "url": "https://api.github.com/repos/rust-lang/rust/commits/960dca172d1102bb1ff3fded56427bc6e00c521e", "html_url": "https://github.com/rust-lang/rust/commit/960dca172d1102bb1ff3fded56427bc6e00c521e"}], "stats": {"total": 116, "additions": 62, "deletions": 54}, "files": [{"sha": "78e8cbeecd78ff798501c8415ef00722ab8ba16d", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/728bb878acb374d313482cac41a2aa3a60af2a84/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/728bb878acb374d313482cac41a2aa3a60af2a84/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=728bb878acb374d313482cac41a2aa3a60af2a84", "patch": "@@ -5,6 +5,7 @@ license = \"MIT/Apache-2.0\"\n name = \"rustc_miri\"\n repository = \"https://github.com/solson/miri\"\n version = \"0.1.0\"\n+workspace = \"../..\"\n \n [lib]\n test = false"}, {"sha": "06d9d8b07fa3ff9421b67cf7eb4c7da53e08b1af", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 61, "deletions": 54, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/728bb878acb374d313482cac41a2aa3a60af2a84/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/728bb878acb374d313482cac41a2aa3a60af2a84/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=728bb878acb374d313482cac41a2aa3a60af2a84", "patch": "@@ -155,6 +155,49 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         }\n         Ok(())\n     }\n+\n+    /// returns `true` if a stackframe was pushed\n+    fn global_item(\n+        &mut self,\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+        span: Span,\n+        mutability: Mutability,\n+    ) -> EvalResult<'tcx, bool> {\n+        let instance = self.resolve_associated_const(def_id, substs);\n+        let cid = GlobalId { instance, promoted: None };\n+        if self.globals.contains_key(&cid) {\n+            return Ok(false);\n+        }\n+        if self.tcx.has_attr(def_id, \"linkage\") {\n+            // FIXME: check that it's `#[linkage = \"extern_weak\"]`\n+            trace!(\"Initializing an extern global with NULL\");\n+            self.globals.insert(cid, Global::initialized(self.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), mutability));\n+            return Ok(false);\n+        }\n+        let mir = self.load_mir(instance.def)?;\n+        self.globals.insert(cid, Global::uninitialized(mir.return_ty));\n+        let internally_mutable = !mir.return_ty.is_freeze(\n+                self.tcx,\n+                ty::ParamEnv::empty(Reveal::All),\n+                span);\n+        let mutability = if mutability == Mutability::Mutable || internally_mutable {\n+            Mutability::Mutable\n+        } else {\n+            Mutability::Immutable\n+        };\n+        let cleanup = StackPopCleanup::MarkStatic(mutability);\n+        let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));\n+        trace!(\"pushing stack frame for global: {}\", name);\n+        self.push_stack_frame(\n+            instance,\n+            span,\n+            mir,\n+            Lvalue::Global(cid),\n+            cleanup,\n+        )?;\n+        Ok(true)\n+    }\n }\n \n // WARNING: make sure that any methods implemented on this type don't ever access ecx.stack\n@@ -170,56 +213,19 @@ struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b, M: Machine<'tcx> + 'a> {\n }\n \n impl<'a, 'b, 'tcx, M: Machine<'tcx>> ConstantExtractor<'a, 'b, 'tcx, M> {\n-    fn global_item(\n-        &mut self,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        span: Span,\n-        mutability: Mutability,\n-    ) {\n-        let instance = self.ecx.resolve_associated_const(def_id, substs);\n-        let cid = GlobalId { instance, promoted: None };\n-        if self.ecx.globals.contains_key(&cid) {\n-            return;\n-        }\n-        if self.ecx.tcx.has_attr(def_id, \"linkage\") {\n-            trace!(\"Initializing an extern global with NULL\");\n-            self.ecx.globals.insert(cid, Global::initialized(self.ecx.tcx.type_of(def_id), Value::ByVal(PrimVal::Bytes(0)), mutability));\n-            return;\n-        }\n-        self.try(|this| {\n-            let mir = this.ecx.load_mir(instance.def)?;\n-            this.ecx.globals.insert(cid, Global::uninitialized(mir.return_ty));\n-            let internally_mutable = !mir.return_ty.is_freeze(\n-                    this.ecx.tcx,\n-                    ty::ParamEnv::empty(Reveal::All),\n-                    span);\n-            let mutability = if mutability == Mutability::Mutable || internally_mutable {\n-                Mutability::Mutable\n-            } else {\n-                Mutability::Immutable\n-            };\n-            let cleanup = StackPopCleanup::MarkStatic(mutability);\n-            let name = ty::tls::with(|tcx| tcx.item_path_str(def_id));\n-            trace!(\"pushing stack frame for global: {}\", name);\n-            this.ecx.push_stack_frame(\n-                instance,\n-                span,\n-                mir,\n-                Lvalue::Global(cid),\n-                cleanup,\n-            )\n-        });\n-    }\n-\n-    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx>>(&mut self, f: F) {\n-        if let Ok(ref mut n) = *self.new_constants {\n-            *n += 1;\n-        } else {\n-            return;\n-        }\n-        if let Err(e) = f(self) {\n-            *self.new_constants = Err(e);\n+    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, bool>>(&mut self, f: F) {\n+        // previous constant errored\n+        let n = match *self.new_constants {\n+            Ok(n) => n,\n+            Err(_) => return,\n+        };\n+        match f(self) {\n+            // everything ok + a new stackframe\n+            Ok(true) => *self.new_constants = Ok(n + 1),\n+            // constant correctly evaluated, but no new stackframe\n+            Ok(false) => {},\n+            // constant eval errored\n+            Err(err) => *self.new_constants = Err(err),\n         }\n     }\n }\n@@ -231,7 +237,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n             // already computed by rustc\n             mir::Literal::Value { .. } => {}\n             mir::Literal::Item { def_id, substs } => {\n-                self.global_item(def_id, substs, constant.span, Mutability::Immutable);\n+                self.try(|this| this.ecx.global_item(def_id, substs, constant.span, Mutability::Immutable));\n             },\n             mir::Literal::Promoted { index } => {\n                 let cid = GlobalId {\n@@ -251,7 +257,8 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n                                               mir,\n                                               Lvalue::Global(cid),\n                                               StackPopCleanup::MarkStatic(Mutability::Immutable),\n-                    )\n+                    )?;\n+                    Ok(true)\n                 });\n             }\n         }\n@@ -271,7 +278,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n             if let Some(node_item) = self.ecx.tcx.hir.get_if_local(def_id) {\n                 if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n                     if let hir::ItemStatic(_, m, _) = *node {\n-                        self.global_item(def_id, substs, span, if m == hir::MutMutable { Mutability::Mutable } else { Mutability::Immutable });\n+                        self.try(|this| this.ecx.global_item(def_id, substs, span, if m == hir::MutMutable { Mutability::Mutable } else { Mutability::Immutable }));\n                         return;\n                     } else {\n                         bug!(\"static def id doesn't point to static\");\n@@ -282,7 +289,7 @@ impl<'a, 'b, 'tcx, M: Machine<'tcx>> Visitor<'tcx> for ConstantExtractor<'a, 'b,\n             } else {\n                 let def = self.ecx.tcx.describe_def(def_id).expect(\"static not found\");\n                 if let hir::def::Def::Static(_, mutable) = def {\n-                    self.global_item(def_id, substs, span, if mutable { Mutability::Mutable } else { Mutability::Immutable });\n+                    self.try(|this| this.ecx.global_item(def_id, substs, span, if mutable { Mutability::Mutable } else { Mutability::Immutable }));\n                 } else {\n                     bug!(\"static found but isn't a static: {:?}\", def);\n                 }"}]}