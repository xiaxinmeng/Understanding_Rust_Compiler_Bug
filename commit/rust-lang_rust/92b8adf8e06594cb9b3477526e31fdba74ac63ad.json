{"sha": "92b8adf8e06594cb9b3477526e31fdba74ac63ad", "node_id": "C_kwDOAAsO6NoAKDkyYjhhZGY4ZTA2NTk0Y2I5YjM0Nzc1MjZlMzFmZGJhNzRhYzYzYWQ", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-07-11T09:49:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-11T09:49:30Z"}, "message": "Rollup merge of #98907 - compiler-errors:plz-no-float, r=oli-obk\n\nDeny float const params even when `adt_const_params` is enabled\n\nSupersedes #98825\nFixes #98813\n\nr? ``@oli-obk``", "tree": {"sha": "da1738011e10dadc441097abe1b08ad1b6f05e4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da1738011e10dadc441097abe1b08ad1b6f05e4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92b8adf8e06594cb9b3477526e31fdba74ac63ad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiy/IqCRBK7hj4Ov3rIwAA7z0IAC/wKeBsPWVsPad5gE7zGcxM\nxET/EMLqS9qACUrIttPHy61EkAnPuA8Q25JuLKmdYwwyZ9BV0c+RYzyDaXTPNEKq\n6jKc+dKm1esGoTw7u4RwDfFylb4+IrBoUeeW60Bd+k1ISz3PEsciaTpiQY2iMgVc\nu7jVlq5zzKxcGqV9qobKCNGEDu3dAv4PJbV2dGyF6A3OI+AWacatT2zOgPoLRDWp\nl17QwLjzRrdoUsX+QKO0sGqQQjALxBCGSIEKnB5VXxGMEjwSQUVYRIa/PJ5k8XMD\nxGrdP5oLUvYotaR/tT5Hx8FA4x0e/zv8uwsnMp5G/uFf+X+Yjg8HlLJSlAjKQTM=\n=aqSI\n-----END PGP SIGNATURE-----\n", "payload": "tree da1738011e10dadc441097abe1b08ad1b6f05e4d\nparent 943152008fbea871013bec69c85baae8356a485d\nparent a1634642e079d4517e31a75fa002ea0496148cda\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1657532970 +0530\ncommitter GitHub <noreply@github.com> 1657532970 +0530\n\nRollup merge of #98907 - compiler-errors:plz-no-float, r=oli-obk\n\nDeny float const params even when `adt_const_params` is enabled\n\nSupersedes #98825\nFixes #98813\n\nr? ``@oli-obk``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92b8adf8e06594cb9b3477526e31fdba74ac63ad", "html_url": "https://github.com/rust-lang/rust/commit/92b8adf8e06594cb9b3477526e31fdba74ac63ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92b8adf8e06594cb9b3477526e31fdba74ac63ad/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "943152008fbea871013bec69c85baae8356a485d", "url": "https://api.github.com/repos/rust-lang/rust/commits/943152008fbea871013bec69c85baae8356a485d", "html_url": "https://github.com/rust-lang/rust/commit/943152008fbea871013bec69c85baae8356a485d"}, {"sha": "a1634642e079d4517e31a75fa002ea0496148cda", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1634642e079d4517e31a75fa002ea0496148cda", "html_url": "https://github.com/rust-lang/rust/commit/a1634642e079d4517e31a75fa002ea0496148cda"}], "stats": {"total": 201, "additions": 135, "deletions": 66}, "files": [{"sha": "0aa7b117b89ba366177f125f5046a920a3750ba2", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92b8adf8e06594cb9b3477526e31fdba74ac63ad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b8adf8e06594cb9b3477526e31fdba74ac63ad/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=92b8adf8e06594cb9b3477526e31fdba74ac63ad", "patch": "@@ -226,7 +226,7 @@ impl Qualif for CustomEq {\n         // because that component may be part of an enum variant (e.g.,\n         // `Option::<NonStructuralMatchTy>::Some`), in which case some values of this type may be\n         // structural-match (`Option::None`).\n-        traits::search_for_structural_match_violation(cx.body.span, cx.tcx, ty).is_some()\n+        traits::search_for_structural_match_violation(cx.body.span, cx.tcx, ty, true).is_some()\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "e32e0b11ba49762bdfcdbd6de2faacd28cba63a2", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/92b8adf8e06594cb9b3477526e31fdba74ac63ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b8adf8e06594cb9b3477526e31fdba74ac63ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=92b8adf8e06594cb9b3477526e31fdba74ac63ad", "patch": "@@ -120,32 +120,37 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n-        traits::search_for_structural_match_violation(self.span, self.tcx(), ty).map(|non_sm_ty| {\n-            with_no_trimmed_paths!(match non_sm_ty.kind {\n-                traits::NonStructuralMatchTyKind::Adt(adt) => self.adt_derive_msg(adt),\n-                traits::NonStructuralMatchTyKind::Dynamic => {\n-                    \"trait objects cannot be used in patterns\".to_string()\n-                }\n-                traits::NonStructuralMatchTyKind::Opaque => {\n-                    \"opaque types cannot be used in patterns\".to_string()\n-                }\n-                traits::NonStructuralMatchTyKind::Closure => {\n-                    \"closures cannot be used in patterns\".to_string()\n-                }\n-                traits::NonStructuralMatchTyKind::Generator => {\n-                    \"generators cannot be used in patterns\".to_string()\n-                }\n-                traits::NonStructuralMatchTyKind::Param => {\n-                    bug!(\"use of a constant whose type is a parameter inside a pattern\")\n-                }\n-                traits::NonStructuralMatchTyKind::Projection => {\n-                    bug!(\"use of a constant whose type is a projection inside a pattern\")\n-                }\n-                traits::NonStructuralMatchTyKind::Foreign => {\n-                    bug!(\"use of a value of a foreign type inside a pattern\")\n-                }\n-            })\n-        })\n+        traits::search_for_structural_match_violation(self.span, self.tcx(), ty, true).map(\n+            |non_sm_ty| {\n+                with_no_trimmed_paths!(match non_sm_ty.kind {\n+                    traits::NonStructuralMatchTyKind::Adt(adt) => self.adt_derive_msg(adt),\n+                    traits::NonStructuralMatchTyKind::Dynamic => {\n+                        \"trait objects cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTyKind::Opaque => {\n+                        \"opaque types cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTyKind::Closure => {\n+                        \"closures cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTyKind::Generator => {\n+                        \"generators cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTyKind::Float => {\n+                        \"floating-point numbers cannot be used in patterns\".to_string()\n+                    }\n+                    traits::NonStructuralMatchTyKind::Param => {\n+                        bug!(\"use of a constant whose type is a parameter inside a pattern\")\n+                    }\n+                    traits::NonStructuralMatchTyKind::Projection => {\n+                        bug!(\"use of a constant whose type is a projection inside a pattern\")\n+                    }\n+                    traits::NonStructuralMatchTyKind::Foreign => {\n+                        bug!(\"use of a value of a foreign type inside a pattern\")\n+                    }\n+                })\n+            },\n+        )\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {"}, {"sha": "6c0b83fbd0304802969bf5d7133f38cab97a8ca4", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/92b8adf8e06594cb9b3477526e31fdba74ac63ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b8adf8e06594cb9b3477526e31fdba74ac63ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=92b8adf8e06594cb9b3477526e31fdba74ac63ad", "patch": "@@ -26,6 +26,7 @@ pub enum NonStructuralMatchTyKind<'tcx> {\n     Closure,\n     Generator,\n     Projection,\n+    Float,\n }\n \n /// This method traverses the structure of `ty`, trying to find an\n@@ -53,12 +54,16 @@ pub enum NonStructuralMatchTyKind<'tcx> {\n /// For more background on why Rust has this requirement, and issues\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n+///\n+/// The floats_allowed flag is used to deny constants in floating point\n pub fn search_for_structural_match_violation<'tcx>(\n     span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n+    floats_allowed: bool,\n ) -> Option<NonStructuralMatchTy<'tcx>> {\n-    ty.visit_with(&mut Search { tcx, span, seen: FxHashSet::default() }).break_value()\n+    ty.visit_with(&mut Search { tcx, span, seen: FxHashSet::default(), floats_allowed })\n+        .break_value()\n }\n \n /// This method returns true if and only if `adt_ty` itself has been marked as\n@@ -119,6 +124,8 @@ struct Search<'tcx> {\n     /// Tracks ADTs previously encountered during search, so that\n     /// we will not recur on them again.\n     seen: FxHashSet<hir::def_id::DefId>,\n+\n+    floats_allowed: bool,\n }\n \n impl<'tcx> Search<'tcx> {\n@@ -192,13 +199,24 @@ impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n                 // for empty array.\n                 return ControlFlow::CONTINUE;\n             }\n-            ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str | ty::Never => {\n+            ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Str | ty::Never => {\n                 // These primitive types are always structural match.\n                 //\n                 // `Never` is kind of special here, but as it is not inhabitable, this should be fine.\n                 return ControlFlow::CONTINUE;\n             }\n \n+            ty::Float(_) => {\n+                if self.floats_allowed {\n+                    return ControlFlow::CONTINUE;\n+                } else {\n+                    return ControlFlow::Break(NonStructuralMatchTy {\n+                        ty,\n+                        kind: NonStructuralMatchTyKind::Float,\n+                    });\n+                }\n+            }\n+\n             ty::Array(..) | ty::Slice(_) | ty::Ref(..) | ty::Tuple(..) => {\n                 // First check all contained types and then tell the caller to continue searching.\n                 return ty.super_visit_with(self);"}, {"sha": "5621cf2e1a4b5a9fbb3222447ff7fdcde2167d55", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 49, "deletions": 37, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/92b8adf8e06594cb9b3477526e31fdba74ac63ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b8adf8e06594cb9b3477526e31fdba74ac63ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=92b8adf8e06594cb9b3477526e31fdba74ac63ad", "patch": "@@ -824,50 +824,62 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                 }\n \n                 if let Some(non_structural_match_ty) =\n-                    traits::search_for_structural_match_violation(param.span, tcx, ty)\n+                    traits::search_for_structural_match_violation(param.span, tcx, ty, false)\n                 {\n                     // We use the same error code in both branches, because this is really the same\n                     // issue: we just special-case the message for type parameters to make it\n                     // clearer.\n-                    if let ty::Param(_) = ty.peel_refs().kind() {\n-                        // Const parameters may not have type parameters as their types,\n-                        // because we cannot be sure that the type parameter derives `PartialEq`\n-                        // and `Eq` (just implementing them is not enough for `structural_match`).\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            hir_ty.span,\n-                            E0741,\n-                            \"`{}` is not guaranteed to `#[derive(PartialEq, Eq)]`, so may not be \\\n-                            used as the type of a const parameter\",\n-                            ty,\n-                        )\n-                        .span_label(\n-                            hir_ty.span,\n-                            format!(\"`{}` may not derive both `PartialEq` and `Eq`\", ty),\n-                        )\n-                        .note(\n-                            \"it is not currently possible to use a type parameter as the type of a \\\n-                            const parameter\",\n-                        )\n-                        .emit();\n-                    } else {\n-                        let mut diag = struct_span_err!(\n-                            tcx.sess,\n-                            hir_ty.span,\n-                            E0741,\n-                            \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n-                            the type of a const parameter\",\n-                            non_structural_match_ty.ty,\n-                        );\n-\n-                        if ty == non_structural_match_ty.ty {\n-                            diag.span_label(\n+                    match ty.peel_refs().kind() {\n+                        ty::Param(_) => {\n+                            // Const parameters may not have type parameters as their types,\n+                            // because we cannot be sure that the type parameter derives `PartialEq`\n+                            // and `Eq` (just implementing them is not enough for `structural_match`).\n+                            struct_span_err!(\n+                                tcx.sess,\n                                 hir_ty.span,\n-                                format!(\"`{ty}` doesn't derive both `PartialEq` and `Eq`\"),\n-                            );\n+                                E0741,\n+                                \"`{ty}` is not guaranteed to `#[derive(PartialEq, Eq)]`, so may not be \\\n+                                used as the type of a const parameter\",\n+                            )\n+                            .span_label(\n+                                hir_ty.span,\n+                                format!(\"`{ty}` may not derive both `PartialEq` and `Eq`\"),\n+                            )\n+                            .note(\n+                                \"it is not currently possible to use a type parameter as the type of a \\\n+                                const parameter\",\n+                            )\n+                            .emit();\n+                        }\n+                        ty::Float(_) => {\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                hir_ty.span,\n+                                E0741,\n+                                \"`{ty}` is forbidden as the type of a const generic parameter\",\n+                            )\n+                            .note(\"floats do not derive `Eq` or `Ord`, which are required for const parameters\")\n+                            .emit();\n                         }\n+                        _ => {\n+                            let mut diag = struct_span_err!(\n+                                tcx.sess,\n+                                hir_ty.span,\n+                                E0741,\n+                                \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n+                                the type of a const parameter\",\n+                                non_structural_match_ty.ty,\n+                            );\n \n-                        diag.emit();\n+                            if ty == non_structural_match_ty.ty {\n+                                diag.span_label(\n+                                    hir_ty.span,\n+                                    format!(\"`{ty}` doesn't derive both `PartialEq` and `Eq`\"),\n+                                );\n+                            }\n+\n+                            diag.emit();\n+                        }\n                     }\n                 }\n             } else {"}, {"sha": "fef5ef0d1facfe91c83873728a2113aab2a28163", "filename": "src/test/ui/const-generics/float-generic.adt_const_params.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/92b8adf8e06594cb9b3477526e31fdba74ac63ad/src%2Ftest%2Fui%2Fconst-generics%2Ffloat-generic.adt_const_params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b8adf8e06594cb9b3477526e31fdba74ac63ad/src%2Ftest%2Fui%2Fconst-generics%2Ffloat-generic.adt_const_params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffloat-generic.adt_const_params.stderr?ref=92b8adf8e06594cb9b3477526e31fdba74ac63ad", "patch": "@@ -0,0 +1,11 @@\n+error[E0741]: `f32` is forbidden as the type of a const generic parameter\n+  --> $DIR/float-generic.rs:5:17\n+   |\n+LL | fn foo<const F: f32>() {}\n+   |                 ^^^\n+   |\n+   = note: floats do not derive `Eq` or `Ord`, which are required for const parameters\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0741`."}, {"sha": "b72059b5b1c6a31729819ce14edd95f30336445e", "filename": "src/test/ui/const-generics/float-generic.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92b8adf8e06594cb9b3477526e31fdba74ac63ad/src%2Ftest%2Fui%2Fconst-generics%2Ffloat-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b8adf8e06594cb9b3477526e31fdba74ac63ad/src%2Ftest%2Fui%2Fconst-generics%2Ffloat-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffloat-generic.rs?ref=92b8adf8e06594cb9b3477526e31fdba74ac63ad", "patch": "@@ -0,0 +1,12 @@\n+// revisions: simple adt_const_params\n+#![cfg_attr(adt_const_params, feature(adt_const_params))]\n+#![cfg_attr(adt_const_params, allow(incomplete_features))]\n+\n+fn foo<const F: f32>() {}\n+//~^ ERROR `f32` is forbidden as the type of a const generic parameter\n+\n+const C: f32 = 1.0;\n+\n+fn main() {\n+    foo::<C>();\n+}"}, {"sha": "89ca36b0f63147fa32f9d1e084ce290c04b9e6db", "filename": "src/test/ui/const-generics/float-generic.simple.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/92b8adf8e06594cb9b3477526e31fdba74ac63ad/src%2Ftest%2Fui%2Fconst-generics%2Ffloat-generic.simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92b8adf8e06594cb9b3477526e31fdba74ac63ad/src%2Ftest%2Fui%2Fconst-generics%2Ffloat-generic.simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffloat-generic.simple.stderr?ref=92b8adf8e06594cb9b3477526e31fdba74ac63ad", "patch": "@@ -0,0 +1,11 @@\n+error: `f32` is forbidden as the type of a const generic parameter\n+  --> $DIR/float-generic.rs:5:17\n+   |\n+LL | fn foo<const F: f32>() {}\n+   |                 ^^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = help: more complex types are supported with `#![feature(adt_const_params)]`\n+\n+error: aborting due to previous error\n+"}]}