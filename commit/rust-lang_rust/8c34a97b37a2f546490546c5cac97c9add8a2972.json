{"sha": "8c34a97b37a2f546490546c5cac97c9add8a2972", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMzRhOTdiMzdhMmY1NDY0OTA1NDZjNWNhYzk3YzlhZGQ4YTI5NzI=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-27T15:44:07Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-07-27T15:44:07Z"}, "message": "doc: TreeMap methods with examples.\n\nSmall corrections for TreeSet examples.", "tree": {"sha": "eb6b07ccc831d10ab7d09b8d4723e596f3d13274", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb6b07ccc831d10ab7d09b8d4723e596f3d13274"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c34a97b37a2f546490546c5cac97c9add8a2972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c34a97b37a2f546490546c5cac97c9add8a2972", "html_url": "https://github.com/rust-lang/rust/commit/8c34a97b37a2f546490546c5cac97c9add8a2972", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c34a97b37a2f546490546c5cac97c9add8a2972/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "034ef079ef401d66cab806e967a8390bfb05cb6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/034ef079ef401d66cab806e967a8390bfb05cb6a", "html_url": "https://github.com/rust-lang/rust/commit/034ef079ef401d66cab806e967a8390bfb05cb6a"}], "stats": {"total": 265, "additions": 248, "deletions": 17}, "files": [{"sha": "ec13c0a2888945daae6c6c3366c05ee4cc097574", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 248, "deletions": 17, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/8c34a97b37a2f546490546c5cac97c9add8a2972/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c34a97b37a2f546490546c5cac97c9add8a2972/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=8c34a97b37a2f546490546c5cac97c9add8a2972", "patch": "@@ -43,10 +43,10 @@ use std::hash::{Writer, Hash};\n use {Collection, Mutable, Set, MutableSet, MutableMap, Map, MutableSeq};\n use vec::Vec;\n \n-// This is implemented as an AA tree, which is a simplified variation of\n-// a red-black tree where red (horizontal) nodes can only be added\n-// as a right child. The time complexity is the same, and re-balancing\n-// operations are more frequent but also cheaper.\n+/// This is implemented as an AA tree, which is a simplified variation of\n+/// a red-black tree where red (horizontal) nodes can only be added\n+/// as a right child. The time complexity is the same, and re-balancing\n+/// operations are more frequent but also cheaper.\n \n // Future improvements:\n \n@@ -59,7 +59,6 @@ use vec::Vec;\n //   * union: |\n // These would be convenient since the methods work like `each`\n \n-#[allow(missing_doc)]\n #[deriving(Clone)]\n pub struct TreeMap<K, V> {\n     root: Option<Box<TreeNode<K, V>>>,\n@@ -139,20 +138,73 @@ impl<K: Ord, V> Default for TreeMap<K,V> {\n \n impl<K: Ord, V> TreeMap<K, V> {\n     /// Create an empty `TreeMap`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map: TreeMap<&str, int> = TreeMap::new();\n+    /// ```\n     pub fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-    /// Get a lazy iterator over the keys in the map.\n+    /// Get a lazy iterator over the keys in the map, in ascending order.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Print \"a\", \"b\", \"c\" in order.\n+    /// for x in map.keys() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n         self.iter().map(|(k, _v)| k)\n     }\n \n-    /// Get a lazy iterator over the values in the map.\n+    /// Get a lazy iterator over the values in the map, in ascending order\n+    /// with respect to the corresponding keys.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Print 1, 2, 3 ordered by keys.\n+    /// for x in map.values() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n         self.iter().map(|(_k, v)| v)\n     }\n \n-    /// Get a lazy iterator over the key-value pairs in the map.\n+    /// Get a lazy iterator over the key-value pairs in the map, in ascending order.\n     /// Requires that it be frozen (immutable).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Print contents in ascending order\n+    /// for (key, value) in map.iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     pub fn iter<'a>(&'a self) -> Entries<'a, K, V> {\n         Entries {\n             stack: vec!(),\n@@ -162,14 +214,49 @@ impl<K: Ord, V> TreeMap<K, V> {\n         }\n     }\n \n-    /// Get a lazy reverse iterator over the key-value pairs in the map.\n+    /// Get a lazy reverse iterator over the key-value pairs in the map, in descending order.\n     /// Requires that it be frozen (immutable).\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Print contents in descending order\n+    /// for (key, value) in map.rev_iter() {\n+    ///     println!(\"{}: {}\", key, value);\n+    /// }\n+    /// ```\n     pub fn rev_iter<'a>(&'a self) -> RevEntries<'a, K, V> {\n         RevEntries{iter: self.iter()}\n     }\n \n     /// Get a lazy forward iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Add 10 until we find \"b\"\n+    /// for (key, value) in map.mut_iter() {\n+    ///     *value += 10;\n+    ///     if key == &\"b\" { break }\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&\"a\"), Some(&11));\n+    /// assert_eq!(map.find(&\"b\"), Some(&12));\n+    /// assert_eq!(map.find(&\"c\"), Some(&3));\n+    /// ```\n     pub fn mut_iter<'a>(&'a mut self) -> MutEntries<'a, K, V> {\n         MutEntries {\n             stack: vec!(),\n@@ -180,12 +267,47 @@ impl<K: Ord, V> TreeMap<K, V> {\n     }\n     /// Get a lazy reverse iterator over the key-value pairs in the\n     /// map, with the values being mutable.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Add 10 until we find \"b\"\n+    /// for (key, value) in map.mut_rev_iter() {\n+    ///     *value += 10;\n+    ///     if key == &\"b\" { break }\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&\"a\"), Some(&1));\n+    /// assert_eq!(map.find(&\"b\"), Some(&12));\n+    /// assert_eq!(map.find(&\"c\"), Some(&13));\n+    /// ```\n     pub fn mut_rev_iter<'a>(&'a mut self) -> RevMutEntries<'a, K, V> {\n         RevMutEntries{iter: self.mut_iter()}\n     }\n \n \n-    /// Get a lazy iterator that consumes the treemap.\n+    /// Get a lazy iterator that consumes the treemap, it is not usable\n+    /// after calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(\"a\", 1i);\n+    /// map.insert(\"c\", 3i);\n+    /// map.insert(\"b\", 2i);\n+    ///\n+    /// // Not possible with a regular `.iter()`\n+    /// let vec: Vec<(&str, int)> = map.move_iter().collect();\n+    /// assert_eq!(vec, vec![(\"a\", 1), (\"b\", 2), (\"c\", 3)]);\n+    /// ```\n     pub fn move_iter(self) -> MoveEntries<K, V> {\n         let TreeMap { root: root, length: length } = self;\n         let stk = match root {\n@@ -302,12 +424,44 @@ impl<K: Ord, V> TreeMap<K, V> {\n \n     /// Return a lazy iterator to the first key-value pair whose key is not less than `k`\n     /// If all keys in map are less than `k` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(2i, \"a\");\n+    /// map.insert(4, \"b\");\n+    /// map.insert(6, \"c\");\n+    /// map.insert(8, \"d\");\n+    ///\n+    /// assert_eq!(map.lower_bound(&4).next(), Some((&4, &\"b\")));\n+    /// assert_eq!(map.lower_bound(&5).next(), Some((&6, &\"c\")));\n+    /// assert_eq!(map.lower_bound(&10).next(), None);\n+    /// ```\n     pub fn lower_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n         bound_setup!(self.iter_for_traversal(), k, true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair whose key is greater than `k`\n-    /// If all keys in map are not greater than `k` an empty iterator is returned.\n+    /// If all keys in map are less than or equal to `k` an empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(2i, \"a\");\n+    /// map.insert(4, \"b\");\n+    /// map.insert(6, \"c\");\n+    /// map.insert(8, \"d\");\n+    ///\n+    /// assert_eq!(map.upper_bound(&4).next(), Some((&6, &\"c\")));\n+    /// assert_eq!(map.upper_bound(&5).next(), Some((&6, &\"c\")));\n+    /// assert_eq!(map.upper_bound(&10).next(), None);\n+    /// ```\n     pub fn upper_bound<'a>(&'a self, k: &K) -> Entries<'a, K, V> {\n         bound_setup!(self.iter_for_traversal(), k, false)\n     }\n@@ -328,15 +482,65 @@ impl<K: Ord, V> TreeMap<K, V> {\n     ///\n     /// If all keys in map are less than `k` an empty iterator is\n     /// returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(2i, \"a\");\n+    /// map.insert(4, \"b\");\n+    /// map.insert(6, \"c\");\n+    /// map.insert(8, \"d\");\n+    ///\n+    /// assert_eq!(map.mut_lower_bound(&4).next(), Some((&4, &mut \"b\")));\n+    /// assert_eq!(map.mut_lower_bound(&5).next(), Some((&6, &mut \"c\")));\n+    /// assert_eq!(map.mut_lower_bound(&10).next(), None);\n+    ///\n+    /// for (key, value) in map.mut_lower_bound(&4) {\n+    ///     *value = \"changed\";\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&2), Some(&\"a\"));\n+    /// assert_eq!(map.find(&4), Some(&\"changed\"));\n+    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.find(&8), Some(&\"changed\"));\n+    /// ```\n     pub fn mut_lower_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.mut_iter_for_traversal(), k, true)\n     }\n \n     /// Return a lazy iterator to the first key-value pair (with the\n     /// value being mutable) whose key is greater than `k`.\n     ///\n-    /// If all keys in map are not greater than `k` an empty iterator\n+    /// If all keys in map are less than or equal to `k` an empty iterator\n     /// is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeMap;\n+    ///\n+    /// let mut map = TreeMap::new();\n+    /// map.insert(2i, \"a\");\n+    /// map.insert(4, \"b\");\n+    /// map.insert(6, \"c\");\n+    /// map.insert(8, \"d\");\n+    ///\n+    /// assert_eq!(map.mut_upper_bound(&4).next(), Some((&6, &mut \"c\")));\n+    /// assert_eq!(map.mut_upper_bound(&5).next(), Some((&6, &mut \"c\")));\n+    /// assert_eq!(map.mut_upper_bound(&10).next(), None);\n+    ///\n+    /// for (key, value) in map.mut_upper_bound(&4) {\n+    ///     *value = \"changed\";\n+    /// }\n+    ///\n+    /// assert_eq!(map.find(&2), Some(&\"a\"));\n+    /// assert_eq!(map.find(&4), Some(&\"b\"));\n+    /// assert_eq!(map.find(&6), Some(&\"changed\"));\n+    /// assert_eq!(map.find(&8), Some(&\"changed\"));\n+    /// ```\n     pub fn mut_upper_bound<'a>(&'a mut self, k: &K) -> MutEntries<'a, K, V> {\n         bound_setup!(self.mut_iter_for_traversal(), k, false)\n     }\n@@ -853,13 +1057,36 @@ impl<T: Ord> TreeSet<T> {\n \n     /// Get a lazy iterator pointing to the first value not less than `v` (greater or equal).\n     /// If all elements in the set are less than `v` empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(set.lower_bound(&4).next(), Some(&4));\n+    /// assert_eq!(set.lower_bound(&5).next(), Some(&6));\n+    /// assert_eq!(set.lower_bound(&10).next(), None);\n+    /// ```\n     #[inline]\n     pub fn lower_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n         SetItems{iter: self.map.lower_bound(v)}\n     }\n \n     /// Get a lazy iterator pointing to the first value greater than `v`.\n-    /// If all elements in the set are not greater than `v` empty iterator is returned.\n+    /// If all elements in the set are less than or equal to `v` an\n+    /// empty iterator is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::TreeSet;\n+    /// let set: TreeSet<int> = [2, 4, 6, 8].iter().map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(set.upper_bound(&4).next(), Some(&6));\n+    /// assert_eq!(set.upper_bound(&5).next(), Some(&6));\n+    /// assert_eq!(set.upper_bound(&10).next(), None);\n+    /// ```\n     #[inline]\n     pub fn upper_bound<'a>(&'a self, v: &T) -> SetItems<'a, T> {\n         SetItems{iter: self.map.upper_bound(v)}\n@@ -871,6 +1098,7 @@ impl<T: Ord> TreeSet<T> {\n     ///\n     /// ```\n     /// use std::collections::TreeSet;\n+    ///\n     /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n     /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n     ///\n@@ -897,6 +1125,7 @@ impl<T: Ord> TreeSet<T> {\n     ///\n     /// ```\n     /// use std::collections::TreeSet;\n+    ///\n     /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n     /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n     ///\n@@ -922,6 +1151,7 @@ impl<T: Ord> TreeSet<T> {\n     ///\n     /// ```\n     /// use std::collections::TreeSet;\n+    ///\n     /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n     /// let b: TreeSet<int> = [2, 3, 4].iter().map(|&x| x).collect();\n     ///\n@@ -943,16 +1173,17 @@ impl<T: Ord> TreeSet<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// use std::collections::HashSet;\n-    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n-    /// let b: HashSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n+    /// use std::collections::TreeSet;\n+    ///\n+    /// let a: TreeSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: TreeSet<int> = [3, 4, 5].iter().map(|&x| x).collect();\n     ///\n     /// // Print 1, 2, 3, 4, 5 in ascending order.\n     /// for x in a.union(&b) {\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n+    /// let diff: TreeSet<int> = a.union(&b).map(|&x| x).collect();\n     /// assert_eq!(diff, [1, 2, 3, 4, 5].iter().map(|&x| x).collect());\n     /// ```\n     pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> UnionItems<'a, T> {"}]}