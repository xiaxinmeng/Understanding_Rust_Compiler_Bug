{"sha": "d92e594c3801a8066f95305c87e53a7ecfb24e9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MmU1OTRjMzgwMWE4MDY2Zjk1MzA1Yzg3ZTUzYTdlY2ZiMjRlOWI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-06T00:12:20Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-12T03:43:34Z"}, "message": "typeck: record `impl Trait` concrete resolutions.", "tree": {"sha": "2ef09df519a7964ffe9dbab595f46f63979dc8e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ef09df519a7964ffe9dbab595f46f63979dc8e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d92e594c3801a8066f95305c87e53a7ecfb24e9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d92e594c3801a8066f95305c87e53a7ecfb24e9b", "html_url": "https://github.com/rust-lang/rust/commit/d92e594c3801a8066f95305c87e53a7ecfb24e9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d92e594c3801a8066f95305c87e53a7ecfb24e9b/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef7ddfda3960589d6f5f79ea18d051acdeabd78", "html_url": "https://github.com/rust-lang/rust/commit/1ef7ddfda3960589d6f5f79ea18d051acdeabd78"}], "stats": {"total": 1320, "additions": 1224, "deletions": 96}, "files": [{"sha": "b70190181af8fcf80123a70d575af4cc1bda43e9", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -194,6 +194,14 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         });\n     }\n \n+    fn visit_ty(&mut self, ty: &'ast Ty) {\n+        self.insert(ty.id, NodeTy(ty));\n+\n+        self.with_parent(ty.id, |this| {\n+            intravisit::walk_ty(this, ty);\n+        });\n+    }\n+\n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n                 b: &'ast Block, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);"}, {"sha": "7e82a4a05a76461216731761e4ed6b1c9b33284e", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -50,6 +50,7 @@ pub enum Node<'ast> {\n     NodeVariant(&'ast Variant),\n     NodeExpr(&'ast Expr),\n     NodeStmt(&'ast Stmt),\n+    NodeTy(&'ast Ty),\n     NodeLocal(&'ast Pat),\n     NodePat(&'ast Pat),\n     NodeBlock(&'ast Block),\n@@ -76,6 +77,7 @@ pub enum MapEntry<'ast> {\n     EntryVariant(NodeId, &'ast Variant),\n     EntryExpr(NodeId, &'ast Expr),\n     EntryStmt(NodeId, &'ast Stmt),\n+    EntryTy(NodeId, &'ast Ty),\n     EntryLocal(NodeId, &'ast Pat),\n     EntryPat(NodeId, &'ast Pat),\n     EntryBlock(NodeId, &'ast Block),\n@@ -104,6 +106,7 @@ impl<'ast> MapEntry<'ast> {\n             NodeVariant(n) => EntryVariant(p, n),\n             NodeExpr(n) => EntryExpr(p, n),\n             NodeStmt(n) => EntryStmt(p, n),\n+            NodeTy(n) => EntryTy(p, n),\n             NodeLocal(n) => EntryLocal(p, n),\n             NodePat(n) => EntryPat(p, n),\n             NodeBlock(n) => EntryBlock(p, n),\n@@ -122,6 +125,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryVariant(id, _) => id,\n             EntryExpr(id, _) => id,\n             EntryStmt(id, _) => id,\n+            EntryTy(id, _) => id,\n             EntryLocal(id, _) => id,\n             EntryPat(id, _) => id,\n             EntryBlock(id, _) => id,\n@@ -144,6 +148,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryVariant(_, n) => NodeVariant(n),\n             EntryExpr(_, n) => NodeExpr(n),\n             EntryStmt(_, n) => NodeStmt(n),\n+            EntryTy(_, n) => NodeTy(n),\n             EntryLocal(_, n) => NodeLocal(n),\n             EntryPat(_, n) => NodePat(n),\n             EntryBlock(_, n) => NodeBlock(n),\n@@ -257,6 +262,7 @@ impl<'ast> Map<'ast> {\n                     EntryVariant(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n+                EntryTy(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |\n@@ -297,6 +303,7 @@ impl<'ast> Map<'ast> {\n                     EntryVariant(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n+                    EntryTy(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |\n@@ -680,6 +687,7 @@ impl<'ast> Map<'ast> {\n             Some(NodeVariant(variant)) => variant.span,\n             Some(NodeExpr(expr)) => expr.span,\n             Some(NodeStmt(stmt)) => stmt.span,\n+            Some(NodeTy(ty)) => ty.span,\n             Some(NodeLocal(pat)) => pat.span,\n             Some(NodePat(pat)) => pat.span,\n             Some(NodeBlock(block)) => block.span,\n@@ -971,6 +979,7 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             NodeVariant(a)     => self.print_variant(&a),\n             NodeExpr(a)        => self.print_expr(&a),\n             NodeStmt(a)        => self.print_stmt(&a),\n+            NodeTy(a)          => self.print_type(&a),\n             NodePat(a)         => self.print_pat(&a),\n             NodeBlock(a)       => self.print_block(&a),\n             NodeLifetime(a)    => self.print_lifetime(&a),\n@@ -1059,6 +1068,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeStmt(ref stmt)) => {\n             format!(\"stmt {}{}\", pprust::stmt_to_string(&stmt), id_str)\n         }\n+        Some(NodeTy(ref ty)) => {\n+            format!(\"type {}{}\", pprust::ty_to_string(&ty), id_str)\n+        }\n         Some(NodeLocal(ref pat)) => {\n             format!(\"local {}{}\", pprust::pat_to_string(&pat), id_str)\n         }"}, {"sha": "cc1d07b33c7e830b6840e2d4b79045210db44f99", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -1390,6 +1390,20 @@ impl<'a, 'b, 'c, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n         intravisit::walk_foreign_item(self, ni);\n         encode_info_for_foreign_item(self.ecx, self.rbml_w_for_visit_item, ni, self.index);\n     }\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        intravisit::walk_ty(self, ty);\n+\n+        if let hir::TyImplTrait(_) = ty.node {\n+            let rbml_w = &mut *self.rbml_w_for_visit_item;\n+            let def_id = self.ecx.tcx.map.local_def_id(ty.id);\n+            let _task = self.index.record(def_id, rbml_w);\n+            rbml_w.start_tag(tag_items_data_item);\n+            encode_def_id_and_key(self.ecx, rbml_w, def_id);\n+            encode_family(rbml_w, 'y');\n+            encode_bounds_and_type_for_item(rbml_w, self.ecx, self.index, ty.id);\n+            rbml_w.end_tag();\n+        }\n+    }\n }\n \n fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,"}, {"sha": "ad61b5b0b513eb355d664e7e4695e1c40de36cf2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -1763,25 +1763,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 // Create the anonymized type.\n                 let def_id = tcx.map.local_def_id(ast_ty.id);\n-                let substs = if let Some(anon_scope) = rscope.anon_type_scope() {\n-                    anon_scope.fresh_substs(tcx)\n+                if let Some(anon_scope) = rscope.anon_type_scope() {\n+                    let substs = anon_scope.fresh_substs(tcx);\n+                    let ty = tcx.mk_anon(tcx.map.local_def_id(ast_ty.id), substs);\n+\n+                    // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n+                    let bounds = compute_bounds(self, ty, bounds,\n+                                                SizedByDefault::Yes,\n+                                                Some(anon_scope),\n+                                                ast_ty.span);\n+                    let predicates = bounds.predicates(tcx, ty);\n+                    let predicates = tcx.lift_to_global(&predicates).unwrap();\n+                    tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n+                        predicates: VecPerParamSpace::new(vec![], vec![], predicates)\n+                    });\n+\n+                    ty\n                 } else {\n                     span_err!(tcx.sess, ast_ty.span, E0562,\n                               \"`impl Trait` not allowed outside of function \\\n                                and inherent method return types\");\n-                    tcx.mk_substs(Substs::empty())\n-                };\n-                let ty = tcx.mk_anon(tcx.map.local_def_id(ast_ty.id), substs);\n-\n-                // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n-                let bounds = compute_bounds(self, ty, bounds, SizedByDefault::Yes, ast_ty.span);\n-                let predicates = tcx.lift_to_global(&bounds.predicates(tcx, ty)).unwrap();\n-                let predicates = ty::GenericPredicates {\n-                    predicates: VecPerParamSpace::new(vec![], vec![], predicates)\n-                };\n-                tcx.predicates.borrow_mut().insert(def_id, predicates);\n-\n-                ty\n+                    tcx.types.err\n+                }\n             }\n             hir::TyPath(ref maybe_qself, ref path) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);"}, {"sha": "1734dec7e7251d80667436053499bc8930322c4e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 22, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -96,7 +96,7 @@ use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n-use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n@@ -172,6 +172,12 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'gcx, 'tcx>>>>,\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n+\n+    // Anonymized types found in explicit return types and their\n+    // associated fresh inference variable. Writeback resolves these\n+    // variables to get the concrete type, which can be used to\n+    // deanonymize TyAnon, after typeck is done with all functions.\n+    anon_types: RefCell<DefIdMap<Ty<'tcx>>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n@@ -408,6 +414,7 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n                 locals: RefCell::new(NodeMap()),\n                 deferred_call_resolutions: RefCell::new(DefIdMap()),\n                 deferred_cast_checks: RefCell::new(Vec::new()),\n+                anon_types: RefCell::new(DefIdMap()),\n             })\n         })\n     }\n@@ -631,32 +638,29 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             body: &'gcx hir::Block)\n                             -> FnCtxt<'a, 'gcx, 'tcx>\n {\n-    let arg_tys = &fn_sig.inputs;\n-    let ret_ty = fn_sig.output;\n+    let mut fn_sig = fn_sig.clone();\n \n-    debug!(\"check_fn(arg_tys={:?}, ret_ty={:?}, fn_id={})\",\n-           arg_tys,\n-           ret_ty,\n-           fn_id);\n+    debug!(\"check_fn(sig={:?}, fn_id={})\", fn_sig, fn_id);\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let fcx = FnCtxt::new(inherited, ret_ty, body.id);\n+    let mut fcx = FnCtxt::new(inherited, fn_sig.output, body.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(unsafety, unsafety_id);\n \n-    if let ty::FnConverging(ret_ty) = ret_ty {\n-        fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n-    }\n-\n-    debug!(\"fn-sig-map: fn_id={} fn_sig={:?}\", fn_id, fn_sig);\n-\n-    inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig.clone());\n+    fn_sig.output = match fcx.ret_ty {\n+        ty::FnConverging(orig_ret_ty) => {\n+            fcx.require_type_is_sized(orig_ret_ty, decl.output.span(), traits::ReturnType);\n+            ty::FnConverging(fcx.instantiate_anon_types(&orig_ret_ty))\n+        }\n+        ty::FnDiverging => ty::FnDiverging\n+    };\n+    fcx.ret_ty = fn_sig.output;\n \n     {\n         let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n \n         // Add formal parameters.\n-        for (arg_ty, input) in arg_tys.iter().zip(&decl.inputs) {\n+        for (arg_ty, input) in fn_sig.inputs.iter().zip(&decl.inputs) {\n             // The type of the argument must be well-formed.\n             //\n             // NB -- this is now checked in wfcheck, but that\n@@ -672,21 +676,20 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             });\n \n             // Check the pattern.\n-            fcx.check_pat(&input.pat, *arg_ty);\n+            fcx.check_pat(&input.pat, arg_ty);\n+            fcx.write_ty(input.id, arg_ty);\n         }\n \n         visit.visit_block(body);\n     }\n \n-    fcx.check_block_with_expected(body, match ret_ty {\n+    inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n+\n+    fcx.check_block_with_expected(body, match fcx.ret_ty {\n         ty::FnConverging(result_type) => ExpectHasType(result_type),\n         ty::FnDiverging => NoExpectation\n     });\n \n-    for (input, arg) in decl.inputs.iter().zip(arg_tys) {\n-        fcx.write_ty(input.id, arg);\n-    }\n-\n     fcx\n }\n \n@@ -1623,6 +1626,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Replace all anonymized types with fresh inference variables\n+    /// and record them for writeback.\n+    fn instantiate_anon_types<T: TypeFoldable<'tcx>>(&self, value: &T) -> T {\n+        value.fold_with(&mut BottomUpFolder { tcx: self.tcx, fldop: |ty| {\n+            if let ty::TyAnon(def_id, substs) = ty.sty {\n+                // Use the same type variable if the exact same TyAnon appears more\n+                // than once in the return type (e.g. if it's pased to a type alias).\n+                if let Some(ty_var) = self.anon_types.borrow().get(&def_id) {\n+                    return ty_var;\n+                }\n+                let ty_var = self.next_ty_var();\n+                self.anon_types.borrow_mut().insert(def_id, ty_var);\n+\n+                let item_predicates = self.tcx.lookup_predicates(def_id);\n+                let bounds = item_predicates.instantiate(self.tcx, substs);\n+\n+                let span = self.tcx.map.def_id_span(def_id, codemap::DUMMY_SP);\n+                for predicate in bounds.predicates {\n+                    // Change the predicate to refer to the type variable,\n+                    // which will be the concrete type, instead of the TyAnon.\n+                    // This also instantiates nested `impl Trait`.\n+                    let predicate = self.instantiate_anon_types(&predicate);\n+\n+                    // Require that the predicate holds for the concrete type.\n+                    let cause = traits::ObligationCause::new(span, self.body_id,\n+                                                             traits::ReturnType);\n+                    self.register_predicate(traits::Obligation::new(cause, predicate));\n+                }\n+\n+                ty_var\n+            } else {\n+                ty\n+            }\n+        }})\n+    }\n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n         where T : TypeFoldable<'tcx>"}, {"sha": "7458e3b9bc7a7d36339748d8872209ee725a26ea", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 104, "deletions": 8, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -18,7 +18,9 @@ use hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n+use rustc::ty::subst::ParamSpace;\n use rustc::infer::{InferCtxt, FixupError};\n+use rustc::util::nodemap::DefIdMap;\n use write_substs_to_tcx;\n use write_ty_to_tcx;\n \n@@ -62,6 +64,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n+        wbcx.visit_anon_types();\n     }\n }\n \n@@ -75,11 +78,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n+\n+    // Mapping from free regions of the function to the\n+    // early-bound versions of them, visible from the\n+    // outside of the function. This is needed by, and\n+    // only populated if there are any `impl Trait`.\n+    free_to_bound_regions: DefIdMap<ty::Region>\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>) -> WritebackCx<'cx, 'gcx, 'tcx> {\n-        WritebackCx { fcx: fcx }\n+        let mut wbcx = WritebackCx {\n+            fcx: fcx,\n+            free_to_bound_regions: DefIdMap()\n+        };\n+\n+        // Only build the reverse mapping if `impl Trait` is used.\n+        if fcx.anon_types.borrow().is_empty() {\n+            return wbcx;\n+        }\n+\n+        let free_substs = fcx.parameter_environment.free_substs;\n+        for &space in &ParamSpace::all() {\n+            for (i, r) in free_substs.regions.get_slice(space).iter().enumerate() {\n+                match *r {\n+                    ty::ReFree(ty::FreeRegion {\n+                        bound_region: ty::BoundRegion::BrNamed(def_id, name, _), ..\n+                    }) => {\n+                        let bound_region = ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                            space: space,\n+                            index: i as u32,\n+                            name: name,\n+                        });\n+                        wbcx.free_to_bound_regions.insert(def_id, bound_region);\n+                    }\n+                    _ => {\n+                        bug!(\"{:?} is not a free region for an early-bound lifetime\", r);\n+                    }\n+                }\n+            }\n+        }\n+\n+        wbcx\n     }\n \n     fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n@@ -255,6 +295,58 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_anon_types(&self) {\n+        if self.fcx.writeback_errors.get() {\n+            return\n+        }\n+\n+        let gcx = self.tcx().global_tcx();\n+        for (&def_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n+            let reason = ResolvingAnonTy(def_id);\n+            let inside_ty = self.resolve(&concrete_ty, reason);\n+\n+            // Convert the type from the function into a type valid outside\n+            // the function, by replacing free regions with early-bound ones.\n+            let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n+                match r {\n+                    // 'static is valid everywhere.\n+                    ty::ReStatic => ty::ReStatic,\n+\n+                    // Free regions that come from early-bound regions are valid.\n+                    ty::ReFree(ty::FreeRegion {\n+                        bound_region: ty::BoundRegion::BrNamed(def_id, _, _), ..\n+                    }) if self.free_to_bound_regions.contains_key(&def_id) => {\n+                        self.free_to_bound_regions[&def_id]\n+                    }\n+\n+                    ty::ReFree(_) |\n+                    ty::ReEarlyBound(_) |\n+                    ty::ReLateBound(..) |\n+                    ty::ReScope(_) |\n+                    ty::ReSkolemized(..) => {\n+                        let span = reason.span(self.tcx());\n+                        span_err!(self.tcx().sess, span, E0564,\n+                                  \"only named lifetimes are allowed in `impl Trait`, \\\n+                                   but `{}` was found in the type `{}`\", r, inside_ty);\n+                        ty::ReStatic\n+                    }\n+\n+                    ty::ReVar(_) |\n+                    ty::ReEmpty |\n+                    ty::ReErased => {\n+                        let span = reason.span(self.tcx());\n+                        span_bug!(span, \"invalid region in impl Trait: {:?}\", r);\n+                    }\n+                }\n+            });\n+\n+            gcx.tcache.borrow_mut().insert(def_id, ty::TypeScheme {\n+                ty: outside_ty,\n+                generics: ty::Generics::empty()\n+            });\n+        }\n+    }\n+\n     fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n         // Resolve any borrowings for the node with id `id`\n         self.visit_adjustments(reason, id);\n@@ -377,7 +469,8 @@ enum ResolveReason {\n     ResolvingUpvar(ty::UpvarId),\n     ResolvingClosure(DefId),\n     ResolvingFnSig(ast::NodeId),\n-    ResolvingFieldTypes(ast::NodeId)\n+    ResolvingFieldTypes(ast::NodeId),\n+    ResolvingAnonTy(DefId),\n }\n \n impl<'a, 'gcx, 'tcx> ResolveReason {\n@@ -395,12 +488,9 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             ResolvingFieldTypes(id) => {\n                 tcx.map.span(id)\n             }\n-            ResolvingClosure(did) => {\n-                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n-                    tcx.expr_span(node_id)\n-                } else {\n-                    DUMMY_SP\n-                }\n+            ResolvingClosure(did) |\n+            ResolvingAnonTy(did) => {\n+                tcx.map.def_id_span(did, DUMMY_SP)\n             }\n         }\n     }\n@@ -483,6 +573,12 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n                         span,\n                         &format!(\"cannot resolve some aspect of data for {:?}\", id));\n                 }\n+\n+                ResolvingAnonTy(_) => {\n+                    let span = self.reason.span(self.tcx);\n+                    span_err!(self.tcx.sess, span, E0563,\n+                              \"cannot determine a type for this `impl Trait`: {}\", e)\n+                }\n             }\n         }\n     }"}, {"sha": "75bfad053a32855c9d6f079b67bcf3465429c019", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 36, "deletions": 51, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -1194,10 +1194,11 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n         let self_param_ty = tcx.mk_self_type();\n         let superbounds1 = compute_bounds(&ccx.icx(scope),\n-                                    self_param_ty,\n-                                    bounds,\n-                                    SizedByDefault::No,\n-                                    item.span);\n+                                          self_param_ty,\n+                                          bounds,\n+                                          SizedByDefault::No,\n+                                          None,\n+                                          item.span);\n \n         let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n@@ -1407,6 +1408,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                         assoc_ty,\n                                         bounds,\n                                         SizedByDefault::Yes,\n+                                        None,\n                                         trait_item.span);\n \n             bounds.predicates(ccx.tcx, assoc_ty).into_iter()\n@@ -1780,6 +1782,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     param_ty,\n                                     &param.bounds,\n                                     SizedByDefault::Yes,\n+                                    None,\n                                     param.span);\n         let predicates = bounds.predicates(ccx.tcx, param_ty);\n         result.predicates.extend(space, predicates.into_iter());\n@@ -2052,25 +2055,43 @@ pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                         param_ty: ty::Ty<'tcx>,\n                                         ast_bounds: &[hir::TyParamBound],\n                                         sized_by_default: SizedByDefault,\n+                                        anon_scope: Option<AnonTypeScope>,\n                                         span: Span)\n                                         -> Bounds<'tcx>\n {\n-    let mut bounds =\n-        conv_param_bounds(astconv,\n-                          span,\n-                          param_ty,\n-                          ast_bounds);\n+    let tcx = astconv.tcx();\n+    let PartitionedBounds {\n+        mut builtin_bounds,\n+        trait_bounds,\n+        region_bounds\n+    } = partition_bounds(tcx, span, &ast_bounds);\n \n     if let SizedByDefault::Yes = sized_by_default {\n-        add_unsized_bound(astconv,\n-                          &mut bounds.builtin_bounds,\n-                          ast_bounds,\n-                          span);\n+        add_unsized_bound(astconv, &mut builtin_bounds, ast_bounds, span);\n     }\n \n-    bounds.trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n+    let mut projection_bounds = vec![];\n+\n+    let rscope = MaybeWithAnonTypes::new(ExplicitRscope, anon_scope);\n+    let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n+        astconv.instantiate_poly_trait_ref(&rscope,\n+                                           bound,\n+                                           Some(param_ty),\n+                                           &mut projection_bounds)\n+    }).collect();\n+\n+    let region_bounds = region_bounds.into_iter().map(|r| {\n+        ast_region_to_region(tcx, r)\n+    }).collect();\n+\n+    trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n \n-    bounds\n+    Bounds {\n+        region_bounds: region_bounds,\n+        builtin_bounds: builtin_bounds,\n+        trait_bounds: trait_bounds,\n+        projection_bounds: projection_bounds,\n+    }\n }\n \n /// Converts a specific TyParamBound from the AST into a set of\n@@ -2116,42 +2137,6 @@ fn conv_poly_trait_ref<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n                                         projections)\n }\n \n-fn conv_param_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n-                                       span: Span,\n-                                       param_ty: ty::Ty<'tcx>,\n-                                       ast_bounds: &[hir::TyParamBound])\n-                                       -> Bounds<'tcx>\n-{\n-    let tcx = astconv.tcx();\n-    let PartitionedBounds {\n-        builtin_bounds,\n-        trait_bounds,\n-        region_bounds\n-    } = partition_bounds(tcx, span, &ast_bounds);\n-\n-    let mut projection_bounds = Vec::new();\n-\n-    let trait_bounds: Vec<ty::PolyTraitRef> =\n-        trait_bounds.iter()\n-                    .map(|bound| conv_poly_trait_ref(astconv,\n-                                                     param_ty,\n-                                                     *bound,\n-                                                     &mut projection_bounds))\n-                    .collect();\n-\n-    let region_bounds: Vec<ty::Region> =\n-        region_bounds.into_iter()\n-                     .map(|r| ast_region_to_region(tcx, r))\n-                     .collect();\n-\n-    Bounds {\n-        region_bounds: region_bounds,\n-        builtin_bounds: builtin_bounds,\n-        trait_bounds: trait_bounds,\n-        projection_bounds: projection_bounds,\n-    }\n-}\n-\n fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n     id: DefId,"}, {"sha": "7b78e83b8012012a14cf90be9a0971c3e72fef8d", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -4086,4 +4086,7 @@ register_diagnostics! {\n     E0533, // `{}` does not name a unit variant, unit struct or a constant\n     E0562, // `impl Trait` not allowed outside of function\n            // and inherent method return types\n+    E0563, // cannot determine a type for this `impl Trait`: {}\n+    E0564, // only named lifetimes are allowed in `impl Trait`,\n+           // but `{}` was found in the type `{}`\n }"}, {"sha": "2a9af26881c77ba77ca71f01f8d83abfbf4696f7", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "added", "additions": 929, "deletions": 0, "changes": 929, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -0,0 +1,929 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait, fn_traits, step_trait, unboxed_closures)]\n+\n+//! Derived from: <https://raw.githubusercontent.com/quickfur/dcal/master/dcal.d>.\n+//!\n+//! Originally converted to Rust by [Daniel Keep](https://github.com/DanielKeep).\n+\n+use std::fmt::Write;\n+use std::mem;\n+\n+/// Date representation.\n+#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+struct NaiveDate(i32, u32, u32);\n+\n+impl NaiveDate {\n+    pub fn from_ymd(y: i32, m: u32, d: u32) -> NaiveDate {\n+        assert!(1 <= m && m <= 12, \"m = {:?}\", m);\n+        assert!(1 <= d && d <= NaiveDate(y, m, 1).days_in_month(), \"d = {:?}\", d);\n+        NaiveDate(y, m, d)\n+    }\n+\n+    pub fn year(&self) -> i32 {\n+        self.0\n+    }\n+\n+    pub fn month(&self) -> u32 {\n+        self.1\n+    }\n+\n+    pub fn day(&self) -> u32 {\n+        self.2\n+    }\n+\n+    pub fn succ(&self) -> NaiveDate {\n+        let (mut y, mut m, mut d, n) = (\n+            self.year(), self.month(), self.day()+1, self.days_in_month());\n+        if d > n {\n+            d = 1;\n+            m += 1;\n+        }\n+        if m > 12 {\n+            m = 1;\n+            y += 1;\n+        }\n+        NaiveDate::from_ymd(y, m, d)\n+    }\n+\n+    pub fn weekday(&self) -> Weekday {\n+        use Weekday::*;\n+\n+        // 0 = Sunday\n+        let year = self.year();\n+        let dow_jan_1 = (year*365 + ((year-1) / 4) - ((year-1) / 100) + ((year-1) / 400)) % 7;\n+        let dow = (dow_jan_1 + (self.day_of_year() as i32 - 1)) % 7;\n+        [Sun, Mon, Tue, Wed, Thu, Fri, Sat][dow as usize]\n+    }\n+\n+    pub fn isoweekdate(&self) -> (i32, u32, Weekday) {\n+        let first_dow_mon_0 = self.year_first_day_of_week().num_days_from_monday();\n+\n+        // Work out this date's DOtY and week number, not including year adjustment.\n+        let doy_0 = self.day_of_year() - 1;\n+        let mut week_mon_0: i32 = ((first_dow_mon_0 + doy_0) / 7) as i32;\n+\n+        if self.first_week_in_prev_year() {\n+            week_mon_0 -= 1;\n+        }\n+\n+        let weeks_in_year = self.last_week_number();\n+\n+        // Work out the final result.\n+        // If the week is -1 or >= weeks_in_year, we will need to adjust the year.\n+        let year = self.year();\n+        let wd = self.weekday();\n+\n+        if week_mon_0 < 0 {\n+            (year - 1, NaiveDate::from_ymd(year - 1, 1, 1).last_week_number(), wd)\n+        } else if week_mon_0 >= weeks_in_year as i32 {\n+            (year + 1, (week_mon_0 + 1 - weeks_in_year as i32) as u32, wd)\n+        } else {\n+            (year, (week_mon_0 + 1) as u32, wd)\n+        }\n+    }\n+\n+    fn first_week_in_prev_year(&self) -> bool {\n+        let first_dow_mon_0 = self.year_first_day_of_week().num_days_from_monday();\n+\n+        // Any day in the year *before* the first Monday of that year\n+        // is considered to be in the last week of the previous year,\n+        // assuming the first week has *less* than four days in it.\n+        // Adjust the week appropriately.\n+        ((7 - first_dow_mon_0) % 7) < 4\n+    }\n+\n+    fn year_first_day_of_week(&self) -> Weekday {\n+        NaiveDate::from_ymd(self.year(), 1, 1).weekday()\n+    }\n+\n+    fn weeks_in_year(&self) -> u32 {\n+        let days_in_last_week = self.year_first_day_of_week().num_days_from_monday() + 1;\n+        if days_in_last_week >= 4 { 53 } else { 52 }\n+    }\n+\n+    fn last_week_number(&self) -> u32 {\n+        let wiy = self.weeks_in_year();\n+        if self.first_week_in_prev_year() { wiy - 1 } else { wiy }\n+    }\n+\n+    fn day_of_year(&self) -> u32 {\n+        (1..self.1).map(|m| NaiveDate::from_ymd(self.year(), m, 1).days_in_month())\n+            .fold(0, |a,b| a+b) + self.day()\n+    }\n+\n+    fn is_leap_year(&self) -> bool {\n+        let year = self.year();\n+        if year % 4 != 0 {\n+            return false\n+        } else if year % 100 != 0 {\n+            return true\n+        } else if year % 400 != 0 {\n+            return false\n+        } else {\n+            return true\n+        }\n+    }\n+\n+    fn days_in_month(&self) -> u32 {\n+        match self.month() {\n+            /* Jan */ 1 => 31,\n+            /* Feb */ 2 => if self.is_leap_year() { 29 } else { 28 },\n+            /* Mar */ 3 => 31,\n+            /* Apr */ 4 => 30,\n+            /* May */ 5 => 31,\n+            /* Jun */ 6 => 30,\n+            /* Jul */ 7 => 31,\n+            /* Aug */ 8 => 31,\n+            /* Sep */ 9 => 30,\n+            /* Oct */ 10 => 31,\n+            /* Nov */ 11 => 30,\n+            /* Dec */ 12 => 31,\n+            _ => unreachable!()\n+        }\n+    }\n+}\n+\n+impl<'a, 'b> std::ops::Add<&'b NaiveDate> for &'a NaiveDate {\n+    type Output = NaiveDate;\n+\n+    fn add(self, other: &'b NaiveDate) -> NaiveDate {\n+        assert_eq!(*other, NaiveDate(0, 0, 1));\n+        self.succ()\n+    }\n+}\n+\n+impl std::iter::Step for NaiveDate {\n+    fn step(&self, by: &Self) -> Option<Self> {\n+        Some(self + by)\n+    }\n+\n+    fn steps_between(_: &Self, _: &Self, _: &Self) -> Option<usize> {\n+        unimplemented!()\n+    }\n+\n+    fn steps_between_by_one(_: &Self, _: &Self) -> Option<usize> {\n+        unimplemented!()\n+    }\n+\n+    fn is_negative(&self) -> bool {\n+        false\n+    }\n+\n+    fn replace_one(&mut self) -> Self {\n+        mem::replace(self, NaiveDate(0, 0, 1))\n+    }\n+\n+    fn replace_zero(&mut self) -> Self {\n+        mem::replace(self, NaiveDate(0, 0, 0))\n+    }\n+\n+    fn add_one(&self) -> Self {\n+        self.succ()\n+    }\n+\n+    fn sub_one(&self) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+pub enum Weekday {\n+    Mon,\n+    Tue,\n+    Wed,\n+    Thu,\n+    Fri,\n+    Sat,\n+    Sun,\n+}\n+\n+impl Weekday {\n+    pub fn num_days_from_monday(&self) -> u32 {\n+        use Weekday::*;\n+        match *self {\n+            Mon => 0,\n+            Tue => 1,\n+            Wed => 2,\n+            Thu => 3,\n+            Fri => 4,\n+            Sat => 5,\n+            Sun => 6,\n+        }\n+    }\n+\n+    pub fn num_days_from_sunday(&self) -> u32 {\n+        use Weekday::*;\n+        match *self {\n+            Sun => 0,\n+            Mon => 1,\n+            Tue => 2,\n+            Wed => 3,\n+            Thu => 4,\n+            Fri => 5,\n+            Sat => 6,\n+        }\n+    }\n+}\n+\n+/// Wrapper for zero-sized closures.\n+// HACK(eddyb) Only needed because closures can't implement Copy.\n+struct Fn0<F>(std::marker::PhantomData<F>);\n+\n+impl<F> Copy for Fn0<F> {}\n+impl<F> Clone for Fn0<F> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+impl<F: FnOnce<A>, A> FnOnce<A> for Fn0<F> {\n+    type Output = F::Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        let f = unsafe { std::mem::uninitialized::<F>() };\n+        f.call_once(args)\n+    }\n+}\n+\n+impl<F: FnMut<A>, A> FnMut<A> for Fn0<F> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: A) -> Self::Output {\n+        let mut f = unsafe { std::mem::uninitialized::<F>() };\n+        f.call_mut(args)\n+    }\n+}\n+\n+trait AsFn0<A>: Sized {\n+    fn copyable(self) -> Fn0<Self>;\n+}\n+\n+impl<F: FnMut<A>, A> AsFn0<A> for F {\n+    fn copyable(self) -> Fn0<Self> {\n+        assert_eq!(std::mem::size_of::<F>(), 0);\n+        Fn0(std::marker::PhantomData)\n+    }\n+}\n+\n+/// GroupBy implementation.\n+struct GroupBy<It: Iterator, F> {\n+    it: std::iter::Peekable<It>,\n+    f: F,\n+}\n+\n+impl<It, F> Clone for GroupBy<It, F>\n+where It: Iterator + Clone, It::Item: Clone, F: Clone {\n+    fn clone(&self) -> GroupBy<It, F> {\n+        GroupBy {\n+            it: self.it.clone(),\n+            f: self.f.clone()\n+        }\n+    }\n+}\n+\n+impl<'a, G, It: 'a, F: 'a> Iterator for GroupBy<It, F>\n+where It: Iterator + Clone,\n+      It::Item: Clone,\n+      F: Clone + FnMut(&It::Item) -> G,\n+      G: Eq + Clone\n+{\n+    type Item = (G, InGroup<std::iter::Peekable<It>, F, G>);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.it.peek().map(&mut self.f).map(|key| {\n+            let start = self.it.clone();\n+            while let Some(k) = self.it.peek().map(&mut self.f) {\n+                if key != k {\n+                    break;\n+                }\n+                self.it.next();\n+            }\n+\n+            (key.clone(), InGroup {\n+                it: start,\n+                f: self.f.clone(),\n+                g: key\n+            })\n+        })\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+struct InGroup<It, F, G> {\n+    it: It,\n+    f: F,\n+    g: G\n+}\n+\n+impl<It: Iterator, F: FnMut(&It::Item) -> G, G: Eq> Iterator for InGroup<It, F, G> {\n+    type Item = It::Item;\n+\n+    fn next(&mut self) -> Option<It::Item> {\n+        self.it.next().and_then(|x| {\n+            if (self.f)(&x) == self.g { Some(x) } else { None }\n+        })\n+    }\n+}\n+\n+trait IteratorExt: Iterator + Sized {\n+    fn group_by<G, F>(self, f: F) -> GroupBy<Self, Fn0<F>>\n+    where F: FnMut(&Self::Item) -> G,\n+          G: Eq\n+    {\n+        GroupBy {\n+            it: self.peekable(),\n+            f: f.copyable(),\n+        }\n+    }\n+\n+    fn join(mut self, sep: &str) -> String\n+    where Self::Item: std::fmt::Display {\n+        let mut s = String::new();\n+        if let Some(e) = self.next() {\n+            write!(s, \"{}\", e);\n+            for e in self {\n+                s.push_str(sep);\n+                write!(s, \"{}\", e);\n+            }\n+        }\n+        s\n+    }\n+\n+    // HACK(eddyb) Only needed because `impl Trait` can't be\n+    // used with trait methods: `.foo()` becomes `.__(foo)`.\n+    fn __<F, R>(self, f: F) -> R\n+    where F: FnOnce(Self) -> R {\n+        f(self)\n+    }\n+}\n+\n+impl<It> IteratorExt for It where It: Iterator {}\n+\n+///\n+/// Generates an iterator that yields exactly n spaces.\n+///\n+fn spaces(n: usize) -> std::iter::Take<std::iter::Repeat<char>> {\n+    std::iter::repeat(' ').take(n)\n+}\n+\n+fn test_spaces() {\n+    assert_eq!(spaces(0).collect::<String>(), \"\");\n+    assert_eq!(spaces(10).collect::<String>(), \"          \")\n+}\n+\n+///\n+/// Returns an iterator of dates in a given year.\n+///\n+fn dates_in_year(year: i32) -> impl Iterator<Item=NaiveDate>+Clone {\n+    InGroup {\n+        it: NaiveDate::from_ymd(year, 1, 1)..,\n+        f: (|d: &NaiveDate| d.year()).copyable(),\n+        g: year\n+    }\n+}\n+\n+fn test_dates_in_year() {\n+    {\n+        let mut dates = dates_in_year(2013);\n+        assert_eq!(dates.next(), Some(NaiveDate::from_ymd(2013, 1, 1)));\n+\n+        // Check increment\n+        assert_eq!(dates.next(), Some(NaiveDate::from_ymd(2013, 1, 2)));\n+\n+        // Check monthly rollover\n+        for _ in 3..31 {\n+            assert!(dates.next() != None);\n+        }\n+\n+        assert_eq!(dates.next(), Some(NaiveDate::from_ymd(2013, 1, 31)));\n+        assert_eq!(dates.next(), Some(NaiveDate::from_ymd(2013, 2, 1)));\n+    }\n+\n+    {\n+        // Check length of year\n+        let mut dates = dates_in_year(2013);\n+        for _ in 0..365 {\n+            assert!(dates.next() != None);\n+        }\n+        assert_eq!(dates.next(), None);\n+    }\n+\n+    {\n+        // Check length of leap year\n+        let mut dates = dates_in_year(1984);\n+        for _ in 0..366 {\n+            assert!(dates.next() != None);\n+        }\n+        assert_eq!(dates.next(), None);\n+    }\n+}\n+\n+///\n+/// Convenience trait for verifying that a given type iterates over\n+/// `NaiveDate`s.\n+///\n+trait DateIterator: Iterator<Item=NaiveDate> + Clone {}\n+impl<It> DateIterator for It where It: Iterator<Item=NaiveDate> + Clone {}\n+\n+fn test_group_by() {\n+    let input = [\n+        [1, 1],\n+        [1, 1],\n+        [1, 2],\n+        [2, 2],\n+        [2, 3],\n+        [2, 3],\n+        [3, 3]\n+    ];\n+\n+    let by_x = input.iter().cloned().group_by(|a| a[0]);\n+    let expected_1: &[&[[i32; 2]]] = &[\n+        &[[1, 1], [1, 1], [1, 2]],\n+        &[[2, 2], [2, 3], [2, 3]],\n+        &[[3, 3]]\n+    ];\n+    for ((_, a), b) in by_x.zip(expected_1.iter().cloned()) {\n+        assert_eq!(&a.collect::<Vec<_>>()[..], b);\n+    }\n+\n+    let by_y = input.iter().cloned().group_by(|a| a[1]);\n+    let expected_2: &[&[[i32; 2]]] = &[\n+        &[[1, 1], [1, 1]],\n+        &[[1, 2], [2, 2]],\n+        &[[2, 3], [2, 3], [3, 3]]\n+    ];\n+    for ((_, a), b) in by_y.zip(expected_2.iter().cloned()) {\n+        assert_eq!(&a.collect::<Vec<_>>()[..], b);\n+    }\n+}\n+\n+///\n+/// Groups an iterator of dates by month.\n+///\n+fn by_month<It>(it: It)\n+                ->  impl Iterator<Item=(u32, impl Iterator<Item=NaiveDate> + Clone)> + Clone\n+where It: Iterator<Item=NaiveDate> + Clone {\n+    it.group_by(|d| d.month())\n+}\n+\n+fn test_by_month() {\n+    let mut months = dates_in_year(2013).__(by_month);\n+    for (month, (_, mut date)) in (1..13).zip(&mut months) {\n+        assert_eq!(date.nth(0).unwrap(), NaiveDate::from_ymd(2013, month, 1));\n+    }\n+    assert!(months.next().is_none());\n+}\n+\n+///\n+/// Groups an iterator of dates by week.\n+///\n+fn by_week<It>(it: It)\n+               -> impl Iterator<Item=(u32, impl DateIterator)> + Clone\n+where It: DateIterator {\n+    // We go forward one day because `isoweekdate` considers the week to start on a Monday.\n+    it.group_by(|d| d.succ().isoweekdate().1)\n+}\n+\n+fn test_isoweekdate() {\n+    fn weeks_uniq(year: i32) -> Vec<((i32, u32), u32)> {\n+        let mut weeks = dates_in_year(year).map(|d| d.isoweekdate())\n+            .map(|(y,w,_)| (y,w));\n+        let mut result = vec![];\n+        let mut accum = (weeks.next().unwrap(), 1);\n+        for yw in weeks {\n+            if accum.0 == yw {\n+                accum.1 += 1;\n+            } else {\n+                result.push(accum);\n+                accum = (yw, 1);\n+            }\n+        }\n+        result.push(accum);\n+        result\n+    }\n+\n+    let wu_1984 = weeks_uniq(1984);\n+    assert_eq!(&wu_1984[..2], &[((1983, 52), 1), ((1984, 1), 7)]);\n+    assert_eq!(&wu_1984[wu_1984.len()-2..], &[((1984, 52), 7), ((1985, 1), 1)]);\n+\n+    let wu_2013 = weeks_uniq(2013);\n+    assert_eq!(&wu_2013[..2], &[((2013, 1), 6), ((2013, 2), 7)]);\n+    assert_eq!(&wu_2013[wu_2013.len()-2..], &[((2013, 52), 7), ((2014, 1), 2)]);\n+\n+    let wu_2015 = weeks_uniq(2015);\n+    assert_eq!(&wu_2015[..2], &[((2015, 1), 4), ((2015, 2), 7)]);\n+    assert_eq!(&wu_2015[wu_2015.len()-2..], &[((2015, 52), 7), ((2015, 53), 4)]);\n+}\n+\n+fn test_by_week() {\n+    let mut weeks = dates_in_year(2013).__(by_week);\n+    assert_eq!(\n+        &*weeks.next().unwrap().1.collect::<Vec<_>>(),\n+        &[\n+            NaiveDate::from_ymd(2013, 1, 1),\n+            NaiveDate::from_ymd(2013, 1, 2),\n+            NaiveDate::from_ymd(2013, 1, 3),\n+            NaiveDate::from_ymd(2013, 1, 4),\n+            NaiveDate::from_ymd(2013, 1, 5),\n+        ]\n+    );\n+    assert_eq!(\n+        &*weeks.next().unwrap().1.collect::<Vec<_>>(),\n+        &[\n+            NaiveDate::from_ymd(2013, 1, 6),\n+            NaiveDate::from_ymd(2013, 1, 7),\n+            NaiveDate::from_ymd(2013, 1, 8),\n+            NaiveDate::from_ymd(2013, 1, 9),\n+            NaiveDate::from_ymd(2013, 1, 10),\n+            NaiveDate::from_ymd(2013, 1, 11),\n+            NaiveDate::from_ymd(2013, 1, 12),\n+        ]\n+    );\n+    assert_eq!(weeks.next().unwrap().1.nth(0).unwrap(), NaiveDate::from_ymd(2013, 1, 13));\n+}\n+\n+/// The number of columns per day in the formatted output.\n+const COLS_PER_DAY: u32 = 3;\n+\n+/// The number of columns per week in the formatted output.\n+const COLS_PER_WEEK: u32 = 7 * COLS_PER_DAY;\n+\n+///\n+/// Formats an iterator of weeks into an iterator of strings.\n+///\n+fn format_weeks<It>(it: It) -> impl Iterator<Item=String>\n+where It: Iterator, It::Item: DateIterator {\n+    it.map(|week| {\n+        let mut buf = String::with_capacity((COLS_PER_DAY * COLS_PER_WEEK + 2) as usize);\n+\n+        // Format each day into its own cell and append to target string.\n+        let mut last_day = 0;\n+        let mut first = true;\n+        for d in week {\n+            last_day = d.weekday().num_days_from_sunday();\n+\n+            // Insert enough filler to align the first day with its respective day-of-week.\n+            if first {\n+                buf.extend(spaces((COLS_PER_DAY * last_day) as usize));\n+                first = false;\n+            }\n+\n+            write!(buf, \" {:>2}\", d.day());\n+        }\n+\n+        // Insert more filler at the end to fill up the remainder of the week,\n+        // if its a short week (e.g. at the end of the month).\n+        buf.extend(spaces((COLS_PER_DAY * (6 - last_day)) as usize));\n+        buf\n+    })\n+}\n+\n+fn test_format_weeks() {\n+    let jan_2013 = dates_in_year(2013)\n+        .__(by_month).next() // pick January 2013 for testing purposes\n+        // NOTE: This `map` is because `next` returns an `Option<_>`.\n+        .map(|(_, month)|\n+            month.__(by_week)\n+                 .map(|(_, weeks)| weeks)\n+                 .__(format_weeks)\n+                 .join(\"\\n\"));\n+\n+    assert_eq!(\n+        jan_2013.as_ref().map(|s| &**s),\n+        Some(\"        1  2  3  4  5\\n\\\n+           \\x20 6  7  8  9 10 11 12\\n\\\n+           \\x2013 14 15 16 17 18 19\\n\\\n+           \\x2020 21 22 23 24 25 26\\n\\\n+           \\x2027 28 29 30 31      \")\n+    );\n+}\n+\n+///\n+/// Formats the name of a month, centered on COLS_PER_WEEK.\n+///\n+fn month_title(month: u32) -> String {\n+    const MONTH_NAMES: &'static [&'static str] = &[\n+        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n+        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n+    ];\n+    assert_eq!(MONTH_NAMES.len(), 12);\n+\n+    // Determine how many spaces before and after the month name\n+    // we need to center it over the formatted weeks in the month.\n+    let name = MONTH_NAMES[(month - 1) as usize];\n+    assert!(name.len() < COLS_PER_WEEK as usize);\n+    let before = (COLS_PER_WEEK as usize - name.len()) / 2;\n+    let after = COLS_PER_WEEK as usize - name.len() - before;\n+\n+    // NOTE: Being slightly more verbose to avoid extra allocations.\n+    let mut result = String::with_capacity(COLS_PER_WEEK as usize);\n+    result.extend(spaces(before));\n+    result.push_str(name);\n+    result.extend(spaces(after));\n+    result\n+}\n+\n+fn test_month_title() {\n+    assert_eq!(month_title(1).len(), COLS_PER_WEEK as usize);\n+}\n+\n+///\n+/// Formats a month.\n+///\n+fn format_month<It: DateIterator>(it: It) -> impl Iterator<Item=String> {\n+    let mut month_days = it.peekable();\n+    let title = month_title(month_days.peek().unwrap().month());\n+\n+    Some(title).into_iter()\n+        .chain(month_days.__(by_week)\n+            .map(|(_, week)| week)\n+            .__(format_weeks))\n+}\n+\n+fn test_format_month() {\n+    let month_fmt = dates_in_year(2013)\n+        .__(by_month).next() // Pick January as a test case\n+        .map(|(_, days)| days.into_iter()\n+            .__(format_month)\n+            .join(\"\\n\"));\n+\n+    assert_eq!(\n+        month_fmt.as_ref().map(|s| &**s),\n+        Some(\"       January       \\n\\\n+           \\x20       1  2  3  4  5\\n\\\n+           \\x20 6  7  8  9 10 11 12\\n\\\n+           \\x2013 14 15 16 17 18 19\\n\\\n+           \\x2020 21 22 23 24 25 26\\n\\\n+           \\x2027 28 29 30 31      \")\n+    );\n+}\n+\n+\n+///\n+/// Formats an iterator of months.\n+///\n+fn format_months<It>(it: It) -> impl Iterator<Item=impl Iterator<Item=String>>\n+where It: Iterator, It::Item: DateIterator {\n+    it.map(format_month)\n+}\n+\n+///\n+/// Takes an iterator of iterators of strings; the sub-iterators are consumed\n+/// in lock-step, with their elements joined together.\n+///\n+trait PasteBlocks: Iterator + Sized\n+where Self::Item: Iterator<Item=String> {\n+    fn paste_blocks(self, sep_width: usize) -> PasteBlocksIter<Self::Item> {\n+        PasteBlocksIter {\n+            iters: self.collect(),\n+            cache: vec![],\n+            col_widths: None,\n+            sep_width: sep_width,\n+        }\n+    }\n+}\n+\n+impl<It> PasteBlocks for It where It: Iterator, It::Item: Iterator<Item=String> {}\n+\n+struct PasteBlocksIter<StrIt>\n+where StrIt: Iterator<Item=String> {\n+    iters: Vec<StrIt>,\n+    cache: Vec<Option<String>>,\n+    col_widths: Option<Vec<usize>>,\n+    sep_width: usize,\n+}\n+\n+impl<StrIt> Iterator for PasteBlocksIter<StrIt>\n+where StrIt: Iterator<Item=String> {\n+    type Item = String;\n+\n+    fn next(&mut self) -> Option<String> {\n+        self.cache.clear();\n+\n+        // `cache` is now the next line from each iterator.\n+        self.cache.extend(self.iters.iter_mut().map(|it| it.next()));\n+\n+        // If every line in `cache` is `None`, we have nothing further to do.\n+        if self.cache.iter().all(|e| e.is_none()) { return None }\n+\n+        // Get the column widths if we haven't already.\n+        let col_widths = match self.col_widths {\n+            Some(ref v) => &**v,\n+            None => {\n+                self.col_widths = Some(self.cache.iter()\n+                    .map(|ms| ms.as_ref().map(|s| s.len()).unwrap_or(0))\n+                    .collect());\n+                &**self.col_widths.as_ref().unwrap()\n+            }\n+        };\n+\n+        // Fill in any `None`s with spaces.\n+        let mut parts = col_widths.iter().cloned().zip(self.cache.iter_mut())\n+            .map(|(w,ms)| ms.take().unwrap_or_else(|| spaces(w).collect()));\n+\n+        // Join them all together.\n+        let first = parts.next().unwrap_or(String::new());\n+        let sep_width = self.sep_width;\n+        Some(parts.fold(first, |mut accum, next| {\n+            accum.extend(spaces(sep_width));\n+            accum.push_str(&next);\n+            accum\n+        }))\n+    }\n+}\n+\n+fn test_paste_blocks() {\n+    let row = dates_in_year(2013)\n+        .__(by_month).map(|(_, days)| days)\n+        .take(3)\n+        .__(format_months)\n+        .paste_blocks(1)\n+        .join(\"\\n\");\n+    assert_eq!(\n+        &*row,\n+        \"       January              February                March        \\n\\\n+      \\x20       1  2  3  4  5                  1  2                  1  2\\n\\\n+      \\x20 6  7  8  9 10 11 12   3  4  5  6  7  8  9   3  4  5  6  7  8  9\\n\\\n+      \\x2013 14 15 16 17 18 19  10 11 12 13 14 15 16  10 11 12 13 14 15 16\\n\\\n+      \\x2020 21 22 23 24 25 26  17 18 19 20 21 22 23  17 18 19 20 21 22 23\\n\\\n+      \\x2027 28 29 30 31        24 25 26 27 28        24 25 26 27 28 29 30\\n\\\n+      \\x20                                            31                  \"\n+    );\n+}\n+\n+///\n+/// Produces an iterator that yields `n` elements at a time.\n+///\n+trait Chunks: Iterator + Sized {\n+    fn chunks(self, n: usize) -> ChunksIter<Self> {\n+        assert!(n > 0);\n+        ChunksIter {\n+            it: self,\n+            n: n,\n+        }\n+    }\n+}\n+\n+impl<It> Chunks for It where It: Iterator {}\n+\n+struct ChunksIter<It>\n+where It: Iterator {\n+    it: It,\n+    n: usize,\n+}\n+\n+// NOTE: `chunks` in Rust is more-or-less impossible without overhead of some kind.\n+// Aliasing rules mean you need to add dynamic borrow checking, and the design of\n+// `Iterator` means that you need to have the iterator's state kept in an allocation\n+// that is jointly owned by the iterator itself and the sub-iterator.\n+// As such, I've chosen to cop-out and just heap-allocate each chunk.\n+\n+impl<It> Iterator for ChunksIter<It>\n+where It: Iterator {\n+    type Item = Vec<It::Item>;\n+\n+    fn next(&mut self) -> Option<Vec<It::Item>> {\n+        let first = match self.it.next() {\n+            Some(e) => e,\n+            None => return None\n+        };\n+\n+        let mut result = Vec::with_capacity(self.n);\n+        result.push(first);\n+\n+        Some((&mut self.it).take(self.n-1)\n+            .fold(result, |mut acc, next| { acc.push(next); acc }))\n+    }\n+}\n+\n+fn test_chunks() {\n+    let r = &[1, 2, 3, 4, 5, 6, 7];\n+    let c = r.iter().cloned().chunks(3).collect::<Vec<_>>();\n+    assert_eq!(&*c, &[vec![1, 2, 3], vec![4, 5, 6], vec![7]]);\n+}\n+\n+///\n+/// Formats a year.\n+///\n+fn format_year(year: i32, months_per_row: usize) -> String {\n+    const COL_SPACING: usize = 1;\n+\n+    // Start by generating all dates for the given year.\n+    dates_in_year(year)\n+\n+        // Group them by month and throw away month number.\n+        .__(by_month).map(|(_, days)| days)\n+\n+        // Group the months into horizontal rows.\n+        .chunks(months_per_row)\n+\n+        // Format each row\n+        .map(|r| r.into_iter()\n+            // By formatting each month\n+            .__(format_months)\n+\n+            // Horizontally pasting each respective month's lines together.\n+            .paste_blocks(COL_SPACING)\n+            .join(\"\\n\")\n+        )\n+\n+        // Insert a blank line between each row\n+        .join(\"\\n\\n\")\n+}\n+\n+fn test_format_year() {\n+    const MONTHS_PER_ROW: usize = 3;\n+\n+    macro_rules! assert_eq_cal {\n+        ($lhs:expr, $rhs:expr) => {\n+            if $lhs != $rhs {\n+                println!(\"got:\\n```\\n{}\\n```\\n\", $lhs.replace(\" \", \".\"));\n+                println!(\"expected:\\n```\\n{}\\n```\", $rhs.replace(\" \", \".\"));\n+                panic!(\"calendars didn't match!\");\n+            }\n+        }\n+    }\n+\n+    assert_eq_cal!(&format_year(1984, MONTHS_PER_ROW), \"\\\n+\\x20      January              February                March        \\n\\\n+\\x20 1  2  3  4  5  6  7            1  2  3  4               1  2  3\\n\\\n+\\x20 8  9 10 11 12 13 14   5  6  7  8  9 10 11   4  5  6  7  8  9 10\\n\\\n+\\x2015 16 17 18 19 20 21  12 13 14 15 16 17 18  11 12 13 14 15 16 17\\n\\\n+\\x2022 23 24 25 26 27 28  19 20 21 22 23 24 25  18 19 20 21 22 23 24\\n\\\n+\\x2029 30 31              26 27 28 29           25 26 27 28 29 30 31\\n\\\n+\\n\\\n+\\x20       April                  May                  June         \\n\\\n+\\x20 1  2  3  4  5  6  7         1  2  3  4  5                  1  2\\n\\\n+\\x20 8  9 10 11 12 13 14   6  7  8  9 10 11 12   3  4  5  6  7  8  9\\n\\\n+\\x2015 16 17 18 19 20 21  13 14 15 16 17 18 19  10 11 12 13 14 15 16\\n\\\n+\\x2022 23 24 25 26 27 28  20 21 22 23 24 25 26  17 18 19 20 21 22 23\\n\\\n+\\x2029 30                 27 28 29 30 31        24 25 26 27 28 29 30\\n\\\n+\\n\\\n+\\x20       July                 August               September      \\n\\\n+\\x20 1  2  3  4  5  6  7            1  2  3  4                     1\\n\\\n+\\x20 8  9 10 11 12 13 14   5  6  7  8  9 10 11   2  3  4  5  6  7  8\\n\\\n+\\x2015 16 17 18 19 20 21  12 13 14 15 16 17 18   9 10 11 12 13 14 15\\n\\\n+\\x2022 23 24 25 26 27 28  19 20 21 22 23 24 25  16 17 18 19 20 21 22\\n\\\n+\\x2029 30 31              26 27 28 29 30 31     23 24 25 26 27 28 29\\n\\\n+\\x20                                            30                  \\n\\\n+\\n\\\n+\\x20      October              November              December       \\n\\\n+\\x20    1  2  3  4  5  6               1  2  3                     1\\n\\\n+\\x20 7  8  9 10 11 12 13   4  5  6  7  8  9 10   2  3  4  5  6  7  8\\n\\\n+\\x2014 15 16 17 18 19 20  11 12 13 14 15 16 17   9 10 11 12 13 14 15\\n\\\n+\\x2021 22 23 24 25 26 27  18 19 20 21 22 23 24  16 17 18 19 20 21 22\\n\\\n+\\x2028 29 30 31           25 26 27 28 29 30     23 24 25 26 27 28 29\\n\\\n+\\x20                                            30 31               \");\n+\n+    assert_eq_cal!(&format_year(2015, MONTHS_PER_ROW), \"\\\n+\\x20      January              February                March        \\n\\\n+\\x20             1  2  3   1  2  3  4  5  6  7   1  2  3  4  5  6  7\\n\\\n+\\x20 4  5  6  7  8  9 10   8  9 10 11 12 13 14   8  9 10 11 12 13 14\\n\\\n+\\x2011 12 13 14 15 16 17  15 16 17 18 19 20 21  15 16 17 18 19 20 21\\n\\\n+\\x2018 19 20 21 22 23 24  22 23 24 25 26 27 28  22 23 24 25 26 27 28\\n\\\n+\\x2025 26 27 28 29 30 31                        29 30 31            \\n\\\n+\\n\\\n+\\x20       April                  May                  June         \\n\\\n+\\x20          1  2  3  4                  1  2      1  2  3  4  5  6\\n\\\n+\\x20 5  6  7  8  9 10 11   3  4  5  6  7  8  9   7  8  9 10 11 12 13\\n\\\n+\\x2012 13 14 15 16 17 18  10 11 12 13 14 15 16  14 15 16 17 18 19 20\\n\\\n+\\x2019 20 21 22 23 24 25  17 18 19 20 21 22 23  21 22 23 24 25 26 27\\n\\\n+\\x2026 27 28 29 30        24 25 26 27 28 29 30  28 29 30            \\n\\\n+\\x20                      31                                        \\n\\\n+\\n\\\n+\\x20       July                 August               September      \\n\\\n+\\x20          1  2  3  4                     1         1  2  3  4  5\\n\\\n+\\x20 5  6  7  8  9 10 11   2  3  4  5  6  7  8   6  7  8  9 10 11 12\\n\\\n+\\x2012 13 14 15 16 17 18   9 10 11 12 13 14 15  13 14 15 16 17 18 19\\n\\\n+\\x2019 20 21 22 23 24 25  16 17 18 19 20 21 22  20 21 22 23 24 25 26\\n\\\n+\\x2026 27 28 29 30 31     23 24 25 26 27 28 29  27 28 29 30         \\n\\\n+\\x20                      30 31                                     \\n\\\n+\\n\\\n+\\x20      October              November              December       \\n\\\n+\\x20             1  2  3   1  2  3  4  5  6  7         1  2  3  4  5\\n\\\n+\\x20 4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12\\n\\\n+\\x2011 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19\\n\\\n+\\x2018 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26\\n\\\n+\\x2025 26 27 28 29 30 31  29 30                 27 28 29 30 31      \");\n+}\n+\n+fn main() {\n+    // Run tests.\n+    test_spaces();\n+    test_dates_in_year();\n+    test_group_by();\n+    test_by_month();\n+    test_isoweekdate();\n+    test_by_week();\n+    test_format_weeks();\n+    test_month_title();\n+    test_format_month();\n+    test_paste_blocks();\n+    test_chunks();\n+    test_format_year();\n+}"}, {"sha": "461d4cf4ff053bc0feea5dc3923503704e4aa72f", "filename": "src/test/run-pass/impl-trait/example-st.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-st.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d92e594c3801a8066f95305c87e53a7ecfb24e9b/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-st.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-st.rs?ref=d92e594c3801a8066f95305c87e53a7ecfb24e9b", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait, question_mark)]\n+\n+struct State;\n+type Error = ();\n+\n+trait Bind<F> {\n+    type Output;\n+    fn bind(self, f: F) -> Self::Output;\n+}\n+\n+fn bind<T, U, A, B, F>(mut a: A, mut f: F)\n+                       -> impl FnMut(&mut State) -> Result<U, Error>\n+where F: FnMut(T) -> B,\n+      A: FnMut(&mut State) -> Result<T, Error>,\n+      B: FnMut(&mut State) -> Result<U, Error>\n+{\n+    move |state | {\n+        let r = a(state)?;\n+        f(r)(state)\n+    }\n+}\n+\n+fn atom<T>(x: T) -> impl FnMut(&mut State) -> Result<T, Error> {\n+    let mut x = Some(x);\n+    move |_| x.take().map_or(Err(()), Ok)\n+}\n+\n+fn main() {\n+    assert_eq!(bind(atom(5), |x| atom(x > 4))(&mut State), Ok(true));\n+}"}]}