{"sha": "e8139dfd5a747842a8303f33d8c842378913d594", "node_id": "C_kwDOAAsO6NoAKGU4MTM5ZGZkNWE3NDc4NDJhODMwM2YzM2Q4Yzg0MjM3ODkxM2Q1OTQ", "commit": {"author": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-03-21T00:46:52Z"}, "committer": {"name": "Le\u00f3n Orell Valerian Liehr", "email": "me@fmease.dev", "date": "2023-05-04T14:59:10Z"}, "message": "IAT: Introduce AliasKind::Inherent", "tree": {"sha": "977f9a1bd7bc5c0e8efc36b3a23c911c64189cc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/977f9a1bd7bc5c0e8efc36b3a23c911c64189cc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8139dfd5a747842a8303f33d8c842378913d594", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXSQFaHGAjVoD5I3F0XoHIV9o5xMFAmRTyD4ACgkQ0XoHIV9o\n5xMtABAAgSxjqIMdQSyFwDidu9plqwTiAC2WJz8A6d1itk19b/4pqaXoCW99VvWw\nlRHYVQB82GjlukR3TJYEO0pnnNA3ZyKHSM9C+qfz65de8/meZyGp28SwHzJayhwm\nkTHQ7ZkMtgdB4kSYjmvq71lTMNN0Mb9Eyjh+UX03GvV7Xq0Ypt5BiqsaYhlkiNxG\nZhPX/MILVHaZmk8czYfu05eO/H/MBsqEANiLG5LzxTr8qxmnXDleOwuAmf2lT6fC\nvzq9cUYLi6a/wttE8z7+1hWeV3ZtybgVccIj4EJw/gPwsz3thj0Gst5rcZv266+9\ne51VFkETpdS09qLeYuxALmTRLk9lerHhndGJ4JsUBC7IgqrJuOh5VegQaJwXHTyH\niPhP2/E+8MZV7saoEHCxVKZtyBOFry9FNPVCKVFswV2OnMbZzTm/ILpNq88NdqZC\n9zFY1Nlftt4Em6K5+X+JDOb7FYSWm225lRG1ikbU1yOfDtOW38mELt0SGYbH7gcR\nTIuQbFKS+FuWrJEmGQsWKwXDfEGVCuL0CWgacpws5QVipC40hIggkK8+EVWaAsZT\n2oqvIhUosJ3qCmtdNBY34vteB+IIcgGt0Kzb/6h6Fm4INOEWNVYx/ADlQvSpYhp0\nozQUpiVAbUf4/DWhPcD7JR70lIGBOj+6Oo+bAzE3H+1UNc0swRs=\n=/Rvc\n-----END PGP SIGNATURE-----", "payload": "tree 977f9a1bd7bc5c0e8efc36b3a23c911c64189cc3\nparent 6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c\nauthor Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1679359612 +0100\ncommitter Le\u00f3n Orell Valerian Liehr <me@fmease.dev> 1683212350 +0200\n\nIAT: Introduce AliasKind::Inherent\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8139dfd5a747842a8303f33d8c842378913d594", "html_url": "https://github.com/rust-lang/rust/commit/e8139dfd5a747842a8303f33d8c842378913d594", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8139dfd5a747842a8303f33d8c842378913d594/comments", "author": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fmease", "id": 14913065, "node_id": "MDQ6VXNlcjE0OTEzMDY1", "avatar_url": "https://avatars.githubusercontent.com/u/14913065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fmease", "html_url": "https://github.com/fmease", "followers_url": "https://api.github.com/users/fmease/followers", "following_url": "https://api.github.com/users/fmease/following{/other_user}", "gists_url": "https://api.github.com/users/fmease/gists{/gist_id}", "starred_url": "https://api.github.com/users/fmease/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fmease/subscriptions", "organizations_url": "https://api.github.com/users/fmease/orgs", "repos_url": "https://api.github.com/users/fmease/repos", "events_url": "https://api.github.com/users/fmease/events{/privacy}", "received_events_url": "https://api.github.com/users/fmease/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c", "html_url": "https://github.com/rust-lang/rust/commit/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c"}], "stats": {"total": 1175, "additions": 1008, "deletions": 167}, "files": [{"sha": "e50e4800621fcd4e1abccc7472314ad9466ca1b8", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 35, "deletions": 26, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -2378,6 +2378,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             return Ok(None);\n         }\n \n+        //\n+        // Select applicable inherent associated type candidates modulo regions.\n+        //\n+\n         // In contexts that have no inference context, just make a new one.\n         // We do need a local variable to store it, though.\n         let infcx_;\n@@ -2390,14 +2394,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n         };\n \n-        let param_env = tcx.param_env(block.owner.to_def_id());\n+        // FIXME(inherent_associated_types): Acquiring the ParamEnv this early leads to cycle errors\n+        // when inside of an ADT (#108491) or where clause.\n+        let param_env = tcx.param_env(block.owner);\n         let cause = ObligationCause::misc(span, block.owner.def_id);\n \n         let mut fulfillment_errors = Vec::new();\n         let mut applicable_candidates: Vec<_> = infcx.probe(|_| {\n             let universe = infcx.create_next_universe();\n \n             // Regions are not considered during selection.\n+            // FIXME(non_lifetime_binders): Here we are \"truncating\" or \"flattening\" the universes\n+            // of type and const binders. Is that correct in the selection phase? See also #109505.\n             let self_ty = tcx.replace_escaping_bound_vars_uncached(\n                 self_ty,\n                 FnMutDelegate {\n@@ -2413,41 +2421,40 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             candidates\n                 .iter()\n-                .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                .copied()\n+                .filter(|&(impl_, _)| {\n                     infcx.probe(|_| {\n                         let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n \n-                        let impl_ty = tcx.type_of(impl_);\n                         let impl_substs = infcx.fresh_item_substs(impl_);\n-                        let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                        let impl_ty = tcx.type_of(impl_).subst(tcx, impl_substs);\n                         let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n \n-                        // Check that the Self-types can be related.\n-                        // FIXME(fmease): Should we use `eq` here?\n-                        ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+                        // Check that the self types can be related.\n+                        // FIXME(inherent_associated_types): Should we use `eq` here? Method probing uses\n+                        // `sup` for this situtation, too. What for? To constrain inference variables?\n+                        if ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).is_err()\n+                        {\n+                            return false;\n+                        }\n \n                         // Check whether the impl imposes obligations we have to worry about.\n-                        let impl_bounds = tcx.predicates_of(impl_);\n-                        let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n-\n+                        let impl_bounds = tcx.predicates_of(impl_).instantiate(tcx, impl_substs);\n                         let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n-\n                         let impl_obligations = traits::predicates_for_generics(\n                             |_, _| cause.clone(),\n                             param_env,\n                             impl_bounds,\n                         );\n-\n                         ocx.register_obligations(impl_obligations);\n \n                         let mut errors = ocx.select_where_possible();\n                         if !errors.is_empty() {\n                             fulfillment_errors.append(&mut errors);\n-                            return None;\n+                            return false;\n                         }\n \n-                        // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n-                        Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                        true\n                     })\n                 })\n                 .collect()\n@@ -2456,24 +2463,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if applicable_candidates.len() > 1 {\n             return Err(self.complain_about_ambiguous_inherent_assoc_type(\n                 name,\n-                applicable_candidates.into_iter().map(|(candidate, ..)| candidate).collect(),\n+                applicable_candidates.into_iter().map(|(_, (candidate, _))| candidate).collect(),\n                 span,\n             ));\n         }\n \n-        if let Some((assoc_item, def_scope, impl_substs)) = applicable_candidates.pop() {\n+        if let Some((impl_, (assoc_item, def_scope))) = applicable_candidates.pop() {\n             self.check_assoc_ty(assoc_item, name, def_scope, block, span);\n \n-            // FIXME(inherent_associated_types): To fully *confirm* the *probed* candidate, we still\n-            // need to relate the Self-type with fresh item substs & register region obligations for\n-            // regionck to prove/disprove.\n-\n-            let item_substs =\n-                self.create_substs_for_associated_item(span, assoc_item, segment, impl_substs);\n+            // FIXME(fmease): Currently creating throwaway `parent_substs` to please\n+            // `create_substs_for_associated_item`. Modify the latter instead (or sth. similar) to\n+            // not require the parent substs logic.\n+            let parent_substs = InternalSubsts::identity_for_item(tcx, impl_);\n+            let substs =\n+                self.create_substs_for_associated_item(span, assoc_item, segment, parent_substs);\n+            let substs = tcx.mk_substs_from_iter(\n+                std::iter::once(ty::GenericArg::from(self_ty))\n+                    .chain(substs.into_iter().skip(parent_substs.len())),\n+            );\n \n-            // FIXME(fmease, #106722): Check if the bounds on the parameters of the\n-            // associated type hold, if any.\n-            let ty = tcx.type_of(assoc_item).subst(tcx, item_substs);\n+            let ty = tcx.mk_alias(ty::Inherent, tcx.mk_alias_ty(assoc_item, substs));\n \n             return Ok(Some((ty, assoc_item)));\n         }"}, {"sha": "272177dfbd0f858ea5bc562e4ad6bda2d2255cd0", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -210,6 +210,19 @@ fn do_orphan_check_impl<'tcx>(\n                 NonlocalImpl::DisallowOther,\n             ),\n \n+            // ```\n+            // struct S<T>(T);\n+            // impl<T: ?Sized> S<T> {\n+            //     type This = T;\n+            // }\n+            // impl<T: ?Sized> AutoTrait for S<T>::This {}\n+            // ```\n+            // FIXME(inherent_associated_types): The example code above currently leads to a cycle\n+            ty::Alias(AliasKind::Inherent, _) => (\n+                LocalImpl::Disallow { problematic_kind: \"associated type\" },\n+                NonlocalImpl::DisallowOther,\n+            ),\n+\n             // type Opaque = impl Trait;\n             // impl AutoTrait for Opaque {}\n             ty::Alias(AliasKind::Opaque, _) => ("}, {"sha": "cb80e5b1350865225f05b9280735e940bf1bf96e", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1938,7 +1938,7 @@ fn is_late_bound_map(\n                 ty::Param(param_ty) => {\n                     self.arg_is_constrained[param_ty.index as usize] = true;\n                 }\n-                ty::Alias(ty::Projection, _) => return ControlFlow::Continue(()),\n+                ty::Alias(ty::Projection | ty::Inherent, _) => return ControlFlow::Continue(()),\n                 _ => (),\n             }\n             t.super_visit_with(self)"}, {"sha": "8df0166f76b4b269c8f97d2760f914b927423eef", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -127,7 +127,7 @@ fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n             // the def_id that this query was called with. We filter to only type and const args here\n             // as a precaution for if it's ever allowed to elide lifetimes in GAT's. It currently isn't\n             // but it can't hurt to be safe ^^\n-            if let ty::Alias(ty::Projection, projection) = ty.kind() {\n+            if let ty::Alias(ty::Projection | ty::Inherent, projection) = ty.kind() {\n                 let generics = tcx.generics_of(projection.def_id);\n \n                 let arg_index = segment"}, {"sha": "9200c2aecf55c07699e9bcdf1f289ea64d2d6977", "filename": "compiler/rustc_hir_analysis/src/constrained_generic_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fconstrained_generic_params.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -59,7 +59,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n-            ty::Alias(ty::Projection, ..) if !self.include_nonconstraining => {\n+            ty::Alias(ty::Projection | ty::Inherent, ..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return ControlFlow::Continue(());\n             }"}, {"sha": "0cd2fc1aa299a4dc3f8a5b532de37fdaebca84e5", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -210,6 +210,9 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 );\n             }\n \n+            // FIXME(inherent_associated_types): Handle this case properly.\n+            ty::Alias(ty::Inherent, _) => {}\n+\n             _ => {}\n         }\n     }"}, {"sha": "05e5d850bf958cc6471a15ed5ff489abdbbe0a09", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -843,7 +843,7 @@ fn find_param_in_ty<'tcx>(\n             return true;\n         }\n         if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                && let ty::Alias(ty::Projection, ..) = ty.kind()\n+                && let ty::Alias(ty::Projection | ty::Inherent, ..) = ty.kind()\n             {\n                 // This logic may seem a bit strange, but typically when\n                 // we have a projection type in a function signature, the"}, {"sha": "67f45f9aa3f0dd64977c8bdd10ab4d142ab76bde", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         match ty.kind() {\n             ty::Adt(adt_def, _) => Some(*adt_def),\n             // FIXME(#104767): Should we handle bound regions here?\n-            ty::Alias(ty::Projection, _) if !ty.has_escaping_bound_vars() => {\n+            ty::Alias(ty::Projection | ty::Inherent, _) if !ty.has_escaping_bound_vars() => {\n                 self.normalize(span, ty).ty_adt_def()\n             }\n             _ => None,"}, {"sha": "3741672e5683c3e906f658d0819f3da82a094768", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -2211,7 +2211,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         | ty::Float(_)\n                         | ty::Adt(_, _)\n                         | ty::Str\n-                        | ty::Alias(ty::Projection, _)\n+                        | ty::Alias(ty::Projection | ty::Inherent, _)\n                         | ty::Param(_) => format!(\"{deref_ty}\"),\n                         // we need to test something like  <&[_]>::len or <(&[u32])>::len\n                         // and Vec::function();"}, {"sha": "44c8b08196e521e0c582e6a4b89c543cb60e8e55", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -125,7 +125,8 @@ impl<'tcx> InferCtxt<'tcx> {\n                 bug!()\n             }\n \n-            (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n+            (_, ty::Alias(AliasKind::Projection | AliasKind::Inherent, _))\n+            | (ty::Alias(AliasKind::Projection | AliasKind::Inherent, _), _)\n                 if self.tcx.trait_solver_next() =>\n             {\n                 relation.register_type_relate_obligation(a, b);"}, {"sha": "ce70f39cc4014d66aae79c447b747a06e9732761", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -2354,7 +2354,9 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),\n             GenericKind::Alias(ref p) => match p.kind(self.tcx) {\n-                ty::AliasKind::Projection => format!(\"the associated type `{}`\", p),\n+                ty::AliasKind::Projection | ty::AliasKind::Inherent => {\n+                    format!(\"the associated type `{}`\", p)\n+                }\n                 ty::AliasKind::Opaque => format!(\"the opaque type `{}`\", p),\n             },\n         };"}, {"sha": "064811bd29d77a25aade79585d08a67122adb6f9", "filename": "compiler/rustc_infer/src/infer/error_reporting/note_and_explain.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote_and_explain.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -71,9 +71,10 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                              #traits-as-parameters\",\n                         );\n                     }\n-                    (ty::Alias(ty::Projection, _), ty::Alias(ty::Projection, _)) => {\n+                    (ty::Alias(ty::Projection | ty::Inherent, _), ty::Alias(ty::Projection | ty::Inherent, _)) => {\n                         diag.note(\"an associated type was expected, but a different one was found\");\n                     }\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     (ty::Param(p), ty::Alias(ty::Projection, proj)) | (ty::Alias(ty::Projection, proj), ty::Param(p))\n                         if !tcx.is_impl_trait_in_trait(proj.def_id) =>\n                     {\n@@ -222,7 +223,7 @@ impl<T> Trait<T> for X {\n                             diag.span_label(p_span, \"this type parameter\");\n                         }\n                     }\n-                    (ty::Alias(ty::Projection, proj_ty), _) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n+                    (ty::Alias(ty::Projection | ty::Inherent, proj_ty), _) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n                         self.expected_projection(\n                             diag,\n                             proj_ty,\n@@ -231,7 +232,7 @@ impl<T> Trait<T> for X {\n                             cause.code(),\n                         );\n                     }\n-                    (_, ty::Alias(ty::Projection, proj_ty)) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n+                    (_, ty::Alias(ty::Projection | ty::Inherent, proj_ty)) if !tcx.is_impl_trait_in_trait(proj_ty.def_id) => {\n                         let msg = format!(\n                             \"consider constraining the associated type `{}` to `{}`\",\n                             values.found, values.expected,"}, {"sha": "362b22b23a8dad81e64d37cb4bad130696df32fe", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -549,6 +549,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // We can't normalize associated types from `rustc_infer`,\n                     // but we can eagerly register inference variables for them.\n                     // FIXME(RPITIT): Don't replace RPITITs with inference vars.\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n                             && !tcx.is_impl_trait_in_trait(projection_ty.def_id) =>\n@@ -569,6 +570,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                         hidden_ty\n                     }\n                     // FIXME(RPITIT): This can go away when we move to associated types\n+                    // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(\n                         ty::Projection,\n                         ty::AliasTy { def_id: def_id2, substs: substs2, .. },"}, {"sha": "08c02e1c253cb7fe56f894b89fd330e92ebfb769", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -62,6 +62,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::TypeVisitableExt;\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, VariantDef};\n use rustc_session::lint::{BuiltinLintDiagnostics, FutureIncompatibilityReason};\n use rustc_span::edition::Edition;\n@@ -1461,6 +1462,10 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n             // Bounds are respected for `type X = impl Trait`\n             return;\n         }\n+        if cx.tcx.type_of(item.owner_id).skip_binder().has_inherent_projections() {\n+            // Bounds are respected for `type X = \u2026 Type::Inherent \u2026`\n+            return;\n+        }\n         // There must not be a where clause\n         if type_alias_generics.predicates.is_empty() {\n             return;\n@@ -1580,7 +1585,6 @@ declare_lint_pass!(\n \n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        use rustc_middle::ty::visit::TypeVisitableExt;\n         use rustc_middle::ty::Clause;\n         use rustc_middle::ty::PredicateKind::*;\n \n@@ -2917,6 +2921,7 @@ impl ClashingExternDeclarations {\n                         | (Generator(..), Generator(..))\n                         | (GeneratorWitness(..), GeneratorWitness(..))\n                         | (Alias(ty::Projection, ..), Alias(ty::Projection, ..))\n+                        | (Alias(ty::Inherent, ..), Alias(ty::Inherent, ..))\n                         | (Alias(ty::Opaque, ..), Alias(ty::Opaque, ..)) => false,\n \n                         // These definitely should have been caught above."}, {"sha": "125b4dc5503100548be60daa014cd00d05560fb5", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1119,14 +1119,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Alias(ty::Projection, ..)\n+            ty::Param(..) | ty::Alias(ty::Projection | ty::Inherent, ..)\n                 if matches!(self.mode, CItemKind::Definition) =>\n             {\n                 FfiSafe\n             }\n \n             ty::Param(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Infer(..)\n             | ty::Bound(..)\n             | ty::Error(_)"}, {"sha": "ab73832ae68a603fb07dee9ffc7e106f7928e60f", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1821,6 +1821,16 @@ rustc_queries! {\n         desc { \"normalizing `{}`\", goal.value.value }\n     }\n \n+    /// Do not call this query directly: invoke `normalize` instead.\n+    query normalize_inherent_projection_ty(\n+        goal: CanonicalProjectionGoal<'tcx>\n+    ) -> Result<\n+        &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, NormalizationResult<'tcx>>>,\n+        NoSolution,\n+    > {\n+        desc { \"normalizing `{}`\", goal.value.value }\n+    }\n+\n     /// Do not call this query directly: invoke `try_normalize_erasing_regions` instead.\n     query try_normalize_generic_arg_after_erasing_regions(\n         goal: ParamEnvAnd<'tcx, GenericArg<'tcx>>"}, {"sha": "212720f3b694f716d48a31469d5059e5771f843e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1846,7 +1846,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         let substs = substs.into_iter().map(Into::into);\n         #[cfg(debug_assertions)]\n         {\n-            let n = self.generics_of(_def_id).count();\n+            let generics = self.generics_of(_def_id);\n+\n+            let n = if let DefKind::AssocTy = self.def_kind(_def_id)\n+                && let DefKind::Impl { of_trait: false } = self.def_kind(self.parent(_def_id))\n+            {\n+                // If this is an inherent projection.\n+\n+                generics.params.len() + 1\n+            } else {\n+                generics.count()\n+            };\n             assert_eq!(\n                 (n, Some(n)),\n                 substs.size_hint(),\n@@ -2007,7 +2017,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         debug_assert_matches!(\n             (kind, self.def_kind(alias_ty.def_id)),\n             (ty::Opaque, DefKind::OpaqueTy)\n-                | (ty::Projection, DefKind::AssocTy)\n+                | (ty::Projection | ty::Inherent, DefKind::AssocTy)\n                 | (ty::Opaque | ty::Projection, DefKind::ImplTraitPlaceholder)\n         );\n         self.mk_ty_from_kind(Alias(kind, alias_ty))"}, {"sha": "49ab9b79e96f32de0dbf5799d9a35f4a56d3d44d", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -265,7 +265,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Infer(ty::FreshTy(_)) => \"fresh type\".into(),\n             ty::Infer(ty::FreshIntTy(_)) => \"fresh integral type\".into(),\n             ty::Infer(ty::FreshFloatTy(_)) => \"fresh floating-point type\".into(),\n-            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n+            ty::Alias(ty::Projection | ty::Inherent, _) => \"associated type\".into(),\n             ty::Param(p) => format!(\"type parameter `{p}`\").into(),\n             ty::Alias(ty::Opaque, ..) => if tcx.ty_is_opaque_future(self) { \"future\".into() } else { \"opaque type\".into() },\n             ty::Error(_) => \"type error\".into(),\n@@ -312,7 +312,7 @@ impl<'tcx> Ty<'tcx> {\n             ty::Tuple(..) => \"tuple\".into(),\n             ty::Placeholder(..) => \"higher-ranked type\".into(),\n             ty::Bound(..) => \"bound type variable\".into(),\n-            ty::Alias(ty::Projection, _) => \"associated type\".into(),\n+            ty::Alias(ty::Projection | ty::Inherent, _) => \"associated type\".into(),\n             ty::Param(_) => \"type parameter\".into(),\n             ty::Alias(ty::Opaque, ..) => \"opaque type\".into(),\n         }"}, {"sha": "d64875a9f00e8cc08cae1abf9cd1a3829836ecb7", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -176,14 +176,14 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Alias(ty::Projection, data) => {\n-                self.add_flags(TypeFlags::HAS_TY_PROJECTION);\n-                self.add_alias_ty(data);\n-            }\n+            &ty::Alias(kind, data) => {\n+                self.add_flags(match kind {\n+                    ty::Projection => TypeFlags::HAS_TY_PROJECTION,\n+                    ty::Inherent => TypeFlags::HAS_TY_INHERENT,\n+                    ty::Opaque => TypeFlags::HAS_TY_OPAQUE,\n+                });\n \n-            &ty::Alias(ty::Opaque, ty::AliasTy { substs, .. }) => {\n-                self.add_flags(TypeFlags::HAS_TY_OPAQUE);\n-                self.add_substs(substs);\n+                self.add_alias_ty(data);\n             }\n \n             &ty::Dynamic(obj, r, _) => {"}, {"sha": "9e672004cf9c0e6dc8d5fbe7598a2643c7831434", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -113,6 +113,12 @@ impl<'tcx> Ty<'tcx> {\n             }\n             Never => InhabitedPredicate::False,\n             Param(_) | Alias(ty::Projection, _) => InhabitedPredicate::GenericType(self),\n+            // FIXME(inherent_associated_types): Most likely we can just map to `GenericType` like above.\n+            // However it's unclear if the substs passed to `InhabitedPredicate::subst` are of the correct\n+            // format, i.e. don't contain parent substs. If you hit this case, please verify this beforehand.\n+            Alias(ty::Inherent, _) => {\n+                bug!(\"unimplemented: inhabitedness checking for inherent projections\")\n+            }\n             Tuple(tys) if tys.is_empty() => InhabitedPredicate::True,\n             // use a query for more complex cases\n             Adt(..) | Array(..) | Tuple(_) => tcx.inhabited_predicate_type(self),"}, {"sha": "47cf48f46cf891fbff7c6493190295f94638ad66", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -324,7 +324,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let non_zero = !ty.is_unsafe_ptr();\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n-                    ty::Param(_) | ty::Alias(ty::Projection, _) => {\n+                    ty::Param(_) | ty::Alias(ty::Projection | ty::Inherent, _) => {\n                         debug_assert!(tail.has_non_region_param());\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }"}, {"sha": "9fc0110b354f419b19e5a78b28e735c7f046b0c7", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1004,7 +1004,7 @@ impl<'tcx> Term<'tcx> {\n         match self.unpack() {\n             TermKind::Ty(ty) => match ty.kind() {\n                 ty::Alias(kind, alias_ty) => match kind {\n-                    AliasKind::Projection => Some(*alias_ty),\n+                    AliasKind::Projection | AliasKind::Inherent => Some(*alias_ty),\n                     AliasKind::Opaque => None,\n                 },\n                 _ => None,"}, {"sha": "8a4d3820d7bc7242efb1f40c1e609a73162907a0", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -729,7 +729,7 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Foreign(def_id) => {\n                 p!(print_def_path(def_id, &[]));\n             }\n-            ty::Alias(ty::Projection, ref data) => {\n+            ty::Alias(ty::Projection | ty::Inherent, ref data) => {\n                 if !(self.should_print_verbose() || NO_QUERIES.with(|q| q.get()))\n                     && self.tcx().is_impl_trait_in_trait(data.def_id)\n                 {"}, {"sha": "da43475941ee5a309780d63a02e38febb36ec9bc", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -550,6 +550,11 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n             Ok(tcx.mk_projection(projection_ty.def_id, projection_ty.substs))\n         }\n \n+        (&ty::Alias(ty::Inherent, a_data), &ty::Alias(ty::Inherent, b_data)) => {\n+            let alias_ty = relation.relate(a_data, b_data)?;\n+            Ok(tcx.mk_alias(ty::Inherent, tcx.mk_alias_ty(alias_ty.def_id, alias_ty.substs)))\n+        }\n+\n         (\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, substs: a_substs, .. }),\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, substs: b_substs, .. }),"}, {"sha": "8d0737e1eeeeb979b95e4ff4fb1ca194c6984f81", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1190,9 +1190,9 @@ where\n \n /// Represents the projection of an associated type.\n ///\n-/// For a projection, this would be `<Ty as Trait<...>>::N`.\n-///\n-/// For an opaque type, there is no explicit syntax.\n+/// * For a projection, this would be `<Ty as Trait<...>>::N<...>`.\n+/// * For an inherent projection, this would be `Ty::N<...>`.\n+/// * For an opaque type, there is no explicit syntax.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct AliasTy<'tcx> {\n@@ -1201,12 +1201,16 @@ pub struct AliasTy<'tcx> {\n     /// For a projection, these are the substitutions for the trait and the\n     /// GAT substitutions, if there are any.\n     ///\n+    /// For an inherent projection, they consist of the self type and the GAT substitutions,\n+    /// if there are any.\n+    ///\n     /// For RPIT the substitutions are for the generics of the function,\n     /// while for TAIT it is used for the generic parameters of the alias.\n     pub substs: SubstsRef<'tcx>,\n \n-    /// The `DefId` of the `TraitItem` for the associated type `N` if this is a projection,\n-    /// or the `OpaqueType` item if this is an opaque.\n+    /// The `DefId` of the `TraitItem` or `ImplItem` for the associated type `N` depending on whether\n+    /// this is a projection or an inherent projection or the `DefId` of the `OpaqueType` item if\n+    /// this is an opaque.\n     ///\n     /// During codegen, `tcx.type_of(def_id)` can be used to get the type of the\n     /// underlying type if the type is an opaque.\n@@ -1224,6 +1228,7 @@ pub struct AliasTy<'tcx> {\n impl<'tcx> AliasTy<'tcx> {\n     pub fn kind(self, tcx: TyCtxt<'tcx>) -> ty::AliasKind {\n         match tcx.def_kind(self.def_id) {\n+            DefKind::AssocTy if let DefKind::Impl { of_trait: false } = tcx.def_kind(tcx.parent(self.def_id)) => ty::Inherent,\n             DefKind::AssocTy | DefKind::ImplTraitPlaceholder => ty::Projection,\n             DefKind::OpaqueTy => ty::Opaque,\n             kind => bug!(\"unexpected DefKind in AliasTy: {kind:?}\"),\n@@ -1236,6 +1241,17 @@ impl<'tcx> AliasTy<'tcx> {\n }\n \n /// The following methods work only with associated type projections.\n+impl<'tcx> AliasTy<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n+        self.substs.type_at(0)\n+    }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+    }\n+}\n+\n+/// The following methods work only with trait associated type projections.\n impl<'tcx> AliasTy<'tcx> {\n     pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n         match tcx.def_kind(self.def_id) {\n@@ -1274,13 +1290,28 @@ impl<'tcx> AliasTy<'tcx> {\n         let def_id = self.trait_def_id(tcx);\n         ty::TraitRef::new(tcx, def_id, self.substs.truncate_to(tcx, tcx.generics_of(def_id)))\n     }\n+}\n \n-    pub fn self_ty(self) -> Ty<'tcx> {\n-        self.substs.type_at(0)\n-    }\n+/// The following methods work only with inherent associated type projections.\n+impl<'tcx> AliasTy<'tcx> {\n+    /// Transform the substitutions to have the given `impl` substs as the base and the GAT substs on top of that.\n+    ///\n+    /// Does the following transformation:\n+    ///\n+    /// ```text\n+    /// [Self, P_0...P_m] -> [I_0...I_n, P_0...P_m]\n+    ///\n+    ///     I_i impl subst\n+    ///     P_j GAT subst\n+    /// ```\n+    pub fn rebase_substs_onto_impl(\n+        self,\n+        impl_substs: ty::SubstsRef<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> ty::SubstsRef<'tcx> {\n+        debug_assert_eq!(self.kind(tcx), ty::Inherent);\n \n-    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n-        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+        tcx.mk_substs_from_iter(impl_substs.into_iter().chain(self.substs.into_iter().skip(1)))\n     }\n }\n "}, {"sha": "520bb55e031c70f366f8e6029eb37cc84c86b421", "filename": "compiler/rustc_middle/src/ty/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvisit.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -49,6 +49,9 @@ pub trait TypeVisitableExt<'tcx>: TypeVisitable<TyCtxt<'tcx>> {\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n     }\n+    fn has_inherent_projections(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_INHERENT)\n+    }\n     fn has_opaque_types(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n     }"}, {"sha": "d6eb5463870effcdc23efddef75926bd5fb1cc87", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -243,6 +243,39 @@ where\n                 // This will also visit substs if necessary, so we don't need to recurse.\n                 return self.visit_projection_ty(proj);\n             }\n+            ty::Alias(ty::Inherent, data) => {\n+                if self.def_id_visitor.skip_assoc_tys() {\n+                    // Visitors searching for minimal visibility/reachability want to\n+                    // conservatively approximate associated types like `Type::Alias`\n+                    // as visible/reachable even if `Type` is private.\n+                    // Ideally, associated types should be substituted in the same way as\n+                    // free type aliases, but this isn't done yet.\n+                    return ControlFlow::Continue(());\n+                }\n+\n+                self.def_id_visitor.visit_def_id(\n+                    data.def_id,\n+                    \"associated type\",\n+                    &LazyDefPathStr { def_id: data.def_id, tcx },\n+                )?;\n+\n+                struct LazyDefPathStr<'tcx> {\n+                    def_id: DefId,\n+                    tcx: TyCtxt<'tcx>,\n+                }\n+                impl<'tcx> fmt::Display for LazyDefPathStr<'tcx> {\n+                    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                        write!(f, \"{}\", self.tcx.def_path_str(self.def_id))\n+                    }\n+                }\n+\n+                // This will also visit substs if necessary, so we don't need to recurse.\n+                return if self.def_id_visitor.shallow() {\n+                    ControlFlow::Continue(())\n+                } else {\n+                    data.substs.iter().try_for_each(|subst| subst.visit_with(self))\n+                };\n+            }\n             ty::Dynamic(predicates, ..) => {\n                 // All traits in the list are considered the \"primary\" part of the type\n                 // and are visited by shallow visitors."}, {"sha": "8fea3fc140d7296d6bb352a33d9bd11e6d3e530f", "filename": "compiler/rustc_trait_selection/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fmessages.ftl?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -20,3 +20,5 @@ trait_selection_negative_positive_conflict = found both positive and negative im\n     .negative_implementation_in_crate = negative implementation in crate `{$negative_impl_cname}`\n     .positive_implementation_here = positive implementation here\n     .positive_implementation_in_crate = positive implementation in crate `{$positive_impl_cname}`\n+\n+trait_selection_inherent_projection_normalization_overflow = overflow evaluating associated type `{$ty}`"}, {"sha": "54e22cc3d7fe28635e2bf4115bd8f204fca2ac01", "filename": "compiler/rustc_trait_selection/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ferrors.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -89,3 +89,11 @@ impl IntoDiagnostic<'_> for NegativePositiveConflict<'_> {\n         diag\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(trait_selection_inherent_projection_normalization_overflow)]\n+pub struct InherentProjectionNormalizationOverflow {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: String,\n+}"}, {"sha": "0ede32c753c6924ba22fa60e9d82c7a2d33abb47", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -33,7 +33,7 @@ pub(in crate::solve) fn instantiate_constituent_tys_for_auto_trait<'tcx>(\n         ty::Dynamic(..)\n         | ty::Param(..)\n         | ty::Foreign(..)\n-        | ty::Alias(ty::Projection, ..)\n+        | ty::Alias(ty::Projection | ty::Inherent, ..)\n         | ty::Placeholder(..)\n         | ty::Bound(..)\n         | ty::Infer(_) => {"}, {"sha": "04b38edc1265fc783b1a6133623fef0b1a98d334", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -655,7 +655,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Placeholder(..) => Some(Err(NoSolution)),\n \n             ty::Infer(_) | ty::Bound(_, _) => bug!(\"unexpected type `{self_ty}`\"),"}, {"sha": "402b09419c87784070d12d205b309c054526832f", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -673,7 +673,7 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for OrphanChecker<'tcx> {\n             | ty::RawPtr(..)\n             | ty::Never\n             | ty::Tuple(..)\n-            | ty::Alias(ty::Projection, ..) => self.found_non_local_ty(ty),\n+            | ty::Alias(ty::Projection | ty::Inherent, ..) => self.found_non_local_ty(ty),\n \n             ty::Param(..) => self.found_param_ty(ty),\n "}, {"sha": "3884153202eb7a7a2702d27d64b9eb6f6c959f30", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1686,13 +1686,14 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 ty::Tuple(..) => Some(10),\n                 ty::Param(..) => Some(11),\n                 ty::Alias(ty::Projection, ..) => Some(12),\n-                ty::Alias(ty::Opaque, ..) => Some(13),\n-                ty::Never => Some(14),\n-                ty::Adt(..) => Some(15),\n-                ty::Generator(..) => Some(16),\n-                ty::Foreign(..) => Some(17),\n-                ty::GeneratorWitness(..) => Some(18),\n-                ty::GeneratorWitnessMIR(..) => Some(19),\n+                ty::Alias(ty::Inherent, ..) => Some(13),\n+                ty::Alias(ty::Opaque, ..) => Some(14),\n+                ty::Never => Some(15),\n+                ty::Adt(..) => Some(16),\n+                ty::Generator(..) => Some(17),\n+                ty::Foreign(..) => Some(18),\n+                ty::GeneratorWitness(..) => Some(19),\n+                ty::GeneratorWitnessMIR(..) => Some(20),\n                 ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error(_) => None,\n             }\n         }"}, {"sha": "5878accd84aabbbd3dc559b8e474925e657e33a1", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -49,7 +49,8 @@ pub use self::object_safety::astconv_object_safety_violations;\n pub use self::object_safety::is_vtable_safe_method;\n pub use self::object_safety::MethodViolationCode;\n pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::project::{normalize_projection_type, NormalizeExt};\n+pub use self::project::NormalizeExt;\n+pub use self::project::{normalize_inherent_projection, normalize_projection_type};\n pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;"}, {"sha": "852780fccace9ee6c63d556be602e424944e310c", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 141, "deletions": 2, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -16,6 +16,7 @@ use super::{\n };\n use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n \n+use crate::errors::InherentProjectionNormalizationOverflow;\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::traits::error_reporting::TypeErrCtxtExt as _;\n@@ -370,10 +371,14 @@ pub(crate) fn needs_normalization<'tcx, T: TypeVisitable<TyCtxt<'tcx>>>(\n     reveal: Reveal,\n ) -> bool {\n     match reveal {\n-        Reveal::UserFacing => value\n-            .has_type_flags(ty::TypeFlags::HAS_TY_PROJECTION | ty::TypeFlags::HAS_CT_PROJECTION),\n+        Reveal::UserFacing => value.has_type_flags(\n+            ty::TypeFlags::HAS_TY_PROJECTION\n+                | ty::TypeFlags::HAS_TY_INHERENT\n+                | ty::TypeFlags::HAS_CT_PROJECTION,\n+        ),\n         Reveal::All => value.has_type_flags(\n             ty::TypeFlags::HAS_TY_PROJECTION\n+                | ty::TypeFlags::HAS_TY_INHERENT\n                 | ty::TypeFlags::HAS_TY_OPAQUE\n                 | ty::TypeFlags::HAS_CT_PROJECTION,\n         ),\n@@ -616,6 +621,51 @@ impl<'a, 'b, 'tcx> TypeFolder<TyCtxt<'tcx>> for AssocTypeNormalizer<'a, 'b, 'tcx\n                 );\n                 normalized_ty\n             }\n+\n+            ty::Inherent if !data.has_escaping_bound_vars() => {\n+                // This branch is *mostly* just an optimization: when we don't\n+                // have escaping bound vars, we don't need to replace them with\n+                // placeholders (see branch below). *Also*, we know that we can\n+                // register an obligation to *later* project, since we know\n+                // there won't be bound vars there.\n+\n+                let data = data.fold_with(self);\n+\n+                // FIXME(inherent_associated_types): Do we need to honor `self.eager_inference_replacement`\n+                // here like `ty::Projection`?\n+                normalize_inherent_projection(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                )\n+            }\n+\n+            ty::Inherent => {\n+                let infcx = self.selcx.infcx;\n+                let (data, mapped_regions, mapped_types, mapped_consts) =\n+                    BoundVarReplacer::replace_bound_vars(infcx, &mut self.universes, data);\n+                let data = data.fold_with(self);\n+                let ty = normalize_inherent_projection(\n+                    self.selcx,\n+                    self.param_env,\n+                    data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                );\n+\n+                PlaceholderReplacer::replace_placeholders(\n+                    infcx,\n+                    mapped_regions,\n+                    mapped_types,\n+                    mapped_consts,\n+                    &self.universes,\n+                    ty,\n+                )\n+            }\n         }\n     }\n \n@@ -1204,6 +1254,95 @@ fn normalize_to_error<'a, 'tcx>(\n     Normalized { value: new_value, obligations: vec![trait_obligation] }\n }\n \n+/// Confirm and normalize the given inherent projection.\n+#[instrument(level = \"debug\", skip(selcx, param_env, cause, obligations))]\n+pub fn normalize_inherent_projection<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    alias_ty: ty::AliasTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Ty<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    if !tcx.recursion_limit().value_within_limit(depth) {\n+        // Halt compilation because it is important that overflows never be masked.\n+        tcx.sess.emit_fatal(InherentProjectionNormalizationOverflow {\n+            span: cause.span,\n+            ty: alias_ty.to_string(),\n+        });\n+    }\n+\n+    let impl_def_id = tcx.parent(alias_ty.def_id);\n+    let impl_substs = selcx.infcx.fresh_substs_for_item(cause.span, impl_def_id);\n+\n+    let impl_ty = tcx.type_of(impl_def_id).subst(tcx, impl_substs);\n+    let impl_ty =\n+        normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, impl_ty, obligations);\n+\n+    // Infer the generic parameters of the impl by unifying the\n+    // impl type with the self type of the projection.\n+    let self_ty = alias_ty.self_ty();\n+    match selcx.infcx.at(&cause, param_env).eq(DefineOpaqueTypes::No, impl_ty, self_ty) {\n+        Ok(mut ok) => obligations.append(&mut ok.obligations),\n+        Err(_) => {\n+            tcx.sess.delay_span_bug(\n+                cause.span,\n+                format!(\n+                    \"{self_ty:?} was a subtype of {impl_ty:?} during selection but now it is not\"\n+                ),\n+            );\n+        }\n+    }\n+\n+    let substs = alias_ty.rebase_substs_onto_impl(impl_substs, tcx);\n+\n+    // Register the obligations arising from the impl and from the associated type itself.\n+    let predicates = tcx.predicates_of(alias_ty.def_id).instantiate(tcx, substs);\n+    for (predicate, span) in predicates {\n+        let predicate = normalize_with_depth_to(\n+            selcx,\n+            param_env,\n+            cause.clone(),\n+            depth + 1,\n+            predicate,\n+            obligations,\n+        );\n+\n+        let nested_cause = ObligationCause::new(\n+            cause.span,\n+            cause.body_id,\n+            // FIXME(inherent_associated_types): Since we can't pass along the self type to the\n+            // cause code, inherent projections will be printed with identity substitutions in\n+            // diagnostics which is not ideal.\n+            // Consider creating separate cause codes for this specific situation.\n+            if span.is_dummy() {\n+                super::ItemObligation(alias_ty.def_id)\n+            } else {\n+                super::BindingObligation(alias_ty.def_id, span)\n+            },\n+        );\n+\n+        obligations.push(Obligation::with_depth(\n+            tcx,\n+            nested_cause,\n+            depth + 1,\n+            param_env,\n+            predicate,\n+        ));\n+    }\n+\n+    let ty = tcx.type_of(alias_ty.def_id).subst(tcx, substs);\n+\n+    let mut ty = selcx.infcx.resolve_vars_if_possible(ty);\n+    if ty.has_projections() {\n+        ty = normalize_with_depth_to(selcx, param_env, cause.clone(), depth + 1, ty, obligations);\n+    }\n+\n+    ty\n+}\n+\n enum Projected<'tcx> {\n     Progress(Progress<'tcx>),\n     NoProgress(ty::Term<'tcx>),"}, {"sha": "8bf934cb78ae1545fdfaa28162541d208ab4d41e", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -257,11 +257,11 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n \n             ty::Opaque => ty.try_super_fold_with(self)?,\n \n-            ty::Projection => {\n+            ty::Projection | ty::Inherent => {\n                 // See note in `rustc_trait_selection::traits::project`\n \n-                let tcx = self.infcx.tcx;\n                 let infcx = self.infcx;\n+                let tcx = infcx.tcx;\n                 // Just an optimization: When we don't have escaping bound vars,\n                 // we don't need to replace them with placeholders.\n                 let (data, maps) = if data.has_escaping_bound_vars() {\n@@ -276,12 +276,15 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                 let mut orig_values = OriginalQueryValues::default();\n                 // HACK(matthewjasper) `'static` is special-cased in selection,\n                 // so we cannot canonicalize it.\n-                let c_data = self\n-                    .infcx\n+                let c_data = infcx\n                     .canonicalize_query_keep_static(self.param_env.and(data), &mut orig_values);\n                 debug!(\"QueryNormalizer: c_data = {:#?}\", c_data);\n                 debug!(\"QueryNormalizer: orig_values = {:#?}\", orig_values);\n-                let result = tcx.normalize_projection_ty(c_data)?;\n+                let result = match kind {\n+                    ty::Projection => tcx.normalize_projection_ty(c_data),\n+                    ty::Inherent => tcx.normalize_inherent_projection_ty(c_data),\n+                    _ => unreachable!(),\n+                }?;\n                 // We don't expect ambiguity.\n                 if result.is_ambiguous() {\n                     // Rustdoc normalizes possibly not well-formed types, so only\n@@ -294,8 +297,8 @@ impl<'cx, 'tcx> FallibleTypeFolder<TyCtxt<'tcx>> for QueryNormalizer<'cx, 'tcx>\n                     }\n                     return Err(NoSolution);\n                 }\n-                let InferOk { value: result, obligations } =\n-                    self.infcx.instantiate_query_response_and_region_obligations(\n+                let InferOk { value: result, obligations } = infcx\n+                    .instantiate_query_response_and_region_obligations(\n                         self.cause,\n                         self.param_env,\n                         &orig_values,"}, {"sha": "a8fb55df2d3029cf04a93a4fb143746e5300f9b9", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -498,7 +498,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // this trait and type.\n                 }\n                 ty::Param(..)\n-                | ty::Alias(ty::Projection, ..)\n+                | ty::Alias(ty::Projection | ty::Inherent, ..)\n                 | ty::Placeholder(..)\n                 | ty::Bound(..) => {\n                     // In these cases, we don't know what the actual"}, {"sha": "616187b69dde4bd89cbb05cd00599f585212cddc", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1268,7 +1268,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // If we have a projection type, make sure to normalize it so we replace it\n                 // with a fresh infer variable\n-                ty::Alias(ty::Projection, ..) => {\n+                ty::Alias(ty::Projection | ty::Inherent, ..) => {\n                     let predicate = normalize_with_depth_to(\n                         self,\n                         obligation.param_env,"}, {"sha": "e4f5a84f4244e1a8a02eefefd5cdd6d70106aa1f", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -2315,7 +2315,7 @@ impl<'tcx> SelectionContext<'_, 'tcx> {\n             | ty::Dynamic(..)\n             | ty::Param(..)\n             | ty::Foreign(..)\n-            | ty::Alias(ty::Projection, ..)\n+            | ty::Alias(ty::Projection | ty::Inherent, ..)\n             | ty::Bound(..)\n             | ty::Infer(ty::TyVar(_) | ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n                 bug!(\"asked to assemble constituent types of unexpected type: {:?}\", t);"}, {"sha": "e5edceda94446e816f5b841aaf8c674d2a4f0368", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -605,6 +605,9 @@ impl<'tcx> WfPredicates<'tcx> {\n                     walker.skip_current_subtree(); // Subtree handled by compute_projection.\n                     self.compute_projection(data);\n                 }\n+                ty::Alias(ty::Inherent, _) => {\n+                    // WF if their substs are WF.\n+                }\n \n                 ty::Adt(def, substs) => {\n                     // WfNominalType"}, {"sha": "2f9e480d8bd529dc1fff1892ba61e3859bf28296", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -372,6 +372,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                     substitution: substs.lower_into(interner),\n                 }))\n             }\n+            ty::Alias(ty::Inherent, _) => unimplemented!(),\n             ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id: chalk_ir::OpaqueTyId(def_id),"}, {"sha": "36d80a06ee7e9edc13c4cf94bfa3fc8f2121f6ca", "filename": "compiler/rustc_traits/src/normalize_projection_ty.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_projection_ty.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -10,7 +10,7 @@ use rustc_trait_selection::traits::{self, ObligationCause, SelectionContext};\n use std::sync::atomic::Ordering;\n \n pub(crate) fn provide(p: &mut Providers) {\n-    *p = Providers { normalize_projection_ty, ..*p };\n+    *p = Providers { normalize_projection_ty, normalize_inherent_projection_ty, ..*p };\n }\n \n fn normalize_projection_ty<'tcx>(\n@@ -42,3 +42,30 @@ fn normalize_projection_ty<'tcx>(\n         },\n     )\n }\n+\n+fn normalize_inherent_projection_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    goal: CanonicalProjectionGoal<'tcx>,\n+) -> Result<&'tcx Canonical<'tcx, QueryResponse<'tcx, NormalizationResult<'tcx>>>, NoSolution> {\n+    debug!(\"normalize_provider(goal={:#?})\", goal);\n+\n+    tcx.infer_ctxt().enter_canonical_trait_query(\n+        &goal,\n+        |ocx, ParamEnvAnd { param_env, value: goal }| {\n+            let selcx = &mut SelectionContext::new(ocx.infcx);\n+            let cause = ObligationCause::dummy();\n+            let mut obligations = vec![];\n+            let answer = traits::normalize_inherent_projection(\n+                selcx,\n+                param_env,\n+                goal,\n+                cause,\n+                0,\n+                &mut obligations,\n+            );\n+            ocx.register_obligations(obligations);\n+\n+            Ok(NormalizationResult { normalized_ty: answer })\n+        },\n+    )\n+}"}, {"sha": "7e5a4d1c735324cccdabcd7ad5c4012820e90b72", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -229,50 +229,53 @@ bitflags! {\n \n         /// Does this have `Projection`?\n         const HAS_TY_PROJECTION           = 1 << 10;\n+        /// Does this have `Inherent`?\n+        const HAS_TY_INHERENT             = 1 << 11;\n         /// Does this have `Opaque`?\n-        const HAS_TY_OPAQUE               = 1 << 11;\n+        const HAS_TY_OPAQUE               = 1 << 12;\n         /// Does this have `ConstKind::Unevaluated`?\n-        const HAS_CT_PROJECTION           = 1 << 12;\n+        const HAS_CT_PROJECTION           = 1 << 13;\n \n         /// Could this type be normalized further?\n         const HAS_PROJECTION              = TypeFlags::HAS_TY_PROJECTION.bits\n                                           | TypeFlags::HAS_TY_OPAQUE.bits\n+                                          | TypeFlags::HAS_TY_INHERENT.bits\n                                           | TypeFlags::HAS_CT_PROJECTION.bits;\n \n         /// Is an error type/const reachable?\n-        const HAS_ERROR                   = 1 << 13;\n+        const HAS_ERROR                   = 1 << 14;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS            = 1 << 14;\n+        const HAS_FREE_REGIONS            = 1 << 15;\n \n         /// Does this have any `ReLateBound` regions?\n-        const HAS_RE_LATE_BOUND           = 1 << 15;\n+        const HAS_RE_LATE_BOUND           = 1 << 16;\n         /// Does this have any `Bound` types?\n-        const HAS_TY_LATE_BOUND           = 1 << 16;\n+        const HAS_TY_LATE_BOUND           = 1 << 17;\n         /// Does this have any `ConstKind::Bound` consts?\n-        const HAS_CT_LATE_BOUND           = 1 << 17;\n+        const HAS_CT_LATE_BOUND           = 1 << 18;\n         /// Does this have any bound variables?\n         /// Used to check if a global bound is safe to evaluate.\n         const HAS_LATE_BOUND              = TypeFlags::HAS_RE_LATE_BOUND.bits\n                                           | TypeFlags::HAS_TY_LATE_BOUND.bits\n                                           | TypeFlags::HAS_CT_LATE_BOUND.bits;\n \n         /// Does this have any `ReErased` regions?\n-        const HAS_RE_ERASED               = 1 << 18;\n+        const HAS_RE_ERASED               = 1 << 19;\n \n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 19;\n+        const STILL_FURTHER_SPECIALIZABLE = 1 << 20;\n \n         /// Does this value have `InferTy::FreshTy/FreshIntTy/FreshFloatTy`?\n-        const HAS_TY_FRESH                = 1 << 20;\n+        const HAS_TY_FRESH                = 1 << 21;\n \n         /// Does this value have `InferConst::Fresh`?\n-        const HAS_CT_FRESH                = 1 << 21;\n+        const HAS_CT_FRESH                = 1 << 22;\n \n         /// Does this have `Generator` or `GeneratorWitness`?\n-        const HAS_TY_GENERATOR            = 1 << 22;\n+        const HAS_TY_GENERATOR            = 1 << 23;\n     }\n }\n "}, {"sha": "f7344bacc028cfabde19ed343575dc54a9020616", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -37,6 +37,7 @@ pub enum DynKind {\n #[derive(Encodable, Decodable, HashStable_Generic)]\n pub enum AliasKind {\n     Projection,\n+    Inherent,\n     Opaque,\n }\n "}, {"sha": "72b60d95b8c154ad07d7a554144bf6c645c68053", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1836,6 +1836,10 @@ pub(crate) fn clean_middle_ty<'tcx>(\n             clean_projection(bound_ty.rebind(*data), cx, parent_def_id)\n         }\n \n+        // FIXME(fmease): Clean inherent projections properly. This requires making the trait ref in\n+        // `QPathData` optional or alternatively adding a new `clean::Type` variant.\n+        ty::Alias(ty::Inherent, _data) => Type::Infer,\n+\n         ty::Param(ref p) => {\n             if let Some(bounds) = cx.impl_trait_bounds.remove(&p.index.into()) {\n                 ImplTrait(bounds)"}, {"sha": "b27ffe73ffda442d153333d8a92bcd5b1e91de1f", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1424,6 +1424,7 @@ fn ty_auto_deref_stability<'tcx>(\n                 continue;\n             },\n             ty::Param(_) => TyPosition::new_deref_stable_for_result(precedence, ty),\n+            ty::Alias(ty::Inherent, _) => unreachable!(\"inherent projection should have been normalized away above\"),\n             ty::Alias(ty::Projection, _) if ty.has_non_region_param() => {\n                 TyPosition::new_deref_stable_for_result(precedence, ty)\n             },"}, {"sha": "bdd881ab456d24c72c4454f78eab6484e062c2f1", "filename": "tests/rustdoc/inherent-projections.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Frustdoc%2Finherent-projections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Frustdoc%2Finherent-projections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finherent-projections.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,14 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(fmease): Properly render inherent projections.\n+\n+// @has inherent_projections/fn.create.html\n+// @has - '//pre[@class=\"rust item-decl\"]' \"create() -> _\"\n+pub fn create() -> Owner::Metadata {}\n+\n+pub struct Owner;\n+\n+impl Owner {\n+    pub type Metadata = ();\n+}"}, {"sha": "f41574403d88766c4d6fdc6af2ef8ee6bb43f4f3", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-adt.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,10 @@\n+// known-bug: #108491\n+\n+// FIXME(inherent_associated_types): This should pass.\n+\n+struct Foo {\n+    bar: Self::Bar,\n+}\n+impl Foo {\n+    pub type Bar = usize;\n+}"}, {"sha": "f313c4946714cebbac02e699ca5e2d893b74456f", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-adt.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-adt.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,49 @@\n+error[E0601]: `main` function not found in crate `cycle_iat_inside_of_adt`\n+  --> $DIR/cycle-iat-inside-of-adt.rs:10:2\n+   |\n+LL | }\n+   |  ^ consider adding a `main` function to `$DIR/cycle-iat-inside-of-adt.rs`\n+\n+error[E0391]: cycle detected when computing predicates of `Foo`\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+   |\n+note: ...which requires computing predicates of `Foo`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+note: ...which requires computing inferred outlives predicates of `Foo`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+   = note: ...which requires computing the inferred outlives predicates for items in this crate...\n+note: ...which requires computing type of `Foo::bar`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:6:5\n+   |\n+LL |     bar: Self::Bar,\n+   |     ^^^^^^^^^^^^^^\n+note: ...which requires computing normalized predicates of `Foo`...\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | struct Foo {\n+   | ^^^^^^^^^^\n+   = note: ...which again requires computing predicates of `Foo`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/cycle-iat-inside-of-adt.rs:5:1\n+   |\n+LL | / struct Foo {\n+LL | |     bar: Self::Bar,\n+LL | | }\n+LL | | impl Foo {\n+LL | |     pub type Bar = usize;\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0391, E0601.\n+For more information about an error, try `rustc --explain E0391`."}, {"sha": "0c2a38b1173d9cdf5e2ce02d227ab9952441ff7a", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-where-predicate.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,16 @@\n+// known-bug: unknown\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(inherent_associated_types): This shouldn't lead to a cycle error.\n+\n+fn user<T>() where S<T>::P: std::fmt::Debug {}\n+\n+struct S<T>;\n+\n+impl<T: Copy> S<T> {\n+    type P = ();\n+}\n+\n+fn main() {}"}, {"sha": "aaa9a39ea0f4a1d45bdddf2249d63e7e0bd44d94", "filename": "tests/ui/associated-inherent-types/bugs/cycle-iat-inside-of-where-predicate.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fcycle-iat-inside-of-where-predicate.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,37 @@\n+error[E0391]: cycle detected when computing predicates of `user`\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires computing predicates of `user`...\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires computing explicit predicates of `user`...\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires computing normalized predicates of `user`...\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:8:1\n+   |\n+LL | fn user<T>() where S<T>::P: std::fmt::Debug {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: ...which again requires computing predicates of `user`, completing the cycle\n+note: cycle used when collecting item types in top-level module\n+  --> $DIR/cycle-iat-inside-of-where-predicate.rs:3:1\n+   |\n+LL | / #![feature(inherent_associated_types)]\n+LL | | #![allow(incomplete_features)]\n+LL | |\n+LL | | // FIXME(inherent_associated_types): This shouldn't lead to a cycle error.\n+...  |\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "53ac79e0561baee45614c02ff575e52b27855a20", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs?ref=6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c", "patch": "@@ -1,23 +0,0 @@\n-// known-bug: unknown\n-// failure-status: 101\n-// normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n-// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n-// rustc-env:RUST_BACKTRACE=0\n-\n-// FIXME: I presume a type variable that couldn't be solved by `resolve_vars_if_possible`\n-//        escapes the InferCtxt snapshot.\n-\n-#![feature(inherent_associated_types)]\n-#![allow(incomplete_features)]\n-\n-struct Cont<T>(T);\n-\n-impl<T: Copy> Cont<T> {\n-    type Out = Vec<T>;\n-}\n-\n-pub fn weird<T: Copy>(x: T) {\n-    let _: Cont<_>::Out = vec![true];\n-}\n-\n-fn main() {}"}, {"sha": "1648cfb266b5652fc23c0e125b92378215f854c8", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.stderr", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr?ref=6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c", "patch": "@@ -1,6 +0,0 @@\n-error: the compiler unexpectedly panicked. this is a bug.\n-\n-query stack during panic:\n-#0 [typeck] type-checking `weird`\n-#1 [used_trait_imports] finding used_trait_imports `weird`\n-end of query stack"}, {"sha": "a920b412b1a492a9840b0c588299bed9d0838926", "filename": "tests/ui/associated-inherent-types/bugs/inference-fail.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs?ref=6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c", "patch": "@@ -1,15 +0,0 @@\n-// known-bug: unknown\n-\n-#![feature(inherent_associated_types)]\n-#![allow(incomplete_features)]\n-\n-struct S<T>(T);\n-\n-impl S<()> {\n-    type P = i128;\n-}\n-\n-fn main() {\n-    // We fail to infer `_ == ()` here.\n-    let _: S<_>::P;\n-}"}, {"sha": "632dbf3854b2b7b0eb5f09225f4be7c938abb462", "filename": "tests/ui/associated-inherent-types/bugs/lack-of-regionck.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs?ref=6f8c0557e0b73c73a8a7163a15f4a5a3feca7d5c", "patch": "@@ -1,19 +0,0 @@\n-// known-bug: unknown\n-// check-pass\n-\n-// We currently don't region-check inherent associated type projections at all.\n-\n-#![feature(inherent_associated_types)]\n-#![allow(incomplete_features, dead_code)]\n-\n-struct S<T>(T);\n-\n-impl S<&'static ()> {\n-    type T = ();\n-}\n-\n-fn usr<'a>() {\n-    let _: S::<&'a ()>::T; // this should *fail* but it doesn't!\n-}\n-\n-fn main() {}"}, {"sha": "c7f66e645bb577a59783da59bab4a750d71f1afb", "filename": "tests/ui/associated-inherent-types/bugs/wf-check-skipped.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fwf-check-skipped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fwf-check-skipped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fwf-check-skipped.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,15 @@\n+// known-bug: #100041\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(inherent_associated_types): This should fail.\n+\n+struct Foo;\n+\n+impl Foo {\n+    type Bar<T> = ();\n+}\n+\n+fn main() -> Foo::Bar::<Vec<[u32]>> {}"}, {"sha": "83be4f43b5e943fad07a64a9e40d2d47179c501d", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -31,7 +31,7 @@ fn main() {\n     let _: Select<u8>::Projection = ();\n \n     let _: Choose<NonCopy>::Result = ();\n-    let _: Choose<bool>::Result = vec![true];\n+    let _: Choose<&str>::Result = vec![\"\u2026\"]; // regression test for issue #108957\n }\n \n // Test if we use the correct `ParamEnv` when proving obligations."}, {"sha": "48390b9430b60e1ad39752755b73187da6d8e6c8", "filename": "tests/ui/associated-inherent-types/former-subst-ice.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fformer-subst-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fformer-subst-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fformer-subst-ice.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Cont<T>(T);\n+\n+impl<T: Copy> Cont<T> {\n+    type Out = Vec<T>;\n+}\n+\n+pub fn weird<T: Copy>(x: T) {\n+    let _: Cont<_>::Out = vec![true];\n+}\n+\n+fn main() {}"}, {"sha": "464b59c249fe1f232e3695be86d4999e64a4723e", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.item.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.item.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/generic-associated-types-bad.rs:16:10\n+   |\n+LL | const _: Ty::Pr<String> = String::new();\n+   |          ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `Ty::Pr`\n+  --> $DIR/generic-associated-types-bad.rs:10:16\n+   |\n+LL |     type Pr<T: Copy> = T;\n+   |                ^^^^ required by this bound in `Ty::Pr`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4f371b24e80344afffd6bf806e7e3f672dc7c3b0", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.local.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.local.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,15 @@\n+error[E0277]: the trait bound `Vec<()>: Copy` is not satisfied\n+  --> $DIR/generic-associated-types-bad.rs:20:12\n+   |\n+LL |     let _: Ty::Pr<Vec<()>>;\n+   |            ^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `Vec<()>`\n+   |\n+note: required by a bound in `Ty::Pr`\n+  --> $DIR/generic-associated-types-bad.rs:10:16\n+   |\n+LL |     type Pr<T: Copy> = T;\n+   |                ^^^^ required by this bound in `Ty::Pr`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "74ec39424edcbdeb6fdfdf503b3dbb229b040f17", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.region.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.region.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,11 @@\n+error: lifetime may not live long enough\n+  --> $DIR/generic-associated-types-bad.rs:25:12\n+   |\n+LL | fn user<'a>() {\n+   |         -- lifetime `'a` defined here\n+LL |     #[cfg(region)]\n+LL |     let _: Ty::Static<&'a str> = \"\";\n+   |            ^^^^^^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "e66392a0a94116c0a1120451d44f700d183ccfbe", "filename": "tests/ui/associated-inherent-types/generic-associated-types-bad.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fgeneric-associated-types-bad.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,26 @@\n+// revisions: item local region\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+#[derive(Clone, Copy)]\n+pub enum Ty {}\n+\n+impl Ty {\n+    type Pr<T: Copy> = T;\n+\n+    type Static<Q: 'static> = Q;\n+}\n+\n+#[cfg(item)]\n+const _: Ty::Pr<String> = String::new(); //[item]~ the trait bound `String: Copy` is not satisfied\n+\n+fn main() {\n+    #[cfg(local)]\n+    let _: Ty::Pr<Vec<()>>; //[local]~ ERROR the trait bound `Vec<()>: Copy` is not satisfied\n+}\n+\n+fn user<'a>() {\n+    #[cfg(region)]\n+    let _: Ty::Static<&'a str> = \"\"; //[region]~ ERROR lifetime may not live long enough\n+}"}, {"sha": "939a4ff60f2bb2fbdce77e970d8d2d68d915dfc0", "filename": "tests/ui/associated-inherent-types/inference-fail.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,11 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T> S<T> { type P = (); }\n+\n+fn main() {\n+    // There is no way to infer this type.\n+    let _: S<_>::P = (); //~ ERROR type annotations needed\n+}"}, {"sha": "f29144e4aa7553cc71e70e36828d19446e717d40", "filename": "tests/ui/associated-inherent-types/inference-fail.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Finference-fail.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -1,8 +1,8 @@\n error[E0282]: type annotations needed\n-  --> $DIR/inference-fail.rs:14:14\n+  --> $DIR/inference-fail.rs:10:12\n    |\n-LL |     let _: S<_>::P;\n-   |              ^ cannot infer type\n+LL |     let _: S<_>::P = ();\n+   |            ^^^^^^^ cannot infer type for type parameter `T`\n \n error: aborting due to previous error\n ", "previous_filename": "tests/ui/associated-inherent-types/bugs/inference-fail.stderr"}, {"sha": "38179214fa124de03df6c8dc4fb259de750b518a", "filename": "tests/ui/associated-inherent-types/inference.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Finference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Finference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Finference.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,39 @@\n+// Testing inference capabilities.\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+use std::convert::identity;\n+\n+struct Container<T>(T);\n+\n+impl Container<u32> {\n+    type Sink = ();\n+}\n+\n+impl<Any> Container<Any> {\n+    type Thing = Any;\n+}\n+\n+impl<T> Container<(T, ())> {\n+    type Output = ((), Wrapped<T>);\n+}\n+\n+fn main() {\n+    // Inferred via the Self type of the impl.\n+    let _: Container<_>::Sink;\n+\n+    // Inferred via the RHS:\n+\n+    let _: Container<_>::Thing = 0;\n+\n+    let _: Container<Wrapped<_>>::Thing = Wrapped(false);\n+\n+    let _: Container<_>::Output = (drop(1), Wrapped(\"...\"));\n+\n+    let binding: Container<_>::Thing = Default::default(); // unsolved at this point\n+    identity::<String>(binding); // constrained and solved here\n+}\n+\n+struct Wrapped<T>(T);"}, {"sha": "488a2cda649ce9d71727b83e9a17ac4a1a446011", "filename": "tests/ui/associated-inherent-types/late-bound-regions.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,25 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Test if we correctly normalize `S<'a>::P` with respect to late-bound regions.\n+\n+type Function = for<'a> fn(&'a i32) -> S<'a>::P;\n+\n+struct S<'a>(&'a ());\n+\n+trait Inter {\n+    type P;\n+}\n+\n+impl<'a> S<'a> {\n+    type P = &'a i32;\n+}\n+\n+fn ret_ref_local<'e>() -> &'e i32 {\n+    let f: Function = |x| x;\n+\n+    let local = 0;\n+    f(&local) //~ ERROR cannot return value referencing local variable `local`\n+}\n+\n+fn main() {}"}, {"sha": "4706fcca91d0644340b2cd5d393637b22b566dde", "filename": "tests/ui/associated-inherent-types/late-bound-regions.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Flate-bound-regions.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,12 @@\n+error[E0515]: cannot return value referencing local variable `local`\n+  --> $DIR/late-bound-regions.rs:22:5\n+   |\n+LL |     f(&local)\n+   |     ^^------^\n+   |     | |\n+   |     | `local` is borrowed here\n+   |     returns a value referencing data owned by the current function\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0515`."}, {"sha": "4228238aa7b7a26b84a4ebeed7c1b54e070ca48a", "filename": "tests/ui/associated-inherent-types/normalization-overflow.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// FIXME(fmease): I'd prefer to report a cycle error here instead of an overflow one.\n+\n+struct T;\n+\n+impl T {\n+    type This = Self::This; //~ ERROR overflow evaluating associated type `T::This`\n+}\n+\n+fn main() {}"}, {"sha": "16bb64281e3af1ed7f0a2b0dbad513228f377a8a", "filename": "tests/ui/associated-inherent-types/normalization-overflow.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnormalization-overflow.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,8 @@\n+error: overflow evaluating associated type `T::This`\n+  --> $DIR/normalization-overflow.rs:9:17\n+   |\n+LL |     type This = Self::This;\n+   |                 ^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "a4b372537c789d680e32a81e767c3992e3ce88bf", "filename": "tests/ui/associated-inherent-types/private-in-public.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,26 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+#![crate_type = \"lib\"]\n+\n+#![deny(private_in_public)]\n+\n+pub type PubAlias0 = PubTy::PrivAssocTy;\n+//~^ ERROR private associated type `PubTy::PrivAssocTy` in public interface (error E0446)\n+//~| WARNING this was previously accepted\n+pub type PubAlias1 = PrivTy::PubAssocTy;\n+//~^ ERROR private type `PrivTy` in public interface (error E0446)\n+//~| WARNING this was previously accepted\n+pub type PubAlias2 = PubTy::PubAssocTy<PrivTy>;\n+//~^ ERROR private type `PrivTy` in public interface (error E0446)\n+//~| WARNING this was previously accepted\n+\n+pub struct PubTy;\n+impl PubTy {\n+    type PrivAssocTy = ();\n+    pub type PubAssocTy<T> = T;\n+}\n+\n+struct PrivTy;\n+impl PrivTy {\n+    pub type PubAssocTy = ();\n+}"}, {"sha": "f0a64e96179ac39dd2a0d5aa5141209c77ffbdf7", "filename": "tests/ui/associated-inherent-types/private-in-public.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fprivate-in-public.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,34 @@\n+error: private associated type `PubTy::PrivAssocTy` in public interface (error E0446)\n+  --> $DIR/private-in-public.rs:7:1\n+   |\n+LL | pub type PubAlias0 = PubTy::PrivAssocTy;\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+note: the lint level is defined here\n+  --> $DIR/private-in-public.rs:5:9\n+   |\n+LL | #![deny(private_in_public)]\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: private type `PrivTy` in public interface (error E0446)\n+  --> $DIR/private-in-public.rs:10:1\n+   |\n+LL | pub type PubAlias1 = PrivTy::PubAssocTy;\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+error: private type `PrivTy` in public interface (error E0446)\n+  --> $DIR/private-in-public.rs:13:1\n+   |\n+LL | pub type PubAlias2 = PubTy::PubAssocTy<PrivTy>;\n+   | ^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7c94539ace1f904db8cc32a2d93ed2d71055598e", "filename": "tests/ui/associated-inherent-types/regionck-0.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,14 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl S<&'static ()> {\n+    type T = ();\n+}\n+\n+fn user<'a>() {\n+    let _: S::<&'a ()>::T; //~ ERROR lifetime may not live long enough\n+}\n+\n+fn main() {}"}, {"sha": "3a438ee630e1e3eea1f0facfd8713a1a50f01df0", "filename": "tests/ui/associated-inherent-types/regionck-0.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-0.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,10 @@\n+error: lifetime may not live long enough\n+  --> $DIR/regionck-0.rs:11:12\n+   |\n+LL | fn user<'a>() {\n+   |         -- lifetime `'a` defined here\n+LL |     let _: S::<&'a ()>::T;\n+   |            ^^^^^^^^^^^^^^ requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "ec663cd0f77fa0bedef29f4d0a78560322ce467c", "filename": "tests/ui/associated-inherent-types/regionck-1.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,13 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct U;\n+\n+impl U {\n+    // Don't imply any bounds here.\n+\n+    type NoTyOutliv<'a, T> = &'a T; //~ ERROR the parameter type `T` may not live long enough\n+    type NoReOutliv<'a, 'b> = &'a &'b (); //~ ERROR reference has a longer lifetime than the data it references\n+}\n+\n+fn main() {}"}, {"sha": "b17d89ca306f41cf1ea76c5f60116ea4019764fd", "filename": "tests/ui/associated-inherent-types/regionck-1.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-1.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,29 @@\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/regionck-1.rs:9:30\n+   |\n+LL |     type NoTyOutliv<'a, T> = &'a T;\n+   |                              ^^^^^- help: consider adding a where clause: `where T: 'a`\n+   |                              |\n+   |                              ...so that the reference type `&'a T` does not outlive the data it points at\n+\n+error[E0491]: in type `&'a &'b ()`, reference has a longer lifetime than the data it references\n+  --> $DIR/regionck-1.rs:10:31\n+   |\n+LL |     type NoReOutliv<'a, 'b> = &'a &'b ();\n+   |                               ^^^^^^^^^^\n+   |\n+note: the pointer is valid for the lifetime `'a` as defined here\n+  --> $DIR/regionck-1.rs:10:21\n+   |\n+LL |     type NoReOutliv<'a, 'b> = &'a &'b ();\n+   |                     ^^\n+note: but the referenced data is only valid for the lifetime `'b` as defined here\n+  --> $DIR/regionck-1.rs:10:25\n+   |\n+LL |     type NoReOutliv<'a, 'b> = &'a &'b ();\n+   |                         ^^\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0309, E0491.\n+For more information about an error, try `rustc --explain E0309`."}, {"sha": "7a0b8b08300157083bedad04ab32402b2903e4ad", "filename": "tests/ui/associated-inherent-types/regionck-2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,14 @@\n+// Regression test for issue #109299.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Lexer<'d>(&'d ());\n+\n+impl Lexer<'static> {\n+    type Cursor = ();\n+}\n+\n+fn test(_: Lexer::Cursor) {} //~ ERROR mismatched types\n+\n+fn main() {}"}, {"sha": "b0a4ed35d560973266a21c49da4590808f2a3ab4", "filename": "tests/ui/associated-inherent-types/regionck-2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fregionck-2.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/regionck-2.rs:12:12\n+   |\n+LL | fn test(_: Lexer::Cursor) {}\n+   |            ^^^^^^^^^^^^^ lifetime mismatch\n+   |\n+   = note: expected struct `Lexer<'static>`\n+              found struct `Lexer<'_>`\n+note: the anonymous lifetime defined here...\n+  --> $DIR/regionck-2.rs:12:12\n+   |\n+LL | fn test(_: Lexer::Cursor) {}\n+   |            ^^^^^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b32b4288ac9f67cd5bc86efb32dca47833bc0ff6", "filename": "tests/ui/associated-inherent-types/type-alias-bounds-are-enforced.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Ftype-alias-bounds-are-enforced.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Ftype-alias-bounds-are-enforced.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Ftype-alias-bounds-are-enforced.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,26 @@\n+// check-pass\n+// compile-flags: --crate-type=lib\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Bounds on the self type play a major role in the resolution of inherent associated types (*).\n+// As a result of that, if a type alias contains any then its bounds have to be respected and the\n+// lint `type_alias_bounds` should not fire.\n+//\n+// FIXME(inherent_associated_types): In the current implementation that is. We might move the\n+// selection phase of IATs from hir_typeck to trait_selection resulting in us not requiring the\n+// ParamEnv that early allowing us to ignore bounds on type aliases again.\n+// Triage this before stabilization.\n+\n+#![deny(type_alias_bounds)]\n+\n+pub type Alias<T: Bound> = (Source<T>::Assoc,);\n+\n+\n+pub struct Source<T>(T);\n+pub trait Bound {}\n+\n+impl<T: Bound> Source<T> {\n+    pub type Assoc = ();\n+}"}, {"sha": "d081c4d5b78e6206af5bf1f9c7a2bb823e28aac8", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-inferred-type.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,12 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T: Copy> S<T> {\n+    type T = T;\n+}\n+\n+fn main() {\n+    let _: S<_>::T = String::new(); //~ ERROR the trait bound `String: Copy` is not satisfied\n+}"}, {"sha": "ecf30f4cdec58626e3b9714c5832dfabe00f0cf6", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-inferred-type.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-inferred-type.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,17 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/unsatisfied-bounds-inferred-type.rs:11:12\n+   |\n+LL |     let _: S<_>::T = String::new();\n+   |            ^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `S<T>::T`\n+  --> $DIR/unsatisfied-bounds-inferred-type.rs:6:9\n+   |\n+LL | impl<T: Copy> S<T> {\n+   |         ^^^^ required by this bound in `S<T>::T`\n+LL |     type T = T;\n+   |          - required by a bound in this associated type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "97bd2c421604af81da3ab3e050f216ae9e52527b", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-where-clause-on-assoc-ty.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.rs?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,14 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T> S<T> {\n+    type X = ()\n+    where\n+        T: Copy;\n+}\n+\n+fn main() {\n+    let _: S::<String>::X; //~ ERROR the trait bound `String: Copy` is not satisfied\n+}"}, {"sha": "d4968cd05dceefa000f1f11dd6888f323331d01b", "filename": "tests/ui/associated-inherent-types/unsatisfied-bounds-where-clause-on-assoc-ty.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e8139dfd5a747842a8303f33d8c842378913d594/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Funsatisfied-bounds-where-clause-on-assoc-ty.stderr?ref=e8139dfd5a747842a8303f33d8c842378913d594", "patch": "@@ -0,0 +1,18 @@\n+error[E0277]: the trait bound `String: Copy` is not satisfied\n+  --> $DIR/unsatisfied-bounds-where-clause-on-assoc-ty.rs:13:12\n+   |\n+LL |     let _: S::<String>::X;\n+   |            ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n+   |\n+note: required by a bound in `S<T>::X`\n+  --> $DIR/unsatisfied-bounds-where-clause-on-assoc-ty.rs:9:12\n+   |\n+LL |     type X = ()\n+   |          - required by a bound in this associated type\n+LL |     where\n+LL |         T: Copy;\n+   |            ^^^^ required by this bound in `S<T>::X`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}