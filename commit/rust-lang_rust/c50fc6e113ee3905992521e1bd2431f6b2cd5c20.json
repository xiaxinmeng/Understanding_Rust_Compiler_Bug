{"sha": "c50fc6e113ee3905992521e1bd2431f6b2cd5c20", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MGZjNmUxMTNlZTM5MDU5OTI1MjFlMWJkMjQzMWY2YjJjZDVjMjA=", "commit": {"author": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-02-25T09:29:47Z"}, "committer": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-05-05T09:24:22Z"}, "message": "Allow SnapshotMap to have a separate undo_log", "tree": {"sha": "0a0d02486cd28dc169467dc14cee4a151fd4e323", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a0d02486cd28dc169467dc14cee4a151fd4e323"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c50fc6e113ee3905992521e1bd2431f6b2cd5c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c50fc6e113ee3905992521e1bd2431f6b2cd5c20", "html_url": "https://github.com/rust-lang/rust/commit/c50fc6e113ee3905992521e1bd2431f6b2cd5c20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c50fc6e113ee3905992521e1bd2431f6b2cd5c20/comments", "author": null, "committer": null, "parents": [{"sha": "caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "url": "https://api.github.com/repos/rust-lang/rust/commits/caacdd2024cc428f95e4177e63fb66fd3e6f6c20", "html_url": "https://github.com/rust-lang/rust/commit/caacdd2024cc428f95e4177e63fb66fd3e6f6c20"}], "stats": {"total": 158, "additions": 62, "deletions": 96}, "files": [{"sha": "81b4c35aa1ab712490f34030fcf338459275f2cf", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 58, "deletions": 92, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/c50fc6e113ee3905992521e1bd2431f6b2cd5c20/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50fc6e113ee3905992521e1bd2431f6b2cd5c20/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=c50fc6e113ee3905992521e1bd2431f6b2cd5c20", "patch": "@@ -1,161 +1,127 @@\n use crate::fx::FxHashMap;\n+use crate::undo_log::{Rollback, Snapshots, UndoLogs, VecLog};\n use std::hash::Hash;\n-use std::mem;\n+use std::marker::PhantomData;\n use std::ops;\n \n+pub use crate::undo_log::Snapshot;\n+\n #[cfg(test)]\n mod tests;\n \n-pub struct SnapshotMap<K, V>\n-where\n-    K: Clone + Eq,\n-{\n-    map: FxHashMap<K, V>,\n-    undo_log: Vec<UndoLog<K, V>>,\n-    num_open_snapshots: usize,\n+pub type SnapshotMapStorage<K, V> = SnapshotMap<K, V, FxHashMap<K, V>, ()>;\n+\n+pub struct SnapshotMap<K, V, M = FxHashMap<K, V>, L = VecLog<UndoLog<K, V>>> {\n+    map: M,\n+    undo_log: L,\n+    _marker: PhantomData<(K, V)>,\n }\n \n // HACK(eddyb) manual impl avoids `Default` bounds on `K` and `V`.\n-impl<K, V> Default for SnapshotMap<K, V>\n+impl<K, V, M, L> Default for SnapshotMap<K, V, M, L>\n where\n-    K: Hash + Clone + Eq,\n+    M: Default,\n+    L: Default,\n {\n     fn default() -> Self {\n-        SnapshotMap { map: Default::default(), undo_log: Default::default(), num_open_snapshots: 0 }\n+        SnapshotMap { map: Default::default(), undo_log: Default::default(), _marker: PhantomData }\n     }\n }\n \n-pub struct Snapshot {\n-    len: usize,\n-}\n-\n-enum UndoLog<K, V> {\n+pub enum UndoLog<K, V> {\n     Inserted(K),\n     Overwrite(K, V),\n     Purged,\n }\n \n-impl<K, V> SnapshotMap<K, V>\n+impl<K, V, M, L> SnapshotMap<K, V, M, L> {\n+    pub fn with_log<L2>(&mut self, undo_log: L2) -> SnapshotMap<K, V, &mut M, L2> {\n+        SnapshotMap { map: &mut self.map, undo_log, _marker: PhantomData }\n+    }\n+}\n+\n+impl<K, V, M, L> SnapshotMap<K, V, M, L>\n where\n     K: Hash + Clone + Eq,\n+    M: AsMut<FxHashMap<K, V>> + AsRef<FxHashMap<K, V>>,\n+    L: UndoLogs<UndoLog<K, V>>,\n {\n     pub fn clear(&mut self) {\n-        self.map.clear();\n+        self.map.as_mut().clear();\n         self.undo_log.clear();\n-        self.num_open_snapshots = 0;\n-    }\n-\n-    fn in_snapshot(&self) -> bool {\n-        self.num_open_snapshots > 0\n     }\n \n     pub fn insert(&mut self, key: K, value: V) -> bool {\n-        match self.map.insert(key.clone(), value) {\n+        match self.map.as_mut().insert(key.clone(), value) {\n             None => {\n-                if self.in_snapshot() {\n-                    self.undo_log.push(UndoLog::Inserted(key));\n-                }\n+                self.undo_log.push(UndoLog::Inserted(key));\n                 true\n             }\n             Some(old_value) => {\n-                if self.in_snapshot() {\n-                    self.undo_log.push(UndoLog::Overwrite(key, old_value));\n-                }\n+                self.undo_log.push(UndoLog::Overwrite(key, old_value));\n                 false\n             }\n         }\n     }\n \n     pub fn remove(&mut self, key: K) -> bool {\n-        match self.map.remove(&key) {\n+        match self.map.as_mut().remove(&key) {\n             Some(old_value) => {\n-                if self.in_snapshot() {\n-                    self.undo_log.push(UndoLog::Overwrite(key, old_value));\n-                }\n+                self.undo_log.push(UndoLog::Overwrite(key, old_value));\n                 true\n             }\n             None => false,\n         }\n     }\n \n     pub fn get(&self, key: &K) -> Option<&V> {\n-        self.map.get(key)\n+        self.map.as_ref().get(key)\n     }\n+}\n \n+impl<K, V> SnapshotMap<K, V>\n+where\n+    K: Hash + Clone + Eq,\n+{\n     pub fn snapshot(&mut self) -> Snapshot {\n-        let len = self.undo_log.len();\n-        self.num_open_snapshots += 1;\n-        Snapshot { len }\n-    }\n-\n-    fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n-        assert!(self.undo_log.len() >= snapshot.len);\n-        assert!(self.num_open_snapshots > 0);\n+        self.undo_log.start_snapshot()\n     }\n \n     pub fn commit(&mut self, snapshot: Snapshot) {\n-        self.assert_open_snapshot(&snapshot);\n-        if self.num_open_snapshots == 1 {\n-            // The root snapshot. It's safe to clear the undo log because\n-            // there's no snapshot further out that we might need to roll back\n-            // to.\n-            assert!(snapshot.len == 0);\n-            self.undo_log.clear();\n-        }\n-\n-        self.num_open_snapshots -= 1;\n-    }\n-\n-    pub fn partial_rollback<F>(&mut self, snapshot: &Snapshot, should_revert_key: &F)\n-    where\n-        F: Fn(&K) -> bool,\n-    {\n-        self.assert_open_snapshot(snapshot);\n-        for i in (snapshot.len..self.undo_log.len()).rev() {\n-            let reverse = match self.undo_log[i] {\n-                UndoLog::Purged => false,\n-                UndoLog::Inserted(ref k) => should_revert_key(k),\n-                UndoLog::Overwrite(ref k, _) => should_revert_key(k),\n-            };\n-\n-            if reverse {\n-                let entry = mem::replace(&mut self.undo_log[i], UndoLog::Purged);\n-                self.reverse(entry);\n-            }\n-        }\n+        self.undo_log.commit(snapshot)\n     }\n \n     pub fn rollback_to(&mut self, snapshot: Snapshot) {\n-        self.assert_open_snapshot(&snapshot);\n-        while self.undo_log.len() > snapshot.len {\n-            let entry = self.undo_log.pop().unwrap();\n-            self.reverse(entry);\n-        }\n+        self.undo_log.rollback_to(&mut self.map, snapshot)\n+    }\n+}\n \n-        self.num_open_snapshots -= 1;\n+impl<'k, K, V, M, L> ops::Index<&'k K> for SnapshotMap<K, V, M, L>\n+where\n+    K: Hash + Clone + Eq,\n+    M: AsRef<FxHashMap<K, V>>,\n+{\n+    type Output = V;\n+    fn index(&self, key: &'k K) -> &V {\n+        &self.map.as_ref()[key]\n     }\n+}\n \n-    fn reverse(&mut self, entry: UndoLog<K, V>) {\n-        match entry {\n+impl<K, V> Rollback<UndoLog<K, V>> for FxHashMap<K, V>\n+where\n+    K: Eq + Hash,\n+{\n+    fn reverse(&mut self, undo: UndoLog<K, V>) {\n+        match undo {\n             UndoLog::Inserted(key) => {\n-                self.map.remove(&key);\n+                self.remove(&key);\n             }\n \n             UndoLog::Overwrite(key, old_value) => {\n-                self.map.insert(key, old_value);\n+                self.insert(key, old_value);\n             }\n \n             UndoLog::Purged => {}\n         }\n     }\n }\n-\n-impl<'k, K, V> ops::Index<&'k K> for SnapshotMap<K, V>\n-where\n-    K: Hash + Clone + Eq,\n-{\n-    type Output = V;\n-    fn index(&self, key: &'k K) -> &V {\n-        &self.map[key]\n-    }\n-}"}, {"sha": "eabb513d2d3a672410ffe8780ebd0706501c47ee", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c50fc6e113ee3905992521e1bd2431f6b2cd5c20/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50fc6e113ee3905992521e1bd2431f6b2cd5c20/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=c50fc6e113ee3905992521e1bd2431f6b2cd5c20", "patch": "@@ -376,6 +376,10 @@ where\n             self.logs.push(undo.into())\n         }\n     }\n+    fn clear(&mut self) {\n+        self.logs.clear();\n+        self.num_open_snapshots = 0;\n+    }\n     fn extend<J>(&mut self, undos: J)\n     where\n         Self: Sized,"}, {"sha": "17105f99ac0fae08937bf69806b72aec43ae1554", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c50fc6e113ee3905992521e1bd2431f6b2cd5c20/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c50fc6e113ee3905992521e1bd2431f6b2cd5c20/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=c50fc6e113ee3905992521e1bd2431f6b2cd5c20", "patch": "@@ -100,10 +100,6 @@ impl<'tcx> ProjectionCache<'tcx> {\n         self.map.rollback_to(snapshot.snapshot);\n     }\n \n-    pub fn rollback_placeholder(&mut self, snapshot: &ProjectionCacheSnapshot) {\n-        self.map.partial_rollback(&snapshot.snapshot, &|k| k.ty.has_re_placeholders());\n-    }\n-\n     pub fn commit(&mut self, snapshot: ProjectionCacheSnapshot) {\n         self.map.commit(snapshot.snapshot);\n     }"}]}