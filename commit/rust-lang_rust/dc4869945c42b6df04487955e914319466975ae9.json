{"sha": "dc4869945c42b6df04487955e914319466975ae9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNDg2OTk0NWM0MmI2ZGYwNDQ4Nzk1NWU5MTQzMTk0NjY5NzVhZTk=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-08T01:55:16Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-11T16:35:59Z"}, "message": "librustc: Remove newtype enums from librustc", "tree": {"sha": "0effe9ea44a35644f27f48d28b1841ac5e454683", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0effe9ea44a35644f27f48d28b1841ac5e454683"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc4869945c42b6df04487955e914319466975ae9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc4869945c42b6df04487955e914319466975ae9", "html_url": "https://github.com/rust-lang/rust/commit/dc4869945c42b6df04487955e914319466975ae9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc4869945c42b6df04487955e914319466975ae9/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4faf63e472f1cd8721be6c498e4db97760665e90", "url": "https://api.github.com/repos/rust-lang/rust/commits/4faf63e472f1cd8721be6c498e4db97760665e90", "html_url": "https://github.com/rust-lang/rust/commit/4faf63e472f1cd8721be6c498e4db97760665e90"}], "stats": {"total": 78, "additions": 41, "deletions": 37}, "files": [{"sha": "0c17b371694c4403bdd3a54aff7a7dac875cdabf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=dc4869945c42b6df04487955e914319466975ae9", "patch": "@@ -137,8 +137,8 @@ use syntax::{visit, ast_util};\n // if it detects an outstanding loan (that is, the addr is taken).\n pub type last_use_map = HashMap<node_id, @mut ~[node_id]>;\n \n-enum Variable = uint;\n-enum LiveNode = uint;\n+struct Variable(uint);\n+struct LiveNode(uint);\n \n impl cmp::Eq for Variable {\n     pure fn eq(&self, other: &Variable) -> bool { *(*self) == *(*other) }"}, {"sha": "b4ef87491a8a324ded3850bfbc24736730df023c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=dc4869945c42b6df04487955e914319466975ae9", "patch": "@@ -582,18 +582,20 @@ pub enum param_bound {\n }\n \n #[deriving_eq]\n-pub enum TyVid = uint;\n+pub struct TyVid(uint);\n \n #[deriving_eq]\n-pub enum IntVid = uint;\n+pub struct IntVid(uint);\n \n #[deriving_eq]\n-pub enum FloatVid = uint;\n+pub struct FloatVid(uint);\n \n #[deriving_eq]\n #[auto_encode]\n #[auto_decode]\n-pub enum RegionVid = uint;\n+pub struct RegionVid {\n+    id: uint\n+}\n \n #[deriving_eq]\n pub enum InferTy {\n@@ -687,11 +689,11 @@ impl ToStr for FloatVid {\n }\n \n impl Vid for RegionVid {\n-    pure fn to_uint(&self) -> uint { **self }\n+    pure fn to_uint(&self) -> uint { self.id }\n }\n \n impl ToStr for RegionVid {\n-    pure fn to_str(&self) -> ~str { fmt!(\"%?\", self) }\n+    pure fn to_str(&self) -> ~str { fmt!(\"%?\", self.id) }\n }\n \n impl ToStr for FnSig {"}, {"sha": "91c987acc6aa725b976b940879e7b50348113cb5", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=dc4869945c42b6df04487955e914319466975ae9", "patch": "@@ -84,7 +84,7 @@ use syntax::ast;\n // Note: Coerce is not actually a combiner, in that it does not\n // conform to the same interface, though it performs a similar\n // function.\n-pub enum Coerce = CombineFields;\n+pub struct Coerce(CombineFields);\n \n pub impl Coerce {\n     fn tys(&self, a: ty::t, b: ty::t) -> CoerceResult {"}, {"sha": "bba35f02b0c1e0eab79bc096545d769d63956dd2", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=dc4869945c42b6df04487955e914319466975ae9", "patch": "@@ -29,7 +29,7 @@ use util::ppaux::mt_to_str;\n \n use std::list;\n \n-pub enum Glb = CombineFields;  // \"greatest lower bound\" (common subtype)\n+pub struct Glb(CombineFields);  // \"greatest lower bound\" (common subtype)\n \n impl Combine for Glb {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }"}, {"sha": "3a12fb31a1a6f70f2eba5f319e04ad6fdf7cc483", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=dc4869945c42b6df04487955e914319466975ae9", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{pure_fn, ret_style, return_val, unsafe_fn};\n use syntax::ast::{Onceness, purity};\n use syntax::codemap::span;\n \n-pub enum Lub = CombineFields;  // least-upper-bound: common supertype\n+pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n \n pub impl Lub {\n     fn bot_ty(&self, b: ty::t) -> cres<ty::t> { Ok(b) }"}, {"sha": "33e953b6218d99357b06f823cb879df86b3b01b7", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=dc4869945c42b6df04487955e914319466975ae9", "patch": "@@ -700,7 +700,7 @@ pub impl RegionVarBindings {\n             match undo_item {\n               Snapshot => {}\n               AddVar(vid) => {\n-                fail_unless!(self.var_spans.len() == *vid + 1);\n+                fail_unless!(self.var_spans.len() == vid.to_uint() + 1);\n                 self.var_spans.pop();\n               }\n               AddConstraint(ref constraint) => {\n@@ -720,7 +720,7 @@ pub impl RegionVarBindings {\n     fn new_region_var(&mut self, span: span) -> RegionVid {\n         let id = self.num_vars();\n         self.var_spans.push(span);\n-        let vid = RegionVid(id);\n+        let vid = RegionVid { id: id };\n         if self.in_snapshot() {\n             self.undo_log.push(AddVar(vid));\n         }\n@@ -863,15 +863,15 @@ pub impl RegionVarBindings {\n     }\n \n     fn resolve_var(&mut self, rid: RegionVid) -> ty::Region {\n-        debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, *rid);\n+        debug!(\"RegionVarBindings: resolve_var(%?=%u)\", rid, rid.to_uint());\n         if self.values.is_empty() {\n             self.tcx.sess.span_bug(\n-                self.var_spans[*rid],\n+                self.var_spans[rid.to_uint()],\n                 fmt!(\"Attempt to resolve region variable before values have \\\n                       been computed!\"));\n         }\n \n-        let v = self.values.with_ref(|values| values[*rid]);\n+        let v = self.values.with_ref(|values| values[rid.to_uint()]);\n         match v {\n             Value(r) => r,\n \n@@ -886,13 +886,13 @@ pub impl RegionVarBindings {\n                 // should ultimately have some bounds.\n \n                 self.tcx.sess.span_err(\n-                    self.var_spans[*rid],\n-                    fmt!(\"Unconstrained region variable #%u\", *rid));\n+                    self.var_spans[rid.to_uint()],\n+                    fmt!(\"Unconstrained region variable #%u\", rid.to_uint()));\n \n                 // Touch of a hack: to suppress duplicate messages,\n                 // replace the NoValue entry with ErrorValue.\n                 let mut values = self.values.take();\n-                values[*rid] = ErrorValue;\n+                values[rid.to_uint()] = ErrorValue;\n                 self.values.put_back(values);\n                 re_static\n             }\n@@ -1049,7 +1049,7 @@ priv impl RegionVarBindings {\n \n           (re_infer(ReVar(v_id)), _) | (_, re_infer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n-                self.var_spans[*v_id],\n+                self.var_spans[v_id.to_uint()],\n                 fmt!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: %?, %?\", a, b));\n           }\n@@ -1111,7 +1111,7 @@ priv impl RegionVarBindings {\n             (re_infer(ReVar(v_id)), _) |\n             (_, re_infer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n-                    self.var_spans[*v_id],\n+                    self.var_spans[v_id.to_uint()],\n                     fmt!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: %?, %?\", a, b));\n             }\n@@ -1275,8 +1275,8 @@ pub impl RegionVarBindings {\n                        edge_idx: uint) {\n             let edge_dir = edge_dir as uint;\n             graph.edges[edge_idx].next_edge[edge_dir] =\n-                graph.nodes[*node_id].head_edge[edge_dir];\n-            graph.nodes[*node_id].head_edge[edge_dir] =\n+                graph.nodes[node_id.to_uint()].head_edge[edge_dir];\n+            graph.nodes[node_id.to_uint()].head_edge[edge_dir] =\n                 edge_idx;\n         }\n     }\n@@ -1285,14 +1285,14 @@ pub impl RegionVarBindings {\n         do iterate_until_fixed_point(~\"Expansion\", graph) |nodes, edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n-                let b_node = &mut nodes[*b_vid];\n+                let b_node = &mut nodes[b_vid.to_uint()];\n                 self.expand_node(a_region, b_vid, b_node)\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match nodes[*a_vid].value {\n+                match nodes[a_vid.to_uint()].value {\n                   NoValue | ErrorValue => false,\n                   Value(a_region) => {\n-                    let b_node = &mut nodes[*b_vid];\n+                    let b_node = &mut nodes[b_vid.to_uint()];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -1349,16 +1349,16 @@ pub impl RegionVarBindings {\n                 false\n               }\n               ConstrainVarSubVar(a_vid, b_vid) => {\n-                match nodes[*b_vid].value {\n+                match nodes[b_vid.to_uint()].value {\n                   NoValue | ErrorValue => false,\n                   Value(b_region) => {\n-                    let a_node = &mut nodes[*a_vid];\n+                    let a_node = &mut nodes[a_vid.to_uint()];\n                     self.contract_node(a_vid, a_node, b_region)\n                   }\n                 }\n               }\n               ConstrainVarSubReg(a_vid, b_region) => {\n-                let a_node = &mut nodes[*a_vid];\n+                let a_node = &mut nodes[a_vid.to_uint()];\n                 self.contract_node(a_vid, a_node, b_region)\n               }\n             }\n@@ -1474,7 +1474,7 @@ pub impl RegionVarBindings {\n                        that is not used is not a problem, so if this rule\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n-                    let node_vid = RegionVid(idx);\n+                    let node_vid = RegionVid { id: idx };\n                     match node.classification {\n                         Expanding => {\n                             self.report_error_for_expanding_node(\n@@ -1525,7 +1525,7 @@ pub impl RegionVarBindings {\n                     }\n \n                     self.tcx.sess.span_err(\n-                        self.var_spans[*node_idx],\n+                        self.var_spans[node_idx.to_uint()],\n                         fmt!(\"cannot infer an appropriate lifetime \\\n                               due to conflicting requirements\"));\n \n@@ -1578,7 +1578,7 @@ pub impl RegionVarBindings {\n                     }\n \n                     self.tcx.sess.span_err(\n-                        self.var_spans[*node_idx],\n+                        self.var_spans[node_idx.to_uint()],\n                         fmt!(\"cannot infer an appropriate lifetime \\\n                               due to conflicting requirements\"));\n \n@@ -1616,7 +1616,7 @@ pub impl RegionVarBindings {\n                              -> ~[SpannedRegion] {\n         let set = HashMap();\n         let mut stack = ~[orig_node_idx];\n-        set.insert(*orig_node_idx, ());\n+        set.insert(orig_node_idx.to_uint(), ());\n         let mut result = ~[];\n         while !vec::is_empty(stack) {\n             let node_idx = stack.pop();\n@@ -1627,7 +1627,7 @@ pub impl RegionVarBindings {\n                       Incoming => from_vid,\n                       Outgoing => to_vid\n                     };\n-                    if set.insert(*vid, ()) {\n+                    if set.insert(vid.to_uint(), ()) {\n                         stack.push(vid);\n                     }\n                   }\n@@ -1658,7 +1658,8 @@ pub impl RegionVarBindings {\n                  node_idx: RegionVid,\n                  dir: Direction,\n                  op: &fn(edge: &GraphEdge) -> bool) {\n-        let mut edge_idx = graph.nodes[*node_idx].head_edge[dir as uint];\n+        let mut edge_idx =\n+            graph.nodes[node_idx.to_uint()].head_edge[dir as uint];\n         while edge_idx != uint::max_value {\n             let edge_ptr = &graph.edges[edge_idx];\n             if !op(edge_ptr) {"}, {"sha": "b4d8905a93627c2f278ae4dfc227ae27e3769962", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=dc4869945c42b6df04487955e914319466975ae9", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{Onceness, m_const, purity, ret_style};\n use syntax::codemap::span;\n \n \n-pub enum Sub = CombineFields;  // \"subtype\", \"subregion\" etc\n+pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n \n impl Combine for Sub {\n     fn infcx(&self) -> @mut InferCtxt { self.infcx }"}, {"sha": "f74a0960f66749b9245aba6bb39bc4a28ba57be6", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc4869945c42b6df04487955e914319466975ae9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=dc4869945c42b6df04487955e914319466975ae9", "patch": "@@ -74,7 +74,8 @@ impl region_scope for MethodRscope {\n     }\n }\n \n-pub enum type_rscope = Option<ty::region_variance>;\n+pub struct type_rscope(Option<ty::region_variance>);\n+\n impl type_rscope {\n     priv fn replacement(&self) -> ty::Region {\n         if self.is_some() {"}]}