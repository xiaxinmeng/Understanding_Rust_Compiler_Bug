{"sha": "80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "node_id": "C_kwDOAAsO6NoAKDgwYjNjNmRiZGUzZmY4OWE0NGY4ZWFhNjNlMDgwNTQzOThiMzBlY2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-23T13:13:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-23T13:13:50Z"}, "message": "Auto merge of #103947 - camsteffen:place-clones, r=cjgillot\n\nReduce `PlaceBuilder` cloning\n\nSome API tweaks with an eye towards reducing clones.", "tree": {"sha": "de2ba838eba2eb7170f118a6c6c0a6cf846c511c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de2ba838eba2eb7170f118a6c6c0a6cf846c511c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "html_url": "https://github.com/rust-lang/rust/commit/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e0d0d757e2f1b61ec809420b006545a9f8974c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e0d0d757e2f1b61ec809420b006545a9f8974c0", "html_url": "https://github.com/rust-lang/rust/commit/4e0d0d757e2f1b61ec809420b006545a9f8974c0"}, {"sha": "9cf6ce070d02e978eb29a84a64934b674bccb32a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf6ce070d02e978eb29a84a64934b674bccb32a", "html_url": "https://github.com/rust-lang/rust/commit/9cf6ce070d02e978eb29a84a64934b674bccb32a"}], "stats": {"total": 284, "additions": 134, "deletions": 150}, "files": [{"sha": "edd527286264a135e019394fc9019646d32f3e88", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 85, "deletions": 83, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "patch": "@@ -65,7 +65,7 @@ pub(crate) enum PlaceBase {\n \n /// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n /// place by pushing more and more projections onto the end, and then convert the final set into a\n-/// place using the `into_place` method.\n+/// place using the `to_place` method.\n ///\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n@@ -167,59 +167,54 @@ fn find_capture_matching_projections<'a, 'tcx>(\n     })\n }\n \n-/// Takes a PlaceBuilder and resolves the upvar (if any) within it, so that the\n-/// `PlaceBuilder` now starts from `PlaceBase::Local`.\n-///\n-/// Returns a Result with the error being the PlaceBuilder (`from_builder`) that was not found.\n+/// Takes an upvar place and tries to resolve it into a `PlaceBuilder`\n+/// with `PlaceBase::Local`\n #[instrument(level = \"trace\", skip(cx), ret)]\n fn to_upvars_resolved_place_builder<'tcx>(\n-    from_builder: PlaceBuilder<'tcx>,\n     cx: &Builder<'_, 'tcx>,\n-) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-    match from_builder.base {\n-        PlaceBase::Local(_) => Ok(from_builder),\n-        PlaceBase::Upvar { var_hir_id, closure_def_id } => {\n-            let Some((capture_index, capture)) =\n-                find_capture_matching_projections(\n-                    &cx.upvars,\n-                    var_hir_id,\n-                    &from_builder.projection,\n-                ) else {\n-                let closure_span = cx.tcx.def_span(closure_def_id);\n-                if !enable_precise_capture(cx.tcx, closure_span) {\n-                    bug!(\n-                        \"No associated capture found for {:?}[{:#?}] even though \\\n-                            capture_disjoint_fields isn't enabled\",\n-                        var_hir_id,\n-                        from_builder.projection\n-                    )\n-                } else {\n-                    debug!(\n-                        \"No associated capture found for {:?}[{:#?}]\",\n-                        var_hir_id, from_builder.projection,\n-                    );\n-                }\n-                return Err(from_builder);\n-            };\n+    var_hir_id: LocalVarId,\n+    closure_def_id: LocalDefId,\n+    projection: &[PlaceElem<'tcx>],\n+) -> Option<PlaceBuilder<'tcx>> {\n+    let Some((capture_index, capture)) =\n+        find_capture_matching_projections(\n+            &cx.upvars,\n+            var_hir_id,\n+            &projection,\n+        ) else {\n+        let closure_span = cx.tcx.def_span(closure_def_id);\n+        if !enable_precise_capture(cx.tcx, closure_span) {\n+            bug!(\n+                \"No associated capture found for {:?}[{:#?}] even though \\\n+                    capture_disjoint_fields isn't enabled\",\n+                var_hir_id,\n+                projection\n+            )\n+        } else {\n+            debug!(\n+                \"No associated capture found for {:?}[{:#?}]\",\n+                var_hir_id, projection,\n+            );\n+        }\n+        return None;\n+    };\n \n-            // Access the capture by accessing the field within the Closure struct.\n-            let capture_info = &cx.upvars[capture_index];\n+    // Access the capture by accessing the field within the Closure struct.\n+    let capture_info = &cx.upvars[capture_index];\n \n-            let mut upvar_resolved_place_builder = PlaceBuilder::from(capture_info.use_place);\n+    let mut upvar_resolved_place_builder = PlaceBuilder::from(capture_info.use_place);\n \n-            // We used some of the projections to build the capture itself,\n-            // now we apply the remaining to the upvar resolved place.\n-            trace!(?capture.captured_place, ?from_builder.projection);\n-            let remaining_projections = strip_prefix(\n-                capture.captured_place.place.base_ty,\n-                from_builder.projection,\n-                &capture.captured_place.place.projections,\n-            );\n-            upvar_resolved_place_builder.projection.extend(remaining_projections);\n+    // We used some of the projections to build the capture itself,\n+    // now we apply the remaining to the upvar resolved place.\n+    trace!(?capture.captured_place, ?projection);\n+    let remaining_projections = strip_prefix(\n+        capture.captured_place.place.base_ty,\n+        projection,\n+        &capture.captured_place.place.projections,\n+    );\n+    upvar_resolved_place_builder.projection.extend(remaining_projections);\n \n-            Ok(upvar_resolved_place_builder)\n-        }\n-    }\n+    Some(upvar_resolved_place_builder)\n }\n \n /// Returns projections remaining after stripping an initial prefix of HIR\n@@ -228,13 +223,14 @@ fn to_upvars_resolved_place_builder<'tcx>(\n /// Supports only HIR projection kinds that represent a path that might be\n /// captured by a closure or a generator, i.e., an `Index` or a `Subslice`\n /// projection kinds are unsupported.\n-fn strip_prefix<'tcx>(\n+fn strip_prefix<'a, 'tcx>(\n     mut base_ty: Ty<'tcx>,\n-    projections: Vec<PlaceElem<'tcx>>,\n+    projections: &'a [PlaceElem<'tcx>],\n     prefix_projections: &[HirProjection<'tcx>],\n-) -> impl Iterator<Item = PlaceElem<'tcx>> {\n+) -> impl Iterator<Item = PlaceElem<'tcx>> + 'a {\n     let mut iter = projections\n-        .into_iter()\n+        .iter()\n+        .copied()\n         // Filter out opaque casts, they are unnecessary in the prefix.\n         .filter(|elem| !matches!(elem, ProjectionElem::OpaqueCast(..)));\n     for projection in prefix_projections {\n@@ -258,21 +254,21 @@ fn strip_prefix<'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    pub(in crate::build) fn into_place(self, cx: &Builder<'_, 'tcx>) -> Place<'tcx> {\n-        if let PlaceBase::Local(local) = self.base {\n-            Place { local, projection: cx.tcx.intern_place_elems(&self.projection) }\n-        } else {\n-            self.expect_upvars_resolved(cx).into_place(cx)\n-        }\n+    pub(in crate::build) fn to_place(&self, cx: &Builder<'_, 'tcx>) -> Place<'tcx> {\n+        self.try_to_place(cx).unwrap()\n     }\n \n-    fn expect_upvars_resolved(self, cx: &Builder<'_, 'tcx>) -> PlaceBuilder<'tcx> {\n-        to_upvars_resolved_place_builder(self, cx).unwrap()\n+    /// Creates a `Place` or returns `None` if an upvar cannot be resolved\n+    pub(in crate::build) fn try_to_place(&self, cx: &Builder<'_, 'tcx>) -> Option<Place<'tcx>> {\n+        let resolved = self.resolve_upvar(cx);\n+        let builder = resolved.as_ref().unwrap_or(self);\n+        let PlaceBase::Local(local) = builder.base else { return None };\n+        let projection = cx.tcx.intern_place_elems(&builder.projection);\n+        Some(Place { local, projection })\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`.\n-    /// On success, it will return the resolved `PlaceBuilder`.\n-    /// On failure, it will return itself.\n+    /// Returns `None` if this is not an upvar.\n     ///\n     /// Upvars resolve may fail for a `PlaceBuilder` when attempting to\n     /// resolve a disjoint field whose root variable is not captured\n@@ -281,11 +277,14 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// not captured. This can happen because the final mir that will be\n     /// generated doesn't require a read for this place. Failures will only\n     /// happen inside closures.\n-    pub(in crate::build) fn try_upvars_resolved(\n-        self,\n+    pub(in crate::build) fn resolve_upvar(\n+        &self,\n         cx: &Builder<'_, 'tcx>,\n-    ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-        to_upvars_resolved_place_builder(self, cx)\n+    ) -> Option<PlaceBuilder<'tcx>> {\n+        let PlaceBase::Upvar { var_hir_id, closure_def_id } = self.base else {\n+            return None;\n+        };\n+        to_upvars_resolved_place_builder(cx, var_hir_id, closure_def_id, &self.projection)\n     }\n \n     pub(crate) fn base(&self) -> PlaceBase {\n@@ -316,6 +315,14 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         self.projection.push(elem);\n         self\n     }\n+\n+    /// Same as `.clone().project(..)` but more efficient\n+    pub(crate) fn clone_project(&self, elem: PlaceElem<'tcx>) -> Self {\n+        Self {\n+            base: self.base,\n+            projection: Vec::from_iter(self.projection.iter().copied().chain([elem])),\n+        }\n+    }\n }\n \n impl<'tcx> From<Local> for PlaceBuilder<'tcx> {\n@@ -355,7 +362,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self))\n+        block.and(place_builder.to_place(self))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -379,7 +386,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self))\n+        block.and(place_builder.to_place(self))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -474,7 +481,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place = place_builder.clone().into_place(this);\n+                    let place = place_builder.to_place(this);\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -599,22 +606,21 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let is_outermost_index = fake_borrow_temps.is_none();\n         let fake_borrow_temps = fake_borrow_temps.unwrap_or(base_fake_borrow_temps);\n \n-        let mut base_place =\n+        let base_place =\n             unpack!(block = self.expr_as_place(block, base, mutability, Some(fake_borrow_temps),));\n \n         // Making this a *fresh* temporary means we do not have to worry about\n         // the index changing later: Nothing will ever change this temporary.\n         // The \"retagging\" transformation (for Stacked Borrows) relies on this.\n         let idx = unpack!(block = self.as_temp(block, temp_lifetime, index, Mutability::Not,));\n \n-        block = self.bounds_check(block, base_place.clone(), idx, expr_span, source_info);\n+        block = self.bounds_check(block, &base_place, idx, expr_span, source_info);\n \n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n-            base_place = base_place.expect_upvars_resolved(self);\n             self.add_fake_borrows_of_base(\n-                &base_place,\n+                base_place.to_place(self),\n                 block,\n                 fake_borrow_temps,\n                 expr_span,\n@@ -628,7 +634,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn bounds_check(\n         &mut self,\n         block: BasicBlock,\n-        slice: PlaceBuilder<'tcx>,\n+        slice: &PlaceBuilder<'tcx>,\n         index: Local,\n         expr_span: Span,\n         source_info: SourceInfo,\n@@ -640,7 +646,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let lt = self.temp(bool_ty, expr_span);\n \n         // len = len(slice)\n-        self.cfg.push_assign(block, source_info, len, Rvalue::Len(slice.into_place(self)));\n+        self.cfg.push_assign(block, source_info, len, Rvalue::Len(slice.to_place(self)));\n         // lt = idx < len\n         self.cfg.push_assign(\n             block,\n@@ -658,19 +664,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     fn add_fake_borrows_of_base(\n         &mut self,\n-        base_place: &PlaceBuilder<'tcx>,\n+        base_place: Place<'tcx>,\n         block: BasicBlock,\n         fake_borrow_temps: &mut Vec<Local>,\n         expr_span: Span,\n         source_info: SourceInfo,\n     ) {\n         let tcx = self.tcx;\n-        let local = match base_place.base {\n-            PlaceBase::Local(local) => local,\n-            PlaceBase::Upvar { .. } => bug!(\"Expected PlacseBase::Local found Upvar\"),\n-        };\n \n-        let place_ty = Place::ty_from(local, &base_place.projection, &self.local_decls, tcx);\n+        let place_ty = base_place.ty(&self.local_decls, tcx);\n         if let ty::Slice(_) = place_ty.ty.kind() {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to\n@@ -680,7 +682,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 match elem {\n                     ProjectionElem::Deref => {\n                         let fake_borrow_deref_ty = Place::ty_from(\n-                            local,\n+                            base_place.local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,\n@@ -698,14 +700,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             Rvalue::Ref(\n                                 tcx.lifetimes.re_erased,\n                                 BorrowKind::Shallow,\n-                                Place { local, projection },\n+                                Place { local: base_place.local, projection },\n                             ),\n                         );\n                         fake_borrow_temps.push(fake_borrow_temp);\n                     }\n                     ProjectionElem::Index(_) => {\n                         let index_ty = Place::ty_from(\n-                            local,\n+                            base_place.local,\n                             &base_place.projection[..idx],\n                             &self.local_decls,\n                             tcx,"}, {"sha": "0814793f27790159dd3aa6400fe3a6e28b6b3b4f", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "patch": "@@ -369,8 +369,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let place_builder =\n                         unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n \n-                    if let Ok(place_builder_resolved) = place_builder.try_upvars_resolved(this) {\n-                        let mir_place = place_builder_resolved.into_place(this);\n+                    if let Some(mir_place) = place_builder.try_to_place(this) {\n                         this.cfg.push_fake_read(\n                             block,\n                             this.source_info(this.tcx.hir().span(*hir_id)),\n@@ -661,7 +660,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // by the parent itself. The mutability of the current capture\n             // is same as that of the capture in the parent closure.\n             PlaceBase::Upvar { .. } => {\n-                let enclosing_upvars_resolved = arg_place_builder.clone().into_place(this);\n+                let enclosing_upvars_resolved = arg_place_builder.to_place(this);\n \n                 match enclosing_upvars_resolved.as_ref() {\n                     PlaceRef {\n@@ -698,7 +697,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n-        let arg_place = arg_place_builder.into_place(this);\n+        let arg_place = arg_place_builder.to_place(this);\n \n         this.cfg.push_assign(\n             block,"}, {"sha": "218a26e62797dc97b0fe5f559ead5374613506de", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "patch": "@@ -358,10 +358,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         .map(|(n, ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n                             None => {\n-                                let place_builder = place_builder.clone();\n-                                this.consume_by_copy_or_move(\n-                                    place_builder.field(n, *ty).into_place(this),\n-                                )\n+                                let place = place_builder.clone_project(PlaceElem::Field(n, *ty));\n+                                this.consume_by_copy_or_move(place.to_place(this))\n                             }\n                         })\n                         .collect()"}, {"sha": "691cbee2c731911acf2997bea4754b5d54c9ee16", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "patch": "@@ -169,7 +169,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let scrutinee_place =\n             unpack!(block = self.lower_scrutinee(block, scrutinee, scrutinee_span,));\n \n-        let mut arm_candidates = self.create_match_candidates(scrutinee_place.clone(), &arms);\n+        let mut arm_candidates = self.create_match_candidates(&scrutinee_place, &arms);\n \n         let match_has_guard = arm_candidates.iter().any(|(_, candidate)| candidate.has_guard);\n         let mut candidates =\n@@ -221,8 +221,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let cause_matched_place = FakeReadCause::ForMatchedPlace(None);\n         let source_info = self.source_info(scrutinee_span);\n \n-        if let Ok(scrutinee_builder) = scrutinee_place_builder.clone().try_upvars_resolved(self) {\n-            let scrutinee_place = scrutinee_builder.into_place(self);\n+        if let Some(scrutinee_place) = scrutinee_place_builder.try_to_place(self) {\n             self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n         }\n \n@@ -232,7 +231,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Create the initial `Candidate`s for a `match` expression.\n     fn create_match_candidates<'pat>(\n         &mut self,\n-        scrutinee: PlaceBuilder<'tcx>,\n+        scrutinee: &PlaceBuilder<'tcx>,\n         arms: &'pat [ArmId],\n     ) -> Vec<(&'pat Arm<'tcx>, Candidate<'pat, 'tcx>)>\n     where\n@@ -335,7 +334,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let arm_scope = (arm.scope, arm_source_info);\n                 let match_scope = self.local_scope();\n                 self.in_scope(arm_scope, arm.lint_level, |this| {\n-                    // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                    // `try_to_place` may fail if it is unable to resolve the given\n                     // `PlaceBuilder` inside a closure. In this case, we don't want to include\n                     // a scrutinee place. `scrutinee_place_builder` will fail to be resolved\n                     // if the only match arm is a wildcard (`_`).\n@@ -346,14 +345,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     //    match foo { _ => () };\n                     // };\n                     // ```\n-                    let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n-                    let scrutinee_place: Place<'tcx>;\n-                    if let Ok(scrutinee_builder) =\n-                        scrutinee_place_builder.clone().try_upvars_resolved(this)\n-                    {\n-                        scrutinee_place = scrutinee_builder.into_place(this);\n-                        opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n-                    }\n+                    let scrutinee_place = scrutinee_place_builder.try_to_place(this);\n+                    let opt_scrutinee_place =\n+                        scrutinee_place.as_ref().map(|place| (Some(place), scrutinee_span));\n                     let scope = this.declare_bindings(\n                         None,\n                         arm.span,\n@@ -592,7 +586,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             while let Some(next) = {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n-                    // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                    // `try_to_place` may fail if it is unable to resolve the given\n                     // `PlaceBuilder` inside a closure. In this case, we don't want to include\n                     // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n                     // assignments. This is because a closure only captures the precise places\n@@ -606,9 +600,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     //    let (v1, v2) = foo;\n                     // };\n                     // ```\n-                    if let Ok(match_pair_resolved) = initializer.clone().try_upvars_resolved(self) {\n-                        let place = match_pair_resolved.into_place(self);\n-\n+                    if let Some(place) = initializer.try_to_place(self) {\n                         let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n                             VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n                         )))) = self.local_decls[local].local_info else {\n@@ -1345,15 +1337,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 bug!(\"Or-patterns should have been sorted to the end\");\n             };\n             let or_span = match_pair.pattern.span;\n-            let place = match_pair.place;\n \n             first_candidate.visit_leaves(|leaf_candidate| {\n                 self.test_or_pattern(\n                     leaf_candidate,\n                     &mut otherwise,\n                     pats,\n                     or_span,\n-                    place.clone(),\n+                    &match_pair.place,\n                     fake_borrows,\n                 );\n             });\n@@ -1381,7 +1372,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         otherwise: &mut Option<BasicBlock>,\n         pats: &'pat [Box<Pat<'tcx>>],\n         or_span: Span,\n-        place: PlaceBuilder<'tcx>,\n+        place: &PlaceBuilder<'tcx>,\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n     ) {\n         debug!(\"candidate={:#?}\\npats={:#?}\", candidate, pats);\n@@ -1599,10 +1590,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         // Insert a Shallow borrow of any places that is switched on.\n-        if let Some(fb) = fake_borrows && let Ok(match_place_resolved) =\n-            match_place.clone().try_upvars_resolved(self)\n+        if let Some(fb) = fake_borrows\n+            && let Some(resolved_place) = match_place.try_to_place(self)\n         {\n-            let resolved_place = match_place_resolved.into_place(self);\n             fb.insert(resolved_place);\n         }\n \n@@ -1621,7 +1611,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // encounter a candidate where the test is not relevant; at\n         // that point, we stop sorting.\n         while let Some(candidate) = candidates.first_mut() {\n-            let Some(idx) = self.sort_candidate(&match_place.clone(), &test, candidate) else {\n+            let Some(idx) = self.sort_candidate(&match_place, &test, candidate) else {\n                 break;\n             };\n             let (candidate, rest) = candidates.split_first_mut().unwrap();\n@@ -1690,7 +1680,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             target_blocks\n         };\n \n-        self.perform_test(span, scrutinee_span, block, match_place, &test, make_target_blocks);\n+        self.perform_test(span, scrutinee_span, block, &match_place, &test, make_target_blocks);\n     }\n \n     /// Determine the fake borrows that are needed from a set of places that\n@@ -1796,12 +1786,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             false,\n             &mut [&mut guard_candidate, &mut otherwise_candidate],\n         );\n-        let mut opt_expr_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n-        let expr_place: Place<'tcx>;\n-        if let Ok(expr_builder) = expr_place_builder.try_upvars_resolved(self) {\n-            expr_place = expr_builder.into_place(self);\n-            opt_expr_place = Some((Some(&expr_place), expr_span));\n-        }\n+        let expr_place = expr_place_builder.try_to_place(self);\n+        let opt_expr_place = expr_place.as_ref().map(|place| (Some(place), expr_span));\n         let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n         self.break_for_else(otherwise_post_guard_block, else_target, self.source_info(expr_span));\n "}, {"sha": "f6b1955fdec4d89814844bbedf3845de14616f83", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "patch": "@@ -73,8 +73,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             {\n                 existing_bindings.extend_from_slice(&new_bindings);\n                 mem::swap(&mut candidate.bindings, &mut existing_bindings);\n-                candidate.subcandidates =\n-                    self.create_or_subcandidates(candidate, place.clone(), pats);\n+                candidate.subcandidates = self.create_or_subcandidates(candidate, &place, pats);\n                 return true;\n             }\n \n@@ -127,7 +126,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn create_or_subcandidates<'pat>(\n         &mut self,\n         candidate: &Candidate<'pat, 'tcx>,\n-        place: PlaceBuilder<'tcx>,\n+        place: &PlaceBuilder<'tcx>,\n         pats: &'pat [Box<Pat<'tcx>>],\n     ) -> Vec<Candidate<'pat, 'tcx>> {\n         pats.iter()\n@@ -156,10 +155,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription: thir::Ascription { ref annotation, variance },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n-                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n+                if let Some(source) = match_pair.place.try_to_place(self) {\n                     candidate.ascriptions.push(Ascription {\n                         annotation: annotation.clone(),\n-                        source: place_resolved.into_place(self),\n+                        source,\n                         variance,\n                     });\n                 }\n@@ -183,10 +182,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ref subpattern,\n                 is_primary: _,\n             } => {\n-                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n+                if let Some(source) = match_pair.place.try_to_place(self) {\n                     candidate.bindings.push(Binding {\n                         span: match_pair.pattern.span,\n-                        source: place_resolved.into_place(self),\n+                        source,\n                         var_id: var,\n                         binding_mode: mode,\n                     });"}, {"sha": "58513bde2aa2a09fdcff2d16b02ec26bd2af02e4", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "patch": "@@ -150,11 +150,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         match_start_span: Span,\n         scrutinee_span: Span,\n         block: BasicBlock,\n-        place_builder: PlaceBuilder<'tcx>,\n+        place_builder: &PlaceBuilder<'tcx>,\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n-        let place = place_builder.into_place(self);\n+        let place = place_builder.to_place(self);\n         let place_ty = place.ty(&self.local_decls, self.tcx);\n         debug!(?place, ?place_ty,);\n \n@@ -760,7 +760,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let downcast_place = match_pair.place.downcast(adt_def, variant_index); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n-            let place = downcast_place.clone().field(subpattern.field, subpattern.pattern.ty);\n+            let place = downcast_place\n+                .clone_project(PlaceElem::Field(subpattern.field, subpattern.pattern.ty));\n             // e.g., `(x as Variant).0 @ P1`\n             MatchPair::new(place, &subpattern.pattern, self)\n         });"}, {"sha": "bd435f9ab0095a4b86e10703a3127c31bbd068b5", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80b3c6dbde3ff89a44f8eaa63e08054398b30ecd/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=80b3c6dbde3ff89a44f8eaa63e08054398b30ecd", "patch": "@@ -18,7 +18,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         subpatterns\n             .iter()\n             .map(|fieldpat| {\n-                let place = place.clone().field(fieldpat.field, fieldpat.pattern.ty);\n+                let place =\n+                    place.clone_project(PlaceElem::Field(fieldpat.field, fieldpat.pattern.ty));\n                 MatchPair::new(place, &fieldpat.pattern, self)\n             })\n             .collect()\n@@ -33,26 +34,24 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         suffix: &'pat [Box<Pat<'tcx>>],\n     ) {\n         let tcx = self.tcx;\n-        let (min_length, exact_size) =\n-            if let Ok(place_resolved) = place.clone().try_upvars_resolved(self) {\n-                match place_resolved.into_place(self).ty(&self.local_decls, tcx).ty.kind() {\n-                    ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n-                    _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n-                }\n-            } else {\n-                ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n-            };\n+        let (min_length, exact_size) = if let Some(place_resolved) = place.try_to_place(self) {\n+            match place_resolved.ty(&self.local_decls, tcx).ty.kind() {\n+                ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n+                _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n+            }\n+        } else {\n+            ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n+        };\n \n         match_pairs.extend(prefix.iter().enumerate().map(|(idx, subpattern)| {\n             let elem =\n                 ProjectionElem::ConstantIndex { offset: idx as u64, min_length, from_end: false };\n-            let place = place.clone().project(elem);\n-            MatchPair::new(place, subpattern, self)\n+            MatchPair::new(place.clone_project(elem), subpattern, self)\n         }));\n \n         if let Some(subslice_pat) = opt_slice {\n             let suffix_len = suffix.len() as u64;\n-            let subslice = place.clone().project(ProjectionElem::Subslice {\n+            let subslice = place.clone_project(PlaceElem::Subslice {\n                 from: prefix.len() as u64,\n                 to: if exact_size { min_length - suffix_len } else { suffix_len },\n                 from_end: !exact_size,\n@@ -67,7 +66,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 min_length,\n                 from_end: !exact_size,\n             };\n-            let place = place.clone().project(elem);\n+            let place = place.clone_project(elem);\n             MatchPair::new(place, subpattern, self)\n         }));\n     }\n@@ -97,15 +96,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n     pub(in crate::build) fn new(\n-        place: PlaceBuilder<'tcx>,\n+        mut place: PlaceBuilder<'tcx>,\n         pattern: &'pat Pat<'tcx>,\n         cx: &Builder<'_, 'tcx>,\n     ) -> MatchPair<'pat, 'tcx> {\n         // Force the place type to the pattern's type.\n         // FIXME(oli-obk): can we use this to simplify slice/array pattern hacks?\n-        let mut place = match place.try_upvars_resolved(cx) {\n-            Ok(val) | Err(val) => val,\n-        };\n+        if let Some(resolved) = place.resolve_upvar(cx) {\n+            place = resolved;\n+        }\n \n         // Only add the OpaqueCast projection if the given place is an opaque type and the\n         // expected type from the pattern is not."}]}