{"sha": "fd69365ead71e6ee0ca2990a926a163df5076f2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNjkzNjVlYWQ3MWU2ZWUwY2EyOTkwYTkyNmExNjNkZjUwNzZmMmQ=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2014-08-02T05:21:02Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2014-08-02T05:21:02Z"}, "message": "Rewrite read_u32v_be() and write_u32_be() to make sure that all memory access is properly aligned", "tree": {"sha": "e6be138c79f7cf1bccce74e41942d219cdeb1774", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e6be138c79f7cf1bccce74e41942d219cdeb1774"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd69365ead71e6ee0ca2990a926a163df5076f2d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd69365ead71e6ee0ca2990a926a163df5076f2d", "html_url": "https://github.com/rust-lang/rust/commit/fd69365ead71e6ee0ca2990a926a163df5076f2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd69365ead71e6ee0ca2990a926a163df5076f2d/comments", "author": null, "committer": null, "parents": [{"sha": "d7cfc34a222c0280670690be0d618b67014cc28d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7cfc34a222c0280670690be0d618b67014cc28d", "html_url": "https://github.com/rust-lang/rust/commit/d7cfc34a222c0280670690be0d618b67014cc28d"}], "stats": {"total": 32, "additions": 17, "deletions": 15}, "files": [{"sha": "d24ff49c61558c0a8ca76a0982508c9c550c55d7", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fd69365ead71e6ee0ca2990a926a163df5076f2d/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd69365ead71e6ee0ca2990a926a163df5076f2d/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=fd69365ead71e6ee0ca2990a926a163df5076f2d", "patch": "@@ -22,26 +22,28 @@ use serialize::hex::ToHex;\n /// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n /// format.\n fn write_u32_be(dst: &mut[u8], input: u32) {\n-    use std::mem::to_be32;\n-    assert!(dst.len() == 4);\n-    unsafe {\n-        let x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n-        *x = to_be32(input);\n-    }\n+    dst[0] = (input >> 24) as u8;\n+    dst[1] = (input >> 16) as u8;\n+    dst[2] = (input >> 8) as u8;\n+    dst[3] = input as u8;\n+}\n+\n+/// Read the value of a vector of bytes as a u32 value in big-endian format.\n+fn read_u32_be(input: &[u8]) -> u32 {\n+    return\n+        (input[0] as u32) << 24 |\n+        (input[1] as u32) << 16 |\n+        (input[2] as u32) << 8 |\n+        (input[3] as u32);\n }\n \n /// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n-    use std::mem::to_be32;\n     assert!(dst.len() * 4 == input.len());\n-    unsafe {\n-        let mut x = dst.unsafe_mut_ref(0) as *mut _ as *mut u32;\n-        let mut y = input.unsafe_ref(0) as *const _ as *const u32;\n-        for _ in range(0, dst.len()) {\n-            *x = to_be32(*y);\n-            x = x.offset(1);\n-            y = y.offset(1);\n-        }\n+    let mut pos = 0u;\n+    for chunk in input.chunks(4) {\n+        dst[pos] = read_u32_be(chunk);\n+        pos += 1;\n     }\n }\n "}]}