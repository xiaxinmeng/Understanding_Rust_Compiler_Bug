{"sha": "8fa68f1e089bc18d3924a19a21853bc4848f8959", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYTY4ZjFlMDg5YmMxOGQzOTI0YTE5YTIxODUzYmM0ODQ4Zjg5NTk=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-05-11T21:36:10Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-05-11T21:36:10Z"}, "message": "Merge pull request #913 from oli-obk/assign_ops\n\nsuggest `a op= b` over `a = a op b`", "tree": {"sha": "2552a8516cf5a1059cc1b8b5a6c762a51c933f93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2552a8516cf5a1059cc1b8b5a6c762a51c933f93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fa68f1e089bc18d3924a19a21853bc4848f8959", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa68f1e089bc18d3924a19a21853bc4848f8959", "html_url": "https://github.com/rust-lang/rust/commit/8fa68f1e089bc18d3924a19a21853bc4848f8959", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fa68f1e089bc18d3924a19a21853bc4848f8959/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c170aa262a34cf884fa2806513a27bfa07fcb8be", "url": "https://api.github.com/repos/rust-lang/rust/commits/c170aa262a34cf884fa2806513a27bfa07fcb8be", "html_url": "https://github.com/rust-lang/rust/commit/c170aa262a34cf884fa2806513a27bfa07fcb8be"}, {"sha": "b0d008bc9d0e2efd92c29da9c40db768b864b52b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0d008bc9d0e2efd92c29da9c40db768b864b52b", "html_url": "https://github.com/rust-lang/rust/commit/b0d008bc9d0e2efd92c29da9c40db768b864b52b"}], "stats": {"total": 237, "additions": 234, "deletions": 3}, "files": [{"sha": "9591e207a8860e40316886bc0c0dee3c52e3e083", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fa68f1e089bc18d3924a19a21853bc4848f8959/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/8fa68f1e089bc18d3924a19a21853bc4848f8959/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=8fa68f1e089bc18d3924a19a21853bc4848f8959", "patch": "@@ -76,6 +76,8 @@ All notable changes to this project will be documented in this file.\n [`absurd_extreme_comparisons`]: https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons\n [`almost_swapped`]: https://github.com/Manishearth/rust-clippy/wiki#almost_swapped\n [`approx_constant`]: https://github.com/Manishearth/rust-clippy/wiki#approx_constant\n+[`assign_op_pattern`]: https://github.com/Manishearth/rust-clippy/wiki#assign_op_pattern\n+[`assign_ops`]: https://github.com/Manishearth/rust-clippy/wiki#assign_ops\n [`bad_bit_mask`]: https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask\n [`blacklisted_name`]: https://github.com/Manishearth/rust-clippy/wiki#blacklisted_name\n [`block_in_if_condition_expr`]: https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr"}, {"sha": "658e2eb63a505725a916ab0772f2840b62d3dd39", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8fa68f1e089bc18d3924a19a21853bc4848f8959/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/8fa68f1e089bc18d3924a19a21853bc4848f8959/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=8fa68f1e089bc18d3924a19a21853bc4848f8959", "patch": "@@ -17,13 +17,15 @@ Table of contents:\n \n ## Lints\n \n-There are 147 lints included in this crate:\n+There are 149 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n [absurd_extreme_comparisons](https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons)             | warn    | a comparison involving a maximum or minimum value involves a case that is always true or always false\n [almost_swapped](https://github.com/Manishearth/rust-clippy/wiki#almost_swapped)                                     | warn    | `foo = bar; bar = foo` sequence\n [approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                                   | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n+[assign_op_pattern](https://github.com/Manishearth/rust-clippy/wiki#assign_op_pattern)                               | warn    | assigning the result of an operation on a variable to that same variable\n+[assign_ops](https://github.com/Manishearth/rust-clippy/wiki#assign_ops)                                             | allow   | Any assignment operation\n [bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                         | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n [blacklisted_name](https://github.com/Manishearth/rust-clippy/wiki#blacklisted_name)                                 | warn    | usage of a blacklisted/placeholder name\n [block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)             | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`"}, {"sha": "2b1aec83e4cc293f24871cc684672c88d08847e3", "filename": "src/assign_ops.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/8fa68f1e089bc18d3924a19a21853bc4848f8959/src%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa68f1e089bc18d3924a19a21853bc4848f8959/src%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fassign_ops.rs?ref=8fa68f1e089bc18d3924a19a21853bc4848f8959", "patch": "@@ -0,0 +1,158 @@\n+use rustc::hir;\n+use rustc::lint::*;\n+use utils::{span_lint_and_then, span_lint, snippet_opt, SpanlessEq, get_trait_def_id, implements_trait};\n+\n+/// **What it does:** This lint checks for `+=` operations and similar\n+///\n+/// **Why is this bad?** Projects with many developers from languages without those operations\n+///                      may find them unreadable and not worth their weight\n+///\n+/// **Known problems:** Types implementing `OpAssign` don't necessarily implement `Op`\n+///\n+/// **Example:**\n+/// ```\n+/// a += 1;\n+/// ```\n+declare_restriction_lint! {\n+    pub ASSIGN_OPS,\n+    \"Any assignment operation\"\n+}\n+\n+/// **What it does:** Check for `a = a op b` or `a = b commutative_op a` patterns\n+///\n+/// **Why is this bad?** These can be written as the shorter `a op= b`\n+///\n+/// **Known problems:** While forbidden by the spec, `OpAssign` traits may have implementations that differ from the regular `Op` impl\n+///\n+/// **Example:**\n+///\n+/// ```\n+/// let mut a = 5;\n+/// ...\n+/// a = a + b;\n+/// ```\n+declare_lint! {\n+    pub ASSIGN_OP_PATTERN,\n+    Warn,\n+    \"assigning the result of an operation on a variable to that same variable\"\n+}\n+\n+#[derive(Copy, Clone, Default)]\n+pub struct AssignOps;\n+\n+impl LintPass for AssignOps {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(ASSIGN_OPS, ASSIGN_OP_PATTERN)\n+    }\n+}\n+\n+impl LateLintPass for AssignOps {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+        match expr.node {\n+            hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n+                if let (Some(l), Some(r)) = (snippet_opt(cx, lhs.span), snippet_opt(cx, rhs.span)) {\n+                    span_lint_and_then(cx,\n+                                       ASSIGN_OPS,\n+                                       expr.span,\n+                                       \"assign operation detected\",\n+                                       |db| {\n+                                           match rhs.node {\n+                                               hir::ExprBinary(op2, _, _) if op2 != op => {\n+                                                   db.span_suggestion(expr.span,\n+                                                                       \"replace it with\",\n+                                                                       format!(\"{} = {} {} ({})\", l, l, op.node.as_str(), r));\n+                                               },\n+                                               _ => {\n+                                                   db.span_suggestion(expr.span,\n+                                                                       \"replace it with\",\n+                                                                       format!(\"{} = {} {} {}\", l, l, op.node.as_str(), r));\n+                                               }\n+                                           }\n+                                       });\n+                } else {\n+                    span_lint(cx,\n+                              ASSIGN_OPS,\n+                              expr.span,\n+                              \"assign operation detected\");\n+                }\n+            },\n+            hir::ExprAssign(ref assignee, ref e) => {\n+                if let hir::ExprBinary(op, ref l, ref r) = e.node {\n+                    let lint = |assignee: &hir::Expr, rhs: &hir::Expr| {\n+                        let ty = cx.tcx.expr_ty(assignee);\n+                        if ty.walk_shallow().next().is_some() {\n+                            return; // implements_trait does not work with generics\n+                        }\n+                        let rty = cx.tcx.expr_ty(rhs);\n+                        if rty.walk_shallow().next().is_some() {\n+                            return; // implements_trait does not work with generics\n+                        }\n+                        macro_rules! ops {\n+                            ($op:expr, $cx:expr, $ty:expr, $rty:expr, $($trait_name:ident:$full_trait_name:ident),+) => {\n+                                match $op {\n+                                    $(hir::$full_trait_name => {\n+                                        let [krate, module] = ::utils::paths::OPS_MODULE;\n+                                        let path = [krate, module, concat!(stringify!($trait_name), \"Assign\")];\n+                                        let trait_id = if let Some(trait_id) = get_trait_def_id($cx, &path) {\n+                                            trait_id\n+                                        } else {\n+                                            return; // useless if the trait doesn't exist\n+                                        };\n+                                        implements_trait($cx, $ty, trait_id, vec![$rty])\n+                                    },)*\n+                                    _ => false,\n+                                }\n+                            }\n+                        }\n+                        if ops!(op.node, cx, ty, rty, Add:BiAdd,\n+                                                      Sub:BiSub,\n+                                                      Mul:BiMul,\n+                                                      Div:BiDiv,\n+                                                      Rem:BiRem,\n+                                                      And:BiAnd,\n+                                                      Or:BiOr,\n+                                                      BitAnd:BiBitAnd,\n+                                                      BitOr:BiBitOr,\n+                                                      BitXor:BiBitXor,\n+                                                      Shr:BiShr,\n+                                                      Shl:BiShl\n+                        ) {\n+                            if let (Some(snip_a), Some(snip_r)) = (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span)) {\n+                                span_lint_and_then(cx,\n+                                                   ASSIGN_OP_PATTERN,\n+                                                   expr.span,\n+                                                   \"manual implementation of an assign operation\",\n+                                                   |db| {\n+                                                       db.span_suggestion(expr.span,\n+                                                                           \"replace it with\",\n+                                                                           format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r));\n+                                                   });\n+                            } else {\n+                                span_lint(cx,\n+                                          ASSIGN_OP_PATTERN,\n+                                          expr.span,\n+                                          \"manual implementation of an assign operation\");\n+                            }\n+                        }\n+                    };\n+                    // a = a op b\n+                    if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, l) {\n+                        lint(assignee, r);\n+                    }\n+                    // a = b commutative_op a\n+                    if SpanlessEq::new(cx).ignore_fn().eq_expr(assignee, r) {\n+                        match op.node {\n+                            hir::BiAdd | hir::BiMul |\n+                            hir::BiAnd | hir::BiOr |\n+                            hir::BiBitXor | hir::BiBitAnd | hir::BiBitOr => {\n+                                lint(assignee, l);\n+                            },\n+                            _ => {},\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+}"}, {"sha": "37464e766b0e20ba45bea8136f28d6dc87e7bc23", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8fa68f1e089bc18d3924a19a21853bc4848f8959/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa68f1e089bc18d3924a19a21853bc4848f8959/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=8fa68f1e089bc18d3924a19a21853bc4848f8959", "patch": "@@ -7,7 +7,6 @@\n #![feature(question_mark)]\n #![feature(stmt_expr_attributes)]\n #![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n-#![allow(float_arithmetic, integer_arithmetic)]\n \n extern crate rustc_driver;\n extern crate getopts;\n@@ -203,6 +202,7 @@ pub mod utils;\n pub mod approx_const;\n pub mod arithmetic;\n pub mod array_indexing;\n+pub mod assign_ops;\n pub mod attrs;\n pub mod bit_mask;\n pub mod blacklisted_name;\n@@ -394,10 +394,12 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box unsafe_removed_from_name::UnsafeNameRemoval);\n     reg.register_late_lint_pass(box mem_forget::MemForget);\n     reg.register_late_lint_pass(box arithmetic::Arithmetic::default());\n+    reg.register_late_lint_pass(box assign_ops::AssignOps);\n \n     reg.register_lint_group(\"clippy_restrictions\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n         arithmetic::INTEGER_ARITHMETIC,\n+        assign_ops::ASSIGN_OPS,\n     ]);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n@@ -432,6 +434,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_lint_group(\"clippy\", vec![\n         approx_const::APPROX_CONSTANT,\n         array_indexing::OUT_OF_BOUNDS_INDEXING,\n+        assign_ops::ASSIGN_OP_PATTERN,\n         attrs::DEPRECATED_SEMVER,\n         attrs::INLINE_ALWAYS,\n         bit_mask::BAD_BIT_MASK,"}, {"sha": "2e6ceb5009697ee3e394a3bf329522237f771b3d", "filename": "src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fa68f1e089bc18d3924a19a21853bc4848f8959/src%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa68f1e089bc18d3924a19a21853bc4848f8959/src%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fpaths.rs?ref=8fa68f1e089bc18d3924a19a21853bc4848f8959", "patch": "@@ -29,6 +29,7 @@ pub const LINKED_LIST: [&'static str; 3] = [\"collections\", \"linked_list\", \"Linke\n pub const MEM_FORGET: [&'static str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MUTEX: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const OPEN_OPTIONS: [&'static str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n+pub const OPS_MODULE: [&'static str; 2] = [\"core\", \"ops\"];\n pub const OPTION: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n pub const RANGE: [&'static str; 3] = [\"core\", \"ops\", \"Range\"];\n pub const RANGE_FROM: [&'static str; 3] = [\"core\", \"ops\", \"RangeFrom\"];"}, {"sha": "84d868ecfcc4e6a749a537f3f753d0bbf69e1e2b", "filename": "tests/compile-fail/assign_ops.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/8fa68f1e089bc18d3924a19a21853bc4848f8959/tests%2Fcompile-fail%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa68f1e089bc18d3924a19a21853bc4848f8959/tests%2Fcompile-fail%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fassign_ops.rs?ref=8fa68f1e089bc18d3924a19a21853bc4848f8959", "patch": "@@ -0,0 +1,65 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#[deny(assign_ops)]\n+#[allow(unused_assignments)]\n+fn main() {\n+    let mut i = 1i32;\n+    i += 2; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i + 2\n+    i -= 6; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i - 6\n+    i *= 5; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i * 5\n+    i /= 32; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i / 32\n+    i %= 42; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i % 42\n+    i >>= i; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i >> i\n+    i <<= 9 + 6 - 7; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i << (9 + 6 - 7)\n+}\n+\n+#[allow(dead_code, unused_assignments)]\n+#[deny(assign_op_pattern)]\n+fn bla() {\n+    let mut a = 5;\n+    a = a + 1; //~ ERROR manual implementation of an assign operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a += 1\n+    a = 1 + a; //~ ERROR manual implementation of an assign operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a += 1\n+    a = a - 1; //~ ERROR manual implementation of an assign operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a -= 1\n+    a = a * 99; //~ ERROR manual implementation of an assign operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a *= 99\n+    a = 42 * a; //~ ERROR manual implementation of an assign operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a *= 42\n+    a = a / 2; //~ ERROR manual implementation of an assign operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a /= 2\n+    a = a % 5; //~ ERROR manual implementation of an assign operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a %= 5\n+    a = a & 1; //~ ERROR manual implementation of an assign operation\n+    //~^ HELP replace it with\n+    //~| SUGGESTION a &= 1\n+    a = 1 - a;\n+    a = 5 / a;\n+    a = 42 % a;\n+    a = 6 << a;\n+    let mut s = String::new();\n+    s = s + \"bla\";\n+}"}, {"sha": "542b6db4abb4e9d0028c6d469a2a7dfda1cc71f1", "filename": "tests/compile-fail/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fa68f1e089bc18d3924a19a21853bc4848f8959/tests%2Fcompile-fail%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa68f1e089bc18d3924a19a21853bc4848f8959/tests%2Fcompile-fail%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstrings.rs?ref=8fa68f1e089bc18d3924a19a21853bc4848f8959", "patch": "@@ -65,6 +65,6 @@ fn main() {\n \n     // the add is only caught for String\n     let mut x = 1;\n-    x = x + 1;\n+    x = x + 1; //~ WARN assign_op_pattern\n     assert_eq!(2, x);\n }"}]}