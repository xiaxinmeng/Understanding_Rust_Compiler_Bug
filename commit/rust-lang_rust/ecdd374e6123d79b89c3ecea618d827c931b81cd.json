{"sha": "ecdd374e6123d79b89c3ecea618d827c931b81cd", "node_id": "C_kwDOAAsO6NoAKGVjZGQzNzRlNjEyM2Q3OWI4OWMzZWNlYTYxOGQ4MjdjOTMxYjgxY2Q", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T07:35:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T07:35:22Z"}, "message": "Auto merge of #97863 - JakobDegen:bitset-choice, r=nnethercote\n\n`BitSet` related perf improvements\n\nThis commit makes two changes:\n 1. Changes `MaybeLiveLocals` to use `ChunkedBitSet`\n 2. Overrides the `fold` method for the iterator for `ChunkedBitSet`\n\nI have local benchmarks verifying that each of these changes individually yield significant perf improvements to #96451 . I'm hoping this will be true outside of that context too. If that is not the case, I'll try to gate things on where they help as needed\n\nr? `@nnethercote` who I believe was working on closely related things, cc `@tmiasko` because of the destprop pr", "tree": {"sha": "d216370927b0464750c42b6e2f3cd89b0e21a835", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d216370927b0464750c42b6e2f3cd89b0e21a835"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecdd374e6123d79b89c3ecea618d827c931b81cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdd374e6123d79b89c3ecea618d827c931b81cd", "html_url": "https://github.com/rust-lang/rust/commit/ecdd374e6123d79b89c3ecea618d827c931b81cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecdd374e6123d79b89c3ecea618d827c931b81cd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0423e06ca96067ea6f166921a7905ecb339eb155", "url": "https://api.github.com/repos/rust-lang/rust/commits/0423e06ca96067ea6f166921a7905ecb339eb155", "html_url": "https://github.com/rust-lang/rust/commit/0423e06ca96067ea6f166921a7905ecb339eb155"}, {"sha": "bc7cd2f351ab35e0830563858e827a2d397d176d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7cd2f351ab35e0830563858e827a2d397d176d", "html_url": "https://github.com/rust-lang/rust/commit/bc7cd2f351ab35e0830563858e827a2d397d176d"}], "stats": {"total": 164, "additions": 141, "deletions": 23}, "files": [{"sha": "f2eaef1e149c02670897317e871e3674181f58bc", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 78, "deletions": 5, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=ecdd374e6123d79b89c3ecea618d827c931b81cd", "patch": "@@ -681,6 +681,48 @@ impl<T: Idx> BitRelations<HybridBitSet<T>> for ChunkedBitSet<T> {\n     }\n }\n \n+impl<T: Idx> BitRelations<ChunkedBitSet<T>> for BitSet<T> {\n+    fn union(&mut self, other: &ChunkedBitSet<T>) -> bool {\n+        sequential_update(|elem| self.insert(elem), other.iter())\n+    }\n+\n+    fn subtract(&mut self, _other: &ChunkedBitSet<T>) -> bool {\n+        unimplemented!(\"implement if/when necessary\");\n+    }\n+\n+    fn intersect(&mut self, other: &ChunkedBitSet<T>) -> bool {\n+        assert_eq!(self.domain_size(), other.domain_size);\n+        let mut changed = false;\n+        for (i, chunk) in other.chunks.iter().enumerate() {\n+            let mut words = &mut self.words[i * CHUNK_WORDS..];\n+            if words.len() > CHUNK_WORDS {\n+                words = &mut words[..CHUNK_WORDS];\n+            }\n+            match chunk {\n+                Chunk::Zeros(..) => {\n+                    for word in words {\n+                        if *word != 0 {\n+                            changed = true;\n+                            *word = 0;\n+                        }\n+                    }\n+                }\n+                Chunk::Ones(..) => (),\n+                Chunk::Mixed(_, _, data) => {\n+                    for (i, word) in words.iter_mut().enumerate() {\n+                        let new_val = *word & data[i];\n+                        if new_val != *word {\n+                            changed = true;\n+                            *word = new_val;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        changed\n+    }\n+}\n+\n impl<T> Clone for ChunkedBitSet<T> {\n     fn clone(&self) -> Self {\n         ChunkedBitSet {\n@@ -743,6 +785,41 @@ impl<'a, T: Idx> Iterator for ChunkedBitIter<'a, T> {\n         }\n         None\n     }\n+\n+    fn fold<B, F>(mut self, mut init: B, mut f: F) -> B\n+    where\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        // If `next` has already been called, we may not be at the start of a chunk, so we first\n+        // advance the iterator to the start of the next chunk, before proceeding in chunk sized\n+        // steps.\n+        while self.index % CHUNK_BITS != 0 {\n+            let Some(item) = self.next() else {\n+                return init\n+            };\n+            init = f(init, item);\n+        }\n+        let start_chunk = self.index / CHUNK_BITS;\n+        let chunks = &self.bitset.chunks[start_chunk..];\n+        for (i, chunk) in chunks.iter().enumerate() {\n+            let base = (start_chunk + i) * CHUNK_BITS;\n+            match chunk {\n+                Chunk::Zeros(_) => (),\n+                Chunk::Ones(limit) => {\n+                    for j in 0..(*limit as usize) {\n+                        init = f(init, T::new(base + j));\n+                    }\n+                }\n+                Chunk::Mixed(_, _, words) => {\n+                    init = BitIter::new(&**words).fold(init, |val, mut item: T| {\n+                        item.increment_by(base);\n+                        f(val, item)\n+                    });\n+                }\n+            }\n+        }\n+        init\n+    }\n }\n \n impl Chunk {\n@@ -799,11 +876,7 @@ fn sequential_update<T: Idx>(\n     mut self_update: impl FnMut(T) -> bool,\n     it: impl Iterator<Item = T>,\n ) -> bool {\n-    let mut changed = false;\n-    for elem in it {\n-        changed |= self_update(elem);\n-    }\n-    changed\n+    it.fold(false, |changed, elem| self_update(elem) | changed)\n }\n \n // Optimization of intersection for SparseBitSet that's generic"}, {"sha": "a58133e4aedfdce7b846a12d93579eb0f91d35d2", "filename": "compiler/rustc_index/src/bit_set/tests.rs", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set%2Ftests.rs?ref=ecdd374e6123d79b89c3ecea618d827c931b81cd", "patch": "@@ -342,38 +342,82 @@ fn chunked_bitset() {\n     b10000b.assert_valid();\n }\n \n+fn with_elements_chunked(elements: &[usize], domain_size: usize) -> ChunkedBitSet<usize> {\n+    let mut s = ChunkedBitSet::new_empty(domain_size);\n+    for &e in elements {\n+        assert!(s.insert(e));\n+    }\n+    s\n+}\n+\n+fn with_elements_standard(elements: &[usize], domain_size: usize) -> BitSet<usize> {\n+    let mut s = BitSet::new_empty(domain_size);\n+    for &e in elements {\n+        assert!(s.insert(e));\n+    }\n+    s\n+}\n+\n+#[test]\n+fn chunked_bitset_into_bitset_operations() {\n+    let a = vec![1, 5, 7, 11, 15, 2000, 3000];\n+    let b = vec![3, 4, 11, 3000, 4000];\n+    let aub = vec![1, 3, 4, 5, 7, 11, 15, 2000, 3000, 4000];\n+    let aib = vec![11, 3000];\n+\n+    let b = with_elements_chunked(&b, 9876);\n+\n+    let mut union = with_elements_standard(&a, 9876);\n+    assert!(union.union(&b));\n+    assert!(!union.union(&b));\n+    assert!(union.iter().eq(aub.iter().copied()));\n+\n+    let mut intersection = with_elements_standard(&a, 9876);\n+    assert!(intersection.intersect(&b));\n+    assert!(!intersection.intersect(&b));\n+    assert!(intersection.iter().eq(aib.iter().copied()));\n+}\n+\n #[test]\n fn chunked_bitset_iter() {\n-    fn with_elements(elements: &[usize], domain_size: usize) -> ChunkedBitSet<usize> {\n-        let mut s = ChunkedBitSet::new_empty(domain_size);\n-        for &e in elements {\n-            s.insert(e);\n+    fn check_iter(bit: &ChunkedBitSet<usize>, vec: &Vec<usize>) {\n+        // Test collecting via both `.next()` and `.fold()` calls, to make sure both are correct\n+        let mut collect_next = Vec::new();\n+        let mut bit_iter = bit.iter();\n+        while let Some(item) = bit_iter.next() {\n+            collect_next.push(item);\n         }\n-        s\n+        assert_eq!(vec, &collect_next);\n+\n+        let collect_fold = bit.iter().fold(Vec::new(), |mut v, item| {\n+            v.push(item);\n+            v\n+        });\n+        assert_eq!(vec, &collect_fold);\n     }\n \n     // Empty\n     let vec: Vec<usize> = Vec::new();\n-    let bit = with_elements(&vec, 9000);\n-    assert_eq!(vec, bit.iter().collect::<Vec<_>>());\n+    let bit = with_elements_chunked(&vec, 9000);\n+    check_iter(&bit, &vec);\n \n     // Filled\n     let n = 10000;\n     let vec: Vec<usize> = (0..n).collect();\n-    let bit = with_elements(&vec, n);\n-    assert_eq!(vec, bit.iter().collect::<Vec<_>>());\n+    let bit = with_elements_chunked(&vec, n);\n+    check_iter(&bit, &vec);\n \n     // Filled with trailing zeros\n     let n = 10000;\n     let vec: Vec<usize> = (0..n).collect();\n-    let bit = with_elements(&vec, 2 * n);\n-    assert_eq!(vec, bit.iter().collect::<Vec<_>>());\n+    let bit = with_elements_chunked(&vec, 2 * n);\n+    check_iter(&bit, &vec);\n \n     // Mixed\n     let n = 12345;\n     let vec: Vec<usize> = vec![0, 1, 2, 2010, 2047, 2099, 6000, 6002, 6004];\n-    let bit = with_elements(&vec, n);\n-    assert_eq!(vec, bit.iter().collect::<Vec<_>>());\n+    let bit = with_elements_chunked(&vec, n);\n+    check_iter(&bit, &vec);\n }\n \n #[test]"}, {"sha": "35febb5d330601427cfeb3997b49b49d1c91069a", "filename": "compiler/rustc_mir_dataflow/src/impls/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fliveness.rs?ref=ecdd374e6123d79b89c3ecea618d827c931b81cd", "patch": "@@ -30,14 +30,14 @@ impl MaybeLiveLocals {\n }\n \n impl<'tcx> AnalysisDomain<'tcx> for MaybeLiveLocals {\n-    type Domain = BitSet<Local>;\n+    type Domain = ChunkedBitSet<Local>;\n     type Direction = Backward;\n \n     const NAME: &'static str = \"liveness\";\n \n     fn bottom_value(&self, body: &mir::Body<'tcx>) -> Self::Domain {\n         // bottom = not live\n-        BitSet::new_empty(body.local_decls.len())\n+        ChunkedBitSet::new_empty(body.local_decls.len())\n     }\n \n     fn initialize_start_block(&self, _: &mir::Body<'tcx>, _: &mut Self::Domain) {"}, {"sha": "e1df482786f1bee6a180c27c707cf88243d79c1d", "filename": "compiler/rustc_mir_dataflow/src/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Frustc_peek.rs?ref=ecdd374e6123d79b89c3ecea618d827c931b81cd", "patch": "@@ -1,7 +1,7 @@\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n-use rustc_index::bit_set::BitSet;\n+use rustc_index::bit_set::ChunkedBitSet;\n use rustc_middle::mir::MirPass;\n use rustc_middle::mir::{self, Body, Local, Location};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -271,7 +271,7 @@ impl<'tcx> RustcPeekAt<'tcx> for MaybeLiveLocals {\n         &self,\n         tcx: TyCtxt<'tcx>,\n         place: mir::Place<'tcx>,\n-        flow_state: &BitSet<Local>,\n+        flow_state: &ChunkedBitSet<Local>,\n         call: PeekCall,\n     ) {\n         info!(?place, \"peek_at\");"}, {"sha": "7f0d3b0a612d59e005fe91d2cdd2d3f94cbcd24c", "filename": "compiler/rustc_mir_transform/src/generator.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecdd374e6123d79b89c3ecea618d827c931b81cd/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fgenerator.rs?ref=ecdd374e6123d79b89c3ecea618d827c931b81cd", "patch": "@@ -495,7 +495,8 @@ fn locals_live_across_suspend_points<'tcx>(\n             let loc = Location { block, statement_index: data.statements.len() };\n \n             liveness.seek_to_block_end(block);\n-            let mut live_locals = liveness.get().clone();\n+            let mut live_locals: BitSet<_> = BitSet::new_empty(body.local_decls.len());\n+            live_locals.union(liveness.get());\n \n             if !movable {\n                 // The `liveness` variable contains the liveness of MIR locals ignoring borrows."}]}