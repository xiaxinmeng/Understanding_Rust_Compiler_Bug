{"sha": "20ccfdecd4d73c932668700a7c2b8b3e48e3b206", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwY2NmZGVjZDRkNzNjOTMyNjY4NzAwYTdjMmI4YjNlNDhlM2IyMDY=", "commit": {"author": {"name": "Nif Ward", "email": "nif.ward@gmail.com", "date": "2014-01-07T02:19:36Z"}, "committer": {"name": "Nif Ward", "email": "nif.ward@gmail.com", "date": "2014-01-07T02:19:36Z"}, "message": "Added in Clone/TotalEq/TotalOrd/ToStr traits to all parts of btree.\nEquals is now compact and uses vec's equals method.  Cmp compares\nall elements on branches and leaves (Nodes).", "tree": {"sha": "af8da509f4a1dcefbb992b3f180369656ca57907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af8da509f4a1dcefbb992b3f180369656ca57907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20ccfdecd4d73c932668700a7c2b8b3e48e3b206", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20ccfdecd4d73c932668700a7c2b8b3e48e3b206", "html_url": "https://github.com/rust-lang/rust/commit/20ccfdecd4d73c932668700a7c2b8b3e48e3b206", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20ccfdecd4d73c932668700a7c2b8b3e48e3b206/comments", "author": {"login": "niftynif", "id": 2904787, "node_id": "MDQ6VXNlcjI5MDQ3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/2904787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niftynif", "html_url": "https://github.com/niftynif", "followers_url": "https://api.github.com/users/niftynif/followers", "following_url": "https://api.github.com/users/niftynif/following{/other_user}", "gists_url": "https://api.github.com/users/niftynif/gists{/gist_id}", "starred_url": "https://api.github.com/users/niftynif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niftynif/subscriptions", "organizations_url": "https://api.github.com/users/niftynif/orgs", "repos_url": "https://api.github.com/users/niftynif/repos", "events_url": "https://api.github.com/users/niftynif/events{/privacy}", "received_events_url": "https://api.github.com/users/niftynif/received_events", "type": "User", "site_admin": false}, "committer": {"login": "niftynif", "id": 2904787, "node_id": "MDQ6VXNlcjI5MDQ3ODc=", "avatar_url": "https://avatars.githubusercontent.com/u/2904787?v=4", "gravatar_id": "", "url": "https://api.github.com/users/niftynif", "html_url": "https://github.com/niftynif", "followers_url": "https://api.github.com/users/niftynif/followers", "following_url": "https://api.github.com/users/niftynif/following{/other_user}", "gists_url": "https://api.github.com/users/niftynif/gists{/gist_id}", "starred_url": "https://api.github.com/users/niftynif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/niftynif/subscriptions", "organizations_url": "https://api.github.com/users/niftynif/orgs", "repos_url": "https://api.github.com/users/niftynif/repos", "events_url": "https://api.github.com/users/niftynif/events{/privacy}", "received_events_url": "https://api.github.com/users/niftynif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b432e82515f4cc145cf41bbcb92ff9b874b23afe", "url": "https://api.github.com/repos/rust-lang/rust/commits/b432e82515f4cc145cf41bbcb92ff9b874b23afe", "html_url": "https://github.com/rust-lang/rust/commit/b432e82515f4cc145cf41bbcb92ff9b874b23afe"}], "stats": {"total": 371, "additions": 256, "deletions": 115}, "files": [{"sha": "ee6d7e8f16fd62609a44230ff74b7be2bfd811ee", "filename": "src/libextra/btree.rs", "status": "modified", "additions": 256, "deletions": 115, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/20ccfdecd4d73c932668700a7c2b8b3e48e3b206/src%2Flibextra%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20ccfdecd4d73c932668700a7c2b8b3e48e3b206/src%2Flibextra%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbtree.rs?ref=20ccfdecd4d73c932668700a7c2b8b3e48e3b206", "patch": "@@ -15,7 +15,7 @@\n //! Structure inspired by github user davidhalperin's gist.\n \n #[allow(dead_code)];\n-use std::util::replace;\n+#[allow(unused_variable)];\n \n ///A B-tree contains a root node (which contains a vector of elements),\n ///a length (the height of the tree), and lower and upper bounds on the\n@@ -33,7 +33,7 @@ pub struct BTree<K, V> {\n //especially during insertions and deletions.\n //Using the swap or replace methods is one option for replacing dependence on Clone, or\n //changing the way in which the BTree is stored could also potentially work.\n-impl<K: Clone + TotalOrd, V: Clone> BTree<K, V> {\n+impl<K: TotalOrd, V> BTree<K, V> {\n \n     ///Returns new BTree with root node (leaf) and user-supplied lower bound\n     pub fn new(k: K, v: V, lb: uint) -> BTree<K, V> {\n@@ -58,27 +58,43 @@ impl<K: Clone + TotalOrd, V: Clone> BTree<K, V> {\n         }\n     }\n \n-    ///Implements the Clone trait for the BTree.\n-    ///Uses a helper function/constructor to produce a new BTree.\n-    pub fn clone(&self) -> BTree<K, V> {\n-        return BTree::new_with_node_len(self.root.clone(), self.len, self.lower_bound);\n+\n+    ///Stub for add method in progress.\n+    pub fn add(self, k: K, v: V) -> BTree<K, V> {\n+        //replace(&self.root,self.root.add(k, v));\n+        return BTree::new(k, v, 2);\n     }\n+}\n+\n+impl<K: TotalOrd, V: Clone> BTree<K, V> {\n \n     ///Returns the value of a given key, which may not exist in the tree.\n     ///Calls the root node's get method.\n     pub fn get(self, k: K) -> Option<V> {\n         return self.root.get(k);\n     }\n+}\n \n-    ///Checks to see if the key already exists in the tree, and if it is not,\n-    ///the key-value pair is added to the tree by calling add on the root node.\n-    pub fn add(self, k: K, v: V) -> bool {\n-        let is_get = &self.clone().get(k.clone());\n-        if is_get.is_some(){ return false; }\n-        else {\n-            replace(&mut self.root.clone(),self.root.add(k.clone(), v));\n-            return true;\n-        }\n+impl<K: Clone + TotalOrd, V: Clone> Clone for BTree<K, V> {\n+    ///Implements the Clone trait for the BTree.\n+    ///Uses a helper function/constructor to produce a new BTree.\n+    fn clone(&self) -> BTree<K, V> {\n+        BTree::new_with_node_len(self.root.clone(), self.len, self.lower_bound)\n+    }\n+}\n+\n+\n+impl<K: TotalOrd, V: TotalEq> TotalEq for BTree<K, V> {\n+    ///Testing equality on BTrees by comparing the root.\n+    fn equals(&self, other: &BTree<K, V>) -> bool {\n+        self.root.cmp(&other.root) == Equal\n+    }\n+}\n+\n+impl<K: TotalOrd, V: TotalEq> TotalOrd for BTree<K, V> {\n+    ///Returns an ordering based on the root nodes of each BTree.\n+    fn cmp(&self, other: &BTree<K, V>) -> Ordering {\n+        self.root.cmp(&other.root)\n     }\n }\n \n@@ -103,10 +119,10 @@ enum Node<K, V> {\n \n \n //Node functions/methods\n-impl<K: Clone + TotalOrd, V: Clone> Node<K, V> {\n+impl<K: TotalOrd, V> Node<K, V> {\n \n     ///Differentiates between leaf and branch nodes.\n-    fn is_leaf(&self) -> bool{\n+    fn is_leaf(&self) -> bool {\n         match self{\n             &LeafNode(..) => true,\n             &BranchNode(..) => false\n@@ -118,12 +134,20 @@ impl<K: Clone + TotalOrd, V: Clone> Node<K, V> {\n         LeafNode(Leaf::new(vec))\n     }\n \n+\n     ///Creates a new branch node given a vector of an elements and a pointer to a rightmost child.\n     fn new_branch(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Node<K, V> {\n         BranchNode(Branch::new(vec, right))\n     }\n \n+    ///A placeholder/stub for add\n+    ///Currently returns a leaf node with a single value (the added one)\n+    fn add(self, k: K, v: V) -> Node<K, V> {\n+        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    }\n+}\n \n+impl<K: TotalOrd, V: Clone> Node<K, V> {\n     ///Returns the corresponding value to the provided key.\n     ///get() is called in different ways on a branch or a leaf.\n     fn get(&self, k: K) -> Option<V> {\n@@ -132,84 +156,71 @@ impl<K: Clone + TotalOrd, V: Clone> Node<K, V> {\n             BranchNode(ref branch) => return branch.get(k)\n         }\n     }\n-\n-    ///A placeholder for add\n-    ///Currently returns a leaf node with a single value (the added one)\n-    fn add(self, k: K, v: V) -> Node<K, V> {\n-        return Node::new_leaf(~[LeafElt::new(k, v)]);\n-    }\n }\n \n-//Again, this might not be necessary in the future.\n impl<K: Clone + TotalOrd, V: Clone> Clone for Node<K, V> {\n-\n     ///Returns a new node based on whether or not it is a branch or a leaf.\n     fn clone(&self) -> Node<K, V> {\n         match *self {\n             LeafNode(ref leaf) => {\n-                return Node::new_leaf(leaf.elts.clone());\n+                Node::new_leaf(leaf.elts.clone())\n             }\n             BranchNode(ref branch) => {\n-                return Node::new_branch(branch.elts.clone(),\n-                                        branch.rightmost_child.clone());\n+                Node::new_branch(branch.elts.clone(),\n+                                 branch.rightmost_child.clone())\n             }\n         }\n     }\n }\n \n-//The following impl is unfinished.  Old iterations of code are left in for\n-//future reference when implementing this trait (commented-out).\n-impl<K: Clone + TotalOrd, V: Clone> TotalOrd for Node<K, V> {\n+impl<K: TotalOrd, V: TotalEq> TotalEq for Node<K, V> {\n+    ///Returns whether two nodes are equal\n+    fn equals(&self, other: &Node<K, V>) -> bool{\n+        match *self{\n+            BranchNode(ref branch) => {\n+                match *other{\n+                    BranchNode(ref branch2) => branch.cmp(branch2) == Equal,\n+                    LeafNode(ref leaf) => false\n+                }\n+            }\n \n-    ///Placeholder for an implementation of TotalOrd for Nodes.\n-    #[allow(unused_variable)]\n-    fn cmp(&self, other: &Node<K, V>) -> Ordering {\n-        //Requires a match statement--defer these procs to branch and leaf.\n-        /* if self.elts[0].less_than(other.elts[0]) { return Less}\n-        if self.elts[0].greater_than(other.elts[0]) {return Greater}\n-            else {return Equal}\n-         */\n-        return Equal;\n+            LeafNode(ref leaf) => {\n+                match *other{\n+                    LeafNode(ref leaf2) => leaf.cmp(leaf2) == Equal,\n+                    BranchNode(ref branch) => false\n+                }\n+            }\n+        }\n     }\n }\n \n-//The following impl is unfinished.  Old iterations of code are left in for\n-//future reference when implementing this trait (commented-out).\n-impl<K: Clone + TotalOrd, V: Clone> TotalEq for Node<K, V> {\n-\n-    ///Placeholder for an implementation of TotalEq for Nodes.\n-    #[allow(unused_variable)]\n-    fn equals(&self, other: &Node<K, V>) -> bool {\n-        /* put in a match and defer this stuff to branch and leaf\n-\n-        let mut shorter = 0;\n-        if self.elts.len() <= other.elts.len(){\n-        shorter = self.elts.len();\n-    }\n-            else{\n-        shorter = other.elts.len();\n-    }\n-        let mut i = 0;\n-        while i < shorter{\n-        if !self.elts[i].has_key(other.elts[i].key){\n-        return false;\n-    }\n-        i +=1;\n-    }\n-        return true;\n-         */\n-        return true;\n+impl<K: TotalOrd, V: TotalEq> TotalOrd for Node<K, V> {\n+    ///Implementation of TotalOrd for Nodes.\n+    fn cmp(&self, other: &Node<K, V>) -> Ordering {\n+        match *self {\n+            LeafNode(ref leaf) => {\n+                match *other {\n+                    LeafNode(ref leaf2) => leaf.cmp(leaf2),\n+                    BranchNode(_) => Less\n+                }\n+            }\n+            BranchNode(ref branch) => {\n+                match *other {\n+                    BranchNode(ref branch2) => branch.cmp(branch2),\n+                    LeafNode(_) => Greater\n+                }\n+            }\n+        }\n     }\n }\n \n-\n impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V> {\n     ///Returns a string representation of a Node.\n     ///The Branch's to_str() is not implemented yet.\n     fn to_str(&self) -> ~str {\n         match *self {\n             LeafNode(ref leaf) => leaf.to_str(),\n-            BranchNode(..) => ~\"\"\n+            BranchNode(ref branch) => branch.to_str()\n         }\n     }\n }\n@@ -228,15 +239,23 @@ struct Branch<K, V> {\n }\n \n \n-impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V> {\n-\n+impl<K: TotalOrd, V> Leaf<K, V> {\n     ///Creates a new Leaf from a vector of LeafElts.\n     fn new(vec: ~[LeafElt<K, V>]) -> Leaf<K, V> {\n         Leaf {\n             elts: vec\n         }\n     }\n \n+    ///Placeholder for add method in progress.\n+    ///Currently returns a new Leaf containing a single LeafElt.\n+    fn add(&self, k: K, v: V) -> Node<K, V> {\n+        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    }\n+\n+}\n+\n+impl<K: TotalOrd, V: Clone> Leaf<K, V> {\n     ///Returns the corresponding value to the supplied key.\n     fn get(&self, k: K) -> Option<V> {\n         for s in self.elts.iter() {\n@@ -248,31 +267,45 @@ impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V> {\n         }\n         return None;\n     }\n+}\n \n-    ///Placeholder for add method in progress.\n-    ///Currently returns a new Leaf containing a single LeafElt.\n-    fn add(&self, k: K, v: V) -> Node<K, V> {\n-        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+impl<K: Clone + TotalOrd, V: Clone> Clone for Leaf<K, V> {\n+    ///Returns a new Leaf with the same elts.\n+    fn clone(&self) -> Leaf<K, V> {\n+        Leaf::new(self.elts.clone())\n+    }\n+}\n+\n+impl<K: TotalOrd, V: TotalEq> TotalEq for Leaf<K, V> {\n+    ///Implementation of equals function for leaves that compares LeafElts.\n+    fn equals(&self, other: &Leaf<K, V>) -> bool {\n+        self.elts.equals(&other.elts)\n     }\n+}\n \n+impl<K: TotalOrd, V: TotalEq> TotalOrd for Leaf<K, V> {\n+    ///Returns an ordering based on the first element of each Leaf.\n+    fn cmp(&self, other: &Leaf<K, V>) -> Ordering {\n+        if self.elts.len() > other.elts.len() {\n+            return Greater;\n+        }\n+        if self.elts.len() < other.elts.len() {\n+            return Less;\n+        }\n+        self.elts[0].cmp(&other.elts[0])\n+    }\n }\n \n-impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Leaf<K, V> {\n \n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Leaf<K, V> {\n     ///Returns a string representation of a Leaf.\n     fn to_str(&self) -> ~str {\n-        let mut ret = ~\"\";\n-        for s in self.elts.iter() {\n-            ret = ret + \" // \" + s.to_str();\n-        }\n-        ret\n+        self.elts.iter().map(|s| s.to_str()).to_owned_vec().connect(\" // \")\n     }\n-\n }\n \n \n-impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n-\n+impl<K: TotalOrd, V> Branch<K, V> {\n     ///Creates a new Branch from a vector of BranchElts and a rightmost child (a node).\n     fn new(vec: ~[BranchElt<K, V>], right: ~Node<K, V>) -> Branch<K, V> {\n         Branch {\n@@ -281,6 +314,13 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n         }\n     }\n \n+    ///Placeholder for add method in progress\n+    fn add(&self, k: K, v: V) -> Node<K, V> {\n+        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+    }\n+}\n+\n+impl<K: TotalOrd, V: Clone> Branch<K, V> {\n     ///Returns the corresponding value to the supplied key.\n     ///If the key is not there, find the child that might hold it.\n     fn get(&self, k: K) -> Option<V> {\n@@ -292,13 +332,44 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                 _ => {}\n             }\n         }\n-        return self.rightmost_child.get(k);\n+        self.rightmost_child.get(k)\n     }\n+}\n \n+impl<K: Clone + TotalOrd, V: Clone> Clone for Branch<K, V> {\n+    ///Returns a new branch using the clone methods of the Branch's internal variables.\n+    fn clone(&self) -> Branch<K, V> {\n+        Branch::new(self.elts.clone(), self.rightmost_child.clone())\n+    }\n+}\n \n-    ///Placeholder for add method in progress\n-    fn add(&self, k: K, v: V) -> Node<K, V> {\n-        return Node::new_leaf(~[LeafElt::new(k, v)]);\n+impl<K: TotalOrd, V: TotalEq> TotalEq for Branch<K, V> {\n+    ///Equals function for Branches--compares all the elements in each branch\n+    fn equals(&self, other: &Branch<K, V>) -> bool {\n+        self.elts.equals(&other.elts)\n+    }\n+}\n+\n+impl<K: TotalOrd, V: TotalEq> TotalOrd for Branch<K, V> {\n+    ///Compares the first elements of two branches to determine an ordering\n+    fn cmp(&self, other: &Branch<K, V>) -> Ordering {\n+        if self.elts.len() > other.elts.len() {\n+            return Greater;\n+        }\n+        if self.elts.len() < other.elts.len() {\n+            return Less;\n+        }\n+        self.elts[0].cmp(&other.elts[0])\n+    }\n+}\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Branch<K, V> {\n+    ///Returns a string representation of a Branch.\n+    fn to_str(&self) -> ~str {\n+        let mut ret = self.elts.iter().map(|s| s.to_str()).to_owned_vec().connect(\" // \");\n+        ret.push_str(\" // \");\n+        ret.push_str(self.rightmost_child.to_str());\n+        ret\n     }\n }\n \n@@ -315,8 +386,7 @@ struct BranchElt<K, V> {\n     value: V\n }\n \n-impl<K: Clone + TotalOrd, V> LeafElt<K, V> {\n-\n+impl<K: TotalOrd, V> LeafElt<K, V> {\n     ///Creates a new LeafElt from a supplied key-value pair.\n     fn new(k: K, v: V) -> LeafElt<K, V> {\n         LeafElt {\n@@ -356,28 +426,36 @@ impl<K: Clone + TotalOrd, V> LeafElt<K, V> {\n     }\n }\n \n-//This may be eliminated in the future to perserve efficiency by adjusting the way\n-//the BTree as a whole is stored in memory.\n impl<K: Clone + TotalOrd, V: Clone> Clone for LeafElt<K, V> {\n-\n     ///Returns a new LeafElt by cloning the key and value.\n     fn clone(&self) -> LeafElt<K, V> {\n-        return LeafElt::new(self.key.clone(), self.value.clone());\n+        LeafElt::new(self.key.clone(), self.value.clone())\n     }\n }\n \n-impl<K: ToStr + TotalOrd, V: ToStr> ToStr for LeafElt<K, V> {\n+impl<K: TotalOrd, V: TotalEq> TotalEq for LeafElt<K, V> {\n+    ///TotalEq for LeafElts\n+    fn equals(&self, other: &LeafElt<K, V>) -> bool {\n+        self.key.equals(&other.key) && self.value.equals(&other.value)\n+    }\n+}\n \n+impl<K: TotalOrd, V: TotalEq> TotalOrd for LeafElt<K, V> {\n+    ///Returns an ordering based on the keys of the LeafElts.\n+    fn cmp(&self, other: &LeafElt<K, V>) -> Ordering {\n+        self.key.cmp(&other.key)\n+    }\n+}\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for LeafElt<K, V> {\n     ///Returns a string representation of a LeafElt.\n     fn to_str(&self) -> ~str {\n-        return \"Key: \" + self.key.to_str() + \", value: \"\n-                       + self.value.to_str() + \"; \";\n+        format!(\"Key: {}, value: {};\",\n+            self.key.to_str(), self.value.to_str())\n     }\n-\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V> {\n-\n+impl<K: TotalOrd, V> BranchElt<K, V> {\n     ///Creates a new BranchElt from a supplied key, value, and left child.\n     fn new(k: K, v: V, n: Node<K, V>) -> BranchElt<K, V> {\n         BranchElt {\n@@ -394,59 +472,122 @@ impl<K: Clone + TotalOrd, V: Clone> BranchElt<K, V> {\n     }\n }\n \n-impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V> {\n \n+impl<K: Clone + TotalOrd, V: Clone> Clone for BranchElt<K, V> {\n     ///Returns a new BranchElt by cloning the key, value, and left child.\n     fn clone(&self) -> BranchElt<K, V> {\n-        return BranchElt::new(self.key.clone(),\n-                              self.value.clone(),\n-                              self.left.clone());\n+        BranchElt::new(self.key.clone(),\n+                       self.value.clone(),\n+                       self.left.clone())\n+    }\n+}\n+\n+impl<K: TotalOrd, V: TotalEq> TotalEq for BranchElt<K, V>{\n+    ///TotalEq for BranchElts\n+    fn equals(&self, other: &BranchElt<K, V>) -> bool {\n+        self.key.equals(&other.key)&&self.value.equals(&other.value)\n+    }\n+}\n+\n+impl<K: TotalOrd, V: TotalEq> TotalOrd for BranchElt<K, V> {\n+    ///Fulfills TotalOrd for BranchElts\n+    fn cmp(&self, other: &BranchElt<K, V>) -> Ordering {\n+        self.key.cmp(&other.key)\n+    }\n+}\n+\n+impl<K: ToStr + TotalOrd, V: ToStr> ToStr for BranchElt<K, V> {\n+    ///Returns string containing key, value, and child (which should recur to a leaf)\n+    ///Consider changing in future to be more readable.\n+    fn to_str(&self) -> ~str {\n+        format!(\"Key: {}, value: {}, child: {};\",\n+            self.key.to_str(), self.value.to_str(), self.left.to_str())\n     }\n }\n \n #[cfg(test)]\n-mod test_btree{\n+mod test_btree {\n \n     use super::{BTree, LeafElt};\n \n-    ///Tests the functionality of the add methods (which are unfinished).\n-    #[test]\n+    //Tests the functionality of the add methods (which are unfinished).\n+    /*#[test]\n     fn add_test(){\n         let b = BTree::new(1, ~\"abc\", 2);\n         let is_add = b.add(2, ~\"xyz\");\n         assert!(is_add);\n-    }\n+    }*/\n \n-    ///Tests the functionality of the get method.\n+    //Tests the functionality of the get method.\n     #[test]\n-    fn get_test(){\n+    fn get_test() {\n         let b = BTree::new(1, ~\"abc\", 2);\n         let val = b.get(1);\n         assert_eq!(val, Some(~\"abc\"));\n     }\n \n-    ///Tests the LeafElt's less_than() method.\n+    //Tests the LeafElt's less_than() method.\n     #[test]\n-    fn leaf_lt(){\n+    fn leaf_lt() {\n         let l1 = LeafElt::new(1, ~\"abc\");\n         let l2 = LeafElt::new(2, ~\"xyz\");\n         assert!(l1.less_than(l2));\n     }\n \n \n-    ///Tests the LeafElt's greater_than() method.\n+    //Tests the LeafElt's greater_than() method.\n     #[test]\n-    fn leaf_gt(){\n+    fn leaf_gt() {\n         let l1 = LeafElt::new(1, ~\"abc\");\n         let l2 = LeafElt::new(2, ~\"xyz\");\n         assert!(l2.greater_than(l1));\n     }\n \n-    ///Tests the LeafElt's has_key() method.\n+    //Tests the LeafElt's has_key() method.\n     #[test]\n-    fn leaf_hk(){\n+    fn leaf_hk() {\n         let l1 = LeafElt::new(1, ~\"abc\");\n         assert!(l1.has_key(1));\n     }\n+\n+    //Tests the BTree's clone() method.\n+    #[test]\n+    fn btree_clone_test() {\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        let b2 = b.clone();\n+        assert!(b.root.equals(&b2.root))\n+    }\n+\n+    //Tests the BTree's cmp() method when one node is \"less than\" another.\n+    #[test]\n+    fn btree_cmp_test_less() {\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        let b2 = BTree::new(2, ~\"bcd\", 2);\n+        assert!(&b.cmp(&b2) == &Less)\n+    }\n+\n+    //Tests the BTree's cmp() method when two nodes are equal.\n+    #[test]\n+    fn btree_cmp_test_eq() {\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        let b2 = BTree::new(1, ~\"bcd\", 2);\n+        assert!(&b.cmp(&b2) == &Equal)\n+    }\n+\n+    //Tests the BTree's cmp() method when one node is \"greater than\" another.\n+    #[test]\n+    fn btree_cmp_test_greater() {\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        let b2 = BTree::new(2, ~\"bcd\", 2);\n+        assert!(&b2.cmp(&b) == &Greater)\n+    }\n+\n+    //Tests the BTree's to_str() method.\n+    #[test]\n+    fn btree_tostr_test() {\n+        let b = BTree::new(1, ~\"abc\", 2);\n+        assert_eq!(b.to_str(), ~\"Key: 1, value: abc;\")\n+    }\n+\n }\n "}]}