{"sha": "dbf472b0df9426da1610e328a3e505fe4dc9de11", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiZjQ3MmIwZGY5NDI2ZGExNjEwZTMyOGEzZTUwNWZlNGRjOWRlMTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-28T01:42:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-09-28T17:22:02Z"}, "message": "rustc: Switch to cdecl for all calls. This is needed to make stack growth efficient, as I need to use eax and ecx in the function prologue and can't afford to stomp on incoming arguments.", "tree": {"sha": "8121babb2ef6e4938be7a2e5d4e5dd9be6c74082", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8121babb2ef6e4938be7a2e5d4e5dd9be6c74082"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbf472b0df9426da1610e328a3e505fe4dc9de11", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbf472b0df9426da1610e328a3e505fe4dc9de11", "html_url": "https://github.com/rust-lang/rust/commit/dbf472b0df9426da1610e328a3e505fe4dc9de11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbf472b0df9426da1610e328a3e505fe4dc9de11/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "512cfb4b8387a6919c06d7e01401c53c6ab7dd1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/512cfb4b8387a6919c06d7e01401c53c6ab7dd1c", "html_url": "https://github.com/rust-lang/rust/commit/512cfb4b8387a6919c06d7e01401c53c6ab7dd1c"}], "stats": {"total": 61, "additions": 25, "deletions": 36}, "files": [{"sha": "d033c2334a7ddd2a3f701b5aaec72b8565604ce3", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 20, "deletions": 30, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/dbf472b0df9426da1610e328a3e505fe4dc9de11/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf472b0df9426da1610e328a3e505fe4dc9de11/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=dbf472b0df9426da1610e328a3e505fe4dc9de11", "patch": "@@ -317,18 +317,12 @@ fn decl_cdecl_fn(llmod: ModuleRef, name: str, llty: TypeRef) -> ValueRef {\n     ret decl_fn(llmod, name, lib::llvm::LLVMCCallConv, llty);\n }\n \n-fn decl_fastcall_fn(llmod: ModuleRef, name: str, llty: TypeRef) -> ValueRef {\n-    let llfn = decl_fn(llmod, name, lib::llvm::LLVMFastCallConv, llty);\n-    let _: () = str::as_buf(\"rust\", {|buf| llvm::LLVMSetGC(llfn, buf) });\n-    ret llfn;\n-}\n-\n \n // Only use this if you are going to actually define the function. It's\n // not valid to simply declare a function as internal.\n-fn decl_internal_fastcall_fn(llmod: ModuleRef, name: str, llty: TypeRef) ->\n+fn decl_internal_cdecl_fn(llmod: ModuleRef, name: str, llty: TypeRef) ->\n    ValueRef {\n-    let llfn = decl_fastcall_fn(llmod, name, llty);\n+    let llfn = decl_cdecl_fn(llmod, name, llty);\n     llvm::LLVMSetLinkage(llfn,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     ret llfn;\n@@ -1454,7 +1448,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n         (llvm::LLVMGetElementType\n          (llvm::LLVMTypeOf(dtor_addr)))[std::vec::len(args)];\n     let val_cast = BitCast(cx, val.val, val_llty);\n-    FastCall(cx, dtor_addr, args + [val_cast]);\n+    Call(cx, dtor_addr, args + [val_cast]);\n \n     cx = drop_ty(cx, val.val, inner_t_s);\n     Store(cx, C_int(0), drop_flag.val);\n@@ -2861,7 +2855,7 @@ fn trans_for_each(cx: @block_ctxt, local: @ast::local, seq: @ast::expr,\n     let iter_body_llty =\n         type_of_fn_from_ty(ccx, cx.sp, iter_body_fn, 0u);\n     let lliterbody: ValueRef =\n-        decl_internal_fastcall_fn(ccx.llmod, s, iter_body_llty);\n+        decl_internal_cdecl_fn(ccx.llmod, s, iter_body_llty);\n     let fcx = new_fn_ctxt_w_id(lcx, cx.sp, lliterbody, body.node.id,\n                                ast::return_val);\n     fcx.iterbodyty = cx.fcx.iterbodyty;\n@@ -3418,8 +3412,7 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     // Give the thunk a name, type, and value.\n     let s: str = mangle_internal_name_by_path_and_seq(ccx, cx.path, \"thunk\");\n     let llthunk_ty: TypeRef = get_pair_fn_ty(type_of(ccx, sp, incoming_fty));\n-    let llthunk: ValueRef =\n-        decl_internal_fastcall_fn(ccx.llmod, s, llthunk_ty);\n+    let llthunk: ValueRef = decl_internal_cdecl_fn(ccx.llmod, s, llthunk_ty);\n \n     // Create a new function context and block context for the thunk, and hold\n     // onto a pointer to the first block in the function for later use.\n@@ -3559,7 +3552,7 @@ fn trans_bind_thunk(cx: @local_ctxt, sp: span, incoming_fty: ty::t,\n     let lltargetty =\n         type_of_fn_from_ty(ccx, sp, outgoing_fty, ty_param_count);\n     lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n-    FastCall(bcx, lltargetfn, llargs);\n+    Call(bcx, lltargetfn, llargs);\n     build_return(bcx);\n     finish_fn(fcx, lltop);\n     ret {val: llthunk, ty: llthunk_ty};\n@@ -3869,8 +3862,8 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n        type _|_. Since that means it diverges, the code\n        for the call itself is unreachable. */\n     let retval = C_nil();\n-    bcx = invoke_fastcall(bcx, faddr, llargs,\n-                          args_res.to_zero, args_res.to_revoke);\n+    bcx = invoke_full(bcx, faddr, llargs, args_res.to_zero,\n+                      args_res.to_revoke);\n     alt lliterbody {\n       none. {\n         if !ty::type_is_nil(tcx, ret_ty) {\n@@ -3922,14 +3915,10 @@ fn invoke(bcx: @block_ctxt, llfn: ValueRef,\n     ret invoke_(bcx, llfn, llargs, [], [], Invoke);\n }\n \n-fn invoke_fastcall(bcx: @block_ctxt, llfn: ValueRef,\n-                   llargs: [ValueRef],\n-                   to_zero: [{v: ValueRef, t: ty::t}],\n-                   to_revoke: [{v: ValueRef, t: ty::t}])\n-    -> @block_ctxt {\n-    ret invoke_(bcx, llfn, llargs,\n-                to_zero, to_revoke,\n-                FastInvoke);\n+fn invoke_full(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n+               to_zero: [{v: ValueRef, t: ty::t}],\n+               to_revoke: [{v: ValueRef, t: ty::t}]) -> @block_ctxt {\n+    ret invoke_(bcx, llfn, llargs, to_zero, to_revoke, Invoke);\n }\n \n fn invoke_(bcx: @block_ctxt, llfn: ValueRef, llargs: [ValueRef],\n@@ -4129,7 +4118,7 @@ fn trans_expr(cx: @block_ctxt, e: @ast::expr) -> result {\n             type_of_fn_from_ty(ccx, e.span, fty, 0u);\n         let sub_cx = extend_path(cx.fcx.lcx, ccx.names.next(\"anon\"));\n         let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n-        let llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n+        let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n         let fn_res =\n             trans_closure(some(cx), some(llfnty), sub_cx, e.span, f, llfn,\n@@ -4580,7 +4569,7 @@ fn trans_put(in_cx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n         llargs += [r.val];\n       }\n     }\n-    bcx = invoke_fastcall(bcx, llcallee, llargs, [], []);\n+    bcx = invoke(bcx, llcallee, llargs);\n     bcx = trans_block_cleanups(bcx, cx);\n     let next_cx = new_sub_block_ctxt(in_cx, \"next\");\n     if bcx.unreachable { Unreachable(next_cx); }\n@@ -5557,7 +5546,7 @@ fn register_fn_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n       _ { ccx.sess.bug(\"register_fn(): fn item doesn't have fn type!\"); }\n     }\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n-    let llfn: ValueRef = decl_fastcall_fn(ccx.llmod, ps, llfty);\n+    let llfn: ValueRef = decl_cdecl_fn(ccx.llmod, ps, llfty);\n     ccx.item_ids.insert(node_id, llfn);\n     ccx.item_symbols.insert(node_id, ps);\n \n@@ -5594,7 +5583,8 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n \n         let llfty = type_of_fn(ccx, sp, ast::proto_fn, false, false,\n                                [vecarg_ty], nt, 0u);\n-        let llfdecl = decl_fastcall_fn(ccx.llmod, \"_rust_main\", llfty);\n+        let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n+                              lib::llvm::LLVMFastCallConv, llfty);\n \n         let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n \n@@ -5613,7 +5603,7 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n             llargvarg = PointerCast(bcx, llargvarg, minus_ptr);\n             args += [do_spill_noroot(bcx, llargvarg)];\n         }\n-        FastCall(bcx, main_llfn, args);\n+        Call(bcx, main_llfn, args);\n         build_return(bcx);\n \n         finish_fn(fcx, lltop);\n@@ -5676,7 +5666,7 @@ fn register_native_fn(ccx: @crate_ctxt, sp: span, path: [str], name: str,\n     let t = node_id_type(ccx, id);\n     let wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n     let ps: str = mangle_exported_name(ccx, path, node_id_type(ccx, id));\n-    let wrapper_fn = decl_fastcall_fn(ccx.llmod, ps, wrapper_type);\n+    let wrapper_fn = decl_cdecl_fn(ccx.llmod, ps, wrapper_type);\n     ccx.item_ids.insert(id, wrapper_fn);\n     ccx.item_symbols.insert(id, ps);\n \n@@ -6048,7 +6038,7 @@ fn trap(bcx: @block_ctxt) {\n \n fn decl_no_op_type_glue(llmod: ModuleRef, taskptr_type: TypeRef) -> ValueRef {\n     let ty = T_fn([taskptr_type, T_ptr(T_i8())], T_void());\n-    ret decl_fastcall_fn(llmod, abi::no_op_type_glue_name(), ty);\n+    ret decl_cdecl_fn(llmod, abi::no_op_type_glue_name(), ty);\n }\n \n fn make_glues(llmod: ModuleRef, taskptr_type: TypeRef) -> @glue_fns {"}, {"sha": "602bd6b5af386ad934555f1341ea2f4e4fd3c8d4", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dbf472b0df9426da1610e328a3e505fe4dc9de11/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbf472b0df9426da1610e328a3e505fe4dc9de11/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=dbf472b0df9426da1610e328a3e505fe4dc9de11", "patch": "@@ -604,8 +604,7 @@ fn begin_fn(cx: @local_ctxt, sp: span, m: @ty::method,\n \n     // Get the function's type and declare it.\n     let llfn_ty: TypeRef = type_of_meth(cx.ccx, sp, m, ty_params);\n-    let llfn: ValueRef =\n-        decl_internal_fastcall_fn(cx.ccx.llmod, s, llfn_ty);\n+    let llfn: ValueRef = decl_internal_cdecl_fn(cx.ccx.llmod, s, llfn_ty);\n \n     ret llfn;\n }\n@@ -706,7 +705,7 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     }\n \n     // And, finally, call the outer method.\n-    FastCall(bcx, llouter_mthd, llouter_mthd_args);\n+    Call(bcx, llouter_mthd, llouter_mthd_args);\n \n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -858,7 +857,7 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n     }\n \n     // And, finally, call the original (inner) method.\n-    FastCall(bcx, llorig_mthd, llorig_mthd_args);\n+    Call(bcx, llorig_mthd, llorig_mthd_args);\n \n     build_return(bcx);\n     finish_fn(fcx, lltop);\n@@ -911,7 +910,7 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n     let mcx: @local_ctxt =\n         @{path: cx.path + [\"method\", m.node.ident] with *cx};\n     let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n-    let llfn: ValueRef = decl_internal_fastcall_fn(ccx.llmod, s, llfnty);\n+    let llfn: ValueRef = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n     // Every method on an object gets its node_id inserted into the crate-wide\n     // item_ids map, together with the ValueRef that points to where that"}, {"sha": "6b0454cc31fc42021bd6f25d7d76075e92539d6d", "filename": "src/rt/main.ll.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbf472b0df9426da1610e328a3e505fe4dc9de11/src%2Frt%2Fmain.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/dbf472b0df9426da1610e328a3e505fe4dc9de11/src%2Frt%2Fmain.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmain.ll.in?ref=dbf472b0df9426da1610e328a3e505fe4dc9de11", "patch": "@@ -29,7 +29,7 @@ define void @_rust_main_wrap(i1* nocapture, %task *, %2* nocapture, %vec *)\n define void @_rust_spawn_wrap(\n        i1* nocapture, %task*, %2* nocapture, %nullary_fn* %f)\n {\n-  call fastcc void %f(i1* %0, %task *%1, %2* nocapture %2)\n+  call void %f(i1* %0, %task *%1, %2* nocapture %2)\n   ret void\n }\n "}]}