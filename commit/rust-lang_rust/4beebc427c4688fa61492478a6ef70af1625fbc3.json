{"sha": "4beebc427c4688fa61492478a6ef70af1625fbc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZWViYzQyN2M0Njg4ZmE2MTQ5MjQ3OGE2ZWY3MGFmMTYyNWZiYzM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-15T20:00:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-15T20:00:56Z"}, "message": "auto merge of #5797 : alexcrichton/rust/issue-1913, r=catamorphism\n\nCloses #5487, #1913, and #4568\r\n\r\nI tracked this by adding all used unsafe blocks/functions to a set on the `tcx` passed around, and then when the lint pass comes around if an unsafe block/function isn't listed in that set, it's unused.\r\n\r\nI also removed everything from the compiler that was unused, and up to stage2 is now compiling without any known unused unsafe blocks.\r\n\r\nI chose `unused_unsafe` as the name of the lint attribute, but there may be a better name...", "tree": {"sha": "d884e879bb497163f860f50be3720a6a3f6d0f96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d884e879bb497163f860f50be3720a6a3f6d0f96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4beebc427c4688fa61492478a6ef70af1625fbc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4beebc427c4688fa61492478a6ef70af1625fbc3", "html_url": "https://github.com/rust-lang/rust/commit/4beebc427c4688fa61492478a6ef70af1625fbc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4beebc427c4688fa61492478a6ef70af1625fbc3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39e2ab5e8b67763ff960203a32acc24a17beeb50", "url": "https://api.github.com/repos/rust-lang/rust/commits/39e2ab5e8b67763ff960203a32acc24a17beeb50", "html_url": "https://github.com/rust-lang/rust/commit/39e2ab5e8b67763ff960203a32acc24a17beeb50"}, {"sha": "59e69aa0e79302887abcb4b6bf3613c84b48e5d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/59e69aa0e79302887abcb4b6bf3613c84b48e5d7", "html_url": "https://github.com/rust-lang/rust/commit/59e69aa0e79302887abcb4b6bf3613c84b48e5d7"}], "stats": {"total": 2030, "additions": 1045, "deletions": 985}, "files": [{"sha": "5a5c091d9570a11d8c3141c8cc5ae8b40e962d53", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -30,36 +30,34 @@ pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n }\n \n fn parse_expected(line_num: uint, line: ~str) -> ~[ExpectedError] {\n-    unsafe {\n-        let error_tag = ~\"//~\";\n-        let mut idx;\n-        match str::find_str(line, error_tag) {\n-          None => return ~[],\n-          Some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n-        }\n+    let error_tag = ~\"//~\";\n+    let mut idx;\n+    match str::find_str(line, error_tag) {\n+      None => return ~[],\n+      Some(nn) => { idx = (nn as uint) + str::len(error_tag); }\n+    }\n \n-        // \"//~^^^ kind msg\" denotes a message expected\n-        // three lines above current line:\n-        let mut adjust_line = 0u;\n-        let len = str::len(line);\n-        while idx < len && line[idx] == ('^' as u8) {\n-            adjust_line += 1u;\n-            idx += 1u;\n-        }\n+    // \"//~^^^ kind msg\" denotes a message expected\n+    // three lines above current line:\n+    let mut adjust_line = 0u;\n+    let len = str::len(line);\n+    while idx < len && line[idx] == ('^' as u8) {\n+        adjust_line += 1u;\n+        idx += 1u;\n+    }\n \n-        // Extract kind:\n-        while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-        let start_kind = idx;\n-        while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n-        let kind = str::to_lower(str::slice(line, start_kind, idx).to_owned());\n+    // Extract kind:\n+    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n+    let start_kind = idx;\n+    while idx < len && line[idx] != (' ' as u8) { idx += 1u; }\n+    let kind = str::to_lower(str::slice(line, start_kind, idx).to_owned());\n \n-        // Extract msg:\n-        while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n-        let msg = str::slice(line, idx, len).to_owned();\n+    // Extract msg:\n+    while idx < len && line[idx] == (' ' as u8) { idx += 1u; }\n+    let msg = str::slice(line, idx, len).to_owned();\n \n-        debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n+    debug!(\"line=%u kind=%s msg=%s\", line_num - adjust_line, kind, msg);\n \n-        return ~[ExpectedError{line: line_num - adjust_line, kind: kind,\n-                               msg: msg}];\n-    }\n+    return ~[ExpectedError{line: line_num - adjust_line, kind: kind,\n+                           msg: msg}];\n }"}, {"sha": "2b36518833888254f7265947a9e38df96180af8b", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -171,16 +171,14 @@ fn parse_name_directive(line: ~str, directive: ~str) -> bool {\n \n fn parse_name_value_directive(line: ~str,\n                               directive: ~str) -> Option<~str> {\n-    unsafe {\n-        let keycolon = directive + ~\":\";\n-        match str::find_str(line, keycolon) {\n-            Some(colon) => {\n-                let value = str::slice(line, colon + str::len(keycolon),\n-                                       str::len(line)).to_owned();\n-                debug!(\"%s: %s\", directive,  value);\n-                Some(value)\n-            }\n-            None => None\n+    let keycolon = directive + ~\":\";\n+    match str::find_str(line, keycolon) {\n+        Some(colon) => {\n+            let value = str::slice(line, colon + str::len(keycolon),\n+                                   str::len(line)).to_owned();\n+            debug!(\"%s: %s\", directive,  value);\n+            Some(value)\n         }\n+        None => None\n     }\n }"}, {"sha": "d665bf311f362868c7fc9f01a6c9af4f77fe45a5", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -188,16 +188,14 @@ impl<T: Owned> Peekable<T> for Port<T> {\n \n #[inline(always)]\n fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n-    unsafe {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        let peek = match &endp {\n-            &Some(ref endp) => peek(endp),\n-            &None => fail!(~\"peeking empty stream\")\n-        };\n-        self.endp <-> endp;\n-        peek\n-    }\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    let peek = match &endp {\n+        &Some(ref endp) => peek(endp),\n+        &None => fail!(~\"peeking empty stream\")\n+    };\n+    self.endp <-> endp;\n+    peek\n }\n \n impl<T: Owned> Selectable for Port<T> {"}, {"sha": "3c5900f51a247d4ba8fa08ac2985a6e91a5aa048", "filename": "src/libcore/io.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -1536,11 +1536,8 @@ pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n-    // FIXME (#3758): This should not be needed.\n-    unsafe {\n-        // Make sure the vector has a trailing null and is proper utf8.\n-        v.push(0);\n-    }\n+    // Make sure the vector has a trailing null and is proper utf8.\n+    v.push(0);\n     assert!(str::is_utf8(v));\n \n     unsafe { ::cast::transmute(v) }\n@@ -1640,16 +1637,14 @@ pub mod fsync {\n     // outer res\n     pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n                          blk: &fn(v: Res<*libc::FILE>)) {\n-        unsafe {\n-            blk(Res(Arg {\n-                val: file.f, opt_level: opt_level,\n-                fsync_fn: |file, l| {\n-                    unsafe {\n-                        os::fsync_fd(libc::fileno(file), l) as int\n-                    }\n+        blk(Res(Arg {\n+            val: file.f, opt_level: opt_level,\n+            fsync_fn: |file, l| {\n+                unsafe {\n+                    os::fsync_fd(libc::fileno(file), l) as int\n                 }\n-            }));\n-        }\n+            }\n+        }));\n     }\n \n     // fsync fd after executing blk"}, {"sha": "2bd3959acf4de476bc28ba5aaa16f0e48e9536f9", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -38,13 +38,13 @@ pub mod raw {\n #[inline(always)]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object\n-    unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n+    ptr::addr_of(&(*a)) == ptr::addr_of(&(*b))\n }\n \n #[inline(always)]\n pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n     //! Determine if two mutable shared boxes point to the same object\n-    unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n+    ptr::addr_of(&(*a)) == ptr::addr_of(&(*b))\n }\n \n #[cfg(notest)]"}, {"sha": "87d04b05087c23dc7cbae85746b9bb91b98382b5", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -369,27 +369,27 @@ pub fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n \n #[inline(always)]\n pub fn abs(x: float) -> float {\n-    unsafe { f64::abs(x as f64) as float }\n+    f64::abs(x as f64) as float\n }\n #[inline(always)]\n pub fn sqrt(x: float) -> float {\n-    unsafe { f64::sqrt(x as f64) as float }\n+    f64::sqrt(x as f64) as float\n }\n #[inline(always)]\n pub fn atan(x: float) -> float {\n-    unsafe { f64::atan(x as f64) as float }\n+    f64::atan(x as f64) as float\n }\n #[inline(always)]\n pub fn sin(x: float) -> float {\n-    unsafe { f64::sin(x as f64) as float }\n+    f64::sin(x as f64) as float\n }\n #[inline(always)]\n pub fn cos(x: float) -> float {\n-    unsafe { f64::cos(x as f64) as float }\n+    f64::cos(x as f64) as float\n }\n #[inline(always)]\n pub fn tan(x: float) -> float {\n-    unsafe { f64::tan(x as f64) as float }\n+    f64::tan(x as f64) as float\n }\n \n #[cfg(notest)]"}, {"sha": "0e8dbd144b14395e2fe6c9a0a7c884542ca18b99", "filename": "src/libcore/path.rs", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -389,13 +389,11 @@ impl GenericPath for PosixPath {\n     }\n \n     fn dirname(&self) -> ~str {\n-        unsafe {\n-            let s = self.dir_path().to_str();\n-            if s.len() == 0 {\n-                ~\".\"\n-            } else {\n-                s\n-            }\n+        let s = self.dir_path().to_str();\n+        if s.len() == 0 {\n+            ~\".\"\n+        } else {\n+            s\n         }\n     }\n \n@@ -439,10 +437,8 @@ impl GenericPath for PosixPath {\n     }\n \n     fn with_filename(&self, f: &str) -> PosixPath {\n-        unsafe {\n-            assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n-            self.dir_path().push(f)\n-        }\n+        assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n+        self.dir_path().push(f)\n     }\n \n     fn with_filestem(&self, s: &str) -> PosixPath {\n@@ -509,7 +505,7 @@ impl GenericPath for PosixPath {\n             for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n                 ss.push(s.to_owned())\n             }\n-            unsafe { v.push_all_move(ss); }\n+            v.push_all_move(ss);\n         }\n         PosixPath { is_absolute: self.is_absolute,\n                     components: v }\n@@ -521,14 +517,14 @@ impl GenericPath for PosixPath {\n         for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n             ss.push(s.to_owned())\n         }\n-        unsafe { v.push_all_move(ss); }\n+        v.push_all_move(ss);\n         PosixPath { components: v, ..copy *self }\n     }\n \n     fn pop(&self) -> PosixPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unsafe { cs.pop(); }\n+            cs.pop();\n         }\n         return PosixPath {\n             is_absolute: self.is_absolute,\n@@ -607,13 +603,11 @@ impl GenericPath for WindowsPath {\n     }\n \n     fn dirname(&self) -> ~str {\n-        unsafe {\n-            let s = self.dir_path().to_str();\n-            if s.len() == 0 {\n-                ~\".\"\n-            } else {\n-                s\n-            }\n+        let s = self.dir_path().to_str();\n+        if s.len() == 0 {\n+            ~\".\"\n+        } else {\n+            s\n         }\n     }\n \n@@ -770,7 +764,7 @@ impl GenericPath for WindowsPath {\n             for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n                 ss.push(s.to_owned())\n             }\n-            unsafe { v.push_all_move(ss); }\n+            v.push_all_move(ss);\n         }\n         // tedious, but as-is, we can't use ..self\n         return WindowsPath {\n@@ -787,14 +781,14 @@ impl GenericPath for WindowsPath {\n         for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n             ss.push(s.to_owned())\n         }\n-        unsafe { v.push_all_move(ss); }\n+        v.push_all_move(ss);\n         return WindowsPath { components: v, ..copy *self }\n     }\n \n     fn pop(&self) -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unsafe { cs.pop(); }\n+            cs.pop();\n         }\n         return WindowsPath {\n             host: copy self.host,\n@@ -820,18 +814,14 @@ impl GenericPath for WindowsPath {\n \n pub fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n-    unsafe {\n-        for components.each |c| {\n-            unsafe {\n-                if *c == ~\".\" && components.len() > 1 { loop; }\n-                if *c == ~\"\" { loop; }\n-                if *c == ~\"..\" && cs.len() != 0 {\n-                    cs.pop();\n-                    loop;\n-                }\n-                cs.push(copy *c);\n-            }\n+    for components.each |c| {\n+        if *c == ~\".\" && components.len() > 1 { loop; }\n+        if *c == ~\"\" { loop; }\n+        if *c == ~\"..\" && cs.len() != 0 {\n+            cs.pop();\n+            loop;\n         }\n+        cs.push(copy *c);\n     }\n     cs\n }"}, {"sha": "14e17de4fbda08170f6d1d0adaa41d5932e74877", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -55,17 +55,13 @@ pub fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n /// Calculate the offset from a pointer\n #[inline(always)]\n pub fn offset<T>(ptr: *T, count: uint) -> *T {\n-    unsafe {\n-        (ptr as uint + count * sys::size_of::<T>()) as *T\n-    }\n+    (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a const pointer\n #[inline(always)]\n pub fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n-    unsafe {\n-        (ptr as uint + count * sys::size_of::<T>()) as *T\n-    }\n+    (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a mut pointer"}, {"sha": "4714be9e3d520715c97c676e8467fdb3dc22340e", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -205,8 +205,6 @@ fn align_down(sp: *mut uint) -> *mut uint {\n #[inline(always)]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     use core::sys::size_of;\n-    unsafe {\n-        (ptr as int + count * (size_of::<T>() as int)) as *mut T\n-    }\n+    (ptr as int + count * (size_of::<T>() as int)) as *mut T\n }\n "}, {"sha": "366996fb93560b275b85e0aae62296258065c699", "filename": "src/libcore/rt/thread_local_storage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread_local_storage.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -21,17 +21,17 @@ pub type Key = pthread_key_t;\n \n #[cfg(unix)]\n pub unsafe fn create(key: &mut Key) {\n-    unsafe { assert!(0 == pthread_key_create(key, null())); }\n+    assert!(0 == pthread_key_create(key, null()));\n }\n \n #[cfg(unix)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n-    unsafe { assert!(0 == pthread_setspecific(key, value)); }\n+    assert!(0 == pthread_setspecific(key, value));\n }\n \n #[cfg(unix)]\n pub unsafe fn get(key: Key) -> *mut c_void {\n-    unsafe { pthread_getspecific(key) }\n+    pthread_getspecific(key)\n }\n \n #[cfg(target_os=\"macos\")]"}, {"sha": "49df2938afd4009c4ab7efd6e151b4f413faa78c", "filename": "src/libcore/run.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -382,64 +382,62 @@ pub struct ProgramOutput {status: int, out: ~str, err: ~str}\n  * the contents of stdout and the contents of stderr.\n  */\n pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n-    unsafe {\n-        let pipe_in = os::pipe();\n-        let pipe_out = os::pipe();\n-        let pipe_err = os::pipe();\n-        let pid = spawn_process(prog, args, &None, &None,\n-                                pipe_in.in, pipe_out.out, pipe_err.out);\n-\n-        os::close(pipe_in.in);\n-        os::close(pipe_out.out);\n-        os::close(pipe_err.out);\n-        if pid == -1i32 {\n-            os::close(pipe_in.out);\n-            os::close(pipe_out.in);\n-            os::close(pipe_err.in);\n-            fail!();\n-        }\n+    let pipe_in = os::pipe();\n+    let pipe_out = os::pipe();\n+    let pipe_err = os::pipe();\n+    let pid = spawn_process(prog, args, &None, &None,\n+                            pipe_in.in, pipe_out.out, pipe_err.out);\n \n+    os::close(pipe_in.in);\n+    os::close(pipe_out.out);\n+    os::close(pipe_err.out);\n+    if pid == -1i32 {\n         os::close(pipe_in.out);\n+        os::close(pipe_out.in);\n+        os::close(pipe_err.in);\n+        fail!();\n+    }\n \n-        // Spawn two entire schedulers to read both stdout and sterr\n-        // in parallel so we don't deadlock while blocking on one\n-        // or the other. FIXME (#2625): Surely there's a much more\n-        // clever way to do this.\n-        let (p, ch) = stream();\n-        let ch = SharedChan(ch);\n-        let ch_clone = ch.clone();\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let errput = readclose(pipe_err.in);\n-            ch.send((2, errput));\n-        };\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let output = readclose(pipe_out.in);\n-            ch_clone.send((1, output));\n-        };\n-        let status = run::waitpid(pid);\n-        let mut errs = ~\"\";\n-        let mut outs = ~\"\";\n-        let mut count = 2;\n-        while count > 0 {\n-            let stream = p.recv();\n-            match stream {\n-                (1, copy s) => {\n-                    outs = s;\n-                }\n-                (2, copy s) => {\n-                    errs = s;\n-                }\n-                (n, _) => {\n-                    fail!(fmt!(\"program_output received an unexpected file \\\n-                               number: %u\", n));\n-                }\n-            };\n-            count -= 1;\n+    os::close(pipe_in.out);\n+\n+    // Spawn two entire schedulers to read both stdout and sterr\n+    // in parallel so we don't deadlock while blocking on one\n+    // or the other. FIXME (#2625): Surely there's a much more\n+    // clever way to do this.\n+    let (p, ch) = stream();\n+    let ch = SharedChan(ch);\n+    let ch_clone = ch.clone();\n+    do task::spawn_sched(task::SingleThreaded) {\n+        let errput = readclose(pipe_err.in);\n+        ch.send((2, errput));\n+    };\n+    do task::spawn_sched(task::SingleThreaded) {\n+        let output = readclose(pipe_out.in);\n+        ch_clone.send((1, output));\n+    };\n+    let status = run::waitpid(pid);\n+    let mut errs = ~\"\";\n+    let mut outs = ~\"\";\n+    let mut count = 2;\n+    while count > 0 {\n+        let stream = p.recv();\n+        match stream {\n+            (1, copy s) => {\n+                outs = s;\n+            }\n+            (2, copy s) => {\n+                errs = s;\n+            }\n+            (n, _) => {\n+                fail!(fmt!(\"program_output received an unexpected file \\\n+                           number: %u\", n));\n+            }\n         };\n-        return ProgramOutput {status: status,\n-                              out: outs,\n-                              err: errs};\n-    }\n+        count -= 1;\n+    };\n+    return ProgramOutput {status: status,\n+                          out: outs,\n+                          err: errs};\n }\n \n pub fn writeclose(fd: c_int, s: ~str) {"}, {"sha": "b0653db365e03c97c1b8d6367ed4d9631d4ab59c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -170,18 +170,16 @@ pub fn push_char(s: &mut ~str, ch: char) {\n /// Convert a char to a string\n pub fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n-    unsafe { push_char(&mut buf, ch); }\n+    push_char(&mut buf, ch);\n     buf\n }\n \n /// Convert a vector of chars to a string\n pub fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n-    unsafe {\n-        reserve(&mut buf, chs.len());\n-        for vec::each(chs) |ch| {\n-            push_char(&mut buf, *ch);\n-        }\n+    reserve(&mut buf, chs.len());\n+    for vec::each(chs) |ch| {\n+        push_char(&mut buf, *ch);\n     }\n     buf\n }\n@@ -226,17 +224,15 @@ pub fn push_str(lhs: &mut ~str, rhs: &str) {\n #[inline(always)]\n pub fn append(lhs: ~str, rhs: &str) -> ~str {\n     let mut v = lhs;\n-    unsafe {\n-        push_str_no_overallocate(&mut v, rhs);\n-    }\n+    push_str_no_overallocate(&mut v, rhs);\n     v\n }\n \n /// Concatenate a vector of strings\n pub fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| {\n-        unsafe { push_str(&mut s, *ss) };\n+        push_str(&mut s, *ss);\n     }\n     s\n }\n@@ -245,8 +241,8 @@ pub fn concat(v: &[~str]) -> ~str {\n pub fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n-        if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n-        unsafe { push_str(&mut s, *ss) };\n+        if first { first = false; } else { push_str(&mut s, sep); }\n+        push_str(&mut s, *ss);\n     }\n     s\n }\n@@ -255,8 +251,8 @@ pub fn connect(v: &[~str], sep: &str) -> ~str {\n pub fn connect_slices(v: &[&str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n-        if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n-        unsafe { push_str(&mut s, *ss) };\n+        if first { first = false; } else { push_str(&mut s, sep); }\n+        push_str(&mut s, *ss);\n     }\n     s\n }\n@@ -2251,16 +2247,14 @@ pub mod raw {\n             assert!((end <= n));\n \n             let mut v = vec::with_capacity(end - begin + 1u);\n-            unsafe {\n-                do vec::as_imm_buf(v) |vbuf, _vlen| {\n-                    let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n-                    let src = ptr::offset(sbuf, begin);\n-                    ptr::copy_memory(vbuf, src, end - begin);\n-                }\n-                vec::raw::set_len(&mut v, end - begin);\n-                v.push(0u8);\n-                ::cast::transmute(v)\n+            do vec::as_imm_buf(v) |vbuf, _vlen| {\n+                let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n+                let src = ptr::offset(sbuf, begin);\n+                ptr::copy_memory(vbuf, src, end - begin);\n             }\n+            vec::raw::set_len(&mut v, end - begin);\n+            v.push(0u8);\n+            ::cast::transmute(v)\n         }\n     }\n \n@@ -2304,7 +2298,7 @@ pub mod raw {\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n-    pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n+    pub fn pop_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n         assert!((len > 0u));\n         let b = s[len - 1u];\n@@ -2313,7 +2307,7 @@ pub mod raw {\n     }\n \n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n-    pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n+    pub fn shift_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n         assert!((len > 0u));\n         let b = s[0];"}, {"sha": "678005ce06f9622bd3a50f9ff6ff882968a47332", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -127,10 +127,8 @@ pub fn refcount<T>(t: @T) -> uint {\n }\n \n pub fn log_str<T>(t: &T) -> ~str {\n-    unsafe {\n-        do io::with_str_writer |wr| {\n-            repr::write_repr(wr, t)\n-        }\n+    do io::with_str_writer |wr| {\n+        repr::write_repr(wr, t)\n     }\n }\n \n@@ -157,10 +155,8 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n }\n \n pub fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n-    unsafe {\n-        let (msg, file) = (msg.to_owned(), file.to_owned());\n-        begin_unwind(~\"assertion failed: \" + msg, file, line)\n-    }\n+    let (msg, file) = (msg.to_owned(), file.to_owned());\n+    begin_unwind(~\"assertion failed: \" + msg, file, line)\n }\n \n #[cfg(test)]"}, {"sha": "d712bf8f98f44960f19141fdb8e24cef6e8a6e7a", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 54, "deletions": 25, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -39,10 +39,9 @@ use result::Result;\n use comm::{stream, Chan, GenericChan, GenericPort, Port};\n use prelude::*;\n use result;\n-use task::rt::{task_id, sched_id};\n+use task::rt::{task_id, sched_id, rust_task};\n use util;\n use util::replace;\n-use unstable::finally::Finally;\n \n #[cfg(test)] use comm::SharedChan;\n \n@@ -566,46 +565,76 @@ pub fn get_scheduler() -> Scheduler {\n  * ~~~\n  */\n pub unsafe fn unkillable<U>(f: &fn() -> U) -> U {\n-    unsafe {\n-        let t = rt::rust_get_task();\n-        rt::rust_task_inhibit_kill(t);\n-        do (|| {\n-            f()\n-        }).finally {\n-            rt::rust_task_allow_kill(t);\n+    struct AllowFailure {\n+        t: *rust_task,\n+        drop {\n+            unsafe {\n+                rt::rust_task_allow_kill(self.t);\n+            }\n+        }\n+    }\n+\n+    fn AllowFailure(t: *rust_task) -> AllowFailure{\n+        AllowFailure {\n+            t: t\n         }\n     }\n+\n+    let t = rt::rust_get_task();\n+    let _allow_failure = AllowFailure(t);\n+    rt::rust_task_inhibit_kill(t);\n+    f()\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n-    unsafe {\n-        let t = rt::rust_get_task();\n-        rt::rust_task_allow_kill(t);\n-        do (|| {\n-            f()\n-        }).finally {\n-            rt::rust_task_inhibit_kill(t);\n+    struct DisallowFailure {\n+        t: *rust_task,\n+        drop {\n+            unsafe {\n+                rt::rust_task_inhibit_kill(self.t);\n+            }\n         }\n     }\n+\n+    fn DisallowFailure(t: *rust_task) -> DisallowFailure {\n+        DisallowFailure {\n+            t: t\n+        }\n+    }\n+\n+    let t = rt::rust_get_task();\n+    let _allow_failure = DisallowFailure(t);\n+    rt::rust_task_allow_kill(t);\n+    f()\n }\n \n /**\n  * A stronger version of unkillable that also inhibits scheduling operations.\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n-    unsafe {\n-        let t = rt::rust_get_task();\n-        rt::rust_task_inhibit_kill(t);\n-        rt::rust_task_inhibit_yield(t);\n-        do (|| {\n-            f()\n-        }).finally {\n-            rt::rust_task_allow_yield(t);\n-            rt::rust_task_allow_kill(t);\n+    struct DeferInterrupts {\n+        t: *rust_task,\n+        drop {\n+            unsafe {\n+                rt::rust_task_allow_yield(self.t);\n+                rt::rust_task_allow_kill(self.t);\n+            }\n         }\n     }\n+\n+    fn DeferInterrupts(t: *rust_task) -> DeferInterrupts {\n+        DeferInterrupts {\n+            t: t\n+        }\n+    }\n+\n+    let t = rt::rust_get_task();\n+    let _interrupts = DeferInterrupts(t);\n+    rt::rust_task_inhibit_kill(t);\n+    rt::rust_task_inhibit_yield(t);\n+    f()\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]"}, {"sha": "c71f7d26d40f1f51901330211651c7991f62378b", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -157,13 +157,13 @@ struct AncestorList(Option<unstable::Exclusive<AncestorNode>>);\n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n-    unsafe { x.with(blk) }\n+    x.with(blk)\n }\n \n #[inline(always)]\n fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n                        blk: &fn(x: &mut AncestorNode) -> U) -> U {\n-    unsafe { x.with(blk) }\n+    x.with(blk)\n }\n \n // Iterates over an ancestor list."}, {"sha": "e43d321dc4d05b86057e7e7c5c22f41c1ee9aafb", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -152,45 +152,37 @@ pub type SharedMutableState<T> = ArcDestruct<T>;\n pub unsafe fn shared_mutable_state<T:Owned>(data: T) ->\n         SharedMutableState<T> {\n     let data = ~ArcData { count: 1, data: Some(data) };\n-    unsafe {\n-        let ptr = cast::transmute(data);\n-        ArcDestruct(ptr)\n-    }\n+    let ptr = cast::transmute(data);\n+    ArcDestruct(ptr)\n }\n \n #[inline(always)]\n pub unsafe fn get_shared_mutable_state<T:Owned>(\n     rc: *SharedMutableState<T>) -> *mut T\n {\n-    unsafe {\n-        let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        assert!(ptr.count > 0);\n-        let r = cast::transmute(ptr.data.get_ref());\n-        cast::forget(ptr);\n-        return r;\n-    }\n+    let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n+    assert!(ptr.count > 0);\n+    let r = cast::transmute(ptr.data.get_ref());\n+    cast::forget(ptr);\n+    return r;\n }\n #[inline(always)]\n pub unsafe fn get_shared_immutable_state<'a,T:Owned>(\n         rc: &'a SharedMutableState<T>) -> &'a T {\n-    unsafe {\n-        let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        assert!(ptr.count > 0);\n-        // Cast us back into the correct region\n-        let r = cast::transmute_region(ptr.data.get_ref());\n-        cast::forget(ptr);\n-        return r;\n-    }\n+    let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n+    assert!(ptr.count > 0);\n+    // Cast us back into the correct region\n+    let r = cast::transmute_region(ptr.data.get_ref());\n+    cast::forget(ptr);\n+    return r;\n }\n \n pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n-    unsafe {\n-        let mut ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n-        assert!(new_count >= 2);\n-        cast::forget(ptr);\n-    }\n+    let mut ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n+    let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n+    assert!(new_count >= 2);\n+    cast::forget(ptr);\n     ArcDestruct((*rc).data)\n }\n "}, {"sha": "8ca5486d929923b9682283b7a7a15d79f3c75f8c", "filename": "src/libcore/unstable/exchange_alloc.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fexchange_alloc.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -19,27 +19,25 @@ use ptr::null;\n use intrinsic::TyDesc;\n \n pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n-    unsafe {\n-        assert!(td.is_not_null());\n+    assert!(td.is_not_null());\n \n-        let total_size = get_box_size(size, (*td).align);\n-        let p = c_malloc(total_size as size_t);\n-        assert!(p.is_not_null());\n+    let total_size = get_box_size(size, (*td).align);\n+    let p = c_malloc(total_size as size_t);\n+    assert!(p.is_not_null());\n \n-        // FIXME #3475: Converting between our two different tydesc types\n-        let td: *TyDesc = transmute(td);\n+    // FIXME #3475: Converting between our two different tydesc types\n+    let td: *TyDesc = transmute(td);\n \n-        let box: &mut BoxRepr = transmute(p);\n-        box.header.ref_count = -1; // Exchange values not ref counted\n-        box.header.type_desc = td;\n-        box.header.prev = null();\n-        box.header.next = null();\n+    let box: &mut BoxRepr = transmute(p);\n+    box.header.ref_count = -1; // Exchange values not ref counted\n+    box.header.type_desc = td;\n+    box.header.prev = null();\n+    box.header.next = null();\n \n-        let exchange_count = &mut *rust_get_exchange_count_ptr();\n-        atomic_xadd(exchange_count, 1);\n+    let exchange_count = &mut *rust_get_exchange_count_ptr();\n+    atomic_xadd(exchange_count, 1);\n \n-        return transmute(box);\n-    }\n+    return transmute(box);\n }\n /**\n Thin wrapper around libc::malloc, none of the box header"}, {"sha": "ad3dce0a7499253ef7e7be4f63a6a55b1b1a3b96", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -512,7 +512,7 @@ pub mod rt {\n                 None\n             }\n         } else { Some('-') };\n-        unsafe { pad(cv, s, head, PadSigned, buf) };\n+        pad(cv, s, head, PadSigned, buf);\n     }\n     pub fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n         let prec = get_int_precision(cv);\n@@ -524,7 +524,7 @@ pub mod rt {\n               TyBits => uint_to_str_prec(u, 2, prec),\n               TyOctal => uint_to_str_prec(u, 8, prec)\n             };\n-        unsafe { pad(cv, rs, None, PadUnsigned, buf) };\n+        pad(cv, rs, None, PadUnsigned, buf);\n     }\n     pub fn conv_bool(cv: Conv, b: bool, buf: &mut ~str) {\n         let s = if b { \"true\" } else { \"false\" };\n@@ -533,7 +533,7 @@ pub mod rt {\n         conv_str(cv, s, buf);\n     }\n     pub fn conv_char(cv: Conv, c: char, buf: &mut ~str) {\n-        unsafe { pad(cv, \"\", Some(c), PadNozero, buf) };\n+        pad(cv, \"\", Some(c), PadNozero, buf);\n     }\n     pub fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n         // For strings, precision is the maximum characters\n@@ -546,14 +546,14 @@ pub mod rt {\n             s\n           }\n         };\n-        unsafe { pad(cv, unpadded, None, PadNozero, buf) };\n+        pad(cv, unpadded, None, PadNozero, buf);\n     }\n     pub fn conv_float(cv: Conv, f: float, buf: &mut ~str) {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str_digits, 6u)\n         };\n-        let mut s = unsafe { to_str(f, digits) };\n+        let mut s = to_str(f, digits);\n         let head = if 0.0 <= f {\n             if have_flag(cv.flags, flag_sign_always) {\n                 Some('+')\n@@ -563,7 +563,7 @@ pub mod rt {\n                 None\n             }\n         } else { None };\n-        unsafe { pad(cv, s, head, PadFloat, buf) };\n+        pad(cv, s, head, PadFloat, buf);\n     }\n     pub fn conv_poly<T>(cv: Conv, v: &T, buf: &mut ~str) {\n         let s = sys::log_str(v);"}, {"sha": "be776a39742f0073439576460beb12aac07f45dc", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -44,7 +44,7 @@ pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n }\n \n #[lang=\"fail_bounds_check\"]\n-pub unsafe fn fail_bounds_check(file: *c_char, line: size_t,\n+pub fn fail_bounds_check(file: *c_char, line: size_t,\n                                 index: size_t, len: size_t) {\n     let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n                     len as int, index as int);\n@@ -53,7 +53,7 @@ pub unsafe fn fail_bounds_check(file: *c_char, line: size_t,\n     }\n }\n \n-pub unsafe fn fail_borrowed() {\n+pub fn fail_borrowed() {\n     let msg = \"borrowed\";\n     do str::as_buf(msg) |msg_p, _| {\n         do str::as_buf(\"???\") |file_p, _| {"}, {"sha": "1c99566280815532df481db91125830e6550fdfb", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -615,9 +615,7 @@ pub fn build_link_meta(sess: Session, c: &ast::crate, output: &Path,\n }\n \n pub fn truncated_hash_result(symbol_hasher: &hash::State) -> ~str {\n-    unsafe {\n-        symbol_hasher.result_str()\n-    }\n+    symbol_hasher.result_str()\n }\n \n "}, {"sha": "116b70bf7e3200e8afbaba1e6f670b07573a3050", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 86, "deletions": 34, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -33,20 +33,26 @@ use util::ppaux::ty_to_str;\n \n use core::hashmap::HashSet;\n use core::uint;\n+use core::util::with;\n use syntax::ast::m_mutbl;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::span;\n use syntax::print::pprust;\n use syntax::visit;\n \n+struct PurityState {\n+    def: ast::node_id,\n+    purity: ast::purity\n+}\n+\n struct CheckLoanCtxt {\n     bccx: @BorrowckCtxt,\n     req_maps: ReqMaps,\n \n     reported: HashSet<ast::node_id>,\n \n-    declared_purity: @mut ast::purity,\n+    declared_purity: @mut PurityState,\n     fn_args: @mut @~[ast::node_id]\n }\n \n@@ -62,14 +68,25 @@ enum purity_cause {\n     pc_cmt(bckerr)\n }\n \n+// if we're not pure, why?\n+#[deriving(Eq)]\n+enum impurity_cause {\n+    // some surrounding block was marked as 'unsafe'\n+    pc_unsafe,\n+\n+    // nothing was unsafe, and nothing was pure\n+    pc_default,\n+}\n+\n pub fn check_loans(bccx: @BorrowckCtxt,\n                    +req_maps: ReqMaps,\n                    crate: @ast::crate) {\n     let clcx = @mut CheckLoanCtxt {\n         bccx: bccx,\n         req_maps: req_maps,\n         reported: HashSet::new(),\n-        declared_purity: @mut ast::impure_fn,\n+        declared_purity: @mut PurityState { purity: ast::impure_fn,\n+                                            def: 0 },\n         fn_args: @mut @~[]\n     };\n     let vt = visit::mk_vt(@visit::Visitor {visit_expr: check_loans_in_expr,\n@@ -106,16 +123,18 @@ pub impl assignment_type {\n pub impl CheckLoanCtxt {\n     fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n-    fn purity(&mut self, scope_id: ast::node_id) -> Option<purity_cause> {\n-        let default_purity = match *self.declared_purity {\n+    fn purity(&mut self, scope_id: ast::node_id)\n+                -> Either<purity_cause, impurity_cause>\n+    {\n+        let default_purity = match self.declared_purity.purity {\n           // an unsafe declaration overrides all\n-          ast::unsafe_fn => return None,\n+          ast::unsafe_fn => return Right(pc_unsafe),\n \n           // otherwise, remember what was declared as the\n           // default, but we must scan for requirements\n           // imposed by the borrow check\n-          ast::pure_fn => Some(pc_pure_fn),\n-          ast::extern_fn | ast::impure_fn => None\n+          ast::pure_fn => Left(pc_pure_fn),\n+          ast::extern_fn | ast::impure_fn => Right(pc_default)\n         };\n \n         // scan to see if this scope or any enclosing scope requires\n@@ -125,7 +144,7 @@ pub impl CheckLoanCtxt {\n         loop {\n             match self.req_maps.pure_map.find(&scope_id) {\n               None => (),\n-              Some(e) => return Some(pc_cmt(*e))\n+              Some(e) => return Left(pc_cmt(*e))\n             }\n \n             match self.tcx().region_maps.opt_encl_scope(scope_id) {\n@@ -171,7 +190,7 @@ pub impl CheckLoanCtxt {\n     // overloaded operators the callee has an id but no expr.\n     // annoying.\n     fn check_pure_callee_or_arg(&mut self,\n-                                pc: purity_cause,\n+                                pc: Either<purity_cause, impurity_cause>,\n                                 opt_expr: Option<@ast::expr>,\n                                 callee_id: ast::node_id,\n                                 callee_span: span) {\n@@ -196,7 +215,7 @@ pub impl CheckLoanCtxt {\n         match opt_expr {\n           Some(expr) => {\n             match expr.node {\n-              ast::expr_path(_) if pc == pc_pure_fn => {\n+              ast::expr_path(_) if pc == Left(pc_pure_fn) => {\n                 let def = *self.tcx().def_map.get(&expr.id);\n                 let did = ast_util::def_id_of_def(def);\n                 let is_fn_arg =\n@@ -361,10 +380,10 @@ pub impl CheckLoanCtxt {\n         // if this is a pure function, only loan-able state can be\n         // assigned, because it is uniquely tied to this function and\n         // is not visible from the outside\n-        match self.purity(ex.id) {\n-          None => (),\n-          Some(pc_cmt(_)) => {\n-            let purity = self.purity(ex.id).get();\n+        let purity = self.purity(ex.id);\n+        match purity {\n+          Right(_) => (),\n+          Left(pc_cmt(_)) => {\n             // Subtle: Issue #3162.  If we are enforcing purity\n             // because there is a reference to aliasable, mutable data\n             // that we require to be immutable, we can't allow writes\n@@ -376,10 +395,10 @@ pub impl CheckLoanCtxt {\n                 ex.span,\n                 at.ing_form(self.bccx.cmt_to_str(cmt)));\n           }\n-          Some(pc_pure_fn) => {\n+          Left(pc_pure_fn) => {\n             if cmt.lp.is_none() {\n                 self.report_purity_error(\n-                    pc_pure_fn, ex.span,\n+                    purity, ex.span,\n                     at.ing_form(self.bccx.cmt_to_str(cmt)));\n             }\n           }\n@@ -462,14 +481,23 @@ pub impl CheckLoanCtxt {\n         }\n     }\n \n-    fn report_purity_error(&mut self, pc: purity_cause, sp: span, msg: ~str) {\n+    fn report_purity_error(&mut self, pc: Either<purity_cause, impurity_cause>,\n+                           sp: span, msg: ~str) {\n         match pc {\n-          pc_pure_fn => {\n+          Right(pc_default) => { fail!(~\"pc_default should be filtered sooner\") }\n+          Right(pc_unsafe) => {\n+            // this error was prevented by being marked as unsafe, so flag the\n+            // definition as having contributed to the validity of the program\n+            let def = self.declared_purity.def;\n+            debug!(\"flagging %? as a used unsafe source\", def);\n+            self.tcx().used_unsafe.insert(def);\n+          }\n+          Left(pc_pure_fn) => {\n             self.tcx().sess.span_err(\n                 sp,\n                 fmt!(\"%s prohibited in pure context\", msg));\n           }\n-          pc_cmt(ref e) => {\n+          Left(pc_cmt(ref e)) => {\n             if self.reported.insert((*e).cmt.id) {\n                 self.tcx().sess.span_err(\n                     (*e).cmt.span,\n@@ -556,16 +584,32 @@ pub impl CheckLoanCtxt {\n                   callee_id: ast::node_id,\n                   callee_span: span,\n                   args: &[@ast::expr]) {\n-        match self.purity(expr.id) {\n-          None => {}\n-          Some(ref pc) => {\n-            self.check_pure_callee_or_arg(\n-                (*pc), callee, callee_id, callee_span);\n-            for args.each |arg| {\n-                self.check_pure_callee_or_arg(\n-                    (*pc), Some(*arg), arg.id, arg.span);\n+        let pc = self.purity(expr.id);\n+        match pc {\n+            // no purity, no need to check for anything\n+            Right(pc_default) => return,\n+\n+            // some form of purity, definitely need to check\n+            Left(_) => (),\n+\n+            // Unsafe trumped. To see if the unsafe is necessary, see what the\n+            // purity would have been without a trump, and if it's some form\n+            // of purity then we need to go ahead with the check\n+            Right(pc_unsafe) => {\n+                match do with(&mut self.declared_purity.purity,\n+                              ast::impure_fn) { self.purity(expr.id) } {\n+                    Right(pc_unsafe) => fail!(~\"unsafe can't trump twice\"),\n+                    Right(pc_default) => return,\n+                    Left(_) => ()\n+                }\n             }\n-          }\n+\n+        }\n+        self.check_pure_callee_or_arg(\n+            pc, callee, callee_id, callee_span);\n+        for args.each |arg| {\n+            self.check_pure_callee_or_arg(\n+                pc, Some(*arg), arg.id, arg.span);\n         }\n     }\n }\n@@ -580,27 +624,32 @@ fn check_loans_in_fn(fk: &visit::fn_kind,\n     let is_stack_closure = self.is_stack_closure(id);\n     let fty = ty::node_id_to_type(self.tcx(), id);\n \n-    let declared_purity;\n+    let declared_purity, src;\n     match *fk {\n         visit::fk_item_fn(*) | visit::fk_method(*) |\n         visit::fk_dtor(*) => {\n             declared_purity = ty::ty_fn_purity(fty);\n+            src = id;\n         }\n \n         visit::fk_anon(*) | visit::fk_fn_block(*) => {\n             let fty_sigil = ty::ty_closure_sigil(fty);\n             check_moves_from_captured_variables(self, id, fty_sigil);\n-            declared_purity = ty::determine_inherited_purity(\n-                *self.declared_purity,\n-                ty::ty_fn_purity(fty),\n+            let pair = ty::determine_inherited_purity(\n+                (self.declared_purity.purity, self.declared_purity.def),\n+                (ty::ty_fn_purity(fty), id),\n                 fty_sigil);\n+            declared_purity = pair.first();\n+            src = pair.second();\n         }\n     }\n \n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n     do save_and_restore_managed(self.declared_purity) {\n         do save_and_restore_managed(self.fn_args) {\n-            *self.declared_purity = declared_purity;\n+            self.declared_purity = @mut PurityState {\n+                purity: declared_purity, def: src\n+            };\n \n             match *fk {\n                 visit::fk_anon(*) |\n@@ -754,7 +803,10 @@ fn check_loans_in_block(blk: &ast::blk,\n           ast::default_blk => {\n           }\n           ast::unsafe_blk => {\n-            *self.declared_purity = ast::unsafe_fn;\n+            *self.declared_purity = PurityState {\n+                purity: ast::unsafe_fn,\n+                def: blk.node.id,\n+            };\n           }\n         }\n "}, {"sha": "bacbeb851aa82624e6376571ff7e54847ed1d593", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -369,7 +369,7 @@ pub impl<'self> LanguageItemCollector<'self> {\n     }\n \n     fn collect_local_language_items(&self) {\n-        let this = unsafe { ptr::addr_of(&self) };\n+        let this = ptr::addr_of(&self);\n         visit_crate(*self.crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 for item.attrs.each |attribute| {"}, {"sha": "876ed76f98741b0bcc848f5507414da86ece0a89", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -75,6 +75,7 @@ pub enum lint {\n     default_methods,\n     deprecated_mutable_fields,\n     deprecated_drop,\n+    unused_unsafe,\n     foreign_mode,\n \n     managed_heap_memory,\n@@ -256,6 +257,13 @@ pub fn get_lint_dict() -> LintDict {\n             default: deny\n         }),\n \n+        (~\"unused_unsafe\",\n+         LintSpec {\n+            lint: unused_unsafe,\n+            desc: \"unnecessary use of an \\\"unsafe\\\" block or function\",\n+            default: warn\n+        }),\n+\n         (~\"unused_variable\",\n          LintSpec {\n             lint: unused_variable,\n@@ -490,6 +498,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_default_methods(cx, i);\n     check_item_deprecated_mutable_fields(cx, i);\n     check_item_deprecated_drop(cx, i);\n+    check_item_unused_unsafe(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -923,19 +932,55 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     }\n }\n \n+fn check_item_unused_unsafe(cx: ty::ctxt, it: @ast::item) {\n+    let visit_expr: @fn(@ast::expr) = |e| {\n+        match e.node {\n+            ast::expr_block(ref blk) if blk.node.rules == ast::unsafe_blk => {\n+                if !cx.used_unsafe.contains(&blk.node.id) {\n+                    cx.sess.span_lint(unused_unsafe, blk.node.id, it.id,\n+                                      blk.span,\n+                                      ~\"unnecessary \\\"unsafe\\\" block\");\n+                }\n+            }\n+            _ => ()\n+        }\n+    };\n+\n+    let visit = item_stopping_visitor(\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_expr: visit_expr,\n+            .. *visit::default_simple_visitor()\n+        }));\n+    visit::visit_item(it, (), visit);\n+}\n+\n fn check_fn(tcx: ty::ctxt, fk: &visit::fn_kind, decl: &ast::fn_decl,\n             _body: &ast::blk, span: span, id: ast::node_id) {\n     debug!(\"lint check_fn fk=%? id=%?\", fk, id);\n \n-    // don't complain about blocks, since they tend to get their modes\n-    // specified from the outside\n+    // Check for an 'unsafe fn' which doesn't need to be unsafe\n+    match *fk {\n+        visit::fk_item_fn(_, _, ast::unsafe_fn, _) => {\n+            if !tcx.used_unsafe.contains(&id) {\n+                tcx.sess.span_lint(unused_unsafe, id, id, span,\n+                                   ~\"unnecessary \\\"unsafe\\\" function\");\n+            }\n+        }\n+        _ => ()\n+    }\n+\n+    // Check for deprecated modes\n     match *fk {\n-      visit::fk_fn_block(*) => { return; }\n-      _ => {}\n+        // don't complain about blocks, since they tend to get their modes\n+        // specified from the outside\n+        visit::fk_fn_block(*) => {}\n+\n+        _ => {\n+            let fn_ty = ty::node_id_to_type(tcx, id);\n+            check_fn_deprecated_modes(tcx, fn_ty, decl, span, id);\n+        }\n     }\n \n-    let fn_ty = ty::node_id_to_type(tcx, id);\n-    check_fn_deprecated_modes(tcx, fn_ty, decl, span, id);\n }\n \n fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: &ast::fn_decl,"}, {"sha": "b2225963d2c33738c5c370f54664c42b44dc49fc", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -19,7 +19,7 @@ use metadata::csearch::get_type_name_if_impl;\n use metadata::cstore::find_extern_mod_stmt_cnum;\n use metadata::decoder::{def_like, dl_def, dl_field, dl_impl};\n use middle::lang_items::LanguageItems;\n-use middle::lint::{deny, allow, forbid, level, unused_imports, warn};\n+use middle::lint::{allow, level, unused_imports};\n use middle::lint::{get_lint_level, get_lint_settings_level};\n use middle::pat_util::pat_bindings;\n \n@@ -5212,17 +5212,11 @@ pub impl Resolver {\n                     import_resolution.span != dummy_sp() &&\n                     import_resolution.privacy != Public {\n                 import_resolution.state.warned = true;\n-                match self.unused_import_lint_level(module_) {\n-                    warn => {\n-                        self.session.span_warn(copy import_resolution.span,\n-                                               ~\"unused import\");\n-                    }\n-                    deny | forbid => {\n-                      self.session.span_err(copy import_resolution.span,\n-                                            ~\"unused import\");\n-                    }\n-                    allow => ()\n-                }\n+                let span = import_resolution.span;\n+                self.session.span_lint_level(\n+                    self.unused_import_lint_level(module_),\n+                    span,\n+                    ~\"unused import\");\n             }\n         }\n     }"}, {"sha": "f58e066526c24bae4efb66a6243f02f261179d2b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -91,10 +91,8 @@ pub struct icx_popper {\n #[unsafe_destructor]\n impl Drop for icx_popper {\n     fn finalize(&self) {\n-        unsafe {\n-            if self.ccx.sess.count_llvm_insns() {\n-                self.ccx.stats.llvm_insn_ctxt.pop();\n-            }\n+        if self.ccx.sess.count_llvm_insns() {\n+            self.ccx.stats.llvm_insn_ctxt.pop();\n         }\n     }\n }\n@@ -145,9 +143,7 @@ pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n             llvm::LLVMGetOrInsertFunction(llmod, buf, llty)\n         }\n     });\n-    unsafe {\n-        lib::llvm::SetFunctionCallConv(llfn, cc);\n-    }\n+    lib::llvm::SetFunctionCallConv(llfn, cc);\n     return llfn;\n }\n \n@@ -730,11 +726,9 @@ pub fn cast_shift_expr_rhs(cx: block, op: ast::binop,\n \n pub fn cast_shift_const_rhs(op: ast::binop,\n                             lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    unsafe {\n-        cast_shift_rhs(op, lhs, rhs,\n-                       |a, b| unsafe { llvm::LLVMConstTrunc(a, b) },\n-                       |a, b| unsafe { llvm::LLVMConstZExt(a, b) })\n-    }\n+    cast_shift_rhs(op, lhs, rhs,\n+                   |a, b| unsafe { llvm::LLVMConstTrunc(a, b) },\n+                   |a, b| unsafe { llvm::LLVMConstZExt(a, b) })\n }\n \n pub fn cast_shift_rhs(op: ast::binop,\n@@ -2865,9 +2859,7 @@ pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n             llvm::LLVMAddGlobal(ccx.llmod, maptype, buf)\n         }\n     });\n-    unsafe {\n-        lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n-    }\n+    lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n     for ccx.module_data.each |key, &val| {\n         let elt = C_struct(~[p2i(ccx, C_cstr(ccx, @/*bad*/ copy *key)),"}, {"sha": "d6c045bb1158bca2e24ea99ff7e91e27f89c1ea1", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -27,9 +27,7 @@ use core::str;\n use core::vec;\n \n pub fn terminate(cx: block, _: &str) {\n-    unsafe {\n-        cx.terminated = true;\n-    }\n+    cx.terminated = true;\n }\n \n pub fn check_not_terminated(cx: block) {"}, {"sha": "c02417aca8b12db9ff1671126ec9e7316e91e527", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 142, "deletions": 152, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -172,74 +172,68 @@ fn cast_safely<T:Copy,U>(val: T) -> U {\n }\n \n fn md_from_metadata<T>(val: debug_metadata) -> T {\n-    unsafe {\n-        match val {\n-          file_metadata(md) => cast_safely(md),\n-          compile_unit_metadata(md) => cast_safely(md),\n-          subprogram_metadata(md) => cast_safely(md),\n-          local_var_metadata(md) => cast_safely(md),\n-          tydesc_metadata(md) => cast_safely(md),\n-          block_metadata(md) => cast_safely(md),\n-          argument_metadata(md) => cast_safely(md),\n-          retval_metadata(md) => cast_safely(md)\n-        }\n+    match val {\n+      file_metadata(md) => cast_safely(md),\n+      compile_unit_metadata(md) => cast_safely(md),\n+      subprogram_metadata(md) => cast_safely(md),\n+      local_var_metadata(md) => cast_safely(md),\n+      tydesc_metadata(md) => cast_safely(md),\n+      block_metadata(md) => cast_safely(md),\n+      argument_metadata(md) => cast_safely(md),\n+      retval_metadata(md) => cast_safely(md)\n     }\n }\n \n fn cached_metadata<T:Copy>(cache: metadata_cache,\n                             mdtag: int,\n                             eq_fn: &fn(md: T) -> bool)\n                          -> Option<T> {\n-    unsafe {\n-        if cache.contains_key(&mdtag) {\n-            let items = cache.get(&mdtag);\n-            for items.each |item| {\n-                let md: T = md_from_metadata::<T>(*item);\n-                if eq_fn(md) {\n-                    return option::Some(md);\n-                }\n+    if cache.contains_key(&mdtag) {\n+        let items = cache.get(&mdtag);\n+        for items.each |item| {\n+            let md: T = md_from_metadata::<T>(*item);\n+            if eq_fn(md) {\n+                return option::Some(md);\n             }\n         }\n-        return option::None;\n     }\n+    return option::None;\n }\n \n fn create_compile_unit(cx: @CrateContext) -> @Metadata<CompileUnitMetadata> {\n-    unsafe {\n-        let cache = get_cache(cx);\n-        let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n-        let tg = CompileUnitTag;\n-        match cached_metadata::<@Metadata<CompileUnitMetadata>>(cache, tg,\n-                            |md| md.data.name == crate_name) {\n-          option::Some(md) => return md,\n-          option::None => ()\n-        }\n+    let cache = get_cache(cx);\n+    let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n+    let tg = CompileUnitTag;\n+    match cached_metadata::<@Metadata<CompileUnitMetadata>>(cache, tg,\n+                        |md| md.data.name == crate_name) {\n+      option::Some(md) => return md,\n+      option::None => ()\n+    }\n \n-        let (_, work_dir) = get_file_path_and_dir(\n-            cx.sess.working_dir.to_str(), crate_name);\n-        let unit_metadata = ~[lltag(tg),\n-                             llunused(),\n-                             lli32(DW_LANG_RUST),\n-                             llstr(crate_name),\n-                             llstr(work_dir),\n-                             llstr(env!(\"CFG_VERSION\")),\n-                             lli1(true), // deprecated: main compile unit\n-                             lli1(cx.sess.opts.optimize != session::No),\n-                             llstr(~\"\"), // flags (???)\n-                             lli32(0) // runtime version (???)\n-                            ];\n-        let unit_node = llmdnode(unit_metadata);\n-        add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n-        let mdval = @Metadata {\n-            node: unit_node,\n-            data: CompileUnitMetadata {\n-                name: crate_name\n-            }\n-        };\n-        update_cache(cache, tg, compile_unit_metadata(mdval));\n+    let (_, work_dir) = get_file_path_and_dir(\n+        cx.sess.working_dir.to_str(), crate_name);\n+    let unit_metadata = ~[lltag(tg),\n+                         llunused(),\n+                         lli32(DW_LANG_RUST),\n+                         llstr(crate_name),\n+                         llstr(work_dir),\n+                         llstr(env!(\"CFG_VERSION\")),\n+                         lli1(true), // deprecated: main compile unit\n+                         lli1(cx.sess.opts.optimize != session::No),\n+                         llstr(~\"\"), // flags (???)\n+                         lli32(0) // runtime version (???)\n+                        ];\n+    let unit_node = llmdnode(unit_metadata);\n+    add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n+    let mdval = @Metadata {\n+        node: unit_node,\n+        data: CompileUnitMetadata {\n+            name: crate_name\n+        }\n+    };\n+    update_cache(cache, tg, compile_unit_metadata(mdval));\n \n-        return mdval;\n-    }\n+    return mdval;\n }\n \n fn get_cache(cx: @CrateContext) -> metadata_cache {\n@@ -710,113 +704,109 @@ fn create_var(type_tag: int, context: ValueRef, name: &str, file: ValueRef,\n \n pub fn create_local_var(bcx: block, local: @ast::local)\n     -> @Metadata<LocalVarMetadata> {\n-    unsafe {\n-        let cx = bcx.ccx();\n-        let cache = get_cache(cx);\n-        let tg = AutoVariableTag;\n-        match cached_metadata::<@Metadata<LocalVarMetadata>>(\n-            cache, tg, |md| md.data.id == local.node.id) {\n-          option::Some(md) => return md,\n-          option::None => ()\n+    let cx = bcx.ccx();\n+    let cache = get_cache(cx);\n+    let tg = AutoVariableTag;\n+    match cached_metadata::<@Metadata<LocalVarMetadata>>(\n+        cache, tg, |md| md.data.id == local.node.id) {\n+      option::Some(md) => return md,\n+      option::None => ()\n+    }\n+\n+    let name = match local.node.pat.node {\n+      ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n+      // FIXME this should be handled (#2533)\n+      _ => fail!(~\"no single variable name for local\")\n+    };\n+    let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n+    let ty = node_id_type(bcx, local.node.id);\n+    let tymd = create_ty(cx, ty, local.node.ty.span);\n+    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n+    let context = match bcx.parent {\n+        None => create_function(bcx.fcx).node,\n+        Some(_) => create_block(bcx).node\n+    };\n+    let mdnode = create_var(tg, context, *cx.sess.str_of(name),\n+                            filemd.node, loc.line as int, tymd.node);\n+    let mdval = @Metadata {\n+        node: mdnode,\n+        data: LocalVarMetadata {\n+            id: local.node.id\n         }\n+    };\n+    update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n \n-        let name = match local.node.pat.node {\n-          ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n-          // FIXME this should be handled (#2533)\n-          _ => fail!(~\"no single variable name for local\")\n-        };\n-        let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n-        let ty = node_id_type(bcx, local.node.id);\n-        let tymd = create_ty(cx, ty, local.node.ty.span);\n-        let filemd = create_file(cx, /*bad*/copy loc.file.name);\n-        let context = match bcx.parent {\n-            None => create_function(bcx.fcx).node,\n-            Some(_) => create_block(bcx).node\n-        };\n-        let mdnode = create_var(tg, context, *cx.sess.str_of(name),\n-                                filemd.node, loc.line as int, tymd.node);\n-        let mdval = @Metadata {\n-            node: mdnode,\n-            data: LocalVarMetadata {\n-                id: local.node.id\n-            }\n-        };\n-        update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n-\n-        let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n-          option::Some(&local_mem(v)) => v,\n-          option::Some(_) => {\n-            bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                    something weird\");\n-          }\n-          option::None => {\n-            match *bcx.fcx.lllocals.get(&local.node.pat.id) {\n-              local_imm(v) => v,\n-              _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n-                                                         something weird\")\n-            }\n-          }\n-        };\n-        let declargs = ~[llmdnode(~[llptr]), mdnode];\n-        trans::build::Call(bcx, *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n-                           declargs);\n-        return mdval;\n-    }\n+    let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n+      option::Some(&local_mem(v)) => v,\n+      option::Some(_) => {\n+        bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n+                something weird\");\n+      }\n+      option::None => {\n+        match *bcx.fcx.lllocals.get(&local.node.pat.id) {\n+          local_imm(v) => v,\n+          _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n+                                                     something weird\")\n+        }\n+      }\n+    };\n+    let declargs = ~[llmdnode(~[llptr]), mdnode];\n+    trans::build::Call(bcx, *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+                       declargs);\n+    return mdval;\n }\n \n pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     -> Option<@Metadata<ArgumentMetadata>> {\n-    unsafe {\n-        let fcx = bcx.fcx, cx = *fcx.ccx;\n-        let cache = get_cache(cx);\n-        let tg = ArgVariableTag;\n-        match cached_metadata::<@Metadata<ArgumentMetadata>>(\n-            cache, ArgVariableTag, |md| md.data.id == arg.id) {\n-          option::Some(md) => return Some(md),\n-          option::None => ()\n-        }\n+    let fcx = bcx.fcx, cx = *fcx.ccx;\n+    let cache = get_cache(cx);\n+    let tg = ArgVariableTag;\n+    match cached_metadata::<@Metadata<ArgumentMetadata>>(\n+        cache, ArgVariableTag, |md| md.data.id == arg.id) {\n+      option::Some(md) => return Some(md),\n+      option::None => ()\n+    }\n \n-        let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n-        if loc.file.name == ~\"<intrinsic>\" {\n-            return None;\n+    let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n+    if loc.file.name == ~\"<intrinsic>\" {\n+        return None;\n+    }\n+    let ty = node_id_type(bcx, arg.id);\n+    let tymd = create_ty(cx, ty, arg.ty.span);\n+    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n+    let context = create_function(bcx.fcx);\n+\n+    match arg.pat.node {\n+        ast::pat_ident(_, path, _) => {\n+            // XXX: This is wrong; it should work for multiple bindings.\n+            let mdnode = create_var(\n+                tg,\n+                context.node,\n+                *cx.sess.str_of(*path.idents.last()),\n+                filemd.node,\n+                loc.line as int,\n+                tymd.node\n+            );\n+\n+            let mdval = @Metadata {\n+                node: mdnode,\n+                data: ArgumentMetadata {\n+                    id: arg.id\n+                }\n+            };\n+            update_cache(cache, tg, argument_metadata(mdval));\n+\n+            let llptr = match *fcx.llargs.get(&arg.id) {\n+              local_mem(v) | local_imm(v) => v,\n+            };\n+            let declargs = ~[llmdnode(~[llptr]), mdnode];\n+            trans::build::Call(bcx,\n+                               *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+                               declargs);\n+            return Some(mdval);\n         }\n-        let ty = node_id_type(bcx, arg.id);\n-        let tymd = create_ty(cx, ty, arg.ty.span);\n-        let filemd = create_file(cx, /*bad*/copy loc.file.name);\n-        let context = create_function(bcx.fcx);\n-\n-        match arg.pat.node {\n-            ast::pat_ident(_, path, _) => {\n-                // XXX: This is wrong; it should work for multiple bindings.\n-                let mdnode = create_var(\n-                    tg,\n-                    context.node,\n-                    *cx.sess.str_of(*path.idents.last()),\n-                    filemd.node,\n-                    loc.line as int,\n-                    tymd.node\n-                );\n-\n-                let mdval = @Metadata {\n-                    node: mdnode,\n-                    data: ArgumentMetadata {\n-                        id: arg.id\n-                    }\n-                };\n-                update_cache(cache, tg, argument_metadata(mdval));\n-\n-                let llptr = match *fcx.llargs.get(&arg.id) {\n-                  local_mem(v) | local_imm(v) => v,\n-                };\n-                let declargs = ~[llmdnode(~[llptr]), mdnode];\n-                trans::build::Call(bcx,\n-                                   *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n-                                   declargs);\n-                return Some(mdval);\n-            }\n-            _ => {\n-                return None;\n-            }\n+        _ => {\n+            return None;\n         }\n     }\n }"}, {"sha": "f62e366ebdcaa8432e9996db4616a85e8abdb26f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -300,7 +300,11 @@ struct ctxt_ {\n     destructors: @mut HashSet<ast::def_id>,\n \n     // Maps a trait onto a mapping from self-ty to impl\n-    trait_impls: @mut HashMap<ast::def_id, @mut HashMap<t, @Impl>>\n+    trait_impls: @mut HashMap<ast::def_id, @mut HashMap<t, @Impl>>,\n+\n+    // Set of used unsafe nodes (functions or blocks). Unsafe nodes not\n+    // present in this set can be warned about.\n+    used_unsafe: @mut HashSet<ast::node_id>,\n }\n \n enum tbox_flag {\n@@ -885,7 +889,8 @@ pub fn mk_ctxt(s: session::Session,\n         supertraits: @mut HashMap::new(),\n         destructor_for_type: @mut HashMap::new(),\n         destructors: @mut HashSet::new(),\n-        trait_impls: @mut HashMap::new()\n+        trait_impls: @mut HashMap::new(),\n+        used_unsafe: @mut HashSet::new(),\n      }\n }\n \n@@ -4309,16 +4314,16 @@ pub fn eval_repeat_count(tcx: ctxt, count_expr: @ast::expr) -> uint {\n }\n \n // Determine what purity to check a nested function under\n-pub fn determine_inherited_purity(parent_purity: ast::purity,\n-                                       child_purity: ast::purity,\n-                                       child_sigil: ast::Sigil)\n-                                    -> ast::purity {\n+pub fn determine_inherited_purity(parent: (ast::purity, ast::node_id),\n+                                  child: (ast::purity, ast::node_id),\n+                                  child_sigil: ast::Sigil)\n+                                    -> (ast::purity, ast::node_id) {\n     // If the closure is a stack closure and hasn't had some non-standard\n     // purity inferred for it, then check it under its parent's purity.\n     // Otherwise, use its own\n     match child_sigil {\n-        ast::BorrowedSigil if child_purity == ast::impure_fn => parent_purity,\n-        _ => child_purity\n+        ast::BorrowedSigil if child.first() == ast::impure_fn => parent,\n+        _ => child\n     }\n }\n "}, {"sha": "5ec4c233bc0d24abfa8da3b19a68bb5d87e612c4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -179,6 +179,11 @@ pub enum FnKind {\n     Vanilla\n }\n \n+struct PurityState {\n+    purity: ast::purity,\n+    from: ast::node_id,\n+}\n+\n pub struct FnCtxt {\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n@@ -187,7 +192,7 @@ pub struct FnCtxt {\n     ret_ty: ty::t,\n     // Used by loop bodies that return from the outer function\n     indirect_ret_ty: Option<ty::t>,\n-    purity: ast::purity,\n+    ps: PurityState,\n \n     // Sometimes we generate region pointers where the precise region\n     // to use is not known. For example, an expression like `&x.f`\n@@ -238,7 +243,7 @@ pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n     @mut FnCtxt {\n         ret_ty: rty,\n         indirect_ret_ty: None,\n-        purity: ast::pure_fn,\n+        ps: PurityState { purity: ast::pure_fn, from: 0 },\n         region_lb: region_bnd,\n         in_scope_regions: @Nil,\n         fn_kind: Vanilla,\n@@ -265,7 +270,7 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n         ty::ty_bare_fn(ref fn_ty) => {\n             let fcx =\n                 check_fn(ccx, self_info, fn_ty.purity,\n-                         &fn_ty.sig, decl, body, Vanilla,\n+                         &fn_ty.sig, decl, id, body, Vanilla,\n                          @Nil, blank_inherited(ccx));;\n \n             vtable::resolve_in_block(fcx, body);\n@@ -282,6 +287,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 purity: ast::purity,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n+                id: ast::node_id,\n                 body: &ast::blk,\n                 fn_kind: FnKind,\n                 inherited_isr: isr_alist,\n@@ -342,7 +348,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         @mut FnCtxt {\n             ret_ty: ret_ty,\n             indirect_ret_ty: indirect_ret_ty,\n-            purity: purity,\n+            ps: PurityState { purity: purity, from: id },\n             region_lb: body.node.id,\n             in_scope_regions: isr,\n             fn_kind: fn_kind,\n@@ -867,8 +873,12 @@ pub impl FnCtxt {\n     }\n \n     fn require_unsafe(&self, sp: span, op: ~str) {\n-        match self.purity {\n-          ast::unsafe_fn => {/*ok*/}\n+        match self.ps.purity {\n+          ast::unsafe_fn => {\n+            // ok, but flag that we used the source of unsafeness\n+            debug!(\"flagging %? as a used unsafe source\", self.ps.from);\n+            self.tcx().used_unsafe.insert(self.ps.from);\n+          }\n           _ => {\n             self.ccx.tcx.sess.span_err(\n                 sp,\n@@ -1679,12 +1689,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         fcx.write_ty(expr.id, fty);\n \n-        let inherited_purity =\n-            ty::determine_inherited_purity(copy fcx.purity, purity,\n+        let (inherited_purity, id) =\n+            ty::determine_inherited_purity((fcx.ps.purity, fcx.ps.from),\n+                                           (purity, expr.id),\n                                            sigil);\n \n         check_fn(fcx.ccx, None, inherited_purity, &fty_sig,\n-                 decl, body, fn_kind, fcx.in_scope_regions, fcx.inh);\n+                 decl, id, body, fn_kind, fcx.in_scope_regions, fcx.inh);\n     }\n \n \n@@ -2923,8 +2934,11 @@ pub fn check_block_with_expected(fcx0: @mut FnCtxt,\n                                  blk: &ast::blk,\n                                  expected: Option<ty::t>) {\n     let fcx = match blk.node.rules {\n-      ast::unsafe_blk => @mut FnCtxt {purity: ast::unsafe_fn,.. copy *fcx0},\n-      ast::default_blk => fcx0\n+        ast::unsafe_blk => @mut FnCtxt {\n+            ps: PurityState { purity: ast::unsafe_fn, from: blk.node.id },\n+            .. copy *fcx0\n+        },\n+        ast::default_blk => fcx0\n     };\n     do fcx.with_region_lb(blk.node.id) {\n         let mut warned = false;"}, {"sha": "a59c76c809b13152d4b809b59060053762a70d9b", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -57,11 +57,9 @@ struct DtorRes {\n #[unsafe_destructor]\n impl Drop for DtorRes {\n     fn finalize(&self) {\n-        unsafe {\n-            match self.dtor {\n-                option::None => (),\n-                option::Some(f) => f()\n-            }\n+        match self.dtor {\n+            option::None => (),\n+            option::Some(f) => f()\n         }\n     }\n }\n@@ -84,7 +82,7 @@ fn DtorRes(dtor: Option<@fn()>) -> DtorRes {\n  * * base - A foreign pointer to a buffer\n  * * len - The number of elements in the buffer\n  */\n-pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n+pub fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n     return CVec{\n         base: base,\n         len: len,\n@@ -103,7 +101,7 @@ pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n  * * dtor - A function to run when the value is destructed, useful\n  *          for freeing the buffer, etc.\n  */\n-pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n+pub fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: @fn())\n   -> CVec<T> {\n     return CVec{\n         base: base,\n@@ -144,7 +142,7 @@ pub fn set<T:Copy>(t: CVec<T>, ofs: uint, v: T) {\n pub fn len<T>(t: CVec<T>) -> uint { t.len }\n \n /// Returns a pointer to the first element of the vector\n-pub unsafe fn ptr<T>(t: CVec<T>) -> *mut T { t.base }\n+pub fn ptr<T>(t: CVec<T>) -> *mut T { t.base }\n \n #[cfg(test)]\n mod tests {"}, {"sha": "b1e80718d8f74c050777b26874a482d7874f47e7", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 108, "deletions": 110, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -223,128 +223,126 @@ pub type Result = result::Result<Matches, Fail_>;\n  * Use <fail_str> to get an error message.\n  */\n pub fn getopts(args: &[~str], opts: &[Opt]) -> Result {\n-    unsafe {\n-        let n_opts = opts.len();\n-        fn f(_x: uint) -> ~[Optval] { return ~[]; }\n-        let mut vals = vec::from_fn(n_opts, f);\n-        let mut free: ~[~str] = ~[];\n-        let l = args.len();\n-        let mut i = 0;\n-        while i < l {\n-            let cur = args[i];\n-            let curlen = cur.len();\n-            if !is_arg(cur) {\n-                free.push(cur);\n-            } else if cur == ~\"--\" {\n-                let mut j = i + 1;\n-                while j < l { free.push(args[j]); j += 1; }\n-                break;\n-            } else {\n-                let mut names;\n-                let mut i_arg = None;\n-                if cur[1] == '-' as u8 {\n-                    let tail = str::slice(cur, 2, curlen).to_owned();\n-                    let mut tail_eq = ~[];\n-                    for str::each_splitn_char(tail, '=', 1) |s| { tail_eq.push(s.to_owned()) }\n-                    if tail_eq.len() <= 1 {\n-                        names = ~[Long(tail)];\n-                    } else {\n-                        names =\n-                            ~[Long(tail_eq[0])];\n-                        i_arg = Some(tail_eq[1]);\n-                    }\n+    let n_opts = opts.len();\n+    fn f(_x: uint) -> ~[Optval] { return ~[]; }\n+    let mut vals = vec::from_fn(n_opts, f);\n+    let mut free: ~[~str] = ~[];\n+    let l = args.len();\n+    let mut i = 0;\n+    while i < l {\n+        let cur = args[i];\n+        let curlen = cur.len();\n+        if !is_arg(cur) {\n+            free.push(cur);\n+        } else if cur == ~\"--\" {\n+            let mut j = i + 1;\n+            while j < l { free.push(args[j]); j += 1; }\n+            break;\n+        } else {\n+            let mut names;\n+            let mut i_arg = None;\n+            if cur[1] == '-' as u8 {\n+                let tail = str::slice(cur, 2, curlen).to_owned();\n+                let mut tail_eq = ~[];\n+                for str::each_splitn_char(tail, '=', 1) |s| { tail_eq.push(s.to_owned()) }\n+                if tail_eq.len() <= 1 {\n+                    names = ~[Long(tail)];\n                 } else {\n-                    let mut j = 1;\n-                    let mut last_valid_opt_id = None;\n-                    names = ~[];\n-                    while j < curlen {\n-                        let range = str::char_range_at(cur, j);\n-                        let opt = Short(range.ch);\n-\n-                        /* In a series of potential options (eg. -aheJ), if we\n-                           see one which takes an argument, we assume all\n-                           subsequent characters make up the argument. This\n-                           allows options such as -L/usr/local/lib/foo to be\n-                           interpreted correctly\n-                        */\n-\n-                        match find_opt(opts, opt) {\n-                          Some(id) => last_valid_opt_id = Some(id),\n-                          None => {\n-                            let arg_follows =\n-                                last_valid_opt_id.is_some() &&\n-                                match opts[last_valid_opt_id.get()]\n-                                  .hasarg {\n-\n-                                  Yes | Maybe => true,\n-                                  No => false\n-                                };\n-                            if arg_follows && j < curlen {\n-                                i_arg = Some(cur.slice(j, curlen).to_owned());\n-                                break;\n-                            } else {\n-                                last_valid_opt_id = None;\n-                            }\n-                          }\n-                        }\n-                        names.push(opt);\n-                        j = range.next;\n-                    }\n+                    names =\n+                        ~[Long(tail_eq[0])];\n+                    i_arg = Some(tail_eq[1]);\n                 }\n-                let mut name_pos = 0;\n-                for names.each() |nm| {\n-                    name_pos += 1;\n-                    let optid = match find_opt(opts, *nm) {\n-                      Some(id) => id,\n-                      None => return Err(UnrecognizedOption(name_str(nm)))\n-                    };\n-                    match opts[optid].hasarg {\n-                      No => {\n-                        if !i_arg.is_none() {\n-                            return Err(UnexpectedArgument(name_str(nm)));\n+            } else {\n+                let mut j = 1;\n+                let mut last_valid_opt_id = None;\n+                names = ~[];\n+                while j < curlen {\n+                    let range = str::char_range_at(cur, j);\n+                    let opt = Short(range.ch);\n+\n+                    /* In a series of potential options (eg. -aheJ), if we\n+                       see one which takes an argument, we assume all\n+                       subsequent characters make up the argument. This\n+                       allows options such as -L/usr/local/lib/foo to be\n+                       interpreted correctly\n+                    */\n+\n+                    match find_opt(opts, opt) {\n+                      Some(id) => last_valid_opt_id = Some(id),\n+                      None => {\n+                        let arg_follows =\n+                            last_valid_opt_id.is_some() &&\n+                            match opts[last_valid_opt_id.get()]\n+                              .hasarg {\n+\n+                              Yes | Maybe => true,\n+                              No => false\n+                            };\n+                        if arg_follows && j < curlen {\n+                            i_arg = Some(cur.slice(j, curlen).to_owned());\n+                            break;\n+                        } else {\n+                            last_valid_opt_id = None;\n                         }\n-                        vals[optid].push(Given);\n-                      }\n-                      Maybe => {\n-                        if !i_arg.is_none() {\n-                            vals[optid].push(Val(i_arg.get()));\n-                        } else if name_pos < names.len() ||\n-                                      i + 1 == l || is_arg(args[i + 1]) {\n-                            vals[optid].push(Given);\n-                        } else { i += 1; vals[optid].push(Val(args[i])); }\n-                      }\n-                      Yes => {\n-                        if !i_arg.is_none() {\n-                            vals[optid].push(Val(i_arg.get()));\n-                        } else if i + 1 == l {\n-                            return Err(ArgumentMissing(name_str(nm)));\n-                        } else { i += 1; vals[optid].push(Val(args[i])); }\n                       }\n                     }\n+                    names.push(opt);\n+                    j = range.next;\n                 }\n             }\n-            i += 1;\n-        }\n-        i = 0u;\n-        while i < n_opts {\n-            let n = vals[i].len();\n-            let occ = opts[i].occur;\n-            if occ == Req {\n-                if n == 0 {\n-                    return Err(OptionMissing(name_str(&(opts[i].name))));\n+            let mut name_pos = 0;\n+            for names.each() |nm| {\n+                name_pos += 1;\n+                let optid = match find_opt(opts, *nm) {\n+                  Some(id) => id,\n+                  None => return Err(UnrecognizedOption(name_str(nm)))\n+                };\n+                match opts[optid].hasarg {\n+                  No => {\n+                    if !i_arg.is_none() {\n+                        return Err(UnexpectedArgument(name_str(nm)));\n+                    }\n+                    vals[optid].push(Given);\n+                  }\n+                  Maybe => {\n+                    if !i_arg.is_none() {\n+                        vals[optid].push(Val(i_arg.get()));\n+                    } else if name_pos < names.len() ||\n+                                  i + 1 == l || is_arg(args[i + 1]) {\n+                        vals[optid].push(Given);\n+                    } else { i += 1; vals[optid].push(Val(args[i])); }\n+                  }\n+                  Yes => {\n+                    if !i_arg.is_none() {\n+                        vals[optid].push(Val(i_arg.get()));\n+                    } else if i + 1 == l {\n+                        return Err(ArgumentMissing(name_str(nm)));\n+                    } else { i += 1; vals[optid].push(Val(args[i])); }\n+                  }\n                 }\n             }\n-            if occ != Multi {\n-                if n > 1 {\n-                    return Err(OptionDuplicated(name_str(&(opts[i].name))));\n-                }\n+        }\n+        i += 1;\n+    }\n+    i = 0u;\n+    while i < n_opts {\n+        let n = vals[i].len();\n+        let occ = opts[i].occur;\n+        if occ == Req {\n+            if n == 0 {\n+                return Err(OptionMissing(name_str(&(opts[i].name))));\n+            }\n+        }\n+        if occ != Multi {\n+            if n > 1 {\n+                return Err(OptionDuplicated(name_str(&(opts[i].name))));\n             }\n-            i += 1;\n         }\n-        return Ok(Matches {opts: vec::from_slice(opts),\n-                   vals: vals,\n-                   free: free});\n+        i += 1;\n     }\n+    return Ok(Matches {opts: vec::from_slice(opts),\n+               vals: vals,\n+               free: free});\n }\n \n fn opt_vals(mm: &Matches, nm: &str) -> ~[Optval] {"}, {"sha": "e920ff20ac5dcd9773545569247967f6c85e68a3", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -116,35 +116,33 @@ pub fn get_addr(node: &str, iotask: &iotask)\n     let mut output_ch = Some(SharedChan(output_ch));\n     do str::as_buf(node) |node_ptr, len| {\n         let output_ch = output_ch.swap_unwrap();\n-        unsafe {\n-            debug!(\"slice len %?\", len);\n-            let handle = create_uv_getaddrinfo_t();\n-            let handle_ptr = ptr::addr_of(&handle);\n-            let handle_data = GetAddrData {\n-                output_ch: output_ch.clone()\n-            };\n-            let handle_data_ptr = ptr::addr_of(&handle_data);\n-            do interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    let result = uv_getaddrinfo(\n-                        loop_ptr,\n-                        handle_ptr,\n-                        get_addr_cb,\n-                        node_ptr,\n-                        ptr::null(),\n-                        ptr::null());\n-                    match result {\n-                        0i32 => {\n-                            set_data_for_req(handle_ptr, handle_data_ptr);\n-                        }\n-                        _ => {\n-                            output_ch.send(result::Err(GetAddrUnknownError));\n-                        }\n+        debug!(\"slice len %?\", len);\n+        let handle = create_uv_getaddrinfo_t();\n+        let handle_ptr = ptr::addr_of(&handle);\n+        let handle_data = GetAddrData {\n+            output_ch: output_ch.clone()\n+        };\n+        let handle_data_ptr = ptr::addr_of(&handle_data);\n+        do interact(iotask) |loop_ptr| {\n+            unsafe {\n+                let result = uv_getaddrinfo(\n+                    loop_ptr,\n+                    handle_ptr,\n+                    get_addr_cb,\n+                    node_ptr,\n+                    ptr::null(),\n+                    ptr::null());\n+                match result {\n+                    0i32 => {\n+                        set_data_for_req(handle_ptr, handle_data_ptr);\n+                    }\n+                    _ => {\n+                        output_ch.send(result::Err(GetAddrUnknownError));\n                     }\n                 }\n-            };\n-            output_po.recv()\n-        }\n+            }\n+        };\n+        output_po.recv()\n     }\n }\n "}, {"sha": "a8b2723bcfbc415154d4e4a5a49db2f2d25e26a8", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 147, "deletions": 160, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -57,9 +57,7 @@ pub struct TcpSocket {\n #[unsafe_destructor]\n impl Drop for TcpSocket {\n     fn finalize(&self) {\n-        unsafe {\n-            tear_down_socket_data(self.socket_data)\n-        }\n+        tear_down_socket_data(self.socket_data)\n     }\n }\n \n@@ -302,11 +300,10 @@ pub fn connect(input_ip: ip::IpAddr, port: uint,\n  * `TcpErrData` value as the `Err` variant\n  */\n pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n-    -> result::Result<(), TcpErrData> {\n-    unsafe {\n-        let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n-        write_common_impl(socket_data_ptr, raw_write_data)\n-    }\n+    -> result::Result<(), TcpErrData>\n+{\n+    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+    write_common_impl(socket_data_ptr, raw_write_data)\n }\n \n /**\n@@ -341,13 +338,12 @@ pub fn write(sock: &TcpSocket, raw_write_data: ~[u8])\n  * value as the `Err` variant\n  */\n pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n-    -> future::Future<result::Result<(), TcpErrData>> {\n-    unsafe {\n-        let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n-        do future_spawn {\n-            let data_copy = copy(raw_write_data);\n-            write_common_impl(socket_data_ptr, data_copy)\n-        }\n+    -> future::Future<result::Result<(), TcpErrData>>\n+{\n+    let socket_data_ptr = ptr::addr_of(&(*(sock.socket_data)));\n+    do future_spawn {\n+        let data_copy = copy(raw_write_data);\n+        write_common_impl(socket_data_ptr, data_copy)\n     }\n }\n \n@@ -369,10 +365,8 @@ pub fn write_future(sock: &TcpSocket, raw_write_data: ~[u8])\n pub fn read_start(sock: &TcpSocket)\n     -> result::Result<@Port<\n         result::Result<~[u8], TcpErrData>>, TcpErrData> {\n-    unsafe {\n-        let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n-        read_start_common_impl(socket_data)\n-    }\n+    let socket_data = ptr::addr_of(&(*(sock.socket_data)));\n+    read_start_common_impl(socket_data)\n }\n \n /**\n@@ -382,12 +376,9 @@ pub fn read_start(sock: &TcpSocket)\n  *\n  * * `sock` - a `net::tcp::TcpSocket` that you wish to stop reading on\n  */\n-pub fn read_stop(sock: &TcpSocket) ->\n-    result::Result<(), TcpErrData> {\n-    unsafe {\n-        let socket_data = ptr::addr_of(&(*sock.socket_data));\n-        read_stop_common_impl(socket_data)\n-    }\n+pub fn read_stop(sock: &TcpSocket) -> result::Result<(), TcpErrData> {\n+    let socket_data = ptr::addr_of(&(*sock.socket_data));\n+    read_stop_common_impl(socket_data)\n }\n \n /**\n@@ -654,150 +645,148 @@ fn listen_common(host_ip: ip::IpAddr,\n                  on_establish_cb: ~fn(SharedChan<Option<TcpErrData>>),\n                  on_connect_cb: ~fn(*uv::ll::uv_tcp_t))\n               -> result::Result<(), TcpListenErrData> {\n-    unsafe {\n-        let (stream_closed_po, stream_closed_ch) = stream::<()>();\n-        let stream_closed_ch = SharedChan(stream_closed_ch);\n-        let (kill_po, kill_ch) = stream::<Option<TcpErrData>>();\n-        let kill_ch = SharedChan(kill_ch);\n-        let server_stream = uv::ll::tcp_t();\n-        let server_stream_ptr = ptr::addr_of(&server_stream);\n-        let server_data: TcpListenFcData = TcpListenFcData {\n-            server_stream_ptr: server_stream_ptr,\n-            stream_closed_ch: stream_closed_ch,\n-            kill_ch: kill_ch.clone(),\n-            on_connect_cb: on_connect_cb,\n-            iotask: iotask.clone(),\n-            ipv6: match &host_ip {\n-                &ip::Ipv4(_) => { false }\n-                &ip::Ipv6(_) => { true }\n-            },\n-            mut active: true\n-        };\n-        let server_data_ptr = ptr::addr_of(&server_data);\n-\n-        let (setup_po, setup_ch) = stream();\n-\n-        // this is to address a compiler warning about\n-        // an implicit copy.. it seems that double nested\n-        // will defeat a move sigil, as is done to the host_ip\n-        // arg above.. this same pattern works w/o complaint in\n-        // tcp::connect (because the iotask::interact cb isn't\n-        // nested within a core::comm::listen block)\n-        let loc_ip = copy(host_ip);\n-        do iotask::interact(iotask) |loop_ptr| {\n-            unsafe {\n-                match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n-                    0i32 => {\n-                        uv::ll::set_data_for_uv_handle(\n-                            server_stream_ptr,\n-                            server_data_ptr);\n-                        let addr_str = ip::format_addr(&loc_ip);\n-                        let bind_result = match loc_ip {\n-                            ip::Ipv4(ref addr) => {\n-                                debug!(\"addr: %?\", addr);\n-                                let in_addr = uv::ll::ip4_addr(\n-                                    addr_str,\n-                                    port as int);\n-                                uv::ll::tcp_bind(server_stream_ptr,\n-                                                 ptr::addr_of(&in_addr))\n-                            }\n-                            ip::Ipv6(ref addr) => {\n-                                debug!(\"addr: %?\", addr);\n-                                let in_addr = uv::ll::ip6_addr(\n-                                    addr_str,\n-                                    port as int);\n-                                uv::ll::tcp_bind6(server_stream_ptr,\n-                                                  ptr::addr_of(&in_addr))\n-                            }\n-                        };\n-                        match bind_result {\n-                            0i32 => {\n-                                match uv::ll::listen(\n-                                    server_stream_ptr,\n-                                    backlog as libc::c_int,\n-                                    tcp_lfc_on_connection_cb) {\n-                                    0i32 => setup_ch.send(None),\n-                                    _ => {\n-                                        debug!(\n-                                            \"failure to uv_tcp_init\");\n-                                        let err_data =\n-                                            uv::ll::get_last_err_data(\n-                                                loop_ptr);\n-                                        setup_ch.send(Some(err_data));\n-                                    }\n+    let (stream_closed_po, stream_closed_ch) = stream::<()>();\n+    let stream_closed_ch = SharedChan(stream_closed_ch);\n+    let (kill_po, kill_ch) = stream::<Option<TcpErrData>>();\n+    let kill_ch = SharedChan(kill_ch);\n+    let server_stream = uv::ll::tcp_t();\n+    let server_stream_ptr = ptr::addr_of(&server_stream);\n+    let server_data: TcpListenFcData = TcpListenFcData {\n+        server_stream_ptr: server_stream_ptr,\n+        stream_closed_ch: stream_closed_ch,\n+        kill_ch: kill_ch.clone(),\n+        on_connect_cb: on_connect_cb,\n+        iotask: iotask.clone(),\n+        ipv6: match &host_ip {\n+            &ip::Ipv4(_) => { false }\n+            &ip::Ipv6(_) => { true }\n+        },\n+        mut active: true\n+    };\n+    let server_data_ptr = ptr::addr_of(&server_data);\n+\n+    let (setup_po, setup_ch) = stream();\n+\n+    // this is to address a compiler warning about\n+    // an implicit copy.. it seems that double nested\n+    // will defeat a move sigil, as is done to the host_ip\n+    // arg above.. this same pattern works w/o complaint in\n+    // tcp::connect (because the iotask::interact cb isn't\n+    // nested within a core::comm::listen block)\n+    let loc_ip = copy(host_ip);\n+    do iotask::interact(iotask) |loop_ptr| {\n+        unsafe {\n+            match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n+                0i32 => {\n+                    uv::ll::set_data_for_uv_handle(\n+                        server_stream_ptr,\n+                        server_data_ptr);\n+                    let addr_str = ip::format_addr(&loc_ip);\n+                    let bind_result = match loc_ip {\n+                        ip::Ipv4(ref addr) => {\n+                            debug!(\"addr: %?\", addr);\n+                            let in_addr = uv::ll::ip4_addr(\n+                                addr_str,\n+                                port as int);\n+                            uv::ll::tcp_bind(server_stream_ptr,\n+                                             ptr::addr_of(&in_addr))\n+                        }\n+                        ip::Ipv6(ref addr) => {\n+                            debug!(\"addr: %?\", addr);\n+                            let in_addr = uv::ll::ip6_addr(\n+                                addr_str,\n+                                port as int);\n+                            uv::ll::tcp_bind6(server_stream_ptr,\n+                                              ptr::addr_of(&in_addr))\n+                        }\n+                    };\n+                    match bind_result {\n+                        0i32 => {\n+                            match uv::ll::listen(\n+                                server_stream_ptr,\n+                                backlog as libc::c_int,\n+                                tcp_lfc_on_connection_cb) {\n+                                0i32 => setup_ch.send(None),\n+                                _ => {\n+                                    debug!(\n+                                        \"failure to uv_tcp_init\");\n+                                    let err_data =\n+                                        uv::ll::get_last_err_data(\n+                                            loop_ptr);\n+                                    setup_ch.send(Some(err_data));\n                                 }\n                             }\n-                            _ => {\n-                                debug!(\"failure to uv_tcp_bind\");\n-                                let err_data = uv::ll::get_last_err_data(\n-                                    loop_ptr);\n-                                setup_ch.send(Some(err_data));\n-                            }\n                         }\n-                    }\n-                    _ => {\n-                        debug!(\"failure to uv_tcp_bind\");\n-                        let err_data = uv::ll::get_last_err_data(\n-                            loop_ptr);\n-                        setup_ch.send(Some(err_data));\n+                        _ => {\n+                            debug!(\"failure to uv_tcp_bind\");\n+                            let err_data = uv::ll::get_last_err_data(\n+                                loop_ptr);\n+                            setup_ch.send(Some(err_data));\n+                        }\n                     }\n                 }\n+                _ => {\n+                    debug!(\"failure to uv_tcp_bind\");\n+                    let err_data = uv::ll::get_last_err_data(\n+                        loop_ptr);\n+                    setup_ch.send(Some(err_data));\n+                }\n             }\n         }\n+    }\n \n-        let setup_result = setup_po.recv();\n+    let setup_result = setup_po.recv();\n \n-        match setup_result {\n-            Some(ref err_data) => {\n-                do iotask::interact(iotask) |loop_ptr| {\n-                    unsafe {\n-                        debug!(\n-                            \"tcp::listen post-kill recv hl interact %?\",\n-                                 loop_ptr);\n-                        (*server_data_ptr).active = false;\n-                        uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n-                    }\n-                };\n-                stream_closed_po.recv();\n-                match err_data.err_name {\n-                    ~\"EACCES\" => {\n-                        debug!(\"Got EACCES error\");\n-                        result::Err(AccessDenied)\n-                    }\n-                    ~\"EADDRINUSE\" => {\n-                        debug!(\"Got EADDRINUSE error\");\n-                        result::Err(AddressInUse)\n-                    }\n-                    _ => {\n-                        debug!(\"Got '%s' '%s' libuv error\",\n-                                        err_data.err_name, err_data.err_msg);\n-                        result::Err(\n-                            GenericListenErr(err_data.err_name,\n-                                             err_data.err_msg))\n-                    }\n+    match setup_result {\n+        Some(ref err_data) => {\n+            do iotask::interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    debug!(\n+                        \"tcp::listen post-kill recv hl interact %?\",\n+                             loop_ptr);\n+                    (*server_data_ptr).active = false;\n+                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n+                }\n+            };\n+            stream_closed_po.recv();\n+            match err_data.err_name {\n+                ~\"EACCES\" => {\n+                    debug!(\"Got EACCES error\");\n+                    result::Err(AccessDenied)\n+                }\n+                ~\"EADDRINUSE\" => {\n+                    debug!(\"Got EADDRINUSE error\");\n+                    result::Err(AddressInUse)\n+                }\n+                _ => {\n+                    debug!(\"Got '%s' '%s' libuv error\",\n+                                    err_data.err_name, err_data.err_msg);\n+                    result::Err(\n+                        GenericListenErr(err_data.err_name,\n+                                         err_data.err_msg))\n                 }\n             }\n-            None => {\n-                on_establish_cb(kill_ch.clone());\n-                let kill_result = kill_po.recv();\n-                do iotask::interact(iotask) |loop_ptr| {\n-                    unsafe {\n-                        debug!(\n-                            \"tcp::listen post-kill recv hl interact %?\",\n-                                 loop_ptr);\n-                        (*server_data_ptr).active = false;\n-                        uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n-                    }\n-                };\n-                stream_closed_po.recv();\n-                match kill_result {\n-                    // some failure post bind/listen\n-                    Some(ref err_data) => result::Err(GenericListenErr(\n-                        err_data.err_name,\n-                        err_data.err_msg)),\n-                    // clean exit\n-                    None => result::Ok(())\n+        }\n+        None => {\n+            on_establish_cb(kill_ch.clone());\n+            let kill_result = kill_po.recv();\n+            do iotask::interact(iotask) |loop_ptr| {\n+                unsafe {\n+                    debug!(\n+                        \"tcp::listen post-kill recv hl interact %?\",\n+                             loop_ptr);\n+                    (*server_data_ptr).active = false;\n+                    uv::ll::close(server_stream_ptr, tcp_lfc_close_cb);\n                 }\n+            };\n+            stream_closed_po.recv();\n+            match kill_result {\n+                // some failure post bind/listen\n+                Some(ref err_data) => result::Err(GenericListenErr(\n+                    err_data.err_name,\n+                    err_data.err_msg)),\n+                // clean exit\n+                None => result::Ok(())\n             }\n         }\n     }\n@@ -1382,9 +1371,7 @@ extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) {\n }\n \n extern fn tcp_connect_close_cb(handle: *uv::ll::uv_tcp_t) {\n-    unsafe {\n-        debug!(\"closed client tcp handle %?\", handle);\n-    }\n+    debug!(\"closed client tcp handle %?\", handle);\n }\n \n extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,"}, {"sha": "9b8b0f9be0bcd19d77609b03ae8e3344549ebbee", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -118,8 +118,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n  * This function is compliant with RFC 3986.\n  */\n pub fn encode(s: &str) -> ~str {\n-    // FIXME(#3722): unsafe only because encode_inner does (string) IO\n-    unsafe {encode_inner(s, true)}\n+    encode_inner(s, true)\n }\n \n /**\n@@ -130,8 +129,7 @@ pub fn encode(s: &str) -> ~str {\n  */\n \n pub fn encode_component(s: &str) -> ~str {\n-    // FIXME(#3722): unsafe only because encode_inner does (string) IO\n-    unsafe {encode_inner(s, false)}\n+    encode_inner(s, false)\n }\n \n fn decode_inner(s: &str, full_url: bool) -> ~str {\n@@ -178,16 +176,14 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n  * This will only decode escape sequences generated by encode.\n  */\n pub fn decode(s: &str) -> ~str {\n-    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-    unsafe {decode_inner(s, true)}\n+    decode_inner(s, true)\n }\n \n /**\n  * Decode a string encoded with percent encoding.\n  */\n pub fn decode_component(s: &str) -> ~str {\n-    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-    unsafe {decode_inner(s, false)}\n+    decode_inner(s, false)\n }\n \n fn encode_plus(s: &str) -> ~str {\n@@ -301,18 +297,15 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     let len = str::len(s);\n     let mut index = len;\n     let mut mat = 0;\n-    // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-    unsafe {\n-        do io::with_str_reader(s) |rdr| {\n-            let mut ch;\n-            while !rdr.eof() {\n-                ch = rdr.read_byte() as char;\n-                if ch == c {\n-                    // found a match, adjust markers\n-                    index = rdr.tell()-1;\n-                    mat = 1;\n-                    break;\n-                }\n+    do io::with_str_reader(s) |rdr| {\n+        let mut ch;\n+        while !rdr.eof() {\n+            ch = rdr.read_byte() as char;\n+            if ch == c {\n+                // found a match, adjust markers\n+                index = rdr.tell()-1;\n+                mat = 1;\n+                break;\n             }\n         }\n     }\n@@ -346,29 +339,25 @@ fn query_from_str(rawquery: &str) -> Query {\n     if str::len(rawquery) != 0 {\n         for str::each_split_char(rawquery, '&') |p| {\n             let (k, v) = split_char_first(p, '=');\n-            // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-            unsafe {query.push((decode_component(k), decode_component(v)));}\n+            query.push((decode_component(k), decode_component(v)));\n         };\n     }\n     return query;\n }\n \n pub fn query_to_str(query: &Query) -> ~str {\n-    unsafe {\n-        // FIXME(#3722): unsafe only because decode_inner does (string) IO\n-        let mut strvec = ~[];\n-        for query.each |kv| {\n-            match kv {\n-                &(ref k, ref v) => {\n-                    strvec.push(fmt!(\"%s=%s\",\n-                        encode_component(*k),\n-                        encode_component(*v))\n-                    );\n-                }\n+    let mut strvec = ~[];\n+    for query.each |kv| {\n+        match kv {\n+            &(ref k, ref v) => {\n+                strvec.push(fmt!(\"%s=%s\",\n+                    encode_component(*k),\n+                    encode_component(*v))\n+                );\n             }\n         }\n-        return str::connect(strvec, ~\"&\");\n     }\n+    return str::connect(strvec, ~\"&\");\n }\n \n // returns the scheme and the rest of the url, or a parsing error"}, {"sha": "9f9f2323d271b344b334a832706994ec73b9edcf", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -59,12 +59,10 @@ pub unsafe fn load_history(file: ~str) -> bool {\n /// Print out a prompt and then wait for input and return it\n pub unsafe fn read(prompt: ~str) -> Option<~str> {\n     do str::as_c_str(prompt) |buf| {\n-        unsafe {\n-            let line = rustrt::linenoise(buf);\n+        let line = rustrt::linenoise(buf);\n \n-            if line.is_null() { None }\n-            else { Some(str::raw::from_c_str(line)) }\n-        }\n+        if line.is_null() { None }\n+        else { Some(str::raw::from_c_str(line)) }\n     }\n }\n \n@@ -74,22 +72,20 @@ fn complete_key(_v: @CompletionCb) {}\n \n /// Bind to the main completion callback\n pub unsafe fn complete(cb: CompletionCb) {\n-    unsafe {\n-        task::local_data::local_data_set(complete_key, @(cb));\n-\n-        extern fn callback(line: *c_char, completions: *()) {\n-            unsafe {\n-                let cb = *task::local_data::local_data_get(complete_key)\n-                    .get();\n-\n-                do cb(str::raw::from_c_str(line)) |suggestion| {\n-                    do str::as_c_str(suggestion) |buf| {\n-                        rustrt::linenoiseAddCompletion(completions, buf);\n-                    }\n+    task::local_data::local_data_set(complete_key, @(cb));\n+\n+    extern fn callback(line: *c_char, completions: *()) {\n+        unsafe {\n+            let cb = *task::local_data::local_data_get(complete_key)\n+                .get();\n+\n+            do cb(str::raw::from_c_str(line)) |suggestion| {\n+                do str::as_c_str(suggestion) |buf| {\n+                    rustrt::linenoiseAddCompletion(completions, buf);\n                 }\n             }\n         }\n-\n-        rustrt::linenoiseSetCompletionCallback(callback);\n     }\n+\n+    rustrt::linenoiseSetCompletionCallback(callback);\n }"}, {"sha": "653283f2e78b925a52b2fd83570072d177519e3c", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -862,17 +862,15 @@ pub mod node {\n      * This function executes in linear time.\n      */\n     pub fn flatten(node: @Node) -> @Node {\n-        unsafe {\n-            match (*node) {\n-                Leaf(_) => node,\n-                Concat(ref x) => {\n-                    @Leaf(Leaf {\n-                        byte_offset: 0u,\n-                        byte_len: x.byte_len,\n-                        char_len: x.char_len,\n-                        content: @serialize_node(node),\n-                    })\n-                }\n+        match (*node) {\n+            Leaf(_) => node,\n+            Concat(ref x) => {\n+                @Leaf(Leaf {\n+                    byte_offset: 0u,\n+                    byte_len: x.byte_len,\n+                    char_len: x.char_len,\n+                    content: @serialize_node(node),\n+                })\n             }\n         }\n     }"}, {"sha": "f2de8213a1b9e18c6691e9f7510cbf47b035ec7a", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 28, "deletions": 38, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -101,17 +101,15 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n pub impl<Q:Owned> Sem<Q> {\n     fn acquire(&self) {\n         let mut waiter_nobe = None;\n-        unsafe {\n-            do (**self).with |state| {\n-                state.count -= 1;\n-                if state.count < 0 {\n-                    // Create waiter nobe.\n-                    let (WaitEnd, SignalEnd) = comm::oneshot();\n-                    // Tell outer scope we need to block.\n-                    waiter_nobe = Some(WaitEnd);\n-                    // Enqueue ourself.\n-                    state.waiters.tail.send(SignalEnd);\n-                }\n+        do (**self).with |state| {\n+            state.count -= 1;\n+            if state.count < 0 {\n+                // Create waiter nobe.\n+                let (WaitEnd, SignalEnd) = comm::oneshot();\n+                // Tell outer scope we need to block.\n+                waiter_nobe = Some(WaitEnd);\n+                // Enqueue ourself.\n+                state.waiters.tail.send(SignalEnd);\n             }\n         }\n         // Uncomment if you wish to test for sem races. Not valgrind-friendly.\n@@ -122,12 +120,10 @@ pub impl<Q:Owned> Sem<Q> {\n         }\n     }\n     fn release(&self) {\n-        unsafe {\n-            do (**self).with |state| {\n-                state.count += 1;\n-                if state.count <= 0 {\n-                    signal_waitqueue(&state.waiters);\n-                }\n+        do (**self).with |state| {\n+            state.count += 1;\n+            if state.count <= 0 {\n+                signal_waitqueue(&state.waiters);\n             }\n         }\n     }\n@@ -169,9 +165,7 @@ struct SemReleaseGeneric<'self, Q> { sem: &'self Sem<Q> }\n #[unsafe_destructor]\n impl<'self, Q:Owned> Drop for SemReleaseGeneric<'self, Q> {\n     fn finalize(&self) {\n-        unsafe {\n-            self.sem.release();\n-        }\n+        self.sem.release();\n     }\n }\n \n@@ -291,13 +285,11 @@ pub impl<'self> Condvar<'self> {\n     fn signal_on(&self, condvar_id: uint) -> bool {\n         let mut out_of_bounds = None;\n         let mut result = false;\n-        unsafe {\n-            do (**self.sem).with |state| {\n-                if condvar_id < vec::len(state.blocked) {\n-                    result = signal_waitqueue(&state.blocked[condvar_id]);\n-                } else {\n-                    out_of_bounds = Some(vec::len(state.blocked));\n-                }\n+        do (**self.sem).with |state| {\n+            if condvar_id < vec::len(state.blocked) {\n+                result = signal_waitqueue(&state.blocked[condvar_id]);\n+            } else {\n+                out_of_bounds = Some(vec::len(state.blocked));\n             }\n         }\n         do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {\n@@ -312,17 +304,15 @@ pub impl<'self> Condvar<'self> {\n     fn broadcast_on(&self, condvar_id: uint) -> uint {\n         let mut out_of_bounds = None;\n         let mut queue = None;\n-        unsafe {\n-            do (**self.sem).with |state| {\n-                if condvar_id < vec::len(state.blocked) {\n-                    // To avoid :broadcast_heavy, we make a new waitqueue,\n-                    // swap it out with the old one, and broadcast on the\n-                    // old one outside of the little-lock.\n-                    queue = Some(util::replace(&mut state.blocked[condvar_id],\n-                                               new_waitqueue()));\n-                } else {\n-                    out_of_bounds = Some(vec::len(state.blocked));\n-                }\n+        do (**self.sem).with |state| {\n+            if condvar_id < vec::len(state.blocked) {\n+                // To avoid :broadcast_heavy, we make a new waitqueue,\n+                // swap it out with the old one, and broadcast on the\n+                // old one outside of the little-lock.\n+                queue = Some(util::replace(&mut state.blocked[condvar_id],\n+                                           new_waitqueue()));\n+            } else {\n+                out_of_bounds = Some(vec::len(state.blocked));\n             }\n         }\n         do check_cvar_bounds(out_of_bounds, condvar_id, \"cond.signal_on()\") {"}, {"sha": "99e772b0c95a3ab332c8e22b266e3f58bfdf65ed", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -42,47 +42,45 @@ pub fn delayed_send<T:Owned>(iotask: &IoTask,\n                               msecs: uint,\n                               ch: &Chan<T>,\n                               val: T) {\n+    let (timer_done_po, timer_done_ch) = stream::<()>();\n+    let timer_done_ch = SharedChan(timer_done_ch);\n+    let timer = uv::ll::timer_t();\n+    let timer_ptr = ptr::addr_of(&timer);\n+    do iotask::interact(iotask) |loop_ptr| {\n         unsafe {\n-            let (timer_done_po, timer_done_ch) = stream::<()>();\n-            let timer_done_ch = SharedChan(timer_done_ch);\n-            let timer = uv::ll::timer_t();\n-            let timer_ptr = ptr::addr_of(&timer);\n-            do iotask::interact(iotask) |loop_ptr| {\n-                unsafe {\n-                    let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n-                    if (init_result == 0i32) {\n-                        let start_result = uv::ll::timer_start(\n-                            timer_ptr, delayed_send_cb, msecs, 0u);\n-                        if (start_result == 0i32) {\n-                            // Note: putting the channel into a ~\n-                            // to cast to *c_void\n-                            let timer_done_ch_clone = ~timer_done_ch.clone();\n-                            let timer_done_ch_ptr = transmute::<\n-                                ~SharedChan<()>, *c_void>(\n-                                timer_done_ch_clone);\n-                            uv::ll::set_data_for_uv_handle(\n-                                timer_ptr,\n-                                timer_done_ch_ptr);\n-                        } else {\n-                            let error_msg = uv::ll::get_last_err_info(\n-                                loop_ptr);\n-                            fail!(~\"timer::delayed_send() start failed: \" +\n-                                error_msg);\n-                        }\n-                    } else {\n-                        let error_msg = uv::ll::get_last_err_info(loop_ptr);\n-                        fail!(~\"timer::delayed_send() init failed: \" +\n-                            error_msg);\n-                    }\n+            let init_result = uv::ll::timer_init(loop_ptr, timer_ptr);\n+            if (init_result == 0i32) {\n+                let start_result = uv::ll::timer_start(\n+                    timer_ptr, delayed_send_cb, msecs, 0u);\n+                if (start_result == 0i32) {\n+                    // Note: putting the channel into a ~\n+                    // to cast to *c_void\n+                    let timer_done_ch_clone = ~timer_done_ch.clone();\n+                    let timer_done_ch_ptr = transmute::<\n+                        ~SharedChan<()>, *c_void>(\n+                        timer_done_ch_clone);\n+                    uv::ll::set_data_for_uv_handle(\n+                        timer_ptr,\n+                        timer_done_ch_ptr);\n+                } else {\n+                    let error_msg = uv::ll::get_last_err_info(\n+                        loop_ptr);\n+                    fail!(~\"timer::delayed_send() start failed: \" +\n+                        error_msg);\n                 }\n-            };\n-            // delayed_send_cb has been processed by libuv\n-            timer_done_po.recv();\n-            // notify the caller immediately\n-            ch.send(val);\n-            // uv_close for this timer has been processed\n-            timer_done_po.recv();\n+            } else {\n+                let error_msg = uv::ll::get_last_err_info(loop_ptr);\n+                fail!(~\"timer::delayed_send() init failed: \" +\n+                    error_msg);\n+            }\n+        }\n     };\n+    // delayed_send_cb has been processed by libuv\n+    timer_done_po.recv();\n+    // notify the caller immediately\n+    ch.send(val);\n+    // uv_close for this timer has been processed\n+    timer_done_po.recv();\n }\n \n /**"}, {"sha": "7a9d2438e6ada5180081ded3e3b7a6ed29aadd0c", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -75,7 +75,7 @@ pub fn spawn_iotask(task: task::TaskBuilder) -> IoTask {\n  * module. It is not safe to send the `loop_ptr` param to this callback out\n  * via ports/chans.\n  */\n-pub unsafe fn interact(iotask: &IoTask, cb: ~fn(*c_void)) {\n+pub fn interact(iotask: &IoTask, cb: ~fn(*c_void)) {\n     send_msg(iotask, Interaction(cb));\n }\n \n@@ -87,9 +87,7 @@ pub unsafe fn interact(iotask: &IoTask, cb: ~fn(*c_void)) {\n  * closed, causing a failure otherwise.\n  */\n pub fn exit(iotask: &IoTask) {\n-    unsafe {\n-        send_msg(iotask, TeardownLoop);\n-    }\n+    send_msg(iotask, TeardownLoop);\n }\n \n "}, {"sha": "3bf297027d4d635b4f32586e8fe18346cd9553b0", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -1111,22 +1111,22 @@ pub unsafe fn freeaddrinfo(res: *addrinfo) {\n }\n \n // libuv struct initializers\n-pub unsafe fn tcp_t() -> uv_tcp_t {\n+pub fn tcp_t() -> uv_tcp_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_tcp_t();\n }\n-pub unsafe fn connect_t() -> uv_connect_t {\n+pub fn connect_t() -> uv_connect_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_connect_t();\n }\n-pub unsafe fn write_t() -> uv_write_t {\n+pub fn write_t() -> uv_write_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_write_t();\n }\n-pub unsafe fn async_t() -> uv_async_t {\n+pub fn async_t() -> uv_async_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_async_t();\n }\n-pub unsafe fn timer_t() -> uv_timer_t {\n+pub fn timer_t() -> uv_timer_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_timer_t();\n }\n-pub unsafe fn getaddrinfo_t() -> uv_getaddrinfo_t {\n+pub fn getaddrinfo_t() -> uv_getaddrinfo_t {\n     return uv_ll_struct_stubgen::gen_stub_uv_getaddrinfo_t();\n }\n "}, {"sha": "a848f97d2e09e3cb928d0a00cb9fe4ffa9c236c6", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -274,13 +274,11 @@ impl ToStr for Abi {\n \n impl ToStr for AbiSet {\n     fn to_str(&self) -> ~str {\n-        unsafe { // so we can push to strs.\n-            let mut strs = ~[];\n-            for self.each |abi| {\n-                strs.push(abi.data().name);\n-            }\n-            fmt!(\"\\\"%s\\\"\", str::connect_slices(strs, \" \"))\n+        let mut strs = ~[];\n+        for self.each |abi| {\n+            strs.push(abi.data().name);\n         }\n+        fmt!(\"\\\"%s\\\"\", str::connect_slices(strs, \" \"))\n     }\n }\n "}, {"sha": "368a0fbe9bece41a947613307e696db4a6f983fc", "filename": "src/test/compile-fail/unused-unsafe.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Ftest%2Fcompile-fail%2Funused-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4beebc427c4688fa61492478a6ef70af1625fbc3/src%2Ftest%2Fcompile-fail%2Funused-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-unsafe.rs?ref=4beebc427c4688fa61492478a6ef70af1625fbc3", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Exercise the unused_unsafe attribute in some positive and negative cases\n+\n+#[deny(unused_unsafe)];\n+\n+use core::libc;\n+\n+fn callback<T>(_f: &fn() -> T) -> T { fail!() }\n+\n+fn bad1() { unsafe {} }                  //~ ERROR: unnecessary \"unsafe\" block\n+fn bad2() { unsafe { bad1() } }          //~ ERROR: unnecessary \"unsafe\" block\n+unsafe fn bad3() {}                      //~ ERROR: unnecessary \"unsafe\" function\n+unsafe fn bad4() { unsafe {} }           //~ ERROR: unnecessary \"unsafe\" function\n+                                         //~^ ERROR: unnecessary \"unsafe\" block\n+fn bad5() { unsafe { do callback {} } }  //~ ERROR: unnecessary \"unsafe\" block\n+\n+unsafe fn good0() { libc::exit(1) }\n+fn good1() { unsafe { libc::exit(1) } }\n+fn good2() {\n+    /* bug uncovered when implementing warning about unused unsafe blocks. Be\n+       sure that when purity is inherited that the source of the unsafe-ness\n+       is tracked correctly */\n+    unsafe {\n+        unsafe fn what() -> ~[~str] { libc::exit(2) }\n+\n+        do callback {\n+            what();\n+        }\n+    }\n+}\n+\n+#[allow(unused_unsafe)] unsafe fn allowed0() {}\n+#[allow(unused_unsafe)] fn allowed1() { unsafe {} }\n+\n+fn main() { }"}]}