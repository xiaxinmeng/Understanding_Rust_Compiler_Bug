{"sha": "d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3N2Y2ZDUzNjZiMzMwZjljMjA2MWNhZDBkM2ZmNjM4YzljYzA1Yjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-27T11:07:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-27T11:07:26Z"}, "message": "Auto merge of #21657 - pnkfelix:block-remainder-extents, r=nikomatsakis\n\n Add `CodeExtent::Remainder` variant; pre-req for new scoping/drop rules.\r\n\r\nThis new enum variant introduces finer-grain code extents, i.e. we now track that a binding lives only for a suffix of a block, and (importantly) will be dropped when it goes out of scope *before* the bindings that occurred earlier in the block.\r\n\r\nBoth of these notions are neatly captured by marking the block (and each suffix) as an enclosing scope of the next suffix beneath it.\r\n\r\nThis is work that is part of the foundation for issue #8861.\r\n\r\n(It actually has been seen in earlier posted pull requests, in particular #21022; I have just factored it out into its own PR to ease my own near-future rebasing, and also get people used to the new rules.)\r\n\r\n----\r\n\r\nThese finer grained scopes do mean that some code is newly rejected by `rustc`; for example:\r\n\r\n```rust\r\nlet mut map : HashMap<u8, &u8> = HashMap::new();\r\nlet tmp = Box::new(2);\r\nmap.insert(43, &*tmp);\r\n```\r\n\r\nThis will now fail to compile with a message that `*tmp` does not live long enough, because the scope of `tmp` is now strictly smaller than\r\nthat of `map`, and the use of `&u8` in map's type requires that the borrowed references are all to data that live at least as long as the map.\r\n\r\nThe usual fix for a case like this is to move the binding for `tmp` up above that of `map`; note that you can still leave the initialization in the original spot, like so:\r\n\r\n```rust\r\nlet tmp;\r\nlet mut map : HashMap<u8, &u8> = HashMap::new();\r\ntmp = box 2;\r\nmap.insert(43, &*tmp);\r\n```\r\n\r\nSimilarly, one can encounter an analogous situation with `Vec`: one would need to rewrite:\r\n\r\n```rust\r\nlet mut vec = Vec::new();\r\nlet tmp = 'c';\r\nvec.push(&tmp);\r\n```\r\n\r\nas:\r\n\r\n```rust\r\nlet tmp;\r\nlet mut vec = Vec::new();\r\ntmp = 'c';\r\nvec.push(&tmp);\r\n```\r\n\r\n----\r\n\r\nIn some corner cases, it does not suffice to reorder the bindings; in particular, when the types for both bindings need to reflect exactly the *same* code extent, and a parent/child relationship between them does not work.\r\n\r\nIn pnkfelix's experience this has arisen most often when mixing uses of cyclic data structures while also allowing a lifetime parameter `'a` to flow into a type parameter context where the type is *invariant* with respect to the type parameter. An important instance of this is `arena::TypedArena<T>`, which is invariant with respect to `T`.\r\n\r\n(The reason that variance is relevant is this: *if* `TypedArena` were covariant with respect to its type parameter, then we could assign it\r\nthe longer lifetime when it is initialized, and then convert it to a subtype (via covariance) with a shorter lifetime when necessary.  But `TypedArena` is invariant with respect to its type parameter, and thus if `S` is a subtype of `T` (in particular, if `S` has a lifetime parameter that is shorter than that of `T`), then a `TypedArena<S>` is unrelated to `TypedArena<T>`.)\r\n\r\nConcretely, consider code like this:\r\n\r\n```rust\r\nstruct Node<'a> { sibling: Option<&'a Node<'a>> }\r\nstruct Context<'a> {\r\n    // because of this field, `Context<'a>` is invariant with respect to `'a`.\r\n    arena: &'a TypedArena<Node<'a>>,\r\n    ...\r\n}\r\nfn new_ctxt<'a>(arena: &'a TypedArena<Node<'a>>) -> Context<'a> { ... }\r\nfn use_ctxt<'a>(fcx: &'a Context<'a>) { ... }\r\n\r\nlet arena = TypedArena::new();\r\nlet ctxt = new_ctxt(&arena);\r\n\r\nuse_ctxt(&ctxt);\r\n```\r\n\r\nIn these situations, if you try to introduce two bindings via two distinct `let` statements, each is (with this commit) assigned a distinct extent, and the region inference system cannot find a single region to assign to the lifetime `'a` that works for both of the bindings. So you get an error that `ctxt` does not live long enough; but moving its binding up above that of `arena` just shifts the error so now the compiler complains that `arena` does not live long enough.\r\n\r\n * SO: What to do? The easiest fix in this case is to ensure that the two bindings *do* get assigned the same static extent, by stuffing both\r\nbindings into the same let statement, like so:\r\n\r\n```rust\r\nlet (arena, ctxt): (TypedArena, Context);\r\narena = TypedArena::new();\r\nctxt = new_ctxt(&arena);\r\n\r\nuse_ctxt(&ctxt);\r\n```\r\n\r\n----\r\n\r\nDue to the new code restrictions outlined above, this is a ...\r\n\r\n[breaking-change]", "tree": {"sha": "39268502b4674d35b6e4e719cf94dec55bd64d53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39268502b4674d35b6e4e719cf94dec55bd64d53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "html_url": "https://github.com/rust-lang/rust/commit/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e365e4c05454d94131d14d0207c12bb895a4c186", "url": "https://api.github.com/repos/rust-lang/rust/commits/e365e4c05454d94131d14d0207c12bb895a4c186", "html_url": "https://github.com/rust-lang/rust/commit/e365e4c05454d94131d14d0207c12bb895a4c186"}, {"sha": "d6bf04a22e78afbe62e9d81e3578418f420123bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6bf04a22e78afbe62e9d81e3578418f420123bc", "html_url": "https://github.com/rust-lang/rust/commit/d6bf04a22e78afbe62e9d81e3578418f420123bc"}], "stats": {"total": 532, "additions": 404, "deletions": 128}, "files": [{"sha": "2ee4b6fbbd4ad676134f65d678c56a6ac8b38f32", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -377,6 +377,14 @@ fn parse_scope(st: &mut PState) -> region::CodeExtent {\n             let node_id = parse_uint(st) as ast::NodeId;\n             region::CodeExtent::Misc(node_id)\n         }\n+        'B' => {\n+            let node_id = parse_uint(st) as ast::NodeId;\n+            let first_stmt_index = parse_uint(st);\n+            let block_remainder = region::BlockRemainder {\n+                block: node_id, first_statement_index: first_stmt_index,\n+            };\n+            region::CodeExtent::Remainder(block_remainder)\n+        }\n         _ => panic!(\"parse_scope: bad input\")\n     }\n }"}, {"sha": "2dc334bfe95fceb039557116d9f3b79c03a30717", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -276,7 +276,9 @@ pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n \n fn enc_scope(w: &mut SeekableMemWriter, _cx: &ctxt, scope: region::CodeExtent) {\n     match scope {\n-        region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id)\n+        region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n+        region::CodeExtent::Remainder(region::BlockRemainder {\n+            block: b, first_statement_index: i }) => mywrite!(w, \"B{}{}\", b, i),\n     }\n }\n "}, {"sha": "cfef88a8deb4471ace63d15f69ed09b5144c343b", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -809,6 +809,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let scope_id = same_regions[0].scope_id;\n         let parent = self.tcx.map.get_parent(scope_id);\n         let parent_node = self.tcx.map.find(parent);\n+        let taken = lifetimes_in_scope(self.tcx, scope_id);\n+        let life_giver = LifeGiver::with_taken(&taken[]);\n         let node_inner = match parent_node {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n@@ -851,8 +853,6 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n         let (fn_decl, generics, unsafety, ident, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n-        let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(&taken[]);\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();"}, {"sha": "9bba01f8af771b904b9dfe500072b9bb363da4b9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 238, "deletions": 51, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -26,6 +26,7 @@ use syntax::codemap::{self, Span};\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};\n use syntax::ast_util::{stmt_id};\n+use syntax::ast_map;\n use syntax::visit::{Visitor, FnKind};\n \n /// CodeExtent represents a statically-describable extent that can be\n@@ -38,7 +39,32 @@ use syntax::visit::{Visitor, FnKind};\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n            RustcDecodable, Show, Copy)]\n pub enum CodeExtent {\n-    Misc(ast::NodeId)\n+    Misc(ast::NodeId),\n+    Remainder(BlockRemainder),\n+}\n+\n+/// Represents a subscope of `block` for a binding that is introduced\n+/// by `block.stmts[first_statement_index]`. Such subscopes represent\n+/// a suffix of the block. Note that each subscope does not include\n+/// the initializer expression, if any, for the statement indexed by\n+/// `first_statement_index`.\n+///\n+/// For example, given `{ let (a, b) = EXPR_1; let c = EXPR_2; ... }`:\n+///\n+/// * the subscope with `first_statement_index == 0` is scope of both\n+///   `a` and `b`; it does not include EXPR_1, but does include\n+///   everything after that first `let`. (If you want a scope that\n+///   includes EXPR_1 as well, then do not use `CodeExtent::Remainder`,\n+///   but instead another `CodeExtent` that encompasses the whole block,\n+///   e.g. `CodeExtent::Misc`.\n+///\n+/// * the subscope with `first_statement_index == 1` is scope of `c`,\n+///   and thus does not include EXPR_2, but covers the `...`.\n+#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n+         RustcDecodable, Show, Copy)]\n+pub struct BlockRemainder {\n+    pub block: ast::NodeId,\n+    pub first_statement_index: uint,\n }\n \n impl CodeExtent {\n@@ -55,6 +81,7 @@ impl CodeExtent {\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n             CodeExtent::Misc(node_id) => node_id,\n+            CodeExtent::Remainder(br) => br.block,\n         }\n     }\n \n@@ -65,16 +92,50 @@ impl CodeExtent {\n     {\n         match *self {\n             CodeExtent::Misc(node_id) => CodeExtent::Misc(f_id(node_id)),\n+            CodeExtent::Remainder(br) =>\n+                CodeExtent::Remainder(BlockRemainder {\n+                    block: f_id(br.block), first_statement_index: br.first_statement_index }),\n         }\n     }\n+\n+    /// Returns the span of this CodeExtent.  Note that in general the\n+    /// returned span may not correspond to the span of any node id in\n+    /// the AST.\n+    pub fn span(&self, ast_map: &ast_map::Map) -> Option<Span> {\n+        match ast_map.find(self.node_id()) {\n+            Some(ast_map::NodeBlock(ref blk)) => {\n+                match *self {\n+                    CodeExtent::Misc(_) => Some(blk.span),\n+\n+                    CodeExtent::Remainder(r) => {\n+                        assert_eq!(r.block, blk.id);\n+                        // Want span for extent starting after the\n+                        // indexed statement and ending at end of\n+                        // `blk`; reuse span of `blk` and shift `lo`\n+                        // forward to end of indexed statement.\n+                        //\n+                        // (This is the special case aluded to in the\n+                        // doc-comment for this method)\n+                        let stmt_span = blk.stmts[r.first_statement_index].span;\n+                        Some(Span { lo: stmt_span.hi, ..blk.span })\n+                    }\n+                }\n+            }\n+            Some(ast_map::NodeExpr(ref expr)) => Some(expr.span),\n+            Some(ast_map::NodeStmt(ref stmt)) => Some(stmt.span),\n+            Some(ast_map::NodeItem(ref item)) => Some(item.span),\n+            Some(_) | None => None,\n+         }\n+    }\n }\n \n /// The region maps encode information about region relationships.\n ///\n /// - `scope_map` maps from a scope id to the enclosing scope id; this is\n ///   usually corresponding to the lexical nesting, though in the case of\n ///   closures the parent scope is the innermost conditional expression or repeating\n-///   block\n+///   block. (Note that the enclosing scope id for the block\n+///   associated with a closure is the closure itself.)\n ///\n /// - `var_map` maps from a variable or binding id to the block in which\n ///   that variable is declared.\n@@ -115,12 +176,77 @@ pub struct RegionMaps {\n     terminating_scopes: RefCell<FnvHashSet<CodeExtent>>,\n }\n \n-#[derive(Copy)]\n+/// Carries the node id for the innermost block or match expression,\n+/// for building up the `var_map` which maps ids to the blocks in\n+/// which they were declared.\n+#[derive(PartialEq, Eq, Show, Copy)]\n+enum InnermostDeclaringBlock {\n+    None,\n+    Block(ast::NodeId),\n+    Statement(DeclaringStatementContext),\n+    Match(ast::NodeId),\n+}\n+\n+impl InnermostDeclaringBlock {\n+    fn to_code_extent(&self) -> Option<CodeExtent> {\n+        let extent = match *self {\n+            InnermostDeclaringBlock::None => {\n+                return Option::None;\n+            }\n+            InnermostDeclaringBlock::Block(id) |\n+            InnermostDeclaringBlock::Match(id) => CodeExtent::from_node_id(id),\n+            InnermostDeclaringBlock::Statement(s) =>  s.to_code_extent(),\n+        };\n+        Option::Some(extent)\n+    }\n+}\n+\n+/// Contextual information for declarations introduced by a statement\n+/// (i.e. `let`). It carries node-id's for statement and enclosing\n+/// block both, as well as the statement's index within the block.\n+#[derive(PartialEq, Eq, Show, Copy)]\n+struct DeclaringStatementContext {\n+    stmt_id: ast::NodeId,\n+    block_id: ast::NodeId,\n+    stmt_index: uint,\n+}\n+\n+impl DeclaringStatementContext {\n+    fn to_code_extent(&self) -> CodeExtent {\n+        CodeExtent::Remainder(BlockRemainder {\n+            block: self.block_id,\n+            first_statement_index: self.stmt_index,\n+        })\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Show, Copy)]\n+enum InnermostEnclosingExpr {\n+    None,\n+    Some(ast::NodeId),\n+    Statement(DeclaringStatementContext),\n+}\n+\n+impl InnermostEnclosingExpr {\n+    fn to_code_extent(&self) -> Option<CodeExtent> {\n+        let extent = match *self {\n+            InnermostEnclosingExpr::None => {\n+                return Option::None;\n+            }\n+            InnermostEnclosingExpr::Statement(s) =>\n+                s.to_code_extent(),\n+            InnermostEnclosingExpr::Some(parent_id) =>\n+                CodeExtent::from_node_id(parent_id),\n+        };\n+        Some(extent)\n+    }\n+}\n+\n+#[derive(Show, Copy)]\n pub struct Context {\n-    var_parent: Option<ast::NodeId>,\n+    var_parent: InnermostDeclaringBlock,\n \n-    // Innermost enclosing expression\n-    parent: Option<ast::NodeId>,\n+    parent: InnermostEnclosingExpr,\n }\n \n struct RegionResolutionVisitor<'a> {\n@@ -381,16 +507,13 @@ impl RegionMaps {\n     }\n }\n \n-/// Records the current parent (if any) as the parent of `child_id`.\n+/// Records the current parent (if any) as the parent of `child_scope`.\n fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n-                        child_id: ast::NodeId,\n+                        child_scope: CodeExtent,\n                         _sp: Span) {\n-    match visitor.cx.parent {\n-        Some(parent_id) => {\n-            let child_scope = CodeExtent::from_node_id(child_id);\n-            let parent_scope = CodeExtent::from_node_id(parent_id);\n-            visitor.region_maps.record_encl_scope(child_scope, parent_scope);\n-        }\n+    match visitor.cx.parent.to_code_extent() {\n+        Some(parent_scope) =>\n+            visitor.region_maps.record_encl_scope(child_scope, parent_scope),\n         None => {}\n     }\n }\n@@ -399,11 +522,9 @@ fn record_superlifetime(visitor: &mut RegionResolutionVisitor,\n fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n                        var_id: ast::NodeId,\n                        _sp: Span) {\n-    match visitor.cx.var_parent {\n-        Some(parent_id) => {\n-            let parent_scope = CodeExtent::from_node_id(parent_id);\n-            visitor.region_maps.record_var_scope(var_id, parent_scope);\n-        }\n+    match visitor.cx.var_parent.to_code_extent() {\n+        Some(parent_scope) =>\n+            visitor.region_maps.record_var_scope(var_id, parent_scope),\n         None => {\n             // this can happen in extern fn declarations like\n             //\n@@ -415,21 +536,72 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &ast::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n-    // Record the parent of this block.\n-    record_superlifetime(visitor, blk.id, blk.span);\n+    let prev_cx = visitor.cx;\n+\n+    let blk_scope = CodeExtent::Misc(blk.id);\n+    record_superlifetime(visitor, blk_scope, blk.span);\n \n     // We treat the tail expression in the block (if any) somewhat\n     // differently from the statements. The issue has to do with\n-    // temporary lifetimes. If the user writes:\n+    // temporary lifetimes. Consider the following:\n     //\n-    //   {\n-    //     ... (&foo()) ...\n-    //   }\n+    //    quux({\n+    //        let inner = ... (&bar()) ...;\n     //\n+    //        (... (&foo()) ...) // (the tail expression)\n+    //    }, other_argument());\n+    //\n+    // Each of the statements within the block is a terminating\n+    // scope, and thus a temporary (e.g. the result of calling\n+    // `bar()` in the initalizer expression for `let inner = ...;`)\n+    // will be cleaned up immediately after its corresponding\n+    // statement (i.e. `let inner = ...;`) executes.\n+    //\n+    // On the other hand, temporaries associated with evaluating the\n+    // tail expression for the block are assigned lifetimes so that\n+    // they will be cleaned up as part of the terminating scope\n+    // *surrounding* the block expression. Here, the terminating\n+    // scope for the block expression is the `quux(..)` call; so\n+    // those temporaries will only be cleaned up *after* both\n+    // `other_argument()` has run and also the call to `quux(..)`\n+    // itself has returned.\n+\n+    visitor.cx = Context {\n+        var_parent: InnermostDeclaringBlock::Block(blk.id),\n+        parent: InnermostEnclosingExpr::Some(blk.id),\n+    };\n+\n+    {\n+        // This block should be kept approximately in sync with\n+        // `visit::walk_block`. (We manually walk the block, rather\n+        // than call `walk_block`, in order to maintain precise\n+        // `InnermostDeclaringBlock` information.)\n+\n+        for (i, statement) in blk.stmts.iter().enumerate() {\n+            if let ast::StmtDecl(_, stmt_id) = statement.node {\n+                // Each StmtDecl introduces a subscope for bindings\n+                // introduced by the declaration; this subscope covers\n+                // a suffix of the block . Each subscope in a block\n+                // has the previous subscope in the block as a parent,\n+                // except for the first such subscope, which has the\n+                // block itself as a parent.\n+                let declaring = DeclaringStatementContext {\n+                    stmt_id: stmt_id,\n+                    block_id: blk.id,\n+                    stmt_index: i,\n+                };\n+                record_superlifetime(\n+                    visitor, declaring.to_code_extent(), statement.span);\n+                visitor.cx = Context {\n+                    var_parent: InnermostDeclaringBlock::Statement(declaring),\n+                    parent: InnermostEnclosingExpr::Statement(declaring),\n+                };\n+            }\n+            visitor.visit_stmt(&**statement)\n+        }\n+        visit::walk_expr_opt(visitor, &blk.expr)\n+    }\n \n-    let prev_cx = visitor.cx;\n-    visitor.cx = Context {var_parent: Some(blk.id), parent: Some(blk.id)};\n-    visit::walk_block(visitor, blk);\n     visitor.cx = prev_cx;\n }\n \n@@ -449,7 +621,7 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &ast::Arm) {\n }\n \n fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &ast::Pat) {\n-    record_superlifetime(visitor, pat.id, pat.span);\n+    record_superlifetime(visitor, CodeExtent::from_node_id(pat.id), pat.span);\n \n     // If this is a binding (or maybe a binding, I'm too lazy to check\n     // the def map) then record the lifetime of that binding.\n@@ -468,22 +640,29 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &ast::Stmt) {\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n     let stmt_scope = CodeExtent::from_node_id(stmt_id);\n+\n+    // Every statement will clean up the temporaries created during\n+    // execution of that statement. Therefore each statement has an\n+    // associated destruction scope that represents the extent of the\n+    // statement plus its destructors, and thus the extent for which\n+    // regions referenced by the destructors need to survive.\n     visitor.region_maps.mark_as_terminating_scope(stmt_scope);\n-    record_superlifetime(visitor, stmt_id, stmt.span);\n+    record_superlifetime(visitor, stmt_scope, stmt.span);\n \n     let prev_parent = visitor.cx.parent;\n-    visitor.cx.parent = Some(stmt_id);\n+    visitor.cx.parent = InnermostEnclosingExpr::Some(stmt_id);\n     visit::walk_stmt(visitor, stmt);\n     visitor.cx.parent = prev_parent;\n }\n \n fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n-    record_superlifetime(visitor, expr.id, expr.span);\n+    let expr_scope = CodeExtent::Misc(expr.id);\n+    record_superlifetime(visitor, expr_scope, expr.span);\n \n     let prev_cx = visitor.cx;\n-    visitor.cx.parent = Some(expr.id);\n+    visitor.cx.parent = InnermostEnclosingExpr::Some(expr.id);\n \n     {\n         let region_maps = &mut visitor.region_maps;\n@@ -527,11 +706,11 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n \n                 // The variable parent of everything inside (most importantly, the\n                 // pattern) is the body.\n-                visitor.cx.var_parent = Some(body.id);\n+                visitor.cx.var_parent = InnermostDeclaringBlock::Block(body.id);\n             }\n \n             ast::ExprMatch(..) => {\n-                visitor.cx.var_parent = Some(expr.id);\n+                visitor.cx.var_parent = InnermostDeclaringBlock::Match(expr.id);\n             }\n \n             ast::ExprAssignOp(..) | ast::ExprIndex(..) |\n@@ -568,19 +747,13 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n \n-    let blk_id = match visitor.cx.var_parent {\n-        Some(id) => id,\n-        None => {\n-            visitor.sess.span_bug(\n-                local.span,\n-                \"local without enclosing block\");\n-        }\n-    };\n-\n     // For convenience in trans, associate with the local-id the var\n     // scope that will be used for any bindings declared in this\n     // pattern.\n-    let blk_scope = CodeExtent::from_node_id(blk_id);\n+    let blk_scope = visitor.cx.var_parent.to_code_extent()\n+        .unwrap_or_else(|| visitor.sess.span_bug(\n+            local.span, \"local without enclosing block\"));\n+\n     visitor.region_maps.record_var_scope(local.id, blk_scope);\n \n     // As an exception to the normal rules governing temporary\n@@ -803,7 +976,10 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &ast::Item) {\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n-    visitor.cx = Context {var_parent: None, parent: None};\n+    visitor.cx = Context {\n+        var_parent: InnermostDeclaringBlock::None,\n+        parent: InnermostEnclosingExpr::None\n+    };\n     visit::walk_item(visitor, item);\n     visitor.cx = prev_cx;\n }\n@@ -829,15 +1005,20 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     let outer_cx = visitor.cx;\n \n     // The arguments and `self` are parented to the body of the fn.\n-    visitor.cx = Context { parent: Some(body.id),\n-                           var_parent: Some(body.id) };\n+    visitor.cx = Context {\n+        parent: InnermostEnclosingExpr::Some(body.id),\n+        var_parent: InnermostDeclaringBlock::Block(body.id)\n+    };\n     visit::walk_fn_decl(visitor, decl);\n \n     // The body of the fn itself is either a root scope (top-level fn)\n     // or it continues with the inherited scope (closures).\n     match fk {\n         visit::FkItemFn(..) | visit::FkMethod(..) => {\n-            visitor.cx = Context { parent: None, var_parent: None };\n+            visitor.cx = Context {\n+                parent: InnermostEnclosingExpr::None,\n+                var_parent: InnermostDeclaringBlock::None\n+            };\n             visitor.visit_block(body);\n             visitor.cx = outer_cx;\n         }\n@@ -898,7 +1079,10 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n-            cx: Context { parent: None, var_parent: None }\n+            cx: Context {\n+                parent: InnermostEnclosingExpr::None,\n+                var_parent: InnermostDeclaringBlock::None,\n+            }\n         };\n         visit::walk_crate(&mut visitor, krate);\n     }\n@@ -911,7 +1095,10 @@ pub fn resolve_inlined_item(sess: &Session,\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n         region_maps: region_maps,\n-        cx: Context { parent: None, var_parent: None }\n+        cx: Context {\n+            parent: InnermostEnclosingExpr::None,\n+            var_parent: InnermostDeclaringBlock::None\n+        }\n     };\n     visit::walk_inlined_item(&mut visitor, item);\n }"}, {"sha": "5601898136c79d629773ed2c93d649322a3cd252", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -10,6 +10,7 @@\n \n \n use middle::def;\n+use middle::region;\n use middle::subst::{VecPerParamSpace,Subst};\n use middle::subst;\n use middle::ty::{BoundRegion, BrAnon, BrNamed};\n@@ -84,37 +85,41 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n                             -> (String, Option<Span>) {\n     return match region {\n       ReScope(scope) => {\n-        match cx.map.find(scope.node_id()) {\n-          Some(ast_map::NodeBlock(ref blk)) => {\n-            explain_span(cx, \"block\", blk.span)\n-          }\n-          Some(ast_map::NodeExpr(expr)) => {\n-            match expr.node {\n-              ast::ExprCall(..) => explain_span(cx, \"call\", expr.span),\n-              ast::ExprMethodCall(..) => {\n-                explain_span(cx, \"method call\", expr.span)\n-              },\n-              ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) =>\n-                  explain_span(cx, \"if let\", expr.span),\n-              ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) => {\n-                  explain_span(cx, \"while let\", expr.span)\n-              },\n-              ast::ExprMatch(..) => explain_span(cx, \"match\", expr.span),\n-              _ => explain_span(cx, \"expression\", expr.span)\n-            }\n-          }\n-          Some(ast_map::NodeStmt(stmt)) => {\n-              explain_span(cx, \"statement\", stmt.span)\n-          }\n-          Some(ast_map::NodeItem(it)) => {\n-              let tag = item_scope_tag(&*it);\n-              explain_span(cx, tag, it.span)\n-          }\n+        let new_string;\n+        let on_unknown_scope = |&:| {\n+          (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n+        };\n+        let span = match scope.span(&cx.map) {\n+          Some(s) => s,\n+          None => return on_unknown_scope(),\n+        };\n+        let tag = match cx.map.find(scope.node_id()) {\n+          Some(ast_map::NodeBlock(_)) => \"block\",\n+          Some(ast_map::NodeExpr(expr)) => match expr.node {\n+              ast::ExprCall(..) => \"call\",\n+              ast::ExprMethodCall(..) => \"method call\",\n+              ast::ExprMatch(_, _, ast::MatchSource::IfLetDesugar { .. }) => \"if let\",\n+              ast::ExprMatch(_, _, ast::MatchSource::WhileLetDesugar) =>  \"while let\",\n+              ast::ExprMatch(..) => \"match\",\n+              _ => \"expression\",\n+          },\n+          Some(ast_map::NodeStmt(_)) => \"statement\",\n+          Some(ast_map::NodeItem(it)) => item_scope_tag(&*it),\n           Some(_) | None => {\n             // this really should not happen\n-            (format!(\"unknown scope: {:?}.  Please report a bug.\", scope), None)\n+            return on_unknown_scope();\n           }\n-        }\n+        };\n+        let scope_decorated_tag = match scope {\n+            region::CodeExtent::Misc(_) => tag,\n+            region::CodeExtent::Remainder(r) => {\n+                new_string = format!(\"block suffix following statement {}\",\n+                                     r.first_statement_index);\n+                new_string.as_slice()\n+            }\n+        };\n+        explain_span(cx, scope_decorated_tag, span)\n+\n       }\n \n       ReFree(ref fr) => {\n@@ -867,6 +872,17 @@ impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n     }\n }\n \n+impl<'tcx> Repr<'tcx> for region::CodeExtent {\n+    fn repr(&self, _tcx: &ctxt) -> String {\n+        match *self {\n+            region::CodeExtent::Misc(node_id) =>\n+                format!(\"Misc({})\", node_id),\n+            region::CodeExtent::Remainder(rem) =>\n+                format!(\"Remainder({}, {})\", rem.block, rem.first_statement_index),\n+        }\n+    }\n+}\n+\n impl<'tcx> Repr<'tcx> for ast::DefId {\n     fn repr(&self, tcx: &ctxt) -> String {\n         // Unfortunately, there seems to be no way to attempt to print"}, {"sha": "25b90041505a76e768604a5aeb80018081c78f93", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -100,6 +100,7 @@ pub fn compile_input(sess: Session,\n                                                                  &id[]));\n \n         let mut forest = ast_map::Forest::new(expanded_crate);\n+        let arenas = ty::CtxtArenas::new();\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n         write_out_deps(&sess, input, &outputs, &id[]);\n@@ -111,7 +112,6 @@ pub fn compile_input(sess: Session,\n                                                                      &ast_map,\n                                                                      &id[]));\n \n-        let arenas = ty::CtxtArenas::new();\n         let analysis = phase_3_run_analysis_passes(sess,\n                                                    ast_map,\n                                                    &arenas,"}, {"sha": "67b15ce8a871eee115fb6b398ab387af52f308d5", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -115,6 +115,7 @@ fn test_env<F>(source_string: &str,\n                     .expect(\"phase 2 aborted\");\n \n     let mut forest = ast_map::Forest::new(krate);\n+    let arenas = ty::CtxtArenas::new();\n     let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n     let krate = ast_map.krate();\n \n@@ -125,7 +126,6 @@ fn test_env<F>(source_string: &str,\n     let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(krate);\n-    let arenas = ty::CtxtArenas::new();\n     let tcx = ty::mk_ctxt(sess,\n                           &arenas,\n                           def_map,"}, {"sha": "5a98bc4da3682384b3cd28089555918cc6f2461c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -1784,15 +1784,16 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"trans_closure(..., param_substs={})\",\n            param_substs.repr(ccx.tcx()));\n \n-    let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx,\n-                          llfndecl,\n-                          fn_ast_id,\n-                          closure_env.kind != closure::NotClosure,\n-                          output_type,\n-                          param_substs,\n-                          Some(body.span),\n-                          &arena);\n+    let (arena, fcx): (TypedArena<_>, FunctionContext);\n+    arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx,\n+                      llfndecl,\n+                      fn_ast_id,\n+                      closure_env.kind != closure::NotClosure,\n+                      output_type,\n+                      param_substs,\n+                      Some(body.span),\n+                      &arena);\n     let mut bcx = init_function(&fcx, false, output_type);\n \n     // cleanup scope for the incoming arguments\n@@ -2046,9 +2047,10 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n                     ty_to_string(ccx.tcx(), ctor_ty))[])\n     };\n \n-    let arena = TypedArena::new();\n-    let fcx = new_fn_ctxt(ccx, llfndecl, ctor_id, false, result_ty,\n-                          param_substs, None, &arena);\n+    let (arena, fcx): (TypedArena<_>, FunctionContext);\n+    arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx, llfndecl, ctor_id, false, result_ty,\n+                      param_substs, None, &arena);\n     let bcx = init_function(&fcx, false, result_ty);\n \n     assert!(!fcx.needs_ret_allocas);"}, {"sha": "d038407791ef6a8e7c4a613776fb4de480afaf6f", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -322,16 +322,17 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                               &function_name[]);\n \n     //\n-    let block_arena = TypedArena::new();\n     let empty_substs = Substs::trans_empty();\n-    let fcx = new_fn_ctxt(ccx,\n-                          llfn,\n-                          ast::DUMMY_NODE_ID,\n-                          false,\n-                          sig.output,\n-                          &empty_substs,\n-                          None,\n-                          &block_arena);\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx,\n+                      llfn,\n+                      ast::DUMMY_NODE_ID,\n+                      false,\n+                      sig.output,\n+                      &empty_substs,\n+                      None,\n+                      &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be ptr to the the fn pointer"}, {"sha": "69d1922ab9adb3e271a2f51a4cd1eef04e5f19fb", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -540,11 +540,12 @@ fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n     let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n     let _s = StatRecorder::new(ccx, glue_name);\n \n-    let arena = TypedArena::new();\n     let empty_param_substs = Substs::trans_empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n-                          ty::FnConverging(ty::mk_nil(ccx.tcx())),\n-                          &empty_param_substs, None, &arena);\n+    let (arena, fcx): (TypedArena<_>, FunctionContext);\n+    arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n+                      ty::FnConverging(ty::mk_nil(ccx.tcx())),\n+                      &empty_param_substs, None, &arena);\n \n     let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n "}, {"sha": "187b73b1b0952fc0b49172506d94239a609e5458", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -601,17 +601,17 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n \n-    //\n-    let block_arena = TypedArena::new();\n     let empty_substs = Substs::trans_empty();\n-    let fcx = new_fn_ctxt(ccx,\n-                          llfn,\n-                          ast::DUMMY_NODE_ID,\n-                          false,\n-                          sig.output,\n-                          &empty_substs,\n-                          None,\n-                          &block_arena);\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx,\n+                      llfn,\n+                      ast::DUMMY_NODE_ID,\n+                      false,\n+                      sig.output,\n+                      &empty_substs,\n+                      None,\n+                      &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be a trait object"}, {"sha": "4c5a8144cbd064ead01dd46c4dcd90d774084cc2", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -1049,8 +1049,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // if there are any.\n         assert_eq!(substs.types.len(subst::FnSpace), 0);\n         assert_eq!(substs.regions().len(subst::FnSpace), 0);\n-        let mut substs = substs;\n         let placeholder;\n+        let mut substs = substs;\n         if\n             !method.generics.types.is_empty_in(subst::FnSpace) ||\n             !method.generics.regions.is_empty_in(subst::FnSpace)"}, {"sha": "65560040f47c28e923d83017f4288ab48531f433", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -3101,8 +3101,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let name = ident.get();\n         // only find fits with at least one matching letter\n         let mut best_dist = name.len();\n-        let mut best = None;\n         let fields = ty::lookup_struct_fields(tcx, id);\n+        let mut best = None;\n         for elem in fields.iter() {\n             let n = elem.name.as_str();\n             // ignore already set fields"}, {"sha": "90a0a0f843e94a314d53d48a043d57e8f75a3ff9", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -126,9 +126,9 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n                     .expect(\"phase_2_configure_and_expand aborted in rustdoc!\");\n \n     let mut forest = ast_map::Forest::new(krate);\n+    let arenas = ty::CtxtArenas::new();\n     let ast_map = driver::assign_node_ids_and_map(&sess, &mut forest);\n \n-    let arenas = ty::CtxtArenas::new();\n     let ty::CrateAnalysis {\n         exported_items, public_items, ty_cx, ..\n     } = driver::phase_3_run_analysis_passes(sess,"}, {"sha": "280d2a8add5ea0ca457e314cc7d1a106725fb2d7", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -1079,13 +1079,13 @@ mod tests {\n     #[test]\n     fn test_override_env() {\n         use os;\n-        let mut new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n \n         // In some build environments (such as chrooted Nix builds), `env` can\n         // only be found in the explicitly-provided PATH env variable, not in\n         // default places such as /bin or /usr/bin. So we need to pass through\n         // PATH to our sub-process.\n         let path_val: String;\n+        let mut new_env = vec![(\"RUN_TEST_NEW_ENV\", \"123\")];\n         match os::getenv(\"PATH\") {\n             None => {}\n             Some(val) => {"}, {"sha": "9c10f01e027557c7e9885d43574a62044cc5f27a", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -16,10 +16,11 @@ extern crate collections;\n use std::collections::HashMap;\n \n fn main() {\n+    let tmp;\n     let mut buggy_map: HashMap<usize, &usize> = HashMap::new();\n     buggy_map.insert(42, &*box 1); //~ ERROR borrowed value does not live long enough\n \n     // but it is ok if we use a temporary\n-    let tmp = box 2;\n+    tmp = box 2;\n     buggy_map.insert(43, &*tmp);\n }"}, {"sha": "f551a2aa81155702af8fd7b698ad81ad21affb25", "filename": "src/test/compile-fail/borrowck-let-suggestion-suffixes.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion-suffixes.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn f() {\n+    let old = ['o'];         // statement 0\n+    let mut v1 = Vec::new(); // statement 1\n+\n+    let mut v2 = Vec::new(); // statement 2\n+    //~^ NOTE reference must be valid for the block suffix following statement 2\n+\n+    let young = ['y'];       // statement 3\n+    //~^ NOTE ...but borrowed value is only valid for the block suffix following statement 3\n+\n+    v2.push(&young[0]);      // statement 4\n+    //~^ ERROR `young[..]` does not live long enough\n+\n+    let mut v3 = Vec::new(); // statement 5\n+    //~^ NOTE reference must be valid for the block suffix following statement 5\n+\n+    v3.push(&'x');           // statement 6\n+    //~^ ERROR borrowed value does not live long enough\n+    //~| NOTE ...but borrowed value is only valid for the statement\n+    //~| HELP consider using a `let` binding to increase its lifetime\n+\n+    {\n+\n+        let mut v4 = Vec::new(); // (sub) statement 0\n+        //~^ NOTE reference must be valid for the block suffix following statement 0\n+\n+        v4.push(&'y');\n+        //~^ ERROR borrowed value does not live long enough\n+        //~| NOTE ...but borrowed value is only valid for the statement\n+        //~| HELP consider using a `let` binding to increase its lifetime\n+\n+    }                       // (statement 7)\n+\n+    let mut v5 = Vec::new(); // statement 8\n+    //~^ NOTE reference must be valid for the block suffix following statement 8\n+\n+    v5.push(&'z');\n+    //~^ ERROR borrowed value does not live long enough\n+    //~| NOTE ...but borrowed value is only valid for the statement\n+    //~| HELP consider using a `let` binding to increase its lifetime\n+\n+    v1.push(&old[0]);\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "a08021919df8540d473f149e8c422c0820e38ef0", "filename": "src/test/compile-fail/borrowck-let-suggestion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-let-suggestion.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -10,7 +10,7 @@\n \n fn f() {\n     let x = [1is].iter(); //~ ERROR borrowed value does not live long enough\n-                         //~^^ NOTE reference must be valid for the block\n+                         //~^ NOTE reference must be valid for the block suffix following statement\n                          //~^^ HELP consider using a `let` binding to increase its lifetime\n }\n "}, {"sha": "d26bf68cb5dfeb4a3fafe259ebb923ebd4e20cea", "filename": "src/test/compile-fail/issue-18783.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18783.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -13,16 +13,16 @@\n use std::cell::RefCell;\n \n fn main() {\n-    let c = RefCell::new(vec![]);\n     let mut y = 1us;\n+    let c = RefCell::new(vec![]);\n     c.push(box || y = 0);\n     c.push(box || y = 0);\n //~^ ERROR cannot borrow `y` as mutable more than once at a time\n }\n \n fn ufcs() {\n-    let c = RefCell::new(vec![]);\n     let mut y = 1us;\n+    let c = RefCell::new(vec![]);\n \n     Push::push(&c, box || y = 0);\n     Push::push(&c, box || y = 0);"}, {"sha": "25663f2605fcb4233cc47bc27743d738068f188b", "filename": "src/test/run-pass/issue-3026.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d77f6d5366b330f9c2061cad0d3ff638c9cc05b7/src%2Ftest%2Frun-pass%2Fissue-3026.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3026.rs?ref=d77f6d5366b330f9c2061cad0d3ff638c9cc05b7", "patch": "@@ -17,7 +17,8 @@ extern crate collections;\n use std::collections::HashMap;\n \n pub fn main() {\n+    let x;\n     let mut buggy_map: HashMap<uint, &uint> = HashMap::new();\n-    let x = box 1;\n+    x = box 1;\n     buggy_map.insert(42, &*x);\n }"}]}