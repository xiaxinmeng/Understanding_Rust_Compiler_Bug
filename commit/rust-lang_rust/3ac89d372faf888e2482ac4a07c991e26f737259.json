{"sha": "3ac89d372faf888e2482ac4a07c991e26f737259", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYzg5ZDM3MmZhZjg4OGUyNDgyYWM0YTA3Yzk5MWUyNmY3MzcyNTk=", "commit": {"author": {"name": "Ms2ger", "email": "ms2ger@gmail.com", "date": "2015-03-09T23:17:01Z"}, "committer": {"name": "Ms2ger", "email": "ms2ger@gmail.com", "date": "2015-03-11T20:37:01Z"}, "message": "Rewrite the dynamic dispatch section to focus on usage rather than implementation.", "tree": {"sha": "4555b789bf84abec29fcc4c90b94355f54b58722", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4555b789bf84abec29fcc4c90b94355f54b58722"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ac89d372faf888e2482ac4a07c991e26f737259", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ac89d372faf888e2482ac4a07c991e26f737259", "html_url": "https://github.com/rust-lang/rust/commit/3ac89d372faf888e2482ac4a07c991e26f737259", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ac89d372faf888e2482ac4a07c991e26f737259/comments", "author": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "638832e64cc62ec46721161ca19731ba00d4da58", "url": "https://api.github.com/repos/rust-lang/rust/commits/638832e64cc62ec46721161ca19731ba00d4da58", "html_url": "https://github.com/rust-lang/rust/commit/638832e64cc62ec46721161ca19731ba00d4da58"}], "stats": {"total": 117, "additions": 68, "deletions": 49}, "files": [{"sha": "504ed63934c6ae0b91b3fdbdfb8d995ce1b3dff2", "filename": "src/doc/trpl/static-and-dynamic-dispatch.md", "status": "modified", "additions": 68, "deletions": 49, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/3ac89d372faf888e2482ac4a07c991e26f737259/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/3ac89d372faf888e2482ac4a07c991e26f737259/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstatic-and-dynamic-dispatch.md?ref=3ac89d372faf888e2482ac4a07c991e26f737259", "patch": "@@ -102,49 +102,88 @@ reason.\n Rust provides dynamic dispatch through a feature called 'trait objects.' Trait\n objects, like `&Foo` or `Box<Foo>`, are normal values that store a value of\n *any* type that implements the given trait, where the precise type can only be\n-known at runtime. The methods of the trait can be called on a trait object via\n-a special record of function pointers (created and managed by the compiler).\n+known at runtime.\n \n-A function that takes a trait object is not specialized to each of the types\n-that implements `Foo`: only one copy is generated, often (but not always)\n-resulting in less code bloat. However, this comes at the cost of requiring\n-slower virtual function calls, and effectively inhibiting any chance of\n-inlining and related optimisations from occurring.\n+A trait object can be obtained from a pointer to a concrete type that\n+implements the trait by *casting* it (e.g. `&x as &Foo`) or *coercing* it\n+(e.g. using `&x` as an argument to a function that takes `&Foo`).\n \n-Trait objects are both simple and complicated: their core representation and\n-layout is quite straight-forward, but there are some curly error messages and\n-surprising behaviors to discover.\n+These trait object coercions and casts also work for pointers like `&mut T` to\n+`&mut Foo` and `Box<T>` to `Box<Foo>`, but that's all at the moment. Coercions\n+and casts are identical.\n \n-### Obtaining a trait object\n+This operation can be seen as \"erasing\" the compiler's knowledge about the\n+specific type of the pointer, and hence trait objects are sometimes referred to\n+as \"type erasure\".\n \n-There's two similar ways to get a trait object value: casts and coercions. If\n-`T` is a type that implements a trait `Foo` (e.g. `u8` for the `Foo` above),\n-then the two ways to get a `Foo` trait object out of a pointer to `T` look\n-like:\n+Coming back to the example above, we can use the same trait to perform dynamic\n+dispatch with trait objects by casting:\n \n-```{rust,ignore}\n-let ref_to_t: &T = ...;\n+```rust\n+# trait Foo { fn method(&self) -> String; }\n+# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n+# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n \n-// `as` keyword for casting\n-let cast = ref_to_t as &Foo;\n+fn do_something(x: &Foo) {\n+    x.method();\n+}\n \n-// using a `&T` in a place that has a known type of `&Foo` will implicitly coerce:\n-let coerce: &Foo = ref_to_t;\n+fn main() {\n+    let x = 5u8;\n+    do_something(&x as &Foo);\n+}\n+```\n \n-fn also_coerce(_unused: &Foo) {}\n-also_coerce(ref_to_t);\n+or by coercing:\n+\n+```rust\n+# trait Foo { fn method(&self) -> String; }\n+# impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n+# impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n+\n+fn do_something(x: &Foo) {\n+    x.method();\n+}\n+\n+fn main() {\n+    let x = \"Hello\".to_string();\n+    do_something(&x);\n+}\n ```\n \n-These trait object coercions and casts also work for pointers like `&mut T` to\n-`&mut Foo` and `Box<T>` to `Box<Foo>`, but that's all at the moment. Coercions\n-and casts are identical.\n+A function that takes a trait object is not specialized to each of the types\n+that implements `Foo`: only one copy is generated, often (but not always)\n+resulting in less code bloat. However, this comes at the cost of requiring\n+slower virtual function calls, and effectively inhibiting any chance of\n+inlining and related optimisations from occurring.\n \n-This operation can be seen as \"erasing\" the compiler's knowledge about the\n-specific type of the pointer, and hence trait objects are sometimes referred to\n-as \"type erasure\".\n+### Why pointers?\n+\n+Rust does not put things behind a pointer by default, unlike many managed\n+languages, so types can have different sizes. Knowing the size of the value at\n+compile time is important for things like passing it as an argument to a\n+function, moving it about on the stack and allocating (and deallocating) space\n+on the heap to store it.\n+\n+For `Foo`, we would need to have a value that could be at least either a\n+`String` (24 bytes) or a `u8` (1 byte), as well as any other type for which\n+dependent crates may implement `Foo` (any number of bytes at all). There's no\n+way to guarantee that this last point can work if the values are stored without\n+a pointer, because those other types can be arbitrarily large.\n+\n+Putting the value behind a pointer means the size of the value is not relevant\n+when we are tossing a trait object around, only the size of the pointer itself.\n \n ### Representation\n \n+The methods of the trait can be called on a trait object via a special record\n+of function pointers traditionally called a 'vtable' (created and managed by\n+the compiler).\n+\n+Trait objects are both simple and complicated: their core representation and\n+layout is quite straight-forward, but there are some curly error messages and\n+surprising behaviors to discover.\n+\n Let's start simple, with the runtime representation of a trait object. The\n `std::raw` module contains structs with layouts that are the same as the\n complicated built-in types, [including trait objects][stdraw]:\n@@ -265,23 +304,3 @@ let y = TraitObject {\n If `b` or `y` were owning trait objects (`Box<Foo>`), there would be a\n `(b.vtable.destructor)(b.data)` (respectively `y`) call when they went out of\n scope.\n-\n-### Why pointers?\n-\n-The use of language like \"fat pointer\" implies that a trait object is\n-always a pointer of some form, but why?\n-\n-Rust does not put things behind a pointer by default, unlike many managed\n-languages, so types can have different sizes. Knowing the size of the value at\n-compile time is important for things like passing it as an argument to a\n-function, moving it about on the stack and allocating (and deallocating) space\n-on the heap to store it.\n-\n-For `Foo`, we would need to have a value that could be at least either a\n-`String` (24 bytes) or a `u8` (1 byte), as well as any other type for which\n-dependent crates may implement `Foo` (any number of bytes at all). There's no\n-way to guarantee that this last point can work if the values are stored without\n-a pointer, because those other types can be arbitrarily large.\n-\n-Putting the value behind a pointer means the size of the value is not relevant\n-when we are tossing a trait object around, only the size of the pointer itself."}]}