{"sha": "6c70619b0126bc0e40bd9df39dcd6e711cac69c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNzA2MTliMDEyNmJjMGU0MGJkOWRmMzlkY2Q2ZTcxMWNhYzY5YzU=", "commit": {"author": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-07T15:24:09Z"}, "committer": {"name": "Florian Diebold", "email": "florian.diebold@freiheit.com", "date": "2020-02-07T17:28:10Z"}, "message": "Deal better with implicit type parameters and argument lists", "tree": {"sha": "c9812b922e3f7ec753ff18e0b17b0f54f18ea737", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9812b922e3f7ec753ff18e0b17b0f54f18ea737"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c70619b0126bc0e40bd9df39dcd6e711cac69c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c70619b0126bc0e40bd9df39dcd6e711cac69c5", "html_url": "https://github.com/rust-lang/rust/commit/6c70619b0126bc0e40bd9df39dcd6e711cac69c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c70619b0126bc0e40bd9df39dcd6e711cac69c5/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dded90a748737c3661aad043524f2248e324c867", "url": "https://api.github.com/repos/rust-lang/rust/commits/dded90a748737c3661aad043524f2248e324c867", "html_url": "https://github.com/rust-lang/rust/commit/dded90a748737c3661aad043524f2248e324c867"}], "stats": {"total": 164, "additions": 138, "deletions": 26}, "files": [{"sha": "00ae35953601bb60db785ad63e54b82475540c5f", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c70619b0126bc0e40bd9df39dcd6e711cac69c5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c70619b0126bc0e40bd9df39dcd6e711cac69c5/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=6c70619b0126bc0e40bd9df39dcd6e711cac69c5", "patch": "@@ -647,8 +647,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         generic_args: Option<&GenericArgs>,\n         receiver_ty: &Ty,\n     ) -> Substs {\n-        let (total_len, _parent_len, child_len) =\n-            def_generics.as_ref().map_or((0, 0, 0), |g| g.len_split());\n+        let (parent_params, self_params, type_params, impl_trait_params) =\n+            def_generics.as_ref().map_or((0, 0, 0, 0), |g| g.provenance_split());\n+        assert_eq!(self_params, 0); // method shouldn't have another Self param\n+        let total_len = parent_params + type_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n         // Parent arguments are unknown, except for the receiver type\n         if let Some(parent_generics) = def_generics.as_ref().map(|p| p.iter_parent()) {\n@@ -663,7 +665,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         // handle provided type arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n-            for arg in generic_args.args.iter().take(child_len) {\n+            for arg in generic_args.args.iter().take(type_params) {\n                 match arg {\n                     GenericArg::Type(type_ref) => {\n                         let ty = self.make_ty(type_ref);"}, {"sha": "d2df3fe2b54078edfb7e27e00ca9c55deaf92b44", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6c70619b0126bc0e40bd9df39dcd6e711cac69c5/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c70619b0126bc0e40bd9df39dcd6e711cac69c5/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=6c70619b0126bc0e40bd9df39dcd6e711cac69c5", "patch": "@@ -161,15 +161,19 @@ impl Ty {\n                     ImplTraitLoweringMode::Variable => {\n                         let idx = ctx.impl_trait_counter.get();\n                         ctx.impl_trait_counter.set(idx + 1);\n-                        let (self_params, list_params, _impl_trait_params) =\n+                        let (parent_params, self_params, list_params, _impl_trait_params) =\n                             if let Some(def) = ctx.resolver.generic_def() {\n                                 let generics = generics(ctx.db, def);\n                                 generics.provenance_split()\n                             } else {\n-                                (0, 0, 0)\n+                                (0, 0, 0, 0)\n                             };\n-                        // assert!((idx as usize) < impl_trait_params); // TODO return position impl trait\n-                        Ty::Bound(idx as u32 + self_params as u32 + list_params as u32)\n+                        Ty::Bound(\n+                            idx as u32\n+                                + parent_params as u32\n+                                + self_params as u32\n+                                + list_params as u32,\n+                        )\n                     }\n                     ImplTraitLoweringMode::Disallowed => {\n                         // FIXME: report error\n@@ -420,26 +424,23 @@ pub(super) fn substs_from_path_segment(\n     ctx: &TyLoweringContext<'_, impl HirDatabase>,\n     segment: PathSegment<'_>,\n     def_generic: Option<GenericDefId>,\n-    add_self_param: bool,\n+    _add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n     let def_generics = def_generic.map(|def| generics(ctx.db, def.into()));\n \n-    let (total_len, parent_len, child_len) = def_generics.map_or((0, 0, 0), |g| g.len_split());\n-    substs.extend(iter::repeat(Ty::Unknown).take(parent_len));\n-    if add_self_param {\n-        // FIXME this add_self_param argument is kind of a hack: Traits have the\n-        // Self type as an implicit first type parameter, but it can't be\n-        // actually provided in the type arguments\n-        // (well, actually sometimes it can, in the form of type-relative paths: `<Foo as Default>::default()`)\n-        // TODO handle this using type param provenance (if there's a self param, and not one provided, add unknown)\n-        substs.push(Ty::Unknown);\n-    }\n+    let (parent_params, self_params, type_params, impl_trait_params) =\n+        def_generics.map_or((0, 0, 0, 0), |g| g.provenance_split());\n+    substs.extend(iter::repeat(Ty::Unknown).take(parent_params));\n     if let Some(generic_args) = &segment.args_and_bindings {\n+        if !generic_args.has_self_type {\n+            substs.extend(iter::repeat(Ty::Unknown).take(self_params));\n+        }\n+        let expected_num =\n+            if generic_args.has_self_type { self_params + type_params } else { type_params };\n+        let skip = if generic_args.has_self_type && self_params == 0 { 1 } else { 0 };\n         // if args are provided, it should be all of them, but we can't rely on that\n-        let self_param_correction = if add_self_param { 1 } else { 0 };\n-        let child_len = child_len - self_param_correction;\n-        for arg in generic_args.args.iter().take(child_len) {\n+        for arg in generic_args.args.iter().skip(skip).take(expected_num) {\n             match arg {\n                 GenericArg::Type(type_ref) => {\n                     let ty = Ty::from_hir(ctx, type_ref);\n@@ -448,9 +449,9 @@ pub(super) fn substs_from_path_segment(\n             }\n         }\n     }\n+    let total_len = parent_params + self_params + type_params + impl_trait_params;\n     // add placeholders for args that were not provided\n-    let supplied_params = substs.len();\n-    for _ in supplied_params..total_len {\n+    for _ in substs.len()..total_len {\n         substs.push(Ty::Unknown);\n     }\n     assert_eq!(substs.len(), total_len);"}, {"sha": "f90dadc08fd249b75643deaaa10a16f33d6eea53", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/6c70619b0126bc0e40bd9df39dcd6e711cac69c5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c70619b0126bc0e40bd9df39dcd6e711cac69c5/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=6c70619b0126bc0e40bd9df39dcd6e711cac69c5", "patch": "@@ -905,6 +905,114 @@ fn test(x: impl Trait<u64>, y: &impl Trait<u32>) {\n     );\n }\n \n+#[test]\n+fn argument_impl_trait_type_args_1() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait {}\n+trait Foo {\n+    // this function has an implicit Self param, an explicit type param,\n+    // and an implicit impl Trait param!\n+    fn bar<T>(x: impl Trait) -> T { loop {} }\n+}\n+fn foo<T>(x: impl Trait) -> T { loop {} }\n+struct S;\n+impl Trait for S {}\n+struct F;\n+impl Foo for F {}\n+\n+fn test() {\n+    Foo::bar(S);\n+    <F as Foo>::bar(S);\n+    F::bar(S);\n+    Foo::bar::<u32>(S);\n+    <F as Foo>::bar::<u32>(S);\n+\n+    foo(S);\n+    foo::<u32>(S);\n+    foo::<u32, i32>(S); // we should ignore the extraneous i32\n+}\n+\"#, true),\n+        @r###\"\n+    [156; 157) 'x': impl Trait\n+    [176; 187) '{ loop {} }': T\n+    [178; 185) 'loop {}': !\n+    [183; 185) '{}': ()\n+    [200; 201) 'x': impl Trait\n+    [220; 231) '{ loop {} }': T\n+    [222; 229) 'loop {}': !\n+    [227; 229) '{}': ()\n+    [301; 510) '{     ... i32 }': ()\n+    [307; 315) 'Foo::bar': fn bar<{unknown}, {unknown}, S>(S) -> {unknown}\n+    [307; 318) 'Foo::bar(S)': {unknown}\n+    [316; 317) 'S': S\n+    [324; 339) '<F as Foo>::bar': fn bar<F, {unknown}, S>(S) -> {unknown}\n+    [324; 342) '<F as ...bar(S)': {unknown}\n+    [340; 341) 'S': S\n+    [348; 354) 'F::bar': fn bar<F, {unknown}, S>(S) -> {unknown}\n+    [348; 357) 'F::bar(S)': {unknown}\n+    [355; 356) 'S': S\n+    [363; 378) 'Foo::bar::<u32>': fn bar<{unknown}, u32, S>(S) -> u32\n+    [363; 381) 'Foo::b...32>(S)': u32\n+    [379; 380) 'S': S\n+    [387; 409) '<F as ...:<u32>': fn bar<F, u32, S>(S) -> u32\n+    [387; 412) '<F as ...32>(S)': u32\n+    [410; 411) 'S': S\n+    [419; 422) 'foo': fn foo<{unknown}, S>(S) -> {unknown}\n+    [419; 425) 'foo(S)': {unknown}\n+    [423; 424) 'S': S\n+    [431; 441) 'foo::<u32>': fn foo<u32, S>(S) -> u32\n+    [431; 444) 'foo::<u32>(S)': u32\n+    [442; 443) 'S': S\n+    [450; 465) 'foo::<u32, i32>': fn foo<u32, S>(S) -> u32\n+    [450; 468) 'foo::<...32>(S)': u32\n+    [466; 467) 'S': S\n+    \"###\n+    );\n+}\n+\n+#[test]\n+fn argument_impl_trait_type_args_2() {\n+    assert_snapshot!(\n+        infer_with_mismatches(r#\"\n+trait Trait {}\n+struct S;\n+impl Trait for S {}\n+struct F<T>;\n+impl<T> F<T> {\n+    fn foo<U>(self, x: impl Trait) -> (T, U) { loop {} }\n+}\n+\n+fn test() {\n+    F.foo(S);\n+    F::<u32>.foo(S);\n+    F::<u32>.foo::<i32>(S);\n+    F::<u32>.foo::<i32, u32>(S); // extraneous argument should be ignored\n+}\n+\"#, true),\n+        @r###\"\n+    [88; 92) 'self': F<T>\n+    [94; 95) 'x': impl Trait\n+    [119; 130) '{ loop {} }': (T, U)\n+    [121; 128) 'loop {}': !\n+    [126; 128) '{}': ()\n+    [144; 284) '{     ...ored }': ()\n+    [150; 151) 'F': F<{unknown}>\n+    [150; 158) 'F.foo(S)': ({unknown}, {unknown})\n+    [156; 157) 'S': S\n+    [164; 172) 'F::<u32>': F<u32>\n+    [164; 179) 'F::<u32>.foo(S)': (u32, {unknown})\n+    [177; 178) 'S': S\n+    [185; 193) 'F::<u32>': F<u32>\n+    [185; 207) 'F::<u3...32>(S)': (u32, i32)\n+    [205; 206) 'S': S\n+    [213; 221) 'F::<u32>': F<u32>\n+    [213; 240) 'F::<u3...32>(S)': (u32, i32)\n+    [238; 239) 'S': S\n+    \"###\n+    );\n+}\n+\n #[test]\n #[ignore]\n fn impl_trait() {"}, {"sha": "508ae90465d7a9f8fcaa2547713fe7cef0b9001f", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c70619b0126bc0e40bd9df39dcd6e711cac69c5/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c70619b0126bc0e40bd9df39dcd6e711cac69c5/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=6c70619b0126bc0e40bd9df39dcd6e711cac69c5", "patch": "@@ -145,8 +145,9 @@ impl Generics {\n         (parent + child, parent, child)\n     }\n \n-    /// (self, type param list, impl trait)\n-    pub(crate) fn provenance_split(&self) -> (usize, usize, usize) {\n+    /// (parent total, self param, type param list, impl trait)\n+    pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize) {\n+        let parent = self.parent_generics.as_ref().map_or(0, |p| p.len());\n         let self_params = self\n             .params\n             .types\n@@ -165,7 +166,7 @@ impl Generics {\n             .iter()\n             .filter(|(_, p)| p.provenance == TypeParamProvenance::ArgumentImplTrait)\n             .count();\n-        (self_params, list_params, impl_trait_params)\n+        (parent, self_params, list_params, impl_trait_params)\n     }\n \n     pub(crate) fn param_idx(&self, param: TypeParamId) -> Option<u32> {"}]}