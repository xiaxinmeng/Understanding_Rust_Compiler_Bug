{"sha": "1954513ace66d81b62692f208fdaa91ab48c9757", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NTQ1MTNhY2U2NmQ4MWI2MjY5MmYyMDhmZGFhOTFhYjQ4Yzk3NTc=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-04-06T13:35:04Z"}, "committer": {"name": "Seiichi Uchida", "email": "seiichi.uchida@dena.com", "date": "2018-04-10T03:36:57Z"}, "message": "Merge imports with the same prefix into a single nested import", "tree": {"sha": "e786953e7b53b45bc76278074257b937fa8cd7ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e786953e7b53b45bc76278074257b937fa8cd7ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1954513ace66d81b62692f208fdaa91ab48c9757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1954513ace66d81b62692f208fdaa91ab48c9757", "html_url": "https://github.com/rust-lang/rust/commit/1954513ace66d81b62692f208fdaa91ab48c9757", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1954513ace66d81b62692f208fdaa91ab48c9757/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dd203eabe747903c3374c1edf5b8e3baaa6a886", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd203eabe747903c3374c1edf5b8e3baaa6a886", "html_url": "https://github.com/rust-lang/rust/commit/5dd203eabe747903c3374c1edf5b8e3baaa6a886"}], "stats": {"total": 324, "additions": 306, "deletions": 18}, "files": [{"sha": "76fa7816f0d8511587274c086815c45eaaf50c80", "filename": "src/imports.rs", "status": "modified", "additions": 274, "deletions": 8, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/1954513ace66d81b62692f208fdaa91ab48c9757/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1954513ace66d81b62692f208fdaa91ab48c9757/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=1954513ace66d81b62692f208fdaa91ab48c9757", "patch": "@@ -12,7 +12,7 @@ use std::cmp::Ordering;\n \n use config::lists::*;\n use syntax::ast::{self, UseTreeKind};\n-use syntax::codemap::{BytePos, Span};\n+use syntax::codemap::{self, BytePos, Span, DUMMY_SP};\n \n use codemap::SpanUtils;\n use config::IndentStyle;\n@@ -24,6 +24,7 @@ use utils::mk_sp;\n use visitor::FmtVisitor;\n \n use std::borrow::Cow;\n+use std::fmt;\n \n /// Returns a name imported by a `use` declaration. e.g. returns `Ordering`\n /// for `std::cmp::Ordering` and `self` for `std::cmp::self`.\n@@ -89,7 +90,7 @@ impl<'a> FmtVisitor<'a> {\n // sorting.\n \n // FIXME we do a lot of allocation to make our own representation.\n-#[derive(Debug, Clone, Eq, PartialEq)]\n+#[derive(Clone, Eq, PartialEq)]\n pub enum UseSegment {\n     Ident(String, Option<String>),\n     Slf(Option<String>),\n@@ -98,12 +99,12 @@ pub enum UseSegment {\n     List(Vec<UseTree>),\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Clone)]\n pub struct UseTree {\n     pub path: Vec<UseSegment>,\n     pub span: Span,\n     // Comment information within nested use tree.\n-    list_item: Option<ListItem>,\n+    pub list_item: Option<ListItem>,\n     // Additional fields for top level use items.\n     // Should we have another struct for top-level use items rather than reusing this?\n     visibility: Option<ast::Visibility>,\n@@ -143,12 +144,84 @@ impl UseSegment {\n     }\n }\n \n+pub fn merge_use_trees(use_trees: Vec<UseTree>) -> Vec<UseTree> {\n+    let mut result = Vec::with_capacity(use_trees.len());\n+    for use_tree in use_trees {\n+        if use_tree.has_comment() || use_tree.attrs.is_some() {\n+            result.push(use_tree);\n+            continue;\n+        }\n+\n+        for flattened in use_tree.flatten() {\n+            merge_use_trees_inner(&mut result, flattened);\n+        }\n+    }\n+    result\n+}\n+\n+fn merge_use_trees_inner(trees: &mut Vec<UseTree>, use_tree: UseTree) {\n+    for tree in trees.iter_mut() {\n+        if tree.share_prefix(&use_tree) {\n+            tree.merge(use_tree);\n+            return;\n+        }\n+    }\n+\n+    trees.push(use_tree);\n+}\n+\n+impl fmt::Debug for UseTree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self)\n+    }\n+}\n+\n+impl fmt::Debug for UseSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self)\n+    }\n+}\n+\n+impl fmt::Display for UseSegment {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            UseSegment::Glob => write!(f, \"*\"),\n+            UseSegment::Ident(ref s, _) => write!(f, \"{}\", s),\n+            UseSegment::Slf(..) => write!(f, \"self\"),\n+            UseSegment::Super(..) => write!(f, \"super\"),\n+            UseSegment::List(ref list) => {\n+                write!(f, \"{{\")?;\n+                for (i, item) in list.iter().enumerate() {\n+                    let is_last = i == list.len() - 1;\n+                    write!(f, \"{}\", item)?;\n+                    if !is_last {\n+                        write!(f, \", \")?;\n+                    }\n+                }\n+                write!(f, \"}}\")\n+            }\n+        }\n+    }\n+}\n+impl fmt::Display for UseTree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        for (i, segment) in self.path.iter().enumerate() {\n+            let is_last = i == self.path.len() - 1;\n+            write!(f, \"{}\", segment)?;\n+            if !is_last {\n+                write!(f, \"::\")?;\n+            }\n+        }\n+        write!(f, \"\")\n+    }\n+}\n+\n impl UseTree {\n     // Rewrite use tree with `use ` and a trailing `;`.\n     pub fn rewrite_top_level(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let mut result = String::with_capacity(256);\n         if let Some(ref attrs) = self.attrs {\n-            result.push_str(&attrs.rewrite(context, shape)?);\n+            result.push_str(&attrs.rewrite(context, shape).expect(\"rewrite attr\"));\n             if !result.is_empty() {\n                 result.push_str(&shape.indent.to_string_with_newline(context.config));\n             }\n@@ -168,6 +241,17 @@ impl UseTree {\n         Some(result)\n     }\n \n+    // FIXME: Use correct span?\n+    fn from_path(path: Vec<UseSegment>, span: Span) -> UseTree {\n+        UseTree {\n+            path,\n+            span,\n+            list_item: None,\n+            visibility: None,\n+            attrs: None,\n+        }\n+    }\n+\n     pub fn from_ast_with_normalization(\n         context: &RewriteContext,\n         item: &ast::Item,\n@@ -360,6 +444,131 @@ impl UseTree {\n         self.path.push(last);\n         self\n     }\n+\n+    fn has_comment(&self) -> bool {\n+        self.list_item.as_ref().map_or(false, |list_item| {\n+            list_item.pre_comment.is_some() || list_item.post_comment.is_some()\n+        })\n+    }\n+\n+    fn same_visibility(&self, other: &UseTree) -> bool {\n+        match (&self.visibility, &other.visibility) {\n+            (\n+                Some(codemap::Spanned {\n+                    node: ast::VisibilityKind::Inherited,\n+                    ..\n+                }),\n+                None,\n+            )\n+            | (\n+                None,\n+                Some(codemap::Spanned {\n+                    node: ast::VisibilityKind::Inherited,\n+                    ..\n+                }),\n+            )\n+            | (None, None) => true,\n+            (\n+                Some(codemap::Spanned { node: lnode, .. }),\n+                Some(codemap::Spanned { node: rnode, .. }),\n+            ) => lnode == rnode,\n+            _ => false,\n+        }\n+    }\n+\n+    fn share_prefix(&self, other: &UseTree) -> bool {\n+        if self.path.is_empty() || other.path.is_empty() || self.attrs.is_some()\n+            || !self.same_visibility(other)\n+        {\n+            false\n+        } else {\n+            self.path[0] == other.path[0]\n+        }\n+    }\n+\n+    fn flatten(self) -> Vec<UseTree> {\n+        if self.path.is_empty() {\n+            return vec![self];\n+        }\n+        match self.path.clone().last().unwrap() {\n+            UseSegment::List(list) => {\n+                let prefix = &self.path[..self.path.len() - 1];\n+                let mut result = vec![];\n+                for nested_use_tree in list.into_iter() {\n+                    for mut flattend in nested_use_tree.clone().flatten().iter_mut() {\n+                        let mut new_path = prefix.to_vec();\n+                        new_path.append(&mut flattend.path);\n+                        result.push(UseTree {\n+                            path: new_path,\n+                            span: self.span,\n+                            list_item: None,\n+                            visibility: self.visibility.clone(),\n+                            attrs: None,\n+                        });\n+                    }\n+                }\n+\n+                result\n+            }\n+            _ => vec![self],\n+        }\n+    }\n+\n+    fn merge(&mut self, other: UseTree) {\n+        let mut new_path = vec![];\n+        let mut len = 0;\n+        for (i, (mut a, b)) in self.path\n+            .clone()\n+            .iter_mut()\n+            .zip(other.path.clone().into_iter())\n+            .enumerate()\n+        {\n+            if *a == b {\n+                len = i + 1;\n+                new_path.push(b);\n+                continue;\n+            } else {\n+                len = i;\n+                break;\n+            }\n+        }\n+        if let Some(merged) = merge_rest(&self.path, &other.path, len) {\n+            new_path.push(merged);\n+            self.span = self.span.to(other.span);\n+        }\n+        self.path = new_path;\n+    }\n+}\n+\n+fn merge_rest(a: &[UseSegment], b: &[UseSegment], len: usize) -> Option<UseSegment> {\n+    let a_rest = &a[len..];\n+    let b_rest = &b[len..];\n+    if a_rest.is_empty() && b_rest.is_empty() {\n+        return None;\n+    }\n+    if a_rest.is_empty() {\n+        return Some(UseSegment::List(vec![\n+            UseTree::from_path(vec![UseSegment::Slf(None)], DUMMY_SP),\n+            UseTree::from_path(b_rest.to_vec(), DUMMY_SP),\n+        ]));\n+    }\n+    if b_rest.is_empty() {\n+        return Some(UseSegment::List(vec![\n+            UseTree::from_path(vec![UseSegment::Slf(None)], DUMMY_SP),\n+            UseTree::from_path(a_rest.to_vec(), DUMMY_SP),\n+        ]));\n+    }\n+    if let UseSegment::List(mut list) = a_rest[0].clone() {\n+        merge_use_trees_inner(&mut list, UseTree::from_path(b_rest.to_vec(), DUMMY_SP));\n+        list.sort();\n+        return Some(UseSegment::List(list.clone()));\n+    }\n+    let mut list = vec![\n+        UseTree::from_path(a_rest.to_vec(), DUMMY_SP),\n+        UseTree::from_path(b_rest.to_vec(), DUMMY_SP),\n+    ];\n+    list.sort();\n+    Some(UseSegment::List(list))\n }\n \n impl PartialOrd for UseSegment {\n@@ -461,9 +670,12 @@ fn rewrite_nested_use_tree(\n         IndentStyle::Visual => shape.visual_indent(0),\n     };\n     for use_tree in use_tree_list {\n-        let mut list_item = use_tree.list_item.clone()?;\n-        list_item.item = use_tree.rewrite(context, nested_shape);\n-        list_items.push(list_item);\n+        if let Some(mut list_item) = use_tree.list_item.clone() {\n+            list_item.item = use_tree.rewrite(context, nested_shape);\n+            list_items.push(list_item);\n+        } else {\n+            list_items.push(ListItem::from_str(use_tree.rewrite(context, nested_shape)?));\n+        }\n     }\n     let (tactic, remaining_width) = if use_tree_list.iter().any(|use_segment| {\n         use_segment\n@@ -683,6 +895,60 @@ mod test {\n         parser.parse_in_list()\n     }\n \n+    macro parse_use_trees($($s:expr),* $(,)*) {\n+        vec![\n+            $(parse_use_tree($s),)*\n+        ]\n+    }\n+\n+    #[test]\n+    fn test_use_tree_merge() {\n+        macro test_merge([$($input:expr),* $(,)*], [$($output:expr),* $(,)*]) {\n+            assert_eq!(\n+                merge_use_trees(parse_use_trees!($($input,)*)),\n+                parse_use_trees!($($output,)*),\n+            );\n+        }\n+\n+        test_merge!([\"a::b::{c, d}\", \"a::b::{e, f}\"], [\"a::b::{c, d, e, f}\"]);\n+        test_merge!([\"a::b::c\", \"a::b\"], [\"a::b::{self, c}\"]);\n+        test_merge!([\"a::b\", \"a::b\"], [\"a::b\"]);\n+        test_merge!([\"a\", \"a::b\", \"a::b::c\"], [\"a::{self, b::{self, c}}\"]);\n+        test_merge!(\n+            [\"a::{b::{self, c}, d::e}\", \"a::d::f\"],\n+            [\"a::{b::{self, c}, d::{e, f}}\"]\n+        );\n+        test_merge!(\n+            [\"a::d::f\", \"a::{b::{self, c}, d::e}\"],\n+            [\"a::{b::{self, c}, d::{e, f}}\"]\n+        );\n+        test_merge!(\n+            [\"a::{c, d, b}\", \"a::{d, e, b, a, f}\", \"a::{f, g, c}\"],\n+            [\"a::{a, b, c, d, e, f, g}\"]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_use_tree_flatten() {\n+        assert_eq!(\n+            parse_use_tree(\"a::b::{c, d, e, f}\").flatten(),\n+            parse_use_trees!(\"a::b::c\", \"a::b::d\", \"a::b::e\", \"a::b::f\",)\n+        );\n+\n+        assert_eq!(\n+            parse_use_tree(\"a::b::{c::{d, e, f}, g, h::{i, j, k}}\").flatten(),\n+            parse_use_trees![\n+                \"a::b::c::d\",\n+                \"a::b::c::e\",\n+                \"a::b::c::f\",\n+                \"a::b::g\",\n+                \"a::b::h::i\",\n+                \"a::b::h::j\",\n+                \"a::b::h::k\",\n+            ]\n+        );\n+    }\n+\n     #[test]\n     fn test_use_tree_normalize() {\n         assert_eq!("}, {"sha": "266cd1b472b0ce4c3ed8e497324c124979ff34ac", "filename": "src/lists.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1954513ace66d81b62692f208fdaa91ab48c9757/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1954513ace66d81b62692f208fdaa91ab48c9757/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=1954513ace66d81b62692f208fdaa91ab48c9757", "patch": "@@ -80,6 +80,16 @@ pub struct ListItem {\n }\n \n impl ListItem {\n+    pub fn empty() -> ListItem {\n+        ListItem {\n+            pre_comment: None,\n+            pre_comment_style: ListItemCommentStyle::None,\n+            item: None,\n+            post_comment: None,\n+            new_lines: false,\n+        }\n+    }\n+\n     pub fn inner_as_ref(&self) -> &str {\n         self.item.as_ref().map_or(\"\", |s| s)\n     }"}, {"sha": "099c25cfd9b1ab6b102e44791ad0229bed2d5bea", "filename": "src/reorder.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1954513ace66d81b62692f208fdaa91ab48c9757/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1954513ace66d81b62692f208fdaa91ab48c9757/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=1954513ace66d81b62692f208fdaa91ab48c9757", "patch": "@@ -22,7 +22,7 @@ use syntax::{ast, attr, codemap::Span};\n use attr::filter_inline_attrs;\n use codemap::LineRangeUtils;\n use comment::combine_strs_with_missing_comments;\n-use imports::UseTree;\n+use imports::{merge_use_trees, UseTree};\n use items::{is_mod_decl, rewrite_extern_crate, rewrite_mod};\n use lists::{itemize_list, write_list, ListFormatting, ListItem};\n use rewrite::{Rewrite, RewriteContext};\n@@ -117,29 +117,41 @@ fn rewrite_reorderable_items(\n     match reorderable_items[0].node {\n         // FIXME: Remove duplicated code.\n         ast::ItemKind::Use(..) => {\n-            let normalized_items: Vec<_> = reorderable_items\n+            let mut normalized_items: Vec<_> = reorderable_items\n                 .iter()\n                 .filter_map(|item| UseTree::from_ast_with_normalization(context, item))\n                 .collect();\n-\n-            // 4 = \"use \", 1 = \";\"\n-            let nested_shape = shape.offset_left(4)?.sub_width(1)?;\n+            let cloned = normalized_items.clone();\n+            // Add comments before merging.\n             let list_items = itemize_list(\n                 context.snippet_provider,\n-                normalized_items.iter(),\n+                cloned.iter(),\n                 \"\",\n                 \";\",\n                 |item| item.span.lo(),\n                 |item| item.span.hi(),\n-                |item| item.rewrite_top_level(context, nested_shape),\n+                |_item| Some(\"\".to_owned()),\n                 span.lo(),\n                 span.hi(),\n                 false,\n             );\n+            for (item, list_item) in normalized_items.iter_mut().zip(list_items) {\n+                item.list_item = Some(list_item.clone());\n+            }\n+            if context.config.merge_imports() {\n+                normalized_items = merge_use_trees(normalized_items);\n+            }\n+            normalized_items.sort();\n \n-            let mut item_pair_vec: Vec<_> = list_items.zip(&normalized_items).collect();\n-            item_pair_vec.sort_by(|a, b| a.1.cmp(b.1));\n-            let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n+            // 4 = \"use \", 1 = \";\"\n+            let nested_shape = shape.offset_left(4)?.sub_width(1)?;\n+            let item_vec: Vec<_> = normalized_items\n+                .into_iter()\n+                .map(|use_tree| ListItem {\n+                    item: use_tree.rewrite_top_level(context, nested_shape),\n+                    ..use_tree.list_item.unwrap_or_else(|| ListItem::empty())\n+                })\n+                .collect();\n \n             wrap_reorderable_items(context, &item_vec, nested_shape)\n         }"}]}