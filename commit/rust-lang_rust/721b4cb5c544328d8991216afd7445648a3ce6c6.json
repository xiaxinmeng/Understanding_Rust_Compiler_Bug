{"sha": "721b4cb5c544328d8991216afd7445648a3ce6c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyMWI0Y2I1YzU0NDMyOGQ4OTkxMjE2YWZkNzQ0NTY0OGEzY2U2YzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-01T06:31:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-01T06:31:35Z"}, "message": "auto merge of #15263 : aturon/rust/rustdoc-stability-index, r=alexcrichton\n\nThis commit hooks rustdoc into the stability index infrastructure in two\r\nways:\r\n\r\n1. It looks up stability levels via the index, rather than by manual\r\nattributes.\r\n\r\n2. It adds stability level information throughout rustdoc output, rather\r\nthan just at the top header. In particular, a stability color (with\r\nmouseover text) appears next to essentially every item that appears\r\nin rustdoc's HTML output.\r\n\r\nAlong the way, the stability index code has been lightly refactored.", "tree": {"sha": "48b5dba5042e6af094c96ea2009269f9c465bfb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48b5dba5042e6af094c96ea2009269f9c465bfb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/721b4cb5c544328d8991216afd7445648a3ce6c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/721b4cb5c544328d8991216afd7445648a3ce6c6", "html_url": "https://github.com/rust-lang/rust/commit/721b4cb5c544328d8991216afd7445648a3ce6c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/721b4cb5c544328d8991216afd7445648a3ce6c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d96834067165634addc172b27ed993ef5f12bae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d96834067165634addc172b27ed993ef5f12bae8", "html_url": "https://github.com/rust-lang/rust/commit/d96834067165634addc172b27ed993ef5f12bae8"}, {"sha": "256df5e3df5fecbd8e9a8ca1b7a370b0ce22efee", "url": "https://api.github.com/repos/rust-lang/rust/commits/256df5e3df5fecbd8e9a8ca1b7a370b0ce22efee", "html_url": "https://github.com/rust-lang/rust/commit/256df5e3df5fecbd8e9a8ca1b7a370b0ce22efee"}], "stats": {"total": 454, "additions": 282, "deletions": 172}, "files": [{"sha": "30296cb318617af1fdc0a544374596a44e5a37c8", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -30,7 +30,7 @@ use middle::def::*;\n use middle::trans::adt; // for `adt::is_ffi_safe`\n use middle::typeck::astconv::ast_ty_to_ty;\n use middle::typeck::infer;\n-use middle::{typeck, ty, def, pat_util};\n+use middle::{typeck, ty, def, pat_util, stability};\n use util::ppaux::{ty_to_str};\n use util::nodemap::NodeSet;\n use lint::{Context, LintPass, LintArray};\n@@ -1426,11 +1426,7 @@ impl LintPass for Stability {\n                     Some(method) => {\n                         match method.origin {\n                             typeck::MethodStatic(def_id) => {\n-                                // If this implements a trait method, get def_id\n-                                // of the method inside trait definition.\n-                                // Otherwise, use the current def_id (which refers\n-                                // to the method inside impl).\n-                                ty::trait_method_of_method(cx.tcx, def_id).unwrap_or(def_id)\n+                                def_id\n                             }\n                             typeck::MethodParam(typeck::MethodParam {\n                                 trait_id: trait_id,\n@@ -1454,8 +1450,7 @@ impl LintPass for Stability {\n         // check anything for crate-local usage.\n         if ast_util::is_local(id) { return }\n \n-        let stability = cx.tcx.stability.borrow_mut().lookup(&cx.tcx.sess.cstore, id);\n-\n+        let stability = stability::lookup(cx.tcx, id);\n         let (lint, label) = match stability {\n             // no stability attributes == Unstable\n             None => (UNSTABLE, \"unmarked\"),"}, {"sha": "96284f8de261a78254f0faa3ff837c660049cf2b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -24,6 +24,7 @@ use middle::ty::{node_id_to_type, lookup_item_type};\n use middle::astencode;\n use middle::ty;\n use middle::typeck;\n+use middle::stability;\n use middle;\n use util::nodemap::{NodeMap, NodeSet};\n \n@@ -328,7 +329,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_visibility(ebml_w, variant.node.vis);\n         encode_attributes(ebml_w, variant.node.attrs.as_slice());\n \n-        let stab = ecx.tcx.stability.borrow().lookup_local(variant.node.id);\n+        let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(ebml_w, stab);\n \n         match variant.node.kind {\n@@ -592,7 +593,9 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     encode_path(ebml_w, path.clone());\n     encode_visibility(ebml_w, vis);\n-    encode_stability(ebml_w, ecx.tcx.stability.borrow().lookup_local(id));\n+\n+    let stab = stability::lookup(ecx.tcx, ast_util::local_def(id));\n+    encode_stability(ebml_w, stab);\n \n     // Encode the reexports of this module, if this module is public.\n     if vis == Public {\n@@ -722,7 +725,8 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n         encode_symbol(ecx, ebml_w, ctor_id);\n     }\n \n-    encode_stability(ebml_w, ecx.tcx.stability.borrow().lookup_local(ctor_id));\n+    let stab = stability::lookup(ecx.tcx, ast_util::local_def(ctor_id));\n+    encode_stability(ebml_w, stab);\n \n     // indicate that this is a tuple struct ctor, because downstream users will normally want\n     // the tuple struct definition, but without this there is no way for them to tell that\n@@ -768,7 +772,7 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     encode_method_ty_fields(ecx, ebml_w, m);\n     encode_parent_item(ebml_w, local_def(parent_id));\n \n-    let stab = ecx.tcx.stability.borrow().lookup_local(m.def_id.node);\n+    let stab = stability::lookup(ecx.tcx, m.def_id);\n     encode_stability(ebml_w, stab);\n \n     // The type for methods gets encoded twice, which is unfortunate.\n@@ -915,10 +919,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n     }\n \n     debug!(\"encoding info for item at {}\",\n-           ecx.tcx.sess.codemap().span_to_str(item.span));\n+           tcx.sess.codemap().span_to_str(item.span));\n \n     let def_id = local_def(item.id);\n-    let stab = tcx.stability.borrow().lookup_local(item.id);\n+    let stab = stability::lookup(tcx, ast_util::local_def(item.id));\n \n     match item.node {\n       ItemStatic(_, m, _) => {\n@@ -1206,7 +1210,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_method_ty_fields(ecx, ebml_w, &*method_ty);\n             encode_parent_item(ebml_w, def_id);\n \n-            let stab = tcx.stability.borrow().lookup_local(method_def_id.node);\n+            let stab = stability::lookup(tcx, method_def_id);\n             encode_stability(ebml_w, stab);\n \n             let elem = ast_map::PathName(method_ty.ident.name);"}, {"sha": "ac17bd07503521212b46b40f71055095d86649e3", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -20,7 +20,8 @@ use syntax::ast::{Generics, StructDef, Ident};\n use syntax::ast_util::is_local;\n use syntax::attr::Stability;\n use syntax::visit::{FnKind, FkMethod, Visitor};\n-use metadata::{cstore, csearch};\n+use middle::ty;\n+use metadata::csearch;\n \n /// A stability index, giving the stability level for items and methods.\n pub struct Index {\n@@ -105,21 +106,24 @@ impl Index {\n                           attr::find_stability(krate.attrs.as_slice()));\n         annotator.index\n     }\n+}\n \n-    /// Lookup the stability for a node, loading external crate\n-    /// metadata as necessary.\n-    pub fn lookup(&mut self, cstore: &cstore::CStore, id: DefId) -> Option<Stability> {\n-        if is_local(id) {\n-            self.lookup_local(id.node)\n-        } else {\n-            let stab = csearch::get_stability(cstore, id);\n-            self.extern_cache.insert(id, stab.clone());\n+/// Lookup the stability for a node, loading external crate\n+/// metadata as necessary.\n+pub fn lookup(tcx: &ty::ctxt,  id: DefId) -> Option<Stability> {\n+    // is this definition the implementation of a trait method?\n+    match ty::trait_method_of_method(tcx, id) {\n+        Some(trait_method_id) if trait_method_id != id => {\n+            lookup(tcx, trait_method_id)\n+        }\n+        _ if is_local(id) => {\n+            tcx.stability.borrow().local.find_copy(&id.node)\n+        }\n+        _ => {\n+            let stab = csearch::get_stability(&tcx.sess.cstore, id);\n+            let mut index = tcx.stability.borrow_mut();\n+            (*index).extern_cache.insert(id, stab.clone());\n             stab\n         }\n     }\n-\n-    /// Lookup the stability for a local node without loading any external crates\n-    pub fn lookup_local(&self, id: NodeId) -> Option<Stability> {\n-        self.local.find_copy(&id)\n-    }\n }"}, {"sha": "2d498e7f302d3fca3330b0182ea547608eac6c68", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -18,6 +18,7 @@ use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::def;\n use rustc::middle::ty;\n+use rustc::middle::stability;\n \n use core;\n use doctree;\n@@ -102,6 +103,7 @@ fn try_inline_def(cx: &core::DocContext,\n         attrs: load_attrs(tcx, did),\n         inner: inner,\n         visibility: Some(ast::Public),\n+        stability: stability::lookup(tcx, did).clean(),\n         def_id: did,\n     });\n     Some(ret)\n@@ -317,6 +319,7 @@ fn build_impl(cx: &core::DocContext,\n         name: None,\n         attrs: attrs,\n         visibility: Some(ast::Inherited),\n+        stability: stability::lookup(tcx, did).clean(),\n         def_id: did,\n     })\n }"}, {"sha": "87151708812e54a5f106291d5a04fd851bf6a0dc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 84, "deletions": 68, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -29,6 +29,7 @@ use rustc::middle::def;\n use rustc::middle::subst;\n use rustc::middle::subst::VecPerParamSpace;\n use rustc::middle::ty;\n+use rustc::middle::stability;\n \n use std::rc::Rc;\n use std::u32;\n@@ -44,6 +45,17 @@ pub static SCHEMA_VERSION: &'static str = \"0.8.3\";\n \n mod inline;\n \n+// load the current DocContext from TLD\n+fn get_cx() -> Gc<core::DocContext> {\n+    *super::ctxtkey.get().unwrap()\n+}\n+\n+// extract the stability index for a node from TLD, if possible\n+fn get_stability(def_id: ast::DefId) -> Option<Stability> {\n+    get_cx().tcx_opt().and_then(|tcx| stability::lookup(tcx, def_id))\n+            .map(|stab| stab.clean())\n+}\n+\n pub trait Clean<T> {\n     fn clean(&self) -> T;\n }\n@@ -97,7 +109,7 @@ pub struct Crate {\n \n impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n     fn clean(&self) -> Crate {\n-        let cx = super::ctxtkey.get().unwrap();\n+        let cx = get_cx();\n \n         let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n@@ -158,6 +170,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n                     name: Some(prim.to_url_str().to_string()),\n                     attrs: Vec::new(),\n                     visibility: None,\n+                    stability: None,\n                     def_id: ast_util::local_def(prim.to_node_id()),\n                     inner: PrimitiveItem(prim),\n                 };\n@@ -193,25 +206,18 @@ pub struct ExternalCrate {\n impl Clean<ExternalCrate> for cstore::crate_metadata {\n     fn clean(&self) -> ExternalCrate {\n         let mut primitives = Vec::new();\n-        let cx = super::ctxtkey.get().unwrap();\n-        match cx.maybe_typed {\n-            core::Typed(ref tcx) => {\n-                csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n-                                                      self.cnum,\n-                                                      |def, _, _| {\n-                    let did = match def {\n-                        decoder::DlDef(def::DefMod(did)) => did,\n-                        _ => return\n-                    };\n-                    let attrs = inline::load_attrs(tcx, did);\n-                    match Primitive::find(attrs.as_slice()) {\n-                        Some(prim) => primitives.push(prim),\n-                        None => {}\n-                    }\n-                });\n-            }\n-            core::NotTyped(..) => {}\n-        }\n+        get_cx().tcx_opt().map(|tcx| {\n+            csearch::each_top_level_item_of_crate(&tcx.sess.cstore,\n+                                                  self.cnum,\n+                                                  |def, _, _| {\n+                let did = match def {\n+                    decoder::DlDef(def::DefMod(did)) => did,\n+                    _ => return\n+                };\n+                let attrs = inline::load_attrs(tcx, did);\n+                Primitive::find(attrs.as_slice()).map(|prim| primitives.push(prim));\n+            })\n+        });\n         ExternalCrate {\n             name: self.name.to_string(),\n             attrs: decoder::get_crate_attributes(self.data()).clean(),\n@@ -233,6 +239,7 @@ pub struct Item {\n     pub inner: ItemEnum,\n     pub visibility: Option<Visibility>,\n     pub def_id: ast::DefId,\n+    pub stability: Option<Stability>,\n }\n \n impl Item {\n@@ -380,6 +387,7 @@ impl Clean<Item> for doctree::Module {\n             attrs: self.attrs.clean(),\n             source: where.clean(),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n@@ -465,9 +473,8 @@ impl Clean<TyParam> for ast::TyParam {\n \n impl Clean<TyParam> for ty::TypeParameterDef {\n     fn clean(&self) -> TyParam {\n-        let cx = super::ctxtkey.get().unwrap();\n-        cx.external_typarams.borrow_mut().get_mut_ref().insert(self.def_id,\n-                                                               self.ident.clean());\n+        get_cx().external_typarams.borrow_mut().get_mut_ref()\n+                .insert(self.def_id, self.ident.clean());\n         TyParam {\n             name: self.ident.clean(),\n             did: self.def_id,\n@@ -515,7 +522,7 @@ fn external_path(name: &str, substs: &subst::Substs) -> Path {\n \n impl Clean<TyParamBound> for ty::BuiltinBound {\n     fn clean(&self) -> TyParamBound {\n-        let cx = super::ctxtkey.get().unwrap();\n+        let cx = get_cx();\n         let tcx = match cx.maybe_typed {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return RegionBound,\n@@ -550,7 +557,7 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n \n impl Clean<TyParamBound> for ty::TraitRef {\n     fn clean(&self) -> TyParamBound {\n-        let cx = super::ctxtkey.get().unwrap();\n+        let cx = get_cx();\n         let tcx = match cx.maybe_typed {\n             core::Typed(ref tcx) => tcx,\n             core::NotTyped(_) => return RegionBound,\n@@ -709,8 +716,9 @@ impl Clean<Item> for ast::Method {\n             name: Some(self.ident.clean()),\n             attrs: self.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n-            def_id: ast_util::local_def(self.id.clone()),\n+            def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: get_stability(ast_util::local_def(self.id)),\n             inner: MethodItem(Method {\n                 generics: self.generics.clean(),\n                 self_: self.explicit_self.node.clean(),\n@@ -749,6 +757,7 @@ impl Clean<Item> for ast::TypeMethod {\n             source: self.span.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: None,\n+            stability: get_stability(ast_util::local_def(self.id)),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fn_style.clone(),\n                 decl: decl,\n@@ -792,6 +801,7 @@ impl Clean<Item> for doctree::Function {\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(),\n@@ -854,14 +864,10 @@ impl Clean<FnDecl> for ast::FnDecl {\n \n impl<'a> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig) {\n     fn clean(&self) -> FnDecl {\n-        let cx = super::ctxtkey.get().unwrap();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => unreachable!(),\n-        };\n+        let cx = get_cx();\n         let (did, sig) = *self;\n         let mut names = if did.node != 0 {\n-            csearch::get_method_arg_names(&tcx.sess.cstore, did).move_iter()\n+            csearch::get_method_arg_names(&cx.tcx().sess.cstore, did).move_iter()\n         } else {\n             Vec::new().move_iter()\n         }.peekable();\n@@ -932,6 +938,7 @@ impl Clean<Item> for doctree::Trait {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: TraitItem(Trait {\n                 methods: self.methods.clean(),\n                 generics: self.generics.clean(),\n@@ -985,11 +992,7 @@ impl Clean<TraitMethod> for ast::TraitMethod {\n \n impl Clean<Item> for ty::Method {\n     fn clean(&self) -> Item {\n-        let cx = super::ctxtkey.get().unwrap();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tcx) => tcx,\n-            core::NotTyped(_) => unreachable!(),\n-        };\n+        let cx = get_cx();\n         let (self_, sig) = match self.explicit_self {\n             ast::SelfStatic => (ast::SelfStatic.clean(), self.fty.sig.clone()),\n             s => {\n@@ -1015,8 +1018,9 @@ impl Clean<Item> for ty::Method {\n         Item {\n             name: Some(self.ident.clean()),\n             visibility: Some(ast::Inherited),\n+            stability: get_stability(self.def_id),\n             def_id: self.def_id,\n-            attrs: inline::load_attrs(tcx, self.def_id),\n+            attrs: inline::load_attrs(cx.tcx(), self.def_id),\n             source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fty.fn_style,\n@@ -1261,12 +1265,7 @@ impl Clean<Type> for ty::t {\n             ty::ty_struct(did, ref substs) |\n             ty::ty_enum(did, ref substs) |\n             ty::ty_trait(box ty::TyTrait { def_id: did, ref substs, .. }) => {\n-                let cx = super::ctxtkey.get().unwrap();\n-                let tcx = match cx.maybe_typed {\n-                    core::Typed(ref tycx) => tycx,\n-                    core::NotTyped(_) => unreachable!(),\n-                };\n-                let fqn = csearch::get_item_path(tcx, did);\n+                let fqn = csearch::get_item_path(get_cx().tcx(), did);\n                 let fqn: Vec<String> = fqn.move_iter().map(|i| {\n                     i.to_str()\n                 }).collect();\n@@ -1277,8 +1276,8 @@ impl Clean<Type> for ty::t {\n                 };\n                 let path = external_path(fqn.last().unwrap().to_str().as_slice(),\n                                          substs);\n-                cx.external_paths.borrow_mut().get_mut_ref().insert(did,\n-                                                                    (fqn, kind));\n+                get_cx().external_paths.borrow_mut().get_mut_ref()\n+                                       .insert(did, (fqn, kind));\n                 ResolvedPath {\n                     path: path,\n                     typarams: None,\n@@ -1318,6 +1317,7 @@ impl Clean<Item> for ast::StructField {\n             attrs: self.node.attrs.clean().move_iter().collect(),\n             source: self.span.clean(),\n             visibility: Some(vis),\n+            stability: get_stability(ast_util::local_def(self.node.id)),\n             def_id: ast_util::local_def(self.node.id),\n             inner: StructFieldItem(TypedStructField(self.node.ty.clean())),\n         }\n@@ -1332,17 +1332,14 @@ impl Clean<Item> for ty::field_ty {\n         } else {\n             Some(self.name)\n         };\n-        let cx = super::ctxtkey.get().unwrap();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tycx) => tycx,\n-            core::NotTyped(_) => unreachable!(),\n-        };\n-        let ty = ty::lookup_item_type(tcx, self.id);\n+        let cx = get_cx();\n+        let ty = ty::lookup_item_type(cx.tcx(), self.id);\n         Item {\n             name: name.clean(),\n-            attrs: inline::load_attrs(tcx, self.id),\n+            attrs: inline::load_attrs(cx.tcx(), self.id),\n             source: Span::empty(),\n             visibility: Some(self.vis),\n+            stability: get_stability(self.id),\n             def_id: self.id,\n             inner: StructFieldItem(TypedStructField(ty.ty.clean())),\n         }\n@@ -1373,6 +1370,7 @@ impl Clean<Item> for doctree::Struct {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: StructItem(Struct {\n                 struct_type: self.struct_type,\n                 generics: self.generics.clean(),\n@@ -1418,6 +1416,7 @@ impl Clean<Item> for doctree::Enum {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: EnumItem(Enum {\n                 variants: self.variants.clean(),\n                 generics: self.generics.clean(),\n@@ -1439,6 +1438,7 @@ impl Clean<Item> for doctree::Variant {\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n             inner: VariantItem(Variant {\n                 kind: self.kind.clean(),\n@@ -1450,11 +1450,7 @@ impl Clean<Item> for doctree::Variant {\n impl Clean<Item> for ty::VariantInfo {\n     fn clean(&self) -> Item {\n         // use syntax::parse::token::special_idents::unnamed_field;\n-        let cx = super::ctxtkey.get().unwrap();\n-        let tcx = match cx.maybe_typed {\n-            core::Typed(ref tycx) => tycx,\n-            core::NotTyped(_) => fail!(\"tcx not present\"),\n-        };\n+        let cx = get_cx();\n         let kind = match self.arg_names.as_ref().map(|s| s.as_slice()) {\n             None | Some([]) if self.args.len() == 0 => CLikeVariant,\n             None | Some([]) => {\n@@ -1470,6 +1466,7 @@ impl Clean<Item> for ty::VariantInfo {\n                             name: Some(name.clean()),\n                             attrs: Vec::new(),\n                             visibility: Some(ast::Public),\n+                            stability: get_stability(self.id),\n                             // FIXME: this is not accurate, we need an id for\n                             //        the specific field but we're using the id\n                             //        for the whole variant. Nothing currently\n@@ -1485,11 +1482,12 @@ impl Clean<Item> for ty::VariantInfo {\n         };\n         Item {\n             name: Some(self.name.clean()),\n-            attrs: inline::load_attrs(tcx, self.id),\n+            attrs: inline::load_attrs(cx.tcx(), self.id),\n             source: Span::empty(),\n             visibility: Some(ast::Public),\n             def_id: self.id,\n             inner: VariantItem(Variant { kind: kind }),\n+            stability: None,\n         }\n     }\n }\n@@ -1626,6 +1624,7 @@ impl Clean<Item> for doctree::Typedef {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id.clone()),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: TypedefItem(Typedef {\n                 type_: self.ty.clean(),\n                 generics: self.gen.clean(),\n@@ -1675,6 +1674,7 @@ impl Clean<Item> for doctree::Static {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: StaticItem(Static {\n                 type_: self.type_.clean(),\n                 mutability: self.mutability.clean(),\n@@ -1720,6 +1720,7 @@ impl Clean<Item> for doctree::Impl {\n             source: self.where.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: self.stab.clean(),\n             inner: ImplItem(Impl {\n                 generics: self.generics.clean(),\n                 trait_: self.trait_.clean(),\n@@ -1754,6 +1755,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                 source: self.span.clean(),\n                 def_id: ast_util::local_def(0),\n                 visibility: self.vis.clean(),\n+                stability: None,\n                 inner: ViewItemItem(ViewItem { inner: node.clean() }),\n             }\n         };\n@@ -1895,6 +1897,7 @@ impl Clean<Item> for ast::ForeignItem {\n             source: self.span.clean(),\n             def_id: ast_util::local_def(self.id),\n             visibility: self.vis.clean(),\n+            stability: None,\n             inner: inner,\n         }\n     }\n@@ -1977,7 +1980,7 @@ fn name_from_pat(p: &ast::Pat) -> String {\n /// Given a Type, resolve it using the def_map\n fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n                 id: ast::NodeId) -> Type {\n-    let cx = super::ctxtkey.get().unwrap();\n+    let cx = get_cx();\n     let tycx = match cx.maybe_typed {\n         core::Typed(ref tycx) => tycx,\n         // If we're extracting tests, this return value doesn't matter.\n@@ -2012,7 +2015,7 @@ fn resolve_type(path: Path, tpbs: Option<Vec<TyParamBound>>,\n         def::DefTyParamBinder(i) => return TyParamBinder(i),\n         _ => {}\n     };\n-    let did = register_def(&**cx, def);\n+    let did = register_def(&*cx, def);\n     ResolvedPath { path: path, typarams: tpbs, did: did }\n }\n \n@@ -2051,13 +2054,9 @@ fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n }\n \n fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n-    let cx = super::ctxtkey.get().unwrap();\n-    match cx.maybe_typed {\n-        core::Typed(ref tcx) => {\n-            tcx.def_map.borrow().find(&id).map(|&def| register_def(&**cx, def))\n-        }\n-        core::NotTyped(_) => None\n-    }\n+    get_cx().tcx_opt().and_then(|tcx| {\n+        tcx.def_map.borrow().find(&id).map(|&def| register_def(&*get_cx(), def))\n+    })\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -2072,10 +2071,27 @@ impl Clean<Item> for doctree::Macro {\n             attrs: self.attrs.clean(),\n             source: self.where.clean(),\n             visibility: ast::Public.clean(),\n+            stability: self.stab.clean(),\n             def_id: ast_util::local_def(self.id),\n             inner: MacroItem(Macro {\n                 source: self.where.to_src(),\n             }),\n         }\n     }\n }\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct Stability {\n+    pub level: attr::StabilityLevel,\n+    pub text: String\n+}\n+\n+impl Clean<Stability> for attr::Stability {\n+    fn clean(&self) -> Stability {\n+        Stability {\n+            level: self.level,\n+            text: self.text.as_ref().map_or(\"\".to_string(),\n+                                            |interned| interned.get().to_string()),\n+        }\n+    }\n+}"}, {"sha": "245b2d162a77b02c76632dd77042628834119b65", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -10,7 +10,7 @@\n \n use rustc;\n use rustc::{driver, middle};\n-use rustc::middle::privacy;\n+use rustc::middle::{privacy, ty};\n use rustc::lint;\n \n use syntax::ast;\n@@ -26,6 +26,7 @@ use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n \n+/// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n pub enum MaybeTyped {\n     Typed(middle::ty::ctxt),\n     NotTyped(driver::session::Session)\n@@ -52,6 +53,18 @@ impl DocContext {\n             NotTyped(ref sess) => sess\n         }\n     }\n+\n+    pub fn tcx_opt<'a>(&'a self) -> Option<&'a ty::ctxt> {\n+        match self.maybe_typed {\n+            Typed(ref tcx) => Some(tcx),\n+            NotTyped(_) => None\n+        }\n+    }\n+\n+    pub fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n+        let tcx_opt = self.tcx_opt();\n+        tcx_opt.expect(\"tcx not present\")\n+    }\n }\n \n pub struct CrateAnalysis {"}, {"sha": "313f1c81c79e81ba8df55f0d5af5fb24b11cd01a", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -14,6 +14,7 @@\n use syntax;\n use syntax::codemap::Span;\n use syntax::ast;\n+use syntax::attr;\n use syntax::ast::{Ident, NodeId};\n \n use std::gc::Gc;\n@@ -32,6 +33,7 @@ pub struct Module {\n     pub statics: Vec<Static>,\n     pub traits: Vec<Trait>,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub impls: Vec<Impl>,\n     pub foreigns: Vec<ast::ForeignMod>,\n     pub view_items: Vec<ast::ViewItem>,\n@@ -45,6 +47,7 @@ impl Module {\n             name       : name,\n             id: 0,\n             vis: ast::Inherited,\n+            stab: None,\n             where_outer: syntax::codemap::DUMMY_SP,\n             where_inner: syntax::codemap::DUMMY_SP,\n             attrs      : Vec::new(),\n@@ -83,6 +86,7 @@ pub enum TypeBound {\n \n pub struct Struct {\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub id: NodeId,\n     pub struct_type: StructType,\n     pub name: Ident,\n@@ -94,6 +98,7 @@ pub struct Struct {\n \n pub struct Enum {\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub variants: Vec<Variant>,\n     pub generics: ast::Generics,\n     pub attrs: Vec<ast::Attribute>,\n@@ -108,6 +113,7 @@ pub struct Variant {\n     pub kind: ast::VariantKind,\n     pub id: ast::NodeId,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub where: Span,\n }\n \n@@ -117,6 +123,7 @@ pub struct Function {\n     pub id: NodeId,\n     pub name: Ident,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub fn_style: ast::FnStyle,\n     pub where: Span,\n     pub generics: ast::Generics,\n@@ -130,6 +137,7 @@ pub struct Typedef {\n     pub attrs: Vec<ast::Attribute>,\n     pub where: Span,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n }\n \n pub struct Static {\n@@ -139,6 +147,7 @@ pub struct Static {\n     pub name: Ident,\n     pub attrs: Vec<ast::Attribute>,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub id: ast::NodeId,\n     pub where: Span,\n }\n@@ -152,6 +161,7 @@ pub struct Trait {\n     pub id: ast::NodeId,\n     pub where: Span,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n }\n \n pub struct Impl {\n@@ -162,6 +172,7 @@ pub struct Impl {\n     pub attrs: Vec<ast::Attribute>,\n     pub where: Span,\n     pub vis: ast::Visibility,\n+    pub stab: Option<attr::Stability>,\n     pub id: ast::NodeId,\n }\n \n@@ -170,6 +181,7 @@ pub struct Macro {\n     pub id: ast::NodeId,\n     pub attrs: Vec<ast::Attribute>,\n     pub where: Span,\n+    pub stab: Option<attr::Stability>,\n }\n \n pub fn struct_type_from_def(sd: &ast::StructDef) -> StructType {"}, {"sha": "60853f450ab329dcb0a5d3ad5a5bedaf5d33a509", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -19,7 +19,7 @@ pub trait DocFolder {\n \n     /// don't override!\n     fn fold_item_recur(&mut self, item: Item) -> Option<Item> {\n-        let Item { attrs, name, source, visibility, def_id, inner } = item;\n+        let Item { attrs, name, source, visibility, def_id, inner, stability } = item;\n         let inner = inner;\n         let inner = match inner {\n             StructItem(mut i) => {\n@@ -83,7 +83,7 @@ pub trait DocFolder {\n         };\n \n         Some(Item { attrs: attrs, name: name, source: source, inner: inner,\n-                    visibility: visibility, def_id: def_id })\n+                    visibility: visibility, stability: stability, def_id: def_id })\n     }\n \n     fn fold_mod(&mut self, m: Module) -> Module {"}, {"sha": "9677b9004cdf1a12e015b56191ab3426747f1e1d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -37,6 +37,10 @@ pub struct FnStyleSpace(pub ast::FnStyle);\n pub struct Method<'a>(pub &'a clean::SelfTy, pub &'a clean::FnDecl);\n /// Similar to VisSpace, but used for mutability\n pub struct MutableSpace(pub clean::Mutability);\n+/// Wrapper struct for properly emitting the stability level.\n+pub struct Stability<'a>(pub &'a Option<clean::Stability>);\n+/// Wrapper struct for emitting the stability level concisely.\n+pub struct ConciseStability<'a>(pub &'a Option<clean::Stability>);\n \n impl VisSpace {\n     pub fn get(&self) -> Option<ast::Visibility> {\n@@ -596,3 +600,34 @@ impl fmt::Show for MutableSpace {\n         }\n     }\n }\n+\n+impl<'a> fmt::Show for Stability<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let Stability(stab) = *self;\n+        match *stab {\n+            Some(ref stability) => {\n+                write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n+                       lvl = stability.level.to_str(),\n+                       reason = stability.text)\n+            }\n+            None => Ok(())\n+        }\n+    }\n+}\n+\n+impl<'a> fmt::Show for ConciseStability<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let ConciseStability(stab) = *self;\n+        match *stab {\n+            Some(ref stability) => {\n+                write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n+                       lvl = stability.level.to_str(),\n+                       colon = if stability.text.len() > 0 { \": \" } else { \"\" },\n+                       reason = stability.text)\n+            }\n+            None => {\n+                write!(f, \"<a class='stability Unmarked' title='No stability level'></a>\")\n+            }\n+        }\n+    }\n+}"}, {"sha": "917eab4eeb9918e547fc2e42f105b85c83c2d516", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 60, "deletions": 63, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -46,14 +46,13 @@ use externalfiles::ExternalHtml;\n use serialize::json::ToJson;\n use syntax::ast;\n use syntax::ast_util;\n-use syntax::attr;\n-use syntax::parse::token::InternedString;\n use rustc::util::nodemap::NodeSet;\n \n use clean;\n use doctree;\n use fold::DocFolder;\n-use html::format::{VisSpace, Method, FnStyleSpace, MutableSpace};\n+use html::format::{VisSpace, Method, FnStyleSpace, MutableSpace, Stability};\n+use html::format::{ConciseStability};\n use html::highlight;\n use html::item_type::{ItemType, shortty};\n use html::item_type;\n@@ -114,6 +113,15 @@ pub struct Implementor {\n     generics: clean::Generics,\n     trait_: clean::Type,\n     for_: clean::Type,\n+    stability: Option<clean::Stability>,\n+}\n+\n+/// Metadata about implementations for a type.\n+#[deriving(Clone)]\n+pub struct Impl {\n+    impl_: clean::Impl,\n+    dox: Option<String>,\n+    stability: Option<clean::Stability>,\n }\n \n /// This cache is used to store information about the `clean::Crate` being\n@@ -137,7 +145,7 @@ pub struct Cache {\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: HashMap<ast::DefId, Vec<(clean::Impl, Option<String>)>>,\n+    pub impls: HashMap<ast::DefId, Vec<Impl>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n@@ -550,7 +558,8 @@ fn write_shared(cx: &Context,\n             // going on). If they're in different crates then the crate defining\n             // the trait will be interested in our implementation.\n             if imp.def_id.krate == did.krate { continue }\n-            try!(write!(&mut f, r#\"\"impl{} {} for {}\",\"#,\n+            try!(write!(&mut f, r#\"\"{}impl{} {} for {}\",\"#,\n+                        ConciseStability(&imp.stability),\n                         imp.generics, imp.trait_, imp.for_));\n         }\n         try!(writeln!(&mut f, r\"];\"));\n@@ -782,6 +791,7 @@ impl DocFolder for Cache {\n                             generics: i.generics.clone(),\n                             trait_: i.trait_.get_ref().clone(),\n                             for_: i.for_.clone(),\n+                            stability: item.stability.clone(),\n                         });\n                     }\n                     Some(..) | None => {}\n@@ -967,7 +977,11 @@ impl DocFolder for Cache {\n                                 let v = self.impls.find_or_insert_with(did, |_| {\n                                     Vec::new()\n                                 });\n-                                v.push((i, dox));\n+                                v.push(Impl {\n+                                    impl_: i,\n+                                    dox: dox,\n+                                    stability: item.stability.clone(),\n+                                });\n                             }\n                             None => {}\n                         }\n@@ -1248,19 +1262,8 @@ impl<'a> fmt::Show for Item<'a> {\n         try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n                     shortty(self.item), self.item.name.get_ref().as_slice()));\n \n-        // Write stability attributes\n-        match attr::find_stability_generic(self.item.attrs.iter()) {\n-            Some((ref stability, _)) => {\n-                try!(write!(fmt,\n-                       \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n-                       lvl = stability.level.to_str(),\n-                       reason = match stability.text {\n-                           Some(ref s) => (*s).clone(),\n-                           None => InternedString::new(\"\"),\n-                       }));\n-            }\n-            None => {}\n-        }\n+        // Write stability level\n+        try!(write!(fmt, \"{}\", Stability(&self.item.stability)));\n \n         // Write `src` tag\n         //\n@@ -1454,10 +1457,11 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n                 try!(write!(w, \"\n                     <tr>\n-                        <td><code>{}static {}{}: {}</code>{}</td>\n+                        <td>{}<code>{}static {}{}: {}</code>{}</td>\n                         <td class='docblock'>{}&nbsp;</td>\n                     </tr>\n                 \",\n+                ConciseStability(&myitem.stability),\n                 VisSpace(myitem.visibility),\n                 MutableSpace(s.mutability),\n                 *myitem.name.get_ref(),\n@@ -1492,7 +1496,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 if myitem.name.is_none() { continue }\n                 try!(write!(w, \"\n                     <tr>\n-                        <td><a class='{class}' href='{href}'\n+                        <td>{stab}<a class='{class}' href='{href}'\n                                title='{title}'>{}</a></td>\n                         <td class='docblock short'>{}</td>\n                     </tr>\n@@ -1501,7 +1505,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 Markdown(shorter(myitem.doc_value())),\n                 class = shortty(myitem),\n                 href = item_path(myitem),\n-                title = full_path(cx, myitem)));\n+                title = full_path(cx, myitem),\n+                stab = ConciseStability(&myitem.stability)));\n             }\n         }\n     }\n@@ -1565,9 +1570,10 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     try!(document(w, it));\n \n     fn meth(w: &mut fmt::Formatter, m: &clean::TraitMethod) -> fmt::Result {\n-        try!(write!(w, \"<h3 id='{}.{}' class='method'><code>\",\n-                      shortty(m.item()),\n-                      *m.item().name.get_ref()));\n+        try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n+                    shortty(m.item()),\n+                    *m.item().name.get_ref(),\n+                    ConciseStability(&m.item().stability)));\n         try!(render_method(w, m.item()));\n         try!(write!(w, \"</code></h3>\"));\n         try!(document(w, m.item()));\n@@ -1604,7 +1610,8 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     match cache.implementors.find(&it.def_id) {\n         Some(implementors) => {\n             for i in implementors.iter() {\n-                try!(writeln!(w, \"<li><code>impl{} {} for {}</code></li>\",\n+                try!(writeln!(w, \"<li>{}<code>impl{} {} for {}</code></li>\",\n+                              ConciseStability(&i.stability),\n                               i.generics, i.trait_, i.for_));\n             }\n         }\n@@ -1677,7 +1684,8 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n             for field in fields {\n                 try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n-                                  <code>{name}</code></td><td>\",\n+                                  {stab}<code>{name}</code></td><td>\",\n+                              stab = ConciseStability(&field.stability),\n                               name = field.name.get_ref().as_slice()));\n                 try!(document(w, field));\n                 try!(write!(w, \"</td></tr>\"));\n@@ -1743,7 +1751,8 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     if e.variants.len() > 0 {\n         try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in e.variants.iter() {\n-            try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n+            try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n+                          stab = ConciseStability(&variant.stability),\n                           name = variant.name.get_ref().as_slice()));\n             try!(document(w, variant));\n             match variant.inner {\n@@ -1853,39 +1862,25 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     match cache_key.get().unwrap().impls.find(&it.def_id) {\n         Some(v) => {\n-            let mut non_trait = v.iter().filter(|p| {\n-                p.ref0().trait_.is_none()\n-            });\n-            let non_trait = non_trait.collect::<Vec<&(clean::Impl, Option<String>)>>();\n-            let mut traits = v.iter().filter(|p| {\n-                p.ref0().trait_.is_some()\n-            });\n-            let traits = traits.collect::<Vec<&(clean::Impl, Option<String>)>>();\n-\n+            let (non_trait, traits) = v.partitioned(|i| i.impl_.trait_.is_none());\n             if non_trait.len() > 0 {\n                 try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n-                for &(ref i, ref dox) in non_trait.move_iter() {\n-                    try!(render_impl(w, i, dox));\n+                for i in non_trait.iter() {\n+                    try!(render_impl(w, i));\n                 }\n             }\n             if traits.len() > 0 {\n                 try!(write!(w, \"<h2 id='implementations'>Trait \\\n                                   Implementations</h2>\"));\n-                let mut any_derived = false;\n-                for & &(ref i, ref dox) in traits.iter() {\n-                    if !i.derived {\n-                        try!(render_impl(w, i, dox));\n-                    } else {\n-                        any_derived = true;\n-                    }\n+                let (derived, manual) = traits.partition(|i| i.impl_.derived);\n+                for i in manual.iter() {\n+                    try!(render_impl(w, i));\n                 }\n-                if any_derived {\n+                if derived.len() > 0 {\n                     try!(write!(w, \"<h3 id='derived_implementations'>Derived Implementations \\\n                                 </h3>\"));\n-                    for &(ref i, ref dox) in traits.move_iter() {\n-                        if i.derived {\n-                            try!(render_impl(w, i, dox));\n-                        }\n+                    for i in derived.iter() {\n+                        try!(render_impl(w, i));\n                     }\n                 }\n             }\n@@ -1895,15 +1890,16 @@ fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n     Ok(())\n }\n \n-fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n-               dox: &Option<String>) -> fmt::Result {\n-    try!(write!(w, \"<h3 class='impl'><code>impl{} \", i.generics));\n-    match i.trait_ {\n+fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n+    try!(write!(w, \"<h3 class='impl'>{}<code>impl{} \",\n+                ConciseStability(&i.stability),\n+                i.impl_.generics));\n+    match i.impl_.trait_ {\n         Some(ref ty) => try!(write!(w, \"{} for \", *ty)),\n         None => {}\n     }\n-    try!(write!(w, \"{}</code></h3>\", i.for_));\n-    match *dox {\n+    try!(write!(w, \"{}</code></h3>\", i.impl_.for_));\n+    match i.dox {\n         Some(ref dox) => {\n             try!(write!(w, \"<div class='docblock'>{}</div>\",\n                           Markdown(dox.as_slice())));\n@@ -1913,8 +1909,9 @@ fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n \n     fn docmeth(w: &mut fmt::Formatter, item: &clean::Item,\n                dox: bool) -> fmt::Result {\n-        try!(write!(w, \"<h4 id='method.{}' class='method'><code>\",\n-                      *item.name.get_ref()));\n+        try!(write!(w, \"<h4 id='method.{}' class='method'>{}<code>\",\n+                    *item.name.get_ref(),\n+                    ConciseStability(&item.stability)));\n         try!(render_method(w, item));\n         try!(write!(w, \"</code></h4>\\n\"));\n         match item.doc_value() {\n@@ -1926,8 +1923,8 @@ fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n         }\n     }\n \n-    try!(write!(w, \"<div class='methods'>\"));\n-    for meth in i.methods.iter() {\n+    try!(write!(w, \"<div class='impl-methods'>\"));\n+    for meth in i.impl_.methods.iter() {\n         try!(docmeth(w, meth, true));\n     }\n \n@@ -1948,11 +1945,11 @@ fn render_impl(w: &mut fmt::Formatter, i: &clean::Impl,\n \n     // If we've implemented a trait, then also emit documentation for all\n     // default methods which weren't overridden in the implementation block.\n-    match i.trait_ {\n+    match i.impl_.trait_ {\n         Some(clean::ResolvedPath { did, .. }) => {\n             try!({\n                 match cache_key.get().unwrap().traits.find(&did) {\n-                    Some(t) => try!(render_default_methods(w, t, i)),\n+                    Some(t) => try!(render_default_methods(w, t, &i.impl_)),\n                     None => {}\n                 }\n                 Ok(())"}, {"sha": "97048229ac4c1842180a90c6ace19b7c5dff06a0", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -258,8 +258,9 @@ nav.sub {\n .content .multi-column li { width: 100%; display: inline-block; }\n \n .content .method { font-size: 1em; }\n-.content .methods { margin-left: 20px; }\n-.content .methods .docblock { margin-left: 20px; }\n+.content .methods .docblock { margin-left: 40px; }\n+\n+.content .impl-methods .docblock { margin-left: 40px; }\n \n nav {\n     border-bottom: 1px solid #e0e0e0;\n@@ -372,20 +373,29 @@ p a:hover { text-decoration: underline; }\n }\n \n .stability {\n-    border-left: 6px solid #000;\n+    border-left: 6px solid;\n+    padding: 3px 6px;\n     border-radius: 3px;\n-    font-weight: 400;\n-    padding: 4px 10px;\n+}\n+\n+h1 .stability {\n     text-transform: lowercase;\n+    font-weight: 400;\n     margin-left: 14px;\n+    padding: 4px 10px;\n+}\n+\n+.impl-methods .stability {\n+    margin-right: 20px;\n }\n \n-.stability.Deprecated { border-color: #D60027; color: #880017; }\n-.stability.Experimental { border-color: #EC5315; color: #a53c0e; }\n-.stability.Unstable { border-color: #FFD700; color: #b39800; }\n-.stability.Stable { border-color: #AEC516; color: #7c8b10; }\n+.stability.Deprecated { border-color: #A071A8; color: #82478C; }\n+.stability.Experimental { border-color: #D46D6A; color: #AA3C39; }\n+.stability.Unstable { border-color: #D4B16A; color: #AA8439; }\n+.stability.Stable { border-color: #54A759; color: #2D8632; }\n .stability.Frozen { border-color: #009431; color: #007726; }\n .stability.Locked { border-color: #0084B6; color: #00668c; }\n+.stability.Unmarked { border-color: #FFFFFF; }\n \n :target { background: #FDFFD3; }\n "}, {"sha": "b7ef0956a7c7640a57593b0fbf133405d1b570cc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/721b4cb5c544328d8991216afd7445648a3ce6c6/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=721b4cb5c544328d8991216afd7445648a3ce6c6", "patch": "@@ -15,9 +15,12 @@ use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_map;\n+use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n \n+use rustc::middle::stability;\n+\n use std::gc::{Gc, GC};\n \n use core;\n@@ -41,6 +44,14 @@ impl<'a> RustdocVisitor<'a> {\n         }\n     }\n \n+    fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n+        let tcx = match self.cx.maybe_typed {\n+            core::Typed(ref tcx) => tcx,\n+            core::NotTyped(_) => return None\n+        };\n+        stability::lookup(tcx, ast_util::local_def(id))\n+    }\n+\n     pub fn visit(&mut self, krate: &ast::Crate) {\n         self.attrs = krate.attrs.iter().map(|x| (*x).clone()).collect();\n \n@@ -65,6 +76,7 @@ impl<'a> RustdocVisitor<'a> {\n             struct_type: struct_type,\n             name: item.ident,\n             vis: item.vis,\n+            stab: self.stability(item.id),\n             attrs: item.attrs.iter().map(|x| *x).collect(),\n             generics: generics.clone(),\n             fields: sd.fields.iter().map(|x| (*x).clone()).collect(),\n@@ -81,6 +93,7 @@ impl<'a> RustdocVisitor<'a> {\n                 name: x.node.name,\n                 attrs: x.node.attrs.iter().map(|x| *x).collect(),\n                 vis: x.node.vis,\n+                stab: self.stability(x.node.id),\n                 id: x.node.id,\n                 kind: x.node.kind.clone(),\n                 where: x.span,\n@@ -90,6 +103,7 @@ impl<'a> RustdocVisitor<'a> {\n             name: it.ident,\n             variants: vars,\n             vis: it.vis,\n+            stab: self.stability(it.id),\n             generics: params.clone(),\n             attrs: it.attrs.iter().map(|x| *x).collect(),\n             id: it.id,\n@@ -104,6 +118,7 @@ impl<'a> RustdocVisitor<'a> {\n         Function {\n             id: item.id,\n             vis: item.vis,\n+            stab: self.stability(item.id),\n             attrs: item.attrs.iter().map(|x| *x).collect(),\n             decl: fd.clone(),\n             name: item.ident,\n@@ -125,6 +140,7 @@ impl<'a> RustdocVisitor<'a> {\n         om.where_inner = m.inner;\n         om.attrs = attrs;\n         om.vis = vis;\n+        om.stab = self.stability(id);\n         om.id = id;\n         for i in m.items.iter() {\n             self.visit_item(&**i, &mut om);\n@@ -258,6 +274,7 @@ impl<'a> RustdocVisitor<'a> {\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     where: item.span,\n                     vis: item.vis,\n+                    stab: self.stability(item.id),\n                 };\n                 om.typedefs.push(t);\n             },\n@@ -271,6 +288,7 @@ impl<'a> RustdocVisitor<'a> {\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     where: item.span,\n                     vis: item.vis,\n+                    stab: self.stability(item.id),\n                 };\n                 om.statics.push(s);\n             },\n@@ -284,6 +302,7 @@ impl<'a> RustdocVisitor<'a> {\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     where: item.span,\n                     vis: item.vis,\n+                    stab: self.stability(item.id),\n                 };\n                 om.traits.push(t);\n             },\n@@ -297,6 +316,7 @@ impl<'a> RustdocVisitor<'a> {\n                     id: item.id,\n                     where: item.span,\n                     vis: item.vis,\n+                    stab: self.stability(item.id),\n                 };\n                 om.impls.push(i);\n             },\n@@ -309,6 +329,7 @@ impl<'a> RustdocVisitor<'a> {\n                     attrs: item.attrs.iter().map(|x| *x).collect(),\n                     name: item.ident,\n                     where: item.span,\n+                    stab: self.stability(item.id),\n                 })\n             }\n         }"}]}