{"sha": "d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0Y2YyODhiMzg1YjljNThjZmEwZDRjOTdiM2I1NDhiYzIxYjQ5MjM=", "commit": {"author": {"name": "John Quigley", "email": "jmquigs@gmail.com", "date": "2015-11-20T05:22:52Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-22T16:22:06Z"}, "message": "Add block_in_if lint, #434", "tree": {"sha": "1c78559d0dd0ecd338f8f48eedebd8ea9affa4e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c78559d0dd0ecd338f8f48eedebd8ea9affa4e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "html_url": "https://github.com/rust-lang/rust/commit/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923/comments", "author": {"login": "jmquigs", "id": 669882, "node_id": "MDQ6VXNlcjY2OTg4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/669882?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jmquigs", "html_url": "https://github.com/jmquigs", "followers_url": "https://api.github.com/users/jmquigs/followers", "following_url": "https://api.github.com/users/jmquigs/following{/other_user}", "gists_url": "https://api.github.com/users/jmquigs/gists{/gist_id}", "starred_url": "https://api.github.com/users/jmquigs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jmquigs/subscriptions", "organizations_url": "https://api.github.com/users/jmquigs/orgs", "repos_url": "https://api.github.com/users/jmquigs/repos", "events_url": "https://api.github.com/users/jmquigs/events{/privacy}", "received_events_url": "https://api.github.com/users/jmquigs/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b41a4515e1aa71702550a933e801694efcc1f13", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b41a4515e1aa71702550a933e801694efcc1f13", "html_url": "https://github.com/rust-lang/rust/commit/1b41a4515e1aa71702550a933e801694efcc1f13"}], "stats": {"total": 317, "additions": 239, "deletions": 78}, "files": [{"sha": "696836f417d2f303498c3b065538cc702b3ce8b0", "filename": "README.md", "status": "modified", "additions": 80, "deletions": 78, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "patch": "@@ -6,84 +6,86 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 74 lints included in this crate:\n-\n-name                                                                                                   | default | meaning\n--------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n-[approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                     | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n-[bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                           | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n-[box_vec](https://github.com/Manishearth/rust-clippy/wiki#box_vec)                                     | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n-[cast_possible_truncation](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation)   | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n-[cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)               | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n-[cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)             | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n-[cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                       | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n-[cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                     | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n-[cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                 | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n-[collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                       | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n-[empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                               | warn    | empty `loop {}` detected\n-[eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                         | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n-[explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)         | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n-[explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)               | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n-[float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                 | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n-[identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                             | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n-[ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)           | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n-[inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                         | warn    | `#[inline(always)]` is a bad idea in most cases\n-[iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                       | warn    | for-looping over `_.next()` which is probably not intended\n-[len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)           | warn    | traits and impls that have `.len()` but not `.is_empty()`\n-[len_zero](https://github.com/Manishearth/rust-clippy/wiki#len_zero)                                   | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n-[let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                       | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n-[let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                       | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n-[linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                               | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n-[map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                 | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n-[match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                               | warn    | a match on boolean expression; recommends `if..else` block instead\n-[match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                       | warn    | a match has all arms prefixed with `&`; the match expression can be dereferenced instead\n-[min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                     | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n-[modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                               | warn    | taking a number modulo 1, which always returns 0\n-[mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                     | allow   | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n-[mutex_atomic](https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic)                           | warn    | using a Mutex where an atomic value could be used instead\n-[mutex_integer](https://github.com/Manishearth/rust-clippy/wiki#mutex_integer)                         | allow   | using a Mutex for an integer type\n-[needless_bool](https://github.com/Manishearth/rust-clippy/wiki#needless_bool)                         | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n-[needless_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#needless_lifetimes)               | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n-[needless_range_loop](https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop)             | warn    | for-looping over a range of indices where an iterator over items would do\n-[needless_return](https://github.com/Manishearth/rust-clippy/wiki#needless_return)                     | warn    | using a return statement like `return expr;` where an expression would suffice\n-[needless_update](https://github.com/Manishearth/rust-clippy/wiki#needless_update)                     | warn    | using `{ ..base }` when there are no missing fields\n-[no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                 | warn    | statements with no effect\n-[non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                 | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n-[nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)   | warn    | nonsensical combination of options for opening a file\n-[option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)               | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n-[precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                               | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught\n-[ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                     | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n-[range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)               | warn    | using Range::step_by(0), which produces an infinite iterator\n-[range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)               | warn    | zipping iterator with a range when enumerate() would do\n-[redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                 | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n-[redundant_pattern](https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern)                 | warn    | using `name @ _` in a pattern\n-[result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)               | allow   | using `Result.unwrap()`, which might be better handled\n-[reverse_range_loop](https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop)               | warn    | Iterating over an empty range, such as `10..0` or `5..5`\n-[shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                           | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n-[shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                             | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n-[shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                   | allow   | The name is re-bound without even using the original value\n-[should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)       | warn    | defining a method that should be implementing a std trait\n-[single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                           | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n-[str_to_string](https://github.com/Manishearth/rust-clippy/wiki#str_to_string)                         | warn    | using `to_string()` on a str, which should be `to_owned()`\n-[string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                               | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n-[string_add_assign](https://github.com/Manishearth/rust-clippy/wiki#string_add_assign)                 | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n-[string_to_string](https://github.com/Manishearth/rust-clippy/wiki#string_to_string)                   | warn    | calling `String.to_string()` which is a no-op\n-[temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)           | warn    | assignments to temporaries\n-[toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                   | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n-[type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                     | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n-[unicode_not_nfc](https://github.com/Manishearth/rust-clippy/wiki#unicode_not_nfc)                     | allow   | using a unicode literal not in NFC normal form (see http://www.unicode.org/reports/tr15/ for further information)\n-[unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                   | warn    | comparing unit values (which is always `true` or `false`, respectively)\n-[unnecessary_mut_passed](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_mut_passed)       | warn    | an argument is passed as a mutable reference although the function/method only demands an immutable reference\n-[unstable_as_mut_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_mut_slice)         | warn    | as_mut_slice is not stable and can be replaced by &mut v[..]see https://github.com/rust-lang/rust/issues/27729\n-[unstable_as_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_slice)                 | warn    | as_slice is not stable and can be replaced by & v[..]see https://github.com/rust-lang/rust/issues/27729\n-[unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                       | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n-[useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                 | warn    | transmutes that have the same to and from types\n-[while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                       | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n-[while_let_on_iterator](https://github.com/Manishearth/rust-clippy/wiki#while_let_on_iterator)         | warn    | using a while-let loop instead of a for loop on an iterator\n-[wrong_pub_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_pub_self_convention) | allow   | defining a public method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n-[wrong_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention)         | warn    | defining a method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n-[zero_divided_by_zero](https://github.com/Manishearth/rust-clippy/wiki#zero_divided_by_zero)           | warn    | usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\n-[zero_width_space](https://github.com/Manishearth/rust-clippy/wiki#zero_width_space)                   | deny    | using a zero-width space in a string literal, which is confusing\n+There are 76 lints included in this crate:\n+\n+name                                                                                                     | default | meaning\n+---------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n+[approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                       | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n+[bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                             | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n+[block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr) | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\n+[block_in_if_condition_stmt](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_stmt) | warn    | avoid complex blocks in conditions, instead move the block higher and bind it with 'let'; e.g: `if { let x = true; x } ...`\n+[box_vec](https://github.com/Manishearth/rust-clippy/wiki#box_vec)                                       | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n+[cast_possible_truncation](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_truncation)     | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n+[cast_possible_wrap](https://github.com/Manishearth/rust-clippy/wiki#cast_possible_wrap)                 | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n+[cast_precision_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_precision_loss)               | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n+[cast_sign_loss](https://github.com/Manishearth/rust-clippy/wiki#cast_sign_loss)                         | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n+[cmp_nan](https://github.com/Manishearth/rust-clippy/wiki#cmp_nan)                                       | deny    | comparisons to NAN (which will always return false, which is probably not intended)\n+[cmp_owned](https://github.com/Manishearth/rust-clippy/wiki#cmp_owned)                                   | warn    | creating owned instances for comparing with others, e.g. `x == \"foo\".to_string()`\n+[collapsible_if](https://github.com/Manishearth/rust-clippy/wiki#collapsible_if)                         | warn    | two nested `if`-expressions can be collapsed into one, e.g. `if x { if y { foo() } }` can be written as `if x && y { foo() }`\n+[empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                 | warn    | empty `loop {}` detected\n+[eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                           | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n+[explicit_counter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_counter_loop)           | warn    | for-looping with an explicit counter when `_.enumerate()` would do\n+[explicit_iter_loop](https://github.com/Manishearth/rust-clippy/wiki#explicit_iter_loop)                 | warn    | for-looping over `_.iter()` or `_.iter_mut()` when `&_` or `&mut _` would do\n+[float_cmp](https://github.com/Manishearth/rust-clippy/wiki#float_cmp)                                   | warn    | using `==` or `!=` on float values (as floating-point operations usually involve rounding errors, it is always better to check for approximate equality within small bounds)\n+[identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                               | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n+[ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)             | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n+[inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                           | warn    | `#[inline(always)]` is a bad idea in most cases\n+[iter_next_loop](https://github.com/Manishearth/rust-clippy/wiki#iter_next_loop)                         | warn    | for-looping over `_.next()` which is probably not intended\n+[len_without_is_empty](https://github.com/Manishearth/rust-clippy/wiki#len_without_is_empty)             | warn    | traits and impls that have `.len()` but not `.is_empty()`\n+[len_zero](https://github.com/Manishearth/rust-clippy/wiki#len_zero)                                     | warn    | checking `.len() == 0` or `.len() > 0` (or similar) when `.is_empty()` could be used instead\n+[let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                         | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n+[let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                         | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n+[linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                                 | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n+[map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                   | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n+[match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                 | warn    | a match on boolean expression; recommends `if..else` block instead\n+[match_ref_pats](https://github.com/Manishearth/rust-clippy/wiki#match_ref_pats)                         | warn    | a match has all arms prefixed with `&`; the match expression can be dereferenced instead\n+[min_max](https://github.com/Manishearth/rust-clippy/wiki#min_max)                                       | warn    | `min(_, max(_, _))` (or vice versa) with bounds clamping the result to a constant\n+[modulo_one](https://github.com/Manishearth/rust-clippy/wiki#modulo_one)                                 | warn    | taking a number modulo 1, which always returns 0\n+[mut_mut](https://github.com/Manishearth/rust-clippy/wiki#mut_mut)                                       | allow   | usage of double-mut refs, e.g. `&mut &mut ...` (either copy'n'paste error, or shows a fundamental misunderstanding of references)\n+[mutex_atomic](https://github.com/Manishearth/rust-clippy/wiki#mutex_atomic)                             | warn    | using a Mutex where an atomic value could be used instead\n+[mutex_integer](https://github.com/Manishearth/rust-clippy/wiki#mutex_integer)                           | allow   | using a Mutex for an integer type\n+[needless_bool](https://github.com/Manishearth/rust-clippy/wiki#needless_bool)                           | warn    | if-statements with plain booleans in the then- and else-clause, e.g. `if p { true } else { false }`\n+[needless_lifetimes](https://github.com/Manishearth/rust-clippy/wiki#needless_lifetimes)                 | warn    | using explicit lifetimes for references in function arguments when elision rules would allow omitting them\n+[needless_range_loop](https://github.com/Manishearth/rust-clippy/wiki#needless_range_loop)               | warn    | for-looping over a range of indices where an iterator over items would do\n+[needless_return](https://github.com/Manishearth/rust-clippy/wiki#needless_return)                       | warn    | using a return statement like `return expr;` where an expression would suffice\n+[needless_update](https://github.com/Manishearth/rust-clippy/wiki#needless_update)                       | warn    | using `{ ..base }` when there are no missing fields\n+[no_effect](https://github.com/Manishearth/rust-clippy/wiki#no_effect)                                   | warn    | statements with no effect\n+[non_ascii_literal](https://github.com/Manishearth/rust-clippy/wiki#non_ascii_literal)                   | allow   | using any literal non-ASCII chars in a string literal; suggests using the \\\\u escape instead\n+[nonsensical_open_options](https://github.com/Manishearth/rust-clippy/wiki#nonsensical_open_options)     | warn    | nonsensical combination of options for opening a file\n+[option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                 | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n+[precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                 | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught\n+[ptr_arg](https://github.com/Manishearth/rust-clippy/wiki#ptr_arg)                                       | warn    | fn arguments of the type `&Vec<...>` or `&String`, suggesting to use `&[...]` or `&str` instead, respectively\n+[range_step_by_zero](https://github.com/Manishearth/rust-clippy/wiki#range_step_by_zero)                 | warn    | using Range::step_by(0), which produces an infinite iterator\n+[range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)                 | warn    | zipping iterator with a range when enumerate() would do\n+[redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                   | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n+[redundant_pattern](https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern)                   | warn    | using `name @ _` in a pattern\n+[result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)                 | allow   | using `Result.unwrap()`, which might be better handled\n+[reverse_range_loop](https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop)                 | warn    | Iterating over an empty range, such as `10..0` or `5..5`\n+[shadow_reuse](https://github.com/Manishearth/rust-clippy/wiki#shadow_reuse)                             | allow   | rebinding a name to an expression that re-uses the original value, e.g. `let x = x + 1`\n+[shadow_same](https://github.com/Manishearth/rust-clippy/wiki#shadow_same)                               | allow   | rebinding a name to itself, e.g. `let mut x = &mut x`\n+[shadow_unrelated](https://github.com/Manishearth/rust-clippy/wiki#shadow_unrelated)                     | allow   | The name is re-bound without even using the original value\n+[should_implement_trait](https://github.com/Manishearth/rust-clippy/wiki#should_implement_trait)         | warn    | defining a method that should be implementing a std trait\n+[single_match](https://github.com/Manishearth/rust-clippy/wiki#single_match)                             | warn    | a match statement with a single nontrivial arm (i.e, where the other arm is `_ => {}`) is used; recommends `if let` instead\n+[str_to_string](https://github.com/Manishearth/rust-clippy/wiki#str_to_string)                           | warn    | using `to_string()` on a str, which should be `to_owned()`\n+[string_add](https://github.com/Manishearth/rust-clippy/wiki#string_add)                                 | allow   | using `x + ..` where x is a `String`; suggests using `push_str()` instead\n+[string_add_assign](https://github.com/Manishearth/rust-clippy/wiki#string_add_assign)                   | allow   | using `x = x + ..` where x is a `String`; suggests using `push_str()` instead\n+[string_to_string](https://github.com/Manishearth/rust-clippy/wiki#string_to_string)                     | warn    | calling `String.to_string()` which is a no-op\n+[temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)             | warn    | assignments to temporaries\n+[toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                     | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n+[type_complexity](https://github.com/Manishearth/rust-clippy/wiki#type_complexity)                       | warn    | usage of very complex types; recommends factoring out parts into `type` definitions\n+[unicode_not_nfc](https://github.com/Manishearth/rust-clippy/wiki#unicode_not_nfc)                       | allow   | using a unicode literal not in NFC normal form (see http://www.unicode.org/reports/tr15/ for further information)\n+[unit_cmp](https://github.com/Manishearth/rust-clippy/wiki#unit_cmp)                                     | warn    | comparing unit values (which is always `true` or `false`, respectively)\n+[unnecessary_mut_passed](https://github.com/Manishearth/rust-clippy/wiki#unnecessary_mut_passed)         | warn    | an argument is passed as a mutable reference although the function/method only demands an immutable reference\n+[unstable_as_mut_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_mut_slice)           | warn    | as_mut_slice is not stable and can be replaced by &mut v[..]see https://github.com/rust-lang/rust/issues/27729\n+[unstable_as_slice](https://github.com/Manishearth/rust-clippy/wiki#unstable_as_slice)                   | warn    | as_slice is not stable and can be replaced by & v[..]see https://github.com/rust-lang/rust/issues/27729\n+[unused_collect](https://github.com/Manishearth/rust-clippy/wiki#unused_collect)                         | warn    | `collect()`ing an iterator without using the result; this is usually better written as a for loop\n+[useless_transmute](https://github.com/Manishearth/rust-clippy/wiki#useless_transmute)                   | warn    | transmutes that have the same to and from types\n+[while_let_loop](https://github.com/Manishearth/rust-clippy/wiki#while_let_loop)                         | warn    | `loop { if let { ... } else break }` can be written as a `while let` loop\n+[while_let_on_iterator](https://github.com/Manishearth/rust-clippy/wiki#while_let_on_iterator)           | warn    | using a while-let loop instead of a for loop on an iterator\n+[wrong_pub_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_pub_self_convention)   | allow   | defining a public method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n+[wrong_self_convention](https://github.com/Manishearth/rust-clippy/wiki#wrong_self_convention)           | warn    | defining a method named with an established prefix (like \"into_\") that takes `self` with the wrong convention\n+[zero_divided_by_zero](https://github.com/Manishearth/rust-clippy/wiki#zero_divided_by_zero)             | warn    | usage of `0.0 / 0.0` to obtain NaN instead of std::f32::NaN or std::f64::NaN\n+[zero_width_space](https://github.com/Manishearth/rust-clippy/wiki#zero_width_space)                     | deny    | using a zero-width space in a string literal, which is confusing\n \n More to come, please [file an issue](https://github.com/Manishearth/rust-clippy/issues) if you have ideas!\n "}, {"sha": "39196ed175f0c62af019f38ca5a82cdc7925dfb4", "filename": "src/block_in_if_condition.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923/src%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923/src%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fblock_in_if_condition.rs?ref=d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "patch": "@@ -0,0 +1,91 @@\n+use rustc_front::hir::*;\n+use rustc::lint::{LateLintPass, LateContext, LintArray, LintPass};\n+use rustc_front::intravisit::{Visitor, walk_expr};\n+use utils::*;\n+\n+declare_lint! {\n+    pub BLOCK_IN_IF_CONDITION_EXPR, Warn,\n+    \"braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\"\n+}\n+\n+declare_lint! {\n+    pub BLOCK_IN_IF_CONDITION_STMT, Warn,\n+    \"avoid complex blocks in conditions, instead move the block higher and bind it \\\n+    with 'let'; e.g: `if { let x = true; x } ...`\"\n+}\n+\n+#[derive(Copy,Clone)]\n+pub struct BlockInIfCondition;\n+\n+impl LintPass for BlockInIfCondition {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(BLOCK_IN_IF_CONDITION_EXPR, BLOCK_IN_IF_CONDITION_STMT)\n+    }\n+}\n+\n+struct ExVisitor<'v> {\n+    found_block: Option<&'v Expr>\n+}\n+\n+impl<'v> Visitor<'v> for ExVisitor<'v> {\n+    fn visit_expr(&mut self, expr: &'v Expr) {\n+        if let ExprClosure(_, _, ref block) = expr.node {\n+            let complex = {\n+                if !block.stmts.is_empty() {\n+                    true\n+                } else {\n+                    if let Some(ref ex) = block.expr {\n+                        match ex.node {\n+                            ExprBlock(_) => true,\n+                            _ => false\n+                        }\n+                    } else {\n+                        false\n+                    }\n+                }\n+            };\n+            if complex {\n+                self.found_block = Some(& expr);\n+                return;\n+            }\n+        }\n+        walk_expr(self, expr);\n+    }\n+}\n+\n+const BRACED_EXPR_MESSAGE:&'static str = \"omit braces around single expression condition\";\n+const COMPLEX_BLOCK_MESSAGE:&'static str = \"in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\";\n+\n+impl LateLintPass for BlockInIfCondition {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if let ExprIf(ref check, ref then, _) = expr.node {\n+            if let ExprBlock(ref block) = check.node {\n+                if block.stmts.is_empty() {\n+                    if let Some(ref ex) = block.expr {\n+                        // don't dig into the expression here, just suggest that they remove\n+                        // the block\n+\n+                        span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_EXPR, check.span,\n+                            BRACED_EXPR_MESSAGE,\n+                            &format!(\"try\\nif {} {} ... \", snippet_block(cx, ex.span, \"..\"),\n+                            snippet_block(cx, then.span, \"..\")));\n+                    }\n+                } else {\n+                    // move block higher\n+                    span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_STMT, check.span,\n+                        COMPLEX_BLOCK_MESSAGE,\n+                        &format!(\"try\\nlet res = {};\\nif res {} ... \",\n+                        snippet_block(cx, block.span, \"..\"),\n+                        snippet_block(cx, then.span, \"..\")));\n+                }\n+            } else {\n+                let mut visitor = ExVisitor { found_block: None };\n+                walk_expr(&mut visitor, check);\n+                if let Some(ref block) = visitor.found_block {\n+                    span_help_and_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span,\n+                        COMPLEX_BLOCK_MESSAGE, \"\");\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "9507b1d86f507746d86be4b1ba34886bb6888274", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "patch": "@@ -37,6 +37,7 @@ pub mod mut_reference;\n pub mod len_zero;\n pub mod attrs;\n pub mod collapsible_if;\n+pub mod block_in_if_condition;\n pub mod unicode;\n pub mod shadow;\n pub mod strings;\n@@ -81,6 +82,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box misc::CmpOwned);\n     reg.register_late_lint_pass(box attrs::AttrPass);\n     reg.register_late_lint_pass(box collapsible_if::CollapsibleIf);\n+    reg.register_late_lint_pass(box block_in_if_condition::BlockInIfCondition);\n     reg.register_late_lint_pass(box misc::ModuloOne);\n     reg.register_late_lint_pass(box unicode::Unicode);\n     reg.register_late_lint_pass(box strings::StringAdd);\n@@ -131,6 +133,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         attrs::INLINE_ALWAYS,\n         bit_mask::BAD_BIT_MASK,\n         bit_mask::INEFFECTIVE_BIT_MASK,\n+        block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n+        block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n         eq_op::EQ_OP,\n         eta_reduction::REDUNDANT_CLOSURE,"}, {"sha": "c075d48297e4623acb150da924ba80146527537c", "filename": "tests/compile-fail/block_in_if_condition.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4cf288b385b9c58cfa0d4c97b3b548bc21b4923/tests%2Fcompile-fail%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fblock_in_if_condition.rs?ref=d4cf288b385b9c58cfa0d4c97b3b548bc21b4923", "patch": "@@ -0,0 +1,64 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![deny(block_in_if_condition_expr)]\n+#![deny(block_in_if_condition_stmt)]\n+#![allow(unused)]\n+\n+fn condition_has_block() -> i32 {\n+\n+    if { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n+        let x = 3;\n+        x == 3\n+    } {\n+        6\n+    } else {\n+        10\n+    }\n+}\n+\n+fn condition_has_block_with_single_expression() -> i32 {\n+    if { true } { //~ERROR omit braces around single expression condition\n+        6\n+    } else {\n+        10\n+    }\n+}\n+\n+fn predicate<F: FnOnce(T) -> bool, T>(pfn: F, val:T) -> bool {\n+    pfn(val)\n+}\n+\n+fn pred_test() {\n+    let v = 3;\n+    let sky = \"blue\";\n+    // this is a sneaky case, where the block isn't directly in the condition, but is actually\n+    // inside a closure that the condition is using.  same principle applies.  add some extra\n+    // expressions to make sure linter isn't confused by them.\n+    if v == 3 && sky == \"blue\" && predicate(|x| { let target = 3; x == target }, v) { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n+\n+    }\n+\n+    if predicate(|x| { let target = 3; x == target }, v) { //~ERROR in an 'if' condition, avoid complex blocks or closures with blocks; instead, move the block or closure higher and bind it with a 'let'\n+\n+    }\n+\n+}\n+\n+fn condition_is_normal() -> i32 {\n+    let x = 3;\n+    if true && x == 3 {\n+        6\n+    } else {\n+        10\n+    }\n+}\n+\n+fn closure_without_block() {\n+    if predicate(|x| x == 3, 6) {\n+\n+    }\n+}\n+\n+fn main() {\n+}"}]}